// all
//
// Based on this Sway which is designed to have many blocks and branches in main() before we inline
// more blocks and branches.  In particular, we need to be sure the `phi` instructions refer to the
// correct predecessor blocks.
//
//
// script;
//
// fn not(v: bool) -> bool {
//     if v { false } else { true }
// }
//
// fn main() -> bool {
//     not(true) || not(false)
// }

// regex: ID=[[:alpha:]0-9_]+
// regex: LABEL=[[:alpha:]0-9_]+\(.*\):
// regex: VAR=v\d+v\d+

script {
    fn not(v: bool) -> bool {
        entry(v: bool):
        cbr v, block0(), block1()

        block0():
        v0 = const bool false
        br block2(v0)

        block1():
        v1 = const bool true
        br block2(v1)

        block2(v2: bool):
        ret bool v2
    }

// check: fn main
    fn main() -> bool {
        entry():
        v0 = const bool true
// not: call
        v1 = call not(v0)

// * Confirm both the blocks from not() are here, they branch to the same block and that block has a
//   phi from each of them.
// check: cbr
// check: $(bl0_lab=$LABEL)
// check: const bool false
// check: br $(bl0_to=$ID)
// check: $(bl1_lab=$LABEL)
// check: const bool true
// check: br $bl0_to
// check: $bl0_to

// * Match this cbr to not be confused with the inlined cbr below.  A more unique marker in not()
//   would be better...
// check: cbr
        cbr v1, block1(v1), block0(v1)

        block0(v2: bool):
        v3 = const bool false
// not: call
        v4 = call not(v3)

// * Check same again for this inlined instance.  The consts are re-used so can't check them.
// check: cbr
// check: $(bl2_lab=$LABEL)
// check: br $(bl2_to=$ID)
// check: $(bl3_lab=$LABEL)
// check: br $bl2_to
// check: $bl2_to($VAR: bool):

        br block1(v4)

        block1(v5: bool):
        ret bool v5
    }
}
