// tweakable things
var_decl_keyword    =  {"let"}
fn_decl_keyword     =  {"fn"}
trait_decl_keyword  =  {"trait"}
return_keyword      =  {"return"}
use_keyword         =  {"use"}
enum_keyword        =  @{"enum"}
impl_keyword        =  {"impl"}
asm_keyword         =  {"asm"}
while_keyword       =  {"while"}
match_keyword       =  {"match"}
mut_keyword         =  { "mut" }
assign              =  _{"="}
line_comment_open   =  {"//"}
block_comment_open  =  {"/*"}
block_comment_close =  {"*/"}
fn_returns          =  {"->"}
path_separator      =  {"::"}


// top level
program =  {SOI ~ (library|contract|script|predicate)* ~ EOI}

library =  { "library" ~ library_name ~ "{" ~ (control_flow|declaration|use_statement)* ~ "}" }
library_name = { ident }
contract = { "contract" ~ "{" ~ (control_flow|declaration|use_statement)* ~ "}" }
script = { "script" ~ "{" ~ (control_flow|declaration|use_statement)* ~ "}" }
predicate = { "predicate" ~ "{" ~ (control_flow|declaration|use_statement)* ~ "}" }

// expressions
expr_inner =  _{literal_value|if_exp|parenthesized_expression|asm_expression|code_block|func_app|struct_expression|delineated_path|method_exp|subfield_exp|var_exp|array_exp|match_expression}
parenthesized_expression = { "(" ~ expr ~ ")" }
// // op exps built in to expr to prevent left recursion
expr       =  {expr_inner ~ (op ~ expr_inner)*}
func_app   =  { fn_name ~ "(" ~ (expr ~ ("," ~ expr)* )? ~ ")" }
fn_name    =  {var_exp}
var_exp    =  { unary_op? ~ var_name_ident } 
method_exp =  { subfield_exp ~ "(" ~ (expr ~ ("," ~ expr)* )? ~ ")" }
subfield_exp = { (call_item ~ ".")+ ~ call_item }
call_item = { ident }
delineated_path = { path_component  ~ ( "(" ~ expr ~ ")" )? }
path_component = { path_ident ~ (path_separator ~ path_ident )+  }
path_ident = { ident }

var_name_ident = { ident }

if_exp =  {"if" ~ expr ~  code_block ~ ("else" ~ code_block)?}

op =  {"+"|"-"|"/"|"*"|"=="|"!="|"|"|"||"|"&"|"&&"|"^"|"%"|"<"|">"}
unary_op = { "!" | "ref" | "deref" }

// // note that decimal/float exprs might be removed since vm doesn't support them
literal_value =  {integer|byte|string|boolean}

boolean =  {"true"|"false"}
string  = ${"\"" ~ char* ~ "\""}
integer = { (u8_integer | u16_integer | u32_integer | u64_integer) }
basic_integer = @{!("0b" | "0x") ~ ASCII_DIGIT+}
u8_integer = {  basic_integer ~ "u8" }
u16_integer = { basic_integer ~ "u16" }
u32_integer = { basic_integer ~ "u32" }
// default is u64
u64_integer = { basic_integer ~ "u64"? }
u128_integer = { basic_integer ~ "u128" }
byte = { binary_byte | hex_byte }
binary_byte = @{ "0b" ~ ("1" | "0")*}
hex_byte    = @{ "0x" ~ hex_digit* }
hex_digit = { "a" | "b" | "c" | "d" | "e" | "f" | "A" | "B" | "C" | "D" | "E" | "F" | ASCII_DIGIT } 
match_expression = { "match"  ~ expr ~ "{" ~ match_branch+ ~ "}" }
match_branch = { match_condition ~ "=>" ~ (code_block | expr) ~ "," }
match_condition = { expr | "_" } // TODO this doesn't support pattern matching

code_block =  {"{" ~ (declaration|control_flow|expr_statement)* ~ (expr)? ~ "}"}

struct_expression = { struct_name ~ "{" ~ struct_expr_fields ~ "}" }
struct_expr_fields = { struct_field_name ~ ":" ~ expr ~ ("," ~ struct_field_name ~ ":" ~ expr)* ~ ","? }
array_exp = { "[" ~ (expr ~ ("," ~ expr)*) ~ "]" }

// declarations 
declaration =  {(enum_decl|var_decl|fn_decl|trait_decl|struct_decl|reassignment|impl_trait|impl_self)}
var_decl    =  {var_decl_keyword ~ mut_keyword? ~ var_name ~ type_ascription? ~ assign ~ expr ~ ";"}
type_ascription = { ":" ~ type_name}
fn_decl     =  {visibility ~ fn_signature ~ code_block}
fn_signature = { fn_decl_keyword ~ fn_decl_name ~ type_params? ~ fn_decl_params ~ (fn_returns ~ return_type)? ~ trait_bounds? }
var_name = {ident}
reassignment = { var_exp ~ assign ~ expr ~ ";" } 

visibility = { "pub"? }

struct_decl = { "struct" ~ struct_name ~ type_params? ~ trait_bounds? ~ "{" ~ struct_fields ~ "}" }
struct_name = {ident}
struct_fields = { struct_field_name ~ ":" ~ type_name ~ ("," ~ struct_field_name ~ ":" ~ type_name)* ~ ","? }
struct_field_name = {ident}
// // enum declaration
enum_decl = { enum_keyword ~ enum_name ~ type_params? ~ trait_bounds? ~ "{" ~ enum_fields ~ "}" }
enum_fields = { enum_field_name ~ ":" ~ type_name ~ ("," ~ enum_field_name ~ ":" ~ type_name)* ~ ","? }
enum_name = {ident} 
enum_field_name = {ident}

impl_self = { impl_keyword ~ type_name ~ type_params? ~ trait_bounds? ~ ("{" ~ fn_decl* ~ "}") }

// // fn declaration
fn_decl_params =  {"(" ~ (fn_decl_param ~ ("," ~ fn_decl_param)*)? ~ ")"}
type_params = { "<" ~ generic_type_param ~ (", " ~ generic_type_param)* ~ ">" }
fn_decl_param  =  {("self") | (fn_decl_param_name ~ ":" ~ type_name)}
fn_decl_param_name = {ident}
return_type    =  {ident}
fn_decl_name   =  {ident}
type_name      =  {ident ~ type_params?}
trait_bounds   =  { "where" ~ (generic_type_param ~ ":" ~ trait_name) ~ ("," ~ generic_type_param ~ ":" ~ trait_name)* }
generic_type_param = @{ident}

// statements
// // statements are basically non-expressions that don't alter the namespace like declarations do
return_statement =  {return_keyword ~ expr? ~ ";"}
expr_statement  = { expr ~ ";" }

// traits
trait_decl = { visibility ~ trait_decl_keyword ~ trait_name ~ type_params? ~ trait_bounds? ~ trait_methods  }
// // just a fn signature denotes a fn something must implement in order for it to be part of the trait
// // i like the idea of separating the interface points from the actual
// // functional implementations the trait provides, so i have them
// // parsed as two separate blocks here.
// // this can of course be changed if others dislike it.
trait_methods = { "{" ~ (fn_signature ~ ";")* ~ "}" ~ ("{"~ fn_decl* ~ "}")* }
trait_name = { ident } 
impl_trait = { impl_keyword ~ trait_name ~ type_params? ~ "for" ~ type_name ~ type_params? ~ trait_bounds? ~ ("{"~ fn_decl* ~ "}") }


// imports

use_statement = { use_keyword ~ import_path ~ ";"}
import_path = { ident ~ (path_separator ~ (ident|star))* }
star = { "*" }

// loops
while_loop = { while_keyword ~ expr ~ code_block }

// asm inlining
asm_expression = { asm_keyword ~ asm_registers ~ "{" ~ asm_op* ~ asm_register? ~  "}" }
asm_registers = { "(" ~ asm_register_declaration ~ ("," ~ asm_register_declaration)* ~ ")" }
// should we allow expressions to be directly assigned to registers, or only 
// already declared variables? i'm unsure
asm_register_declaration = { ident ~ (":" ~ var_name)? }
asm_op = { opcode ~ (asm_immediate | asm_register)* ~ ";" }
asm_register = { ident }
asm_immediate = {"i" ~ u64_integer}
opcode = { ident } 

// control flow
control_flow = _{while_loop|return_statement}

// boilerplate
WHITESPACE    = _{(" "|"\t"|"\r"|"\n")+}
COMMENT       = _{block_comment|line_comment}
block_comment = @{block_comment_open ~ (!block_comment_close ~ ANY)* ~ block_comment_close}
line_comment  = @{line_comment_open ~ (!("\r"|"\n") ~ ANY)*}
char          =  @{
    !("\""|"\\") ~ ANY
  | "\\" ~ ("\""|"\\"|"/"|"b"|"f"|"n"|"r"|"t")
  | "\\" ~ ("u" ~ ASCII_HEX_DIGIT{4})
}
ident          = @{(!(reserved_words) ~ ASCII_ALPHA ~ (ASCII_ALPHANUMERIC|"_")*) | "()"}
reserved_words = {  while_keyword | "struct" | enum_keyword |  match_keyword | use_keyword | var_decl_keyword | fn_decl_keyword | trait_decl_keyword | return_keyword } 

