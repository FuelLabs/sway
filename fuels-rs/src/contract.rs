use crate::abi_encoder::ABIEncoder;
use crate::errors::Error;

use crate::json_abi::{parse_array_param, parse_custom_type_param, parse_param, ABI};

use crate::rustfmt;
use crate::tokens::{Detokenize, Token, Tokenize};
use crate::types::{expand_type, ByteArray, Function, JsonABI, ParamType, Property};
use inflector::Inflector;
use proc_macro2::{Ident, Literal, Span, TokenStream};
use quote::quote;
use std::collections::BTreeMap;
use std::{collections::HashMap, fs::File, io::Write, path::Path};
use syn::{parse_macro_input, Ident as SynIdent, Path as SynPath};

pub type Selector = ByteArray;

// Test struct
pub struct Abigen {
    /// The source of the ABI JSON for the contract whose bindings
    /// are being generated.
    parsed_abi: JsonABI,

    source: String,

    /// Override the contract name to use for the generated type.
    contract_name: String,

    /// Manually specified contract method aliases.
    method_aliases: HashMap<String, String>,

    /// Format the code using a locally installed copy of `rustfmt`.
    rustfmt: bool,
}

impl Abigen {
    /// Creates a new builder with the given ABI JSON source.
    pub fn new(contract_name: &str, abi_source: &str) -> Result<Self, Error> {
        let parsed_abi: JsonABI = serde_json::from_str(abi_source)?;
        Ok(Self {
            parsed_abi,
            source: abi_source.to_owned(),
            contract_name: contract_name.to_owned(),
            method_aliases: HashMap::new(),
            rustfmt: true,
        })
    }

    pub fn generate(self) -> Result<ContractBindings, Error> {
        let rustfmt = self.rustfmt;

        let c = Contract::new(&self.contract_name, &self.source)?;

        c.generate()
    }
}

/// TODO: rewrite comments
/// Type-safe contract bindings generated by a `Builder`. This type can be
/// either written to file or into a token stream for use in a procedural macro.
pub struct ContractBindings {
    /// The TokenStream representing the contract bindings.
    tokens: TokenStream,
    /// The output options used for serialization.
    rustfmt: bool,
}

impl ContractBindings {
    /// Writes the bindings to a given `Write`.
    pub fn write<W>(&self, mut w: W) -> Result<(), Error>
    where
        W: Write,
    {
        let source = {
            let raw = self.tokens.to_string();

            if self.rustfmt {
                rustfmt::format(&raw).unwrap_or(raw)
            } else {
                raw
            }
        };

        w.write_all(source.as_bytes()).unwrap();
        Ok(())
    }

    /// Writes the bindings to the specified file.
    pub fn write_to_file<P>(&self, path: P) -> Result<(), Error>
    where
        P: AsRef<Path>,
    {
        let file = File::create(path).unwrap();
        self.write(file)
    }

    /// Converts the bindings into its underlying token stream. This allows it
    /// to be used within a procedural macro.
    pub fn into_tokens(self) -> TokenStream {
        self.tokens
    }
}

/// A reduced form of `Contract` which just takes the `abi` and produces
/// ABI encoded data for its functions.
// #[derive(Debug, Clone)]
// pub struct BaseContract {
//     pub abi: Abi,

//     /// A mapping from method signature to a name-index pair for accessing
//     /// functions in the contract ABI.
//     pub methods: HashMap<Selector, (String, usize)>,
// }

pub struct ContractCall {}

impl ContractCall {
    pub fn new() -> Self {
        Self {}
    }

    // TODO: rethink naming
    pub fn method_hash<T: Tokenize>(signature: Selector, args: T) {
        let mut encoder = ABIEncoder::new();

        let encoded_params = hex::encode(encoder.encode(&args.into_tokens()).unwrap());
        let encoded_selector = hex::encode(signature);

        println!("encoded: {}{}\n", encoded_selector, encoded_params);
        // TODO: In the near future, the actual contract call will happen somewhere here.
        // Right now we're just generating the type-safe bindings with this `method_hash`
        // injected in these bindings.
    }
}

/// Internal shared context for generating smart contract bindings.
pub struct Contract {
    // Source of the abi
    abi_source: String,

    /// The ABI string pre-parsing.
    // abi_str: Literal,

    /// The parsed ABI.
    abi: JsonABI,

    /// The parser used for human readable format
    abi_parser: ABI,

    /// Contains all the solidity structs extracted from the JSON ABI.
    // internal_structs: InternalStructs, unclear if needed

    /// Was the ABI in human readable format?
    //human_readable: bool,

    /// The contract name as an identifier.
    contract_name: Ident, // TODO: option for now

    contract_name_str: String, // Might be temp

    /// Manually specified method aliases.
    method_aliases: BTreeMap<String, Ident>,

    /// Format the code using a locally installed copy of `rustfmt`.
    rustfmt: bool,
}

/// Expands a identifier string into an token.
pub fn ident(name: &str) -> Ident {
    Ident::new(name, Span::call_site())
}

impl Contract {
    /// Creates a new contract with the given ABI JSON source.
    pub fn new(contract_name: &str, abi_source: &str) -> Result<Self, Error> {
        let parsed_abi: JsonABI = serde_json::from_str(abi_source)?;
        Ok(Self {
            contract_name: ident(contract_name),
            abi_source: abi_source.to_owned(),
            abi: parsed_abi,
            abi_parser: ABI::new(),
            contract_name_str: contract_name.to_owned(),
            method_aliases: BTreeMap::new(),
            rustfmt: true,
        })
    }

    /// Generates the contract bindings.
    pub fn generate(self) -> Result<ContractBindings, Error> {
        let rustfmt = self.rustfmt;
        let tokens = self.expand()?;

        Ok(ContractBindings { tokens, rustfmt })
    }

    pub fn functions(&self) -> Result<TokenStream, Error> {
        // The goal here is to turn the parsed abi into TokenStream
        let mut tokenized_functions = Vec::new();

        for function in &self.abi {
            let tokenized_fn = self.expand_function(function, None)?;
            tokenized_functions.push(tokenized_fn);
        }

        Ok(quote! { #( #tokenized_functions )* })
    }

    fn expand_function(
        &self,
        function: &Function,
        alias: Option<Ident>,
    ) -> Result<TokenStream, Error> {
        let name = safe_ident(&function.name);

        let fn_signature = self
            .abi_parser
            .build_fn_selector(&function.name, &function.inputs);

        let encoded = ABIEncoder::encode_function_selector(fn_signature.as_bytes());
        let tokenized_signature = Contract::expand_selector(encoded);

        let tokenized_output = Contract::expand_fn_outputs(&function.outputs)?;

        let result = quote! { #tokenized_output }; // This can get fancier later

        let (input, arg) = self.expand_inputs_call_arg_with_structs(function)?;

        println!("input: {:?}\n", input);
        println!("arg: {:?}\n", arg);

        let doc = Contract::expand_doc(&format!(
            "Calls the contract's `{}` (0x{}) function",
            function.name,
            hex::encode(encoded)
        ));

        Ok(quote! {

            #doc
            pub fn #name(&self #input) -> #result {
                ContractCall::method_hash(#tokenized_signature, #arg);
                true
            }
        })
    }

    /// Expands a doc string into an attribute token stream.
    pub fn expand_doc(s: &str) -> TokenStream {
        let doc = Literal::string(s);
        quote! {
            #[doc = #doc]
        }
    }

    fn expand_selector(selector: Selector) -> TokenStream {
        let bytes = selector.iter().copied().map(Literal::u8_unsuffixed);
        quote! { [#( #bytes ),*] }
    }

    fn expand_fn_outputs(outputs: &[Property]) -> Result<TokenStream, Error> {
        match outputs.len() {
            0 => Ok(quote! { () }),
            1 => expand_type(&parse_param(&outputs[0])?),
            _ => {
                let types = outputs
                    .iter()
                    .map(|param| expand_type(&parse_param(param)?))
                    .collect::<Result<Vec<_>, Error>>()?;
                Ok(quote! { (#( #types ),*) })
            }
        }
    }

    fn expand_inputs_call_arg_with_structs(
        &self,
        fun: &Function,
    ) -> Result<(TokenStream, TokenStream), Error> {
        let mut args = Vec::with_capacity(fun.inputs.len());
        let mut call_args = Vec::with_capacity(fun.inputs.len());

        for (i, param) in fun.inputs.iter().enumerate() {
            let name = Contract::expand_input_name(i, &param.name);

            let ty = self.expand_input_param(fun, &param.name, &parse_param(param)?)?;
            println!("name: {:?}\n", name);
            println!("ty: {:?}\n", ty);
            args.push(quote! { #name: #ty });
            let call_arg = match parse_param(param)? {
                // this is awkward edge case where the function inputs are a single struct
                // we need to force this argument into a tuple so it gets expanded to `((#name,))`
                // this is currently necessary because internally `flatten_tokens` is called which removes the outermost `tuple` level
                // and since `((#name))` is not a rust tuple it doesn't get wrapped into another tuple that will be peeled off by `flatten_tokens`
                ParamType::Struct(_) if fun.inputs.len() == 1 => {
                    // make sure the tuple gets converted to `Token::Tuple`
                    // quote! {(#name,)}
                    unimplemented!()
                }
                _ => name,
            };
            call_args.push(call_arg);
        }
        let args = quote! { #( , #args )* };
        let call_args = match call_args.len() {
            0 => quote! { () },
            1 => quote! { #( #call_args )* },
            _ => quote! { ( #(#call_args, )* ) },
        };

        Ok((args, call_args))
    }

    /// Expands a positional identifier string that may be empty.
    ///
    /// Note that this expands the parameter name with `safe_ident`, meaning that
    /// identifiers that are reserved keywords get `_` appended to them.
    pub fn expand_input_name(index: usize, name: &str) -> TokenStream {
        let name_str = match name {
            "" => format!("p{}", index),
            n => n.to_snake_case(),
        };
        let name = safe_ident(&name_str);

        quote! { #name }
    }

    fn expand_input_param(
        &self,
        fun: &Function,
        param: &str,
        kind: &ParamType,
    ) -> Result<TokenStream, Error> {
        match kind {
            ParamType::Array(ty, _) => {
                let ty = self.expand_input_param(fun, param, ty)?;
                Ok(quote! {
                    ::std::vec::Vec<#ty>
                })
            }

            ParamType::Struct(_) => {
                unimplemented!()
                // let ty = if let Some(rust_struct_name) = self
                //     .internal_structs
                //     .get_function_input_struct_type(&fun.name, param)
                // {
                //     let ident = util::ident(rust_struct_name);
                //     quote! {#ident}
                // } else {
                //     types::expand(kind)?
                // };
                // Ok(ty)
            }
            _ => expand_type(kind),
        }
    }

    // This is where the magic happens
    pub fn expand(&self) -> Result<TokenStream, Error> {
        let name = &self.contract_name;
        let name_mod = ident(&format!(
            "{}_mod",
            self.contract_name.to_string().to_lowercase()
        ));

        let contract_functions = self.functions()?; // This is the part we care the most for now

        Ok(quote! {
            pub use #name_mod::*;

            #[allow(clippy::too_many_arguments)]
            mod #name_mod {
                #![allow(clippy::enum_variant_names)]
                #![allow(dead_code)]
                #![allow(unused_imports)]

                // #imports
                use fuels_rs::contract::ContractCall;
                // #struct_decl

                pub struct #name;

                impl #name {
                    pub fn new() -> Self {
                        Self{}
                    }

                    #contract_functions
                }
            }
        })

        // unimplemented!()
    }
}

// Expands an identifier string into a token and appending `_` if the
/// identifier is for a reserved keyword.
///
/// Parsing keywords like `self` can fail, in this case we add an underscore.
pub fn safe_ident(name: &str) -> Ident {
    syn::parse_str::<SynIdent>(name).unwrap_or_else(|_| ident(&format!("{}_", name)))
}

#[cfg(test)]
mod tests {
    use super::*;

    // TODO: move a lot of the tests from ethers (e.g methods.rs file) here

    #[test]
    fn generates_bindings() {
        let contract = r#"
        [
            {
                "type":"contract",
                "inputs":[
                    {
                        "name":"arg",
                        "type":"u32"
                    }
                ],
                "name":"takes_u32_returns_bool",
                "outputs":[
                    {
                        "name":"",
                        "type":"bool"
                    }
                ]
            }
        ]
        "#;

        let bindings = Contract::new("test", contract).unwrap().generate().unwrap();
        bindings.write(std::io::stdout()).unwrap();
    }
}
