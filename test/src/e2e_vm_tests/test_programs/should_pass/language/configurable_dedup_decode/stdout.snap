---
source: test/src/snapshot/mod.rs
---
> forc build --path test/src/e2e_vm_tests/test_programs/should_pass/language/configurable_dedup_decode --release --ir final --asm final
exit status: 0
output:
    Building test/src/e2e_vm_tests/test_programs/should_pass/language/configurable_dedup_decode
   Compiling library std (sway-lib-std)
// IR: Final
library {
}

warning: Returned value is ignored
    --> sway-lib-std/src/codec.sw:3181:5
     |
...
3181 |     T::is_memcopy();
     |     --------------- This returns a value which is not assigned to anything and is ignored.
     |     --------------- help: The returned value has type "bool".
     |
     = help: If you want to intentionally ignore the returned value, use `let _ = ...`:
     = help:   let _ = T::is_memcopy();
____

  Compiled library "std" with 1 warning.
   Compiling script configurable_dedup_decode (test/src/e2e_vm_tests/test_programs/should_pass/language/configurable_dedup_decode)
// IR: Final
script {
    TUPLE = config { u64 }, abi_decode_in_place_0, 0x0000000000000002, !1
    WRAPPED = config { u64 }, abi_decode_in_place_0, 0x0000000000000001, !2

    pub fn abi_decode_in_place_0(ptr !4: ptr, len !5: u64, target !6: ptr) -> (), !10 {
        local { ptr } __anon_0
        local { u64 } __anon_00
        local mut { ptr } buffer
        local { u64 } temp

        entry(ptr: ptr, len: u64, target: ptr):
        v0 = get_local __ptr { ptr }, __anon_0, !14
        v1 = const u64 0
        v2 = get_elem_ptr v0, __ptr ptr, v1, !15
        store ptr to v2, !16
        v3 = get_local __ptr { ptr }, buffer, !17
        mem_copy_val v3, v0
        v4 = get_local __ptr { ptr }, buffer, !18
        v5 = const u64 0
        v6 = get_elem_ptr v4, __ptr ptr, v5, !26
        v7 = load v6, !27
        v8 = asm(ptr: v7, val) -> u64 val, !29 {
            lw     val ptr i0, !30
        }
        v9 = load v6, !31
        v10 = const u64 8, !32
        v11 = add v9, v10, !33
        store v11 to v6, !35
        v12 = get_local __ptr { u64 }, __anon_00, !37
        v13 = const u64 0
        v14 = get_elem_ptr v12, __ptr u64, v13, !38
        store v8 to v14, !39
        v15 = get_local __ptr { u64 }, temp, !40
        mem_copy_val v15, v12
        v16 = get_local __ptr { u64 }, temp, !41
        v17 = cast_ptr v16 to ptr, !42
        v18 = const u64 8
        v19 = asm(target: target, temp: v17, size: v18) -> (), !43 {
            mcp    target temp size, !44
        }
        v20 = const unit ()
        ret () v20
    }

    pub entry fn __entry() -> (), !48 {
        entry():
        v0 = call main_8(), !51
        v1 = call encode_and_return_10(v0), !54
        v2 = const unit ()
        ret () v2
    }

    entry_orig fn main_8() -> u64, !57 {
        entry():
        v0 = get_config __ptr { u64 }, WRAPPED, !58
        v1 = const u64 0
        v2 = get_elem_ptr v0, __ptr u64, v1, !59
        v3 = load v2
        v4 = get_config __ptr { u64 }, TUPLE, !60
        v5 = const u64 0
        v6 = get_elem_ptr v4, __ptr u64, v5, !61
        v7 = load v6
        v8 = add v3, v7, !64
        ret u64 v8
    }

    pub fn encode_and_return_10(item !65: u64) -> (), !68 {
        local slice __ret_val
        local slice slice
        local slice slice_
        local slice slice_0

        entry(item: u64):
        v0 = get_local __ptr slice, __ret_val
        v1 = call encode_13(item, v0)
        v2 = get_local __ptr slice, slice, !69
        mem_copy_val v2, v0
        v3 = get_local __ptr slice, slice, !74
        v4 = get_local __ptr slice, slice_, !77
        mem_copy_val v4, v3
        v5 = get_local __ptr slice, slice_, !79
        v6 = asm(ptr: v5) -> __ptr { ptr, u64 } ptr {
        }
        v7 = const u64 0
        v8 = get_elem_ptr v6, __ptr ptr, v7
        v9 = load v8
        v10 = get_local __ptr slice, slice, !83
        v11 = get_local __ptr slice, slice_0, !86
        mem_copy_val v11, v10
        v12 = get_local __ptr slice, slice_0, !87
        v13 = asm(ptr: v12) -> __ptr { ptr, u64 } ptr {
        }
        v14 = const u64 1
        v15 = get_elem_ptr v13, __ptr u64, v14
        v16 = load v15
        retd v9 v16, !88
    }

    pub fn encode_13(item !89: u64, __ret_value: __ptr slice) -> (), !92 {
        local mut { ptr, u64, u64 } __aggr_memcpy_0
        local mut { ptr, u64, u64 } __aggr_memcpy_00
        local mut { ptr, u64, u64 } __aggr_memcpy_01
        local mut { ptr, u64, u64 } __aggr_memcpy_02
        local mut slice __aggr_memcpy_03
        local { ptr, u64, u64 } __anon_0
        local { ptr, u64, u64 } __anon_00
        local { ptr, u64, u64 } __anon_01
        local { { ptr, u64, u64 } } __anon_1
        local { ptr, u64, u64 } __anon_10
        local { ptr, u64 } __anon_11
        local { { ptr, u64, u64 } } __anon_2
        local { { ptr, u64, u64 } } buffer
        local { { ptr, u64, u64 } } buffer_
        local { { ptr, u64, u64 } } self_0

        entry(item: u64, __ret_value: __ptr slice):
        v0 = const u64 1024
        v1 = asm(cap: v0) -> ptr hp, !95 {
            aloc   cap
        }
        v2 = get_local __ptr { ptr, u64, u64 }, __anon_0, !95
        v3 = const u64 0
        v4 = get_elem_ptr v2, __ptr ptr, v3, !95
        store v1 to v4, !95
        v5 = const u64 1
        v6 = get_elem_ptr v2, __ptr u64, v5, !95
        store v0 to v6, !95
        v7 = const u64 2
        v8 = get_elem_ptr v2, __ptr u64, v7, !95
        v9 = const u64 0
        store v9 to v8, !95
        v10 = asm(buffer: v2) -> __ptr { ptr, u64, u64 } buffer {
        }
        v11 = get_local __ptr { ptr, u64, u64 }, __aggr_memcpy_0
        mem_copy_val v11, v10
        v12 = get_local __ptr { { ptr, u64, u64 } }, __anon_1, !97
        v13 = const u64 0
        v14 = get_elem_ptr v12, __ptr { ptr, u64, u64 }, v13, !95
        mem_copy_val v14, v11
        v15 = get_local __ptr { { ptr, u64, u64 } }, buffer_, !100
        mem_copy_val v15, v12
        v16 = get_local __ptr { { ptr, u64, u64 } }, buffer_, !102
        v17 = const u64 0
        v18 = get_elem_ptr v16, __ptr { ptr, u64, u64 }, v17, !104
        v19 = asm(buffer: v18) -> __ptr { ptr, u64, u64 } buffer {
        }
        v20 = get_local __ptr { ptr, u64, u64 }, __aggr_memcpy_00
        mem_copy_val v20, v19
        v21 = get_local __ptr { ptr, u64, u64 }, __anon_00, !100
        mem_copy_val v21, v20
        v22 = const u64 0
        v23 = get_elem_ptr v21, __ptr ptr, v22, !100
        v24 = load v23, !100
        v25 = const u64 1
        v26 = get_elem_ptr v21, __ptr u64, v25, !100
        v27 = load v26, !100
        v28 = const u64 2
        v29 = get_elem_ptr v21, __ptr u64, v28, !100
        v30 = load v29, !100
        v31 = const u64 8
        v32 = add v30, v31, !100
        v33 = cmp gt v32 v27, !100
        cbr v33, abi_encode_14_block1(), abi_encode_14_block0(v24, v27), !100

        abi_encode_14_block0(v34: ptr, v35: u64):
        v36 = add v34, v30, !100
        v37 = cast_ptr v36 to __ptr u64, !100
        store item to v37, !100
        v38 = get_local __ptr { ptr, u64, u64 }, __anon_10, !100
        v39 = const u64 0
        v40 = get_elem_ptr v38, __ptr ptr, v39, !100
        store v34 to v40, !100
        v41 = const u64 1
        v42 = get_elem_ptr v38, __ptr u64, v41, !100
        store v35 to v42, !100
        v43 = const u64 2
        v44 = get_elem_ptr v38, __ptr u64, v43, !100
        store v32 to v44, !100
        v45 = asm(buffer: v38) -> __ptr { ptr, u64, u64 } buffer {
        }
        v46 = get_local __ptr { ptr, u64, u64 }, __aggr_memcpy_01
        mem_copy_val v46, v45
        v47 = get_local __ptr { { ptr, u64, u64 } }, __anon_2, !106
        v48 = const u64 0
        v49 = get_elem_ptr v47, __ptr { ptr, u64, u64 }, v48, !100
        mem_copy_val v49, v46
        v50 = get_local __ptr { { ptr, u64, u64 } }, buffer, !107
        mem_copy_val v50, v47
        v51 = get_local __ptr { { ptr, u64, u64 } }, buffer, !108
        v52 = get_local __ptr { { ptr, u64, u64 } }, self_0, !111
        mem_copy_val v52, v51
        v53 = get_local __ptr { { ptr, u64, u64 } }, self_0, !113
        v54 = const u64 0
        v55 = get_elem_ptr v53, __ptr { ptr, u64, u64 }, v54, !114
        v56 = asm(buffer: v55) -> __ptr { ptr, u64, u64 } buffer {
        }
        v57 = get_local __ptr { ptr, u64, u64 }, __aggr_memcpy_02
        mem_copy_val v57, v56
        v58 = get_local __ptr { ptr, u64, u64 }, __anon_01, !111
        mem_copy_val v58, v57
        v59 = const u64 0
        v60 = get_elem_ptr v58, __ptr ptr, v59, !111
        v61 = const u64 2
        v62 = get_elem_ptr v58, __ptr u64, v61, !111
        v63 = get_local __ptr { ptr, u64 }, __anon_11, !111
        v64 = const u64 0
        v65 = get_elem_ptr v63, __ptr ptr, v64, !111
        mem_copy_val v65, v60
        v66 = const u64 1
        v67 = get_elem_ptr v63, __ptr u64, v66, !111
        mem_copy_val v67, v62
        v68 = asm(s: v63) -> __ptr slice s {
        }
        v69 = get_local __ptr slice, __aggr_memcpy_03
        mem_copy_val v69, v68
        mem_copy_val __ret_value, v69
        v70 = const unit ()
        ret () v70

        abi_encode_14_block1():
        v71 = const u64 2
        v72 = mul v27, v71, !100
        v73 = add v72, v31, !100
        v74 = asm(new_cap: v73, old_ptr: v24, len: v30) -> __ptr u8 hp, !100 {
            aloc   new_cap
            mcp    hp old_ptr len
        }
        br abi_encode_14_block0(v74, v73), !100
    }
}

!0 = "test/src/e2e_vm_tests/test_programs/should_pass/language/configurable_dedup_decode/src/main.sw"
!1 = span !0 177 182
!2 = span !0 136 143
!3 = "sway-lib-std/src/codec.sw"
!4 = span !3 79914 79917
!5 = span !3 79928 79931
!6 = span !3 79938 79944
!7 = span !3 79884 80217
!8 = fn_name_span !3 79891 79910
!9 = inline "never"
!10 = (!7 !8 !9)
!11 = span !3 80002 80036
!12 = fn_call_path_span !3 80002 80026
!13 = span !3 735 755
!14 = (!11 !12 !13)
!15 = (!11 !12)
!16 = (!11 !12 !13)
!17 = span !3 79985 80037
!18 = span !3 80067 80073
!19 = span !3 80053 80074
!20 = fn_call_path_span !3 80053 80066
!21 = span !3 123738 123759
!22 = fn_call_path_span !3 123738 123751
!23 = span !3 80666 80694
!24 = fn_call_path_span !3 80673 80685
!25 = span !3 625 637
!26 = (!19 !20 !21 !22 !23 !24 !25)
!27 = (!19 !20 !21 !22 !23 !24)
!28 = span !3 2766 2847
!29 = (!19 !20 !21 !22 !23 !24 !28)
!30 = span !3 2804 2817
!31 = (!19 !20 !21 !22 !23 !24)
!32 = (!19 !20 !21 !22 !23 !24)
!33 = (!19 !20 !21 !22 !23 !24)
!34 = span !3 2857 2896
!35 = (!19 !20 !21 !22 !23 !24 !34)
!36 = span !3 123737 123762
!37 = (!19 !20 !36)
!38 = (!19 !20 !36)
!39 = (!19 !20 !36)
!40 = span !3 80042 80075
!41 = span !3 80133 80137
!42 = span !3 80123 80138
!43 = span !3 80080 80215
!44 = span !3 80188 80208
!45 = "test/src/e2e_vm_tests/test_programs/should_pass/language/configurable_dedup_decode/src/main.<autogenerated>.sw"
!46 = span !45 0 126
!47 = fn_name_span !45 7 14
!48 = (!46 !47)
!49 = span !45 54 60
!50 = fn_call_path_span !45 54 58
!51 = (!49 !50)
!52 = span !45 78 111
!53 = fn_call_path_span !45 78 95
!54 = (!52 !53)
!55 = span !0 202 246
!56 = fn_name_span !0 205 209
!57 = (!55 !56)
!58 = span !0 225 232
!59 = span !0 30 36
!60 = span !0 237 242
!61 = span !0 243 244
!62 = span !0 225 244
!63 = fn_call_path_span !0 235 236
!64 = (!62 !63)
!65 = span !3 79403 79407
!66 = span !3 79375 79673
!67 = fn_name_span !3 79382 79399
!68 = (!66 !67 !9)
!69 = span !3 79579 79609
!70 = span !3 79633 79644
!71 = fn_call_path_span !3 79639 79642
!72 = "sway-lib-std/src/raw_slice.sw"
!73 = span !72 2922 2926
!74 = (!70 !71 !73)
!75 = span !72 2911 2927
!76 = fn_call_path_span !72 2911 2921
!77 = (!70 !71 !75 !76)
!78 = span !72 1633 1638
!79 = (!70 !71 !75 !76 !78)
!80 = span !3 79646 79663
!81 = fn_call_path_span !3 79652 79655
!82 = span !72 3420 3424
!83 = (!80 !81 !82)
!84 = span !72 3409 3425
!85 = fn_call_path_span !72 3409 3419
!86 = (!80 !81 !84 !85)
!87 = (!80 !81 !84 !85 !78)
!88 = span !3 79618 79664
!89 = span !3 79232 79236
!90 = span !3 79215 79356
!91 = fn_name_span !3 79222 79228
!92 = (!90 !91 !9)
!93 = span !3 79313 79326
!94 = fn_call_path_span !3 79313 79324
!95 = (!93 !94)
!96 = span !3 191 254
!97 = (!93 !94 !96)
!98 = span !3 79297 79327
!99 = fn_call_path_span !3 79302 79312
!100 = (!98 !99)
!101 = span !3 4996 5002
!102 = (!98 !99 !101)
!103 = span !3 87 114
!104 = (!98 !99 !103)
!105 = span !3 4944 5027
!106 = (!98 !99 !105)
!107 = span !3 79284 79328
!108 = span !3 79333 79339
!109 = span !3 79333 79354
!110 = fn_call_path_span !3 79340 79352
!111 = (!109 !110)
!112 = span !3 573 577
!113 = (!109 !110 !112)
!114 = (!109 !110 !103)

;; ASM: Final program
;; Program kind: Script
.program:
move $$tmp $pc
jmpf $zero i4
DATA_SECTION_OFFSET[0..32]
DATA_SECTION_OFFSET[32..64]
CONFIGURABLES_OFFSET[0..32]
CONFIGURABLES_OFFSET[32..64]
lw   $$ds $$tmp i1
add  $$ds $$ds $$tmp
cfei i16                      ; allocate stack space for globals
addr $$arg0 data_Configurable_0; get pointer to configurable TUPLE default value
addi $$arg1 $zero i8          ; get length of configurable TUPLE default value
addi $$arg2 $ssp i0           ; get pointer to configurable TUPLE stack address
jal  $$reta $pc i11           ; decode configurable TUPLE
addr $$arg0 data_Configurable_1; get pointer to configurable WRAPPED default value
addi $$arg1 $zero i8          ; get length of configurable WRAPPED default value
addi $$arg2 $ssp i8           ; get pointer to configurable WRAPPED stack address
jal  $$reta $pc i6            ; decode configurable WRAPPED
move $$locbase $sp            ; save locals base register for function __entry
jal  $$reta $pc i31           ; [call]: call main_8
move $$arg0 $$retv            ; [call]: pass argument 0
jal  $$reta $pc i39           ; [call]: call encode_and_return_10
ret  $zero                    ; return unit as zero
pshl i31                      ; save registers 16..40
pshh i524288                  ; save registers 40..64
move $$locbase $sp            ; save locals base register for function abi_decode_in_place_0
cfei i32                      ; allocate 32 bytes for locals and 0 slots for call arguments
move $r2 $$arg2               ; save argument 2 (target)
move $r3 $$reta               ; save return address
sw   $$locbase $$arg0 i0      ; store word
addi $r0 $$locbase i16        ; get offset to local __ptr { ptr }
mcpi $r0 $$locbase i8         ; copy memory
lw   $r0 $$locbase i2         ; load word
lw   $r4 $r0 i0               ; lw val ptr i0
lw   $r0 $$locbase i2         ; load word
movi $r1 i8                   ; initialize constant into register
add  $r0 $r0 $r1
sw   $$locbase $r0 i2         ; store word
addi $r0 $$locbase i8         ; get offset to local __ptr { u64 }
sw   $$locbase $r4 i1         ; store word
addi $r1 $$locbase i24        ; get offset to local __ptr { u64 }
mcpi $r1 $r0 i8               ; copy memory
addi $r0 $$locbase i24        ; get offset to local __ptr { u64 }
movi $r1 i8                   ; initialize constant into register
mcp  $r2 $r0 $r1              ; mcp target temp size
cfsi i32                      ; free 32 bytes for locals and 0 slots for extra call arguments
move $$reta $r3               ; restore return address
poph i524288                  ; restore registers 40..64
popl i31                      ; restore registers 16..40
jal  $zero $$reta i0          ; return from call
pshl i3                       ; save registers 16..40
pshh i524288                  ; save registers 40..64
move $$locbase $sp            ; save locals base register for function main_8
lw   $r0 $ssp i1              ; load word
lw   $r1 $ssp i0              ; load word
add  $r0 $r0 $r1
move $$retv $r0               ; set return value
poph i524288                  ; restore registers 40..64
popl i3                       ; restore registers 16..40
jal  $zero $$reta i0          ; return from call
pshl i15                      ; save registers 16..40
pshh i524288                  ; save registers 40..64
move $$locbase $sp            ; save locals base register for function encode_and_return_10
cfei i64                      ; allocate 64 bytes for locals and 0 slots for call arguments
move $r0 $$reta               ; save return address
move $$arg1 $$locbase         ; [call]: pass argument 1
jal  $$reta $pc i17           ; [call]: call encode_13
addi $r1 $$locbase i16        ; get offset to local __ptr slice
mcpi $r1 $$locbase i16        ; copy memory
addi $r1 $$locbase i16        ; get offset to local __ptr slice
addi $r2 $$locbase i32        ; get offset to local __ptr slice
mcpi $r2 $r1 i16              ; copy memory
lw   $r1 $$locbase i4         ; load word
addi $r2 $$locbase i16        ; get offset to local __ptr slice
addi $r3 $$locbase i48        ; get offset to local __ptr slice
mcpi $r3 $r2 i16              ; copy memory
lw   $r2 $$locbase i7         ; load word
retd  $r1 $r2
cfsi i64                      ; free 64 bytes for locals and 0 slots for extra call arguments
move $$reta $r0               ; restore return address
poph i524288                  ; restore registers 40..64
popl i15                      ; restore registers 16..40
jal  $zero $$reta i0          ; return from call
pshl i255                     ; save registers 16..40
pshh i524288                  ; save registers 40..64
move $$locbase $sp            ; save locals base register for function encode_13
cfei i344                     ; allocate 344 bytes for locals and 0 slots for call arguments
move $r0 $$arg0               ; save argument 0 (item)
move $r1 $$arg1               ; save argument 1 (__ret_value)
move $r2 $$reta               ; save return address
movi $r3 i1024                ; initialize constant into register
aloc $r3
addi $r3 $$locbase i112       ; get offset to local __ptr { ptr, u64, u64 }
sw   $$locbase $hp i14        ; store word
movi $r4 i1024                ; initialize constant into register
sw   $$locbase $r4 i15        ; store word
sw   $$locbase $zero i16      ; store word
mcpi $$locbase $r3 i24        ; copy memory
addi $r3 $$locbase i184       ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r3 $$locbase i24        ; copy memory
addi $r4 $$locbase i296       ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r4 $r3 i24              ; copy memory
addi $r3 $$locbase i296       ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r4 $$locbase i24        ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r4 $r3 i24              ; copy memory
addi $r3 $$locbase i136       ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r3 $r4 i24              ; copy memory
lw   $r3 $$locbase i17        ; load word
lw   $r7 $$locbase i18        ; load word
lw   $r4 $$locbase i19        ; load word
movi $r5 i8                   ; initialize constant into register
add  $r5 $r4 $r5
gt   $r6 $r5 $r7
jnzf $r6 $zero i1
jmpf $zero i7
movi $r6 i2                   ; initialize constant into register
mul  $r6 $r7 $r6
movi $r7 i8                   ; initialize constant into register
add  $r7 $r6 $r7
aloc $r7
mcp  $hp $r3 $r4
move $r3 $hp                  ; move parameter from branch to block argument
add  $r4 $r3 $r4
sw   $r4 $r0 i0               ; store word
addi $r0 $$locbase i208       ; get offset to local __ptr { ptr, u64, u64 }
sw   $$locbase $r3 i26        ; store word
sw   $$locbase $r7 i27        ; store word
sw   $$locbase $r5 i28        ; store word
addi $r3 $$locbase i48        ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r3 $r0 i24              ; copy memory
addi $r0 $$locbase i248       ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r0 $r3 i24              ; copy memory
addi $r3 $$locbase i272       ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r3 $r0 i24              ; copy memory
addi $r0 $$locbase i272       ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r3 $$locbase i320       ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r3 $r0 i24              ; copy memory
addi $r0 $$locbase i320       ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r3 $$locbase i72        ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r3 $r0 i24              ; copy memory
addi $r0 $$locbase i160       ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r0 $r3 i24              ; copy memory
addi $r3 $r0 i16              ; get offset to aggregate element
addi $r4 $$locbase i232       ; get offset to local __ptr { ptr, u64 }
mcpi $r4 $r0 i8               ; copy memory
addi $r0 $r4 i8               ; get offset to aggregate element
mcpi $r0 $r3 i8               ; copy memory
addi $r0 $$locbase i96        ; get offset to local __ptr slice
mcpi $r0 $r4 i16              ; copy memory
mcpi $r1 $r0 i16              ; copy memory
cfsi i344                     ; free 344 bytes for locals and 0 slots for extra call arguments
move $$reta $r2               ; restore return address
poph i524288                  ; restore registers 40..64
popl i255                     ; restore registers 16..40
jal  $zero $$reta i0          ; return from call
.data:
data_<Configurable, TUPLE>_0 .bytes[8] 00 00 00 00 00 00 00 02  ........
data_<Configurable, WRAPPED>_1 .bytes[8] 00 00 00 00 00 00 00 01  ........


    Finished release [optimized + fuel] target(s) [640 B] in ???
