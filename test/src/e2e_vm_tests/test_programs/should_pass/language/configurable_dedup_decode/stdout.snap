---
source: test/src/snapshot/mod.rs
snapshot_kind: text
---
> forc build --path test/src/e2e_vm_tests/test_programs/should_pass/language/configurable_dedup_decode --release --ir final --asm final
exit status: 0
output:
    Building test/src/e2e_vm_tests/test_programs/should_pass/language/configurable_dedup_decode
   Compiling library std (sway-lib-std)
// IR: Final
library {
}

   Compiling script configurable_dedup_decode (test/src/e2e_vm_tests/test_programs/should_pass/language/configurable_dedup_decode)
// IR: Final
script {
    TUPLE = config { u64 }, abi_decode_in_place_0, 0x0000000000000002, !1
    WRAPPED = config { u64 }, abi_decode_in_place_7, 0x0000000000000001, !2

    pub fn abi_decode_in_place_0(ptr !4: ptr, len !5: u64, target !6: ptr) -> (), !10 {
        local mut { ptr } buffer
        local { u64 } temp

        entry(ptr: ptr, len: u64, target: ptr):
<<<<<<< HEAD
        v416v1 = get_local __ptr { ptr }, buffer, !14
        v114v1 = const u64 0
        v417v1 = get_elem_ptr v416v1, __ptr ptr, v114v1, !15
        store ptr to v417v1, !16
        v171v1 = get_local __ptr { ptr }, buffer, !17
        v136v1 = const u64 0
        v423v3 = get_elem_ptr v171v1, __ptr ptr, v136v1, !25
        v613v1 = load v423v3, !26
        v614v1 = asm(ptr: v613v1, val) -> u64 val, !28 {
            lw     val ptr i0, !29
        }
        v616v1 = load v423v3, !30
        v617v1 = const u64 8, !31
        v618v1 = add v616v1, v617v1, !32
        store v618v1 to v423v3, !34
        v424v1 = get_local __ptr { u64 }, temp, !36
        v166v1 = const u64 0
        v425v1 = get_elem_ptr v424v1, __ptr u64, v166v1, !37
        store v614v1 to v425v1, !38
        v178v1 = get_local __ptr { u64 }, temp, !39
        v179v1 = cast_ptr v178v1 to ptr, !40
        v180v1 = const u64 8
        v181v1 = asm(target: target, temp: v179v1, size: v180v1) -> (), !41 {
            mcp    target temp size, !42
=======
        v0 = get_local __ptr { ptr }, buffer, !14
        v1 = const u64 0
        v2 = get_elem_ptr v0, __ptr ptr, v1, !15
        store ptr to v2, !16
        v3 = get_local __ptr { ptr }, buffer, !17
        v4 = const u64 0
        v5 = get_elem_ptr v3, __ptr ptr, v4, !25
        v6 = load v5, !26
        v7 = asm(ptr: v6, val) -> u64 val, !28 {
            lw     val ptr i0, !29
        }
        v8 = load v5, !30
        v9 = const u64 8, !31
        v10 = add v8, v9, !32
        store v10 to v5, !34
        v11 = get_local __ptr { u64 }, temp, !36
        v12 = const u64 0
        v13 = get_elem_ptr v11, __ptr u64, v12, !37
        store v7 to v13, !38
        v14 = get_local __ptr { u64 }, temp, !39
        v15 = cast_ptr v14 to ptr, !40
        v16 = const u64 8
<<<<<<< HEAD
        v17 = asm(target: target, temp: v15, size: v16) -> (), !44 {
            mcp    target temp size, !45
>>>>>>> 2b4c2d140 (update snapshot tests)
=======
        v17 = asm(target: target, temp: v15, size: v16) -> (), !41 {
            mcp    target temp size, !42
>>>>>>> c47472c5f (update tests)
        }
        v182v1 = const unit ()
        ret () v182v1
    }

    pub fn abi_decode_in_place_7(ptr !4: ptr, len !5: u64, target !6: ptr) -> (), !43 {
        entry(ptr: ptr, len: u64, target: ptr):
        v0 = asm(src: ptr, target: target, len: len) -> (), !44 {
            mcp    target src len, !45
        }
        v1 = const unit ()
        ret () v1
    }

    pub entry fn __entry() -> __ptr never, !49 {
        local u64 _result

        entry():
<<<<<<< HEAD
<<<<<<< HEAD
        v254v1 = call main_8(), !49
        v527v1 = get_local __ptr u64, item_, !52
        store v254v1 to v527v1, !52
        v609v1 = get_local __ptr u64, item_, !54
        v283v1 = const u64 8
        retd v609v1 v283v1, !56
=======
        v0 = call main_12(), !51
        v1 = get_local __ptr u64, _result, !52
        store v0 to v1, !52
        v2 = get_local __ptr u64, _result, !53
        v3 = const u64 8
        retd v2 v3, !57
>>>>>>> 2b4c2d140 (update snapshot tests)
=======
        v0 = call main_15(), !52
        v1 = get_local __ptr u64, _result, !53
        store v0 to v1, !53
        v2 = get_local __ptr u64, _result, !54
        v3 = const u64 8
        retd v2 v3, !58
>>>>>>> c47472c5f (update tests)
    }

    entry_orig fn main_15() -> u64, !61 {
        entry():
<<<<<<< HEAD
<<<<<<< HEAD
        v244v1 = get_config __ptr { u64 }, WRAPPED, !60
        v245v1 = const u64 0
        v246v1 = get_elem_ptr v244v1, __ptr u64, v245v1, !61
        v247v1 = load v246v1
        v248v1 = get_config __ptr { u64 }, TUPLE, !62
        v249v1 = const u64 0
        v250v1 = get_elem_ptr v248v1, __ptr u64, v249v1, !63
        v251v1 = load v250v1
        v457v1 = add v247v1, v251v1, !66
        ret u64 v457v1
=======
        v0 = get_config __ptr { u64 }, WRAPPED, !61
=======
        v0 = get_config __ptr { u64 }, WRAPPED, !62
>>>>>>> c47472c5f (update tests)
        v1 = const u64 0
        v2 = get_elem_ptr v0, __ptr u64, v1, !63
        v3 = load v2
        v4 = get_config __ptr { u64 }, TUPLE, !64
        v5 = const u64 0
        v6 = get_elem_ptr v4, __ptr u64, v5, !65
        v7 = load v6
        v8 = add v3, v7, !68
        ret u64 v8
>>>>>>> 2b4c2d140 (update snapshot tests)
    }
}

!0 = "test/src/e2e_vm_tests/test_programs/should_pass/language/configurable_dedup_decode/src/main.sw"
!1 = span !0 177 182
!2 = span !0 136 143
!3 = "sway-lib-std/src/codec.sw"
!4 = span !3 82242 82245
!5 = span !3 82256 82259
!6 = span !3 82266 82272
!7 = span !3 82212 82726
!8 = fn_name_span !3 82219 82238
!9 = inline "never"
!10 = (!7 !8 !9)
!11 = span !3 82473 82507
!12 = fn_call_path_span !3 82473 82497
!13 = span !3 739 759
!14 = (!11 !12 !13)
!15 = (!11 !12)
!16 = (!11 !12 !13)
!17 = span !3 82542 82548
!18 = span !3 82528 82549
!19 = fn_call_path_span !3 82528 82541
!20 = span !3 134798 134819
!21 = fn_call_path_span !3 134798 134811
!22 = span !3 83379 83407
!23 = fn_call_path_span !3 83386 83398
!24 = span !3 625 641
!25 = (!18 !19 !20 !21 !22 !23 !24)
!26 = (!18 !19 !20 !21 !22 !23)
!27 = span !3 2927 3008
!28 = (!18 !19 !20 !21 !22 !23 !27)
!29 = span !3 2965 2978
!30 = (!18 !19 !20 !21 !22 !23)
!31 = (!18 !19 !20 !21 !22 !23)
!32 = (!18 !19 !20 !21 !22 !23)
!33 = span !3 3018 3057
!34 = (!18 !19 !20 !21 !22 !23 !33)
!35 = span !3 134797 134822
!36 = (!18 !19 !35)
!37 = (!18 !19 !35)
!38 = (!18 !19 !35)
!39 = span !3 82620 82624
!40 = span !3 82610 82625
!41 = span !3 82559 82718
!42 = span !3 82687 82707
!43 = (!7 !8 !9)
!44 = span !3 82351 82434
!45 = span !3 82405 82423
!46 = "test/src/e2e_vm_tests/test_programs/should_pass/language/configurable_dedup_decode/src/main.<autogenerated>.sw"
!47 = span !46 0 131
!48 = fn_name_span !46 7 14
!49 = (!47 !48)
!50 = span !46 59 65
!51 = fn_call_path_span !46 59 63
!52 = (!50 !51)
!53 = span !46 40 66
!54 = span !46 109 116
!55 = span !46 83 117
!56 = fn_call_path_span !46 83 100
!57 = span !3 81408 81434
!58 = (!55 !56 !57)
!59 = span !0 202 246
!60 = fn_name_span !0 205 209
!61 = (!59 !60)
!62 = span !0 225 232
!63 = span !0 30 36
!64 = span !0 237 242
!65 = span !0 243 244
!66 = span !0 225 244
!67 = fn_call_path_span !0 235 236
!68 = (!66 !67)

;; ASM: Final program
;; Program kind: Script
.program:
move $$tmp $pc
jmpf $zero i4
DATA_SECTION_OFFSET[0..32]
DATA_SECTION_OFFSET[32..64]
CONFIGURABLES_OFFSET[0..32]
CONFIGURABLES_OFFSET[32..64]
lw   $$ds $$tmp i1
add  $$ds $$ds $$tmp
cfei i16                      ; allocate stack space for globals
addr $$arg0 data_Configurable_0; get pointer to configurable TUPLE default value
addi $$arg1 $zero i8          ; get length of configurable TUPLE default value
addi $$arg2 $ssp i0           ; get pointer to configurable TUPLE stack address
jal  $$reta $pc i12           ; decode configurable TUPLE
addr $$arg0 data_Configurable_1; get pointer to configurable WRAPPED default value
addi $$arg1 $zero i8          ; get length of configurable WRAPPED default value
addi $$arg2 $ssp i8           ; get pointer to configurable WRAPPED stack address
jal  $$reta $pc i29           ; decode configurable WRAPPED
move $$locbase $sp            ; save locals base register for function __entry
cfei i8                       ; allocate 8 bytes for locals and 0 slots for call arguments
jal  $$reta $pc i35           ; [call]: call main_15
sw   $$locbase $$retv i0      ; store word
movi $r0 i8                   ; initialize constant into register
retd  $$locbase $r0
pshl i31                      ; save registers 16..40
pshh i524288                  ; save registers 40..64
move $$locbase $sp            ; save locals base register for function abi_decode_in_place_0
cfei i16                      ; allocate 16 bytes for locals and 0 slots for call arguments
move $r2 $$arg2               ; save argument 2 (target)
move $r3 $$reta               ; save return address
sw   $$locbase $$arg0 i0      ; store word
lw   $r0 $$locbase i0         ; load word
lw   $r1 $r0 i0               ; lw val ptr i0
lw   $r0 $$locbase i0         ; load word
movi $r4 i8                   ; initialize constant into register
add  $r0 $r0 $r4
sw   $$locbase $r0 i0         ; store word
sw   $$locbase $r1 i1         ; store word
addi $r0 $$locbase i8         ; get offset to local __ptr { u64 }
movi $r1 i8                   ; initialize constant into register
mcp  $r2 $r0 $r1              ; mcp target temp size
cfsi i16                      ; free 16 bytes for locals and 0 slots for extra call arguments
move $$reta $r3               ; restore return address
poph i524288                  ; restore registers 40..64
popl i31                      ; restore registers 16..40
jal  $zero $$reta i0          ; return from call
pshl i1                       ; save registers 16..40
pshh i524288                  ; save registers 40..64
move $$locbase $sp            ; save locals base register for function abi_decode_in_place_7
move $r0 $$reta               ; save return address
mcp  $$arg2 $$arg0 $$arg1     ; mcp target src len
move $$reta $r0               ; restore return address
poph i524288                  ; restore registers 40..64
popl i1                       ; restore registers 16..40
jal  $zero $$reta i0          ; return from call
pshl i3                       ; save registers 16..40
pshh i524288                  ; save registers 40..64
move $$locbase $sp            ; save locals base register for function main_15
lw   $r0 $ssp i1              ; load word
lw   $r1 $ssp i0              ; load word
add  $r0 $r0 $r1
move $$retv $r0               ; set return value
poph i524288                  ; restore registers 40..64
popl i3                       ; restore registers 16..40
jal  $zero $$reta i0          ; return from call
.data:
data_<Configurable, TUPLE>_0 .bytes[8] 00 00 00 00 00 00 00 02  ........
data_<Configurable, WRAPPED>_1 .bytes[8] 00 00 00 00 00 00 00 01  ........


    Finished release [optimized + fuel] target(s) [280 B] in ???
