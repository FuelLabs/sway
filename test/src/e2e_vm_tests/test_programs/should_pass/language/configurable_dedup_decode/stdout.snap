---
source: test/src/snapshot/mod.rs
---
> forc build --path test/src/e2e_vm_tests/test_programs/should_pass/language/configurable_dedup_decode --release --ir final --asm final
exit status: 0
output:
    Building test/src/e2e_vm_tests/test_programs/should_pass/language/configurable_dedup_decode
   Compiling library std (sway-lib-std)
// IR: Final
library {
}

DIFF------------------------------
.program:
DIFF------------------------------
.program:
   Compiling script configurable_dedup_decode (test/src/e2e_vm_tests/test_programs/should_pass/language/configurable_dedup_decode)
// IR: Final
script {
    TUPLE = config { u64 }, abi_decode_in_place_0, 0x0000000000000002, !1
    WRAPPED = config { u64 }, abi_decode_in_place_0, 0x0000000000000001, !2

    pub fn abi_decode_in_place_0(ptr !4: ptr, len !5: u64, target !6: ptr) -> (), !9 {
        entry(ptr: ptr, len: u64, target: ptr):
        v138v1 = asm(src: ptr, target: target, len: len) -> (), !10 {
            mcp    target src len, !11
        }
        v216v1 = const unit ()
        ret () v216v1
    }

    pub entry fn __entry() -> __ptr never, !15 {
        local u64 _result

        entry():
        v308v1 = call main_15(), !18
        v309v1 = get_local __ptr u64, _result, !19
        store v308v1 to v309v1, !19
        v328v1 = get_local __ptr u64, _result, !20
        v319v1 = const u64 8
        retd v328v1 v319v1, !24
    }

    entry_orig fn main_15() -> u64, !27 {
        entry():
        v298v1 = get_config __ptr { u64 }, WRAPPED, !28
        v299v1 = const u64 0
        v300v1 = get_elem_ptr v298v1, __ptr u64, v299v1, !29
        v301v1 = load v300v1
        v302v1 = get_config __ptr { u64 }, TUPLE, !30
        v303v1 = const u64 0
        v304v1 = get_elem_ptr v302v1, __ptr u64, v303v1, !31
        v305v1 = load v304v1
        v462v1 = add v301v1, v305v1, !34
        ret u64 v462v1
    }
}

!0 = "test/src/e2e_vm_tests/test_programs/should_pass/language/configurable_dedup_decode/src/main.sw"
!1 = span !0 177 182
!2 = span !0 136 143
!3 = "sway-lib-std/src/codec.sw"
!4 = span !3 94880 94883
!5 = span !3 94894 94897
!6 = span !3 94904 94910
!7 = span !3 94850 95364
!8 = fn_name_span !3 94857 94876
!9 = (!7 !8)
!10 = span !3 94989 95072
!11 = span !3 95043 95061
!12 = "test/src/e2e_vm_tests/test_programs/should_pass/language/configurable_dedup_decode/src/main.<autogenerated>.sw"
!13 = span !12 0 131
!14 = fn_name_span !12 7 14
!15 = (!13 !14)
!16 = span !12 59 65
!17 = fn_call_path_span !12 59 63
!18 = (!16 !17)
!19 = span !12 40 66
!20 = span !12 109 116
!21 = span !12 83 117
!22 = fn_call_path_span !12 83 100
!23 = span !3 94080 94106
!24 = (!21 !22 !23)
!25 = span !0 202 246
!26 = fn_name_span !0 205 209
!27 = (!25 !26)
!28 = span !0 225 232
!29 = span !0 30 36
!30 = span !0 237 242
!31 = span !0 243 244
!32 = span !0 225 244
!33 = fn_call_path_span !0 235 236
!34 = (!32 !33)

DIFF------------------------------
.program:
addr $$arg0 data_Configurable_0         ; get pointer to configurable TUPLE default value
addi $$arg1 $zero i8                    ; get length of configurable TUPLE default value
addi $$arg2 $ssp i0                     ; get pointer to configurable TUPLE stack address
fncall .0                               ; decode configurable TUPLE
addr $$arg0 data_Configurable_1         ; get pointer to configurable WRAPPED default value
addi $$arg1 $zero i8                    ; get length of configurable WRAPPED default value
addi $$arg2 $ssp i8                     ; get pointer to configurable WRAPPED stack address
fncall .0                               ; decode configurable WRAPPED
DIFF------------------------------
.program:
addr $$arg0 data_Configurable_0         ; get pointer to configurable TUPLE default value
addi $$arg1 $zero i8                    ; get length of configurable TUPLE default value
addi $$arg2 $ssp i0                     ; get pointer to configurable TUPLE stack address
fncall .0                               ; decode configurable TUPLE
addr $$arg0 data_Configurable_1         ; get pointer to configurable WRAPPED default value
addi $$arg1 $zero i8                    ; get length of configurable WRAPPED default value
addi $$arg2 $ssp i8                     ; get pointer to configurable WRAPPED stack address
fncall .0                               ; decode configurable WRAPPED
DIFF------------------------------
.program:
.2                                      ; --- start of function: __entry ---
move $$locbase $sp                      ; [entry init: __entry]: set locals base register
cfei i8                                 ; [entry init: __entry]: allocate: locals 8 byte(s), call args 0 slot(s)
.7
fncall .4                               ; [call: main_15]: call function
move $r6 $$retv                         ; [call: main_15]: copy returned value
 sw $$locbase $r6 i0                     ; store word
 sw $$locbase $$retv i0                  ; store word
movi $r7 i8                             ; initialize constant into register
retd $$locbase $r7                      ; [entry end: __entry] return slice
DIFF------------------------------
.program:
.2                                      ; --- start of function: __entry ---
move $$locbase $sp                      ; [entry init: __entry]: set locals base register
cfei i8                                 ; [entry init: __entry]: allocate: locals 8 byte(s), call args 0 slot(s)
.7
fncall .4                               ; [call: main_15]: call function
sw $$locbase $$retv i0                  ; store word
movi $r7 i8                             ; initialize constant into register
retd $$locbase $r7                      ; [entry end: __entry] return slice
DIFF------------------------------
.program:
.2                                      ; --- start of function: __entry ---
move $$locbase $sp                      ; [entry init: __entry]: set locals base register
cfei i8                                 ; [entry init: __entry]: allocate: locals 8 byte(s), call args 0 slot(s)
.7
fncall .4                               ; [call: main_15]: call function
sw $$locbase $$retv i0                  ; store word
movi $r7 i8                             ; initialize constant into register
retd $$locbase $r7                      ; [entry end: __entry] return slice
DIFF------------------------------
.program:
.2                                      ; --- start of function: __entry ---
move $$locbase $sp                      ; [entry init: __entry]: set locals base register
cfei i8                                 ; [entry init: __entry]: allocate: locals 8 byte(s), call args 0 slot(s)
.7
fncall .4                               ; [call: main_15]: call function
sw $$locbase $$retv i0                  ; store word
movi $r7 i8                             ; initialize constant into register
retd $$locbase $r7                      ; [entry end: __entry] return slice
DIFF------------------------------
.program:
.0                                      ; --- start of function: abi_decode_in_place_0 ---
pusha .0                                ; [fn init: abi_decode_in_place_0]: push all used registers to stack
move $$locbase $sp                      ; [fn init: abi_decode_in_place_0]: set locals base register
cfei i0                                 ; [fn init: abi_decode_in_place_0]: allocate: locals 0 byte(s), call args 0 slot(s)
.6
move $r1 $$arg0                         ; copy ASM block argument's constant initial value to register
move $r2 $$arg2                         ; copy ASM block argument's constant initial value to register
move $r3 $$arg1                         ; copy ASM block argument's constant initial value to register
 mcp $r2 $r1 $r3                         ; mcp target src len
 move $r4 $zero                          ; return unit value from ASM block without return register
 mcp $$arg2 $$arg0 $$arg1                ; mcp target src len
 movi $r4 i0                             ; return unit value from ASM block without return register
ji  .1
.1
cfsi i0                                 ; [fn end: abi_decode_in_place_0] free: locals 0 byte(s), call args 0 slot(s)
popa .0                                 ; [fn end: abi_decode_in_place_0] restore all used registers
jal $zero $$reta i0                     ; [fn end: abi_decode_in_place_0] return from call
DIFF------------------------------
.program:
.0                                      ; --- start of function: abi_decode_in_place_0 ---
pusha .0                                ; [fn init: abi_decode_in_place_0]: push all used registers to stack
move $$locbase $sp                      ; [fn init: abi_decode_in_place_0]: set locals base register
cfei i0                                 ; [fn init: abi_decode_in_place_0]: allocate: locals 0 byte(s), call args 0 slot(s)
.6
mcp $$arg2 $$arg0 $$arg1                ; mcp target src len
.1
cfsi i0                                 ; [fn end: abi_decode_in_place_0] free: locals 0 byte(s), call args 0 slot(s)
popa .0                                 ; [fn end: abi_decode_in_place_0] restore all used registers
jal $zero $$reta i0                     ; [fn end: abi_decode_in_place_0] return from call
DIFF------------------------------
.program:
.0                                      ; --- start of function: abi_decode_in_place_0 ---
pusha .0                                ; [fn init: abi_decode_in_place_0]: push all used registers to stack
move $$locbase $sp                      ; [fn init: abi_decode_in_place_0]: set locals base register
cfei i0                                 ; [fn init: abi_decode_in_place_0]: allocate: locals 0 byte(s), call args 0 slot(s)
.6
mcp $$arg2 $$arg0 $$arg1                ; mcp target src len
.1
cfsi i0                                 ; [fn end: abi_decode_in_place_0] free: locals 0 byte(s), call args 0 slot(s)
popa .0                                 ; [fn end: abi_decode_in_place_0] restore all used registers
jal $zero $$reta i0                     ; [fn end: abi_decode_in_place_0] return from call
DIFF------------------------------
.program:
.0                                      ; --- start of function: abi_decode_in_place_0 ---
pusha .0                                ; [fn init: abi_decode_in_place_0]: push all used registers to stack
move $$locbase $sp                      ; [fn init: abi_decode_in_place_0]: set locals base register
cfei i0                                 ; [fn init: abi_decode_in_place_0]: allocate: locals 0 byte(s), call args 0 slot(s)
.6
mcp $$arg2 $$arg0 $$arg1                ; mcp target src len
.1
cfsi i0                                 ; [fn end: abi_decode_in_place_0] free: locals 0 byte(s), call args 0 slot(s)
popa .0                                 ; [fn end: abi_decode_in_place_0] restore all used registers
jal $zero $$reta i0                     ; [fn end: abi_decode_in_place_0] return from call
DIFF------------------------------
.program:
.4                                      ; --- start of function: main_15 ---
pusha .4                                ; [fn init: main_15]: push all used registers to stack
move $$locbase $sp                      ; [fn init: main_15]: set locals base register
cfei i0                                 ; [fn init: main_15]: allocate: locals 0 byte(s), call args 0 slot(s)
.8
addi $r9 $ssp i8                        ; get address of configurable WRAPPED
lw $r10 $ssp i1                         ; load word
addi $r11 $ssp i0                       ; get address of configurable TUPLE
lw $r12 $ssp i0                         ; load word
add $r13 $r10 $r12
move $$retv $r13                        ; [fn end: main_15] set return value
ji  .5
.5
cfsi i0                                 ; [fn end: main_15] free: locals 0 byte(s), call args 0 slot(s)
popa .4                                 ; [fn end: main_15] restore all used registers
jal $zero $$reta i0                     ; [fn end: main_15] return from call
DIFF------------------------------
.program:
.4                                      ; --- start of function: main_15 ---
pusha .4                                ; [fn init: main_15]: push all used registers to stack
move $$locbase $sp                      ; [fn init: main_15]: set locals base register
cfei i0                                 ; [fn init: main_15]: allocate: locals 0 byte(s), call args 0 slot(s)
.8
lw $r10 $ssp i1                         ; load word
lw $r12 $ssp i0                         ; load word
add $r13 $r10 $r12
move $$retv $r13                        ; [fn end: main_15] set return value
.5
cfsi i0                                 ; [fn end: main_15] free: locals 0 byte(s), call args 0 slot(s)
popa .4                                 ; [fn end: main_15] restore all used registers
jal $zero $$reta i0                     ; [fn end: main_15] return from call
DIFF------------------------------
.program:
.4                                      ; --- start of function: main_15 ---
pusha .4                                ; [fn init: main_15]: push all used registers to stack
move $$locbase $sp                      ; [fn init: main_15]: set locals base register
cfei i0                                 ; [fn init: main_15]: allocate: locals 0 byte(s), call args 0 slot(s)
.8
lw $r10 $ssp i1                         ; load word
lw $r12 $ssp i0                         ; load word
add $r13 $r10 $r12
move $$retv $r13                        ; [fn end: main_15] set return value
.5
cfsi i0                                 ; [fn end: main_15] free: locals 0 byte(s), call args 0 slot(s)
popa .4                                 ; [fn end: main_15] restore all used registers
jal $zero $$reta i0                     ; [fn end: main_15] return from call
DIFF------------------------------
.program:
.4                                      ; --- start of function: main_15 ---
pusha .4                                ; [fn init: main_15]: push all used registers to stack
move $$locbase $sp                      ; [fn init: main_15]: set locals base register
cfei i0                                 ; [fn init: main_15]: allocate: locals 0 byte(s), call args 0 slot(s)
.8
lw $r10 $ssp i1                         ; load word
lw $r12 $ssp i0                         ; load word
add $r13 $r10 $r12
move $$retv $r13                        ; [fn end: main_15] set return value
.5
cfsi i0                                 ; [fn end: main_15] free: locals 0 byte(s), call args 0 slot(s)
popa .4                                 ; [fn end: main_15] restore all used registers
jal $zero $$reta i0                     ; [fn end: main_15] return from call
;; ASM: Final program
;; Program kind: Script
.program:
move $$tmp $pc
jmpf $zero i4
DATA_SECTION_OFFSET[0..32]
DATA_SECTION_OFFSET[32..64]
CONFIGURABLES_OFFSET[0..32]
CONFIGURABLES_OFFSET[32..64]
lw   $$ds $$tmp i1
add  $$ds $$ds $$tmp
cfei i16                      ; allocate stack space for globals
addr $$arg0 data_Configurable_0; get pointer to configurable TUPLE default value
addi $$arg1 $zero i8          ; get length of configurable TUPLE default value
addi $$arg2 $ssp i0           ; get pointer to configurable TUPLE stack address
jal  $$reta $pc i12           ; decode configurable TUPLE
addr $$arg0 data_Configurable_1; get pointer to configurable WRAPPED default value
addi $$arg1 $zero i8          ; get length of configurable WRAPPED default value
addi $$arg2 $ssp i8           ; get pointer to configurable WRAPPED stack address
jal  $$reta $pc i7            ; decode configurable WRAPPED
move $$locbase $sp            ; [entry init: __entry]: set locals base register
cfei i8                       ; [entry init: __entry]: allocate: locals 8 byte(s), call args 0 slot(s)
jal  $$reta $pc i8            ; [call: main_15]: call function
sw   $$locbase $$retv i0      ; store word
movi $r0 i8                   ; initialize constant into register
retd  $$locbase $r0           ; [entry end: __entry] return slice
pshh i524288                  ; [fn init: abi_decode_in_place_0]: push used high registers 40..64
mcp  $$arg2 $$arg0 $$arg1     ; mcp target src len
poph i524288                  ; [fn end: abi_decode_in_place_0]: restore used high registers 40..64
jal  $zero $$reta i0          ; [fn end: abi_decode_in_place_0] return from call
pshl i3                       ; [fn init: main_15]: push used low registers 16..40
pshh i524288                  ; [fn init: main_15]: push used high registers 40..64
lw   $r0 $ssp i1              ; load word
lw   $r1 $ssp i0              ; load word
add  $r0 $r0 $r1
move $$retv $r0               ; [fn end: main_15] set return value
poph i524288                  ; [fn end: main_15]: restore used high registers 40..64
popl i3                       ; [fn end: main_15]: restore used low registers 16..40
jal  $zero $$reta i0          ; [fn end: main_15] return from call
.data:
data_<Configurable, TUPLE>_0 .bytes[8] 00 00 00 00 00 00 00 02  ........
data_<Configurable, WRAPPED>_1 .bytes[8] 00 00 00 00 00 00 00 01  ........


    Finished release [optimized + fuel] target(s) [168 B] in ???
