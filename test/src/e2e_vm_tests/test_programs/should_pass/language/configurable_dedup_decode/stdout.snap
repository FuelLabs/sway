---
source: test/src/snapshot/mod.rs
---
> forc build --path test/src/e2e_vm_tests/test_programs/should_pass/language/configurable_dedup_decode --release --ir final --asm final
exit status: 0
output:
    Building test/src/e2e_vm_tests/test_programs/should_pass/language/configurable_dedup_decode
   Compiling library std (sway-lib-std)
// IR: Final
library {
}

   Compiling script configurable_dedup_decode (test/src/e2e_vm_tests/test_programs/should_pass/language/configurable_dedup_decode)
// IR: Final
script {
    TUPLE = config { u64 }, abi_decode_in_place_0, 0x0000000000000002, !1
    WRAPPED = config { u64 }, abi_decode_in_place_0, 0x0000000000000001, !2

    pub fn abi_decode_in_place_0(ptr !4: ptr, len !5: u64, target !6: ptr) -> (), !10 {
        local { ptr } __anon_0
        local { u64 } __anon_00
        local mut { ptr } buffer
        local { u64 } temp

        entry(ptr: ptr, len: u64, target: ptr):
        v0 = get_local __ptr { ptr }, __anon_0, !14
        v1 = const u64 0
        v2 = get_elem_ptr v0, __ptr ptr, v1, !15
        store ptr to v2, !16
        v3 = get_local __ptr { ptr }, buffer, !17
        mem_copy_val v3, v0
        v4 = get_local __ptr { ptr }, buffer, !18
        v5 = const u64 0
        v6 = get_elem_ptr v4, __ptr ptr, v5, !26
        v7 = load v6, !27
        v8 = asm(ptr: v7, val) -> u64 val, !29 {
            lw     val ptr i0, !30
        }
        v9 = load v6, !31
        v10 = const u64 8, !32
        v11 = add v9, v10, !33
        store v11 to v6, !35
        v12 = get_local __ptr { u64 }, __anon_00, !37
        v13 = const u64 0
        v14 = get_elem_ptr v12, __ptr u64, v13, !38
        store v8 to v14, !39
        v15 = get_local __ptr { u64 }, temp, !40
        mem_copy_val v15, v12
        v16 = get_local __ptr { u64 }, temp, !41
        v17 = cast_ptr v16 to ptr, !42
        v18 = const u64 8
        v19 = asm(target: target, temp: v17, size: v18) -> (), !43 {
            mcp    target temp size, !44
        }
        v20 = const unit ()
        ret () v20
    }

    pub entry fn __entry() -> (), !48 {
        entry():
        v0 = call main_8(), !51
        v1 = call encode_and_return_10(v0), !54
        v2 = const unit ()
        ret () v2
    }

    entry_orig fn main_8() -> u64, !57 {
        entry():
        v0 = get_config __ptr { u64 }, WRAPPED, !58
        v1 = const u64 0
        v2 = get_elem_ptr v0, __ptr u64, v1, !59
        v3 = load v2
        v4 = get_config __ptr { u64 }, TUPLE, !60
        v5 = const u64 0
        v6 = get_elem_ptr v4, __ptr u64, v5, !61
        v7 = load v6
        v8 = add v3, v7, !64
        ret u64 v8
    }

    pub fn encode_and_return_10(item !65: u64) -> (), !68 {
        local u64 item_

        entry(item: u64):
        v0 = get_local __ptr u64, item_
        store item to v0
        v1 = get_local __ptr u64, item_, !69
        v2 = cast_ptr v1 to ptr, !70
        v3 = const u64 8
        retd v2 v3, !71
    }
}

!0 = "test/src/e2e_vm_tests/test_programs/should_pass/language/configurable_dedup_decode/src/main.sw"
!1 = span !0 177 182
!2 = span !0 136 143
!3 = "sway-lib-std/src/codec.sw"
!4 = span !3 79878 79881
!5 = span !3 79892 79895
!6 = span !3 79902 79908
!7 = span !3 79848 80181
!8 = fn_name_span !3 79855 79874
!9 = inline "never"
!10 = (!7 !8 !9)
!11 = span !3 79966 80000
!12 = fn_call_path_span !3 79966 79990
!13 = span !3 735 755
!14 = (!11 !12 !13)
!15 = (!11 !12)
!16 = (!11 !12 !13)
!17 = span !3 79949 80001
!18 = span !3 80031 80037
!19 = span !3 80017 80038
!20 = fn_call_path_span !3 80017 80030
!21 = span !3 123702 123723
!22 = fn_call_path_span !3 123702 123715
!23 = span !3 80630 80658
!24 = fn_call_path_span !3 80637 80649
!25 = span !3 625 637
!26 = (!19 !20 !21 !22 !23 !24 !25)
!27 = (!19 !20 !21 !22 !23 !24)
!28 = span !3 2766 2847
!29 = (!19 !20 !21 !22 !23 !24 !28)
!30 = span !3 2804 2817
!31 = (!19 !20 !21 !22 !23 !24)
!32 = (!19 !20 !21 !22 !23 !24)
!33 = (!19 !20 !21 !22 !23 !24)
!34 = span !3 2857 2896
!35 = (!19 !20 !21 !22 !23 !24 !34)
!36 = span !3 123701 123726
!37 = (!19 !20 !36)
!38 = (!19 !20 !36)
!39 = (!19 !20 !36)
!40 = span !3 80006 80039
!41 = span !3 80097 80101
!42 = span !3 80087 80102
!43 = span !3 80044 80179
!44 = span !3 80152 80172
!45 = "test/src/e2e_vm_tests/test_programs/should_pass/language/configurable_dedup_decode/src/main.<autogenerated>.sw"
!46 = span !45 0 126
!47 = fn_name_span !45 7 14
!48 = (!46 !47)
!49 = span !45 54 60
!50 = fn_call_path_span !45 54 58
!51 = (!49 !50)
!52 = span !45 78 111
!53 = fn_call_path_span !45 78 95
!54 = (!52 !53)
!55 = span !0 202 246
!56 = fn_name_span !0 205 209
!57 = (!55 !56)
!58 = span !0 225 232
!59 = span !0 30 36
!60 = span !0 237 242
!61 = span !0 243 244
!62 = span !0 225 244
!63 = fn_call_path_span !0 235 236
!64 = (!62 !63)
!65 = span !3 79403 79407
!66 = span !3 79375 79637
!67 = fn_name_span !3 79382 79399
!68 = (!66 !67 !9)
!69 = span !3 79496 79500
!70 = span !3 79486 79501
!71 = span !3 79471 79520

;; ASM: Final program
;; Program kind: Script
.program:
move $$tmp $pc
jmpf $zero i4
DATA_SECTION_OFFSET[0..32]
DATA_SECTION_OFFSET[32..64]
CONFIGURABLES_OFFSET[0..32]
CONFIGURABLES_OFFSET[32..64]
lw   $$ds $$tmp i1
add  $$ds $$ds $$tmp
cfei i16                      ; allocate stack space for globals
addr $$arg0 data_Configurable_0; get pointer to configurable TUPLE default value
addi $$arg1 $zero i8          ; get length of configurable TUPLE default value
addi $$arg2 $ssp i0           ; get pointer to configurable TUPLE stack address
jal  $$reta $pc i11           ; decode configurable TUPLE
addr $$arg0 data_Configurable_1; get pointer to configurable WRAPPED default value
addi $$arg1 $zero i8          ; get length of configurable WRAPPED default value
addi $$arg2 $ssp i8           ; get pointer to configurable WRAPPED stack address
jal  $$reta $pc i6            ; decode configurable WRAPPED
move $$locbase $sp            ; save locals base register for function __entry
jal  $$reta $pc i31           ; [call]: call main_8
move $$arg0 $$retv            ; [call]: pass argument 0
jal  $$reta $pc i39           ; [call]: call encode_and_return_10
ret  $zero                    ; return unit as zero
pshl i31                      ; save registers 16..40
pshh i524288                  ; save registers 40..64
move $$locbase $sp            ; save locals base register for function abi_decode_in_place_0
cfei i32                      ; allocate 32 bytes for locals and 0 slots for call arguments
move $r2 $$arg2               ; save argument 2 (target)
move $r3 $$reta               ; save return address
sw   $$locbase $$arg0 i0      ; store word
addi $r0 $$locbase i16        ; get offset to local __ptr { ptr }
mcpi $r0 $$locbase i8         ; copy memory
lw   $r0 $$locbase i2         ; load word
lw   $r4 $r0 i0               ; lw val ptr i0
lw   $r0 $$locbase i2         ; load word
movi $r1 i8                   ; initialize constant into register
add  $r0 $r0 $r1
sw   $$locbase $r0 i2         ; store word
addi $r0 $$locbase i8         ; get offset to local __ptr { u64 }
sw   $$locbase $r4 i1         ; store word
addi $r1 $$locbase i24        ; get offset to local __ptr { u64 }
mcpi $r1 $r0 i8               ; copy memory
addi $r0 $$locbase i24        ; get offset to local __ptr { u64 }
movi $r1 i8                   ; initialize constant into register
mcp  $r2 $r0 $r1              ; mcp target temp size
cfsi i32                      ; free 32 bytes for locals and 0 slots for extra call arguments
move $$reta $r3               ; restore return address
poph i524288                  ; restore registers 40..64
popl i31                      ; restore registers 16..40
jal  $zero $$reta i0          ; return from call
pshl i3                       ; save registers 16..40
pshh i524288                  ; save registers 40..64
move $$locbase $sp            ; save locals base register for function main_8
lw   $r0 $ssp i1              ; load word
lw   $r1 $ssp i0              ; load word
add  $r0 $r0 $r1
move $$retv $r0               ; set return value
poph i524288                  ; restore registers 40..64
popl i3                       ; restore registers 16..40
jal  $zero $$reta i0          ; return from call
pshl i3                       ; save registers 16..40
pshh i524288                  ; save registers 40..64
move $$locbase $sp            ; save locals base register for function encode_and_return_10
cfei i8                       ; allocate 8 bytes for locals and 0 slots for call arguments
move $r0 $$reta               ; save return address
sw   $$locbase $$arg0 i0      ; store word
movi $r1 i8                   ; initialize constant into register
retd  $$locbase $r1
cfsi i8                       ; free 8 bytes for locals and 0 slots for extra call arguments
move $$reta $r0               ; restore return address
poph i524288                  ; restore registers 40..64
popl i3                       ; restore registers 16..40
jal  $zero $$reta i0          ; return from call
.data:
data_<Configurable, TUPLE>_0 .bytes[8] 00 00 00 00 00 00 00 02  ........
data_<Configurable, WRAPPED>_1 .bytes[8] 00 00 00 00 00 00 00 01  ........


    Finished release [optimized + fuel] target(s) [312 B] in ???
