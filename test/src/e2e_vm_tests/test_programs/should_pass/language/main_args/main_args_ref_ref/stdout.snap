---
source: test/src/snapshot/mod.rs
---
Because this test receives and returns a simple struct, we should see decoding loading 
from the `script_data` pointer directly, and encoding just returning a pointer to 
a local variable inside `__entry` stack frame. 

> forc build --path test/src/e2e_vm_tests/test_programs/should_pass/language/main_args/main_args_ref_ref --release --ir final --asm final --bytecode | filter-fn main_args_ref_ref __entry

pub entry fn __entry() -> () {
    local mut { { u64 }, { u64 } } __aggr_memcpy_0
    local { { u64 }, { u64 } } __ret_val
    local { u64 } __tmp_arg
    local { u64 } __tmp_arg0
    local { { u64 }, { u64 } } _result
    local { { u64 }, { u64 } } args
    local { { u64 }, { u64 } } item_

    entry():
    v0 = const u64 0
    v1 = gtf v0, 10
    v2 = bitcast v1 to ptr
    v3 = cast_ptr v2 to __ptr { { u64 }, { u64 } }
    v4 = get_local __ptr { { u64 }, { u64 } }, __aggr_memcpy_0
    mem_copy_val v4, v3
    v5 = get_local __ptr { { u64 }, { u64 } }, args
    mem_copy_val v5, v4
    v6 = get_local __ptr { { u64 }, { u64 } }, args
    v7 = const u64 0
    v8 = get_elem_ptr v6, __ptr { u64 }, v7
    v9 = get_local __ptr { { u64 }, { u64 } }, args
    v10 = const u64 1
    v11 = get_elem_ptr v9, __ptr { u64 }, v10
    v12 = get_local __ptr { u64 }, __tmp_arg
    mem_copy_val v12, v8
    v13 = get_local __ptr { u64 }, __tmp_arg0
    mem_copy_val v13, v11
    v14 = get_local __ptr { { u64 }, { u64 } }, __ret_val
    v15 = call main_8(v12, v13, v14)
    v16 = get_local __ptr { { u64 }, { u64 } }, _result
    mem_copy_val v16, v14
    v17 = get_local __ptr { { u64 }, { u64 } }, _result
    v18 = get_local __ptr { { u64 }, { u64 } }, item_
    mem_copy_val v18, v17
    v19 = get_local __ptr { { u64 }, { u64 } }, item_
    v20 = cast_ptr v19 to ptr
    v21 = const u64 16
    retd v20 v21
}


move $$locbase $sp            ; save locals base register for function __entry
cfei i96                      ; allocate 96 bytes for locals and 0 slots for call arguments
gtf  $r0 $zero i10            ; get transaction field
mcpi $$locbase $r0 i16        ; copy memory
addi $r0 $$locbase i64        ; get offset to local __ptr { { u64 }, { u64 } }
mcpi $r0 $$locbase i16        ; copy memory
addi $r0 $$locbase i64        ; get offset to local __ptr { { u64 }, { u64 } }
addi $r1 $$locbase i64        ; get offset to local __ptr { { u64 }, { u64 } }
addi $r1 $r1 i8               ; get offset to aggregate element
addi $r2 $$locbase i32        ; get offset to local __ptr { u64 }
mcpi $r2 $r0 i8               ; copy memory
addi $r0 $$locbase i40        ; get offset to local __ptr { u64 }
mcpi $r0 $r1 i8               ; copy memory
addi $r1 $$locbase i16        ; get offset to local __ptr { { u64 }, { u64 } }
move $$arg0 $r2               ; [call]: pass argument 0
move $$arg1 $r0               ; [call]: pass argument 1
move $$arg2 $r1               ; [call]: pass argument 2
jal  $$reta $pc i9            ; [call]: call main_8
addi $r0 $$locbase i48        ; get offset to local __ptr { { u64 }, { u64 } }
mcpi $r0 $r1 i16              ; copy memory
addi $r0 $$locbase i48        ; get offset to local __ptr { { u64 }, { u64 } }
addi $r1 $$locbase i80        ; get offset to local __ptr { { u64 }, { u64 } }
mcpi $r1 $r0 i16              ; copy memory
addi $r0 $$locbase i80        ; get offset to local __ptr { { u64 }, { u64 } }
movi $r1 i16                  ; initialize constant into register
retd  $r0 $r1

This is the result using encoding v0 for comparison. 

> forc build --path test/src/e2e_vm_tests/test_programs/should_pass/language/main_args/main_args_ref_ref --release --ir final --asm final --bytecode --no-experimental new_encoding  | filter-fn main_args_ref_ref main

entry entry_orig fn main(baba: __ptr { u64 }, keke: __ptr { u64 }) -> __ptr { { u64 }, { u64 } } {
    local { { u64 }, { u64 } } __anon_2

    entry(baba: __ptr { u64 }, keke: __ptr { u64 }):
    v0 = get_local __ptr { { u64 }, { u64 } }, __anon_2
    v1 = const u64 0
    v2 = get_elem_ptr baba, __ptr u64, v1
    v3 = load v2
    v4 = const u64 0
    v5 = get_elem_ptr keke, __ptr u64, v4
    v6 = load v5
    v7 = add v3, v6
    v8 = const u64 0
    v9 = get_elem_ptr baba, __ptr u64, v8
    v10 = load v9
    v11 = const u64 0
    v12 = get_elem_ptr keke, __ptr u64, v11
    v13 = load v12
    v14 = add v10, v13
    v15 = get_local __ptr { { u64 }, { u64 } }, __anon_2
    v16 = const u64 0
    v17 = get_elem_ptr v15, __ptr { u64 }, v16
    v18 = const u64 0
    v19 = get_elem_ptr v17, __ptr u64, v18
    store v7 to v19
    v20 = const u64 1
    v21 = get_elem_ptr v15, __ptr { u64 }, v20
    v22 = const u64 0
    v23 = get_elem_ptr v21, __ptr u64, v22
    store v14 to v23
    ret __ptr { { u64 }, { u64 } } v0
}


add  $$ds $$ds $$tmp
cfei i0                       ; allocate stack space for globals
move $$locbase $sp            ; save locals base register for function main
cfei i16                      ; allocate 16 bytes for locals and 0 slots for call arguments
gtf  $r0 $zero i10            ; get base register for main function arguments
addi $r1 $r0 i0               ; get offset of argument baba
addi $r0 $r0 i8               ; get offset of argument keke
lw   $r2 $r1 i0               ; load word
lw   $r3 $r0 i0               ; load word
add  $r2 $r2 $r3
lw   $r1 $r1 i0               ; load word
lw   $r0 $r0 i0               ; load word
add  $r0 $r1 $r0
sw   $$locbase $r2 i0         ; store word
sw   $$locbase $r0 i1         ; store word
movi $r0 i16                  ; get size of type returned by pointer
retd  $$locbase $r0
