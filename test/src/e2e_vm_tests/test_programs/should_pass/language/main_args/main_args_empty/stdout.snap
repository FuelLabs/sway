---
source: test/src/snapshot/mod.rs
---
> forc build --path test/src/e2e_vm_tests/test_programs/should_pass/language/main_args/main_args_empty --release --ir final --asm final
exit status: 0
output:
    Building test/src/e2e_vm_tests/test_programs/should_pass/language/main_args/main_args_empty
   Compiling library std (test/src/e2e_vm_tests/reduced_std_libs/sway-lib-std-core)
// IR: Final
library {
}

   Compiling script main_args_empty (test/src/e2e_vm_tests/test_programs/should_pass/language/main_args/main_args_empty)
// IR: Final
script {
    pub entry fn __entry() -> __ptr slice, !3 {
        local mut slice __aggr_memcpy_0
        local { u64, u64 } __anon_0
        local slice __ret_value

        entry():
        v0 = get_local __ptr slice, __ret_value
        v1 = call main_0(), !6
        v2 = get_local __ptr { u64, u64 }, __anon_0, !7
        v3 = const u64 0
        v4 = get_elem_ptr v2, __ptr u64, v3, !7
        v5 = const u64 0, !8
        store v5 to v4, !7
        v6 = const u64 1
        v7 = get_elem_ptr v2, __ptr u64, v6, !7
        v8 = const u64 0, !9
        store v8 to v7, !7
        v9 = asm(s: v2) -> __ptr slice s {
        }
        v10 = get_local __ptr slice, __aggr_memcpy_0
        mem_copy_val v10, v9
        mem_copy_val v0, v10
        ret __ptr slice v0
    }

    entry_orig fn main_0() -> (), !13 {
        local slice __ret_val

        entry():
        v0 = get_local __ptr slice, __ret_val
        v1 = call f3_1(v0)
        v2 = const unit ()
        ret () v2
    }

    fn f3_1(__ret_value: __ptr slice) -> (), !17 {
        entry(__ret_value: __ptr slice):
        v0 = const u64 0, !18
        v1 = asm(size: v0) -> ptr hp, !19 {
            aloc   size, !20
        }
        v2 = cast_ptr __ret_value to __ptr { ptr, u64 }
        v3 = const u64 0
        v4 = get_elem_ptr v2, __ptr ptr, v3, !21
        store v1 to v4, !21
        v5 = const u64 1
        v6 = get_elem_ptr v2, __ptr u64, v5, !21
        v7 = const u64 0, !22
        store v7 to v6, !21
        v8 = const unit ()
        ret () v8
    }
}

!0 = "test/src/e2e_vm_tests/test_programs/should_pass/language/main_args/main_args_empty/src/main.<autogenerated>.sw"
!1 = span !0 0 135
!2 = fn_name_span !0 7 14
!3 = (!1 !2)
!4 = span !0 66 72
!5 = fn_call_path_span !0 66 70
!6 = (!4 !5)
!7 = span !0 97 103
!8 = span !0 98 99
!9 = span !0 101 102
!10 = "test/src/e2e_vm_tests/test_programs/should_pass/language/main_args/main_args_empty/src/main.sw"
!11 = span !10 182 205
!12 = fn_name_span !10 185 189
!13 = (!11 !12)
!14 = span !10 26 180
!15 = fn_name_span !10 29 31
!16 = inline "never"
!17 = (!14 !15 !16)
!18 = span !10 73 74
!19 = span !10 63 122
!20 = span !10 86 95
!21 = span !10 169 177
!22 = span !10 175 176

;; ASM: Final program
;; Program kind: Script
.program:
move $$tmp $pc
jmpf $zero i4
DATA_SECTION_OFFSET[0..32]
DATA_SECTION_OFFSET[32..64]
CONFIGURABLES_OFFSET[0..32]
CONFIGURABLES_OFFSET[32..64]
lw   $$ds $$tmp i1
add  $$ds $$ds $$tmp
cfei i0                       ; allocate stack space for globals
move $$locbase $sp            ; save locals base register for function __entry
cfei i48                      ; allocate 48 bytes for locals and 0 slots for call arguments
addi $r0 $$locbase i32        ; get offset to local __ptr slice
jal  $$reta $pc i9            ; [call]: call main_0
addi $r1 $$locbase i16        ; get offset to local __ptr { u64, u64 }
sw   $$locbase $zero i2       ; store word
sw   $$locbase $zero i3       ; store word
mcpi $$locbase $r1 i16        ; copy memory
mcpi $r0 $$locbase i16        ; copy memory
lw   $r1 $r0 i1               ; load size of returned slice
lw   $r0 $r0 i0               ; load pointer to returned slice
retd  $r0 $r1
pshl i1                       ; save registers 16..40
pshh i524288                  ; save registers 40..64
move $$locbase $sp            ; save locals base register for function main_0
cfei i16                      ; allocate 16 bytes for locals and 0 slots for call arguments
move $r0 $$reta               ; save return address
move $$arg0 $$locbase         ; [call]: pass argument 0
jal  $$reta $pc i6            ; [call]: call f3_1
cfsi i16                      ; free 16 bytes for locals and 0 slots for extra call arguments
move $$reta $r0               ; restore return address
poph i524288                  ; restore registers 40..64
popl i1                       ; restore registers 16..40
jal  $zero $$reta i0          ; return from call
pshl i3                       ; save registers 16..40
pshh i524288                  ; save registers 40..64
move $$locbase $sp            ; save locals base register for function f3_1
move $r0 $$arg0               ; save argument 0 (__ret_value)
move $r1 $$reta               ; save return address
aloc $zero                    ; aloc size
sw   $r0 $hp i0               ; store word
sw   $r0 $zero i1             ; store word
move $$reta $r1               ; restore return address
poph i524288                  ; restore registers 40..64
popl i3                       ; restore registers 16..40
jal  $zero $$reta i0          ; return from call
.data:


warning: Returned value is ignored
  --> test/src/e2e_vm_tests/test_programs/should_pass/language/main_args/main_args_empty/src/main.sw:13:5
   |
...
13 |     f3();
   |     ---- This returns a value which is not assigned to anything and is ignored.
   |     ---- help: The returned value has type "raw_slice".
   |
   = help: If you want to intentionally ignore the returned value, use `let _ = ...`:
   = help:   let _ = f3();
____

  Compiled script "main_args_empty" with 1 warning.
    Finished release [optimized + fuel] target(s) [176 B] in ???
