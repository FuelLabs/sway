---
source: test/src/snapshot/mod.rs
---
> forc build --path test/src/e2e_vm_tests/test_programs/should_pass/language/logging --release --ir final
exit status: 0
output:
    Building test/src/e2e_vm_tests/test_programs/should_pass/language/logging
   Compiling library std (test/src/e2e_vm_tests/reduced_std_libs/sway-lib-std-vec)
// IR: Final
library {
}

DIFF------------------------------
.program:
DIFF------------------------------
.program:
   Compiling script logging (test/src/e2e_vm_tests/test_programs/should_pass/language/logging)
// IR: Final
script {
    global __const_global : string<4> = const string<4> "sway"

    pub entry fn __entry() -> __ptr never, !3 {
        local u64 _result

        entry():
        v1376v1 = call main_0(), !6
        v1377v1 = get_local __ptr u64, _result, !7
        store v1376v1 to v1377v1, !7
        v1396v1 = get_local __ptr u64, _result, !8
        v1387v1 = const u64 8
        retd v1396v1 v1387v1, !13
    }

    entry_orig fn main_0() -> u64, !17 {
        local { ptr, u64 } __anon_0
        local slice __anon_1
        local u256 __const = const u256 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff
        local { ptr, u64 } __struct_init_000
        local { u64 } __struct_init_2
        local { u64, u64, u64, u8, { { ptr, u64 }, u64 }, slice, u256 } __tmp_arg
        local { u64 } __tmp_arg0
        local { u64, ( { u64 } | () ) } __tmp_arg1
        local { u64, ( { u64 } | () ) } __tmp_arg2
        local {  } __tmp_arg3
        local mut { { ptr, u64 }, u64 } e

        entry():
        v3720v1 = get_local __ptr u256, __const
        v163v1 = const u64 0, !18
        v164v1 = call local_log_1(v163v1), !21
        v3695v1 = get_local __ptr { { ptr, u64 }, u64 }, e, !26
        v3696v1 = get_local __ptr { ptr, u64 }, __struct_init_000, !30
        v174v1 = const u64 0, !31
        v3699v1 = alloc u64 x v174v1, !36
        v1457v1 = const u64 0
        v3701v1 = get_elem_ptr v3696v1, __ptr ptr, v1457v1, !37
        store v3699v1 to v3701v1, !38
        v1460v1 = const u64 1
        v3703v1 = get_elem_ptr v3696v1, __ptr u64, v1460v1, !39
        v176v1 = const u64 0, !40
        store v176v1 to v3703v1, !41
        v1451v1 = const u64 0
        v3707v1 = get_elem_ptr v3695v1, __ptr { ptr, u64 }, v1451v1, !42
        mem_copy_val v3707v1, v3696v1
        v1454v1 = const u64 1
        v3709v1 = get_elem_ptr v3695v1, __ptr u64, v1454v1, !43
        v181v1 = const u64 0, !44
        store v181v1 to v3709v1, !45
        v469v1 = get_local __ptr { { ptr, u64 }, u64 }, e, !46
        v471v1 = const u64 1, !47
        v472v1 = call push_11(v469v1, v471v1), !50
        v473v1 = get_local __ptr { { ptr, u64 }, u64 }, e, !51
        v475v1 = const u64 2, !52
        v476v1 = call push_11(v473v1, v475v1), !55
        v477v1 = get_local __ptr { { ptr, u64 }, u64 }, e, !56
        v479v1 = const u64 3, !57
        v480v1 = call push_11(v477v1, v479v1), !60
        v1065v1 = get_local __ptr { u64, u64, u64, u8, { { ptr, u64 }, u64 }, slice, u256 }, __tmp_arg, !61
        v1070v1 = get_local __ptr { { ptr, u64 }, u64 }, e, !62
        v1073v1 = get_global __ptr string<4>, __const_global
        v1074v1 = cast_ptr v1073v1 to ptr, !63
        v1076v1 = get_local __ptr { ptr, u64 }, __anon_0, !63
        v1077v1 = const u64 0
        v1078v1 = get_elem_ptr v1076v1, __ptr ptr, v1077v1
        store v1074v1 to v1078v1, !63
        v1080v1 = const u64 1
        v1081v1 = get_elem_ptr v1076v1, __ptr u64, v1080v1
        v1075v1 = const u64 4
        store v1075v1 to v1081v1, !63
        v1083v1 = get_local __ptr slice, __anon_1, !63
        mem_copy_bytes v1083v1, v1076v1, 16
        v1418v1 = const u64 0
        v1419v1 = get_elem_ptr v1065v1, __ptr u64, v1418v1, !61
        v1066v1 = const u64 1, !64
        store v1066v1 to v1419v1, !61
        v1421v1 = const u64 1
        v1422v1 = get_elem_ptr v1065v1, __ptr u64, v1421v1, !61
        v1067v1 = const u64 2, !65
        store v1067v1 to v1422v1, !61
        v1424v1 = const u64 2
        v1425v1 = get_elem_ptr v1065v1, __ptr u64, v1424v1, !61
        v1068v1 = const u64 3, !66
        store v1068v1 to v1425v1, !61
        v1427v1 = const u64 3
        v1428v1 = get_elem_ptr v1065v1, __ptr u8, v1427v1, !61
        v1069v1 = const u8 4, !67
        store v1069v1 to v1428v1, !61
        v1430v1 = const u64 4
        v1431v1 = get_elem_ptr v1065v1, __ptr { { ptr, u64 }, u64 }, v1430v1, !61
        mem_copy_val v1431v1, v1070v1
        v1433v1 = const u64 5
        v1434v1 = get_elem_ptr v1065v1, __ptr slice, v1433v1, !61
        mem_copy_val v1434v1, v1083v1
        v1436v1 = const u64 6
        v1437v1 = get_elem_ptr v1065v1, __ptr u256, v1436v1, !61
        mem_copy_val v1437v1, v3720v1
        v3758v1 = get_local __ptr { u64, u64, u64, u8, { { ptr, u64 }, u64 }, slice, u256 }, __tmp_arg
        v3760v1 = call local_log_21(v3758v1)
        v1163v1 = get_local __ptr { u64 }, __tmp_arg0, !68
        v1415v1 = const u64 0
        v1416v1 = get_elem_ptr v1163v1, __ptr u64, v1415v1, !68
        v1164v1 = const u64 1, !69
        store v1164v1 to v1416v1, !68
        v3769v1 = get_local __ptr { u64 }, __tmp_arg0
        v3771v1 = call local_log_48(v3769v1)
        v1292v1 = get_local __ptr { u64, ( { u64 } | () ) }, __tmp_arg1, !70
        v1293v1 = const u64 0
        v1294v1 = get_elem_ptr v1292v1, __ptr u64, v1293v1, !70
        v1291v1 = const u64 0, !70
        store v1291v1 to v1294v1, !70
        v1296v1 = get_local __ptr { u64 }, __struct_init_2, !71
        v1412v1 = const u64 0
        v1413v1 = get_elem_ptr v1296v1, __ptr u64, v1412v1, !71
        v1297v1 = const u64 1, !72
        store v1297v1 to v1413v1, !71
        v1300v1 = const u64 1
        v1301v1 = const u64 0
        v1302v1 = get_elem_ptr v1292v1, __ptr { u64 }, v1300v1, v1301v1, !70
        mem_copy_val v1302v1, v1296v1
        v3783v1 = get_local __ptr { u64, ( { u64 } | () ) }, __tmp_arg1
        v3785v1 = call local_log_53(v3783v1)
        v1307v1 = get_local __ptr { u64, ( { u64 } | () ) }, __tmp_arg2, !70
        v1308v1 = const u64 0
        v1309v1 = get_elem_ptr v1307v1, __ptr u64, v1308v1, !70
        v1306v1 = const u64 1, !70
        store v1306v1 to v1309v1, !70
        v3786v1 = get_local __ptr { u64, ( { u64 } | () ) }, __tmp_arg2
        v3788v1 = call local_log_53(v3786v1)
        v3803v1 = get_local __ptr {  }, __tmp_arg3
        v3805v1 = call local_log_60(v3803v1)
        v1374v1 = const u64 1, !73
        ret u64 v1374v1
    }

    fn local_log_1(item !74: u64) -> (), !78 {
        local { __ptr u64, u64 } __anon_0
        local slice __log_arg
        local u64 item_

        entry(item: u64):
        v15v1 = get_local __ptr u64, item_
        store item to v15v1
        v156v1 = get_local __ptr u64, item_, !79
        v1525v1 = get_local __ptr { __ptr u64, u64 }, __anon_0, !81
        v1439v1 = const u64 0
        v1528v1 = get_elem_ptr v1525v1, __ptr __ptr u64, v1439v1, !82
        store v156v1 to v1528v1, !83
        v1442v1 = const u64 1
        v1530v1 = get_elem_ptr v1525v1, __ptr u64, v1442v1, !84
        v25v1 = const u64 8
        store v25v1 to v1530v1, !85
        v1533v1 = get_local __ptr { __ptr u64, u64 }, __anon_0, !79
        v1535v1 = cast_ptr v1533v1 to __ptr slice, !79
        v3865v1 = get_local __ptr slice, __log_arg
        mem_copy_val v3865v1, v1535v1
        v158v1 = const u64 1515152261580153489
        log __ptr slice v3865v1, v158v1
        v161v1 = const unit ()
        ret () v161v1
    }

    pub fn abi_encode_5(self !86: u64, buffer: __ptr { { ptr, u64, u64 } }, __ret_value: __ptr { { ptr, u64, u64 } }) -> (), !89 {
        local mut { ptr, u64, u64 } __aggr_memcpy_0
        local mut { ptr, u64, u64 } __aggr_memcpy_00
        local { ptr, u64, u64 } __anon_0
        local { ptr, u64, u64 } __anon_1
        local { { ptr, u64, u64 } } __struct_init_0
        local { { ptr, u64, u64 } } buffer_

        entry(self: u64, buffer: __ptr { { ptr, u64, u64 } }, __ret_value: __ptr { { ptr, u64, u64 } }):
        v43v1 = get_local __ptr { { ptr, u64, u64 } }, buffer_
        mem_copy_val v43v1, buffer
        v45v1 = get_local __ptr { { ptr, u64, u64 } }, __struct_init_0, !90
        v46v1 = get_local __ptr { { ptr, u64, u64 } }, buffer_, !91
        v47v1 = const u64 0
        v48v1 = get_elem_ptr v46v1, __ptr { ptr, u64, u64 }, v47v1, !92
        v3868v1 = asm(buffer: v48v1) -> __ptr { ptr, u64, u64 } buffer {
        }
        v3926v1 = get_local __ptr { ptr, u64, u64 }, __aggr_memcpy_0
        mem_copy_val v3926v1, v3868v1
        v51v1 = get_local __ptr { ptr, u64, u64 }, __anon_0
        mem_copy_val v51v1, v3926v1
        v53v1 = const u64 0
        v54v1 = get_elem_ptr v51v1, __ptr ptr, v53v1
        v55v1 = load v54v1
        v56v1 = const u64 1
        v57v1 = get_elem_ptr v51v1, __ptr u64, v56v1
        v58v1 = load v57v1
        v59v1 = const u64 2
        v60v1 = get_elem_ptr v51v1, __ptr u64, v59v1
        v61v1 = load v60v1
        v64v1 = const u64 8
        v67v1 = add v61v1, v64v1
        v68v1 = cmp gt v67v1 v58v1
        cbr v68v1, block1(), block0(v55v1, v58v1)

        block0(v65v1: ptr, v66v1: u64):
        v76v1 = add v65v1, v61v1
        v77v1 = cast_ptr v76v1 to __ptr u64
        store self to v77v1
        v81v1 = get_local __ptr { ptr, u64, u64 }, __anon_1
        v82v1 = const u64 0
        v83v1 = get_elem_ptr v81v1, __ptr ptr, v82v1
        store v65v1 to v83v1
        v85v1 = const u64 1
        v86v1 = get_elem_ptr v81v1, __ptr u64, v85v1
        store v66v1 to v86v1
        v88v1 = const u64 2
        v89v1 = get_elem_ptr v81v1, __ptr u64, v88v1
        store v67v1 to v89v1
        v3870v1 = asm(buffer: v81v1) -> __ptr { ptr, u64, u64 } buffer {
        }
        v3929v1 = get_local __ptr { ptr, u64, u64 }, __aggr_memcpy_00
        mem_copy_val v3929v1, v3870v1
        v1445v1 = const u64 0
        v1446v1 = get_elem_ptr v45v1, __ptr { ptr, u64, u64 }, v1445v1, !90
        mem_copy_val v1446v1, v3929v1
        mem_copy_val __ret_value, v45v1
        v3809v1 = const unit ()
        ret () v3809v1

        block1():
        v70v1 = const u64 2
        v71v1 = mul v58v1, v70v1
        v72v1 = add v71v1, v64v1
        v73v1 = asm(new_cap: v72v1, old_ptr: v55v1, len: v61v1) -> __ptr u8 hp {
            aloc   new_cap
            mcp    hp old_ptr len
        }
        br block0(v73v1, v72v1)
    }

    pub fn new_6(__ret_value: __ptr { { ptr, u64, u64 } }) -> (), !95 {
        local mut { ptr, u64, u64 } __aggr_memcpy_0
        local { ptr, u64, u64 } __anon_0
        local { { ptr, u64, u64 } } __struct_init_0

        entry(__ret_value: __ptr { { ptr, u64, u64 } }):
        v98v1 = get_local __ptr { { ptr, u64, u64 } }, __struct_init_0, !96
        v99v1 = const u64 1024
        v100v1 = asm(cap: v99v1) -> ptr hp {
            aloc   cap
        }
        v102v1 = get_local __ptr { ptr, u64, u64 }, __anon_0
        v103v1 = const u64 0
        v104v1 = get_elem_ptr v102v1, __ptr ptr, v103v1
        store v100v1 to v104v1
        v106v1 = const u64 1
        v107v1 = get_elem_ptr v102v1, __ptr u64, v106v1
        store v99v1 to v107v1
        v109v1 = const u64 2
        v110v1 = get_elem_ptr v102v1, __ptr u64, v109v1
        v101v1 = const u64 0
        store v101v1 to v110v1
        v3872v1 = asm(buffer: v102v1) -> __ptr { ptr, u64, u64 } buffer {
        }
        v3933v1 = get_local __ptr { ptr, u64, u64 }, __aggr_memcpy_0
        mem_copy_val v3933v1, v3872v1
        v1448v1 = const u64 0
        v1449v1 = get_elem_ptr v98v1, __ptr { ptr, u64, u64 }, v1448v1, !96
        mem_copy_val v1449v1, v3933v1
        mem_copy_val __ret_value, v98v1
        v3834v1 = const unit ()
        ret () v3834v1
    }

    pub fn as_raw_slice_7(self: __ptr { { ptr, u64, u64 } }, __ret_value: __ptr slice) -> (), !99 {
        local mut slice __aggr_memcpy_00
        local { ptr, u64 } __anon_1
        local { { ptr, u64, u64 } } self_

        entry(self: __ptr { { ptr, u64, u64 } }, __ret_value: __ptr slice):
        v121v1 = get_local __ptr { { ptr, u64, u64 } }, self_
        mem_copy_val v121v1, self
        v123v1 = get_local __ptr { { ptr, u64, u64 } }, self_, !100
        v124v1 = const u64 0
        v125v1 = get_elem_ptr v123v1, __ptr { ptr, u64, u64 }, v124v1, !92
        v3874v1 = asm(buffer: v125v1) -> __ptr { ptr, u64, u64 } buffer {
        }
        v4042v1 = const u64 0
        v4043v1 = get_elem_ptr v3874v1, __ptr ptr, v4042v1
        v4044v1 = load v4043v1
        v4048v1 = const u64 2
        v4049v1 = get_elem_ptr v3874v1, __ptr u64, v4048v1
        v4050v1 = load v4049v1
        v139v1 = get_local __ptr { ptr, u64 }, __anon_1
        v140v1 = const u64 0
        v141v1 = get_elem_ptr v139v1, __ptr ptr, v140v1
        store v4044v1 to v141v1
        v143v1 = const u64 1
        v144v1 = get_elem_ptr v139v1, __ptr u64, v143v1
        store v4050v1 to v144v1
        v3876v1 = asm(s: v139v1) -> __ptr slice s {
        }
        v3943v1 = get_local __ptr slice, __aggr_memcpy_00
        mem_copy_val v3943v1, v3876v1
        mem_copy_val __ret_value, v3943v1
        v3847v1 = const unit ()
        ret () v3847v1
    }

    pub fn push_11(self !101: __ptr { { ptr, u64 }, u64 }, value !102: u64) -> (), !105 {
        entry(self: __ptr { { ptr, u64 }, u64 }, value: u64):
        v207v1 = const u64 1
        v208v1 = get_elem_ptr self, __ptr u64, v207v1, !106
        v209v1 = load v208v1
        v211v1 = const u64 0
        v212v1 = get_elem_ptr self, __ptr { ptr, u64 }, v211v1, !107
        v213v1 = const u64 1
        v214v1 = get_elem_ptr v212v1, __ptr u64, v213v1, !108
        v215v1 = load v214v1
        v1675v1 = cmp eq v209v1 v215v1, !111
        cbr v1675v1, block0(), block2(), !109

        block0():
        v1691v1 = load v214v1, !114
        v224v1 = const u64 0, !115
        v1696v1 = cmp eq v1691v1 v224v1, !118
        v226v1 = const u64 1, !119
        cbr v1696v1, grow_13_block2(v226v1), grow_13_block1(), !120

        grow_13_block1():
        v1701v1 = load v214v1, !114
        v239v1 = const u64 2, !121
        v1706v1 = mul v239v1, v1701v1, !124
        br grow_13_block2(v1706v1), !114

        grow_13_block2(v1679v1: u64):
        v334v1 = const u64 0
        v1712v1 = get_elem_ptr v212v1, __ptr ptr, v334v1, !126
        v1713v1 = load v1712v1, !114
        v1716v1 = load v214v1, !114
        v1727v1 = cmp gt v1679v1 v1716v1, !131
        cbr v1727v1, grow_13_realloc_15_block0(), grow_13_realloc_15_block5(v1713v1), !132

        grow_13_realloc_15_block0():
        v1735v1 = alloc u64 x v1679v1, !135
        v284v1 = const u64 0, !136
        v1743v1 = cmp gt v1716v1 v284v1, !139
        cbr v1743v1, grow_13_realloc_15_block1(), grow_13_realloc_15_block5(v1735v1), !140

        grow_13_realloc_15_block1():
        v297v1 = const u64 8
        v1758v1 = mul v1716v1, v297v1, !146
        v1764v1 = asm(dst: v1735v1, src: v1713v1, len: v1758v1) -> (), !148 {
            mcp    dst src len, !149
        }
        br grow_13_realloc_15_block5(v1735v1), !150

        grow_13_realloc_15_block5(v1686v1: ptr):
        store v1686v1 to v1712v1, !152
        store v1679v1 to v214v1, !154
        br block2()

        block2():
        v387v1 = const u64 0
        v388v1 = get_elem_ptr v212v1, __ptr ptr, v387v1, !125
        v389v1 = load v388v1
        v393v1 = load v208v1
        v376v1 = const u64 8
        v1782v1 = mul v376v1, v393v1, !157
        v1783v1 = add v389v1, v1782v1, !157
        v1800v1 = asm(ptr: v1783v1, val: value) -> (), !161 {
            sw     ptr val i0, !162
        }
        v458v1 = load v208v1
        v459v1 = const u64 1, !163
        v1817v1 = add v458v1, v459v1, !166
        store v1817v1 to v208v1, !164
        v467v1 = const unit ()
        ret () v467v1
    }

    fn local_log_21(item: __ptr { u64, u64, u64, u8, { { ptr, u64 }, u64 }, slice, u256 }) -> (), !167 {
        local mut { ptr, u64, u64 } __aggr_memcpy_0
        local mut { ptr, u64, u64 } __aggr_memcpy_00
        local mut { ptr, u64, u64 } __aggr_memcpy_01
        local mut { ptr, u64, u64 } __aggr_memcpy_010
        local mut { ptr, u64, u64 } __aggr_memcpy_02
        local mut { ptr, u64, u64 } __aggr_memcpy_03
        local mut { ptr, u64, u64 } __aggr_memcpy_04
        local mut { ptr, u64, u64 } __aggr_memcpy_05
        local mut { u64, u64 } __aggr_memcpy_06
        local mut slice __aggr_memcpy_07
        local mut { ptr, u64, u64 } __aggr_memcpy_08
        local mut { ptr, u64, u64 } __aggr_memcpy_09
        local { __ptr { u64, u64, u64, u8, { { ptr, u64 }, u64 }, slice, u256 }, u64 } __anon_0
        local { ptr, u64, u64 } __anon_00
        local { ptr, u64, u64 } __anon_000
        local { ptr, u64, u64 } __anon_01
        local { ptr, u64, u64 } __anon_02
        local { ptr, u64, u64 } __anon_03
        local u64 __anon_1
        local u64 __anon_10
        local { ptr, u64, u64 } __anon_11
        local { u64, u64 } __anon_12
        local u256 __anon_13
        local { ptr, u64, u64 } __anon_2
        local { ptr, u64, u64 } __anon_20
        local slice __anon_21
        local { ptr, u64, u64 } __anon_22
        local { ptr, u64, u64 } __anon_3
        local slice __log_arg
        local { { ptr, u64, u64 } } __ret_val
        local { { ptr, u64, u64 } } __ret_val0
        local { { ptr, u64, u64 } } __ret_val1
        local { { ptr, u64, u64 } } __ret_val2
        local slice __ret_val3
        local { { ptr, u64, u64 } } __struct_init_0
        local { { ptr, u64, u64 } } __struct_init_00
        local { { ptr, u64, u64 } } __struct_init_01
        local { { ptr, u64, u64 } } __struct_init_02
        local { { ptr, u64, u64 } } __struct_init_03
        local { { ptr, u64, u64 } } __tmp_arg
        local { { ptr, u64, u64 } } __tmp_arg0
        local { { ptr, u64, u64 } } __tmp_arg1
        local { { ptr, u64, u64 } } __tmp_arg2
        local slice __tmp_block_arg
        local { __ptr { u64, u64, u64, u8, { { ptr, u64 }, u64 }, slice, u256 }, u64 } __tuple_init_0
        local { { ptr, u64, u64 } } buffer
        local { { ptr, u64, u64 } } buffer_
        local { { ptr, u64, u64 } } buffer_0
        local { { ptr, u64, u64 } } buffer_1
        local { { ptr, u64, u64 } } buffer_2
        local { { ptr, u64, u64 } } buffer_3
        local { { ptr, u64, u64 } } buffer_4
        local { { ptr, u64, u64 } } buffer_5
        local { { ptr, u64, u64 } } buffer__
        local mut { { ptr, u64, u64 } } buffer__0
        local { { ptr, u64, u64 } } buffer___
        local { { ptr, u64, u64 } } buffer____
        local { { ptr, u64, u64 } } buffer_____
        local { { ptr, u64, u64 } } buffer______
        local { { ptr, u64, u64 } } buffer_______
        local { { ptr, u64, u64 } } buffer________
        local { u64, u64, u64, u8, { { ptr, u64 }, u64 }, slice, u256 } item_
        local { u64, u64, u64, u8, { { ptr, u64 }, u64 }, slice, u256 } self_0
        local { { ptr, u64 }, u64 } self_10
        local { { ptr, u64 }, u64 } self_3
        local slice self_4
        local u256 self_5

        entry(item: __ptr { u64, u64, u64, u8, { { ptr, u64 }, u64 }, slice, u256 }):
        v482v1 = get_local __ptr { u64, u64, u64, u8, { { ptr, u64 }, u64 }, slice, u256 }, item_
        mem_copy_val v482v1, item
        v1058v1 = get_local __ptr { u64, u64, u64, u8, { { ptr, u64 }, u64 }, slice, u256 }, item_, !79
        v2827v1 = const bool false, !174
        cbr v2827v1, encode_allow_alias_22_is_encode_trivial_23_is_encode_trivial_24_block4(), encode_allow_alias_22_is_encode_trivial_23_is_encode_trivial_24_block5(v2827v1), !176

        encode_allow_alias_22_is_encode_trivial_23_is_encode_trivial_24_block4():
        v520v1 = const bool false, !177
        br encode_allow_alias_22_is_encode_trivial_23_is_encode_trivial_24_block5(v520v1), !178

        encode_allow_alias_22_is_encode_trivial_23_is_encode_trivial_24_block5(v2780v1: bool):
        cbr v2780v1, encode_allow_alias_22_is_encode_trivial_23_is_encode_trivial_24_block6(), encode_allow_alias_22_is_encode_trivial_23_is_encode_trivial_24_block7(v2780v1), !180

        encode_allow_alias_22_is_encode_trivial_23_is_encode_trivial_24_block6():
        v512v1 = const bool true, !181
        br encode_allow_alias_22_is_encode_trivial_23_is_encode_trivial_24_block7(v512v1), !182

        encode_allow_alias_22_is_encode_trivial_23_is_encode_trivial_24_block7(v2783v1: bool):
        cbr v2783v1, encode_allow_alias_22_is_encode_trivial_23_is_encode_trivial_24_block8(), encode_allow_alias_22_is_encode_trivial_23_is_encode_trivial_24_block9(v2783v1), !184

        encode_allow_alias_22_is_encode_trivial_23_is_encode_trivial_24_block8():
        br encode_allow_alias_22_is_encode_trivial_23_is_encode_trivial_24_block9(v520v1), !185

        encode_allow_alias_22_is_encode_trivial_23_is_encode_trivial_24_block9(v2786v1: bool):
        cbr v2786v1, encode_allow_alias_22_is_encode_trivial_23_is_encode_trivial_24_block10(), encode_allow_alias_22_is_encode_trivial_23_is_encode_trivial_24_block11(v2786v1), !187

        encode_allow_alias_22_is_encode_trivial_23_is_encode_trivial_24_block10():
        br encode_allow_alias_22_is_encode_trivial_23_is_encode_trivial_24_block11(v520v1), !188

        encode_allow_alias_22_is_encode_trivial_23_is_encode_trivial_24_block11(v2789v1: bool):
        cbr v2789v1, encode_allow_alias_22_is_encode_trivial_23_is_encode_trivial_24_block12(), encode_allow_alias_22_is_encode_trivial_23_is_encode_trivial_24_block13(v2789v1), !190

        encode_allow_alias_22_is_encode_trivial_23_is_encode_trivial_24_block12():
        br encode_allow_alias_22_is_encode_trivial_23_is_encode_trivial_24_block13(v512v1), !191

        encode_allow_alias_22_is_encode_trivial_23_is_encode_trivial_24_block13(v2792v1: bool):
        cbr v2792v1, encode_allow_alias_22_block0(), encode_allow_alias_22_block1(), !192

        encode_allow_alias_22_block0():
        v3236v1 = get_local __ptr { __ptr { u64, u64, u64, u8, { { ptr, u64 }, u64 }, slice, u256 }, u64 }, __tuple_init_0, !193
        v1463v1 = const u64 0
        v3239v1 = get_elem_ptr v3236v1, __ptr __ptr { u64, u64, u64, u8, { { ptr, u64 }, u64 }, slice, u256 }, v1463v1, !194
        store v1058v1 to v3239v1, !195
        v1466v1 = const u64 1
        v3241v1 = get_elem_ptr v3236v1, __ptr u64, v1466v1, !196
        v546v1 = const u64 104
        store v546v1 to v3241v1, !197
        v3244v1 = get_local __ptr { __ptr { u64, u64, u64, u8, { { ptr, u64 }, u64 }, slice, u256 }, u64 }, __anon_0, !79
        mem_copy_val v3244v1, v3236v1
        v3246v1 = cast_ptr v3244v1 to __ptr slice, !79
        v3765v1 = get_local __ptr slice, __tmp_block_arg
        mem_copy_val v3765v1, v3246v1
        br encode_allow_alias_22_block2(v3765v1), !79

        encode_allow_alias_22_block1():
        v3836v1 = get_local __ptr { { ptr, u64, u64 } }, __ret_val2
        v3837v1 = call new_6(v3836v1)
        v2863v1 = get_local __ptr { u64, u64, u64, u8, { { ptr, u64 }, u64 }, slice, u256 }, self_0, !200
        mem_copy_val v2863v1, v1058v1
        v2865v1 = get_local __ptr { { ptr, u64, u64 } }, buffer_, !201
        mem_copy_val v2865v1, v3836v1
        v2867v1 = get_local __ptr { u64, u64, u64, u8, { { ptr, u64 }, u64 }, slice, u256 }, self_0, !203
        v567v1 = const u64 0
        v2868v1 = get_elem_ptr v2867v1, __ptr u64, v567v1, !205
        v2869v1 = load v2868v1, !206
        v2870v1 = get_local __ptr { { ptr, u64, u64 } }, buffer_, !208
        v3724v1 = get_local __ptr { { ptr, u64, u64 } }, __tmp_arg
        mem_copy_val v3724v1, v2870v1
        v3811v1 = get_local __ptr { { ptr, u64, u64 } }, __ret_val
        v3812v1 = call abi_encode_5(v2869v1, v3724v1, v3811v1)
        v2873v1 = get_local __ptr { { ptr, u64, u64 } }, buffer__, !210
        mem_copy_val v2873v1, v3811v1
        v2875v1 = get_local __ptr { u64, u64, u64, u8, { { ptr, u64 }, u64 }, slice, u256 }, self_0, !212
        v637v1 = const u64 1
        v2876v1 = get_elem_ptr v2875v1, __ptr u64, v637v1, !214
        v2878v1 = get_local __ptr { { ptr, u64, u64 } }, buffer__, !216
        v2881v1 = get_local __ptr { { ptr, u64, u64 } }, buffer_0, !219
        mem_copy_val v2881v1, v2878v1
        v2883v1 = get_local __ptr { { ptr, u64, u64 } }, __struct_init_0, !221
        v2884v1 = get_local __ptr { { ptr, u64, u64 } }, buffer_0, !223
        v583v1 = const u64 0
        v2885v1 = get_elem_ptr v2884v1, __ptr { ptr, u64, u64 }, v583v1, !224
        v3881v1 = asm(buffer: v2885v1) -> __ptr { ptr, u64, u64 } buffer {
        }
        v3954v1 = get_local __ptr { ptr, u64, u64 }, __aggr_memcpy_0
        mem_copy_val v3954v1, v3881v1
        v2888v1 = get_local __ptr { ptr, u64, u64 }, __anon_00, !225
        mem_copy_val v2888v1, v3954v1
        v589v1 = const u64 0
        v2890v1 = get_elem_ptr v2888v1, __ptr ptr, v589v1, !226
        v2891v1 = load v2890v1, !227
        v592v1 = const u64 1
        v2892v1 = get_elem_ptr v2888v1, __ptr u64, v592v1, !228
        v2893v1 = load v2892v1, !229
        v595v1 = const u64 2
        v2894v1 = get_elem_ptr v2888v1, __ptr u64, v595v1, !230
        v2895v1 = load v2894v1, !231
        v600v1 = const u64 4
        v2897v1 = add v2895v1, v600v1, !232
        v2898v1 = cmp gt v2897v1 v2893v1, !233
        cbr v2898v1, encode_allow_alias_22_abi_encode_37_abi_encode_38_block1(), encode_allow_alias_22_abi_encode_37_abi_encode_38_block0(v2891v1, v2893v1), !234

        encode_allow_alias_22_abi_encode_37_abi_encode_38_block0(v2795v1: ptr, v2796v1: u64):
        v2905v1 = get_local __ptr u64, __anon_1, !235
        mem_copy_val v2905v1, v2876v1
        v614v1 = const u64 4
        v2907v1 = add v2905v1, v614v1, !236
        v2908v1 = cast_ptr v2907v1 to __ptr u8, !237
        v2909v1 = add v2795v1, v2895v1, !238
        v2910v1 = cast_ptr v2909v1 to __ptr u8, !239
        mem_copy_bytes v2910v1, v2908v1, 4, !240
        v2913v1 = get_local __ptr { ptr, u64, u64 }, __anon_2, !241
        v623v1 = const u64 0
        v2914v1 = get_elem_ptr v2913v1, __ptr ptr, v623v1, !242
        store v2795v1 to v2914v1, !243
        v626v1 = const u64 1
        v2916v1 = get_elem_ptr v2913v1, __ptr u64, v626v1, !244
        store v2796v1 to v2916v1, !245
        v629v1 = const u64 2
        v2918v1 = get_elem_ptr v2913v1, __ptr u64, v629v1, !246
        store v2897v1 to v2918v1, !247
        v3883v1 = asm(buffer: v2913v1) -> __ptr { ptr, u64, u64 } buffer {
        }
        v3958v1 = get_local __ptr { ptr, u64, u64 }, __aggr_memcpy_00
        mem_copy_val v3958v1, v3883v1
        v1469v1 = const u64 0
        v2921v1 = get_elem_ptr v2883v1, __ptr { ptr, u64, u64 }, v1469v1, !248
        mem_copy_val v2921v1, v3958v1
        v2925v1 = get_local __ptr { { ptr, u64, u64 } }, buffer___, !250
        mem_copy_val v2925v1, v2883v1
        v2927v1 = get_local __ptr { u64, u64, u64, u8, { { ptr, u64 }, u64 }, slice, u256 }, self_0, !252
        v707v1 = const u64 2
        v2928v1 = get_elem_ptr v2927v1, __ptr u64, v707v1, !254
        v2930v1 = get_local __ptr { { ptr, u64, u64 } }, buffer___, !256
        v2933v1 = get_local __ptr { { ptr, u64, u64 } }, buffer_1, !259
        mem_copy_val v2933v1, v2930v1
        v2935v1 = get_local __ptr { { ptr, u64, u64 } }, __struct_init_00, !261
        v2936v1 = get_local __ptr { { ptr, u64, u64 } }, buffer_1, !263
        v653v1 = const u64 0
        v2937v1 = get_elem_ptr v2936v1, __ptr { ptr, u64, u64 }, v653v1, !264
        v3885v1 = asm(buffer: v2937v1) -> __ptr { ptr, u64, u64 } buffer {
        }
        v3963v1 = get_local __ptr { ptr, u64, u64 }, __aggr_memcpy_01
        mem_copy_val v3963v1, v3885v1
        v2940v1 = get_local __ptr { ptr, u64, u64 }, __anon_000, !265
        mem_copy_val v2940v1, v3963v1
        v659v1 = const u64 0
        v2942v1 = get_elem_ptr v2940v1, __ptr ptr, v659v1, !266
        v2943v1 = load v2942v1, !267
        v662v1 = const u64 1
        v2944v1 = get_elem_ptr v2940v1, __ptr u64, v662v1, !268
        v2945v1 = load v2944v1, !269
        v665v1 = const u64 2
        v2946v1 = get_elem_ptr v2940v1, __ptr u64, v665v1, !270
        v2947v1 = load v2946v1, !271
        v670v1 = const u64 2
        v2949v1 = add v2947v1, v670v1, !272
        v2950v1 = cmp gt v2949v1 v2945v1, !273
        cbr v2950v1, encode_allow_alias_22_abi_encode_37_abi_encode_39_block1(), encode_allow_alias_22_abi_encode_37_abi_encode_39_block0(v2943v1, v2945v1), !274

        encode_allow_alias_22_abi_encode_37_abi_encode_38_block1():
        v606v1 = const u64 2
        v2901v1 = mul v2893v1, v606v1, !275
        v2902v1 = add v2901v1, v600v1, !276
        v2903v1 = asm(new_cap: v2902v1, old_ptr: v2891v1, len: v2895v1) -> __ptr u8 hp, !277 {
            aloc   new_cap
            mcp    hp old_ptr len
        }
        br encode_allow_alias_22_abi_encode_37_abi_encode_38_block0(v2903v1, v2902v1), !278

        encode_allow_alias_22_abi_encode_37_abi_encode_39_block0(v2798v1: ptr, v2799v1: u64):
        v2957v1 = get_local __ptr u64, __anon_10, !279
        mem_copy_val v2957v1, v2928v1
        v684v1 = const u64 6
        v2959v1 = add v2957v1, v684v1, !280
        v2960v1 = cast_ptr v2959v1 to __ptr u8, !281
        v2961v1 = add v2798v1, v2947v1, !282
        v2962v1 = cast_ptr v2961v1 to __ptr u8, !283
        mem_copy_bytes v2962v1, v2960v1, 2, !284
        v2965v1 = get_local __ptr { ptr, u64, u64 }, __anon_20, !285
        v693v1 = const u64 0
        v2966v1 = get_elem_ptr v2965v1, __ptr ptr, v693v1, !286
        store v2798v1 to v2966v1, !287
        v696v1 = const u64 1
        v2968v1 = get_elem_ptr v2965v1, __ptr u64, v696v1, !288
        store v2799v1 to v2968v1, !289
        v699v1 = const u64 2
        v2970v1 = get_elem_ptr v2965v1, __ptr u64, v699v1, !290
        store v2949v1 to v2970v1, !291
        v3887v1 = asm(buffer: v2965v1) -> __ptr { ptr, u64, u64 } buffer {
        }
        v3967v1 = get_local __ptr { ptr, u64, u64 }, __aggr_memcpy_02
        mem_copy_val v3967v1, v3887v1
        v1472v1 = const u64 0
        v2973v1 = get_elem_ptr v2935v1, __ptr { ptr, u64, u64 }, v1472v1, !292
        mem_copy_val v2973v1, v3967v1
        v2977v1 = get_local __ptr { { ptr, u64, u64 } }, buffer____, !294
        mem_copy_val v2977v1, v2935v1
        v2979v1 = get_local __ptr { u64, u64, u64, u8, { { ptr, u64 }, u64 }, slice, u256 }, self_0, !296
        v772v1 = const u64 3
        v2980v1 = get_elem_ptr v2979v1, __ptr u8, v772v1, !298
        v2981v1 = load v2980v1, !299
        v2982v1 = get_local __ptr { { ptr, u64, u64 } }, buffer____, !301
        v2985v1 = get_local __ptr { { ptr, u64, u64 } }, buffer_2, !304
        mem_copy_val v2985v1, v2982v1
        v2987v1 = get_local __ptr { { ptr, u64, u64 } }, __struct_init_01, !306
        v2988v1 = get_local __ptr { { ptr, u64, u64 } }, buffer_2, !308
        v723v1 = const u64 0
        v2989v1 = get_elem_ptr v2988v1, __ptr { ptr, u64, u64 }, v723v1, !309
        v3889v1 = asm(buffer: v2989v1) -> __ptr { ptr, u64, u64 } buffer {
        }
        v3972v1 = get_local __ptr { ptr, u64, u64 }, __aggr_memcpy_03
        mem_copy_val v3972v1, v3889v1
        v2992v1 = get_local __ptr { ptr, u64, u64 }, __anon_01, !310
        mem_copy_val v2992v1, v3972v1
        v729v1 = const u64 0
        v2994v1 = get_elem_ptr v2992v1, __ptr ptr, v729v1, !311
        v2995v1 = load v2994v1, !312
        v732v1 = const u64 1
        v2996v1 = get_elem_ptr v2992v1, __ptr u64, v732v1, !313
        v2997v1 = load v2996v1, !314
        v735v1 = const u64 2
        v2998v1 = get_elem_ptr v2992v1, __ptr u64, v735v1, !315
        v2999v1 = load v2998v1, !316
        v740v1 = const u64 1
        v3001v1 = add v2999v1, v740v1, !317
        v3002v1 = cmp gt v3001v1 v2997v1, !318
        cbr v3002v1, encode_allow_alias_22_abi_encode_37_abi_encode_40_block1(), encode_allow_alias_22_abi_encode_37_abi_encode_40_block0(v2995v1, v2997v1), !319

        encode_allow_alias_22_abi_encode_37_abi_encode_39_block1():
        v676v1 = const u64 2
        v2953v1 = mul v2945v1, v676v1, !320
        v2954v1 = add v2953v1, v670v1, !321
        v2955v1 = asm(new_cap: v2954v1, old_ptr: v2943v1, len: v2947v1) -> __ptr u8 hp, !322 {
            aloc   new_cap
            mcp    hp old_ptr len
        }
        br encode_allow_alias_22_abi_encode_37_abi_encode_39_block0(v2955v1, v2954v1), !323

        encode_allow_alias_22_abi_encode_37_abi_encode_40_block0(v2801v1: ptr, v2802v1: u64):
        v3009v1 = add v2801v1, v2999v1, !324
        v3010v1 = cast_ptr v3009v1 to __ptr u8, !325
        store v2981v1 to v3010v1, !326
        v3013v1 = get_local __ptr { ptr, u64, u64 }, __anon_11, !327
        v758v1 = const u64 0
        v3014v1 = get_elem_ptr v3013v1, __ptr ptr, v758v1, !328
        store v2801v1 to v3014v1, !329
        v761v1 = const u64 1
        v3016v1 = get_elem_ptr v3013v1, __ptr u64, v761v1, !330
        store v2802v1 to v3016v1, !331
        v764v1 = const u64 2
        v3018v1 = get_elem_ptr v3013v1, __ptr u64, v764v1, !332
        store v3001v1 to v3018v1, !333
        v3891v1 = asm(buffer: v3013v1) -> __ptr { ptr, u64, u64 } buffer {
        }
        v3975v1 = get_local __ptr { ptr, u64, u64 }, __aggr_memcpy_04
        mem_copy_val v3975v1, v3891v1
        v1475v1 = const u64 0
        v3021v1 = get_elem_ptr v2987v1, __ptr { ptr, u64, u64 }, v1475v1, !334
        mem_copy_val v3021v1, v3975v1
        v3025v1 = get_local __ptr { { ptr, u64, u64 } }, buffer_____, !336
        mem_copy_val v3025v1, v2987v1
        v3027v1 = get_local __ptr { u64, u64, u64, u8, { { ptr, u64 }, u64 }, slice, u256 }, self_0, !338
        v893v1 = const u64 4
        v3028v1 = get_elem_ptr v3027v1, __ptr { { ptr, u64 }, u64 }, v893v1, !340
        v3030v1 = get_local __ptr { { ptr, u64, u64 } }, buffer_____, !342
        v3032v1 = get_local __ptr { { ptr, u64 }, u64 }, self_3, !345
        mem_copy_val v3032v1, v3028v1
        v3034v1 = get_local __ptr { { ptr, u64, u64 } }, buffer_3, !346
        mem_copy_val v3034v1, v3030v1
        v3036v1 = get_local __ptr { { ptr, u64 }, u64 }, self_3, !348
        v787v1 = const u64 1
        v3037v1 = get_elem_ptr v3036v1, __ptr u64, v787v1, !349
        v3038v1 = load v3037v1, !350
        v3041v1 = get_local __ptr { { ptr, u64, u64 } }, buffer_3, !352
        v3727v1 = get_local __ptr { { ptr, u64, u64 } }, __tmp_arg0
        mem_copy_val v3727v1, v3041v1
        v3814v1 = get_local __ptr { { ptr, u64, u64 } }, __ret_val0
        v3815v1 = call abi_encode_5(v3038v1, v3727v1, v3814v1)
        v3044v1 = get_local __ptr { { ptr, u64, u64 } }, buffer__0, !354
        mem_copy_val v3044v1, v3814v1
        v799v1 = const u64 0, !355
        br encode_allow_alias_22_abi_encode_37_abi_encode_41_while(v799v1), !356

        encode_allow_alias_22_abi_encode_37_abi_encode_40_block1():
        v746v1 = const u64 2
        v3005v1 = mul v2997v1, v746v1, !357
        v3006v1 = add v3005v1, v740v1, !358
        v3007v1 = asm(new_cap: v3006v1, old_ptr: v2995v1, len: v2999v1) -> __ptr u8 hp, !359 {
            aloc   new_cap
            mcp    hp old_ptr len
        }
        br encode_allow_alias_22_abi_encode_37_abi_encode_40_block0(v3007v1, v3006v1), !360

        encode_allow_alias_22_abi_encode_37_abi_encode_41_while(v2804v1: u64):
        v3054v1 = cmp lt v2804v1 v3038v1, !363
        cbr v3054v1, encode_allow_alias_22_abi_encode_37_abi_encode_41_while_body(), encode_allow_alias_22_abi_encode_37_abi_encode_41_end_while(), !364

        encode_allow_alias_22_abi_encode_37_abi_encode_41_while_body():
        v3180v1 = get_local __ptr { { ptr, u64 }, u64 }, self_3, !366
        v3183v1 = get_local __ptr { { ptr, u64 }, u64 }, self_10, !369
        mem_copy_val v3183v1, v3180v1
        v3186v1 = get_local __ptr { { ptr, u64 }, u64 }, self_10, !371
        v852v1 = const u64 0
        v3187v1 = get_elem_ptr v3186v1, __ptr { ptr, u64 }, v852v1, !372
        v854v1 = const u64 0
        v3188v1 = get_elem_ptr v3187v1, __ptr ptr, v854v1, !373
        v3189v1 = load v3188v1, !374
        v376v1 = const u64 8
        v3195v1 = mul v376v1, v2804v1, !377
        v3196v1 = add v3189v1, v3195v1, !378
        v3208v1 = asm(ptr: v3196v1, val) -> u64 val, !382 {
            lw     val ptr i0, !383
        }
        v3221v1 = get_local __ptr { { ptr, u64, u64 } }, buffer__0, !385
        v3730v1 = get_local __ptr { { ptr, u64, u64 } }, __tmp_arg1
        mem_copy_val v3730v1, v3221v1
        v3817v1 = get_local __ptr { { ptr, u64, u64 } }, __ret_val1
        v3818v1 = call abi_encode_5(v3208v1, v3730v1, v3817v1)
        v3224v1 = get_local __ptr { { ptr, u64, u64 } }, buffer__0, !387
        mem_copy_val v3224v1, v3817v1
        v879v1 = const u64 1, !388
        v3231v1 = add v2804v1, v879v1, !391
        br encode_allow_alias_22_abi_encode_37_abi_encode_41_while(v3231v1), !392

        encode_allow_alias_22_abi_encode_37_abi_encode_41_end_while():
        v3057v1 = get_local __ptr { { ptr, u64, u64 } }, buffer__0, !394
        v3060v1 = get_local __ptr { { ptr, u64, u64 } }, buffer______, !396
        mem_copy_val v3060v1, v3057v1
        v3062v1 = get_local __ptr { u64, u64, u64, u8, { { ptr, u64 }, u64 }, slice, u256 }, self_0, !398
        v965v1 = const u64 5
        v3063v1 = get_elem_ptr v3062v1, __ptr slice, v965v1, !400
        v3065v1 = get_local __ptr { { ptr, u64, u64 } }, buffer______, !402
        v3067v1 = get_local __ptr slice, self_4, !405
        mem_copy_val v3067v1, v3063v1
        v3069v1 = get_local __ptr { { ptr, u64, u64 } }, buffer_4, !406
        mem_copy_val v3069v1, v3065v1
        v3071v1 = get_local __ptr { { ptr, u64, u64 } }, __struct_init_02, !408
        v3072v1 = get_local __ptr { { ptr, u64, u64 } }, buffer_4, !410
        v909v1 = const u64 0
        v3073v1 = get_elem_ptr v3072v1, __ptr { ptr, u64, u64 }, v909v1, !411
        v3893v1 = asm(buffer: v3073v1) -> __ptr { ptr, u64, u64 } buffer {
        }
        v3989v1 = get_local __ptr { ptr, u64, u64 }, __aggr_memcpy_05
        mem_copy_val v3989v1, v3893v1
        v3076v1 = get_local __ptr { ptr, u64, u64 }, __anon_02, !412
        mem_copy_val v3076v1, v3989v1
        v915v1 = const u64 0
        v3078v1 = get_elem_ptr v3076v1, __ptr ptr, v915v1, !413
        v3079v1 = load v3078v1, !414
        v918v1 = const u64 1
        v3080v1 = get_elem_ptr v3076v1, __ptr u64, v918v1, !415
        v3081v1 = load v3080v1, !416
        v921v1 = const u64 2
        v3082v1 = get_elem_ptr v3076v1, __ptr u64, v921v1, !417
        v3083v1 = load v3082v1, !418
        v3084v1 = get_local __ptr slice, self_4, !420
        v3995v1 = get_local __ptr slice, __aggr_memcpy_07
        mem_copy_val v3995v1, v3084v1
        v3895v1 = asm(item: v3084v1) -> __ptr { u64, u64 } item {
        }
        v3992v1 = get_local __ptr { u64, u64 }, __aggr_memcpy_06
        mem_copy_val v3992v1, v3895v1
        v3087v1 = get_local __ptr { u64, u64 }, __anon_12, !421
        mem_copy_val v3087v1, v3992v1
        v929v1 = const u64 1
        v3089v1 = get_elem_ptr v3087v1, __ptr u64, v929v1, !422
        v3090v1 = load v3089v1, !423
        v932v1 = const u64 8
        v3091v1 = add v3090v1, v932v1, !424
        v3092v1 = add v3083v1, v3091v1, !425
        v3093v1 = cmp gt v3092v1 v3081v1, !426
        cbr v3093v1, encode_allow_alias_22_abi_encode_37_abi_encode_45_block1(), encode_allow_alias_22_abi_encode_37_abi_encode_45_block0(v3079v1, v3081v1), !427

        encode_allow_alias_22_abi_encode_37_abi_encode_45_block0(v2814v1: ptr, v2815v1: u64):
        v3100v1 = get_local __ptr slice, __anon_21, !428
        mem_copy_val v3100v1, v3995v1
        v3102v1 = add v2814v1, v3083v1, !429
        v3103v1 = cast_ptr v3102v1 to __ptr u8, !430
        v3104v1 = asm(item_ptr: v3100v1, len: v3083v1, addr: v3103v1, data_ptr, item_len, new_len) -> u64 new_len, !431 {
            lw     item_len item_ptr i1
            sw     addr item_len i0
            addi   addr addr i8
            lw     data_ptr item_ptr i0
            mcp    addr data_ptr item_len
            addi   new_len len i8
            add    new_len new_len item_len
        }
        v3105v1 = get_local __ptr { ptr, u64, u64 }, __anon_3, !432
        v951v1 = const u64 0
        v3106v1 = get_elem_ptr v3105v1, __ptr ptr, v951v1, !433
        store v2814v1 to v3106v1, !434
        v954v1 = const u64 1
        v3108v1 = get_elem_ptr v3105v1, __ptr u64, v954v1, !435
        store v2815v1 to v3108v1, !436
        v957v1 = const u64 2
        v3110v1 = get_elem_ptr v3105v1, __ptr u64, v957v1, !437
        store v3104v1 to v3110v1, !438
        v3897v1 = asm(buffer: v3105v1) -> __ptr { ptr, u64, u64 } buffer {
        }
        v3998v1 = get_local __ptr { ptr, u64, u64 }, __aggr_memcpy_08
        mem_copy_val v3998v1, v3897v1
        v1478v1 = const u64 0
        v3113v1 = get_elem_ptr v3071v1, __ptr { ptr, u64, u64 }, v1478v1, !439
        mem_copy_val v3113v1, v3998v1
        v3117v1 = get_local __ptr { { ptr, u64, u64 } }, buffer_______, !441
        mem_copy_val v3117v1, v3071v1
        v3119v1 = get_local __ptr { u64, u64, u64, u8, { { ptr, u64 }, u64 }, slice, u256 }, self_0, !443
        v1032v1 = const u64 6
        v3120v1 = get_elem_ptr v3119v1, __ptr u256, v1032v1, !445
        v3122v1 = get_local __ptr { { ptr, u64, u64 } }, buffer_______, !447
        v3124v1 = get_local __ptr u256, self_5, !450
        mem_copy_val v3124v1, v3120v1
        v3126v1 = get_local __ptr { { ptr, u64, u64 } }, buffer_5, !451
        mem_copy_val v3126v1, v3122v1
        v3128v1 = get_local __ptr { { ptr, u64, u64 } }, __struct_init_03, !453
        v3129v1 = get_local __ptr { { ptr, u64, u64 } }, buffer_5, !455
        v981v1 = const u64 0
        v3130v1 = get_elem_ptr v3129v1, __ptr { ptr, u64, u64 }, v981v1, !456
        v3899v1 = asm(buffer: v3130v1) -> __ptr { ptr, u64, u64 } buffer {
        }
        v4004v1 = get_local __ptr { ptr, u64, u64 }, __aggr_memcpy_09
        mem_copy_val v4004v1, v3899v1
        v3133v1 = get_local __ptr { ptr, u64, u64 }, __anon_03, !457
        mem_copy_val v3133v1, v4004v1
        v987v1 = const u64 0
        v3135v1 = get_elem_ptr v3133v1, __ptr ptr, v987v1, !458
        v3136v1 = load v3135v1, !459
        v990v1 = const u64 1
        v3137v1 = get_elem_ptr v3133v1, __ptr u64, v990v1, !460
        v3138v1 = load v3137v1, !461
        v993v1 = const u64 2
        v3139v1 = get_elem_ptr v3133v1, __ptr u64, v993v1, !462
        v3140v1 = load v3139v1, !463
        v3141v1 = get_local __ptr u256, self_5, !465
        v998v1 = const u64 32
        v3143v1 = add v3140v1, v998v1, !466
        v3144v1 = cmp gt v3143v1 v3138v1, !467
        cbr v3144v1, encode_allow_alias_22_abi_encode_37_abi_encode_46_block1(), encode_allow_alias_22_abi_encode_37_abi_encode_46_block0(v3136v1, v3138v1), !468

        encode_allow_alias_22_abi_encode_37_abi_encode_45_block1():
        v939v1 = const u64 2
        v3096v1 = mul v3081v1, v939v1, !469
        v3097v1 = add v3096v1, v3091v1, !470
        v3098v1 = asm(new_cap: v3097v1, old_ptr: v3079v1, len: v3083v1) -> __ptr u8 hp, !471 {
            aloc   new_cap
            mcp    hp old_ptr len
        }
        br encode_allow_alias_22_abi_encode_37_abi_encode_45_block0(v3098v1, v3097v1), !472

        encode_allow_alias_22_abi_encode_37_abi_encode_46_block0(v2817v1: ptr, v2818v1: u64):
        v3151v1 = get_local __ptr u256, __anon_13, !473
        mem_copy_val v3151v1, v3141v1
        v3153v1 = add v2817v1, v3140v1, !474
        v3154v1 = cast_ptr v3153v1 to __ptr u8, !475
        mem_copy_bytes v3154v1, v3151v1, 32, !476
        v3157v1 = get_local __ptr { ptr, u64, u64 }, __anon_22, !477
        v1018v1 = const u64 0
        v3158v1 = get_elem_ptr v3157v1, __ptr ptr, v1018v1, !478
        store v2817v1 to v3158v1, !479
        v1021v1 = const u64 1
        v3160v1 = get_elem_ptr v3157v1, __ptr u64, v1021v1, !480
        store v2818v1 to v3160v1, !481
        v1024v1 = const u64 2
        v3162v1 = get_elem_ptr v3157v1, __ptr u64, v1024v1, !482
        store v3143v1 to v3162v1, !483
        v3901v1 = asm(buffer: v3157v1) -> __ptr { ptr, u64, u64 } buffer {
        }
        v4008v1 = get_local __ptr { ptr, u64, u64 }, __aggr_memcpy_010
        mem_copy_val v4008v1, v3901v1
        v1481v1 = const u64 0
        v3165v1 = get_elem_ptr v3128v1, __ptr { ptr, u64, u64 }, v1481v1, !484
        mem_copy_val v3165v1, v4008v1
        v3169v1 = get_local __ptr { { ptr, u64, u64 } }, buffer________, !486
        mem_copy_val v3169v1, v3128v1
        v3171v1 = get_local __ptr { { ptr, u64, u64 } }, buffer________, !488
        v3174v1 = get_local __ptr { { ptr, u64, u64 } }, buffer, !490
        mem_copy_val v3174v1, v3171v1
        v3176v1 = get_local __ptr { { ptr, u64, u64 } }, buffer, !492
        v3747v1 = get_local __ptr { { ptr, u64, u64 } }, __tmp_arg2
        mem_copy_val v3747v1, v3176v1
        v3849v1 = get_local __ptr slice, __ret_val3
        v3850v1 = call as_raw_slice_7(v3747v1, v3849v1)
        v3763v1 = get_local __ptr slice, __tmp_block_arg
        mem_copy_val v3763v1, v3849v1
        br encode_allow_alias_22_block2(v3763v1), !79

        encode_allow_alias_22_abi_encode_37_abi_encode_46_block1():
        v1004v1 = const u64 2
        v3147v1 = mul v3138v1, v1004v1, !493
        v3148v1 = add v3147v1, v998v1, !494
        v3149v1 = asm(new_cap: v3148v1, old_ptr: v3136v1, len: v3140v1) -> __ptr u8 hp, !495 {
            aloc   new_cap
            mcp    hp old_ptr len
        }
        br encode_allow_alias_22_abi_encode_37_abi_encode_46_block0(v3149v1, v3148v1), !496

        encode_allow_alias_22_block2(v3761v1: __ptr slice):
        v3878v1 = get_local __ptr slice, __log_arg
        mem_copy_val v3878v1, v3761v1
        v1060v1 = const u64 4579537983717831593
        log __ptr slice v3878v1, v1060v1
        v1063v1 = const unit ()
        ret () v1063v1
    }

    fn local_log_48(item: __ptr { u64 }) -> (), !497 {
        local { __ptr { u64 }, u64 } __anon_0
        local slice __log_arg
        local { u64 } item_

        entry(item: __ptr { u64 }):
        v1093v1 = get_local __ptr { u64 }, item_
        mem_copy_val v1093v1, item
        v1156v1 = get_local __ptr { u64 }, item_, !79
        v3323v1 = get_local __ptr { __ptr { u64 }, u64 }, __anon_0, !498
        v1484v1 = const u64 0
        v3326v1 = get_elem_ptr v3323v1, __ptr __ptr { u64 }, v1484v1, !499
        store v1156v1 to v3326v1, !500
        v1487v1 = const u64 1
        v3328v1 = get_elem_ptr v3323v1, __ptr u64, v1487v1, !501
        v1109v1 = const u64 8
        store v1109v1 to v3328v1, !502
        v3331v1 = get_local __ptr { __ptr { u64 }, u64 }, __anon_0, !79
        v3333v1 = cast_ptr v3331v1 to __ptr slice, !79
        v3903v1 = get_local __ptr slice, __log_arg
        mem_copy_val v3903v1, v3333v1
        v1158v1 = const u64 16566583104751091389
        log __ptr slice v3903v1, v1158v1
        v1161v1 = const unit ()
        ret () v1161v1
    }

    pub fn abi_encode_52(self: __ptr { u64 }, buffer: __ptr { { ptr, u64, u64 } }, __ret_value: __ptr { { ptr, u64, u64 } }) -> (), !505 {
        entry(self: __ptr { u64 }, buffer: __ptr { { ptr, u64, u64 } }, __ret_value: __ptr { { ptr, u64, u64 } }):
        v1130v1 = const u64 0
        v1131v1 = get_elem_ptr self, __ptr u64, v1130v1, !506
        v1132v1 = load v1131v1
        v3821v1 = call abi_encode_5(v1132v1, buffer, __ret_value)
        v3860v1 = const unit ()
        ret () v3860v1
    }

    fn local_log_53(item: __ptr { u64, ( { u64 } | () ) }) -> (), !507 {
        local { __ptr { u64, ( { u64 } | () ) }, u64 } __anon_0
        local slice __log_arg
        local { u64, ( { u64 } | () ) } __matched_value_1
        local { { ptr, u64, u64 } } __tmp_block_arg
        local { { ptr, u64, u64 } } buffer_
        local { { ptr, u64, u64 } } buffer__

        entry(item: __ptr { u64, ( { u64 } | () ) }):
        v1169v1 = get_local __ptr { u64, ( { u64 } | () ) }, __matched_value_1
        mem_copy_val v1169v1, item
        v1284v1 = get_local __ptr { u64, ( { u64 } | () ) }, __matched_value_1, !79
        v3536v1 = const bool false, !508
        cbr v3536v1, encode_allow_alias_54_block0(), encode_allow_alias_54_block1(), !509

        encode_allow_alias_54_block0():
        v3628v1 = get_local __ptr { __ptr { u64, ( { u64 } | () ) }, u64 }, __anon_0, !510
        v1490v1 = const u64 0
        v3631v1 = get_elem_ptr v3628v1, __ptr __ptr { u64, ( { u64 } | () ) }, v1490v1, !511
        store v1284v1 to v3631v1, !512
        v1493v1 = const u64 1
        v3633v1 = get_elem_ptr v3628v1, __ptr u64, v1493v1, !513
        v1193v1 = const u64 16
        store v1193v1 to v3633v1, !514
        v3636v1 = get_local __ptr { __ptr { u64, ( { u64 } | () ) }, u64 }, __anon_0, !79
        v3638v1 = cast_ptr v3636v1 to __ptr slice, !79
        v3797v1 = get_local __ptr slice, __log_arg
        mem_copy_val v3797v1, v3638v1
        br encode_allow_alias_54_block2(), !79

        encode_allow_alias_54_block1():
        v3839v1 = get_local __ptr { { ptr, u64, u64 } }, buffer_
        v3840v1 = call new_6(v3839v1)
        v4037v1 = get_local __ptr { u64, ( { u64 } | () ) }, __matched_value_1
        v1218v1 = const u64 0
        v4038v1 = get_elem_ptr v4037v1, __ptr u64, v1218v1
        v3572v1 = load v4038v1, !515
        v1221v1 = const u64 0, !516
        v3577v1 = cmp eq v3572v1 v1221v1, !519
        cbr v3577v1, encode_allow_alias_54_abi_encode_59_block0(), encode_allow_alias_54_abi_encode_59_block1(), !520

        encode_allow_alias_54_abi_encode_59_block0():
        v3596v1 = get_local __ptr { u64, ( { u64 } | () ) }, __matched_value_1, !521
        v1224v1 = const u64 1
        v1225v1 = const u64 0
        v3597v1 = get_elem_ptr v3596v1, __ptr { u64 }, v1224v1, v1225v1, !522
        v3601v1 = get_local __ptr { { ptr, u64, u64 } }, buffer_, !524
        v3823v1 = get_local __ptr { { ptr, u64, u64 } }, buffer__
        v1230v1 = const u64 0, !525
        v3824v1 = call abi_encode_5(v1230v1, v3601v1, v3823v1)
        v3778v1 = get_local __ptr { { ptr, u64, u64 } }, buffer__
        v3862v1 = get_local __ptr { { ptr, u64, u64 } }, __tmp_block_arg
        v3863v1 = call abi_encode_52(v3597v1, v3778v1, v3862v1)
        v3793v1 = get_local __ptr { { ptr, u64, u64 } }, __tmp_block_arg
        br encode_allow_alias_54_abi_encode_59_block5(v3793v1), !526

        encode_allow_alias_54_abi_encode_59_block1():
        v3580v1 = get_local __ptr { u64, ( { u64 } | () ) }, __matched_value_1, !527
        v1246v1 = const u64 0
        v3581v1 = get_elem_ptr v3580v1, __ptr u64, v1246v1, !528
        v3582v1 = load v3581v1, !529
        v1249v1 = const u64 1, !516
        v3587v1 = cmp eq v3582v1 v1249v1, !532
        cbr v3587v1, encode_allow_alias_54_abi_encode_59_block2(), encode_allow_alias_54_abi_encode_59_block3(), !533

        encode_allow_alias_54_abi_encode_59_block2():
        v3591v1 = get_local __ptr { { ptr, u64, u64 } }, buffer_, !535
        v3826v1 = get_local __ptr { { ptr, u64, u64 } }, __tmp_block_arg
        v1251v1 = const u64 1, !536
        v3827v1 = call abi_encode_5(v1251v1, v3591v1, v3826v1)
        v3791v1 = get_local __ptr { { ptr, u64, u64 } }, __tmp_block_arg
        br encode_allow_alias_54_abi_encode_59_block5(v3791v1), !537

        encode_allow_alias_54_abi_encode_59_block3():
        v1255v1 = const u64 14757395258967588866, !538
        revert v1255v1, !539

        encode_allow_alias_54_abi_encode_59_block5(v3789v1: __ptr { { ptr, u64, u64 } }):
        v3852v1 = get_local __ptr slice, __log_arg
        v3853v1 = call as_raw_slice_7(v3789v1, v3852v1)
        br encode_allow_alias_54_block2(), !79

        encode_allow_alias_54_block2():
        v3906v1 = get_local __ptr slice, __log_arg
        v1286v1 = const u64 5087777005172090899
        log __ptr slice v3906v1, v1286v1
        v1289v1 = const unit ()
        ret () v1289v1
    }

    fn local_log_60(item: __ptr {  }) -> (), !540 {
        local slice __log_arg
        local { { ptr, u64, u64 } } buffer
        local { { ptr, u64, u64 } } buffer_

        entry(item: __ptr {  }):
        v3842v1 = get_local __ptr { { ptr, u64, u64 } }, buffer_
        v3843v1 = call new_6(v3842v1)
        v3742v1 = get_local __ptr { { ptr, u64, u64 } }, buffer_
        v3829v1 = get_local __ptr { { ptr, u64, u64 } }, buffer
        v1344v1 = const u64 77, !541
        v3830v1 = call abi_encode_5(v1344v1, v3742v1, v3829v1)
        v3753v1 = get_local __ptr { { ptr, u64, u64 } }, buffer
        v3855v1 = get_local __ptr slice, __log_arg
        v3856v1 = call as_raw_slice_7(v3753v1, v3855v1)
        v3909v1 = get_local __ptr slice, __log_arg
        v1366v1 = const u64 5555909392781521367
        log __ptr slice v3909v1, v1366v1
        v1369v1 = const unit ()
        ret () v1369v1
    }
}

!0 = "test/src/e2e_vm_tests/test_programs/should_pass/language/logging/src/main.<autogenerated>.sw"
!1 = span !0 0 131
!2 = fn_name_span !0 7 14
!3 = (!1 !2)
!4 = span !0 59 65
!5 = fn_call_path_span !0 59 63
!6 = (!4 !5)
!7 = span !0 40 66
!8 = span !0 109 116
!9 = span !0 83 117
!10 = fn_call_path_span !0 83 100
!11 = "test/src/e2e_vm_tests/reduced_std_libs/sway-lib-std-vec/src/codec.sw"
!12 = span !11 94080 94106
!13 = (!9 !10 !12)
!14 = "test/src/e2e_vm_tests/test_programs/should_pass/language/logging/src/main.sw"
!15 = span !14 594 999
!16 = fn_name_span !14 597 601
!17 = (!15 !16)
!18 = span !14 627 631
!19 = span !14 617 632
!20 = fn_call_path_span !14 617 626
!21 = (!19 !20)
!22 = span !14 651 661
!23 = fn_call_path_span !14 651 659
!24 = "test/src/e2e_vm_tests/reduced_std_libs/sway-lib-std-vec/src/vec.sw"
!25 = span !24 4087 4155
!26 = (!22 !23 !25)
!27 = span !24 4111 4124
!28 = fn_call_path_span !24 4111 4122
!29 = span !24 750 818
!30 = (!22 !23 !27 !28 !29)
!31 = span !24 785 786
!32 = span !24 774 787
!33 = fn_call_path_span !24 774 779
!34 = "test/src/e2e_vm_tests/reduced_std_libs/sway-lib-std-vec/src/alloc.sw"
!35 = span !34 1777 1796
!36 = (!22 !23 !27 !28 !32 !33 !35)
!37 = (!22 !23 !27 !28 !29)
!38 = (!22 !23 !27 !28 !29)
!39 = (!22 !23 !27 !28 !29)
!40 = span !24 806 807
!41 = (!22 !23 !27 !28 !29)
!42 = (!22 !23 !25)
!43 = (!22 !23 !25)
!44 = span !24 4143 4144
!45 = (!22 !23 !25)
!46 = span !14 667 668
!47 = span !14 674 675
!48 = span !14 667 676
!49 = fn_call_path_span !14 669 673
!50 = (!48 !49)
!51 = span !14 682 683
!52 = span !14 689 690
!53 = span !14 682 691
!54 = fn_call_path_span !14 684 688
!55 = (!53 !54)
!56 = span !14 697 698
!57 = span !14 704 705
!58 = span !14 697 706
!59 = fn_call_path_span !14 699 703
!60 = (!58 !59)
!61 = span !14 723 840
!62 = span !14 790 791
!63 = span !14 804 810
!64 = span !14 737 738
!65 = span !14 751 752
!66 = span !14 765 766
!67 = span !14 779 780
!68 = span !14 857 883
!69 = span !14 873 877
!70 = span !14 203 239
!71 = span !14 905 931
!72 = span !14 921 925
!73 = span !14 996 997
!74 = span !14 544 548
!75 = span !14 528 592
!76 = fn_name_span !14 531 540
!77 = inline "never"
!78 = (!75 !76 !77)
!79 = span !14 584 588
!80 = span !11 93769 93781
!81 = (!79 !80)
!82 = (!79 !80)
!83 = (!79 !80)
!84 = (!79 !80)
!85 = (!79 !80)
!86 = span !11 4703 4707
!87 = span !11 4689 4834
!88 = fn_name_span !11 4692 4702
!89 = (!87 !88)
!90 = span !11 4745 4828
!91 = span !11 4797 4803
!92 = span !11 87 114
!93 = span !11 160 260
!94 = fn_name_span !11 167 170
!95 = (!93 !94)
!96 = span !11 191 254
!97 = span !11 499 591
!98 = fn_name_span !11 502 514
!99 = (!97 !98)
!100 = span !11 573 577
!101 = span !24 5760 5764
!102 = span !24 5766 5771
!103 = span !24 5740 6205
!104 = fn_name_span !24 5747 5751
!105 = (!103 !104)
!106 = span !24 3543 3551
!107 = span !24 3523 3537
!108 = span !24 375 383
!109 = span !24 5852 5876
!110 = fn_call_path_span !24 5861 5863
!111 = (!109 !110)
!112 = span !24 5891 5906
!113 = fn_call_path_span !24 5900 5904
!114 = (!112 !113)
!115 = span !24 2990 2991
!116 = span !24 2978 2991
!117 = fn_call_path_span !24 2987 2989
!118 = (!112 !113 !116 !117)
!119 = span !24 2994 2995
!120 = (!112 !113 !116)
!121 = span !24 3005 3006
!122 = span !24 3005 3017
!123 = fn_call_path_span !24 3007 3008
!124 = (!112 !113 !122 !123)
!125 = span !24 357 369
!126 = (!112 !113 !125)
!127 = span !24 3041 3082
!128 = fn_call_path_span !24 3041 3048
!129 = span !34 2578 2595
!130 = fn_call_path_span !34 2588 2589
!131 = (!112 !113 !127 !128 !129 !130)
!132 = (!112 !113 !127 !128 !129)
!133 = span !34 2620 2641
!134 = fn_call_path_span !34 2620 2625
!135 = (!112 !113 !127 !128 !133 !134 !35)
!136 = span !34 2662 2663
!137 = span !34 2654 2663
!138 = fn_call_path_span !34 2660 2661
!139 = (!112 !113 !127 !128 !137 !138)
!140 = (!112 !113 !127 !128 !137)
!141 = span !34 2678 2710
!142 = fn_call_path_span !34 2682 2689
!143 = "test/src/e2e_vm_tests/reduced_std_libs/sway-lib-std-vec/src/raw_ptr.sw"
!144 = span !143 3413 3437
!145 = fn_call_path_span !143 3419 3420
!146 = (!112 !113 !127 !128 !141 !142 !144 !145)
!147 = span !143 3447 3522
!148 = (!112 !113 !127 !128 !141 !142 !147)
!149 = span !143 3496 3511
!150 = (!112 !113 !127 !128)
!151 = span !24 3030 3082
!152 = (!112 !113 !151)
!153 = span !24 3092 3110
!154 = (!112 !113 !153)
!155 = span !24 6040 6071
!156 = fn_call_path_span !24 6053 6056
!157 = (!155 !156)
!158 = span !24 6124 6145
!159 = fn_call_path_span !24 6128 6133
!160 = span !143 4228 4299
!161 = (!158 !159 !160)
!162 = span !143 4271 4284
!163 = span !24 6197 6198
!164 = span !24 6185 6198
!165 = fn_call_path_span !24 6194 6196
!166 = (!164 !165)
!167 = (!75 !76 !77)
!168 = span !11 93661 93685
!169 = fn_call_path_span !11 93661 93678
!170 = span !11 3637 3659
!171 = fn_call_path_span !11 3637 3657
!172 = span !0 148 205
!173 = fn_call_path_span !0 175 177
!174 = (!79 !168 !169 !170 !171 !172 !173)
!175 = span !0 148 295
!176 = (!79 !168 !169 !170 !171 !175)
!177 = span !24 21271 21276
!178 = (!79 !168 !169 !170 !171 !175)
!179 = span !0 148 324
!180 = (!79 !168 !169 !170 !171 !179)
!181 = span !11 5377 5381
!182 = (!79 !168 !169 !170 !171 !179)
!183 = span !0 148 359
!184 = (!79 !168 !169 !170 !171 !183)
!185 = (!79 !168 !169 !170 !171 !183)
!186 = span !0 148 389
!187 = (!79 !168 !169 !170 !171 !186)
!188 = (!79 !168 !169 !170 !171 !186)
!189 = span !0 148 420
!190 = (!79 !168 !169 !170 !171 !189)
!191 = (!79 !168 !169 !170 !171 !189)
!192 = (!79 !168)
!193 = (!79 !80)
!194 = (!79 !80)
!195 = (!79 !80)
!196 = (!79 !80)
!197 = (!79 !80)
!198 = span !11 93817 93850
!199 = fn_call_path_span !11 93825 93835
!200 = (!79 !198 !199)
!201 = (!79 !198 !199)
!202 = span !0 556 560
!203 = (!79 !198 !199 !202)
!204 = span !14 116 122
!205 = (!79 !198 !199 !204)
!206 = (!79 !198 !199)
!207 = span !0 574 580
!208 = (!79 !198 !199 !207)
!209 = span !0 543 582
!210 = (!79 !198 !199 !209)
!211 = span !0 596 600
!212 = (!79 !198 !199 !211)
!213 = span !14 128 134
!214 = (!79 !198 !199 !213)
!215 = span !0 614 620
!216 = (!79 !198 !199 !215)
!217 = span !0 596 621
!218 = fn_call_path_span !0 603 613
!219 = (!79 !198 !199 !217 !218)
!220 = span !11 4980 5063
!221 = (!79 !198 !199 !217 !218 !220)
!222 = span !11 5032 5038
!223 = (!79 !198 !199 !217 !218 !222)
!224 = (!79 !198 !199 !217 !218 !92)
!225 = (!79 !198 !199 !217 !218)
!226 = (!79 !198 !199 !217 !218)
!227 = (!79 !198 !199 !217 !218)
!228 = (!79 !198 !199 !217 !218)
!229 = (!79 !198 !199 !217 !218)
!230 = (!79 !198 !199 !217 !218)
!231 = (!79 !198 !199 !217 !218)
!232 = (!79 !198 !199 !217 !218)
!233 = (!79 !198 !199 !217 !218)
!234 = (!79 !198 !199 !217 !218)
!235 = (!79 !198 !199 !217 !218)
!236 = (!79 !198 !199 !217 !218)
!237 = (!79 !198 !199 !217 !218)
!238 = (!79 !198 !199 !217 !218)
!239 = (!79 !198 !199 !217 !218)
!240 = (!79 !198 !199 !217 !218)
!241 = (!79 !198 !199 !217 !218)
!242 = (!79 !198 !199 !217 !218)
!243 = (!79 !198 !199 !217 !218)
!244 = (!79 !198 !199 !217 !218)
!245 = (!79 !198 !199 !217 !218)
!246 = (!79 !198 !199 !217 !218)
!247 = (!79 !198 !199 !217 !218)
!248 = (!79 !198 !199 !217 !218 !220)
!249 = span !0 583 622
!250 = (!79 !198 !199 !249)
!251 = span !0 636 640
!252 = (!79 !198 !199 !251)
!253 = span !14 140 146
!254 = (!79 !198 !199 !253)
!255 = span !0 654 660
!256 = (!79 !198 !199 !255)
!257 = span !0 636 661
!258 = fn_call_path_span !0 643 653
!259 = (!79 !198 !199 !257 !258)
!260 = span !11 5215 5298
!261 = (!79 !198 !199 !257 !258 !260)
!262 = span !11 5267 5273
!263 = (!79 !198 !199 !257 !258 !262)
!264 = (!79 !198 !199 !257 !258 !92)
!265 = (!79 !198 !199 !257 !258)
!266 = (!79 !198 !199 !257 !258)
!267 = (!79 !198 !199 !257 !258)
!268 = (!79 !198 !199 !257 !258)
!269 = (!79 !198 !199 !257 !258)
!270 = (!79 !198 !199 !257 !258)
!271 = (!79 !198 !199 !257 !258)
!272 = (!79 !198 !199 !257 !258)
!273 = (!79 !198 !199 !257 !258)
!274 = (!79 !198 !199 !257 !258)
!275 = (!79 !198 !199 !217 !218)
!276 = (!79 !198 !199 !217 !218)
!277 = (!79 !198 !199 !217 !218)
!278 = (!79 !198 !199 !217 !218)
!279 = (!79 !198 !199 !257 !258)
!280 = (!79 !198 !199 !257 !258)
!281 = (!79 !198 !199 !257 !258)
!282 = (!79 !198 !199 !257 !258)
!283 = (!79 !198 !199 !257 !258)
!284 = (!79 !198 !199 !257 !258)
!285 = (!79 !198 !199 !257 !258)
!286 = (!79 !198 !199 !257 !258)
!287 = (!79 !198 !199 !257 !258)
!288 = (!79 !198 !199 !257 !258)
!289 = (!79 !198 !199 !257 !258)
!290 = (!79 !198 !199 !257 !258)
!291 = (!79 !198 !199 !257 !258)
!292 = (!79 !198 !199 !257 !258 !260)
!293 = span !0 623 662
!294 = (!79 !198 !199 !293)
!295 = span !0 676 680
!296 = (!79 !198 !199 !295)
!297 = span !14 152 157
!298 = (!79 !198 !199 !297)
!299 = (!79 !198 !199)
!300 = span !0 694 700
!301 = (!79 !198 !199 !300)
!302 = span !0 676 701
!303 = fn_call_path_span !0 683 693
!304 = (!79 !198 !199 !302 !303)
!305 = span !11 5448 5531
!306 = (!79 !198 !199 !302 !303 !305)
!307 = span !11 5500 5506
!308 = (!79 !198 !199 !302 !303 !307)
!309 = (!79 !198 !199 !302 !303 !92)
!310 = (!79 !198 !199 !302 !303)
!311 = (!79 !198 !199 !302 !303)
!312 = (!79 !198 !199 !302 !303)
!313 = (!79 !198 !199 !302 !303)
!314 = (!79 !198 !199 !302 !303)
!315 = (!79 !198 !199 !302 !303)
!316 = (!79 !198 !199 !302 !303)
!317 = (!79 !198 !199 !302 !303)
!318 = (!79 !198 !199 !302 !303)
!319 = (!79 !198 !199 !302 !303)
!320 = (!79 !198 !199 !257 !258)
!321 = (!79 !198 !199 !257 !258)
!322 = (!79 !198 !199 !257 !258)
!323 = (!79 !198 !199 !257 !258)
!324 = (!79 !198 !199 !302 !303)
!325 = (!79 !198 !199 !302 !303)
!326 = (!79 !198 !199 !302 !303)
!327 = (!79 !198 !199 !302 !303)
!328 = (!79 !198 !199 !302 !303)
!329 = (!79 !198 !199 !302 !303)
!330 = (!79 !198 !199 !302 !303)
!331 = (!79 !198 !199 !302 !303)
!332 = (!79 !198 !199 !302 !303)
!333 = (!79 !198 !199 !302 !303)
!334 = (!79 !198 !199 !302 !303 !305)
!335 = span !0 663 702
!336 = (!79 !198 !199 !335)
!337 = span !0 716 720
!338 = (!79 !198 !199 !337)
!339 = span !14 163 174
!340 = (!79 !198 !199 !339)
!341 = span !0 734 740
!342 = (!79 !198 !199 !341)
!343 = span !0 716 741
!344 = fn_call_path_span !0 723 733
!345 = (!79 !198 !199 !343 !344)
!346 = (!79 !198 !199 !343 !344)
!347 = span !24 21353 21357
!348 = (!79 !198 !199 !343 !344 !347)
!349 = (!79 !198 !199 !343 !344 !106)
!350 = (!79 !198 !199 !343 !344)
!351 = span !24 21403 21409
!352 = (!79 !198 !199 !343 !344 !351)
!353 = span !24 21371 21411
!354 = (!79 !198 !199 !343 !344 !353)
!355 = span !24 21433 21434
!356 = (!79 !198 !199 !343 !344)
!357 = (!79 !198 !199 !302 !303)
!358 = (!79 !198 !199 !302 !303)
!359 = (!79 !198 !199 !302 !303)
!360 = (!79 !198 !199 !302 !303)
!361 = span !24 21450 21457
!362 = fn_call_path_span !24 21452 21453
!363 = (!79 !198 !199 !343 !344 !361 !362)
!364 = (!79 !198 !199 !343 !344)
!365 = span !24 21483 21487
!366 = (!79 !198 !199 !343 !344 !365)
!367 = span !24 21483 21504
!368 = fn_call_path_span !24 21488 21501
!369 = (!79 !198 !199 !343 !344 !367 !368)
!370 = span !24 8256 8260
!371 = (!79 !198 !199 !343 !344 !367 !368 !370)
!372 = (!79 !198 !199 !343 !344 !367 !368 !107)
!373 = (!79 !198 !199 !343 !344 !367 !368 !125)
!374 = (!79 !198 !199 !343 !344 !367 !368)
!375 = span !24 8256 8284
!376 = fn_call_path_span !24 8269 8272
!377 = (!79 !198 !199 !343 !344 !367 !368 !375 !376)
!378 = (!79 !198 !199 !343 !344 !367 !368 !375 !376)
!379 = span !24 8256 8296
!380 = fn_call_path_span !24 8285 8289
!381 = span !143 2650 2739
!382 = (!79 !198 !199 !343 !344 !367 !368 !379 !380 !381)
!383 = span !143 2688 2701
!384 = span !24 21543 21549
!385 = (!79 !198 !199 !343 !344 !384)
!386 = span !24 21518 21550
!387 = (!79 !198 !199 !343 !344 !386)
!388 = span !24 21569 21570
!389 = span !24 21564 21570
!390 = fn_call_path_span !24 21566 21568
!391 = (!79 !198 !199 !343 !344 !389 !390)
!392 = (!79 !198 !199 !343 !344)
!393 = span !24 21591 21597
!394 = (!79 !198 !199 !343 !344 !393)
!395 = span !0 703 742
!396 = (!79 !198 !199 !395)
!397 = span !0 756 760
!398 = (!79 !198 !199 !397)
!399 = span !14 180 186
!400 = (!79 !198 !199 !399)
!401 = span !0 774 780
!402 = (!79 !198 !199 !401)
!403 = span !0 756 781
!404 = fn_call_path_span !0 763 773
!405 = (!79 !198 !199 !403 !404)
!406 = (!79 !198 !199 !403 !404)
!407 = span !11 5719 5802
!408 = (!79 !198 !199 !403 !404 !407)
!409 = span !11 5771 5777
!410 = (!79 !198 !199 !403 !404 !409)
!411 = (!79 !198 !199 !403 !404 !92)
!412 = (!79 !198 !199 !403 !404)
!413 = (!79 !198 !199 !403 !404)
!414 = (!79 !198 !199 !403 !404)
!415 = (!79 !198 !199 !403 !404)
!416 = (!79 !198 !199 !403 !404)
!417 = (!79 !198 !199 !403 !404)
!418 = (!79 !198 !199 !403 !404)
!419 = span !11 5786 5790
!420 = (!79 !198 !199 !403 !404 !419)
!421 = (!79 !198 !199 !403 !404)
!422 = (!79 !198 !199 !403 !404)
!423 = (!79 !198 !199 !403 !404)
!424 = (!79 !198 !199 !403 !404)
!425 = (!79 !198 !199 !403 !404)
!426 = (!79 !198 !199 !403 !404)
!427 = (!79 !198 !199 !403 !404)
!428 = (!79 !198 !199 !403 !404)
!429 = (!79 !198 !199 !403 !404)
!430 = (!79 !198 !199 !403 !404)
!431 = (!79 !198 !199 !403 !404)
!432 = (!79 !198 !199 !403 !404)
!433 = (!79 !198 !199 !403 !404)
!434 = (!79 !198 !199 !403 !404)
!435 = (!79 !198 !199 !403 !404)
!436 = (!79 !198 !199 !403 !404)
!437 = (!79 !198 !199 !403 !404)
!438 = (!79 !198 !199 !403 !404)
!439 = (!79 !198 !199 !403 !404 !407)
!440 = span !0 743 782
!441 = (!79 !198 !199 !440)
!442 = span !0 796 800
!443 = (!79 !198 !199 !442)
!444 = span !14 192 199
!445 = (!79 !198 !199 !444)
!446 = span !0 814 820
!447 = (!79 !198 !199 !446)
!448 = span !0 796 821
!449 = fn_call_path_span !0 803 813
!450 = (!79 !198 !199 !448 !449)
!451 = (!79 !198 !199 !448 !449)
!452 = span !11 4511 4594
!453 = (!79 !198 !199 !448 !449 !452)
!454 = span !11 4563 4569
!455 = (!79 !198 !199 !448 !449 !454)
!456 = (!79 !198 !199 !448 !449 !92)
!457 = (!79 !198 !199 !448 !449)
!458 = (!79 !198 !199 !448 !449)
!459 = (!79 !198 !199 !448 !449)
!460 = (!79 !198 !199 !448 !449)
!461 = (!79 !198 !199 !448 !449)
!462 = (!79 !198 !199 !448 !449)
!463 = (!79 !198 !199 !448 !449)
!464 = span !11 4578 4582
!465 = (!79 !198 !199 !448 !449 !464)
!466 = (!79 !198 !199 !448 !449)
!467 = (!79 !198 !199 !448 !449)
!468 = (!79 !198 !199 !448 !449)
!469 = (!79 !198 !199 !403 !404)
!470 = (!79 !198 !199 !403 !404)
!471 = (!79 !198 !199 !403 !404)
!472 = (!79 !198 !199 !403 !404)
!473 = (!79 !198 !199 !448 !449)
!474 = (!79 !198 !199 !448 !449)
!475 = (!79 !198 !199 !448 !449)
!476 = (!79 !198 !199 !448 !449)
!477 = (!79 !198 !199 !448 !449)
!478 = (!79 !198 !199 !448 !449)
!479 = (!79 !198 !199 !448 !449)
!480 = (!79 !198 !199 !448 !449)
!481 = (!79 !198 !199 !448 !449)
!482 = (!79 !198 !199 !448 !449)
!483 = (!79 !198 !199 !448 !449)
!484 = (!79 !198 !199 !448 !449 !452)
!485 = span !0 783 822
!486 = (!79 !198 !199 !485)
!487 = span !0 840 846
!488 = (!79 !198 !199 !487)
!489 = span !11 93804 93851
!490 = (!79 !489)
!491 = span !11 93860 93866
!492 = (!79 !491)
!493 = (!79 !198 !199 !448 !449)
!494 = (!79 !198 !199 !448 !449)
!495 = (!79 !198 !199 !448 !449)
!496 = (!79 !198 !199 !448 !449)
!497 = (!75 !76 !77)
!498 = (!79 !80)
!499 = (!79 !80)
!500 = (!79 !80)
!501 = (!79 !80)
!502 = (!79 !80)
!503 = span !0 321 463
!504 = fn_name_span !0 324 334
!505 = (!503 !504)
!506 = span !14 92 97
!507 = (!75 !76 !77)
!508 = (!79 !168 !169 !170 !171 !172 !173)
!509 = (!79 !168)
!510 = (!79 !80)
!511 = (!79 !80)
!512 = (!79 !80)
!513 = (!79 !80)
!514 = (!79 !80)
!515 = (!79 !198 !199)
!516 = span !0 410 414
!517 = span !0 417 612
!518 = fn_call_path_span !0 417 612
!519 = (!79 !198 !199 !517 !518)
!520 = (!79 !198 !199 !517)
!521 = (!79 !198 !199 !516)
!522 = (!79 !198 !199)
!523 = span !0 487 493
!524 = (!79 !198 !199 !523)
!525 = span !0 471 475
!526 = (!79 !198 !199)
!527 = (!79 !198 !199 !516)
!528 = (!79 !198 !199 !516)
!529 = (!79 !198 !199)
!530 = span !0 614 694
!531 = fn_call_path_span !0 614 694
!532 = (!79 !198 !199 !530 !531)
!533 = (!79 !198 !199 !530)
!534 = span !0 664 670
!535 = (!79 !198 !199 !534)
!536 = span !0 648 652
!537 = (!79 !198 !199)
!538 = span !0 404 698
!539 = (!79 !198 !199 !538)
!540 = (!75 !76 !77)
!541 = span !14 433 438

DIFF------------------------------
.program:
DIFF------------------------------
.program:
DIFF------------------------------
.program:
.0                                      ; --- start of function: __entry ---
move $$locbase $sp                      ; save locals base register for function __entry
cfei i8                                 ; allocate 8 bytes for locals and 0 slots for call arguments
.24
fncall .2                               ; [call]: call main_0
move $r1 $$retv                         ; [call]: copy the return value
 sw $$locbase $r1 i0                     ; store word
 sw $$locbase $$retv i0                  ; store word
movi $r2 i8                             ; initialize constant into register
retd $$locbase $r2
DIFF------------------------------
.program:
.0                                      ; --- start of function: __entry ---
move $$locbase $sp                      ; save locals base register for function __entry
cfei i8                                 ; allocate 8 bytes for locals and 0 slots for call arguments
.24
fncall .2                               ; [call]: call main_0
sw $$locbase $$retv i0                  ; store word
movi $r2 i8                             ; initialize constant into register
retd $$locbase $r2
DIFF------------------------------
.program:
.0                                      ; --- start of function: __entry ---
move $$locbase $sp                      ; save locals base register for function __entry
cfei i8                                 ; allocate 8 bytes for locals and 0 slots for call arguments
.24
fncall .2                               ; [call]: call main_0
sw $$locbase $$retv i0                  ; store word
movi $r2 i8                             ; initialize constant into register
retd $$locbase $r2
DIFF------------------------------
.program:
.0                                      ; --- start of function: __entry ---
move $$locbase $sp                      ; save locals base register for function __entry
cfei i8                                 ; allocate 8 bytes for locals and 0 slots for call arguments
.24
fncall .2                               ; [call]: call main_0
sw $$locbase $$retv i0                  ; store word
movi $r2 i8                             ; initialize constant into register
retd $$locbase $r2
DIFF------------------------------
.program:
.2                                      ; --- start of function: main_0 ---
pusha .2                                ; save all registers
move $$locbase $sp                      ; save locals base register for function main_0
cfei i224                               ; allocate 224 bytes for locals and 0 slots for call arguments
move $r3 $$reta                         ; save return address
.25
load $r4 data_NonConfigurable_0         ; get local constant
 move $$arg0 $zero                       ; [call]: pass argument 0
 movi $$arg0 i0                          ; [call]: pass argument 0
fncall .4                               ; [call]: call local_log_1
 move $r5 $zero                          ; [call]: return unit value
 movi $r5 i0                             ; [call]: return unit value
addi $r6 $$locbase i200                 ; get offset to local __ptr { { ptr, u64 }, u64 }
addi $r7 $$locbase i32                  ; get offset to local __ptr { ptr, u64 }
movi $r8 i0                             ; get total allocation size in bytes
 aloc $r8                                ; allocate memory
 aloc $zero                              ; allocate memory
move $r9 $hp                            ; save allocated memory pointer
 sw $$locbase $r9 i4                     ; store word
 sw $$locbase $hp i4                     ; store word
addi $r10 $r7 i8                        ; get offset to aggregate element
sw $$locbase $zero i5                   ; store word
mcpi $r6 $r7 i16                        ; copy memory
addi $r11 $r6 i16                       ; get offset to aggregate element
sw $$locbase $zero i27                  ; store word
addi $r12 $$locbase i200                ; get offset to local __ptr { { ptr, u64 }, u64 }
move $$arg0 $r12                        ; [call]: pass argument 0
 move $$arg1 $one                        ; [call]: pass argument 1
 movi $$arg1 i1                          ; [call]: pass argument 1
fncall .12                              ; [call]: call push_11
 move $r13 $zero                         ; [call]: return unit value
 movi $r13 i0                            ; [call]: return unit value
addi $r14 $$locbase i200                ; get offset to local __ptr { { ptr, u64 }, u64 }
move $$arg0 $r14                        ; [call]: pass argument 0
movi $r15 i2                            ; initialize constant into register
 move $$arg1 $r15                        ; [call]: pass argument 1
 movi $$arg1 i2                          ; [call]: pass argument 1
fncall .12                              ; [call]: call push_11
 move $r16 $zero                         ; [call]: return unit value
 movi $r16 i0                            ; [call]: return unit value
addi $r17 $$locbase i200                ; get offset to local __ptr { { ptr, u64 }, u64 }
move $$arg0 $r17                        ; [call]: pass argument 0
movi $r18 i3                            ; initialize constant into register
 move $$arg1 $r18                        ; [call]: pass argument 1
 movi $$arg1 i3                          ; [call]: pass argument 1
fncall .12                              ; [call]: call push_11
 move $r19 $zero                         ; [call]: return unit value
 movi $r19 i0                            ; [call]: return unit value
addi $r20 $$locbase i56                 ; get offset to local __ptr { u64, u64, u64, u8, { { ptr, u64 }, u64 }, slice, u256 }
addi $r21 $$locbase i200                ; get offset to local __ptr { { ptr, u64 }, u64 }
addr $r22 data_NonConfigurable_1        ; get __const_global's address in data section
sw $$locbase $r22 i0                    ; store word
addi $r23 $$locbase i8                  ; get offset to aggregate element
movi $r24 i4                            ; initialize constant into register
sw $$locbase $r24 i1                    ; store word
addi $r25 $$locbase i16                 ; get offset to local __ptr slice
mcpi $r25 $$locbase i16                 ; copy memory
sw $$locbase $one i7                    ; store word
addi $r26 $r20 i8                       ; get offset to aggregate element
movi $r27 i2                            ; initialize constant into register
sw $$locbase $r27 i8                    ; store word
addi $r28 $r20 i16                      ; get offset to aggregate element
movi $r29 i3                            ; initialize constant into register
sw $$locbase $r29 i9                    ; store word
addi $r30 $r20 i24                      ; get offset to aggregate element
movi $r31 i4                            ; initialize constant into register
sb $r30 $r31 i0                         ; store byte
addi $r32 $r20 i32                      ; get offset to aggregate element
mcpi $r32 $r21 i24                      ; copy memory
addi $r33 $r20 i56                      ; get offset to aggregate element
mcpi $r33 $r25 i16                      ; copy memory
addi $r34 $r20 i72                      ; get offset to aggregate element
mcpi $r34 $r4 i32                       ; copy memory
addi $r35 $$locbase i56                 ; get offset to local __ptr { u64, u64, u64, u8, { { ptr, u64 }, u64 }, slice, u256 }
move $$arg0 $r35                        ; [call]: pass argument 0
fncall .14                              ; [call]: call local_log_21
 move $r36 $zero                         ; [call]: return unit value
 movi $r36 i0                            ; [call]: return unit value
addi $r37 $$locbase i160                ; get offset to local __ptr { u64 }
sw $$locbase $one i20                   ; store word
addi $r38 $$locbase i160                ; get offset to local __ptr { u64 }
move $$arg0 $r38                        ; [call]: pass argument 0
fncall .16                              ; [call]: call local_log_48
 move $r39 $zero                         ; [call]: return unit value
 movi $r39 i0                            ; [call]: return unit value
addi $r40 $$locbase i168                ; get offset to local __ptr { u64, ( { u64 } | () ) }
sw $$locbase $zero i21                  ; store word
addi $r41 $$locbase i48                 ; get offset to local __ptr { u64 }
sw $$locbase $one i6                    ; store word
addi $r42 $r40 i8                       ; get offset to aggregate element
mcpi $r42 $r41 i8                       ; copy memory
addi $r43 $$locbase i168                ; get offset to local __ptr { u64, ( { u64 } | () ) }
move $$arg0 $r43                        ; [call]: pass argument 0
fncall .20                              ; [call]: call local_log_53
 move $r44 $zero                         ; [call]: return unit value
 movi $r44 i0                            ; [call]: return unit value
addi $r45 $$locbase i184                ; get offset to local __ptr { u64, ( { u64 } | () ) }
sw $$locbase $one i23                   ; store word
addi $r46 $$locbase i184                ; get offset to local __ptr { u64, ( { u64 } | () ) }
move $$arg0 $r46                        ; [call]: pass argument 0
fncall .20                              ; [call]: call local_log_53
 move $r47 $zero                         ; [call]: return unit value
 movi $r47 i0                            ; [call]: return unit value
addi $r48 $$locbase i200                ; get offset to local __ptr {  }
move $$arg0 $r48                        ; [call]: pass argument 0
fncall .22                              ; [call]: call local_log_60
 move $r49 $zero                         ; [call]: return unit value
 move $$retv $one                        ; set return value
 movi $r49 i0                            ; [call]: return unit value
 movi $$retv i1                          ; set return value
ji  .3
.3
cfsi i224                               ; free 224 bytes for locals and 0 slots for extra call arguments
move $$reta $r3                         ; restore return address
popa .2                                 ; restore all registers
jal $zero $$reta i0                     ; return from call
DIFF------------------------------
.program:
.2                                      ; --- start of function: main_0 ---
pusha .2                                ; save all registers
move $$locbase $sp                      ; save locals base register for function main_0
cfei i224                               ; allocate 224 bytes for locals and 0 slots for call arguments
move $r3 $$reta                         ; save return address
.25
load $r4 data_NonConfigurable_0         ; get local constant
movi $$arg0 i0                          ; [call]: pass argument 0
fncall .4                               ; [call]: call local_log_1
addi $r6 $$locbase i200                 ; get offset to local __ptr { { ptr, u64 }, u64 }
addi $r7 $$locbase i32                  ; get offset to local __ptr { ptr, u64 }
aloc $zero                              ; allocate memory
sw $$locbase $hp i4                     ; store word
sw $$locbase $zero i5                   ; store word
mcpi $r6 $r7 i16                        ; copy memory
sw $$locbase $zero i27                  ; store word
addi $r12 $$locbase i200                ; get offset to local __ptr { { ptr, u64 }, u64 }
move $$arg0 $r12                        ; [call]: pass argument 0
movi $$arg1 i1                          ; [call]: pass argument 1
fncall .12                              ; [call]: call push_11
addi $r14 $$locbase i200                ; get offset to local __ptr { { ptr, u64 }, u64 }
move $$arg0 $r14                        ; [call]: pass argument 0
movi $$arg1 i2                          ; [call]: pass argument 1
fncall .12                              ; [call]: call push_11
addi $r17 $$locbase i200                ; get offset to local __ptr { { ptr, u64 }, u64 }
move $$arg0 $r17                        ; [call]: pass argument 0
movi $$arg1 i3                          ; [call]: pass argument 1
fncall .12                              ; [call]: call push_11
addi $r20 $$locbase i56                 ; get offset to local __ptr { u64, u64, u64, u8, { { ptr, u64 }, u64 }, slice, u256 }
addi $r21 $$locbase i200                ; get offset to local __ptr { { ptr, u64 }, u64 }
addr $r22 data_NonConfigurable_1        ; get __const_global's address in data section
sw $$locbase $r22 i0                    ; store word
movi $r24 i4                            ; initialize constant into register
sw $$locbase $r24 i1                    ; store word
addi $r25 $$locbase i16                 ; get offset to local __ptr slice
mcpi $r25 $$locbase i16                 ; copy memory
sw $$locbase $one i7                    ; store word
movi $r27 i2                            ; initialize constant into register
sw $$locbase $r27 i8                    ; store word
movi $r29 i3                            ; initialize constant into register
sw $$locbase $r29 i9                    ; store word
addi $r30 $r20 i24                      ; get offset to aggregate element
movi $r31 i4                            ; initialize constant into register
sb $r30 $r31 i0                         ; store byte
addi $r32 $r20 i32                      ; get offset to aggregate element
mcpi $r32 $r21 i24                      ; copy memory
addi $r33 $r20 i56                      ; get offset to aggregate element
mcpi $r33 $r25 i16                      ; copy memory
addi $r34 $r20 i72                      ; get offset to aggregate element
mcpi $r34 $r4 i32                       ; copy memory
addi $r35 $$locbase i56                 ; get offset to local __ptr { u64, u64, u64, u8, { { ptr, u64 }, u64 }, slice, u256 }
move $$arg0 $r35                        ; [call]: pass argument 0
fncall .14                              ; [call]: call local_log_21
sw $$locbase $one i20                   ; store word
addi $r38 $$locbase i160                ; get offset to local __ptr { u64 }
move $$arg0 $r38                        ; [call]: pass argument 0
fncall .16                              ; [call]: call local_log_48
addi $r40 $$locbase i168                ; get offset to local __ptr { u64, ( { u64 } | () ) }
sw $$locbase $zero i21                  ; store word
addi $r41 $$locbase i48                 ; get offset to local __ptr { u64 }
sw $$locbase $one i6                    ; store word
addi $r42 $r40 i8                       ; get offset to aggregate element
mcpi $r42 $r41 i8                       ; copy memory
addi $r43 $$locbase i168                ; get offset to local __ptr { u64, ( { u64 } | () ) }
move $$arg0 $r43                        ; [call]: pass argument 0
fncall .20                              ; [call]: call local_log_53
sw $$locbase $one i23                   ; store word
addi $r46 $$locbase i184                ; get offset to local __ptr { u64, ( { u64 } | () ) }
move $$arg0 $r46                        ; [call]: pass argument 0
fncall .20                              ; [call]: call local_log_53
addi $r48 $$locbase i200                ; get offset to local __ptr {  }
move $$arg0 $r48                        ; [call]: pass argument 0
fncall .22                              ; [call]: call local_log_60
movi $$retv i1                          ; set return value
.3
cfsi i224                               ; free 224 bytes for locals and 0 slots for extra call arguments
move $$reta $r3                         ; restore return address
popa .2                                 ; restore all registers
jal $zero $$reta i0                     ; return from call
DIFF------------------------------
.program:
.2                                      ; --- start of function: main_0 ---
pusha .2                                ; save all registers
move $$locbase $sp                      ; save locals base register for function main_0
cfei i224                               ; allocate 224 bytes for locals and 0 slots for call arguments
move $r3 $$reta                         ; save return address
.25
load $r4 data_NonConfigurable_0         ; get local constant
movi $$arg0 i0                          ; [call]: pass argument 0
fncall .4                               ; [call]: call local_log_1
addi $r6 $$locbase i200                 ; get offset to local __ptr { { ptr, u64 }, u64 }
addi $r7 $$locbase i32                  ; get offset to local __ptr { ptr, u64 }
aloc $zero                              ; allocate memory
sw $$locbase $hp i4                     ; store word
sw $$locbase $zero i5                   ; store word
mcpi $r6 $r7 i16                        ; copy memory
sw $$locbase $zero i27                  ; store word
addi $r12 $$locbase i200                ; get offset to local __ptr { { ptr, u64 }, u64 }
move $$arg0 $r12                        ; [call]: pass argument 0
movi $$arg1 i1                          ; [call]: pass argument 1
fncall .12                              ; [call]: call push_11
addi $r14 $$locbase i200                ; get offset to local __ptr { { ptr, u64 }, u64 }
move $$arg0 $r14                        ; [call]: pass argument 0
movi $$arg1 i2                          ; [call]: pass argument 1
fncall .12                              ; [call]: call push_11
addi $r17 $$locbase i200                ; get offset to local __ptr { { ptr, u64 }, u64 }
move $$arg0 $r17                        ; [call]: pass argument 0
movi $$arg1 i3                          ; [call]: pass argument 1
fncall .12                              ; [call]: call push_11
addi $r20 $$locbase i56                 ; get offset to local __ptr { u64, u64, u64, u8, { { ptr, u64 }, u64 }, slice, u256 }
addi $r21 $$locbase i200                ; get offset to local __ptr { { ptr, u64 }, u64 }
addr $r22 data_NonConfigurable_1        ; get __const_global's address in data section
sw $$locbase $r22 i0                    ; store word
movi $r24 i4                            ; initialize constant into register
sw $$locbase $r24 i1                    ; store word
addi $r25 $$locbase i16                 ; get offset to local __ptr slice
mcpi $r25 $$locbase i16                 ; copy memory
sw $$locbase $one i7                    ; store word
movi $r27 i2                            ; initialize constant into register
sw $$locbase $r27 i8                    ; store word
movi $r29 i3                            ; initialize constant into register
sw $$locbase $r29 i9                    ; store word
addi $r30 $r20 i24                      ; get offset to aggregate element
movi $r31 i4                            ; initialize constant into register
sb $r30 $r31 i0                         ; store byte
addi $r32 $r20 i32                      ; get offset to aggregate element
mcpi $r32 $r21 i24                      ; copy memory
addi $r33 $r20 i56                      ; get offset to aggregate element
mcpi $r33 $r25 i16                      ; copy memory
addi $r34 $r20 i72                      ; get offset to aggregate element
mcpi $r34 $r4 i32                       ; copy memory
addi $r35 $$locbase i56                 ; get offset to local __ptr { u64, u64, u64, u8, { { ptr, u64 }, u64 }, slice, u256 }
move $$arg0 $r35                        ; [call]: pass argument 0
fncall .14                              ; [call]: call local_log_21
sw $$locbase $one i20                   ; store word
addi $r38 $$locbase i160                ; get offset to local __ptr { u64 }
move $$arg0 $r38                        ; [call]: pass argument 0
fncall .16                              ; [call]: call local_log_48
addi $r40 $$locbase i168                ; get offset to local __ptr { u64, ( { u64 } | () ) }
sw $$locbase $zero i21                  ; store word
addi $r41 $$locbase i48                 ; get offset to local __ptr { u64 }
sw $$locbase $one i6                    ; store word
addi $r42 $r40 i8                       ; get offset to aggregate element
mcpi $r42 $r41 i8                       ; copy memory
addi $r43 $$locbase i168                ; get offset to local __ptr { u64, ( { u64 } | () ) }
move $$arg0 $r43                        ; [call]: pass argument 0
fncall .20                              ; [call]: call local_log_53
sw $$locbase $one i23                   ; store word
addi $r46 $$locbase i184                ; get offset to local __ptr { u64, ( { u64 } | () ) }
move $$arg0 $r46                        ; [call]: pass argument 0
fncall .20                              ; [call]: call local_log_53
addi $r48 $$locbase i200                ; get offset to local __ptr {  }
move $$arg0 $r48                        ; [call]: pass argument 0
fncall .22                              ; [call]: call local_log_60
movi $$retv i1                          ; set return value
.3
cfsi i224                               ; free 224 bytes for locals and 0 slots for extra call arguments
move $$reta $r3                         ; restore return address
popa .2                                 ; restore all registers
jal $zero $$reta i0                     ; return from call
DIFF------------------------------
.program:
.2                                      ; --- start of function: main_0 ---
pusha .2                                ; save all registers
move $$locbase $sp                      ; save locals base register for function main_0
cfei i224                               ; allocate 224 bytes for locals and 0 slots for call arguments
move $r3 $$reta                         ; save return address
.25
load $r4 data_NonConfigurable_0         ; get local constant
movi $$arg0 i0                          ; [call]: pass argument 0
fncall .4                               ; [call]: call local_log_1
addi $r6 $$locbase i200                 ; get offset to local __ptr { { ptr, u64 }, u64 }
addi $r7 $$locbase i32                  ; get offset to local __ptr { ptr, u64 }
aloc $zero                              ; allocate memory
sw $$locbase $hp i4                     ; store word
sw $$locbase $zero i5                   ; store word
mcpi $r6 $r7 i16                        ; copy memory
sw $$locbase $zero i27                  ; store word
addi $r12 $$locbase i200                ; get offset to local __ptr { { ptr, u64 }, u64 }
move $$arg0 $r12                        ; [call]: pass argument 0
movi $$arg1 i1                          ; [call]: pass argument 1
fncall .12                              ; [call]: call push_11
addi $r14 $$locbase i200                ; get offset to local __ptr { { ptr, u64 }, u64 }
move $$arg0 $r14                        ; [call]: pass argument 0
movi $$arg1 i2                          ; [call]: pass argument 1
fncall .12                              ; [call]: call push_11
addi $r17 $$locbase i200                ; get offset to local __ptr { { ptr, u64 }, u64 }
move $$arg0 $r17                        ; [call]: pass argument 0
movi $$arg1 i3                          ; [call]: pass argument 1
fncall .12                              ; [call]: call push_11
addi $r20 $$locbase i56                 ; get offset to local __ptr { u64, u64, u64, u8, { { ptr, u64 }, u64 }, slice, u256 }
addi $r21 $$locbase i200                ; get offset to local __ptr { { ptr, u64 }, u64 }
addr $r22 data_NonConfigurable_1        ; get __const_global's address in data section
sw $$locbase $r22 i0                    ; store word
movi $r24 i4                            ; initialize constant into register
sw $$locbase $r24 i1                    ; store word
addi $r25 $$locbase i16                 ; get offset to local __ptr slice
mcpi $r25 $$locbase i16                 ; copy memory
sw $$locbase $one i7                    ; store word
movi $r27 i2                            ; initialize constant into register
sw $$locbase $r27 i8                    ; store word
movi $r29 i3                            ; initialize constant into register
sw $$locbase $r29 i9                    ; store word
addi $r30 $r20 i24                      ; get offset to aggregate element
movi $r31 i4                            ; initialize constant into register
sb $r30 $r31 i0                         ; store byte
addi $r32 $r20 i32                      ; get offset to aggregate element
mcpi $r32 $r21 i24                      ; copy memory
addi $r33 $r20 i56                      ; get offset to aggregate element
mcpi $r33 $r25 i16                      ; copy memory
addi $r34 $r20 i72                      ; get offset to aggregate element
mcpi $r34 $r4 i32                       ; copy memory
addi $r35 $$locbase i56                 ; get offset to local __ptr { u64, u64, u64, u8, { { ptr, u64 }, u64 }, slice, u256 }
move $$arg0 $r35                        ; [call]: pass argument 0
fncall .14                              ; [call]: call local_log_21
sw $$locbase $one i20                   ; store word
addi $r38 $$locbase i160                ; get offset to local __ptr { u64 }
move $$arg0 $r38                        ; [call]: pass argument 0
fncall .16                              ; [call]: call local_log_48
addi $r40 $$locbase i168                ; get offset to local __ptr { u64, ( { u64 } | () ) }
sw $$locbase $zero i21                  ; store word
addi $r41 $$locbase i48                 ; get offset to local __ptr { u64 }
sw $$locbase $one i6                    ; store word
addi $r42 $r40 i8                       ; get offset to aggregate element
mcpi $r42 $r41 i8                       ; copy memory
addi $r43 $$locbase i168                ; get offset to local __ptr { u64, ( { u64 } | () ) }
move $$arg0 $r43                        ; [call]: pass argument 0
fncall .20                              ; [call]: call local_log_53
sw $$locbase $one i23                   ; store word
addi $r46 $$locbase i184                ; get offset to local __ptr { u64, ( { u64 } | () ) }
move $$arg0 $r46                        ; [call]: pass argument 0
fncall .20                              ; [call]: call local_log_53
addi $r48 $$locbase i200                ; get offset to local __ptr {  }
move $$arg0 $r48                        ; [call]: pass argument 0
fncall .22                              ; [call]: call local_log_60
movi $$retv i1                          ; set return value
.3
cfsi i224                               ; free 224 bytes for locals and 0 slots for extra call arguments
move $$reta $r3                         ; restore return address
popa .2                                 ; restore all registers
jal $zero $$reta i0                     ; return from call
DIFF------------------------------
.program:
.4                                      ; --- start of function: local_log_1 ---
pusha .4                                ; save all registers
move $$locbase $sp                      ; save locals base register for function local_log_1
cfei i40                                ; allocate 40 bytes for locals and 0 slots for call arguments
.26
addi $r51 $$locbase i32                 ; get offset to local __ptr u64
sw $$locbase $$arg0 i4                  ; store word
addi $r52 $$locbase i32                 ; get offset to local __ptr u64
sw $$locbase $r52 i0                    ; store word
addi $r53 $$locbase i8                  ; get offset to aggregate element
movi $r54 i8                            ; initialize constant into register
sw $$locbase $r54 i1                    ; store word
addi $r55 $$locbase i16                 ; get offset to local __ptr slice
mcpi $r55 $$locbase i16                 ; copy memory
load $r56 data_NonConfigurable_2        ; load constant from data section
lw $r57 $$locbase i2                    ; load slice pointer for logging data
lw $r58 $$locbase i3                    ; load slice size for logging data
logd $zero $r56 $r57 $r58               ; log slice
ji  .5
.5
cfsi i40                                ; free 40 bytes for locals and 0 slots for extra call arguments
popa .4                                 ; restore all registers
jal $zero $$reta i0                     ; return from call
DIFF------------------------------
.program:
.4                                      ; --- start of function: local_log_1 ---
pusha .4                                ; save all registers
move $$locbase $sp                      ; save locals base register for function local_log_1
cfei i40                                ; allocate 40 bytes for locals and 0 slots for call arguments
.26
sw $$locbase $$arg0 i4                  ; store word
addi $r52 $$locbase i32                 ; get offset to local __ptr u64
sw $$locbase $r52 i0                    ; store word
movi $r54 i8                            ; initialize constant into register
sw $$locbase $r54 i1                    ; store word
addi $r55 $$locbase i16                 ; get offset to local __ptr slice
mcpi $r55 $$locbase i16                 ; copy memory
load $r56 data_NonConfigurable_2        ; load constant from data section
lw $r57 $$locbase i2                    ; load slice pointer for logging data
lw $r58 $$locbase i3                    ; load slice size for logging data
logd $zero $r56 $r57 $r58               ; log slice
.5
cfsi i40                                ; free 40 bytes for locals and 0 slots for extra call arguments
popa .4                                 ; restore all registers
jal $zero $$reta i0                     ; return from call
DIFF------------------------------
.program:
.4                                      ; --- start of function: local_log_1 ---
pusha .4                                ; save all registers
move $$locbase $sp                      ; save locals base register for function local_log_1
cfei i40                                ; allocate 40 bytes for locals and 0 slots for call arguments
.26
sw $$locbase $$arg0 i4                  ; store word
addi $r52 $$locbase i32                 ; get offset to local __ptr u64
sw $$locbase $r52 i0                    ; store word
movi $r54 i8                            ; initialize constant into register
sw $$locbase $r54 i1                    ; store word
addi $r55 $$locbase i16                 ; get offset to local __ptr slice
mcpi $r55 $$locbase i16                 ; copy memory
load $r56 data_NonConfigurable_2        ; load constant from data section
lw $r57 $$locbase i2                    ; load slice pointer for logging data
lw $r58 $$locbase i3                    ; load slice size for logging data
logd $zero $r56 $r57 $r58               ; log slice
.5
cfsi i40                                ; free 40 bytes for locals and 0 slots for extra call arguments
popa .4                                 ; restore all registers
jal $zero $$reta i0                     ; return from call
DIFF------------------------------
.program:
.4                                      ; --- start of function: local_log_1 ---
pusha .4                                ; save all registers
move $$locbase $sp                      ; save locals base register for function local_log_1
cfei i40                                ; allocate 40 bytes for locals and 0 slots for call arguments
.26
sw $$locbase $$arg0 i4                  ; store word
addi $r52 $$locbase i32                 ; get offset to local __ptr u64
sw $$locbase $r52 i0                    ; store word
movi $r54 i8                            ; initialize constant into register
sw $$locbase $r54 i1                    ; store word
addi $r55 $$locbase i16                 ; get offset to local __ptr slice
mcpi $r55 $$locbase i16                 ; copy memory
load $r56 data_NonConfigurable_2        ; load constant from data section
lw $r57 $$locbase i2                    ; load slice pointer for logging data
lw $r58 $$locbase i3                    ; load slice size for logging data
logd $zero $r56 $r57 $r58               ; log slice
.5
cfsi i40                                ; free 40 bytes for locals and 0 slots for extra call arguments
popa .4                                 ; restore all registers
jal $zero $$reta i0                     ; return from call
DIFF------------------------------
.program:
.6                                      ; --- start of function: abi_encode_5 ---
pusha .6                                ; save all registers
move $$locbase $sp                      ; save locals base register for function abi_encode_5
cfei i144                               ; allocate 144 bytes for locals and 0 slots for call arguments
.27
addi $r60 $$locbase i120                ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r60 $$arg1 i24                    ; copy memory
addi $r61 $$locbase i96                 ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r62 $$locbase i120                ; get offset to local __ptr { { ptr, u64, u64 } }
move $r63 $r62                          ; return value from ASM block with return register buffer
 mcpi $$locbase $r63 i24                 ; copy memory
 mcpi $$locbase $r62 i24                 ; copy memory
addi $r64 $$locbase i48                 ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r64 $$locbase i24                 ; copy memory
lw $r65 $$locbase i6                    ; load word
addi $r66 $r64 i8                       ; get offset to aggregate element
lw $r67 $$locbase i7                    ; load word
addi $r68 $r64 i16                      ; get offset to aggregate element
lw $r69 $$locbase i8                    ; load word
movi $r70 i8                            ; initialize constant into register
add $r71 $r69 $r70
gt $r72 $r71 $r67
move $r73 $r65                          ; move parameter from branch to block argument
move $r74 $r67                          ; move parameter from branch to block argument
jnzi $r72 .28
ji  .29
.28
movi $r75 i2                            ; initialize constant into register
mul $r76 $r67 $r75
movi $r77 i8                            ; initialize constant into register
add $r78 $r76 $r77
aloc $r78
mcp $hp $r65 $r69
move $r79 $hp                           ; return value from ASM block with return register hp
 move $r73 $r79                          ; move parameter from branch to block argument
 move $r73 $hp                           ; move parameter from branch to block argument
move $r74 $r78                          ; move parameter from branch to block argument
ji  .29
.29
move $r83 $r73                          ; move parameter from branch to block argument
move $r85 $r74                          ; move parameter from branch to block argument
 add $r86 $r83 $r69
 add $r86 $r73 $r69
sw $r86 $$arg0 i0                       ; store word
addi $r87 $$locbase i72                 ; get offset to local __ptr { ptr, u64, u64 }
sw $$locbase $r83 i9                    ; store word
addi $r88 $r87 i8                       ; get offset to aggregate element
sw $$locbase $r85 i10                   ; store word
addi $r89 $r87 i16                      ; get offset to aggregate element
sw $$locbase $r71 i11                   ; store word
move $r90 $r87                          ; return value from ASM block with return register buffer
addi $r91 $$locbase i24                 ; get offset to local __ptr { ptr, u64, u64 }
 mcpi $r91 $r90 i24                      ; copy memory
 mcpi $r91 $r87 i24                      ; copy memory
mcpi $r61 $r91 i24                      ; copy memory
mcpi $$arg2 $r61 i24                    ; copy memory
ji  .7
.7
cfsi i144                               ; free 144 bytes for locals and 0 slots for extra call arguments
popa .6                                 ; restore all registers
jal $zero $$reta i0                     ; return from call
DIFF------------------------------
.program:
.6                                      ; --- start of function: abi_encode_5 ---
pusha .6                                ; save all registers
move $$locbase $sp                      ; save locals base register for function abi_encode_5
cfei i144                               ; allocate 144 bytes for locals and 0 slots for call arguments
.27
addi $r60 $$locbase i120                ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r60 $$arg1 i24                    ; copy memory
addi $r61 $$locbase i96                 ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r62 $$locbase i120                ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $$locbase $r62 i24                 ; copy memory
addi $r64 $$locbase i48                 ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r64 $$locbase i24                 ; copy memory
lw $r65 $$locbase i6                    ; load word
lw $r67 $$locbase i7                    ; load word
lw $r69 $$locbase i8                    ; load word
movi $r70 i8                            ; initialize constant into register
add $r71 $r69 $r70
gt $r72 $r71 $r67
move $r73 $r65                          ; move parameter from branch to block argument
move $r74 $r67                          ; move parameter from branch to block argument
jnzi $r72 .28
ji  .29
.28
movi $r75 i2                            ; initialize constant into register
mul $r76 $r67 $r75
movi $r77 i8                            ; initialize constant into register
add $r78 $r76 $r77
aloc $r78
mcp $hp $r65 $r69
move $r73 $hp                           ; move parameter from branch to block argument
move $r74 $r78                          ; move parameter from branch to block argument
.29
move $r83 $r73                          ; move parameter from branch to block argument
move $r85 $r74                          ; move parameter from branch to block argument
add $r86 $r73 $r69
sw $r86 $$arg0 i0                       ; store word
addi $r87 $$locbase i72                 ; get offset to local __ptr { ptr, u64, u64 }
sw $$locbase $r83 i9                    ; store word
sw $$locbase $r85 i10                   ; store word
sw $$locbase $r71 i11                   ; store word
addi $r91 $$locbase i24                 ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r91 $r87 i24                      ; copy memory
mcpi $r61 $r91 i24                      ; copy memory
mcpi $$arg2 $r61 i24                    ; copy memory
.7
cfsi i144                               ; free 144 bytes for locals and 0 slots for extra call arguments
popa .6                                 ; restore all registers
jal $zero $$reta i0                     ; return from call
DIFF------------------------------
.program:
.6                                      ; --- start of function: abi_encode_5 ---
pusha .6                                ; save all registers
move $$locbase $sp                      ; save locals base register for function abi_encode_5
cfei i144                               ; allocate 144 bytes for locals and 0 slots for call arguments
.27
addi $r60 $$locbase i120                ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r60 $$arg1 i24                    ; copy memory
addi $r61 $$locbase i96                 ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r62 $$locbase i120                ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $$locbase $r62 i24                 ; copy memory
addi $r64 $$locbase i48                 ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r64 $$locbase i24                 ; copy memory
lw $r65 $$locbase i6                    ; load word
lw $r67 $$locbase i7                    ; load word
lw $r69 $$locbase i8                    ; load word
movi $r70 i8                            ; initialize constant into register
add $r71 $r69 $r70
gt $r72 $r71 $r67
move $r73 $r65                          ; move parameter from branch to block argument
move $r74 $r67                          ; move parameter from branch to block argument
jnzi $r72 .28
ji  .29
.28
movi $r75 i2                            ; initialize constant into register
mul $r76 $r67 $r75
movi $r77 i8                            ; initialize constant into register
add $r78 $r76 $r77
aloc $r78
mcp $hp $r65 $r69
move $r73 $hp                           ; move parameter from branch to block argument
move $r74 $r78                          ; move parameter from branch to block argument
.29
move $r83 $r73                          ; move parameter from branch to block argument
move $r85 $r74                          ; move parameter from branch to block argument
add $r86 $r73 $r69
sw $r86 $$arg0 i0                       ; store word
addi $r87 $$locbase i72                 ; get offset to local __ptr { ptr, u64, u64 }
sw $$locbase $r83 i9                    ; store word
sw $$locbase $r85 i10                   ; store word
sw $$locbase $r71 i11                   ; store word
addi $r91 $$locbase i24                 ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r91 $r87 i24                      ; copy memory
mcpi $r61 $r91 i24                      ; copy memory
mcpi $$arg2 $r61 i24                    ; copy memory
.7
cfsi i144                               ; free 144 bytes for locals and 0 slots for extra call arguments
popa .6                                 ; restore all registers
jal $zero $$reta i0                     ; return from call
DIFF------------------------------
.program:
.6                                      ; --- start of function: abi_encode_5 ---
pusha .6                                ; save all registers
move $$locbase $sp                      ; save locals base register for function abi_encode_5
cfei i144                               ; allocate 144 bytes for locals and 0 slots for call arguments
.27
addi $r60 $$locbase i120                ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r60 $$arg1 i24                    ; copy memory
addi $r61 $$locbase i96                 ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r62 $$locbase i120                ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $$locbase $r62 i24                 ; copy memory
addi $r64 $$locbase i48                 ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r64 $$locbase i24                 ; copy memory
lw $r65 $$locbase i6                    ; load word
lw $r67 $$locbase i7                    ; load word
lw $r69 $$locbase i8                    ; load word
movi $r70 i8                            ; initialize constant into register
add $r71 $r69 $r70
gt $r72 $r71 $r67
move $r73 $r65                          ; move parameter from branch to block argument
move $r74 $r67                          ; move parameter from branch to block argument
jnzi $r72 .28
ji  .29
.28
movi $r75 i2                            ; initialize constant into register
mul $r76 $r67 $r75
movi $r77 i8                            ; initialize constant into register
add $r78 $r76 $r77
aloc $r78
mcp $hp $r65 $r69
move $r73 $hp                           ; move parameter from branch to block argument
move $r74 $r78                          ; move parameter from branch to block argument
.29
move $r83 $r73                          ; move parameter from branch to block argument
move $r85 $r74                          ; move parameter from branch to block argument
add $r86 $r73 $r69
sw $r86 $$arg0 i0                       ; store word
addi $r87 $$locbase i72                 ; get offset to local __ptr { ptr, u64, u64 }
sw $$locbase $r83 i9                    ; store word
sw $$locbase $r85 i10                   ; store word
sw $$locbase $r71 i11                   ; store word
addi $r91 $$locbase i24                 ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r91 $r87 i24                      ; copy memory
mcpi $r61 $r91 i24                      ; copy memory
mcpi $$arg2 $r61 i24                    ; copy memory
.7
cfsi i144                               ; free 144 bytes for locals and 0 slots for extra call arguments
popa .6                                 ; restore all registers
jal $zero $$reta i0                     ; return from call
DIFF------------------------------
.program:
.8                                      ; --- start of function: new_6 ---
pusha .8                                ; save all registers
move $$locbase $sp                      ; save locals base register for function new_6
cfei i72                                ; allocate 72 bytes for locals and 0 slots for call arguments
.30
addi $r93 $$locbase i48                 ; get offset to local __ptr { { ptr, u64, u64 } }
movi $r94 i1024                         ; initialize constant into register
aloc $r94
move $r95 $hp                           ; return value from ASM block with return register hp
addi $r96 $$locbase i24                 ; get offset to local __ptr { ptr, u64, u64 }
 sw $$locbase $r95 i3                    ; store word
 sw $$locbase $hp i3                     ; store word
addi $r97 $r96 i8                       ; get offset to aggregate element
movi $r98 i1024                         ; initialize constant into register
sw $$locbase $r98 i4                    ; store word
addi $r99 $r96 i16                      ; get offset to aggregate element
sw $$locbase $zero i5                   ; store word
move $r100 $r96                         ; return value from ASM block with return register buffer
 mcpi $$locbase $r100 i24                ; copy memory
 mcpi $$locbase $r96 i24                 ; copy memory
mcpi $r93 $$locbase i24                 ; copy memory
mcpi $$arg0 $r93 i24                    ; copy memory
ji  .9
.9
cfsi i72                                ; free 72 bytes for locals and 0 slots for extra call arguments
popa .8                                 ; restore all registers
jal $zero $$reta i0                     ; return from call
DIFF------------------------------
.program:
.8                                      ; --- start of function: new_6 ---
pusha .8                                ; save all registers
move $$locbase $sp                      ; save locals base register for function new_6
cfei i72                                ; allocate 72 bytes for locals and 0 slots for call arguments
.30
addi $r93 $$locbase i48                 ; get offset to local __ptr { { ptr, u64, u64 } }
movi $r94 i1024                         ; initialize constant into register
aloc $r94
addi $r96 $$locbase i24                 ; get offset to local __ptr { ptr, u64, u64 }
sw $$locbase $hp i3                     ; store word
movi $r98 i1024                         ; initialize constant into register
sw $$locbase $r98 i4                    ; store word
sw $$locbase $zero i5                   ; store word
mcpi $$locbase $r96 i24                 ; copy memory
mcpi $r93 $$locbase i24                 ; copy memory
mcpi $$arg0 $r93 i24                    ; copy memory
.9
cfsi i72                                ; free 72 bytes for locals and 0 slots for extra call arguments
popa .8                                 ; restore all registers
jal $zero $$reta i0                     ; return from call
DIFF------------------------------
.program:
.8                                      ; --- start of function: new_6 ---
pusha .8                                ; save all registers
move $$locbase $sp                      ; save locals base register for function new_6
cfei i72                                ; allocate 72 bytes for locals and 0 slots for call arguments
.30
addi $r93 $$locbase i48                 ; get offset to local __ptr { { ptr, u64, u64 } }
movi $r94 i1024                         ; initialize constant into register
aloc $r94
addi $r96 $$locbase i24                 ; get offset to local __ptr { ptr, u64, u64 }
sw $$locbase $hp i3                     ; store word
movi $r98 i1024                         ; initialize constant into register
sw $$locbase $r98 i4                    ; store word
sw $$locbase $zero i5                   ; store word
mcpi $$locbase $r96 i24                 ; copy memory
mcpi $r93 $$locbase i24                 ; copy memory
mcpi $$arg0 $r93 i24                    ; copy memory
.9
cfsi i72                                ; free 72 bytes for locals and 0 slots for extra call arguments
popa .8                                 ; restore all registers
jal $zero $$reta i0                     ; return from call
DIFF------------------------------
.program:
.8                                      ; --- start of function: new_6 ---
pusha .8                                ; save all registers
move $$locbase $sp                      ; save locals base register for function new_6
cfei i72                                ; allocate 72 bytes for locals and 0 slots for call arguments
.30
addi $r93 $$locbase i48                 ; get offset to local __ptr { { ptr, u64, u64 } }
movi $r94 i1024                         ; initialize constant into register
aloc $r94
addi $r96 $$locbase i24                 ; get offset to local __ptr { ptr, u64, u64 }
sw $$locbase $hp i3                     ; store word
movi $r98 i1024                         ; initialize constant into register
sw $$locbase $r98 i4                    ; store word
sw $$locbase $zero i5                   ; store word
mcpi $$locbase $r96 i24                 ; copy memory
mcpi $r93 $$locbase i24                 ; copy memory
mcpi $$arg0 $r93 i24                    ; copy memory
.9
cfsi i72                                ; free 72 bytes for locals and 0 slots for extra call arguments
popa .8                                 ; restore all registers
jal $zero $$reta i0                     ; return from call
DIFF------------------------------
.program:
.10                                     ; --- start of function: as_raw_slice_7 ---
pusha .10                               ; save all registers
move $$locbase $sp                      ; save locals base register for function as_raw_slice_7
cfei i56                                ; allocate 56 bytes for locals and 0 slots for call arguments
.31
addi $r102 $$locbase i32                ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r102 $$arg0 i24                   ; copy memory
addi $r103 $$locbase i32                ; get offset to local __ptr { { ptr, u64, u64 } }
move $r104 $r103                        ; return value from ASM block with return register buffer
lw $r105 $r103 i0                       ; load word
 addi $r106 $r104 i16                    ; get offset to aggregate element
 addi $r106 $r103 i16                    ; get offset to aggregate element
lw $r107 $r103 i2                       ; load word
addi $r108 $$locbase i16                ; get offset to local __ptr { ptr, u64 }
sw $$locbase $r105 i2                   ; store word
addi $r109 $r108 i8                     ; get offset to aggregate element
sw $$locbase $r107 i3                   ; store word
move $r110 $r108                        ; return value from ASM block with return register s
 mcpi $$locbase $r110 i16                ; copy memory
 mcpi $$locbase $r108 i16                ; copy memory
mcpi $$arg1 $$locbase i16               ; copy memory
ji  .11
.11
cfsi i56                                ; free 56 bytes for locals and 0 slots for extra call arguments
popa .10                                ; restore all registers
jal $zero $$reta i0                     ; return from call
DIFF------------------------------
.program:
.10                                     ; --- start of function: as_raw_slice_7 ---
pusha .10                               ; save all registers
move $$locbase $sp                      ; save locals base register for function as_raw_slice_7
cfei i56                                ; allocate 56 bytes for locals and 0 slots for call arguments
.31
addi $r102 $$locbase i32                ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r102 $$arg0 i24                   ; copy memory
addi $r103 $$locbase i32                ; get offset to local __ptr { { ptr, u64, u64 } }
lw $r105 $$locbase i4                   ; load word
lw $r107 $$locbase i6                   ; load word
addi $r108 $$locbase i16                ; get offset to local __ptr { ptr, u64 }
sw $$locbase $r105 i2                   ; store word
sw $$locbase $r107 i3                   ; store word
mcpi $$locbase $r108 i16                ; copy memory
mcpi $$arg1 $$locbase i16               ; copy memory
.11
cfsi i56                                ; free 56 bytes for locals and 0 slots for extra call arguments
popa .10                                ; restore all registers
jal $zero $$reta i0                     ; return from call
DIFF------------------------------
.program:
.10                                     ; --- start of function: as_raw_slice_7 ---
pusha .10                               ; save all registers
move $$locbase $sp                      ; save locals base register for function as_raw_slice_7
cfei i56                                ; allocate 56 bytes for locals and 0 slots for call arguments
.31
addi $r102 $$locbase i32                ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r102 $$arg0 i24                   ; copy memory
lw $r105 $$locbase i4                   ; load word
lw $r107 $$locbase i6                   ; load word
addi $r108 $$locbase i16                ; get offset to local __ptr { ptr, u64 }
sw $$locbase $r105 i2                   ; store word
sw $$locbase $r107 i3                   ; store word
mcpi $$locbase $r108 i16                ; copy memory
mcpi $$arg1 $$locbase i16               ; copy memory
.11
cfsi i56                                ; free 56 bytes for locals and 0 slots for extra call arguments
popa .10                                ; restore all registers
jal $zero $$reta i0                     ; return from call
DIFF------------------------------
.program:
.10                                     ; --- start of function: as_raw_slice_7 ---
pusha .10                               ; save all registers
move $$locbase $sp                      ; save locals base register for function as_raw_slice_7
cfei i56                                ; allocate 56 bytes for locals and 0 slots for call arguments
.31
addi $r102 $$locbase i32                ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r102 $$arg0 i24                   ; copy memory
lw $r105 $$locbase i4                   ; load word
lw $r107 $$locbase i6                   ; load word
addi $r108 $$locbase i16                ; get offset to local __ptr { ptr, u64 }
sw $$locbase $r105 i2                   ; store word
sw $$locbase $r107 i3                   ; store word
mcpi $$locbase $r108 i16                ; copy memory
mcpi $$arg1 $$locbase i16               ; copy memory
.11
cfsi i56                                ; free 56 bytes for locals and 0 slots for extra call arguments
popa .10                                ; restore all registers
jal $zero $$reta i0                     ; return from call
DIFF------------------------------
.program:
.12                                     ; --- start of function: push_11 ---
pusha .12                               ; save all registers
move $$locbase $sp                      ; save locals base register for function push_11
cfei i0                                 ; allocate 0 bytes for locals and 0 slots for call arguments
.32
addi $r112 $$arg0 i16                   ; get offset to aggregate element
lw $r113 $$arg0 i2                      ; load word
addi $r114 $$arg0 i8                    ; get offset to aggregate element
lw $r115 $$arg0 i1                      ; load word
eq $r116 $r113 $r115
jnzi $r116 .33
ji  .34
.33
lw $r117 $r114 i0                       ; load word
eq $r118 $r117 $zero
 move $r119 $one                         ; move parameter from branch to block argument
 movi $r119 i1                           ; move parameter from branch to block argument
jnzi $r118 .35
ji  .36
.36
lw $r120 $r114 i0                       ; load word
movi $r121 i2                           ; initialize constant into register
mul $r122 $r121 $r120
move $r119 $r122                        ; move parameter from branch to block argument
ji  .35
.35
move $r125 $r119                        ; move parameter from branch to block argument
lw $r126 $$arg0 i0                      ; load word
lw $r127 $r114 i0                       ; load word
 gt $r128 $r125 $r127
 gt $r128 $r119 $r127
move $r129 $r126                        ; move parameter from branch to block argument
jnzi $r128 .37
ji  .38
.37
movi $r130 i8                           ; get size of allocation element type
mul $r130 $r130 $r125                   ; get total allocation size in bytes
aloc $r130                              ; allocate memory
move $r131 $hp                          ; save allocated memory pointer
gt $r132 $r127 $zero
 move $r129 $r131                        ; move parameter from branch to block argument
 move $r129 $hp                          ; move parameter from branch to block argument
jnzi $r132 .39
ji  .38
.39
movi $r134 i8                           ; initialize constant into register
mul $r135 $r127 $r134
mcp $r131 $r126 $r135                   ; mcp dst src len
 move $r136 $zero                        ; return unit value from ASM block without return register
 movi $r136 i0                           ; return unit value from ASM block without return register
move $r129 $r131                        ; move parameter from branch to block argument
ji  .38
.38
move $r139 $r129                        ; move parameter from branch to block argument
 sw $$arg0 $r139 i0                      ; store word
 sw $$arg0 $r129 i0                      ; store word
sw $r114 $r125 i0                       ; store word
ji  .34
.34
lw $r140 $$arg0 i0                      ; load word
lw $r141 $r112 i0                       ; load word
movi $r142 i8                           ; initialize constant into register
mul $r143 $r142 $r141
add $r144 $r140 $r143
move $r145 $$arg1                       ; copy ASM block argument's constant initial value to register
 sw $r144 $r145 i0                       ; sw ptr val i0
 move $r146 $zero                        ; return unit value from ASM block without return register
 sw $r144 $$arg1 i0                      ; sw ptr val i0
 movi $r146 i0                           ; return unit value from ASM block without return register
lw $r147 $r112 i0                       ; load word
add $r148 $r147 $one
sw $r112 $r148 i0                       ; store word
ji  .13
.13
cfsi i0                                 ; free 0 bytes for locals and 0 slots for extra call arguments
popa .12                                ; restore all registers
jal $zero $$reta i0                     ; return from call
DIFF------------------------------
.program:
.12                                     ; --- start of function: push_11 ---
pusha .12                               ; save all registers
move $$locbase $sp                      ; save locals base register for function push_11
.32
addi $r112 $$arg0 i16                   ; get offset to aggregate element
lw $r113 $$arg0 i2                      ; load word
addi $r114 $$arg0 i8                    ; get offset to aggregate element
lw $r115 $$arg0 i1                      ; load word
eq $r116 $r113 $r115
jnzi $r116 .33
ji  .34
.33
lw $r117 $r114 i0                       ; load word
eq $r118 $r117 $zero
movi $r119 i1                           ; move parameter from branch to block argument
jnzi $r118 .35
.36
lw $r120 $r114 i0                       ; load word
movi $r121 i2                           ; initialize constant into register
mul $r122 $r121 $r120
move $r119 $r122                        ; move parameter from branch to block argument
.35
move $r125 $r119                        ; move parameter from branch to block argument
lw $r126 $$arg0 i0                      ; load word
lw $r127 $r114 i0                       ; load word
gt $r128 $r119 $r127
move $r129 $r126                        ; move parameter from branch to block argument
jnzi $r128 .37
ji  .38
.37
movi $r130 i8                           ; get size of allocation element type
mul $r130 $r130 $r125                   ; get total allocation size in bytes
aloc $r130                              ; allocate memory
move $r131 $hp                          ; save allocated memory pointer
gt $r132 $r127 $zero
move $r129 $hp                          ; move parameter from branch to block argument
jnzi $r132 .39
ji  .38
.39
movi $r134 i8                           ; initialize constant into register
mul $r135 $r127 $r134
mcp $r131 $r126 $r135                   ; mcp dst src len
move $r129 $r131                        ; move parameter from branch to block argument
.38
sw $$arg0 $r129 i0                      ; store word
sw $r114 $r125 i0                       ; store word
.34
lw $r140 $$arg0 i0                      ; load word
lw $r141 $r112 i0                       ; load word
movi $r142 i8                           ; initialize constant into register
mul $r143 $r142 $r141
add $r144 $r140 $r143
sw $r144 $$arg1 i0                      ; sw ptr val i0
lw $r147 $r112 i0                       ; load word
add $r148 $r147 $one
sw $r112 $r148 i0                       ; store word
.13
popa .12                                ; restore all registers
jal $zero $$reta i0                     ; return from call
DIFF------------------------------
.program:
.12                                     ; --- start of function: push_11 ---
pusha .12                               ; save all registers
move $$locbase $sp                      ; save locals base register for function push_11
.32
addi $r112 $$arg0 i16                   ; get offset to aggregate element
lw $r113 $$arg0 i2                      ; load word
addi $r114 $$arg0 i8                    ; get offset to aggregate element
lw $r115 $$arg0 i1                      ; load word
eq $r116 $r113 $r115
jnzi $r116 .33
ji  .34
.33
lw $r117 $r114 i0                       ; load word
eq $r118 $r117 $zero
movi $r119 i1                           ; move parameter from branch to block argument
jnzi $r118 .35
.36
lw $r120 $r114 i0                       ; load word
movi $r121 i2                           ; initialize constant into register
mul $r122 $r121 $r120
move $r119 $r122                        ; move parameter from branch to block argument
.35
move $r125 $r119                        ; move parameter from branch to block argument
lw $r126 $$arg0 i0                      ; load word
lw $r127 $r114 i0                       ; load word
gt $r128 $r119 $r127
move $r129 $r126                        ; move parameter from branch to block argument
jnzi $r128 .37
ji  .38
.37
movi $r130 i8                           ; get size of allocation element type
mul $r130 $r130 $r125                   ; get total allocation size in bytes
aloc $r130                              ; allocate memory
move $r131 $hp                          ; save allocated memory pointer
gt $r132 $r127 $zero
move $r129 $hp                          ; move parameter from branch to block argument
jnzi $r132 .39
ji  .38
.39
movi $r134 i8                           ; initialize constant into register
mul $r135 $r127 $r134
mcp $r131 $r126 $r135                   ; mcp dst src len
move $r129 $r131                        ; move parameter from branch to block argument
.38
sw $$arg0 $r129 i0                      ; store word
sw $r114 $r125 i0                       ; store word
.34
lw $r140 $$arg0 i0                      ; load word
lw $r141 $r112 i0                       ; load word
movi $r142 i8                           ; initialize constant into register
mul $r143 $r142 $r141
add $r144 $r140 $r143
sw $r144 $$arg1 i0                      ; sw ptr val i0
lw $r147 $r112 i0                       ; load word
add $r148 $r147 $one
sw $r112 $r148 i0                       ; store word
.13
popa .12                                ; restore all registers
jal $zero $$reta i0                     ; return from call
DIFF------------------------------
.program:
.12                                     ; --- start of function: push_11 ---
pusha .12                               ; save all registers
move $$locbase $sp                      ; save locals base register for function push_11
.32
addi $r112 $$arg0 i16                   ; get offset to aggregate element
lw $r113 $$arg0 i2                      ; load word
addi $r114 $$arg0 i8                    ; get offset to aggregate element
lw $r115 $$arg0 i1                      ; load word
eq $r116 $r113 $r115
jnzi $r116 .33
ji  .34
.33
lw $r117 $r114 i0                       ; load word
eq $r118 $r117 $zero
movi $r119 i1                           ; move parameter from branch to block argument
jnzi $r118 .35
.36
lw $r120 $r114 i0                       ; load word
movi $r121 i2                           ; initialize constant into register
mul $r122 $r121 $r120
move $r119 $r122                        ; move parameter from branch to block argument
.35
move $r125 $r119                        ; move parameter from branch to block argument
lw $r126 $$arg0 i0                      ; load word
lw $r127 $r114 i0                       ; load word
gt $r128 $r119 $r127
move $r129 $r126                        ; move parameter from branch to block argument
jnzi $r128 .37
ji  .38
.37
movi $r130 i8                           ; get size of allocation element type
mul $r130 $r130 $r125                   ; get total allocation size in bytes
aloc $r130                              ; allocate memory
move $r131 $hp                          ; save allocated memory pointer
gt $r132 $r127 $zero
move $r129 $hp                          ; move parameter from branch to block argument
jnzi $r132 .39
ji  .38
.39
movi $r134 i8                           ; initialize constant into register
mul $r135 $r127 $r134
mcp $r131 $r126 $r135                   ; mcp dst src len
move $r129 $r131                        ; move parameter from branch to block argument
.38
sw $$arg0 $r129 i0                      ; store word
sw $r114 $r125 i0                       ; store word
.34
lw $r140 $$arg0 i0                      ; load word
lw $r141 $r112 i0                       ; load word
movi $r142 i8                           ; initialize constant into register
mul $r143 $r142 $r141
add $r144 $r140 $r143
sw $r144 $$arg1 i0                      ; sw ptr val i0
lw $r147 $r112 i0                       ; load word
add $r148 $r147 $one
sw $r112 $r148 i0                       ; store word
.13
popa .12                                ; restore all registers
jal $zero $$reta i0                     ; return from call
DIFF------------------------------
.program:
.14                                     ; --- start of function: local_log_21 ---
pusha .14                               ; save all registers
move $$locbase $sp                      ; save locals base register for function local_log_21
cfei i1672                              ; allocate 1672 bytes for locals and 0 slots for call arguments
move $r149 $$arg0                       ; save argument 0 (item)
move $r150 $$reta                       ; save return address
.40
addi $r151 $$locbase i1368              ; get offset to local __ptr { u64, u64, u64, u8, { { ptr, u64 }, u64 }, slice, u256 }
 mcpi $r151 $r149 i104                   ; copy memory
 mcpi $r151 $$arg0 i104                  ; copy memory
addi $r152 $$locbase i1368              ; get offset to local __ptr { u64, u64, u64, u8, { { ptr, u64 }, u64 }, slice, u256 }
 move $r153 $zero                        ; move parameter from branch to block argument
 jnzi $zero .41
 movi $r153 i0                           ; move parameter from branch to block argument
 
ji  .42
.41
 move $r153 $zero                        ; move parameter from branch to block argument
                                         ; move parameter from branch to block argument
ji  .42
.42
move $r156 $r153                        ; move parameter from branch to block argument
 move $r157 $r156                        ; move parameter from branch to block argument
 jnzi $r156 .43
 move $r157 $r153                        ; move parameter from branch to block argument
 jnzi $r153 .43
ji  .44
.43
 move $r157 $one                         ; move parameter from branch to block argument
 movi $r157 i1                           ; move parameter from branch to block argument
ji  .44
.44
move $r160 $r157                        ; move parameter from branch to block argument
 move $r161 $r160                        ; move parameter from branch to block argument
 jnzi $r160 .45
 move $r161 $r157                        ; move parameter from branch to block argument
 jnzi $r157 .45
ji  .46
.45
 move $r161 $zero                        ; move parameter from branch to block argument
 movi $r161 i0                           ; move parameter from branch to block argument
ji  .46
.46
move $r164 $r161                        ; move parameter from branch to block argument
 move $r165 $r164                        ; move parameter from branch to block argument
 jnzi $r164 .47
 move $r165 $r161                        ; move parameter from branch to block argument
 jnzi $r161 .47
ji  .48
.47
 move $r165 $zero                        ; move parameter from branch to block argument
 movi $r165 i0                           ; move parameter from branch to block argument
ji  .48
.48
move $r168 $r165                        ; move parameter from branch to block argument
 move $r169 $r168                        ; move parameter from branch to block argument
 jnzi $r168 .49
 move $r169 $r165                        ; move parameter from branch to block argument
 jnzi $r165 .49
ji  .50
.49
 move $r169 $one                         ; move parameter from branch to block argument
 movi $r169 i1                           ; move parameter from branch to block argument
ji  .50
.50
move $r172 $r169                        ; move parameter from branch to block argument
 jnzi $r172 .51
 jnzi $r169 .51
ji  .52
.52
addi $r173 $$locbase i696               ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r173                       ; [call]: pass argument 0
fncall .8                               ; [call]: call new_6
 move $r174 $zero                        ; [call]: return unit value
 movi $r174 i0                           ; [call]: return unit value
addi $r175 $$locbase i1472              ; get offset to local __ptr { u64, u64, u64, u8, { { ptr, u64 }, u64 }, slice, u256 }
mcpi $r175 $r152 i104                   ; copy memory
addi $r176 $$locbase i1008              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r176 $r173 i24                    ; copy memory
addi $r177 $$locbase i1472              ; get offset to local __ptr { u64, u64, u64, u8, { { ptr, u64 }, u64 }, slice, u256 }
lw $r178 $$locbase i184                 ; load word
addi $r179 $$locbase i1008              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r180 $$locbase i856               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r180 $r179 i24                    ; copy memory
addi $r181 $$locbase i624               ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r178                       ; [call]: pass argument 0
move $$arg1 $r180                       ; [call]: pass argument 1
move $$arg2 $r181                       ; [call]: pass argument 2
fncall .6                               ; [call]: call abi_encode_5
 move $r182 $zero                        ; [call]: return unit value
 movi $r182 i0                           ; [call]: return unit value
addi $r183 $$locbase i1176              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r183 $r181 i24                    ; copy memory
addi $r184 $$locbase i1472              ; get offset to local __ptr { u64, u64, u64, u8, { { ptr, u64 }, u64 }, slice, u256 }
addi $r185 $r184 i8                     ; get offset to aggregate element
addi $r186 $$locbase i1176              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r187 $$locbase i1032              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r187 $r186 i24                    ; copy memory
addi $r188 $$locbase i736               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r189 $$locbase i1032              ; get offset to local __ptr { { ptr, u64, u64 } }
move $r190 $r189                        ; return value from ASM block with return register buffer
 mcpi $$locbase $r190 i24                ; copy memory
 mcpi $$locbase $r189 i24                ; copy memory
addi $r191 $$locbase i288               ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r191 $$locbase i24                ; copy memory
lw $r192 $$locbase i36                  ; load word
addi $r193 $r191 i8                     ; get offset to aggregate element
lw $r194 $$locbase i37                  ; load word
addi $r195 $r191 i16                    ; get offset to aggregate element
lw $r196 $$locbase i38                  ; load word
movi $r197 i4                           ; initialize constant into register
add $r198 $r196 $r197
gt $r199 $r198 $r194
move $r200 $r192                        ; move parameter from branch to block argument
move $r201 $r194                        ; move parameter from branch to block argument
jnzi $r199 .53
ji  .54
.53
movi $r202 i2                           ; initialize constant into register
mul $r203 $r194 $r202
movi $r204 i4                           ; initialize constant into register
add $r205 $r203 $r204
aloc $r205
mcp $hp $r192 $r196
move $r206 $hp                          ; return value from ASM block with return register hp
 move $r200 $r206                        ; move parameter from branch to block argument
 move $r200 $hp                          ; move parameter from branch to block argument
move $r201 $r205                        ; move parameter from branch to block argument
ji  .54
.54
move $r210 $r200                        ; move parameter from branch to block argument
move $r212 $r201                        ; move parameter from branch to block argument
addi $r213 $$locbase i408               ; get offset to local __ptr u64
mcpi $r213 $r185 i8                     ; copy memory
movi $r214 i4                           ; initialize constant into register
add $r215 $r213 $r214
add $r216 $r210 $r196
mcpi $r216 $r215 i4                     ; copy memory
addi $r217 $$locbase i496               ; get offset to local __ptr { ptr, u64, u64 }
sw $$locbase $r210 i62                  ; store word
addi $r218 $r217 i8                     ; get offset to aggregate element
sw $$locbase $r212 i63                  ; store word
addi $r219 $r217 i16                    ; get offset to aggregate element
sw $$locbase $r198 i64                  ; store word
move $r220 $r217                        ; return value from ASM block with return register buffer
addi $r221 $$locbase i24                ; get offset to local __ptr { ptr, u64, u64 }
 mcpi $r221 $r220 i24                    ; copy memory
 mcpi $r221 $r217 i24                    ; copy memory
mcpi $r188 $r221 i24                    ; copy memory
addi $r222 $$locbase i1224              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r222 $r188 i24                    ; copy memory
addi $r223 $$locbase i1472              ; get offset to local __ptr { u64, u64, u64, u8, { { ptr, u64 }, u64 }, slice, u256 }
addi $r224 $r223 i16                    ; get offset to aggregate element
addi $r225 $$locbase i1224              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r226 $$locbase i1056              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r226 $r225 i24                    ; copy memory
addi $r227 $$locbase i760               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r228 $$locbase i1056              ; get offset to local __ptr { { ptr, u64, u64 } }
move $r229 $r228                        ; return value from ASM block with return register buffer
addi $r230 $$locbase i48                ; get offset to local __ptr { ptr, u64, u64 }
 mcpi $r230 $r229 i24                    ; copy memory
 mcpi $r230 $r228 i24                    ; copy memory
addi $r231 $$locbase i312               ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r231 $r230 i24                    ; copy memory
lw $r232 $$locbase i39                  ; load word
addi $r233 $r231 i8                     ; get offset to aggregate element
lw $r234 $$locbase i40                  ; load word
addi $r235 $r231 i16                    ; get offset to aggregate element
lw $r236 $$locbase i41                  ; load word
movi $r237 i2                           ; initialize constant into register
add $r238 $r236 $r237
gt $r239 $r238 $r234
move $r240 $r232                        ; move parameter from branch to block argument
move $r241 $r234                        ; move parameter from branch to block argument
jnzi $r239 .55
ji  .56
.55
movi $r242 i2                           ; initialize constant into register
mul $r243 $r234 $r242
movi $r244 i2                           ; initialize constant into register
add $r245 $r243 $r244
aloc $r245
mcp $hp $r232 $r236
move $r246 $hp                          ; return value from ASM block with return register hp
 move $r240 $r246                        ; move parameter from branch to block argument
 move $r240 $hp                          ; move parameter from branch to block argument
move $r241 $r245                        ; move parameter from branch to block argument
ji  .56
.56
move $r250 $r240                        ; move parameter from branch to block argument
move $r252 $r241                        ; move parameter from branch to block argument
addi $r253 $$locbase i416               ; get offset to local __ptr u64
mcpi $r253 $r224 i8                     ; copy memory
movi $r254 i6                           ; initialize constant into register
add $r255 $r253 $r254
add $r256 $r250 $r236
mcpi $r256 $r255 i2                     ; copy memory
addi $r257 $$locbase i520               ; get offset to local __ptr { ptr, u64, u64 }
sw $$locbase $r250 i65                  ; store word
addi $r258 $r257 i8                     ; get offset to aggregate element
sw $$locbase $r252 i66                  ; store word
addi $r259 $r257 i16                    ; get offset to aggregate element
sw $$locbase $r238 i67                  ; store word
move $r260 $r257                        ; return value from ASM block with return register buffer
addi $r261 $$locbase i96                ; get offset to local __ptr { ptr, u64, u64 }
 mcpi $r261 $r260 i24                    ; copy memory
 mcpi $r261 $r257 i24                    ; copy memory
mcpi $r227 $r261 i24                    ; copy memory
addi $r262 $$locbase i1248              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r262 $r227 i24                    ; copy memory
addi $r263 $$locbase i1472              ; get offset to local __ptr { u64, u64, u64, u8, { { ptr, u64 }, u64 }, slice, u256 }
addi $r264 $r263 i24                    ; get offset to aggregate element
lb $r265 $r264 i0                       ; load byte
addi $r266 $$locbase i1248              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r267 $$locbase i1080              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r267 $r266 i24                    ; copy memory
addi $r268 $$locbase i784               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r269 $$locbase i1080              ; get offset to local __ptr { { ptr, u64, u64 } }
move $r270 $r269                        ; return value from ASM block with return register buffer
addi $r271 $$locbase i120               ; get offset to local __ptr { ptr, u64, u64 }
 mcpi $r271 $r270 i24                    ; copy memory
 mcpi $r271 $r269 i24                    ; copy memory
addi $r272 $$locbase i336               ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r272 $r271 i24                    ; copy memory
lw $r273 $$locbase i42                  ; load word
addi $r274 $r272 i8                     ; get offset to aggregate element
lw $r275 $$locbase i43                  ; load word
addi $r276 $r272 i16                    ; get offset to aggregate element
lw $r277 $$locbase i44                  ; load word
add $r278 $r277 $one
gt $r279 $r278 $r275
move $r280 $r273                        ; move parameter from branch to block argument
move $r281 $r275                        ; move parameter from branch to block argument
jnzi $r279 .57
ji  .58
.57
movi $r282 i2                           ; initialize constant into register
mul $r283 $r275 $r282
add $r284 $r283 $one
aloc $r284
mcp $hp $r273 $r277
move $r285 $hp                          ; return value from ASM block with return register hp
 move $r280 $r285                        ; move parameter from branch to block argument
 move $r280 $hp                          ; move parameter from branch to block argument
move $r281 $r284                        ; move parameter from branch to block argument
ji  .58
.58
move $r289 $r280                        ; move parameter from branch to block argument
move $r291 $r281                        ; move parameter from branch to block argument
 add $r292 $r289 $r277
 add $r292 $r280 $r277
sb $r292 $r265 i0                       ; store byte
addi $r293 $$locbase i424               ; get offset to local __ptr { ptr, u64, u64 }
sw $$locbase $r289 i53                  ; store word
addi $r294 $r293 i8                     ; get offset to aggregate element
sw $$locbase $r291 i54                  ; store word
addi $r295 $r293 i16                    ; get offset to aggregate element
sw $$locbase $r278 i55                  ; store word
move $r296 $r293                        ; return value from ASM block with return register buffer
addi $r297 $$locbase i144               ; get offset to local __ptr { ptr, u64, u64 }
 mcpi $r297 $r296 i24                    ; copy memory
 mcpi $r297 $r293 i24                    ; copy memory
mcpi $r268 $r297 i24                    ; copy memory
addi $r298 $$locbase i1272              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r298 $r268 i24                    ; copy memory
addi $r299 $$locbase i1472              ; get offset to local __ptr { u64, u64, u64, u8, { { ptr, u64 }, u64 }, slice, u256 }
addi $r300 $r299 i32                    ; get offset to aggregate element
addi $r301 $$locbase i1272              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r302 $$locbase i1600              ; get offset to local __ptr { { ptr, u64 }, u64 }
mcpi $r302 $r300 i24                    ; copy memory
addi $r303 $$locbase i1104              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r303 $r301 i24                    ; copy memory
addi $r304 $$locbase i1600              ; get offset to local __ptr { { ptr, u64 }, u64 }
addi $r305 $r304 i16                    ; get offset to aggregate element
lw $r306 $$locbase i202                 ; load word
addi $r307 $$locbase i1104              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r308 $$locbase i880               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r308 $r307 i24                    ; copy memory
addi $r309 $$locbase i648               ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r306                       ; [call]: pass argument 0
move $$arg1 $r308                       ; [call]: pass argument 1
move $$arg2 $r309                       ; [call]: pass argument 2
fncall .6                               ; [call]: call abi_encode_5
 move $r310 $zero                        ; [call]: return unit value
 movi $r310 i0                           ; [call]: return unit value
addi $r311 $$locbase i1200              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r311 $r309 i24                    ; copy memory
 move $r312 $zero                        ; move parameter from branch to block argument
 movi $r312 i0                           ; move parameter from branch to block argument
ji  .59
.59
move $r314 $r312                        ; move parameter from branch to block argument
 lt $r315 $r314 $r306
 lt $r315 $r312 $r306
jnzi $r315 .60
ji  .61
.61
addi $r316 $$locbase i1200              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r317 $$locbase i1296              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r317 $r316 i24                    ; copy memory
addi $r318 $$locbase i1472              ; get offset to local __ptr { u64, u64, u64, u8, { { ptr, u64 }, u64 }, slice, u256 }
addi $r319 $r318 i56                    ; get offset to aggregate element
addi $r320 $$locbase i1296              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r321 $$locbase i1624              ; get offset to local __ptr slice
mcpi $r321 $r319 i16                    ; copy memory
addi $r322 $$locbase i1128              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r322 $r320 i24                    ; copy memory
addi $r323 $$locbase i808               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r324 $$locbase i1128              ; get offset to local __ptr { { ptr, u64, u64 } }
move $r325 $r324                        ; return value from ASM block with return register buffer
addi $r326 $$locbase i168               ; get offset to local __ptr { ptr, u64, u64 }
 mcpi $r326 $r325 i24                    ; copy memory
 mcpi $r326 $r324 i24                    ; copy memory
addi $r327 $$locbase i360               ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r327 $r326 i24                    ; copy memory
lw $r328 $$locbase i45                  ; load word
addi $r329 $r327 i8                     ; get offset to aggregate element
lw $r330 $$locbase i46                  ; load word
addi $r331 $r327 i16                    ; get offset to aggregate element
lw $r332 $$locbase i47                  ; load word
addi $r333 $$locbase i1624              ; get offset to local __ptr slice
addi $r334 $$locbase i208               ; get offset to local __ptr slice
mcpi $r334 $r333 i16                    ; copy memory
move $r335 $r333                        ; return value from ASM block with return register item
addi $r336 $$locbase i192               ; get offset to local __ptr { u64, u64 }
 mcpi $r336 $r335 i16                    ; copy memory
 mcpi $r336 $r333 i16                    ; copy memory
addi $r337 $$locbase i448               ; get offset to local __ptr { u64, u64 }
mcpi $r337 $r336 i16                    ; copy memory
addi $r338 $r337 i8                     ; get offset to aggregate element
lw $r339 $$locbase i57                  ; load word
movi $r340 i8                           ; initialize constant into register
add $r341 $r339 $r340
add $r342 $r332 $r341
gt $r343 $r342 $r330
move $r344 $r328                        ; move parameter from branch to block argument
move $r345 $r330                        ; move parameter from branch to block argument
jnzi $r343 .62
ji  .63
.62
movi $r346 i2                           ; initialize constant into register
mul $r347 $r330 $r346
add $r348 $r347 $r341
aloc $r348
mcp $hp $r328 $r332
move $r349 $hp                          ; return value from ASM block with return register hp
 move $r344 $r349                        ; move parameter from branch to block argument
 move $r344 $hp                          ; move parameter from branch to block argument
move $r345 $r348                        ; move parameter from branch to block argument
ji  .63
.63
move $r353 $r344                        ; move parameter from branch to block argument
move $r355 $r345                        ; move parameter from branch to block argument
addi $r356 $$locbase i544               ; get offset to local __ptr slice
mcpi $r356 $r334 i16                    ; copy memory
add $r357 $r353 $r332
lw $r359 $$locbase i69
sw $r357 $r359 i0
addi $r357 $r357 i8
lw $r358 $$locbase i68
mcp $r357 $r358 $r359
addi $r360 $r332 i8
add $r360 $r360 $r359
move $r361 $r360                        ; return value from ASM block with return register new_len
addi $r362 $$locbase i584               ; get offset to local __ptr { ptr, u64, u64 }
sw $$locbase $r353 i73                  ; store word
addi $r363 $r362 i8                     ; get offset to aggregate element
sw $$locbase $r355 i74                  ; store word
addi $r364 $r362 i16                    ; get offset to aggregate element
sw $$locbase $r361 i75                  ; store word
move $r365 $r362                        ; return value from ASM block with return register buffer
addi $r366 $$locbase i224               ; get offset to local __ptr { ptr, u64, u64 }
 mcpi $r366 $r365 i24                    ; copy memory
 mcpi $r366 $r362 i24                    ; copy memory
mcpi $r323 $r366 i24                    ; copy memory
addi $r367 $$locbase i1320              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r367 $r323 i24                    ; copy memory
addi $r368 $$locbase i1472              ; get offset to local __ptr { u64, u64, u64, u8, { { ptr, u64 }, u64 }, slice, u256 }
addi $r369 $r368 i72                    ; get offset to aggregate element
addi $r370 $$locbase i1320              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r371 $$locbase i1640              ; get offset to local __ptr u256
mcpi $r371 $r369 i32                    ; copy memory
addi $r372 $$locbase i1152              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r372 $r370 i24                    ; copy memory
addi $r373 $$locbase i832               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r374 $$locbase i1152              ; get offset to local __ptr { { ptr, u64, u64 } }
move $r375 $r374                        ; return value from ASM block with return register buffer
addi $r376 $$locbase i248               ; get offset to local __ptr { ptr, u64, u64 }
 mcpi $r376 $r375 i24                    ; copy memory
 mcpi $r376 $r374 i24                    ; copy memory
addi $r377 $$locbase i384               ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r377 $r376 i24                    ; copy memory
lw $r378 $$locbase i48                  ; load word
addi $r379 $r377 i8                     ; get offset to aggregate element
lw $r380 $$locbase i49                  ; load word
addi $r381 $r377 i16                    ; get offset to aggregate element
lw $r382 $$locbase i50                  ; load word
addi $r383 $$locbase i1640              ; get offset to local __ptr u256
movi $r384 i32                          ; initialize constant into register
add $r385 $r382 $r384
gt $r386 $r385 $r380
move $r387 $r378                        ; move parameter from branch to block argument
move $r388 $r380                        ; move parameter from branch to block argument
jnzi $r386 .64
ji  .65
.64
movi $r389 i2                           ; initialize constant into register
mul $r390 $r380 $r389
movi $r391 i32                          ; initialize constant into register
add $r392 $r390 $r391
aloc $r392
mcp $hp $r378 $r382
move $r393 $hp                          ; return value from ASM block with return register hp
 move $r387 $r393                        ; move parameter from branch to block argument
 move $r387 $hp                          ; move parameter from branch to block argument
move $r388 $r392                        ; move parameter from branch to block argument
ji  .65
.65
move $r397 $r387                        ; move parameter from branch to block argument
move $r399 $r388                        ; move parameter from branch to block argument
addi $r400 $$locbase i464               ; get offset to local __ptr u256
mcpi $r400 $r383 i32                    ; copy memory
add $r401 $r397 $r382
mcpi $r401 $r400 i32                    ; copy memory
addi $r402 $$locbase i560               ; get offset to local __ptr { ptr, u64, u64 }
sw $$locbase $r397 i70                  ; store word
addi $r403 $r402 i8                     ; get offset to aggregate element
sw $$locbase $r399 i71                  ; store word
addi $r404 $r402 i16                    ; get offset to aggregate element
sw $$locbase $r385 i72                  ; store word
move $r405 $r402                        ; return value from ASM block with return register buffer
addi $r406 $$locbase i72                ; get offset to local __ptr { ptr, u64, u64 }
 mcpi $r406 $r405 i24                    ; copy memory
 mcpi $r406 $r402 i24                    ; copy memory
mcpi $r373 $r406 i24                    ; copy memory
addi $r407 $$locbase i1344              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r407 $r373 i24                    ; copy memory
addi $r408 $$locbase i1344              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r409 $$locbase i984               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r409 $r408 i24                    ; copy memory
addi $r410 $$locbase i984               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r411 $$locbase i928               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r411 $r410 i24                    ; copy memory
addi $r412 $$locbase i720               ; get offset to local __ptr slice
move $$arg0 $r411                       ; [call]: pass argument 0
move $$arg1 $r412                       ; [call]: pass argument 1
fncall .10                              ; [call]: call as_raw_slice_7
 move $r413 $zero                        ; [call]: return unit value
 movi $r413 i0                           ; [call]: return unit value
addi $r414 $$locbase i952               ; get offset to local __ptr slice
mcpi $r414 $r412 i16                    ; copy memory
move $r415 $r414                        ; move parameter from branch to block argument
ji  .66
.60
addi $r416 $$locbase i1600              ; get offset to local __ptr { { ptr, u64 }, u64 }
addi $r417 $$locbase i1576              ; get offset to local __ptr { { ptr, u64 }, u64 }
mcpi $r417 $r416 i24                    ; copy memory
addi $r418 $$locbase i1576              ; get offset to local __ptr { { ptr, u64 }, u64 }
lw $r419 $$locbase i197                 ; load word
movi $r420 i8                           ; initialize constant into register
mul $r421 $r420 $r314
add $r422 $r419 $r421
lw $r423 $r422 i0                       ; lw val ptr i0
move $r424 $r423                        ; return value from ASM block with return register val
addi $r425 $$locbase i1200              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r426 $$locbase i904               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r426 $r425 i24                    ; copy memory
addi $r427 $$locbase i672               ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r424                       ; [call]: pass argument 0
move $$arg1 $r426                       ; [call]: pass argument 1
move $$arg2 $r427                       ; [call]: pass argument 2
fncall .6                               ; [call]: call abi_encode_5
 move $r428 $zero                        ; [call]: return unit value
 movi $r428 i0                           ; [call]: return unit value
addi $r429 $$locbase i1200              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r429 $r427 i24                    ; copy memory
add $r430 $r314 $one
move $r312 $r430                        ; move parameter from branch to block argument
ji  .59
.51
addi $r432 $$locbase i968               ; get offset to local __ptr { __ptr { u64, u64, u64, u8, { { ptr, u64 }, u64 }, slice, u256 }, u64 }
sw $$locbase $r152 i121                 ; store word
addi $r433 $r432 i8                     ; get offset to aggregate element
movi $r434 i104                         ; initialize constant into register
sw $$locbase $r434 i122                 ; store word
addi $r435 $$locbase i272               ; get offset to local __ptr { __ptr { u64, u64, u64, u8, { { ptr, u64 }, u64 }, slice, u256 }, u64 }
mcpi $r435 $r432 i16                    ; copy memory
addi $r436 $$locbase i952               ; get offset to local __ptr slice
mcpi $r436 $r435 i16                    ; copy memory
move $r415 $r436                        ; move parameter from branch to block argument
ji  .66
.66
move $r439 $r415                        ; move parameter from branch to block argument
addi $r440 $$locbase i608               ; get offset to local __ptr slice
 mcpi $r440 $r439 i16                    ; copy memory
 mcpi $r440 $r415 i16                    ; copy memory
load $r441 data_NonConfigurable_3       ; load constant from data section
lw $r442 $$locbase i76                  ; load slice pointer for logging data
lw $r443 $$locbase i77                  ; load slice size for logging data
logd $zero $r441 $r442 $r443            ; log slice
ji  .15
.15
cfsi i1672                              ; free 1672 bytes for locals and 0 slots for extra call arguments
move $$reta $r150                       ; restore return address
popa .14                                ; restore all registers
jal $zero $$reta i0                     ; return from call
DIFF------------------------------
.program:
.14                                     ; --- start of function: local_log_21 ---
pusha .14                               ; save all registers
move $$locbase $sp                      ; save locals base register for function local_log_21
cfei i1672                              ; allocate 1672 bytes for locals and 0 slots for call arguments
move $r150 $$reta                       ; save return address
.40
addi $r151 $$locbase i1368              ; get offset to local __ptr { u64, u64, u64, u8, { { ptr, u64 }, u64 }, slice, u256 }
mcpi $r151 $$arg0 i104                  ; copy memory
addi $r152 $$locbase i1368              ; get offset to local __ptr { u64, u64, u64, u8, { { ptr, u64 }, u64 }, slice, u256 }
movi $r153 i0                           ; move parameter from branch to block argument
.42
 move $r157 $r153                        ; move parameter from branch to block argument
 jnzi $r153 .43
 movi $r157 i0                           ; move parameter from branch to block argument
 
ji  .44
.43
movi $r157 i1                           ; move parameter from branch to block argument
.44
move $r161 $r157                        ; move parameter from branch to block argument
jnzi $r157 .45
ji  .46
.45
movi $r161 i0                           ; move parameter from branch to block argument
.46
move $r165 $r161                        ; move parameter from branch to block argument
jnzi $r161 .47
ji  .48
.47
movi $r165 i0                           ; move parameter from branch to block argument
.48
move $r169 $r165                        ; move parameter from branch to block argument
jnzi $r165 .49
ji  .50
.49
movi $r169 i1                           ; move parameter from branch to block argument
.50
jnzi $r169 .51
.52
addi $r173 $$locbase i696               ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r173                       ; [call]: pass argument 0
fncall .8                               ; [call]: call new_6
addi $r175 $$locbase i1472              ; get offset to local __ptr { u64, u64, u64, u8, { { ptr, u64 }, u64 }, slice, u256 }
mcpi $r175 $r152 i104                   ; copy memory
addi $r176 $$locbase i1008              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r176 $r173 i24                    ; copy memory
lw $r178 $$locbase i184                 ; load word
addi $r179 $$locbase i1008              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r180 $$locbase i856               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r180 $r179 i24                    ; copy memory
addi $r181 $$locbase i624               ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r178                       ; [call]: pass argument 0
move $$arg1 $r180                       ; [call]: pass argument 1
move $$arg2 $r181                       ; [call]: pass argument 2
fncall .6                               ; [call]: call abi_encode_5
addi $r183 $$locbase i1176              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r183 $r181 i24                    ; copy memory
addi $r184 $$locbase i1472              ; get offset to local __ptr { u64, u64, u64, u8, { { ptr, u64 }, u64 }, slice, u256 }
addi $r185 $r184 i8                     ; get offset to aggregate element
addi $r186 $$locbase i1176              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r187 $$locbase i1032              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r187 $r186 i24                    ; copy memory
addi $r188 $$locbase i736               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r189 $$locbase i1032              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $$locbase $r189 i24                ; copy memory
addi $r191 $$locbase i288               ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r191 $$locbase i24                ; copy memory
lw $r192 $$locbase i36                  ; load word
lw $r194 $$locbase i37                  ; load word
lw $r196 $$locbase i38                  ; load word
movi $r197 i4                           ; initialize constant into register
add $r198 $r196 $r197
gt $r199 $r198 $r194
move $r200 $r192                        ; move parameter from branch to block argument
move $r201 $r194                        ; move parameter from branch to block argument
jnzi $r199 .53
ji  .54
.53
movi $r202 i2                           ; initialize constant into register
mul $r203 $r194 $r202
movi $r204 i4                           ; initialize constant into register
add $r205 $r203 $r204
aloc $r205
mcp $hp $r192 $r196
move $r200 $hp                          ; move parameter from branch to block argument
move $r201 $r205                        ; move parameter from branch to block argument
.54
move $r210 $r200                        ; move parameter from branch to block argument
move $r212 $r201                        ; move parameter from branch to block argument
addi $r213 $$locbase i408               ; get offset to local __ptr u64
mcpi $r213 $r185 i8                     ; copy memory
movi $r214 i4                           ; initialize constant into register
add $r215 $r213 $r214
add $r216 $r210 $r196
mcpi $r216 $r215 i4                     ; copy memory
addi $r217 $$locbase i496               ; get offset to local __ptr { ptr, u64, u64 }
sw $$locbase $r210 i62                  ; store word
sw $$locbase $r212 i63                  ; store word
sw $$locbase $r198 i64                  ; store word
addi $r221 $$locbase i24                ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r221 $r217 i24                    ; copy memory
mcpi $r188 $r221 i24                    ; copy memory
addi $r222 $$locbase i1224              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r222 $r188 i24                    ; copy memory
addi $r223 $$locbase i1472              ; get offset to local __ptr { u64, u64, u64, u8, { { ptr, u64 }, u64 }, slice, u256 }
addi $r224 $r223 i16                    ; get offset to aggregate element
addi $r225 $$locbase i1224              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r226 $$locbase i1056              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r226 $r225 i24                    ; copy memory
addi $r227 $$locbase i760               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r228 $$locbase i1056              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r230 $$locbase i48                ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r230 $r228 i24                    ; copy memory
addi $r231 $$locbase i312               ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r231 $r230 i24                    ; copy memory
lw $r232 $$locbase i39                  ; load word
lw $r234 $$locbase i40                  ; load word
lw $r236 $$locbase i41                  ; load word
movi $r237 i2                           ; initialize constant into register
add $r238 $r236 $r237
gt $r239 $r238 $r234
move $r240 $r232                        ; move parameter from branch to block argument
move $r241 $r234                        ; move parameter from branch to block argument
jnzi $r239 .55
ji  .56
.55
movi $r242 i2                           ; initialize constant into register
mul $r243 $r234 $r242
movi $r244 i2                           ; initialize constant into register
add $r245 $r243 $r244
aloc $r245
mcp $hp $r232 $r236
move $r240 $hp                          ; move parameter from branch to block argument
move $r241 $r245                        ; move parameter from branch to block argument
.56
move $r250 $r240                        ; move parameter from branch to block argument
move $r252 $r241                        ; move parameter from branch to block argument
addi $r253 $$locbase i416               ; get offset to local __ptr u64
mcpi $r253 $r224 i8                     ; copy memory
movi $r254 i6                           ; initialize constant into register
add $r255 $r253 $r254
add $r256 $r250 $r236
mcpi $r256 $r255 i2                     ; copy memory
addi $r257 $$locbase i520               ; get offset to local __ptr { ptr, u64, u64 }
sw $$locbase $r250 i65                  ; store word
sw $$locbase $r252 i66                  ; store word
sw $$locbase $r238 i67                  ; store word
addi $r261 $$locbase i96                ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r261 $r257 i24                    ; copy memory
mcpi $r227 $r261 i24                    ; copy memory
addi $r262 $$locbase i1248              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r262 $r227 i24                    ; copy memory
addi $r263 $$locbase i1472              ; get offset to local __ptr { u64, u64, u64, u8, { { ptr, u64 }, u64 }, slice, u256 }
addi $r264 $r263 i24                    ; get offset to aggregate element
lb $r265 $r264 i0                       ; load byte
addi $r266 $$locbase i1248              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r267 $$locbase i1080              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r267 $r266 i24                    ; copy memory
addi $r268 $$locbase i784               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r269 $$locbase i1080              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r271 $$locbase i120               ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r271 $r269 i24                    ; copy memory
addi $r272 $$locbase i336               ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r272 $r271 i24                    ; copy memory
lw $r273 $$locbase i42                  ; load word
lw $r275 $$locbase i43                  ; load word
lw $r277 $$locbase i44                  ; load word
add $r278 $r277 $one
gt $r279 $r278 $r275
move $r280 $r273                        ; move parameter from branch to block argument
move $r281 $r275                        ; move parameter from branch to block argument
jnzi $r279 .57
ji  .58
.57
movi $r282 i2                           ; initialize constant into register
mul $r283 $r275 $r282
add $r284 $r283 $one
aloc $r284
mcp $hp $r273 $r277
move $r280 $hp                          ; move parameter from branch to block argument
move $r281 $r284                        ; move parameter from branch to block argument
.58
move $r289 $r280                        ; move parameter from branch to block argument
move $r291 $r281                        ; move parameter from branch to block argument
add $r292 $r280 $r277
sb $r292 $r265 i0                       ; store byte
addi $r293 $$locbase i424               ; get offset to local __ptr { ptr, u64, u64 }
sw $$locbase $r289 i53                  ; store word
sw $$locbase $r291 i54                  ; store word
sw $$locbase $r278 i55                  ; store word
addi $r297 $$locbase i144               ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r297 $r293 i24                    ; copy memory
mcpi $r268 $r297 i24                    ; copy memory
addi $r298 $$locbase i1272              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r298 $r268 i24                    ; copy memory
addi $r299 $$locbase i1472              ; get offset to local __ptr { u64, u64, u64, u8, { { ptr, u64 }, u64 }, slice, u256 }
addi $r300 $r299 i32                    ; get offset to aggregate element
addi $r301 $$locbase i1272              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r302 $$locbase i1600              ; get offset to local __ptr { { ptr, u64 }, u64 }
mcpi $r302 $r300 i24                    ; copy memory
addi $r303 $$locbase i1104              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r303 $r301 i24                    ; copy memory
lw $r306 $$locbase i202                 ; load word
addi $r307 $$locbase i1104              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r308 $$locbase i880               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r308 $r307 i24                    ; copy memory
addi $r309 $$locbase i648               ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r306                       ; [call]: pass argument 0
move $$arg1 $r308                       ; [call]: pass argument 1
move $$arg2 $r309                       ; [call]: pass argument 2
fncall .6                               ; [call]: call abi_encode_5
addi $r311 $$locbase i1200              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r311 $r309 i24                    ; copy memory
movi $r312 i0                           ; move parameter from branch to block argument
.59
move $r314 $r312                        ; move parameter from branch to block argument
lt $r315 $r312 $r306
jnzi $r315 .60
.61
addi $r316 $$locbase i1200              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r317 $$locbase i1296              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r317 $r316 i24                    ; copy memory
addi $r318 $$locbase i1472              ; get offset to local __ptr { u64, u64, u64, u8, { { ptr, u64 }, u64 }, slice, u256 }
addi $r319 $r318 i56                    ; get offset to aggregate element
addi $r320 $$locbase i1296              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r321 $$locbase i1624              ; get offset to local __ptr slice
mcpi $r321 $r319 i16                    ; copy memory
addi $r322 $$locbase i1128              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r322 $r320 i24                    ; copy memory
addi $r323 $$locbase i808               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r324 $$locbase i1128              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r326 $$locbase i168               ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r326 $r324 i24                    ; copy memory
addi $r327 $$locbase i360               ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r327 $r326 i24                    ; copy memory
lw $r328 $$locbase i45                  ; load word
lw $r330 $$locbase i46                  ; load word
lw $r332 $$locbase i47                  ; load word
addi $r333 $$locbase i1624              ; get offset to local __ptr slice
addi $r334 $$locbase i208               ; get offset to local __ptr slice
mcpi $r334 $r333 i16                    ; copy memory
addi $r336 $$locbase i192               ; get offset to local __ptr { u64, u64 }
mcpi $r336 $r333 i16                    ; copy memory
addi $r337 $$locbase i448               ; get offset to local __ptr { u64, u64 }
mcpi $r337 $r336 i16                    ; copy memory
lw $r339 $$locbase i57                  ; load word
movi $r340 i8                           ; initialize constant into register
add $r341 $r339 $r340
add $r342 $r332 $r341
gt $r343 $r342 $r330
move $r344 $r328                        ; move parameter from branch to block argument
move $r345 $r330                        ; move parameter from branch to block argument
jnzi $r343 .62
ji  .63
.62
movi $r346 i2                           ; initialize constant into register
mul $r347 $r330 $r346
add $r348 $r347 $r341
aloc $r348
mcp $hp $r328 $r332
move $r344 $hp                          ; move parameter from branch to block argument
move $r345 $r348                        ; move parameter from branch to block argument
.63
move $r353 $r344                        ; move parameter from branch to block argument
move $r355 $r345                        ; move parameter from branch to block argument
addi $r356 $$locbase i544               ; get offset to local __ptr slice
mcpi $r356 $r334 i16                    ; copy memory
add $r357 $r353 $r332
lw $r359 $$locbase i69
sw $r357 $r359 i0
addi $r357 $r357 i8
lw $r358 $$locbase i68
mcp $r357 $r358 $r359
addi $r360 $r332 i8
add $r360 $r360 $r359
move $r361 $r360                        ; return value from ASM block with return register new_len
addi $r362 $$locbase i584               ; get offset to local __ptr { ptr, u64, u64 }
sw $$locbase $r353 i73                  ; store word
sw $$locbase $r355 i74                  ; store word
sw $$locbase $r361 i75                  ; store word
addi $r366 $$locbase i224               ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r366 $r362 i24                    ; copy memory
mcpi $r323 $r366 i24                    ; copy memory
addi $r367 $$locbase i1320              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r367 $r323 i24                    ; copy memory
addi $r368 $$locbase i1472              ; get offset to local __ptr { u64, u64, u64, u8, { { ptr, u64 }, u64 }, slice, u256 }
addi $r369 $r368 i72                    ; get offset to aggregate element
addi $r370 $$locbase i1320              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r371 $$locbase i1640              ; get offset to local __ptr u256
mcpi $r371 $r369 i32                    ; copy memory
addi $r372 $$locbase i1152              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r372 $r370 i24                    ; copy memory
addi $r373 $$locbase i832               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r374 $$locbase i1152              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r376 $$locbase i248               ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r376 $r374 i24                    ; copy memory
addi $r377 $$locbase i384               ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r377 $r376 i24                    ; copy memory
lw $r378 $$locbase i48                  ; load word
lw $r380 $$locbase i49                  ; load word
lw $r382 $$locbase i50                  ; load word
addi $r383 $$locbase i1640              ; get offset to local __ptr u256
movi $r384 i32                          ; initialize constant into register
add $r385 $r382 $r384
gt $r386 $r385 $r380
move $r387 $r378                        ; move parameter from branch to block argument
move $r388 $r380                        ; move parameter from branch to block argument
jnzi $r386 .64
ji  .65
.64
movi $r389 i2                           ; initialize constant into register
mul $r390 $r380 $r389
movi $r391 i32                          ; initialize constant into register
add $r392 $r390 $r391
aloc $r392
mcp $hp $r378 $r382
move $r387 $hp                          ; move parameter from branch to block argument
move $r388 $r392                        ; move parameter from branch to block argument
.65
move $r397 $r387                        ; move parameter from branch to block argument
move $r399 $r388                        ; move parameter from branch to block argument
addi $r400 $$locbase i464               ; get offset to local __ptr u256
mcpi $r400 $r383 i32                    ; copy memory
add $r401 $r397 $r382
mcpi $r401 $r400 i32                    ; copy memory
addi $r402 $$locbase i560               ; get offset to local __ptr { ptr, u64, u64 }
sw $$locbase $r397 i70                  ; store word
sw $$locbase $r399 i71                  ; store word
sw $$locbase $r385 i72                  ; store word
addi $r406 $$locbase i72                ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r406 $r402 i24                    ; copy memory
mcpi $r373 $r406 i24                    ; copy memory
addi $r407 $$locbase i1344              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r407 $r373 i24                    ; copy memory
addi $r408 $$locbase i1344              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r409 $$locbase i984               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r409 $r408 i24                    ; copy memory
addi $r410 $$locbase i984               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r411 $$locbase i928               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r411 $r410 i24                    ; copy memory
addi $r412 $$locbase i720               ; get offset to local __ptr slice
move $$arg0 $r411                       ; [call]: pass argument 0
move $$arg1 $r412                       ; [call]: pass argument 1
fncall .10                              ; [call]: call as_raw_slice_7
addi $r414 $$locbase i952               ; get offset to local __ptr slice
mcpi $r414 $r412 i16                    ; copy memory
move $r415 $r414                        ; move parameter from branch to block argument
ji  .66
.60
addi $r416 $$locbase i1600              ; get offset to local __ptr { { ptr, u64 }, u64 }
addi $r417 $$locbase i1576              ; get offset to local __ptr { { ptr, u64 }, u64 }
mcpi $r417 $r416 i24                    ; copy memory
lw $r419 $$locbase i197                 ; load word
movi $r420 i8                           ; initialize constant into register
mul $r421 $r420 $r314
add $r422 $r419 $r421
lw $r423 $r422 i0                       ; lw val ptr i0
move $r424 $r423                        ; return value from ASM block with return register val
addi $r425 $$locbase i1200              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r426 $$locbase i904               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r426 $r425 i24                    ; copy memory
addi $r427 $$locbase i672               ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r424                       ; [call]: pass argument 0
move $$arg1 $r426                       ; [call]: pass argument 1
move $$arg2 $r427                       ; [call]: pass argument 2
fncall .6                               ; [call]: call abi_encode_5
addi $r429 $$locbase i1200              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r429 $r427 i24                    ; copy memory
add $r430 $r314 $one
move $r312 $r430                        ; move parameter from branch to block argument
ji  .59
.51
addi $r432 $$locbase i968               ; get offset to local __ptr { __ptr { u64, u64, u64, u8, { { ptr, u64 }, u64 }, slice, u256 }, u64 }
sw $$locbase $r152 i121                 ; store word
movi $r434 i104                         ; initialize constant into register
sw $$locbase $r434 i122                 ; store word
addi $r435 $$locbase i272               ; get offset to local __ptr { __ptr { u64, u64, u64, u8, { { ptr, u64 }, u64 }, slice, u256 }, u64 }
mcpi $r435 $r432 i16                    ; copy memory
addi $r436 $$locbase i952               ; get offset to local __ptr slice
mcpi $r436 $r435 i16                    ; copy memory
move $r415 $r436                        ; move parameter from branch to block argument
.66
addi $r440 $$locbase i608               ; get offset to local __ptr slice
mcpi $r440 $r415 i16                    ; copy memory
load $r441 data_NonConfigurable_3       ; load constant from data section
lw $r442 $$locbase i76                  ; load slice pointer for logging data
lw $r443 $$locbase i77                  ; load slice size for logging data
logd $zero $r441 $r442 $r443            ; log slice
.15
cfsi i1672                              ; free 1672 bytes for locals and 0 slots for extra call arguments
move $$reta $r150                       ; restore return address
popa .14                                ; restore all registers
jal $zero $$reta i0                     ; return from call
DIFF------------------------------
.program:
.14                                     ; --- start of function: local_log_21 ---
pusha .14                               ; save all registers
move $$locbase $sp                      ; save locals base register for function local_log_21
cfei i1672                              ; allocate 1672 bytes for locals and 0 slots for call arguments
move $r150 $$reta                       ; save return address
.40
addi $r151 $$locbase i1368              ; get offset to local __ptr { u64, u64, u64, u8, { { ptr, u64 }, u64 }, slice, u256 }
mcpi $r151 $$arg0 i104                  ; copy memory
addi $r152 $$locbase i1368              ; get offset to local __ptr { u64, u64, u64, u8, { { ptr, u64 }, u64 }, slice, u256 }
.42
movi $r157 i0                           ; move parameter from branch to block argument
.44
 move $r161 $r157                        ; move parameter from branch to block argument
 jnzi $r157 .45
 movi $r161 i0                           ; move parameter from branch to block argument
 
ji  .46
.45
 movi $r161 i0                           ; move parameter from branch to block argument
                                         ; move parameter from branch to block argument
.46
move $r165 $r161                        ; move parameter from branch to block argument
jnzi $r161 .47
ji  .48
.47
movi $r165 i0                           ; move parameter from branch to block argument
.48
move $r169 $r165                        ; move parameter from branch to block argument
jnzi $r165 .49
ji  .50
.49
movi $r169 i1                           ; move parameter from branch to block argument
.50
jnzi $r169 .51
.52
addi $r173 $$locbase i696               ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r173                       ; [call]: pass argument 0
fncall .8                               ; [call]: call new_6
addi $r175 $$locbase i1472              ; get offset to local __ptr { u64, u64, u64, u8, { { ptr, u64 }, u64 }, slice, u256 }
mcpi $r175 $r152 i104                   ; copy memory
addi $r176 $$locbase i1008              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r176 $r173 i24                    ; copy memory
lw $r178 $$locbase i184                 ; load word
addi $r179 $$locbase i1008              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r180 $$locbase i856               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r180 $r179 i24                    ; copy memory
addi $r181 $$locbase i624               ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r178                       ; [call]: pass argument 0
move $$arg1 $r180                       ; [call]: pass argument 1
move $$arg2 $r181                       ; [call]: pass argument 2
fncall .6                               ; [call]: call abi_encode_5
addi $r183 $$locbase i1176              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r183 $r181 i24                    ; copy memory
addi $r184 $$locbase i1472              ; get offset to local __ptr { u64, u64, u64, u8, { { ptr, u64 }, u64 }, slice, u256 }
addi $r185 $r184 i8                     ; get offset to aggregate element
addi $r186 $$locbase i1176              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r187 $$locbase i1032              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r187 $r186 i24                    ; copy memory
addi $r188 $$locbase i736               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r189 $$locbase i1032              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $$locbase $r189 i24                ; copy memory
addi $r191 $$locbase i288               ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r191 $$locbase i24                ; copy memory
lw $r192 $$locbase i36                  ; load word
lw $r194 $$locbase i37                  ; load word
lw $r196 $$locbase i38                  ; load word
movi $r197 i4                           ; initialize constant into register
add $r198 $r196 $r197
gt $r199 $r198 $r194
move $r200 $r192                        ; move parameter from branch to block argument
move $r201 $r194                        ; move parameter from branch to block argument
jnzi $r199 .53
ji  .54
.53
movi $r202 i2                           ; initialize constant into register
mul $r203 $r194 $r202
movi $r204 i4                           ; initialize constant into register
add $r205 $r203 $r204
aloc $r205
mcp $hp $r192 $r196
move $r200 $hp                          ; move parameter from branch to block argument
move $r201 $r205                        ; move parameter from branch to block argument
.54
move $r210 $r200                        ; move parameter from branch to block argument
move $r212 $r201                        ; move parameter from branch to block argument
addi $r213 $$locbase i408               ; get offset to local __ptr u64
mcpi $r213 $r185 i8                     ; copy memory
movi $r214 i4                           ; initialize constant into register
add $r215 $r213 $r214
add $r216 $r210 $r196
mcpi $r216 $r215 i4                     ; copy memory
addi $r217 $$locbase i496               ; get offset to local __ptr { ptr, u64, u64 }
sw $$locbase $r210 i62                  ; store word
sw $$locbase $r212 i63                  ; store word
sw $$locbase $r198 i64                  ; store word
addi $r221 $$locbase i24                ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r221 $r217 i24                    ; copy memory
mcpi $r188 $r221 i24                    ; copy memory
addi $r222 $$locbase i1224              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r222 $r188 i24                    ; copy memory
addi $r223 $$locbase i1472              ; get offset to local __ptr { u64, u64, u64, u8, { { ptr, u64 }, u64 }, slice, u256 }
addi $r224 $r223 i16                    ; get offset to aggregate element
addi $r225 $$locbase i1224              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r226 $$locbase i1056              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r226 $r225 i24                    ; copy memory
addi $r227 $$locbase i760               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r228 $$locbase i1056              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r230 $$locbase i48                ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r230 $r228 i24                    ; copy memory
addi $r231 $$locbase i312               ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r231 $r230 i24                    ; copy memory
lw $r232 $$locbase i39                  ; load word
lw $r234 $$locbase i40                  ; load word
lw $r236 $$locbase i41                  ; load word
movi $r237 i2                           ; initialize constant into register
add $r238 $r236 $r237
gt $r239 $r238 $r234
move $r240 $r232                        ; move parameter from branch to block argument
move $r241 $r234                        ; move parameter from branch to block argument
jnzi $r239 .55
ji  .56
.55
movi $r242 i2                           ; initialize constant into register
mul $r243 $r234 $r242
movi $r244 i2                           ; initialize constant into register
add $r245 $r243 $r244
aloc $r245
mcp $hp $r232 $r236
move $r240 $hp                          ; move parameter from branch to block argument
move $r241 $r245                        ; move parameter from branch to block argument
.56
move $r250 $r240                        ; move parameter from branch to block argument
move $r252 $r241                        ; move parameter from branch to block argument
addi $r253 $$locbase i416               ; get offset to local __ptr u64
mcpi $r253 $r224 i8                     ; copy memory
movi $r254 i6                           ; initialize constant into register
add $r255 $r253 $r254
add $r256 $r250 $r236
mcpi $r256 $r255 i2                     ; copy memory
addi $r257 $$locbase i520               ; get offset to local __ptr { ptr, u64, u64 }
sw $$locbase $r250 i65                  ; store word
sw $$locbase $r252 i66                  ; store word
sw $$locbase $r238 i67                  ; store word
addi $r261 $$locbase i96                ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r261 $r257 i24                    ; copy memory
mcpi $r227 $r261 i24                    ; copy memory
addi $r262 $$locbase i1248              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r262 $r227 i24                    ; copy memory
addi $r263 $$locbase i1472              ; get offset to local __ptr { u64, u64, u64, u8, { { ptr, u64 }, u64 }, slice, u256 }
addi $r264 $r263 i24                    ; get offset to aggregate element
lb $r265 $r264 i0                       ; load byte
addi $r266 $$locbase i1248              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r267 $$locbase i1080              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r267 $r266 i24                    ; copy memory
addi $r268 $$locbase i784               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r269 $$locbase i1080              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r271 $$locbase i120               ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r271 $r269 i24                    ; copy memory
addi $r272 $$locbase i336               ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r272 $r271 i24                    ; copy memory
lw $r273 $$locbase i42                  ; load word
lw $r275 $$locbase i43                  ; load word
lw $r277 $$locbase i44                  ; load word
add $r278 $r277 $one
gt $r279 $r278 $r275
move $r280 $r273                        ; move parameter from branch to block argument
move $r281 $r275                        ; move parameter from branch to block argument
jnzi $r279 .57
ji  .58
.57
movi $r282 i2                           ; initialize constant into register
mul $r283 $r275 $r282
add $r284 $r283 $one
aloc $r284
mcp $hp $r273 $r277
move $r280 $hp                          ; move parameter from branch to block argument
move $r281 $r284                        ; move parameter from branch to block argument
.58
move $r289 $r280                        ; move parameter from branch to block argument
move $r291 $r281                        ; move parameter from branch to block argument
add $r292 $r280 $r277
sb $r292 $r265 i0                       ; store byte
addi $r293 $$locbase i424               ; get offset to local __ptr { ptr, u64, u64 }
sw $$locbase $r289 i53                  ; store word
sw $$locbase $r291 i54                  ; store word
sw $$locbase $r278 i55                  ; store word
addi $r297 $$locbase i144               ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r297 $r293 i24                    ; copy memory
mcpi $r268 $r297 i24                    ; copy memory
addi $r298 $$locbase i1272              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r298 $r268 i24                    ; copy memory
addi $r299 $$locbase i1472              ; get offset to local __ptr { u64, u64, u64, u8, { { ptr, u64 }, u64 }, slice, u256 }
addi $r300 $r299 i32                    ; get offset to aggregate element
addi $r301 $$locbase i1272              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r302 $$locbase i1600              ; get offset to local __ptr { { ptr, u64 }, u64 }
mcpi $r302 $r300 i24                    ; copy memory
addi $r303 $$locbase i1104              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r303 $r301 i24                    ; copy memory
lw $r306 $$locbase i202                 ; load word
addi $r307 $$locbase i1104              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r308 $$locbase i880               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r308 $r307 i24                    ; copy memory
addi $r309 $$locbase i648               ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r306                       ; [call]: pass argument 0
move $$arg1 $r308                       ; [call]: pass argument 1
move $$arg2 $r309                       ; [call]: pass argument 2
fncall .6                               ; [call]: call abi_encode_5
addi $r311 $$locbase i1200              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r311 $r309 i24                    ; copy memory
movi $r312 i0                           ; move parameter from branch to block argument
.59
move $r314 $r312                        ; move parameter from branch to block argument
lt $r315 $r312 $r306
jnzi $r315 .60
.61
addi $r316 $$locbase i1200              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r317 $$locbase i1296              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r317 $r316 i24                    ; copy memory
addi $r318 $$locbase i1472              ; get offset to local __ptr { u64, u64, u64, u8, { { ptr, u64 }, u64 }, slice, u256 }
addi $r319 $r318 i56                    ; get offset to aggregate element
addi $r320 $$locbase i1296              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r321 $$locbase i1624              ; get offset to local __ptr slice
mcpi $r321 $r319 i16                    ; copy memory
addi $r322 $$locbase i1128              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r322 $r320 i24                    ; copy memory
addi $r323 $$locbase i808               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r324 $$locbase i1128              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r326 $$locbase i168               ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r326 $r324 i24                    ; copy memory
addi $r327 $$locbase i360               ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r327 $r326 i24                    ; copy memory
lw $r328 $$locbase i45                  ; load word
lw $r330 $$locbase i46                  ; load word
lw $r332 $$locbase i47                  ; load word
addi $r333 $$locbase i1624              ; get offset to local __ptr slice
addi $r334 $$locbase i208               ; get offset to local __ptr slice
mcpi $r334 $r333 i16                    ; copy memory
addi $r336 $$locbase i192               ; get offset to local __ptr { u64, u64 }
mcpi $r336 $r333 i16                    ; copy memory
addi $r337 $$locbase i448               ; get offset to local __ptr { u64, u64 }
mcpi $r337 $r336 i16                    ; copy memory
lw $r339 $$locbase i57                  ; load word
movi $r340 i8                           ; initialize constant into register
add $r341 $r339 $r340
add $r342 $r332 $r341
gt $r343 $r342 $r330
move $r344 $r328                        ; move parameter from branch to block argument
move $r345 $r330                        ; move parameter from branch to block argument
jnzi $r343 .62
ji  .63
.62
movi $r346 i2                           ; initialize constant into register
mul $r347 $r330 $r346
add $r348 $r347 $r341
aloc $r348
mcp $hp $r328 $r332
move $r344 $hp                          ; move parameter from branch to block argument
move $r345 $r348                        ; move parameter from branch to block argument
.63
move $r353 $r344                        ; move parameter from branch to block argument
move $r355 $r345                        ; move parameter from branch to block argument
addi $r356 $$locbase i544               ; get offset to local __ptr slice
mcpi $r356 $r334 i16                    ; copy memory
add $r357 $r353 $r332
lw $r359 $$locbase i69
sw $r357 $r359 i0
addi $r357 $r357 i8
lw $r358 $$locbase i68
mcp $r357 $r358 $r359
addi $r360 $r332 i8
add $r360 $r360 $r359
move $r361 $r360                        ; return value from ASM block with return register new_len
addi $r362 $$locbase i584               ; get offset to local __ptr { ptr, u64, u64 }
sw $$locbase $r353 i73                  ; store word
sw $$locbase $r355 i74                  ; store word
sw $$locbase $r361 i75                  ; store word
addi $r366 $$locbase i224               ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r366 $r362 i24                    ; copy memory
mcpi $r323 $r366 i24                    ; copy memory
addi $r367 $$locbase i1320              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r367 $r323 i24                    ; copy memory
addi $r368 $$locbase i1472              ; get offset to local __ptr { u64, u64, u64, u8, { { ptr, u64 }, u64 }, slice, u256 }
addi $r369 $r368 i72                    ; get offset to aggregate element
addi $r370 $$locbase i1320              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r371 $$locbase i1640              ; get offset to local __ptr u256
mcpi $r371 $r369 i32                    ; copy memory
addi $r372 $$locbase i1152              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r372 $r370 i24                    ; copy memory
addi $r373 $$locbase i832               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r374 $$locbase i1152              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r376 $$locbase i248               ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r376 $r374 i24                    ; copy memory
addi $r377 $$locbase i384               ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r377 $r376 i24                    ; copy memory
lw $r378 $$locbase i48                  ; load word
lw $r380 $$locbase i49                  ; load word
lw $r382 $$locbase i50                  ; load word
addi $r383 $$locbase i1640              ; get offset to local __ptr u256
movi $r384 i32                          ; initialize constant into register
add $r385 $r382 $r384
gt $r386 $r385 $r380
move $r387 $r378                        ; move parameter from branch to block argument
move $r388 $r380                        ; move parameter from branch to block argument
jnzi $r386 .64
ji  .65
.64
movi $r389 i2                           ; initialize constant into register
mul $r390 $r380 $r389
movi $r391 i32                          ; initialize constant into register
add $r392 $r390 $r391
aloc $r392
mcp $hp $r378 $r382
move $r387 $hp                          ; move parameter from branch to block argument
move $r388 $r392                        ; move parameter from branch to block argument
.65
move $r397 $r387                        ; move parameter from branch to block argument
move $r399 $r388                        ; move parameter from branch to block argument
addi $r400 $$locbase i464               ; get offset to local __ptr u256
mcpi $r400 $r383 i32                    ; copy memory
add $r401 $r397 $r382
mcpi $r401 $r400 i32                    ; copy memory
addi $r402 $$locbase i560               ; get offset to local __ptr { ptr, u64, u64 }
sw $$locbase $r397 i70                  ; store word
sw $$locbase $r399 i71                  ; store word
sw $$locbase $r385 i72                  ; store word
addi $r406 $$locbase i72                ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r406 $r402 i24                    ; copy memory
mcpi $r373 $r406 i24                    ; copy memory
addi $r407 $$locbase i1344              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r407 $r373 i24                    ; copy memory
addi $r408 $$locbase i1344              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r409 $$locbase i984               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r409 $r408 i24                    ; copy memory
addi $r410 $$locbase i984               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r411 $$locbase i928               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r411 $r410 i24                    ; copy memory
addi $r412 $$locbase i720               ; get offset to local __ptr slice
move $$arg0 $r411                       ; [call]: pass argument 0
move $$arg1 $r412                       ; [call]: pass argument 1
fncall .10                              ; [call]: call as_raw_slice_7
addi $r414 $$locbase i952               ; get offset to local __ptr slice
mcpi $r414 $r412 i16                    ; copy memory
move $r415 $r414                        ; move parameter from branch to block argument
ji  .66
.60
addi $r416 $$locbase i1600              ; get offset to local __ptr { { ptr, u64 }, u64 }
addi $r417 $$locbase i1576              ; get offset to local __ptr { { ptr, u64 }, u64 }
mcpi $r417 $r416 i24                    ; copy memory
lw $r419 $$locbase i197                 ; load word
movi $r420 i8                           ; initialize constant into register
mul $r421 $r420 $r314
add $r422 $r419 $r421
lw $r423 $r422 i0                       ; lw val ptr i0
move $r424 $r423                        ; return value from ASM block with return register val
addi $r425 $$locbase i1200              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r426 $$locbase i904               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r426 $r425 i24                    ; copy memory
addi $r427 $$locbase i672               ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r424                       ; [call]: pass argument 0
move $$arg1 $r426                       ; [call]: pass argument 1
move $$arg2 $r427                       ; [call]: pass argument 2
fncall .6                               ; [call]: call abi_encode_5
addi $r429 $$locbase i1200              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r429 $r427 i24                    ; copy memory
add $r430 $r314 $one
move $r312 $r430                        ; move parameter from branch to block argument
ji  .59
.51
addi $r432 $$locbase i968               ; get offset to local __ptr { __ptr { u64, u64, u64, u8, { { ptr, u64 }, u64 }, slice, u256 }, u64 }
sw $$locbase $r152 i121                 ; store word
movi $r434 i104                         ; initialize constant into register
sw $$locbase $r434 i122                 ; store word
addi $r435 $$locbase i272               ; get offset to local __ptr { __ptr { u64, u64, u64, u8, { { ptr, u64 }, u64 }, slice, u256 }, u64 }
mcpi $r435 $r432 i16                    ; copy memory
addi $r436 $$locbase i952               ; get offset to local __ptr slice
mcpi $r436 $r435 i16                    ; copy memory
move $r415 $r436                        ; move parameter from branch to block argument
.66
addi $r440 $$locbase i608               ; get offset to local __ptr slice
mcpi $r440 $r415 i16                    ; copy memory
load $r441 data_NonConfigurable_3       ; load constant from data section
lw $r442 $$locbase i76                  ; load slice pointer for logging data
lw $r443 $$locbase i77                  ; load slice size for logging data
logd $zero $r441 $r442 $r443            ; log slice
.15
cfsi i1672                              ; free 1672 bytes for locals and 0 slots for extra call arguments
move $$reta $r150                       ; restore return address
popa .14                                ; restore all registers
jal $zero $$reta i0                     ; return from call
DIFF------------------------------
.program:
.14                                     ; --- start of function: local_log_21 ---
pusha .14                               ; save all registers
move $$locbase $sp                      ; save locals base register for function local_log_21
cfei i1672                              ; allocate 1672 bytes for locals and 0 slots for call arguments
move $r150 $$reta                       ; save return address
.40
addi $r151 $$locbase i1368              ; get offset to local __ptr { u64, u64, u64, u8, { { ptr, u64 }, u64 }, slice, u256 }
mcpi $r151 $$arg0 i104                  ; copy memory
addi $r152 $$locbase i1368              ; get offset to local __ptr { u64, u64, u64, u8, { { ptr, u64 }, u64 }, slice, u256 }
.42
.44
movi $r161 i0                           ; move parameter from branch to block argument
.46
 move $r165 $r161                        ; move parameter from branch to block argument
 jnzi $r161 .47
 movi $r165 i0                           ; move parameter from branch to block argument
 
ji  .48
.47
 movi $r165 i0                           ; move parameter from branch to block argument
                                         ; move parameter from branch to block argument
.48
move $r169 $r165                        ; move parameter from branch to block argument
jnzi $r165 .49
ji  .50
.49
movi $r169 i1                           ; move parameter from branch to block argument
.50
jnzi $r169 .51
.52
addi $r173 $$locbase i696               ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r173                       ; [call]: pass argument 0
fncall .8                               ; [call]: call new_6
addi $r175 $$locbase i1472              ; get offset to local __ptr { u64, u64, u64, u8, { { ptr, u64 }, u64 }, slice, u256 }
mcpi $r175 $r152 i104                   ; copy memory
addi $r176 $$locbase i1008              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r176 $r173 i24                    ; copy memory
lw $r178 $$locbase i184                 ; load word
addi $r179 $$locbase i1008              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r180 $$locbase i856               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r180 $r179 i24                    ; copy memory
addi $r181 $$locbase i624               ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r178                       ; [call]: pass argument 0
move $$arg1 $r180                       ; [call]: pass argument 1
move $$arg2 $r181                       ; [call]: pass argument 2
fncall .6                               ; [call]: call abi_encode_5
addi $r183 $$locbase i1176              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r183 $r181 i24                    ; copy memory
addi $r184 $$locbase i1472              ; get offset to local __ptr { u64, u64, u64, u8, { { ptr, u64 }, u64 }, slice, u256 }
addi $r185 $r184 i8                     ; get offset to aggregate element
addi $r186 $$locbase i1176              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r187 $$locbase i1032              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r187 $r186 i24                    ; copy memory
addi $r188 $$locbase i736               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r189 $$locbase i1032              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $$locbase $r189 i24                ; copy memory
addi $r191 $$locbase i288               ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r191 $$locbase i24                ; copy memory
lw $r192 $$locbase i36                  ; load word
lw $r194 $$locbase i37                  ; load word
lw $r196 $$locbase i38                  ; load word
movi $r197 i4                           ; initialize constant into register
add $r198 $r196 $r197
gt $r199 $r198 $r194
move $r200 $r192                        ; move parameter from branch to block argument
move $r201 $r194                        ; move parameter from branch to block argument
jnzi $r199 .53
ji  .54
.53
movi $r202 i2                           ; initialize constant into register
mul $r203 $r194 $r202
movi $r204 i4                           ; initialize constant into register
add $r205 $r203 $r204
aloc $r205
mcp $hp $r192 $r196
move $r200 $hp                          ; move parameter from branch to block argument
move $r201 $r205                        ; move parameter from branch to block argument
.54
move $r210 $r200                        ; move parameter from branch to block argument
move $r212 $r201                        ; move parameter from branch to block argument
addi $r213 $$locbase i408               ; get offset to local __ptr u64
mcpi $r213 $r185 i8                     ; copy memory
movi $r214 i4                           ; initialize constant into register
add $r215 $r213 $r214
add $r216 $r210 $r196
mcpi $r216 $r215 i4                     ; copy memory
addi $r217 $$locbase i496               ; get offset to local __ptr { ptr, u64, u64 }
sw $$locbase $r210 i62                  ; store word
sw $$locbase $r212 i63                  ; store word
sw $$locbase $r198 i64                  ; store word
addi $r221 $$locbase i24                ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r221 $r217 i24                    ; copy memory
mcpi $r188 $r221 i24                    ; copy memory
addi $r222 $$locbase i1224              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r222 $r188 i24                    ; copy memory
addi $r223 $$locbase i1472              ; get offset to local __ptr { u64, u64, u64, u8, { { ptr, u64 }, u64 }, slice, u256 }
addi $r224 $r223 i16                    ; get offset to aggregate element
addi $r225 $$locbase i1224              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r226 $$locbase i1056              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r226 $r225 i24                    ; copy memory
addi $r227 $$locbase i760               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r228 $$locbase i1056              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r230 $$locbase i48                ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r230 $r228 i24                    ; copy memory
addi $r231 $$locbase i312               ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r231 $r230 i24                    ; copy memory
lw $r232 $$locbase i39                  ; load word
lw $r234 $$locbase i40                  ; load word
lw $r236 $$locbase i41                  ; load word
movi $r237 i2                           ; initialize constant into register
add $r238 $r236 $r237
gt $r239 $r238 $r234
move $r240 $r232                        ; move parameter from branch to block argument
move $r241 $r234                        ; move parameter from branch to block argument
jnzi $r239 .55
ji  .56
.55
movi $r242 i2                           ; initialize constant into register
mul $r243 $r234 $r242
movi $r244 i2                           ; initialize constant into register
add $r245 $r243 $r244
aloc $r245
mcp $hp $r232 $r236
move $r240 $hp                          ; move parameter from branch to block argument
move $r241 $r245                        ; move parameter from branch to block argument
.56
move $r250 $r240                        ; move parameter from branch to block argument
move $r252 $r241                        ; move parameter from branch to block argument
addi $r253 $$locbase i416               ; get offset to local __ptr u64
mcpi $r253 $r224 i8                     ; copy memory
movi $r254 i6                           ; initialize constant into register
add $r255 $r253 $r254
add $r256 $r250 $r236
mcpi $r256 $r255 i2                     ; copy memory
addi $r257 $$locbase i520               ; get offset to local __ptr { ptr, u64, u64 }
sw $$locbase $r250 i65                  ; store word
sw $$locbase $r252 i66                  ; store word
sw $$locbase $r238 i67                  ; store word
addi $r261 $$locbase i96                ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r261 $r257 i24                    ; copy memory
mcpi $r227 $r261 i24                    ; copy memory
addi $r262 $$locbase i1248              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r262 $r227 i24                    ; copy memory
addi $r263 $$locbase i1472              ; get offset to local __ptr { u64, u64, u64, u8, { { ptr, u64 }, u64 }, slice, u256 }
addi $r264 $r263 i24                    ; get offset to aggregate element
lb $r265 $r264 i0                       ; load byte
addi $r266 $$locbase i1248              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r267 $$locbase i1080              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r267 $r266 i24                    ; copy memory
addi $r268 $$locbase i784               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r269 $$locbase i1080              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r271 $$locbase i120               ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r271 $r269 i24                    ; copy memory
addi $r272 $$locbase i336               ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r272 $r271 i24                    ; copy memory
lw $r273 $$locbase i42                  ; load word
lw $r275 $$locbase i43                  ; load word
lw $r277 $$locbase i44                  ; load word
add $r278 $r277 $one
gt $r279 $r278 $r275
move $r280 $r273                        ; move parameter from branch to block argument
move $r281 $r275                        ; move parameter from branch to block argument
jnzi $r279 .57
ji  .58
.57
movi $r282 i2                           ; initialize constant into register
mul $r283 $r275 $r282
add $r284 $r283 $one
aloc $r284
mcp $hp $r273 $r277
move $r280 $hp                          ; move parameter from branch to block argument
move $r281 $r284                        ; move parameter from branch to block argument
.58
move $r289 $r280                        ; move parameter from branch to block argument
move $r291 $r281                        ; move parameter from branch to block argument
add $r292 $r280 $r277
sb $r292 $r265 i0                       ; store byte
addi $r293 $$locbase i424               ; get offset to local __ptr { ptr, u64, u64 }
sw $$locbase $r289 i53                  ; store word
sw $$locbase $r291 i54                  ; store word
sw $$locbase $r278 i55                  ; store word
addi $r297 $$locbase i144               ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r297 $r293 i24                    ; copy memory
mcpi $r268 $r297 i24                    ; copy memory
addi $r298 $$locbase i1272              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r298 $r268 i24                    ; copy memory
addi $r299 $$locbase i1472              ; get offset to local __ptr { u64, u64, u64, u8, { { ptr, u64 }, u64 }, slice, u256 }
addi $r300 $r299 i32                    ; get offset to aggregate element
addi $r301 $$locbase i1272              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r302 $$locbase i1600              ; get offset to local __ptr { { ptr, u64 }, u64 }
mcpi $r302 $r300 i24                    ; copy memory
addi $r303 $$locbase i1104              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r303 $r301 i24                    ; copy memory
lw $r306 $$locbase i202                 ; load word
addi $r307 $$locbase i1104              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r308 $$locbase i880               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r308 $r307 i24                    ; copy memory
addi $r309 $$locbase i648               ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r306                       ; [call]: pass argument 0
move $$arg1 $r308                       ; [call]: pass argument 1
move $$arg2 $r309                       ; [call]: pass argument 2
fncall .6                               ; [call]: call abi_encode_5
addi $r311 $$locbase i1200              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r311 $r309 i24                    ; copy memory
movi $r312 i0                           ; move parameter from branch to block argument
.59
move $r314 $r312                        ; move parameter from branch to block argument
lt $r315 $r312 $r306
jnzi $r315 .60
.61
addi $r316 $$locbase i1200              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r317 $$locbase i1296              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r317 $r316 i24                    ; copy memory
addi $r318 $$locbase i1472              ; get offset to local __ptr { u64, u64, u64, u8, { { ptr, u64 }, u64 }, slice, u256 }
addi $r319 $r318 i56                    ; get offset to aggregate element
addi $r320 $$locbase i1296              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r321 $$locbase i1624              ; get offset to local __ptr slice
mcpi $r321 $r319 i16                    ; copy memory
addi $r322 $$locbase i1128              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r322 $r320 i24                    ; copy memory
addi $r323 $$locbase i808               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r324 $$locbase i1128              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r326 $$locbase i168               ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r326 $r324 i24                    ; copy memory
addi $r327 $$locbase i360               ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r327 $r326 i24                    ; copy memory
lw $r328 $$locbase i45                  ; load word
lw $r330 $$locbase i46                  ; load word
lw $r332 $$locbase i47                  ; load word
addi $r333 $$locbase i1624              ; get offset to local __ptr slice
addi $r334 $$locbase i208               ; get offset to local __ptr slice
mcpi $r334 $r333 i16                    ; copy memory
addi $r336 $$locbase i192               ; get offset to local __ptr { u64, u64 }
mcpi $r336 $r333 i16                    ; copy memory
addi $r337 $$locbase i448               ; get offset to local __ptr { u64, u64 }
mcpi $r337 $r336 i16                    ; copy memory
lw $r339 $$locbase i57                  ; load word
movi $r340 i8                           ; initialize constant into register
add $r341 $r339 $r340
add $r342 $r332 $r341
gt $r343 $r342 $r330
move $r344 $r328                        ; move parameter from branch to block argument
move $r345 $r330                        ; move parameter from branch to block argument
jnzi $r343 .62
ji  .63
.62
movi $r346 i2                           ; initialize constant into register
mul $r347 $r330 $r346
add $r348 $r347 $r341
aloc $r348
mcp $hp $r328 $r332
move $r344 $hp                          ; move parameter from branch to block argument
move $r345 $r348                        ; move parameter from branch to block argument
.63
move $r353 $r344                        ; move parameter from branch to block argument
move $r355 $r345                        ; move parameter from branch to block argument
addi $r356 $$locbase i544               ; get offset to local __ptr slice
mcpi $r356 $r334 i16                    ; copy memory
add $r357 $r353 $r332
lw $r359 $$locbase i69
sw $r357 $r359 i0
addi $r357 $r357 i8
lw $r358 $$locbase i68
mcp $r357 $r358 $r359
addi $r360 $r332 i8
add $r360 $r360 $r359
move $r361 $r360                        ; return value from ASM block with return register new_len
addi $r362 $$locbase i584               ; get offset to local __ptr { ptr, u64, u64 }
sw $$locbase $r353 i73                  ; store word
sw $$locbase $r355 i74                  ; store word
sw $$locbase $r361 i75                  ; store word
addi $r366 $$locbase i224               ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r366 $r362 i24                    ; copy memory
mcpi $r323 $r366 i24                    ; copy memory
addi $r367 $$locbase i1320              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r367 $r323 i24                    ; copy memory
addi $r368 $$locbase i1472              ; get offset to local __ptr { u64, u64, u64, u8, { { ptr, u64 }, u64 }, slice, u256 }
addi $r369 $r368 i72                    ; get offset to aggregate element
addi $r370 $$locbase i1320              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r371 $$locbase i1640              ; get offset to local __ptr u256
mcpi $r371 $r369 i32                    ; copy memory
addi $r372 $$locbase i1152              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r372 $r370 i24                    ; copy memory
addi $r373 $$locbase i832               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r374 $$locbase i1152              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r376 $$locbase i248               ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r376 $r374 i24                    ; copy memory
addi $r377 $$locbase i384               ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r377 $r376 i24                    ; copy memory
lw $r378 $$locbase i48                  ; load word
lw $r380 $$locbase i49                  ; load word
lw $r382 $$locbase i50                  ; load word
addi $r383 $$locbase i1640              ; get offset to local __ptr u256
movi $r384 i32                          ; initialize constant into register
add $r385 $r382 $r384
gt $r386 $r385 $r380
move $r387 $r378                        ; move parameter from branch to block argument
move $r388 $r380                        ; move parameter from branch to block argument
jnzi $r386 .64
ji  .65
.64
movi $r389 i2                           ; initialize constant into register
mul $r390 $r380 $r389
movi $r391 i32                          ; initialize constant into register
add $r392 $r390 $r391
aloc $r392
mcp $hp $r378 $r382
move $r387 $hp                          ; move parameter from branch to block argument
move $r388 $r392                        ; move parameter from branch to block argument
.65
move $r397 $r387                        ; move parameter from branch to block argument
move $r399 $r388                        ; move parameter from branch to block argument
addi $r400 $$locbase i464               ; get offset to local __ptr u256
mcpi $r400 $r383 i32                    ; copy memory
add $r401 $r397 $r382
mcpi $r401 $r400 i32                    ; copy memory
addi $r402 $$locbase i560               ; get offset to local __ptr { ptr, u64, u64 }
sw $$locbase $r397 i70                  ; store word
sw $$locbase $r399 i71                  ; store word
sw $$locbase $r385 i72                  ; store word
addi $r406 $$locbase i72                ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r406 $r402 i24                    ; copy memory
mcpi $r373 $r406 i24                    ; copy memory
addi $r407 $$locbase i1344              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r407 $r373 i24                    ; copy memory
addi $r408 $$locbase i1344              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r409 $$locbase i984               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r409 $r408 i24                    ; copy memory
addi $r410 $$locbase i984               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r411 $$locbase i928               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r411 $r410 i24                    ; copy memory
addi $r412 $$locbase i720               ; get offset to local __ptr slice
move $$arg0 $r411                       ; [call]: pass argument 0
move $$arg1 $r412                       ; [call]: pass argument 1
fncall .10                              ; [call]: call as_raw_slice_7
addi $r414 $$locbase i952               ; get offset to local __ptr slice
mcpi $r414 $r412 i16                    ; copy memory
move $r415 $r414                        ; move parameter from branch to block argument
ji  .66
.60
addi $r416 $$locbase i1600              ; get offset to local __ptr { { ptr, u64 }, u64 }
addi $r417 $$locbase i1576              ; get offset to local __ptr { { ptr, u64 }, u64 }
mcpi $r417 $r416 i24                    ; copy memory
lw $r419 $$locbase i197                 ; load word
movi $r420 i8                           ; initialize constant into register
mul $r421 $r420 $r314
add $r422 $r419 $r421
lw $r423 $r422 i0                       ; lw val ptr i0
move $r424 $r423                        ; return value from ASM block with return register val
addi $r425 $$locbase i1200              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r426 $$locbase i904               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r426 $r425 i24                    ; copy memory
addi $r427 $$locbase i672               ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r424                       ; [call]: pass argument 0
move $$arg1 $r426                       ; [call]: pass argument 1
move $$arg2 $r427                       ; [call]: pass argument 2
fncall .6                               ; [call]: call abi_encode_5
addi $r429 $$locbase i1200              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r429 $r427 i24                    ; copy memory
add $r430 $r314 $one
move $r312 $r430                        ; move parameter from branch to block argument
ji  .59
.51
addi $r432 $$locbase i968               ; get offset to local __ptr { __ptr { u64, u64, u64, u8, { { ptr, u64 }, u64 }, slice, u256 }, u64 }
sw $$locbase $r152 i121                 ; store word
movi $r434 i104                         ; initialize constant into register
sw $$locbase $r434 i122                 ; store word
addi $r435 $$locbase i272               ; get offset to local __ptr { __ptr { u64, u64, u64, u8, { { ptr, u64 }, u64 }, slice, u256 }, u64 }
mcpi $r435 $r432 i16                    ; copy memory
addi $r436 $$locbase i952               ; get offset to local __ptr slice
mcpi $r436 $r435 i16                    ; copy memory
move $r415 $r436                        ; move parameter from branch to block argument
.66
addi $r440 $$locbase i608               ; get offset to local __ptr slice
mcpi $r440 $r415 i16                    ; copy memory
load $r441 data_NonConfigurable_3       ; load constant from data section
lw $r442 $$locbase i76                  ; load slice pointer for logging data
lw $r443 $$locbase i77                  ; load slice size for logging data
logd $zero $r441 $r442 $r443            ; log slice
.15
cfsi i1672                              ; free 1672 bytes for locals and 0 slots for extra call arguments
move $$reta $r150                       ; restore return address
popa .14                                ; restore all registers
jal $zero $$reta i0                     ; return from call
DIFF------------------------------
.program:
.14                                     ; --- start of function: local_log_21 ---
pusha .14                               ; save all registers
move $$locbase $sp                      ; save locals base register for function local_log_21
cfei i1672                              ; allocate 1672 bytes for locals and 0 slots for call arguments
move $r150 $$reta                       ; save return address
.40
addi $r151 $$locbase i1368              ; get offset to local __ptr { u64, u64, u64, u8, { { ptr, u64 }, u64 }, slice, u256 }
mcpi $r151 $$arg0 i104                  ; copy memory
addi $r152 $$locbase i1368              ; get offset to local __ptr { u64, u64, u64, u8, { { ptr, u64 }, u64 }, slice, u256 }
.42
.44
.46
movi $r165 i0                           ; move parameter from branch to block argument
.48
 move $r169 $r165                        ; move parameter from branch to block argument
 jnzi $r165 .49
 movi $r169 i0                           ; move parameter from branch to block argument
 
ji  .50
.49
movi $r169 i1                           ; move parameter from branch to block argument
.50
jnzi $r169 .51
.52
addi $r173 $$locbase i696               ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r173                       ; [call]: pass argument 0
fncall .8                               ; [call]: call new_6
addi $r175 $$locbase i1472              ; get offset to local __ptr { u64, u64, u64, u8, { { ptr, u64 }, u64 }, slice, u256 }
mcpi $r175 $r152 i104                   ; copy memory
addi $r176 $$locbase i1008              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r176 $r173 i24                    ; copy memory
lw $r178 $$locbase i184                 ; load word
addi $r179 $$locbase i1008              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r180 $$locbase i856               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r180 $r179 i24                    ; copy memory
addi $r181 $$locbase i624               ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r178                       ; [call]: pass argument 0
move $$arg1 $r180                       ; [call]: pass argument 1
move $$arg2 $r181                       ; [call]: pass argument 2
fncall .6                               ; [call]: call abi_encode_5
addi $r183 $$locbase i1176              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r183 $r181 i24                    ; copy memory
addi $r184 $$locbase i1472              ; get offset to local __ptr { u64, u64, u64, u8, { { ptr, u64 }, u64 }, slice, u256 }
addi $r185 $r184 i8                     ; get offset to aggregate element
addi $r186 $$locbase i1176              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r187 $$locbase i1032              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r187 $r186 i24                    ; copy memory
addi $r188 $$locbase i736               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r189 $$locbase i1032              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $$locbase $r189 i24                ; copy memory
addi $r191 $$locbase i288               ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r191 $$locbase i24                ; copy memory
lw $r192 $$locbase i36                  ; load word
lw $r194 $$locbase i37                  ; load word
lw $r196 $$locbase i38                  ; load word
movi $r197 i4                           ; initialize constant into register
add $r198 $r196 $r197
gt $r199 $r198 $r194
move $r200 $r192                        ; move parameter from branch to block argument
move $r201 $r194                        ; move parameter from branch to block argument
jnzi $r199 .53
ji  .54
.53
movi $r202 i2                           ; initialize constant into register
mul $r203 $r194 $r202
movi $r204 i4                           ; initialize constant into register
add $r205 $r203 $r204
aloc $r205
mcp $hp $r192 $r196
move $r200 $hp                          ; move parameter from branch to block argument
move $r201 $r205                        ; move parameter from branch to block argument
.54
move $r210 $r200                        ; move parameter from branch to block argument
move $r212 $r201                        ; move parameter from branch to block argument
addi $r213 $$locbase i408               ; get offset to local __ptr u64
mcpi $r213 $r185 i8                     ; copy memory
movi $r214 i4                           ; initialize constant into register
add $r215 $r213 $r214
add $r216 $r210 $r196
mcpi $r216 $r215 i4                     ; copy memory
addi $r217 $$locbase i496               ; get offset to local __ptr { ptr, u64, u64 }
sw $$locbase $r210 i62                  ; store word
sw $$locbase $r212 i63                  ; store word
sw $$locbase $r198 i64                  ; store word
addi $r221 $$locbase i24                ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r221 $r217 i24                    ; copy memory
mcpi $r188 $r221 i24                    ; copy memory
addi $r222 $$locbase i1224              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r222 $r188 i24                    ; copy memory
addi $r223 $$locbase i1472              ; get offset to local __ptr { u64, u64, u64, u8, { { ptr, u64 }, u64 }, slice, u256 }
addi $r224 $r223 i16                    ; get offset to aggregate element
addi $r225 $$locbase i1224              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r226 $$locbase i1056              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r226 $r225 i24                    ; copy memory
addi $r227 $$locbase i760               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r228 $$locbase i1056              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r230 $$locbase i48                ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r230 $r228 i24                    ; copy memory
addi $r231 $$locbase i312               ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r231 $r230 i24                    ; copy memory
lw $r232 $$locbase i39                  ; load word
lw $r234 $$locbase i40                  ; load word
lw $r236 $$locbase i41                  ; load word
movi $r237 i2                           ; initialize constant into register
add $r238 $r236 $r237
gt $r239 $r238 $r234
move $r240 $r232                        ; move parameter from branch to block argument
move $r241 $r234                        ; move parameter from branch to block argument
jnzi $r239 .55
ji  .56
.55
movi $r242 i2                           ; initialize constant into register
mul $r243 $r234 $r242
movi $r244 i2                           ; initialize constant into register
add $r245 $r243 $r244
aloc $r245
mcp $hp $r232 $r236
move $r240 $hp                          ; move parameter from branch to block argument
move $r241 $r245                        ; move parameter from branch to block argument
.56
move $r250 $r240                        ; move parameter from branch to block argument
move $r252 $r241                        ; move parameter from branch to block argument
addi $r253 $$locbase i416               ; get offset to local __ptr u64
mcpi $r253 $r224 i8                     ; copy memory
movi $r254 i6                           ; initialize constant into register
add $r255 $r253 $r254
add $r256 $r250 $r236
mcpi $r256 $r255 i2                     ; copy memory
addi $r257 $$locbase i520               ; get offset to local __ptr { ptr, u64, u64 }
sw $$locbase $r250 i65                  ; store word
sw $$locbase $r252 i66                  ; store word
sw $$locbase $r238 i67                  ; store word
addi $r261 $$locbase i96                ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r261 $r257 i24                    ; copy memory
mcpi $r227 $r261 i24                    ; copy memory
addi $r262 $$locbase i1248              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r262 $r227 i24                    ; copy memory
addi $r263 $$locbase i1472              ; get offset to local __ptr { u64, u64, u64, u8, { { ptr, u64 }, u64 }, slice, u256 }
addi $r264 $r263 i24                    ; get offset to aggregate element
lb $r265 $r264 i0                       ; load byte
addi $r266 $$locbase i1248              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r267 $$locbase i1080              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r267 $r266 i24                    ; copy memory
addi $r268 $$locbase i784               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r269 $$locbase i1080              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r271 $$locbase i120               ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r271 $r269 i24                    ; copy memory
addi $r272 $$locbase i336               ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r272 $r271 i24                    ; copy memory
lw $r273 $$locbase i42                  ; load word
lw $r275 $$locbase i43                  ; load word
lw $r277 $$locbase i44                  ; load word
add $r278 $r277 $one
gt $r279 $r278 $r275
move $r280 $r273                        ; move parameter from branch to block argument
move $r281 $r275                        ; move parameter from branch to block argument
jnzi $r279 .57
ji  .58
.57
movi $r282 i2                           ; initialize constant into register
mul $r283 $r275 $r282
add $r284 $r283 $one
aloc $r284
mcp $hp $r273 $r277
move $r280 $hp                          ; move parameter from branch to block argument
move $r281 $r284                        ; move parameter from branch to block argument
.58
move $r289 $r280                        ; move parameter from branch to block argument
move $r291 $r281                        ; move parameter from branch to block argument
add $r292 $r280 $r277
sb $r292 $r265 i0                       ; store byte
addi $r293 $$locbase i424               ; get offset to local __ptr { ptr, u64, u64 }
sw $$locbase $r289 i53                  ; store word
sw $$locbase $r291 i54                  ; store word
sw $$locbase $r278 i55                  ; store word
addi $r297 $$locbase i144               ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r297 $r293 i24                    ; copy memory
mcpi $r268 $r297 i24                    ; copy memory
addi $r298 $$locbase i1272              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r298 $r268 i24                    ; copy memory
addi $r299 $$locbase i1472              ; get offset to local __ptr { u64, u64, u64, u8, { { ptr, u64 }, u64 }, slice, u256 }
addi $r300 $r299 i32                    ; get offset to aggregate element
addi $r301 $$locbase i1272              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r302 $$locbase i1600              ; get offset to local __ptr { { ptr, u64 }, u64 }
mcpi $r302 $r300 i24                    ; copy memory
addi $r303 $$locbase i1104              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r303 $r301 i24                    ; copy memory
lw $r306 $$locbase i202                 ; load word
addi $r307 $$locbase i1104              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r308 $$locbase i880               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r308 $r307 i24                    ; copy memory
addi $r309 $$locbase i648               ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r306                       ; [call]: pass argument 0
move $$arg1 $r308                       ; [call]: pass argument 1
move $$arg2 $r309                       ; [call]: pass argument 2
fncall .6                               ; [call]: call abi_encode_5
addi $r311 $$locbase i1200              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r311 $r309 i24                    ; copy memory
movi $r312 i0                           ; move parameter from branch to block argument
.59
move $r314 $r312                        ; move parameter from branch to block argument
lt $r315 $r312 $r306
jnzi $r315 .60
.61
addi $r316 $$locbase i1200              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r317 $$locbase i1296              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r317 $r316 i24                    ; copy memory
addi $r318 $$locbase i1472              ; get offset to local __ptr { u64, u64, u64, u8, { { ptr, u64 }, u64 }, slice, u256 }
addi $r319 $r318 i56                    ; get offset to aggregate element
addi $r320 $$locbase i1296              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r321 $$locbase i1624              ; get offset to local __ptr slice
mcpi $r321 $r319 i16                    ; copy memory
addi $r322 $$locbase i1128              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r322 $r320 i24                    ; copy memory
addi $r323 $$locbase i808               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r324 $$locbase i1128              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r326 $$locbase i168               ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r326 $r324 i24                    ; copy memory
addi $r327 $$locbase i360               ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r327 $r326 i24                    ; copy memory
lw $r328 $$locbase i45                  ; load word
lw $r330 $$locbase i46                  ; load word
lw $r332 $$locbase i47                  ; load word
addi $r333 $$locbase i1624              ; get offset to local __ptr slice
addi $r334 $$locbase i208               ; get offset to local __ptr slice
mcpi $r334 $r333 i16                    ; copy memory
addi $r336 $$locbase i192               ; get offset to local __ptr { u64, u64 }
mcpi $r336 $r333 i16                    ; copy memory
addi $r337 $$locbase i448               ; get offset to local __ptr { u64, u64 }
mcpi $r337 $r336 i16                    ; copy memory
lw $r339 $$locbase i57                  ; load word
movi $r340 i8                           ; initialize constant into register
add $r341 $r339 $r340
add $r342 $r332 $r341
gt $r343 $r342 $r330
move $r344 $r328                        ; move parameter from branch to block argument
move $r345 $r330                        ; move parameter from branch to block argument
jnzi $r343 .62
ji  .63
.62
movi $r346 i2                           ; initialize constant into register
mul $r347 $r330 $r346
add $r348 $r347 $r341
aloc $r348
mcp $hp $r328 $r332
move $r344 $hp                          ; move parameter from branch to block argument
move $r345 $r348                        ; move parameter from branch to block argument
.63
move $r353 $r344                        ; move parameter from branch to block argument
move $r355 $r345                        ; move parameter from branch to block argument
addi $r356 $$locbase i544               ; get offset to local __ptr slice
mcpi $r356 $r334 i16                    ; copy memory
add $r357 $r353 $r332
lw $r359 $$locbase i69
sw $r357 $r359 i0
addi $r357 $r357 i8
lw $r358 $$locbase i68
mcp $r357 $r358 $r359
addi $r360 $r332 i8
add $r360 $r360 $r359
move $r361 $r360                        ; return value from ASM block with return register new_len
addi $r362 $$locbase i584               ; get offset to local __ptr { ptr, u64, u64 }
sw $$locbase $r353 i73                  ; store word
sw $$locbase $r355 i74                  ; store word
sw $$locbase $r361 i75                  ; store word
addi $r366 $$locbase i224               ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r366 $r362 i24                    ; copy memory
mcpi $r323 $r366 i24                    ; copy memory
addi $r367 $$locbase i1320              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r367 $r323 i24                    ; copy memory
addi $r368 $$locbase i1472              ; get offset to local __ptr { u64, u64, u64, u8, { { ptr, u64 }, u64 }, slice, u256 }
addi $r369 $r368 i72                    ; get offset to aggregate element
addi $r370 $$locbase i1320              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r371 $$locbase i1640              ; get offset to local __ptr u256
mcpi $r371 $r369 i32                    ; copy memory
addi $r372 $$locbase i1152              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r372 $r370 i24                    ; copy memory
addi $r373 $$locbase i832               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r374 $$locbase i1152              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r376 $$locbase i248               ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r376 $r374 i24                    ; copy memory
addi $r377 $$locbase i384               ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r377 $r376 i24                    ; copy memory
lw $r378 $$locbase i48                  ; load word
lw $r380 $$locbase i49                  ; load word
lw $r382 $$locbase i50                  ; load word
addi $r383 $$locbase i1640              ; get offset to local __ptr u256
movi $r384 i32                          ; initialize constant into register
add $r385 $r382 $r384
gt $r386 $r385 $r380
move $r387 $r378                        ; move parameter from branch to block argument
move $r388 $r380                        ; move parameter from branch to block argument
jnzi $r386 .64
ji  .65
.64
movi $r389 i2                           ; initialize constant into register
mul $r390 $r380 $r389
movi $r391 i32                          ; initialize constant into register
add $r392 $r390 $r391
aloc $r392
mcp $hp $r378 $r382
move $r387 $hp                          ; move parameter from branch to block argument
move $r388 $r392                        ; move parameter from branch to block argument
.65
move $r397 $r387                        ; move parameter from branch to block argument
move $r399 $r388                        ; move parameter from branch to block argument
addi $r400 $$locbase i464               ; get offset to local __ptr u256
mcpi $r400 $r383 i32                    ; copy memory
add $r401 $r397 $r382
mcpi $r401 $r400 i32                    ; copy memory
addi $r402 $$locbase i560               ; get offset to local __ptr { ptr, u64, u64 }
sw $$locbase $r397 i70                  ; store word
sw $$locbase $r399 i71                  ; store word
sw $$locbase $r385 i72                  ; store word
addi $r406 $$locbase i72                ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r406 $r402 i24                    ; copy memory
mcpi $r373 $r406 i24                    ; copy memory
addi $r407 $$locbase i1344              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r407 $r373 i24                    ; copy memory
addi $r408 $$locbase i1344              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r409 $$locbase i984               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r409 $r408 i24                    ; copy memory
addi $r410 $$locbase i984               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r411 $$locbase i928               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r411 $r410 i24                    ; copy memory
addi $r412 $$locbase i720               ; get offset to local __ptr slice
move $$arg0 $r411                       ; [call]: pass argument 0
move $$arg1 $r412                       ; [call]: pass argument 1
fncall .10                              ; [call]: call as_raw_slice_7
addi $r414 $$locbase i952               ; get offset to local __ptr slice
mcpi $r414 $r412 i16                    ; copy memory
move $r415 $r414                        ; move parameter from branch to block argument
ji  .66
.60
addi $r416 $$locbase i1600              ; get offset to local __ptr { { ptr, u64 }, u64 }
addi $r417 $$locbase i1576              ; get offset to local __ptr { { ptr, u64 }, u64 }
mcpi $r417 $r416 i24                    ; copy memory
lw $r419 $$locbase i197                 ; load word
movi $r420 i8                           ; initialize constant into register
mul $r421 $r420 $r314
add $r422 $r419 $r421
lw $r423 $r422 i0                       ; lw val ptr i0
move $r424 $r423                        ; return value from ASM block with return register val
addi $r425 $$locbase i1200              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r426 $$locbase i904               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r426 $r425 i24                    ; copy memory
addi $r427 $$locbase i672               ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r424                       ; [call]: pass argument 0
move $$arg1 $r426                       ; [call]: pass argument 1
move $$arg2 $r427                       ; [call]: pass argument 2
fncall .6                               ; [call]: call abi_encode_5
addi $r429 $$locbase i1200              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r429 $r427 i24                    ; copy memory
add $r430 $r314 $one
move $r312 $r430                        ; move parameter from branch to block argument
ji  .59
.51
addi $r432 $$locbase i968               ; get offset to local __ptr { __ptr { u64, u64, u64, u8, { { ptr, u64 }, u64 }, slice, u256 }, u64 }
sw $$locbase $r152 i121                 ; store word
movi $r434 i104                         ; initialize constant into register
sw $$locbase $r434 i122                 ; store word
addi $r435 $$locbase i272               ; get offset to local __ptr { __ptr { u64, u64, u64, u8, { { ptr, u64 }, u64 }, slice, u256 }, u64 }
mcpi $r435 $r432 i16                    ; copy memory
addi $r436 $$locbase i952               ; get offset to local __ptr slice
mcpi $r436 $r435 i16                    ; copy memory
move $r415 $r436                        ; move parameter from branch to block argument
.66
addi $r440 $$locbase i608               ; get offset to local __ptr slice
mcpi $r440 $r415 i16                    ; copy memory
load $r441 data_NonConfigurable_3       ; load constant from data section
lw $r442 $$locbase i76                  ; load slice pointer for logging data
lw $r443 $$locbase i77                  ; load slice size for logging data
logd $zero $r441 $r442 $r443            ; log slice
.15
cfsi i1672                              ; free 1672 bytes for locals and 0 slots for extra call arguments
move $$reta $r150                       ; restore return address
popa .14                                ; restore all registers
jal $zero $$reta i0                     ; return from call
DIFF------------------------------
.program:
.14                                     ; --- start of function: local_log_21 ---
pusha .14                               ; save all registers
move $$locbase $sp                      ; save locals base register for function local_log_21
cfei i1672                              ; allocate 1672 bytes for locals and 0 slots for call arguments
move $r150 $$reta                       ; save return address
.40
addi $r151 $$locbase i1368              ; get offset to local __ptr { u64, u64, u64, u8, { { ptr, u64 }, u64 }, slice, u256 }
mcpi $r151 $$arg0 i104                  ; copy memory
addi $r152 $$locbase i1368              ; get offset to local __ptr { u64, u64, u64, u8, { { ptr, u64 }, u64 }, slice, u256 }
.42
.44
.46
.48
movi $r169 i0                           ; move parameter from branch to block argument
.50
 jnzi $r169 .51
 
.52
addi $r173 $$locbase i696               ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r173                       ; [call]: pass argument 0
fncall .8                               ; [call]: call new_6
addi $r175 $$locbase i1472              ; get offset to local __ptr { u64, u64, u64, u8, { { ptr, u64 }, u64 }, slice, u256 }
mcpi $r175 $r152 i104                   ; copy memory
addi $r176 $$locbase i1008              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r176 $r173 i24                    ; copy memory
lw $r178 $$locbase i184                 ; load word
addi $r179 $$locbase i1008              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r180 $$locbase i856               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r180 $r179 i24                    ; copy memory
addi $r181 $$locbase i624               ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r178                       ; [call]: pass argument 0
move $$arg1 $r180                       ; [call]: pass argument 1
move $$arg2 $r181                       ; [call]: pass argument 2
fncall .6                               ; [call]: call abi_encode_5
addi $r183 $$locbase i1176              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r183 $r181 i24                    ; copy memory
addi $r184 $$locbase i1472              ; get offset to local __ptr { u64, u64, u64, u8, { { ptr, u64 }, u64 }, slice, u256 }
addi $r185 $r184 i8                     ; get offset to aggregate element
addi $r186 $$locbase i1176              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r187 $$locbase i1032              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r187 $r186 i24                    ; copy memory
addi $r188 $$locbase i736               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r189 $$locbase i1032              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $$locbase $r189 i24                ; copy memory
addi $r191 $$locbase i288               ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r191 $$locbase i24                ; copy memory
lw $r192 $$locbase i36                  ; load word
lw $r194 $$locbase i37                  ; load word
lw $r196 $$locbase i38                  ; load word
movi $r197 i4                           ; initialize constant into register
add $r198 $r196 $r197
gt $r199 $r198 $r194
move $r200 $r192                        ; move parameter from branch to block argument
move $r201 $r194                        ; move parameter from branch to block argument
jnzi $r199 .53
ji  .54
.53
movi $r202 i2                           ; initialize constant into register
mul $r203 $r194 $r202
movi $r204 i4                           ; initialize constant into register
add $r205 $r203 $r204
aloc $r205
mcp $hp $r192 $r196
move $r200 $hp                          ; move parameter from branch to block argument
move $r201 $r205                        ; move parameter from branch to block argument
.54
move $r210 $r200                        ; move parameter from branch to block argument
move $r212 $r201                        ; move parameter from branch to block argument
addi $r213 $$locbase i408               ; get offset to local __ptr u64
mcpi $r213 $r185 i8                     ; copy memory
movi $r214 i4                           ; initialize constant into register
add $r215 $r213 $r214
add $r216 $r210 $r196
mcpi $r216 $r215 i4                     ; copy memory
addi $r217 $$locbase i496               ; get offset to local __ptr { ptr, u64, u64 }
sw $$locbase $r210 i62                  ; store word
sw $$locbase $r212 i63                  ; store word
sw $$locbase $r198 i64                  ; store word
addi $r221 $$locbase i24                ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r221 $r217 i24                    ; copy memory
mcpi $r188 $r221 i24                    ; copy memory
addi $r222 $$locbase i1224              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r222 $r188 i24                    ; copy memory
addi $r223 $$locbase i1472              ; get offset to local __ptr { u64, u64, u64, u8, { { ptr, u64 }, u64 }, slice, u256 }
addi $r224 $r223 i16                    ; get offset to aggregate element
addi $r225 $$locbase i1224              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r226 $$locbase i1056              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r226 $r225 i24                    ; copy memory
addi $r227 $$locbase i760               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r228 $$locbase i1056              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r230 $$locbase i48                ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r230 $r228 i24                    ; copy memory
addi $r231 $$locbase i312               ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r231 $r230 i24                    ; copy memory
lw $r232 $$locbase i39                  ; load word
lw $r234 $$locbase i40                  ; load word
lw $r236 $$locbase i41                  ; load word
movi $r237 i2                           ; initialize constant into register
add $r238 $r236 $r237
gt $r239 $r238 $r234
move $r240 $r232                        ; move parameter from branch to block argument
move $r241 $r234                        ; move parameter from branch to block argument
jnzi $r239 .55
ji  .56
.55
movi $r242 i2                           ; initialize constant into register
mul $r243 $r234 $r242
movi $r244 i2                           ; initialize constant into register
add $r245 $r243 $r244
aloc $r245
mcp $hp $r232 $r236
move $r240 $hp                          ; move parameter from branch to block argument
move $r241 $r245                        ; move parameter from branch to block argument
.56
move $r250 $r240                        ; move parameter from branch to block argument
move $r252 $r241                        ; move parameter from branch to block argument
addi $r253 $$locbase i416               ; get offset to local __ptr u64
mcpi $r253 $r224 i8                     ; copy memory
movi $r254 i6                           ; initialize constant into register
add $r255 $r253 $r254
add $r256 $r250 $r236
mcpi $r256 $r255 i2                     ; copy memory
addi $r257 $$locbase i520               ; get offset to local __ptr { ptr, u64, u64 }
sw $$locbase $r250 i65                  ; store word
sw $$locbase $r252 i66                  ; store word
sw $$locbase $r238 i67                  ; store word
addi $r261 $$locbase i96                ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r261 $r257 i24                    ; copy memory
mcpi $r227 $r261 i24                    ; copy memory
addi $r262 $$locbase i1248              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r262 $r227 i24                    ; copy memory
addi $r263 $$locbase i1472              ; get offset to local __ptr { u64, u64, u64, u8, { { ptr, u64 }, u64 }, slice, u256 }
addi $r264 $r263 i24                    ; get offset to aggregate element
lb $r265 $r264 i0                       ; load byte
addi $r266 $$locbase i1248              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r267 $$locbase i1080              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r267 $r266 i24                    ; copy memory
addi $r268 $$locbase i784               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r269 $$locbase i1080              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r271 $$locbase i120               ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r271 $r269 i24                    ; copy memory
addi $r272 $$locbase i336               ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r272 $r271 i24                    ; copy memory
lw $r273 $$locbase i42                  ; load word
lw $r275 $$locbase i43                  ; load word
lw $r277 $$locbase i44                  ; load word
add $r278 $r277 $one
gt $r279 $r278 $r275
move $r280 $r273                        ; move parameter from branch to block argument
move $r281 $r275                        ; move parameter from branch to block argument
jnzi $r279 .57
ji  .58
.57
movi $r282 i2                           ; initialize constant into register
mul $r283 $r275 $r282
add $r284 $r283 $one
aloc $r284
mcp $hp $r273 $r277
move $r280 $hp                          ; move parameter from branch to block argument
move $r281 $r284                        ; move parameter from branch to block argument
.58
move $r289 $r280                        ; move parameter from branch to block argument
move $r291 $r281                        ; move parameter from branch to block argument
add $r292 $r280 $r277
sb $r292 $r265 i0                       ; store byte
addi $r293 $$locbase i424               ; get offset to local __ptr { ptr, u64, u64 }
sw $$locbase $r289 i53                  ; store word
sw $$locbase $r291 i54                  ; store word
sw $$locbase $r278 i55                  ; store word
addi $r297 $$locbase i144               ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r297 $r293 i24                    ; copy memory
mcpi $r268 $r297 i24                    ; copy memory
addi $r298 $$locbase i1272              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r298 $r268 i24                    ; copy memory
addi $r299 $$locbase i1472              ; get offset to local __ptr { u64, u64, u64, u8, { { ptr, u64 }, u64 }, slice, u256 }
addi $r300 $r299 i32                    ; get offset to aggregate element
addi $r301 $$locbase i1272              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r302 $$locbase i1600              ; get offset to local __ptr { { ptr, u64 }, u64 }
mcpi $r302 $r300 i24                    ; copy memory
addi $r303 $$locbase i1104              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r303 $r301 i24                    ; copy memory
lw $r306 $$locbase i202                 ; load word
addi $r307 $$locbase i1104              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r308 $$locbase i880               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r308 $r307 i24                    ; copy memory
addi $r309 $$locbase i648               ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r306                       ; [call]: pass argument 0
move $$arg1 $r308                       ; [call]: pass argument 1
move $$arg2 $r309                       ; [call]: pass argument 2
fncall .6                               ; [call]: call abi_encode_5
addi $r311 $$locbase i1200              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r311 $r309 i24                    ; copy memory
movi $r312 i0                           ; move parameter from branch to block argument
.59
move $r314 $r312                        ; move parameter from branch to block argument
lt $r315 $r312 $r306
jnzi $r315 .60
.61
addi $r316 $$locbase i1200              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r317 $$locbase i1296              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r317 $r316 i24                    ; copy memory
addi $r318 $$locbase i1472              ; get offset to local __ptr { u64, u64, u64, u8, { { ptr, u64 }, u64 }, slice, u256 }
addi $r319 $r318 i56                    ; get offset to aggregate element
addi $r320 $$locbase i1296              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r321 $$locbase i1624              ; get offset to local __ptr slice
mcpi $r321 $r319 i16                    ; copy memory
addi $r322 $$locbase i1128              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r322 $r320 i24                    ; copy memory
addi $r323 $$locbase i808               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r324 $$locbase i1128              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r326 $$locbase i168               ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r326 $r324 i24                    ; copy memory
addi $r327 $$locbase i360               ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r327 $r326 i24                    ; copy memory
lw $r328 $$locbase i45                  ; load word
lw $r330 $$locbase i46                  ; load word
lw $r332 $$locbase i47                  ; load word
addi $r333 $$locbase i1624              ; get offset to local __ptr slice
addi $r334 $$locbase i208               ; get offset to local __ptr slice
mcpi $r334 $r333 i16                    ; copy memory
addi $r336 $$locbase i192               ; get offset to local __ptr { u64, u64 }
mcpi $r336 $r333 i16                    ; copy memory
addi $r337 $$locbase i448               ; get offset to local __ptr { u64, u64 }
mcpi $r337 $r336 i16                    ; copy memory
lw $r339 $$locbase i57                  ; load word
movi $r340 i8                           ; initialize constant into register
add $r341 $r339 $r340
add $r342 $r332 $r341
gt $r343 $r342 $r330
move $r344 $r328                        ; move parameter from branch to block argument
move $r345 $r330                        ; move parameter from branch to block argument
jnzi $r343 .62
ji  .63
.62
movi $r346 i2                           ; initialize constant into register
mul $r347 $r330 $r346
add $r348 $r347 $r341
aloc $r348
mcp $hp $r328 $r332
move $r344 $hp                          ; move parameter from branch to block argument
move $r345 $r348                        ; move parameter from branch to block argument
.63
move $r353 $r344                        ; move parameter from branch to block argument
move $r355 $r345                        ; move parameter from branch to block argument
addi $r356 $$locbase i544               ; get offset to local __ptr slice
mcpi $r356 $r334 i16                    ; copy memory
add $r357 $r353 $r332
lw $r359 $$locbase i69
sw $r357 $r359 i0
addi $r357 $r357 i8
lw $r358 $$locbase i68
mcp $r357 $r358 $r359
addi $r360 $r332 i8
add $r360 $r360 $r359
move $r361 $r360                        ; return value from ASM block with return register new_len
addi $r362 $$locbase i584               ; get offset to local __ptr { ptr, u64, u64 }
sw $$locbase $r353 i73                  ; store word
sw $$locbase $r355 i74                  ; store word
sw $$locbase $r361 i75                  ; store word
addi $r366 $$locbase i224               ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r366 $r362 i24                    ; copy memory
mcpi $r323 $r366 i24                    ; copy memory
addi $r367 $$locbase i1320              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r367 $r323 i24                    ; copy memory
addi $r368 $$locbase i1472              ; get offset to local __ptr { u64, u64, u64, u8, { { ptr, u64 }, u64 }, slice, u256 }
addi $r369 $r368 i72                    ; get offset to aggregate element
addi $r370 $$locbase i1320              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r371 $$locbase i1640              ; get offset to local __ptr u256
mcpi $r371 $r369 i32                    ; copy memory
addi $r372 $$locbase i1152              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r372 $r370 i24                    ; copy memory
addi $r373 $$locbase i832               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r374 $$locbase i1152              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r376 $$locbase i248               ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r376 $r374 i24                    ; copy memory
addi $r377 $$locbase i384               ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r377 $r376 i24                    ; copy memory
lw $r378 $$locbase i48                  ; load word
lw $r380 $$locbase i49                  ; load word
lw $r382 $$locbase i50                  ; load word
addi $r383 $$locbase i1640              ; get offset to local __ptr u256
movi $r384 i32                          ; initialize constant into register
add $r385 $r382 $r384
gt $r386 $r385 $r380
move $r387 $r378                        ; move parameter from branch to block argument
move $r388 $r380                        ; move parameter from branch to block argument
jnzi $r386 .64
ji  .65
.64
movi $r389 i2                           ; initialize constant into register
mul $r390 $r380 $r389
movi $r391 i32                          ; initialize constant into register
add $r392 $r390 $r391
aloc $r392
mcp $hp $r378 $r382
move $r387 $hp                          ; move parameter from branch to block argument
move $r388 $r392                        ; move parameter from branch to block argument
.65
move $r397 $r387                        ; move parameter from branch to block argument
move $r399 $r388                        ; move parameter from branch to block argument
addi $r400 $$locbase i464               ; get offset to local __ptr u256
mcpi $r400 $r383 i32                    ; copy memory
add $r401 $r397 $r382
mcpi $r401 $r400 i32                    ; copy memory
addi $r402 $$locbase i560               ; get offset to local __ptr { ptr, u64, u64 }
sw $$locbase $r397 i70                  ; store word
sw $$locbase $r399 i71                  ; store word
sw $$locbase $r385 i72                  ; store word
addi $r406 $$locbase i72                ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r406 $r402 i24                    ; copy memory
mcpi $r373 $r406 i24                    ; copy memory
addi $r407 $$locbase i1344              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r407 $r373 i24                    ; copy memory
addi $r408 $$locbase i1344              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r409 $$locbase i984               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r409 $r408 i24                    ; copy memory
addi $r410 $$locbase i984               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r411 $$locbase i928               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r411 $r410 i24                    ; copy memory
addi $r412 $$locbase i720               ; get offset to local __ptr slice
move $$arg0 $r411                       ; [call]: pass argument 0
move $$arg1 $r412                       ; [call]: pass argument 1
fncall .10                              ; [call]: call as_raw_slice_7
addi $r414 $$locbase i952               ; get offset to local __ptr slice
mcpi $r414 $r412 i16                    ; copy memory
move $r415 $r414                        ; move parameter from branch to block argument
ji  .66
.60
addi $r416 $$locbase i1600              ; get offset to local __ptr { { ptr, u64 }, u64 }
addi $r417 $$locbase i1576              ; get offset to local __ptr { { ptr, u64 }, u64 }
mcpi $r417 $r416 i24                    ; copy memory
lw $r419 $$locbase i197                 ; load word
movi $r420 i8                           ; initialize constant into register
mul $r421 $r420 $r314
add $r422 $r419 $r421
lw $r423 $r422 i0                       ; lw val ptr i0
move $r424 $r423                        ; return value from ASM block with return register val
addi $r425 $$locbase i1200              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r426 $$locbase i904               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r426 $r425 i24                    ; copy memory
addi $r427 $$locbase i672               ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r424                       ; [call]: pass argument 0
move $$arg1 $r426                       ; [call]: pass argument 1
move $$arg2 $r427                       ; [call]: pass argument 2
fncall .6                               ; [call]: call abi_encode_5
addi $r429 $$locbase i1200              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r429 $r427 i24                    ; copy memory
add $r430 $r314 $one
move $r312 $r430                        ; move parameter from branch to block argument
ji  .59
.51
addi $r432 $$locbase i968               ; get offset to local __ptr { __ptr { u64, u64, u64, u8, { { ptr, u64 }, u64 }, slice, u256 }, u64 }
sw $$locbase $r152 i121                 ; store word
movi $r434 i104                         ; initialize constant into register
sw $$locbase $r434 i122                 ; store word
addi $r435 $$locbase i272               ; get offset to local __ptr { __ptr { u64, u64, u64, u8, { { ptr, u64 }, u64 }, slice, u256 }, u64 }
mcpi $r435 $r432 i16                    ; copy memory
addi $r436 $$locbase i952               ; get offset to local __ptr slice
mcpi $r436 $r435 i16                    ; copy memory
move $r415 $r436                        ; move parameter from branch to block argument
.66
addi $r440 $$locbase i608               ; get offset to local __ptr slice
mcpi $r440 $r415 i16                    ; copy memory
load $r441 data_NonConfigurable_3       ; load constant from data section
lw $r442 $$locbase i76                  ; load slice pointer for logging data
lw $r443 $$locbase i77                  ; load slice size for logging data
logd $zero $r441 $r442 $r443            ; log slice
.15
cfsi i1672                              ; free 1672 bytes for locals and 0 slots for extra call arguments
move $$reta $r150                       ; restore return address
popa .14                                ; restore all registers
jal $zero $$reta i0                     ; return from call
DIFF------------------------------
.program:
.14                                     ; --- start of function: local_log_21 ---
pusha .14                               ; save all registers
move $$locbase $sp                      ; save locals base register for function local_log_21
cfei i1672                              ; allocate 1672 bytes for locals and 0 slots for call arguments
move $r150 $$reta                       ; save return address
.40
addi $r151 $$locbase i1368              ; get offset to local __ptr { u64, u64, u64, u8, { { ptr, u64 }, u64 }, slice, u256 }
mcpi $r151 $$arg0 i104                  ; copy memory
addi $r152 $$locbase i1368              ; get offset to local __ptr { u64, u64, u64, u8, { { ptr, u64 }, u64 }, slice, u256 }
.42
.44
.46
.48
.50
.52
addi $r173 $$locbase i696               ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r173                       ; [call]: pass argument 0
fncall .8                               ; [call]: call new_6
addi $r175 $$locbase i1472              ; get offset to local __ptr { u64, u64, u64, u8, { { ptr, u64 }, u64 }, slice, u256 }
mcpi $r175 $r152 i104                   ; copy memory
addi $r176 $$locbase i1008              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r176 $r173 i24                    ; copy memory
lw $r178 $$locbase i184                 ; load word
addi $r179 $$locbase i1008              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r180 $$locbase i856               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r180 $r179 i24                    ; copy memory
addi $r181 $$locbase i624               ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r178                       ; [call]: pass argument 0
move $$arg1 $r180                       ; [call]: pass argument 1
move $$arg2 $r181                       ; [call]: pass argument 2
fncall .6                               ; [call]: call abi_encode_5
addi $r183 $$locbase i1176              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r183 $r181 i24                    ; copy memory
addi $r184 $$locbase i1472              ; get offset to local __ptr { u64, u64, u64, u8, { { ptr, u64 }, u64 }, slice, u256 }
addi $r185 $r184 i8                     ; get offset to aggregate element
addi $r186 $$locbase i1176              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r187 $$locbase i1032              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r187 $r186 i24                    ; copy memory
addi $r188 $$locbase i736               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r189 $$locbase i1032              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $$locbase $r189 i24                ; copy memory
addi $r191 $$locbase i288               ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r191 $$locbase i24                ; copy memory
lw $r192 $$locbase i36                  ; load word
lw $r194 $$locbase i37                  ; load word
lw $r196 $$locbase i38                  ; load word
movi $r197 i4                           ; initialize constant into register
add $r198 $r196 $r197
gt $r199 $r198 $r194
move $r200 $r192                        ; move parameter from branch to block argument
move $r201 $r194                        ; move parameter from branch to block argument
jnzi $r199 .53
ji  .54
.53
movi $r202 i2                           ; initialize constant into register
mul $r203 $r194 $r202
movi $r204 i4                           ; initialize constant into register
add $r205 $r203 $r204
aloc $r205
mcp $hp $r192 $r196
move $r200 $hp                          ; move parameter from branch to block argument
move $r201 $r205                        ; move parameter from branch to block argument
.54
move $r210 $r200                        ; move parameter from branch to block argument
move $r212 $r201                        ; move parameter from branch to block argument
addi $r213 $$locbase i408               ; get offset to local __ptr u64
mcpi $r213 $r185 i8                     ; copy memory
movi $r214 i4                           ; initialize constant into register
add $r215 $r213 $r214
add $r216 $r210 $r196
mcpi $r216 $r215 i4                     ; copy memory
addi $r217 $$locbase i496               ; get offset to local __ptr { ptr, u64, u64 }
sw $$locbase $r210 i62                  ; store word
sw $$locbase $r212 i63                  ; store word
sw $$locbase $r198 i64                  ; store word
addi $r221 $$locbase i24                ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r221 $r217 i24                    ; copy memory
mcpi $r188 $r221 i24                    ; copy memory
addi $r222 $$locbase i1224              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r222 $r188 i24                    ; copy memory
addi $r223 $$locbase i1472              ; get offset to local __ptr { u64, u64, u64, u8, { { ptr, u64 }, u64 }, slice, u256 }
addi $r224 $r223 i16                    ; get offset to aggregate element
addi $r225 $$locbase i1224              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r226 $$locbase i1056              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r226 $r225 i24                    ; copy memory
addi $r227 $$locbase i760               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r228 $$locbase i1056              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r230 $$locbase i48                ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r230 $r228 i24                    ; copy memory
addi $r231 $$locbase i312               ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r231 $r230 i24                    ; copy memory
lw $r232 $$locbase i39                  ; load word
lw $r234 $$locbase i40                  ; load word
lw $r236 $$locbase i41                  ; load word
movi $r237 i2                           ; initialize constant into register
add $r238 $r236 $r237
gt $r239 $r238 $r234
move $r240 $r232                        ; move parameter from branch to block argument
move $r241 $r234                        ; move parameter from branch to block argument
jnzi $r239 .55
ji  .56
.55
movi $r242 i2                           ; initialize constant into register
mul $r243 $r234 $r242
movi $r244 i2                           ; initialize constant into register
add $r245 $r243 $r244
aloc $r245
mcp $hp $r232 $r236
move $r240 $hp                          ; move parameter from branch to block argument
move $r241 $r245                        ; move parameter from branch to block argument
.56
move $r250 $r240                        ; move parameter from branch to block argument
move $r252 $r241                        ; move parameter from branch to block argument
addi $r253 $$locbase i416               ; get offset to local __ptr u64
mcpi $r253 $r224 i8                     ; copy memory
movi $r254 i6                           ; initialize constant into register
add $r255 $r253 $r254
add $r256 $r250 $r236
mcpi $r256 $r255 i2                     ; copy memory
addi $r257 $$locbase i520               ; get offset to local __ptr { ptr, u64, u64 }
sw $$locbase $r250 i65                  ; store word
sw $$locbase $r252 i66                  ; store word
sw $$locbase $r238 i67                  ; store word
addi $r261 $$locbase i96                ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r261 $r257 i24                    ; copy memory
mcpi $r227 $r261 i24                    ; copy memory
addi $r262 $$locbase i1248              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r262 $r227 i24                    ; copy memory
addi $r263 $$locbase i1472              ; get offset to local __ptr { u64, u64, u64, u8, { { ptr, u64 }, u64 }, slice, u256 }
addi $r264 $r263 i24                    ; get offset to aggregate element
lb $r265 $r264 i0                       ; load byte
addi $r266 $$locbase i1248              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r267 $$locbase i1080              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r267 $r266 i24                    ; copy memory
addi $r268 $$locbase i784               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r269 $$locbase i1080              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r271 $$locbase i120               ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r271 $r269 i24                    ; copy memory
addi $r272 $$locbase i336               ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r272 $r271 i24                    ; copy memory
lw $r273 $$locbase i42                  ; load word
lw $r275 $$locbase i43                  ; load word
lw $r277 $$locbase i44                  ; load word
add $r278 $r277 $one
gt $r279 $r278 $r275
move $r280 $r273                        ; move parameter from branch to block argument
move $r281 $r275                        ; move parameter from branch to block argument
jnzi $r279 .57
ji  .58
.57
movi $r282 i2                           ; initialize constant into register
mul $r283 $r275 $r282
add $r284 $r283 $one
aloc $r284
mcp $hp $r273 $r277
move $r280 $hp                          ; move parameter from branch to block argument
move $r281 $r284                        ; move parameter from branch to block argument
.58
move $r289 $r280                        ; move parameter from branch to block argument
move $r291 $r281                        ; move parameter from branch to block argument
add $r292 $r280 $r277
sb $r292 $r265 i0                       ; store byte
addi $r293 $$locbase i424               ; get offset to local __ptr { ptr, u64, u64 }
sw $$locbase $r289 i53                  ; store word
sw $$locbase $r291 i54                  ; store word
sw $$locbase $r278 i55                  ; store word
addi $r297 $$locbase i144               ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r297 $r293 i24                    ; copy memory
mcpi $r268 $r297 i24                    ; copy memory
addi $r298 $$locbase i1272              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r298 $r268 i24                    ; copy memory
addi $r299 $$locbase i1472              ; get offset to local __ptr { u64, u64, u64, u8, { { ptr, u64 }, u64 }, slice, u256 }
addi $r300 $r299 i32                    ; get offset to aggregate element
addi $r301 $$locbase i1272              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r302 $$locbase i1600              ; get offset to local __ptr { { ptr, u64 }, u64 }
mcpi $r302 $r300 i24                    ; copy memory
addi $r303 $$locbase i1104              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r303 $r301 i24                    ; copy memory
lw $r306 $$locbase i202                 ; load word
addi $r307 $$locbase i1104              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r308 $$locbase i880               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r308 $r307 i24                    ; copy memory
addi $r309 $$locbase i648               ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r306                       ; [call]: pass argument 0
move $$arg1 $r308                       ; [call]: pass argument 1
move $$arg2 $r309                       ; [call]: pass argument 2
fncall .6                               ; [call]: call abi_encode_5
addi $r311 $$locbase i1200              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r311 $r309 i24                    ; copy memory
movi $r312 i0                           ; move parameter from branch to block argument
.59
move $r314 $r312                        ; move parameter from branch to block argument
lt $r315 $r312 $r306
jnzi $r315 .60
.61
addi $r316 $$locbase i1200              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r317 $$locbase i1296              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r317 $r316 i24                    ; copy memory
addi $r318 $$locbase i1472              ; get offset to local __ptr { u64, u64, u64, u8, { { ptr, u64 }, u64 }, slice, u256 }
addi $r319 $r318 i56                    ; get offset to aggregate element
addi $r320 $$locbase i1296              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r321 $$locbase i1624              ; get offset to local __ptr slice
mcpi $r321 $r319 i16                    ; copy memory
addi $r322 $$locbase i1128              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r322 $r320 i24                    ; copy memory
addi $r323 $$locbase i808               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r324 $$locbase i1128              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r326 $$locbase i168               ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r326 $r324 i24                    ; copy memory
addi $r327 $$locbase i360               ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r327 $r326 i24                    ; copy memory
lw $r328 $$locbase i45                  ; load word
lw $r330 $$locbase i46                  ; load word
lw $r332 $$locbase i47                  ; load word
addi $r333 $$locbase i1624              ; get offset to local __ptr slice
addi $r334 $$locbase i208               ; get offset to local __ptr slice
mcpi $r334 $r333 i16                    ; copy memory
addi $r336 $$locbase i192               ; get offset to local __ptr { u64, u64 }
mcpi $r336 $r333 i16                    ; copy memory
addi $r337 $$locbase i448               ; get offset to local __ptr { u64, u64 }
mcpi $r337 $r336 i16                    ; copy memory
lw $r339 $$locbase i57                  ; load word
movi $r340 i8                           ; initialize constant into register
add $r341 $r339 $r340
add $r342 $r332 $r341
gt $r343 $r342 $r330
move $r344 $r328                        ; move parameter from branch to block argument
move $r345 $r330                        ; move parameter from branch to block argument
jnzi $r343 .62
ji  .63
.62
movi $r346 i2                           ; initialize constant into register
mul $r347 $r330 $r346
add $r348 $r347 $r341
aloc $r348
mcp $hp $r328 $r332
move $r344 $hp                          ; move parameter from branch to block argument
move $r345 $r348                        ; move parameter from branch to block argument
.63
move $r353 $r344                        ; move parameter from branch to block argument
move $r355 $r345                        ; move parameter from branch to block argument
addi $r356 $$locbase i544               ; get offset to local __ptr slice
mcpi $r356 $r334 i16                    ; copy memory
add $r357 $r353 $r332
lw $r359 $$locbase i69
sw $r357 $r359 i0
addi $r357 $r357 i8
lw $r358 $$locbase i68
mcp $r357 $r358 $r359
addi $r360 $r332 i8
add $r360 $r360 $r359
move $r361 $r360                        ; return value from ASM block with return register new_len
addi $r362 $$locbase i584               ; get offset to local __ptr { ptr, u64, u64 }
sw $$locbase $r353 i73                  ; store word
sw $$locbase $r355 i74                  ; store word
sw $$locbase $r361 i75                  ; store word
addi $r366 $$locbase i224               ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r366 $r362 i24                    ; copy memory
mcpi $r323 $r366 i24                    ; copy memory
addi $r367 $$locbase i1320              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r367 $r323 i24                    ; copy memory
addi $r368 $$locbase i1472              ; get offset to local __ptr { u64, u64, u64, u8, { { ptr, u64 }, u64 }, slice, u256 }
addi $r369 $r368 i72                    ; get offset to aggregate element
addi $r370 $$locbase i1320              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r371 $$locbase i1640              ; get offset to local __ptr u256
mcpi $r371 $r369 i32                    ; copy memory
addi $r372 $$locbase i1152              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r372 $r370 i24                    ; copy memory
addi $r373 $$locbase i832               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r374 $$locbase i1152              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r376 $$locbase i248               ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r376 $r374 i24                    ; copy memory
addi $r377 $$locbase i384               ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r377 $r376 i24                    ; copy memory
lw $r378 $$locbase i48                  ; load word
lw $r380 $$locbase i49                  ; load word
lw $r382 $$locbase i50                  ; load word
addi $r383 $$locbase i1640              ; get offset to local __ptr u256
movi $r384 i32                          ; initialize constant into register
add $r385 $r382 $r384
gt $r386 $r385 $r380
move $r387 $r378                        ; move parameter from branch to block argument
move $r388 $r380                        ; move parameter from branch to block argument
jnzi $r386 .64
ji  .65
.64
movi $r389 i2                           ; initialize constant into register
mul $r390 $r380 $r389
movi $r391 i32                          ; initialize constant into register
add $r392 $r390 $r391
aloc $r392
mcp $hp $r378 $r382
move $r387 $hp                          ; move parameter from branch to block argument
move $r388 $r392                        ; move parameter from branch to block argument
.65
move $r397 $r387                        ; move parameter from branch to block argument
move $r399 $r388                        ; move parameter from branch to block argument
addi $r400 $$locbase i464               ; get offset to local __ptr u256
mcpi $r400 $r383 i32                    ; copy memory
add $r401 $r397 $r382
mcpi $r401 $r400 i32                    ; copy memory
addi $r402 $$locbase i560               ; get offset to local __ptr { ptr, u64, u64 }
sw $$locbase $r397 i70                  ; store word
sw $$locbase $r399 i71                  ; store word
sw $$locbase $r385 i72                  ; store word
addi $r406 $$locbase i72                ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r406 $r402 i24                    ; copy memory
mcpi $r373 $r406 i24                    ; copy memory
addi $r407 $$locbase i1344              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r407 $r373 i24                    ; copy memory
addi $r408 $$locbase i1344              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r409 $$locbase i984               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r409 $r408 i24                    ; copy memory
addi $r410 $$locbase i984               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r411 $$locbase i928               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r411 $r410 i24                    ; copy memory
addi $r412 $$locbase i720               ; get offset to local __ptr slice
move $$arg0 $r411                       ; [call]: pass argument 0
move $$arg1 $r412                       ; [call]: pass argument 1
fncall .10                              ; [call]: call as_raw_slice_7
addi $r414 $$locbase i952               ; get offset to local __ptr slice
mcpi $r414 $r412 i16                    ; copy memory
move $r415 $r414                        ; move parameter from branch to block argument
ji  .66
.60
addi $r416 $$locbase i1600              ; get offset to local __ptr { { ptr, u64 }, u64 }
addi $r417 $$locbase i1576              ; get offset to local __ptr { { ptr, u64 }, u64 }
mcpi $r417 $r416 i24                    ; copy memory
lw $r419 $$locbase i197                 ; load word
movi $r420 i8                           ; initialize constant into register
mul $r421 $r420 $r314
add $r422 $r419 $r421
lw $r423 $r422 i0                       ; lw val ptr i0
move $r424 $r423                        ; return value from ASM block with return register val
addi $r425 $$locbase i1200              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r426 $$locbase i904               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r426 $r425 i24                    ; copy memory
addi $r427 $$locbase i672               ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r424                       ; [call]: pass argument 0
move $$arg1 $r426                       ; [call]: pass argument 1
move $$arg2 $r427                       ; [call]: pass argument 2
fncall .6                               ; [call]: call abi_encode_5
addi $r429 $$locbase i1200              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r429 $r427 i24                    ; copy memory
add $r430 $r314 $one
move $r312 $r430                        ; move parameter from branch to block argument
ji  .59
.66
addi $r440 $$locbase i608               ; get offset to local __ptr slice
mcpi $r440 $r415 i16                    ; copy memory
load $r441 data_NonConfigurable_3       ; load constant from data section
lw $r442 $$locbase i76                  ; load slice pointer for logging data
lw $r443 $$locbase i77                  ; load slice size for logging data
logd $zero $r441 $r442 $r443            ; log slice
.15
cfsi i1672                              ; free 1672 bytes for locals and 0 slots for extra call arguments
move $$reta $r150                       ; restore return address
popa .14                                ; restore all registers
jal $zero $$reta i0                     ; return from call
DIFF------------------------------
.program:
.14                                     ; --- start of function: local_log_21 ---
pusha .14                               ; save all registers
move $$locbase $sp                      ; save locals base register for function local_log_21
cfei i1672                              ; allocate 1672 bytes for locals and 0 slots for call arguments
move $r150 $$reta                       ; save return address
.40
addi $r151 $$locbase i1368              ; get offset to local __ptr { u64, u64, u64, u8, { { ptr, u64 }, u64 }, slice, u256 }
mcpi $r151 $$arg0 i104                  ; copy memory
addi $r152 $$locbase i1368              ; get offset to local __ptr { u64, u64, u64, u8, { { ptr, u64 }, u64 }, slice, u256 }
.42
.44
.46
.48
.50
.52
addi $r173 $$locbase i696               ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r173                       ; [call]: pass argument 0
fncall .8                               ; [call]: call new_6
addi $r175 $$locbase i1472              ; get offset to local __ptr { u64, u64, u64, u8, { { ptr, u64 }, u64 }, slice, u256 }
mcpi $r175 $r152 i104                   ; copy memory
addi $r176 $$locbase i1008              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r176 $r173 i24                    ; copy memory
lw $r178 $$locbase i184                 ; load word
addi $r179 $$locbase i1008              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r180 $$locbase i856               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r180 $r179 i24                    ; copy memory
addi $r181 $$locbase i624               ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r178                       ; [call]: pass argument 0
move $$arg1 $r180                       ; [call]: pass argument 1
move $$arg2 $r181                       ; [call]: pass argument 2
fncall .6                               ; [call]: call abi_encode_5
addi $r183 $$locbase i1176              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r183 $r181 i24                    ; copy memory
addi $r184 $$locbase i1472              ; get offset to local __ptr { u64, u64, u64, u8, { { ptr, u64 }, u64 }, slice, u256 }
addi $r185 $r184 i8                     ; get offset to aggregate element
addi $r186 $$locbase i1176              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r187 $$locbase i1032              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r187 $r186 i24                    ; copy memory
addi $r188 $$locbase i736               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r189 $$locbase i1032              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $$locbase $r189 i24                ; copy memory
addi $r191 $$locbase i288               ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r191 $$locbase i24                ; copy memory
lw $r192 $$locbase i36                  ; load word
lw $r194 $$locbase i37                  ; load word
lw $r196 $$locbase i38                  ; load word
movi $r197 i4                           ; initialize constant into register
add $r198 $r196 $r197
gt $r199 $r198 $r194
move $r200 $r192                        ; move parameter from branch to block argument
move $r201 $r194                        ; move parameter from branch to block argument
jnzi $r199 .53
ji  .54
.53
movi $r202 i2                           ; initialize constant into register
mul $r203 $r194 $r202
movi $r204 i4                           ; initialize constant into register
add $r205 $r203 $r204
aloc $r205
mcp $hp $r192 $r196
move $r200 $hp                          ; move parameter from branch to block argument
move $r201 $r205                        ; move parameter from branch to block argument
.54
move $r210 $r200                        ; move parameter from branch to block argument
move $r212 $r201                        ; move parameter from branch to block argument
addi $r213 $$locbase i408               ; get offset to local __ptr u64
mcpi $r213 $r185 i8                     ; copy memory
movi $r214 i4                           ; initialize constant into register
add $r215 $r213 $r214
add $r216 $r210 $r196
mcpi $r216 $r215 i4                     ; copy memory
addi $r217 $$locbase i496               ; get offset to local __ptr { ptr, u64, u64 }
sw $$locbase $r210 i62                  ; store word
sw $$locbase $r212 i63                  ; store word
sw $$locbase $r198 i64                  ; store word
addi $r221 $$locbase i24                ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r221 $r217 i24                    ; copy memory
mcpi $r188 $r221 i24                    ; copy memory
addi $r222 $$locbase i1224              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r222 $r188 i24                    ; copy memory
addi $r223 $$locbase i1472              ; get offset to local __ptr { u64, u64, u64, u8, { { ptr, u64 }, u64 }, slice, u256 }
addi $r224 $r223 i16                    ; get offset to aggregate element
addi $r225 $$locbase i1224              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r226 $$locbase i1056              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r226 $r225 i24                    ; copy memory
addi $r227 $$locbase i760               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r228 $$locbase i1056              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r230 $$locbase i48                ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r230 $r228 i24                    ; copy memory
addi $r231 $$locbase i312               ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r231 $r230 i24                    ; copy memory
lw $r232 $$locbase i39                  ; load word
lw $r234 $$locbase i40                  ; load word
lw $r236 $$locbase i41                  ; load word
movi $r237 i2                           ; initialize constant into register
add $r238 $r236 $r237
gt $r239 $r238 $r234
move $r240 $r232                        ; move parameter from branch to block argument
move $r241 $r234                        ; move parameter from branch to block argument
jnzi $r239 .55
ji  .56
.55
movi $r242 i2                           ; initialize constant into register
mul $r243 $r234 $r242
movi $r244 i2                           ; initialize constant into register
add $r245 $r243 $r244
aloc $r245
mcp $hp $r232 $r236
move $r240 $hp                          ; move parameter from branch to block argument
move $r241 $r245                        ; move parameter from branch to block argument
.56
move $r250 $r240                        ; move parameter from branch to block argument
move $r252 $r241                        ; move parameter from branch to block argument
addi $r253 $$locbase i416               ; get offset to local __ptr u64
mcpi $r253 $r224 i8                     ; copy memory
movi $r254 i6                           ; initialize constant into register
add $r255 $r253 $r254
add $r256 $r250 $r236
mcpi $r256 $r255 i2                     ; copy memory
addi $r257 $$locbase i520               ; get offset to local __ptr { ptr, u64, u64 }
sw $$locbase $r250 i65                  ; store word
sw $$locbase $r252 i66                  ; store word
sw $$locbase $r238 i67                  ; store word
addi $r261 $$locbase i96                ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r261 $r257 i24                    ; copy memory
mcpi $r227 $r261 i24                    ; copy memory
addi $r262 $$locbase i1248              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r262 $r227 i24                    ; copy memory
addi $r263 $$locbase i1472              ; get offset to local __ptr { u64, u64, u64, u8, { { ptr, u64 }, u64 }, slice, u256 }
addi $r264 $r263 i24                    ; get offset to aggregate element
lb $r265 $r264 i0                       ; load byte
addi $r266 $$locbase i1248              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r267 $$locbase i1080              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r267 $r266 i24                    ; copy memory
addi $r268 $$locbase i784               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r269 $$locbase i1080              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r271 $$locbase i120               ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r271 $r269 i24                    ; copy memory
addi $r272 $$locbase i336               ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r272 $r271 i24                    ; copy memory
lw $r273 $$locbase i42                  ; load word
lw $r275 $$locbase i43                  ; load word
lw $r277 $$locbase i44                  ; load word
add $r278 $r277 $one
gt $r279 $r278 $r275
move $r280 $r273                        ; move parameter from branch to block argument
move $r281 $r275                        ; move parameter from branch to block argument
jnzi $r279 .57
ji  .58
.57
movi $r282 i2                           ; initialize constant into register
mul $r283 $r275 $r282
add $r284 $r283 $one
aloc $r284
mcp $hp $r273 $r277
move $r280 $hp                          ; move parameter from branch to block argument
move $r281 $r284                        ; move parameter from branch to block argument
.58
move $r289 $r280                        ; move parameter from branch to block argument
move $r291 $r281                        ; move parameter from branch to block argument
add $r292 $r280 $r277
sb $r292 $r265 i0                       ; store byte
addi $r293 $$locbase i424               ; get offset to local __ptr { ptr, u64, u64 }
sw $$locbase $r289 i53                  ; store word
sw $$locbase $r291 i54                  ; store word
sw $$locbase $r278 i55                  ; store word
addi $r297 $$locbase i144               ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r297 $r293 i24                    ; copy memory
mcpi $r268 $r297 i24                    ; copy memory
addi $r298 $$locbase i1272              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r298 $r268 i24                    ; copy memory
addi $r299 $$locbase i1472              ; get offset to local __ptr { u64, u64, u64, u8, { { ptr, u64 }, u64 }, slice, u256 }
addi $r300 $r299 i32                    ; get offset to aggregate element
addi $r301 $$locbase i1272              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r302 $$locbase i1600              ; get offset to local __ptr { { ptr, u64 }, u64 }
mcpi $r302 $r300 i24                    ; copy memory
addi $r303 $$locbase i1104              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r303 $r301 i24                    ; copy memory
lw $r306 $$locbase i202                 ; load word
addi $r307 $$locbase i1104              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r308 $$locbase i880               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r308 $r307 i24                    ; copy memory
addi $r309 $$locbase i648               ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r306                       ; [call]: pass argument 0
move $$arg1 $r308                       ; [call]: pass argument 1
move $$arg2 $r309                       ; [call]: pass argument 2
fncall .6                               ; [call]: call abi_encode_5
addi $r311 $$locbase i1200              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r311 $r309 i24                    ; copy memory
movi $r312 i0                           ; move parameter from branch to block argument
.59
move $r314 $r312                        ; move parameter from branch to block argument
lt $r315 $r312 $r306
jnzi $r315 .60
.61
addi $r316 $$locbase i1200              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r317 $$locbase i1296              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r317 $r316 i24                    ; copy memory
addi $r318 $$locbase i1472              ; get offset to local __ptr { u64, u64, u64, u8, { { ptr, u64 }, u64 }, slice, u256 }
addi $r319 $r318 i56                    ; get offset to aggregate element
addi $r320 $$locbase i1296              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r321 $$locbase i1624              ; get offset to local __ptr slice
mcpi $r321 $r319 i16                    ; copy memory
addi $r322 $$locbase i1128              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r322 $r320 i24                    ; copy memory
addi $r323 $$locbase i808               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r324 $$locbase i1128              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r326 $$locbase i168               ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r326 $r324 i24                    ; copy memory
addi $r327 $$locbase i360               ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r327 $r326 i24                    ; copy memory
lw $r328 $$locbase i45                  ; load word
lw $r330 $$locbase i46                  ; load word
lw $r332 $$locbase i47                  ; load word
addi $r333 $$locbase i1624              ; get offset to local __ptr slice
addi $r334 $$locbase i208               ; get offset to local __ptr slice
mcpi $r334 $r333 i16                    ; copy memory
addi $r336 $$locbase i192               ; get offset to local __ptr { u64, u64 }
mcpi $r336 $r333 i16                    ; copy memory
addi $r337 $$locbase i448               ; get offset to local __ptr { u64, u64 }
mcpi $r337 $r336 i16                    ; copy memory
lw $r339 $$locbase i57                  ; load word
movi $r340 i8                           ; initialize constant into register
add $r341 $r339 $r340
add $r342 $r332 $r341
gt $r343 $r342 $r330
move $r344 $r328                        ; move parameter from branch to block argument
move $r345 $r330                        ; move parameter from branch to block argument
jnzi $r343 .62
ji  .63
.62
movi $r346 i2                           ; initialize constant into register
mul $r347 $r330 $r346
add $r348 $r347 $r341
aloc $r348
mcp $hp $r328 $r332
move $r344 $hp                          ; move parameter from branch to block argument
move $r345 $r348                        ; move parameter from branch to block argument
.63
move $r353 $r344                        ; move parameter from branch to block argument
move $r355 $r345                        ; move parameter from branch to block argument
addi $r356 $$locbase i544               ; get offset to local __ptr slice
mcpi $r356 $r334 i16                    ; copy memory
add $r357 $r353 $r332
lw $r359 $$locbase i69
sw $r357 $r359 i0
addi $r357 $r357 i8
lw $r358 $$locbase i68
mcp $r357 $r358 $r359
addi $r360 $r332 i8
add $r360 $r360 $r359
move $r361 $r360                        ; return value from ASM block with return register new_len
addi $r362 $$locbase i584               ; get offset to local __ptr { ptr, u64, u64 }
sw $$locbase $r353 i73                  ; store word
sw $$locbase $r355 i74                  ; store word
sw $$locbase $r361 i75                  ; store word
addi $r366 $$locbase i224               ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r366 $r362 i24                    ; copy memory
mcpi $r323 $r366 i24                    ; copy memory
addi $r367 $$locbase i1320              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r367 $r323 i24                    ; copy memory
addi $r368 $$locbase i1472              ; get offset to local __ptr { u64, u64, u64, u8, { { ptr, u64 }, u64 }, slice, u256 }
addi $r369 $r368 i72                    ; get offset to aggregate element
addi $r370 $$locbase i1320              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r371 $$locbase i1640              ; get offset to local __ptr u256
mcpi $r371 $r369 i32                    ; copy memory
addi $r372 $$locbase i1152              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r372 $r370 i24                    ; copy memory
addi $r373 $$locbase i832               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r374 $$locbase i1152              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r376 $$locbase i248               ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r376 $r374 i24                    ; copy memory
addi $r377 $$locbase i384               ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r377 $r376 i24                    ; copy memory
lw $r378 $$locbase i48                  ; load word
lw $r380 $$locbase i49                  ; load word
lw $r382 $$locbase i50                  ; load word
addi $r383 $$locbase i1640              ; get offset to local __ptr u256
movi $r384 i32                          ; initialize constant into register
add $r385 $r382 $r384
gt $r386 $r385 $r380
move $r387 $r378                        ; move parameter from branch to block argument
move $r388 $r380                        ; move parameter from branch to block argument
jnzi $r386 .64
ji  .65
.64
movi $r389 i2                           ; initialize constant into register
mul $r390 $r380 $r389
movi $r391 i32                          ; initialize constant into register
add $r392 $r390 $r391
aloc $r392
mcp $hp $r378 $r382
move $r387 $hp                          ; move parameter from branch to block argument
move $r388 $r392                        ; move parameter from branch to block argument
.65
move $r397 $r387                        ; move parameter from branch to block argument
move $r399 $r388                        ; move parameter from branch to block argument
addi $r400 $$locbase i464               ; get offset to local __ptr u256
mcpi $r400 $r383 i32                    ; copy memory
add $r401 $r397 $r382
mcpi $r401 $r400 i32                    ; copy memory
addi $r402 $$locbase i560               ; get offset to local __ptr { ptr, u64, u64 }
sw $$locbase $r397 i70                  ; store word
sw $$locbase $r399 i71                  ; store word
sw $$locbase $r385 i72                  ; store word
addi $r406 $$locbase i72                ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r406 $r402 i24                    ; copy memory
mcpi $r373 $r406 i24                    ; copy memory
addi $r407 $$locbase i1344              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r407 $r373 i24                    ; copy memory
addi $r408 $$locbase i1344              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r409 $$locbase i984               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r409 $r408 i24                    ; copy memory
addi $r410 $$locbase i984               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r411 $$locbase i928               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r411 $r410 i24                    ; copy memory
addi $r412 $$locbase i720               ; get offset to local __ptr slice
move $$arg0 $r411                       ; [call]: pass argument 0
move $$arg1 $r412                       ; [call]: pass argument 1
fncall .10                              ; [call]: call as_raw_slice_7
addi $r414 $$locbase i952               ; get offset to local __ptr slice
mcpi $r414 $r412 i16                    ; copy memory
move $r415 $r414                        ; move parameter from branch to block argument
ji  .66
.60
addi $r416 $$locbase i1600              ; get offset to local __ptr { { ptr, u64 }, u64 }
addi $r417 $$locbase i1576              ; get offset to local __ptr { { ptr, u64 }, u64 }
mcpi $r417 $r416 i24                    ; copy memory
lw $r419 $$locbase i197                 ; load word
movi $r420 i8                           ; initialize constant into register
mul $r421 $r420 $r314
add $r422 $r419 $r421
lw $r423 $r422 i0                       ; lw val ptr i0
move $r424 $r423                        ; return value from ASM block with return register val
addi $r425 $$locbase i1200              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r426 $$locbase i904               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r426 $r425 i24                    ; copy memory
addi $r427 $$locbase i672               ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r424                       ; [call]: pass argument 0
move $$arg1 $r426                       ; [call]: pass argument 1
move $$arg2 $r427                       ; [call]: pass argument 2
fncall .6                               ; [call]: call abi_encode_5
addi $r429 $$locbase i1200              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r429 $r427 i24                    ; copy memory
add $r430 $r314 $one
move $r312 $r430                        ; move parameter from branch to block argument
ji  .59
.66
addi $r440 $$locbase i608               ; get offset to local __ptr slice
mcpi $r440 $r415 i16                    ; copy memory
load $r441 data_NonConfigurable_3       ; load constant from data section
lw $r442 $$locbase i76                  ; load slice pointer for logging data
lw $r443 $$locbase i77                  ; load slice size for logging data
logd $zero $r441 $r442 $r443            ; log slice
.15
cfsi i1672                              ; free 1672 bytes for locals and 0 slots for extra call arguments
move $$reta $r150                       ; restore return address
popa .14                                ; restore all registers
jal $zero $$reta i0                     ; return from call
DIFF------------------------------
.program:
.16                                     ; --- start of function: local_log_48 ---
pusha .16                               ; save all registers
move $$locbase $sp                      ; save locals base register for function local_log_48
cfei i40                                ; allocate 40 bytes for locals and 0 slots for call arguments
.67
addi $r445 $$locbase i32                ; get offset to local __ptr { u64 }
mcpi $r445 $$arg0 i8                    ; copy memory
addi $r446 $$locbase i32                ; get offset to local __ptr { u64 }
sw $$locbase $r446 i0                   ; store word
addi $r447 $$locbase i8                 ; get offset to aggregate element
movi $r448 i8                           ; initialize constant into register
sw $$locbase $r448 i1                   ; store word
addi $r449 $$locbase i16                ; get offset to local __ptr slice
mcpi $r449 $$locbase i16                ; copy memory
load $r450 data_NonConfigurable_4       ; load constant from data section
lw $r451 $$locbase i2                   ; load slice pointer for logging data
lw $r452 $$locbase i3                   ; load slice size for logging data
logd $zero $r450 $r451 $r452            ; log slice
ji  .17
.17
cfsi i40                                ; free 40 bytes for locals and 0 slots for extra call arguments
popa .16                                ; restore all registers
jal $zero $$reta i0                     ; return from call
DIFF------------------------------
.program:
.16                                     ; --- start of function: local_log_48 ---
pusha .16                               ; save all registers
move $$locbase $sp                      ; save locals base register for function local_log_48
cfei i40                                ; allocate 40 bytes for locals and 0 slots for call arguments
.67
addi $r445 $$locbase i32                ; get offset to local __ptr { u64 }
mcpi $r445 $$arg0 i8                    ; copy memory
addi $r446 $$locbase i32                ; get offset to local __ptr { u64 }
sw $$locbase $r446 i0                   ; store word
movi $r448 i8                           ; initialize constant into register
sw $$locbase $r448 i1                   ; store word
addi $r449 $$locbase i16                ; get offset to local __ptr slice
mcpi $r449 $$locbase i16                ; copy memory
load $r450 data_NonConfigurable_4       ; load constant from data section
lw $r451 $$locbase i2                   ; load slice pointer for logging data
lw $r452 $$locbase i3                   ; load slice size for logging data
logd $zero $r450 $r451 $r452            ; log slice
.17
cfsi i40                                ; free 40 bytes for locals and 0 slots for extra call arguments
popa .16                                ; restore all registers
jal $zero $$reta i0                     ; return from call
DIFF------------------------------
.program:
.16                                     ; --- start of function: local_log_48 ---
pusha .16                               ; save all registers
move $$locbase $sp                      ; save locals base register for function local_log_48
cfei i40                                ; allocate 40 bytes for locals and 0 slots for call arguments
.67
addi $r445 $$locbase i32                ; get offset to local __ptr { u64 }
mcpi $r445 $$arg0 i8                    ; copy memory
addi $r446 $$locbase i32                ; get offset to local __ptr { u64 }
sw $$locbase $r446 i0                   ; store word
movi $r448 i8                           ; initialize constant into register
sw $$locbase $r448 i1                   ; store word
addi $r449 $$locbase i16                ; get offset to local __ptr slice
mcpi $r449 $$locbase i16                ; copy memory
load $r450 data_NonConfigurable_4       ; load constant from data section
lw $r451 $$locbase i2                   ; load slice pointer for logging data
lw $r452 $$locbase i3                   ; load slice size for logging data
logd $zero $r450 $r451 $r452            ; log slice
.17
cfsi i40                                ; free 40 bytes for locals and 0 slots for extra call arguments
popa .16                                ; restore all registers
jal $zero $$reta i0                     ; return from call
DIFF------------------------------
.program:
.16                                     ; --- start of function: local_log_48 ---
pusha .16                               ; save all registers
move $$locbase $sp                      ; save locals base register for function local_log_48
cfei i40                                ; allocate 40 bytes for locals and 0 slots for call arguments
.67
addi $r445 $$locbase i32                ; get offset to local __ptr { u64 }
mcpi $r445 $$arg0 i8                    ; copy memory
addi $r446 $$locbase i32                ; get offset to local __ptr { u64 }
sw $$locbase $r446 i0                   ; store word
movi $r448 i8                           ; initialize constant into register
sw $$locbase $r448 i1                   ; store word
addi $r449 $$locbase i16                ; get offset to local __ptr slice
mcpi $r449 $$locbase i16                ; copy memory
load $r450 data_NonConfigurable_4       ; load constant from data section
lw $r451 $$locbase i2                   ; load slice pointer for logging data
lw $r452 $$locbase i3                   ; load slice size for logging data
logd $zero $r450 $r451 $r452            ; log slice
.17
cfsi i40                                ; free 40 bytes for locals and 0 slots for extra call arguments
popa .16                                ; restore all registers
jal $zero $$reta i0                     ; return from call
DIFF------------------------------
.program:
.18                                     ; --- start of function: abi_encode_52 ---
pusha .18                               ; save all registers
move $$locbase $sp                      ; save locals base register for function abi_encode_52
cfei i0                                 ; allocate 0 bytes for locals and 0 slots for call arguments
move $r453 $$arg0                       ; save argument 0 (self)
move $r454 $$arg1                       ; save argument 1 (buffer)
move $r455 $$arg2                       ; save argument 2 (__ret_value)
move $r456 $$reta                       ; save return address
.68
 lw $r457 $r453 i0                       ; load word
 lw $r457 $$arg0 i0                      ; load word
move $$arg0 $r457                       ; [call]: pass argument 0
 move $$arg1 $r454                       ; [call]: pass argument 1
 move $$arg2 $r455                       ; [call]: pass argument 2
 move $$arg1 $$arg1                      ; [call]: pass argument 1
 move $$arg2 $$arg2                      ; [call]: pass argument 2
fncall .6                               ; [call]: call abi_encode_5
 move $r458 $zero                        ; [call]: return unit value
 movi $r458 i0                           ; [call]: return unit value
ji  .19
.19
cfsi i0                                 ; free 0 bytes for locals and 0 slots for extra call arguments
move $$reta $r456                       ; restore return address
popa .18                                ; restore all registers
jal $zero $$reta i0                     ; return from call
DIFF------------------------------
.program:
.18                                     ; --- start of function: abi_encode_52 ---
pusha .18                               ; save all registers
move $$locbase $sp                      ; save locals base register for function abi_encode_52
move $r456 $$reta                       ; save return address
.68
lw $r457 $$arg0 i0                      ; load word
move $$arg0 $r457                       ; [call]: pass argument 0
fncall .6                               ; [call]: call abi_encode_5
.19
move $$reta $r456                       ; restore return address
popa .18                                ; restore all registers
jal $zero $$reta i0                     ; return from call
DIFF------------------------------
.program:
.18                                     ; --- start of function: abi_encode_52 ---
pusha .18                               ; save all registers
move $$locbase $sp                      ; save locals base register for function abi_encode_52
move $r456 $$reta                       ; save return address
.68
lw $r457 $$arg0 i0                      ; load word
move $$arg0 $r457                       ; [call]: pass argument 0
fncall .6                               ; [call]: call abi_encode_5
.19
move $$reta $r456                       ; restore return address
popa .18                                ; restore all registers
jal $zero $$reta i0                     ; return from call
DIFF------------------------------
.program:
.18                                     ; --- start of function: abi_encode_52 ---
pusha .18                               ; save all registers
move $$locbase $sp                      ; save locals base register for function abi_encode_52
move $r456 $$reta                       ; save return address
.68
lw $r457 $$arg0 i0                      ; load word
move $$arg0 $r457                       ; [call]: pass argument 0
fncall .6                               ; [call]: call abi_encode_5
.19
move $$reta $r456                       ; restore return address
popa .18                                ; restore all registers
jal $zero $$reta i0                     ; return from call
DIFF------------------------------
.program:
.20                                     ; --- start of function: local_log_53 ---
pusha .20                               ; save all registers
move $$locbase $sp                      ; save locals base register for function local_log_53
cfei i120                               ; allocate 120 bytes for locals and 0 slots for call arguments
move $r459 $$arg0                       ; save argument 0 (item)
move $r460 $$reta                       ; save return address
.69
addi $r461 $$locbase i32                ; get offset to local __ptr { u64, ( { u64 } | () ) }
 mcpi $r461 $r459 i16                    ; copy memory
 mcpi $r461 $$arg0 i16                   ; copy memory
addi $r462 $$locbase i32                ; get offset to local __ptr { u64, ( { u64 } | () ) }
 jnzi $zero .70
 
ji  .71
.71
addi $r463 $$locbase i72                ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r463                       ; [call]: pass argument 0
fncall .8                               ; [call]: call new_6
 move $r464 $zero                        ; [call]: return unit value
 movi $r464 i0                           ; [call]: return unit value
addi $r465 $$locbase i32                ; get offset to local __ptr { u64, ( { u64 } | () ) }
lw $r466 $$locbase i4                   ; load word
eq $r467 $r466 $zero
jnzi $r467 .72
ji  .73
.73
addi $r468 $$locbase i32                ; get offset to local __ptr { u64, ( { u64 } | () ) }
lw $r469 $$locbase i4                   ; load word
eq $r470 $r469 $one
jnzi $r470 .74
ji  .75
.75
load $r471 data_NonConfigurable_5       ; load constant from data section
rvrt $r471
.74
addi $r472 $$locbase i72                ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r473 $$locbase i48                ; get offset to local __ptr { { ptr, u64, u64 } }
 move $$arg0 $one                        ; [call]: pass argument 0
 movi $$arg0 i1                          ; [call]: pass argument 0
move $$arg1 $r472                       ; [call]: pass argument 1
move $$arg2 $r473                       ; [call]: pass argument 2
fncall .6                               ; [call]: call abi_encode_5
 move $r474 $zero                        ; [call]: return unit value
 movi $r474 i0                           ; [call]: return unit value
addi $r475 $$locbase i48                ; get offset to local __ptr { { ptr, u64, u64 } }
move $r476 $r475                        ; move parameter from branch to block argument
ji  .76
.72
addi $r477 $$locbase i32                ; get offset to local __ptr { u64, ( { u64 } | () ) }
addi $r478 $r477 i8                     ; get offset to aggregate element
addi $r479 $$locbase i72                ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r480 $$locbase i96                ; get offset to local __ptr { { ptr, u64, u64 } }
 move $$arg0 $zero                       ; [call]: pass argument 0
 movi $$arg0 i0                          ; [call]: pass argument 0
move $$arg1 $r479                       ; [call]: pass argument 1
move $$arg2 $r480                       ; [call]: pass argument 2
fncall .6                               ; [call]: call abi_encode_5
 move $r481 $zero                        ; [call]: return unit value
 movi $r481 i0                           ; [call]: return unit value
addi $r482 $$locbase i96                ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r483 $$locbase i48                ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r478                       ; [call]: pass argument 0
move $$arg1 $r482                       ; [call]: pass argument 1
move $$arg2 $r483                       ; [call]: pass argument 2
fncall .18                              ; [call]: call abi_encode_52
 move $r484 $zero                        ; [call]: return unit value
 movi $r484 i0                           ; [call]: return unit value
addi $r485 $$locbase i48                ; get offset to local __ptr { { ptr, u64, u64 } }
move $r476 $r485                        ; move parameter from branch to block argument
ji  .76
.76
move $r488 $r476                        ; move parameter from branch to block argument
addi $r489 $$locbase i16                ; get offset to local __ptr slice
 move $$arg0 $r488                       ; [call]: pass argument 0
 move $$arg0 $r476                       ; [call]: pass argument 0
move $$arg1 $r489                       ; [call]: pass argument 1
fncall .10                              ; [call]: call as_raw_slice_7
 move $r490 $zero                        ; [call]: return unit value
 movi $r490 i0                           ; [call]: return unit value
ji  .77
.70
sw $$locbase $r462 i0                   ; store word
addi $r491 $$locbase i8                 ; get offset to aggregate element
movi $r492 i16                          ; initialize constant into register
sw $$locbase $r492 i1                   ; store word
addi $r493 $$locbase i16                ; get offset to local __ptr slice
mcpi $r493 $$locbase i16                ; copy memory
ji  .77
.77
addi $r494 $$locbase i16                ; get offset to local __ptr slice
load $r495 data_NonConfigurable_6       ; load constant from data section
lw $r496 $$locbase i2                   ; load slice pointer for logging data
lw $r497 $$locbase i3                   ; load slice size for logging data
logd $zero $r495 $r496 $r497            ; log slice
ji  .21
.21
cfsi i120                               ; free 120 bytes for locals and 0 slots for extra call arguments
move $$reta $r460                       ; restore return address
popa .20                                ; restore all registers
jal $zero $$reta i0                     ; return from call
DIFF------------------------------
.program:
.20                                     ; --- start of function: local_log_53 ---
pusha .20                               ; save all registers
move $$locbase $sp                      ; save locals base register for function local_log_53
cfei i120                               ; allocate 120 bytes for locals and 0 slots for call arguments
move $r460 $$reta                       ; save return address
.69
addi $r461 $$locbase i32                ; get offset to local __ptr { u64, ( { u64 } | () ) }
mcpi $r461 $$arg0 i16                   ; copy memory
.71
addi $r463 $$locbase i72                ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r463                       ; [call]: pass argument 0
fncall .8                               ; [call]: call new_6
lw $r466 $$locbase i4                   ; load word
eq $r467 $r466 $zero
jnzi $r467 .72
.73
lw $r469 $$locbase i4                   ; load word
eq $r470 $r469 $one
jnzi $r470 .74
.75
load $r471 data_NonConfigurable_5       ; load constant from data section
rvrt $r471
.74
addi $r472 $$locbase i72                ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r473 $$locbase i48                ; get offset to local __ptr { { ptr, u64, u64 } }
movi $$arg0 i1                          ; [call]: pass argument 0
move $$arg1 $r472                       ; [call]: pass argument 1
move $$arg2 $r473                       ; [call]: pass argument 2
fncall .6                               ; [call]: call abi_encode_5
addi $r475 $$locbase i48                ; get offset to local __ptr { { ptr, u64, u64 } }
move $r476 $r475                        ; move parameter from branch to block argument
ji  .76
.72
addi $r477 $$locbase i32                ; get offset to local __ptr { u64, ( { u64 } | () ) }
addi $r478 $r477 i8                     ; get offset to aggregate element
addi $r479 $$locbase i72                ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r480 $$locbase i96                ; get offset to local __ptr { { ptr, u64, u64 } }
movi $$arg0 i0                          ; [call]: pass argument 0
move $$arg1 $r479                       ; [call]: pass argument 1
move $$arg2 $r480                       ; [call]: pass argument 2
fncall .6                               ; [call]: call abi_encode_5
addi $r482 $$locbase i96                ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r483 $$locbase i48                ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r478                       ; [call]: pass argument 0
move $$arg1 $r482                       ; [call]: pass argument 1
move $$arg2 $r483                       ; [call]: pass argument 2
fncall .18                              ; [call]: call abi_encode_52
addi $r485 $$locbase i48                ; get offset to local __ptr { { ptr, u64, u64 } }
move $r476 $r485                        ; move parameter from branch to block argument
.76
addi $r489 $$locbase i16                ; get offset to local __ptr slice
move $$arg0 $r476                       ; [call]: pass argument 0
move $$arg1 $r489                       ; [call]: pass argument 1
fncall .10                              ; [call]: call as_raw_slice_7
.77
load $r495 data_NonConfigurable_6       ; load constant from data section
lw $r496 $$locbase i2                   ; load slice pointer for logging data
lw $r497 $$locbase i3                   ; load slice size for logging data
logd $zero $r495 $r496 $r497            ; log slice
.21
cfsi i120                               ; free 120 bytes for locals and 0 slots for extra call arguments
move $$reta $r460                       ; restore return address
popa .20                                ; restore all registers
jal $zero $$reta i0                     ; return from call
DIFF------------------------------
.program:
.20                                     ; --- start of function: local_log_53 ---
pusha .20                               ; save all registers
move $$locbase $sp                      ; save locals base register for function local_log_53
cfei i120                               ; allocate 120 bytes for locals and 0 slots for call arguments
move $r460 $$reta                       ; save return address
.69
addi $r461 $$locbase i32                ; get offset to local __ptr { u64, ( { u64 } | () ) }
mcpi $r461 $$arg0 i16                   ; copy memory
.71
addi $r463 $$locbase i72                ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r463                       ; [call]: pass argument 0
fncall .8                               ; [call]: call new_6
lw $r466 $$locbase i4                   ; load word
eq $r467 $r466 $zero
jnzi $r467 .72
.73
lw $r469 $$locbase i4                   ; load word
eq $r470 $r469 $one
jnzi $r470 .74
.75
load $r471 data_NonConfigurable_5       ; load constant from data section
rvrt $r471
.74
addi $r472 $$locbase i72                ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r473 $$locbase i48                ; get offset to local __ptr { { ptr, u64, u64 } }
movi $$arg0 i1                          ; [call]: pass argument 0
move $$arg1 $r472                       ; [call]: pass argument 1
move $$arg2 $r473                       ; [call]: pass argument 2
fncall .6                               ; [call]: call abi_encode_5
addi $r475 $$locbase i48                ; get offset to local __ptr { { ptr, u64, u64 } }
move $r476 $r475                        ; move parameter from branch to block argument
ji  .76
.72
addi $r477 $$locbase i32                ; get offset to local __ptr { u64, ( { u64 } | () ) }
addi $r478 $r477 i8                     ; get offset to aggregate element
addi $r479 $$locbase i72                ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r480 $$locbase i96                ; get offset to local __ptr { { ptr, u64, u64 } }
movi $$arg0 i0                          ; [call]: pass argument 0
move $$arg1 $r479                       ; [call]: pass argument 1
move $$arg2 $r480                       ; [call]: pass argument 2
fncall .6                               ; [call]: call abi_encode_5
addi $r482 $$locbase i96                ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r483 $$locbase i48                ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r478                       ; [call]: pass argument 0
move $$arg1 $r482                       ; [call]: pass argument 1
move $$arg2 $r483                       ; [call]: pass argument 2
fncall .18                              ; [call]: call abi_encode_52
addi $r485 $$locbase i48                ; get offset to local __ptr { { ptr, u64, u64 } }
move $r476 $r485                        ; move parameter from branch to block argument
.76
addi $r489 $$locbase i16                ; get offset to local __ptr slice
move $$arg0 $r476                       ; [call]: pass argument 0
move $$arg1 $r489                       ; [call]: pass argument 1
fncall .10                              ; [call]: call as_raw_slice_7
.77
load $r495 data_NonConfigurable_6       ; load constant from data section
lw $r496 $$locbase i2                   ; load slice pointer for logging data
lw $r497 $$locbase i3                   ; load slice size for logging data
logd $zero $r495 $r496 $r497            ; log slice
.21
cfsi i120                               ; free 120 bytes for locals and 0 slots for extra call arguments
move $$reta $r460                       ; restore return address
popa .20                                ; restore all registers
jal $zero $$reta i0                     ; return from call
DIFF------------------------------
.program:
.20                                     ; --- start of function: local_log_53 ---
pusha .20                               ; save all registers
move $$locbase $sp                      ; save locals base register for function local_log_53
cfei i120                               ; allocate 120 bytes for locals and 0 slots for call arguments
move $r460 $$reta                       ; save return address
.69
addi $r461 $$locbase i32                ; get offset to local __ptr { u64, ( { u64 } | () ) }
mcpi $r461 $$arg0 i16                   ; copy memory
.71
addi $r463 $$locbase i72                ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r463                       ; [call]: pass argument 0
fncall .8                               ; [call]: call new_6
lw $r466 $$locbase i4                   ; load word
eq $r467 $r466 $zero
jnzi $r467 .72
.73
lw $r469 $$locbase i4                   ; load word
eq $r470 $r469 $one
jnzi $r470 .74
.75
load $r471 data_NonConfigurable_5       ; load constant from data section
rvrt $r471
.74
addi $r472 $$locbase i72                ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r473 $$locbase i48                ; get offset to local __ptr { { ptr, u64, u64 } }
movi $$arg0 i1                          ; [call]: pass argument 0
move $$arg1 $r472                       ; [call]: pass argument 1
move $$arg2 $r473                       ; [call]: pass argument 2
fncall .6                               ; [call]: call abi_encode_5
addi $r475 $$locbase i48                ; get offset to local __ptr { { ptr, u64, u64 } }
move $r476 $r475                        ; move parameter from branch to block argument
ji  .76
.72
addi $r477 $$locbase i32                ; get offset to local __ptr { u64, ( { u64 } | () ) }
addi $r478 $r477 i8                     ; get offset to aggregate element
addi $r479 $$locbase i72                ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r480 $$locbase i96                ; get offset to local __ptr { { ptr, u64, u64 } }
movi $$arg0 i0                          ; [call]: pass argument 0
move $$arg1 $r479                       ; [call]: pass argument 1
move $$arg2 $r480                       ; [call]: pass argument 2
fncall .6                               ; [call]: call abi_encode_5
addi $r482 $$locbase i96                ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r483 $$locbase i48                ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r478                       ; [call]: pass argument 0
move $$arg1 $r482                       ; [call]: pass argument 1
move $$arg2 $r483                       ; [call]: pass argument 2
fncall .18                              ; [call]: call abi_encode_52
addi $r485 $$locbase i48                ; get offset to local __ptr { { ptr, u64, u64 } }
move $r476 $r485                        ; move parameter from branch to block argument
.76
addi $r489 $$locbase i16                ; get offset to local __ptr slice
move $$arg0 $r476                       ; [call]: pass argument 0
move $$arg1 $r489                       ; [call]: pass argument 1
fncall .10                              ; [call]: call as_raw_slice_7
.77
load $r495 data_NonConfigurable_6       ; load constant from data section
lw $r496 $$locbase i2                   ; load slice pointer for logging data
lw $r497 $$locbase i3                   ; load slice size for logging data
logd $zero $r495 $r496 $r497            ; log slice
.21
cfsi i120                               ; free 120 bytes for locals and 0 slots for extra call arguments
move $$reta $r460                       ; restore return address
popa .20                                ; restore all registers
jal $zero $$reta i0                     ; return from call
DIFF------------------------------
.program:
.22                                     ; --- start of function: local_log_60 ---
pusha .22                               ; save all registers
move $$locbase $sp                      ; save locals base register for function local_log_60
cfei i64                                ; allocate 64 bytes for locals and 0 slots for call arguments
move $r498 $$arg0                       ; save argument 0 (item)
move $r499 $$reta                       ; save return address
.78
addi $r500 $$locbase i40                ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r500                       ; [call]: pass argument 0
fncall .8                               ; [call]: call new_6
 move $r501 $zero                        ; [call]: return unit value
 movi $r501 i0                           ; [call]: return unit value
addi $r502 $$locbase i40                ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r503 $$locbase i16                ; get offset to local __ptr { { ptr, u64, u64 } }
movi $r504 i77                          ; initialize constant into register
 move $$arg0 $r504                       ; [call]: pass argument 0
 movi $$arg0 i77                         ; [call]: pass argument 0
move $$arg1 $r502                       ; [call]: pass argument 1
move $$arg2 $r503                       ; [call]: pass argument 2
fncall .6                               ; [call]: call abi_encode_5
 move $r505 $zero                        ; [call]: return unit value
 movi $r505 i0                           ; [call]: return unit value
addi $r506 $$locbase i16                ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r506                       ; [call]: pass argument 0
move $$arg1 $$locbase                   ; [call]: pass argument 1
fncall .10                              ; [call]: call as_raw_slice_7
 move $r507 $zero                        ; [call]: return unit value
 movi $r507 i0                           ; [call]: return unit value
load $r508 data_NonConfigurable_7       ; load constant from data section
lw $r509 $$locbase i0                   ; load slice pointer for logging data
lw $r510 $$locbase i1                   ; load slice size for logging data
logd $zero $r508 $r509 $r510            ; log slice
ji  .23
.23
cfsi i64                                ; free 64 bytes for locals and 0 slots for extra call arguments
move $$reta $r499                       ; restore return address
popa .22                                ; restore all registers
jal $zero $$reta i0                     ; return from call
DIFF------------------------------
.program:
.22                                     ; --- start of function: local_log_60 ---
pusha .22                               ; save all registers
move $$locbase $sp                      ; save locals base register for function local_log_60
cfei i64                                ; allocate 64 bytes for locals and 0 slots for call arguments
move $r499 $$reta                       ; save return address
.78
addi $r500 $$locbase i40                ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r500                       ; [call]: pass argument 0
fncall .8                               ; [call]: call new_6
addi $r502 $$locbase i40                ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r503 $$locbase i16                ; get offset to local __ptr { { ptr, u64, u64 } }
movi $$arg0 i77                         ; [call]: pass argument 0
move $$arg1 $r502                       ; [call]: pass argument 1
move $$arg2 $r503                       ; [call]: pass argument 2
fncall .6                               ; [call]: call abi_encode_5
addi $r506 $$locbase i16                ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r506                       ; [call]: pass argument 0
move $$arg1 $$locbase                   ; [call]: pass argument 1
fncall .10                              ; [call]: call as_raw_slice_7
load $r508 data_NonConfigurable_7       ; load constant from data section
lw $r509 $$locbase i0                   ; load slice pointer for logging data
lw $r510 $$locbase i1                   ; load slice size for logging data
logd $zero $r508 $r509 $r510            ; log slice
.23
cfsi i64                                ; free 64 bytes for locals and 0 slots for extra call arguments
move $$reta $r499                       ; restore return address
popa .22                                ; restore all registers
jal $zero $$reta i0                     ; return from call
DIFF------------------------------
.program:
.22                                     ; --- start of function: local_log_60 ---
pusha .22                               ; save all registers
move $$locbase $sp                      ; save locals base register for function local_log_60
cfei i64                                ; allocate 64 bytes for locals and 0 slots for call arguments
move $r499 $$reta                       ; save return address
.78
addi $r500 $$locbase i40                ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r500                       ; [call]: pass argument 0
fncall .8                               ; [call]: call new_6
addi $r502 $$locbase i40                ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r503 $$locbase i16                ; get offset to local __ptr { { ptr, u64, u64 } }
movi $$arg0 i77                         ; [call]: pass argument 0
move $$arg1 $r502                       ; [call]: pass argument 1
move $$arg2 $r503                       ; [call]: pass argument 2
fncall .6                               ; [call]: call abi_encode_5
addi $r506 $$locbase i16                ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r506                       ; [call]: pass argument 0
move $$arg1 $$locbase                   ; [call]: pass argument 1
fncall .10                              ; [call]: call as_raw_slice_7
load $r508 data_NonConfigurable_7       ; load constant from data section
lw $r509 $$locbase i0                   ; load slice pointer for logging data
lw $r510 $$locbase i1                   ; load slice size for logging data
logd $zero $r508 $r509 $r510            ; log slice
.23
cfsi i64                                ; free 64 bytes for locals and 0 slots for extra call arguments
move $$reta $r499                       ; restore return address
popa .22                                ; restore all registers
jal $zero $$reta i0                     ; return from call
DIFF------------------------------
.program:
.22                                     ; --- start of function: local_log_60 ---
pusha .22                               ; save all registers
move $$locbase $sp                      ; save locals base register for function local_log_60
cfei i64                                ; allocate 64 bytes for locals and 0 slots for call arguments
move $r499 $$reta                       ; save return address
.78
addi $r500 $$locbase i40                ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r500                       ; [call]: pass argument 0
fncall .8                               ; [call]: call new_6
addi $r502 $$locbase i40                ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r503 $$locbase i16                ; get offset to local __ptr { { ptr, u64, u64 } }
movi $$arg0 i77                         ; [call]: pass argument 0
move $$arg1 $r502                       ; [call]: pass argument 1
move $$arg2 $r503                       ; [call]: pass argument 2
fncall .6                               ; [call]: call abi_encode_5
addi $r506 $$locbase i16                ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r506                       ; [call]: pass argument 0
move $$arg1 $$locbase                   ; [call]: pass argument 1
fncall .10                              ; [call]: call as_raw_slice_7
load $r508 data_NonConfigurable_7       ; load constant from data section
lw $r509 $$locbase i0                   ; load slice pointer for logging data
lw $r510 $$locbase i1                   ; load slice size for logging data
logd $zero $r508 $r509 $r510            ; log slice
.23
cfsi i64                                ; free 64 bytes for locals and 0 slots for extra call arguments
move $$reta $r499                       ; restore return address
popa .22                                ; restore all registers
jal $zero $$reta i0                     ; return from call
warning
  --> test/src/e2e_vm_tests/test_programs/should_pass/language/logging/src/main.sw:27:5
   |
25 | 
26 | enum F {
27 |     A: ()
   |     - Enum variant A is never constructed.
28 | }
29 | 
   |
____

warning
  --> test/src/e2e_vm_tests/test_programs/should_pass/language/logging/src/main.sw:26:6
   |
24 | }
25 | 
26 | enum F {
   |      - This enum is never used.
27 |     A: ()
28 | }
   |
____

warning
  --> test/src/e2e_vm_tests/test_programs/should_pass/language/logging/src/main.sw:35:5
   |
33 |   impl AbiEncode for CustomAbiEncode {
34 |       fn is_encode_trivial() -> bool { false }
35 |       fn abi_encode(self, buffer: Buffer) -> Buffer {
   |  _____-
36 | |         77u64.abi_encode(buffer)
37 | |     }
   | |_____- This method is never called.
38 |   }
39 |   
   |
____

warning
  --> test/src/e2e_vm_tests/test_programs/should_pass/language/logging/src/main.sw:34:5
   |
32 | 
33 | impl AbiEncode for CustomAbiEncode {
34 |     fn is_encode_trivial() -> bool { false }
   |     ---------------------------------------- This method is never called.
35 |     fn abi_encode(self, buffer: Buffer) -> Buffer {
36 |         77u64.abi_encode(buffer)
   |
____

warning
  --> test/src/e2e_vm_tests/test_programs/should_pass/language/logging/src/main.sw:40:8
   |
38 | }
39 | 
40 | struct NotAutoEncodable {
   |        ---------------- This struct is never used.
41 |     p: raw_ptr
42 | }
   |
____

warning
  --> test/src/e2e_vm_tests/test_programs/should_pass/language/logging/src/main.sw:41:5
   |
39 | 
40 | struct NotAutoEncodable {
41 |     p: raw_ptr
   |     - This struct field is never accessed.
42 | }
43 | 
   |
____

  Compiled script "logging" with 6 warnings.
<<<<<<< HEAD
    Finished release [optimized + fuel] target(s) [2.792 KB] in ???
=======
    Finished release [optimized + fuel] target(s) [2.784 KB] in ???
>>>>>>> 0f3fd4cde (replave move by movi when possible on asm optimisation)

> forc test --path test/src/e2e_vm_tests/test_programs/should_pass/language/logging --release
exit status: 0
output:
    Building test/src/e2e_vm_tests/test_programs/should_pass/language/logging
   Compiling library std (test/src/e2e_vm_tests/reduced_std_libs/sway-lib-std-vec)
DIFF------------------------------
.program:
DIFF------------------------------
.program:
   Compiling script logging (test/src/e2e_vm_tests/test_programs/should_pass/language/logging)
DIFF------------------------------
.program:
DIFF------------------------------
.program:
DIFF------------------------------
.program:
.0                                      ; --- start of function: __entry ---
move $$locbase $sp                      ; save locals base register for function __entry
cfei i8                                 ; allocate 8 bytes for locals and 0 slots for call arguments
.26
fncall .2                               ; [call]: call main_0
move $r1 $$retv                         ; [call]: copy the return value
 sw $$locbase $r1 i0                     ; store word
 sw $$locbase $$retv i0                  ; store word
movi $r2 i8                             ; initialize constant into register
retd $$locbase $r2
DIFF------------------------------
.program:
.0                                      ; --- start of function: __entry ---
move $$locbase $sp                      ; save locals base register for function __entry
cfei i8                                 ; allocate 8 bytes for locals and 0 slots for call arguments
.26
fncall .2                               ; [call]: call main_0
sw $$locbase $$retv i0                  ; store word
movi $r2 i8                             ; initialize constant into register
retd $$locbase $r2
DIFF------------------------------
.program:
.0                                      ; --- start of function: __entry ---
move $$locbase $sp                      ; save locals base register for function __entry
cfei i8                                 ; allocate 8 bytes for locals and 0 slots for call arguments
.26
fncall .2                               ; [call]: call main_0
sw $$locbase $$retv i0                  ; store word
movi $r2 i8                             ; initialize constant into register
retd $$locbase $r2
DIFF------------------------------
.program:
.0                                      ; --- start of function: __entry ---
move $$locbase $sp                      ; save locals base register for function __entry
cfei i8                                 ; allocate 8 bytes for locals and 0 slots for call arguments
.26
fncall .2                               ; [call]: call main_0
sw $$locbase $$retv i0                  ; store word
movi $r2 i8                             ; initialize constant into register
retd $$locbase $r2
DIFF------------------------------
.program:
.24                                     ; --- start of function: call_main ---
move $$locbase $sp                      ; save locals base register for function call_main
cfei i0                                 ; allocate 0 bytes for locals and 0 slots for call arguments
.81
fncall .2                               ; [call]: call main_0
move $r512 $$retv                       ; [call]: copy the return value
ret $zero                               ; return unit as zero
DIFF------------------------------
.program:
.24                                     ; --- start of function: call_main ---
move $$locbase $sp                      ; save locals base register for function call_main
.81
fncall .2                               ; [call]: call main_0
ret $zero                               ; return unit as zero
DIFF------------------------------
.program:
.24                                     ; --- start of function: call_main ---
move $$locbase $sp                      ; save locals base register for function call_main
.81
fncall .2                               ; [call]: call main_0
ret $zero                               ; return unit as zero
DIFF------------------------------
.program:
.24                                     ; --- start of function: call_main ---
move $$locbase $sp                      ; save locals base register for function call_main
.81
fncall .2                               ; [call]: call main_0
ret $zero                               ; return unit as zero
DIFF------------------------------
.program:
.2                                      ; --- start of function: main_0 ---
pusha .2                                ; save all registers
move $$locbase $sp                      ; save locals base register for function main_0
cfei i224                               ; allocate 224 bytes for locals and 0 slots for call arguments
move $r3 $$reta                         ; save return address
.27
load $r4 data_NonConfigurable_0         ; get local constant
 move $$arg0 $zero                       ; [call]: pass argument 0
 movi $$arg0 i0                          ; [call]: pass argument 0
fncall .4                               ; [call]: call local_log_1
 move $r5 $zero                          ; [call]: return unit value
 movi $r5 i0                             ; [call]: return unit value
addi $r6 $$locbase i200                 ; get offset to local __ptr { { ptr, u64 }, u64 }
addi $r7 $$locbase i32                  ; get offset to local __ptr { ptr, u64 }
movi $r8 i0                             ; get total allocation size in bytes
 aloc $r8                                ; allocate memory
 aloc $zero                              ; allocate memory
move $r9 $hp                            ; save allocated memory pointer
 sw $$locbase $r9 i4                     ; store word
 sw $$locbase $hp i4                     ; store word
addi $r10 $r7 i8                        ; get offset to aggregate element
sw $$locbase $zero i5                   ; store word
mcpi $r6 $r7 i16                        ; copy memory
addi $r11 $r6 i16                       ; get offset to aggregate element
sw $$locbase $zero i27                  ; store word
addi $r12 $$locbase i200                ; get offset to local __ptr { { ptr, u64 }, u64 }
move $$arg0 $r12                        ; [call]: pass argument 0
 move $$arg1 $one                        ; [call]: pass argument 1
 movi $$arg1 i1                          ; [call]: pass argument 1
fncall .12                              ; [call]: call push_11
 move $r13 $zero                         ; [call]: return unit value
 movi $r13 i0                            ; [call]: return unit value
addi $r14 $$locbase i200                ; get offset to local __ptr { { ptr, u64 }, u64 }
move $$arg0 $r14                        ; [call]: pass argument 0
movi $r15 i2                            ; initialize constant into register
 move $$arg1 $r15                        ; [call]: pass argument 1
 movi $$arg1 i2                          ; [call]: pass argument 1
fncall .12                              ; [call]: call push_11
 move $r16 $zero                         ; [call]: return unit value
 movi $r16 i0                            ; [call]: return unit value
addi $r17 $$locbase i200                ; get offset to local __ptr { { ptr, u64 }, u64 }
move $$arg0 $r17                        ; [call]: pass argument 0
movi $r18 i3                            ; initialize constant into register
 move $$arg1 $r18                        ; [call]: pass argument 1
 movi $$arg1 i3                          ; [call]: pass argument 1
fncall .12                              ; [call]: call push_11
 move $r19 $zero                         ; [call]: return unit value
 movi $r19 i0                            ; [call]: return unit value
addi $r20 $$locbase i56                 ; get offset to local __ptr { u64, u64, u64, u8, { { ptr, u64 }, u64 }, slice, u256 }
addi $r21 $$locbase i200                ; get offset to local __ptr { { ptr, u64 }, u64 }
addr $r22 data_NonConfigurable_1        ; get __const_global's address in data section
sw $$locbase $r22 i0                    ; store word
addi $r23 $$locbase i8                  ; get offset to aggregate element
movi $r24 i4                            ; initialize constant into register
sw $$locbase $r24 i1                    ; store word
addi $r25 $$locbase i16                 ; get offset to local __ptr slice
mcpi $r25 $$locbase i16                 ; copy memory
sw $$locbase $one i7                    ; store word
addi $r26 $r20 i8                       ; get offset to aggregate element
movi $r27 i2                            ; initialize constant into register
sw $$locbase $r27 i8                    ; store word
addi $r28 $r20 i16                      ; get offset to aggregate element
movi $r29 i3                            ; initialize constant into register
sw $$locbase $r29 i9                    ; store word
addi $r30 $r20 i24                      ; get offset to aggregate element
movi $r31 i4                            ; initialize constant into register
sb $r30 $r31 i0                         ; store byte
addi $r32 $r20 i32                      ; get offset to aggregate element
mcpi $r32 $r21 i24                      ; copy memory
addi $r33 $r20 i56                      ; get offset to aggregate element
mcpi $r33 $r25 i16                      ; copy memory
addi $r34 $r20 i72                      ; get offset to aggregate element
mcpi $r34 $r4 i32                       ; copy memory
addi $r35 $$locbase i56                 ; get offset to local __ptr { u64, u64, u64, u8, { { ptr, u64 }, u64 }, slice, u256 }
move $$arg0 $r35                        ; [call]: pass argument 0
fncall .14                              ; [call]: call local_log_21
 move $r36 $zero                         ; [call]: return unit value
 movi $r36 i0                            ; [call]: return unit value
addi $r37 $$locbase i160                ; get offset to local __ptr { u64 }
sw $$locbase $one i20                   ; store word
addi $r38 $$locbase i160                ; get offset to local __ptr { u64 }
move $$arg0 $r38                        ; [call]: pass argument 0
fncall .16                              ; [call]: call local_log_48
 move $r39 $zero                         ; [call]: return unit value
 movi $r39 i0                            ; [call]: return unit value
addi $r40 $$locbase i168                ; get offset to local __ptr { u64, ( { u64 } | () ) }
sw $$locbase $zero i21                  ; store word
addi $r41 $$locbase i48                 ; get offset to local __ptr { u64 }
sw $$locbase $one i6                    ; store word
addi $r42 $r40 i8                       ; get offset to aggregate element
mcpi $r42 $r41 i8                       ; copy memory
addi $r43 $$locbase i168                ; get offset to local __ptr { u64, ( { u64 } | () ) }
move $$arg0 $r43                        ; [call]: pass argument 0
fncall .20                              ; [call]: call local_log_53
 move $r44 $zero                         ; [call]: return unit value
 movi $r44 i0                            ; [call]: return unit value
addi $r45 $$locbase i184                ; get offset to local __ptr { u64, ( { u64 } | () ) }
sw $$locbase $one i23                   ; store word
addi $r46 $$locbase i184                ; get offset to local __ptr { u64, ( { u64 } | () ) }
move $$arg0 $r46                        ; [call]: pass argument 0
fncall .20                              ; [call]: call local_log_53
 move $r47 $zero                         ; [call]: return unit value
 movi $r47 i0                            ; [call]: return unit value
addi $r48 $$locbase i200                ; get offset to local __ptr {  }
move $$arg0 $r48                        ; [call]: pass argument 0
fncall .22                              ; [call]: call local_log_60
 move $r49 $zero                         ; [call]: return unit value
 move $$retv $one                        ; set return value
 movi $r49 i0                            ; [call]: return unit value
 movi $$retv i1                          ; set return value
ji  .3
.3
cfsi i224                               ; free 224 bytes for locals and 0 slots for extra call arguments
move $$reta $r3                         ; restore return address
popa .2                                 ; restore all registers
jal $zero $$reta i0                     ; return from call
DIFF------------------------------
.program:
.2                                      ; --- start of function: main_0 ---
pusha .2                                ; save all registers
move $$locbase $sp                      ; save locals base register for function main_0
cfei i224                               ; allocate 224 bytes for locals and 0 slots for call arguments
move $r3 $$reta                         ; save return address
.27
load $r4 data_NonConfigurable_0         ; get local constant
movi $$arg0 i0                          ; [call]: pass argument 0
fncall .4                               ; [call]: call local_log_1
addi $r6 $$locbase i200                 ; get offset to local __ptr { { ptr, u64 }, u64 }
addi $r7 $$locbase i32                  ; get offset to local __ptr { ptr, u64 }
aloc $zero                              ; allocate memory
sw $$locbase $hp i4                     ; store word
sw $$locbase $zero i5                   ; store word
mcpi $r6 $r7 i16                        ; copy memory
sw $$locbase $zero i27                  ; store word
addi $r12 $$locbase i200                ; get offset to local __ptr { { ptr, u64 }, u64 }
move $$arg0 $r12                        ; [call]: pass argument 0
movi $$arg1 i1                          ; [call]: pass argument 1
fncall .12                              ; [call]: call push_11
addi $r14 $$locbase i200                ; get offset to local __ptr { { ptr, u64 }, u64 }
move $$arg0 $r14                        ; [call]: pass argument 0
movi $$arg1 i2                          ; [call]: pass argument 1
fncall .12                              ; [call]: call push_11
addi $r17 $$locbase i200                ; get offset to local __ptr { { ptr, u64 }, u64 }
move $$arg0 $r17                        ; [call]: pass argument 0
movi $$arg1 i3                          ; [call]: pass argument 1
fncall .12                              ; [call]: call push_11
addi $r20 $$locbase i56                 ; get offset to local __ptr { u64, u64, u64, u8, { { ptr, u64 }, u64 }, slice, u256 }
addi $r21 $$locbase i200                ; get offset to local __ptr { { ptr, u64 }, u64 }
addr $r22 data_NonConfigurable_1        ; get __const_global's address in data section
sw $$locbase $r22 i0                    ; store word
movi $r24 i4                            ; initialize constant into register
sw $$locbase $r24 i1                    ; store word
addi $r25 $$locbase i16                 ; get offset to local __ptr slice
mcpi $r25 $$locbase i16                 ; copy memory
sw $$locbase $one i7                    ; store word
movi $r27 i2                            ; initialize constant into register
sw $$locbase $r27 i8                    ; store word
movi $r29 i3                            ; initialize constant into register
sw $$locbase $r29 i9                    ; store word
addi $r30 $r20 i24                      ; get offset to aggregate element
movi $r31 i4                            ; initialize constant into register
sb $r30 $r31 i0                         ; store byte
addi $r32 $r20 i32                      ; get offset to aggregate element
mcpi $r32 $r21 i24                      ; copy memory
addi $r33 $r20 i56                      ; get offset to aggregate element
mcpi $r33 $r25 i16                      ; copy memory
addi $r34 $r20 i72                      ; get offset to aggregate element
mcpi $r34 $r4 i32                       ; copy memory
addi $r35 $$locbase i56                 ; get offset to local __ptr { u64, u64, u64, u8, { { ptr, u64 }, u64 }, slice, u256 }
move $$arg0 $r35                        ; [call]: pass argument 0
fncall .14                              ; [call]: call local_log_21
sw $$locbase $one i20                   ; store word
addi $r38 $$locbase i160                ; get offset to local __ptr { u64 }
move $$arg0 $r38                        ; [call]: pass argument 0
fncall .16                              ; [call]: call local_log_48
addi $r40 $$locbase i168                ; get offset to local __ptr { u64, ( { u64 } | () ) }
sw $$locbase $zero i21                  ; store word
addi $r41 $$locbase i48                 ; get offset to local __ptr { u64 }
sw $$locbase $one i6                    ; store word
addi $r42 $r40 i8                       ; get offset to aggregate element
mcpi $r42 $r41 i8                       ; copy memory
addi $r43 $$locbase i168                ; get offset to local __ptr { u64, ( { u64 } | () ) }
move $$arg0 $r43                        ; [call]: pass argument 0
fncall .20                              ; [call]: call local_log_53
sw $$locbase $one i23                   ; store word
addi $r46 $$locbase i184                ; get offset to local __ptr { u64, ( { u64 } | () ) }
move $$arg0 $r46                        ; [call]: pass argument 0
fncall .20                              ; [call]: call local_log_53
addi $r48 $$locbase i200                ; get offset to local __ptr {  }
move $$arg0 $r48                        ; [call]: pass argument 0
fncall .22                              ; [call]: call local_log_60
movi $$retv i1                          ; set return value
.3
cfsi i224                               ; free 224 bytes for locals and 0 slots for extra call arguments
move $$reta $r3                         ; restore return address
popa .2                                 ; restore all registers
jal $zero $$reta i0                     ; return from call
DIFF------------------------------
.program:
.2                                      ; --- start of function: main_0 ---
pusha .2                                ; save all registers
move $$locbase $sp                      ; save locals base register for function main_0
cfei i224                               ; allocate 224 bytes for locals and 0 slots for call arguments
move $r3 $$reta                         ; save return address
.27
load $r4 data_NonConfigurable_0         ; get local constant
movi $$arg0 i0                          ; [call]: pass argument 0
fncall .4                               ; [call]: call local_log_1
addi $r6 $$locbase i200                 ; get offset to local __ptr { { ptr, u64 }, u64 }
addi $r7 $$locbase i32                  ; get offset to local __ptr { ptr, u64 }
aloc $zero                              ; allocate memory
sw $$locbase $hp i4                     ; store word
sw $$locbase $zero i5                   ; store word
mcpi $r6 $r7 i16                        ; copy memory
sw $$locbase $zero i27                  ; store word
addi $r12 $$locbase i200                ; get offset to local __ptr { { ptr, u64 }, u64 }
move $$arg0 $r12                        ; [call]: pass argument 0
movi $$arg1 i1                          ; [call]: pass argument 1
fncall .12                              ; [call]: call push_11
addi $r14 $$locbase i200                ; get offset to local __ptr { { ptr, u64 }, u64 }
move $$arg0 $r14                        ; [call]: pass argument 0
movi $$arg1 i2                          ; [call]: pass argument 1
fncall .12                              ; [call]: call push_11
addi $r17 $$locbase i200                ; get offset to local __ptr { { ptr, u64 }, u64 }
move $$arg0 $r17                        ; [call]: pass argument 0
movi $$arg1 i3                          ; [call]: pass argument 1
fncall .12                              ; [call]: call push_11
addi $r20 $$locbase i56                 ; get offset to local __ptr { u64, u64, u64, u8, { { ptr, u64 }, u64 }, slice, u256 }
addi $r21 $$locbase i200                ; get offset to local __ptr { { ptr, u64 }, u64 }
addr $r22 data_NonConfigurable_1        ; get __const_global's address in data section
sw $$locbase $r22 i0                    ; store word
movi $r24 i4                            ; initialize constant into register
sw $$locbase $r24 i1                    ; store word
addi $r25 $$locbase i16                 ; get offset to local __ptr slice
mcpi $r25 $$locbase i16                 ; copy memory
sw $$locbase $one i7                    ; store word
movi $r27 i2                            ; initialize constant into register
sw $$locbase $r27 i8                    ; store word
movi $r29 i3                            ; initialize constant into register
sw $$locbase $r29 i9                    ; store word
addi $r30 $r20 i24                      ; get offset to aggregate element
movi $r31 i4                            ; initialize constant into register
sb $r30 $r31 i0                         ; store byte
addi $r32 $r20 i32                      ; get offset to aggregate element
mcpi $r32 $r21 i24                      ; copy memory
addi $r33 $r20 i56                      ; get offset to aggregate element
mcpi $r33 $r25 i16                      ; copy memory
addi $r34 $r20 i72                      ; get offset to aggregate element
mcpi $r34 $r4 i32                       ; copy memory
addi $r35 $$locbase i56                 ; get offset to local __ptr { u64, u64, u64, u8, { { ptr, u64 }, u64 }, slice, u256 }
move $$arg0 $r35                        ; [call]: pass argument 0
fncall .14                              ; [call]: call local_log_21
sw $$locbase $one i20                   ; store word
addi $r38 $$locbase i160                ; get offset to local __ptr { u64 }
move $$arg0 $r38                        ; [call]: pass argument 0
fncall .16                              ; [call]: call local_log_48
addi $r40 $$locbase i168                ; get offset to local __ptr { u64, ( { u64 } | () ) }
sw $$locbase $zero i21                  ; store word
addi $r41 $$locbase i48                 ; get offset to local __ptr { u64 }
sw $$locbase $one i6                    ; store word
addi $r42 $r40 i8                       ; get offset to aggregate element
mcpi $r42 $r41 i8                       ; copy memory
addi $r43 $$locbase i168                ; get offset to local __ptr { u64, ( { u64 } | () ) }
move $$arg0 $r43                        ; [call]: pass argument 0
fncall .20                              ; [call]: call local_log_53
sw $$locbase $one i23                   ; store word
addi $r46 $$locbase i184                ; get offset to local __ptr { u64, ( { u64 } | () ) }
move $$arg0 $r46                        ; [call]: pass argument 0
fncall .20                              ; [call]: call local_log_53
addi $r48 $$locbase i200                ; get offset to local __ptr {  }
move $$arg0 $r48                        ; [call]: pass argument 0
fncall .22                              ; [call]: call local_log_60
movi $$retv i1                          ; set return value
.3
cfsi i224                               ; free 224 bytes for locals and 0 slots for extra call arguments
move $$reta $r3                         ; restore return address
popa .2                                 ; restore all registers
jal $zero $$reta i0                     ; return from call
DIFF------------------------------
.program:
.2                                      ; --- start of function: main_0 ---
pusha .2                                ; save all registers
move $$locbase $sp                      ; save locals base register for function main_0
cfei i224                               ; allocate 224 bytes for locals and 0 slots for call arguments
move $r3 $$reta                         ; save return address
.27
load $r4 data_NonConfigurable_0         ; get local constant
movi $$arg0 i0                          ; [call]: pass argument 0
fncall .4                               ; [call]: call local_log_1
addi $r6 $$locbase i200                 ; get offset to local __ptr { { ptr, u64 }, u64 }
addi $r7 $$locbase i32                  ; get offset to local __ptr { ptr, u64 }
aloc $zero                              ; allocate memory
sw $$locbase $hp i4                     ; store word
sw $$locbase $zero i5                   ; store word
mcpi $r6 $r7 i16                        ; copy memory
sw $$locbase $zero i27                  ; store word
addi $r12 $$locbase i200                ; get offset to local __ptr { { ptr, u64 }, u64 }
move $$arg0 $r12                        ; [call]: pass argument 0
movi $$arg1 i1                          ; [call]: pass argument 1
fncall .12                              ; [call]: call push_11
addi $r14 $$locbase i200                ; get offset to local __ptr { { ptr, u64 }, u64 }
move $$arg0 $r14                        ; [call]: pass argument 0
movi $$arg1 i2                          ; [call]: pass argument 1
fncall .12                              ; [call]: call push_11
addi $r17 $$locbase i200                ; get offset to local __ptr { { ptr, u64 }, u64 }
move $$arg0 $r17                        ; [call]: pass argument 0
movi $$arg1 i3                          ; [call]: pass argument 1
fncall .12                              ; [call]: call push_11
addi $r20 $$locbase i56                 ; get offset to local __ptr { u64, u64, u64, u8, { { ptr, u64 }, u64 }, slice, u256 }
addi $r21 $$locbase i200                ; get offset to local __ptr { { ptr, u64 }, u64 }
addr $r22 data_NonConfigurable_1        ; get __const_global's address in data section
sw $$locbase $r22 i0                    ; store word
movi $r24 i4                            ; initialize constant into register
sw $$locbase $r24 i1                    ; store word
addi $r25 $$locbase i16                 ; get offset to local __ptr slice
mcpi $r25 $$locbase i16                 ; copy memory
sw $$locbase $one i7                    ; store word
movi $r27 i2                            ; initialize constant into register
sw $$locbase $r27 i8                    ; store word
movi $r29 i3                            ; initialize constant into register
sw $$locbase $r29 i9                    ; store word
addi $r30 $r20 i24                      ; get offset to aggregate element
movi $r31 i4                            ; initialize constant into register
sb $r30 $r31 i0                         ; store byte
addi $r32 $r20 i32                      ; get offset to aggregate element
mcpi $r32 $r21 i24                      ; copy memory
addi $r33 $r20 i56                      ; get offset to aggregate element
mcpi $r33 $r25 i16                      ; copy memory
addi $r34 $r20 i72                      ; get offset to aggregate element
mcpi $r34 $r4 i32                       ; copy memory
addi $r35 $$locbase i56                 ; get offset to local __ptr { u64, u64, u64, u8, { { ptr, u64 }, u64 }, slice, u256 }
move $$arg0 $r35                        ; [call]: pass argument 0
fncall .14                              ; [call]: call local_log_21
sw $$locbase $one i20                   ; store word
addi $r38 $$locbase i160                ; get offset to local __ptr { u64 }
move $$arg0 $r38                        ; [call]: pass argument 0
fncall .16                              ; [call]: call local_log_48
addi $r40 $$locbase i168                ; get offset to local __ptr { u64, ( { u64 } | () ) }
sw $$locbase $zero i21                  ; store word
addi $r41 $$locbase i48                 ; get offset to local __ptr { u64 }
sw $$locbase $one i6                    ; store word
addi $r42 $r40 i8                       ; get offset to aggregate element
mcpi $r42 $r41 i8                       ; copy memory
addi $r43 $$locbase i168                ; get offset to local __ptr { u64, ( { u64 } | () ) }
move $$arg0 $r43                        ; [call]: pass argument 0
fncall .20                              ; [call]: call local_log_53
sw $$locbase $one i23                   ; store word
addi $r46 $$locbase i184                ; get offset to local __ptr { u64, ( { u64 } | () ) }
move $$arg0 $r46                        ; [call]: pass argument 0
fncall .20                              ; [call]: call local_log_53
addi $r48 $$locbase i200                ; get offset to local __ptr {  }
move $$arg0 $r48                        ; [call]: pass argument 0
fncall .22                              ; [call]: call local_log_60
movi $$retv i1                          ; set return value
.3
cfsi i224                               ; free 224 bytes for locals and 0 slots for extra call arguments
move $$reta $r3                         ; restore return address
popa .2                                 ; restore all registers
jal $zero $$reta i0                     ; return from call
DIFF------------------------------
.program:
.4                                      ; --- start of function: local_log_1 ---
pusha .4                                ; save all registers
move $$locbase $sp                      ; save locals base register for function local_log_1
cfei i40                                ; allocate 40 bytes for locals and 0 slots for call arguments
.28
addi $r51 $$locbase i32                 ; get offset to local __ptr u64
sw $$locbase $$arg0 i4                  ; store word
addi $r52 $$locbase i32                 ; get offset to local __ptr u64
sw $$locbase $r52 i0                    ; store word
addi $r53 $$locbase i8                  ; get offset to aggregate element
movi $r54 i8                            ; initialize constant into register
sw $$locbase $r54 i1                    ; store word
addi $r55 $$locbase i16                 ; get offset to local __ptr slice
mcpi $r55 $$locbase i16                 ; copy memory
load $r56 data_NonConfigurable_2        ; load constant from data section
lw $r57 $$locbase i2                    ; load slice pointer for logging data
lw $r58 $$locbase i3                    ; load slice size for logging data
logd $zero $r56 $r57 $r58               ; log slice
ji  .5
.5
cfsi i40                                ; free 40 bytes for locals and 0 slots for extra call arguments
popa .4                                 ; restore all registers
jal $zero $$reta i0                     ; return from call
DIFF------------------------------
.program:
.4                                      ; --- start of function: local_log_1 ---
pusha .4                                ; save all registers
move $$locbase $sp                      ; save locals base register for function local_log_1
cfei i40                                ; allocate 40 bytes for locals and 0 slots for call arguments
.28
sw $$locbase $$arg0 i4                  ; store word
addi $r52 $$locbase i32                 ; get offset to local __ptr u64
sw $$locbase $r52 i0                    ; store word
movi $r54 i8                            ; initialize constant into register
sw $$locbase $r54 i1                    ; store word
addi $r55 $$locbase i16                 ; get offset to local __ptr slice
mcpi $r55 $$locbase i16                 ; copy memory
load $r56 data_NonConfigurable_2        ; load constant from data section
lw $r57 $$locbase i2                    ; load slice pointer for logging data
lw $r58 $$locbase i3                    ; load slice size for logging data
logd $zero $r56 $r57 $r58               ; log slice
.5
cfsi i40                                ; free 40 bytes for locals and 0 slots for extra call arguments
popa .4                                 ; restore all registers
jal $zero $$reta i0                     ; return from call
DIFF------------------------------
.program:
.4                                      ; --- start of function: local_log_1 ---
pusha .4                                ; save all registers
move $$locbase $sp                      ; save locals base register for function local_log_1
cfei i40                                ; allocate 40 bytes for locals and 0 slots for call arguments
.28
sw $$locbase $$arg0 i4                  ; store word
addi $r52 $$locbase i32                 ; get offset to local __ptr u64
sw $$locbase $r52 i0                    ; store word
movi $r54 i8                            ; initialize constant into register
sw $$locbase $r54 i1                    ; store word
addi $r55 $$locbase i16                 ; get offset to local __ptr slice
mcpi $r55 $$locbase i16                 ; copy memory
load $r56 data_NonConfigurable_2        ; load constant from data section
lw $r57 $$locbase i2                    ; load slice pointer for logging data
lw $r58 $$locbase i3                    ; load slice size for logging data
logd $zero $r56 $r57 $r58               ; log slice
.5
cfsi i40                                ; free 40 bytes for locals and 0 slots for extra call arguments
popa .4                                 ; restore all registers
jal $zero $$reta i0                     ; return from call
DIFF------------------------------
.program:
.4                                      ; --- start of function: local_log_1 ---
pusha .4                                ; save all registers
move $$locbase $sp                      ; save locals base register for function local_log_1
cfei i40                                ; allocate 40 bytes for locals and 0 slots for call arguments
.28
sw $$locbase $$arg0 i4                  ; store word
addi $r52 $$locbase i32                 ; get offset to local __ptr u64
sw $$locbase $r52 i0                    ; store word
movi $r54 i8                            ; initialize constant into register
sw $$locbase $r54 i1                    ; store word
addi $r55 $$locbase i16                 ; get offset to local __ptr slice
mcpi $r55 $$locbase i16                 ; copy memory
load $r56 data_NonConfigurable_2        ; load constant from data section
lw $r57 $$locbase i2                    ; load slice pointer for logging data
lw $r58 $$locbase i3                    ; load slice size for logging data
logd $zero $r56 $r57 $r58               ; log slice
.5
cfsi i40                                ; free 40 bytes for locals and 0 slots for extra call arguments
popa .4                                 ; restore all registers
jal $zero $$reta i0                     ; return from call
DIFF------------------------------
.program:
.6                                      ; --- start of function: abi_encode_5 ---
pusha .6                                ; save all registers
move $$locbase $sp                      ; save locals base register for function abi_encode_5
cfei i144                               ; allocate 144 bytes for locals and 0 slots for call arguments
.29
addi $r60 $$locbase i120                ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r60 $$arg1 i24                    ; copy memory
addi $r61 $$locbase i96                 ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r62 $$locbase i120                ; get offset to local __ptr { { ptr, u64, u64 } }
move $r63 $r62                          ; return value from ASM block with return register buffer
 mcpi $$locbase $r63 i24                 ; copy memory
 mcpi $$locbase $r62 i24                 ; copy memory
addi $r64 $$locbase i48                 ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r64 $$locbase i24                 ; copy memory
lw $r65 $$locbase i6                    ; load word
addi $r66 $r64 i8                       ; get offset to aggregate element
lw $r67 $$locbase i7                    ; load word
addi $r68 $r64 i16                      ; get offset to aggregate element
lw $r69 $$locbase i8                    ; load word
movi $r70 i8                            ; initialize constant into register
add $r71 $r69 $r70
gt $r72 $r71 $r67
move $r73 $r65                          ; move parameter from branch to block argument
move $r74 $r67                          ; move parameter from branch to block argument
jnzi $r72 .30
ji  .31
.30
movi $r75 i2                            ; initialize constant into register
mul $r76 $r67 $r75
movi $r77 i8                            ; initialize constant into register
add $r78 $r76 $r77
aloc $r78
mcp $hp $r65 $r69
move $r79 $hp                           ; return value from ASM block with return register hp
 move $r73 $r79                          ; move parameter from branch to block argument
 move $r73 $hp                           ; move parameter from branch to block argument
move $r74 $r78                          ; move parameter from branch to block argument
ji  .31
.31
move $r83 $r73                          ; move parameter from branch to block argument
move $r85 $r74                          ; move parameter from branch to block argument
 add $r86 $r83 $r69
 add $r86 $r73 $r69
sw $r86 $$arg0 i0                       ; store word
addi $r87 $$locbase i72                 ; get offset to local __ptr { ptr, u64, u64 }
sw $$locbase $r83 i9                    ; store word
addi $r88 $r87 i8                       ; get offset to aggregate element
sw $$locbase $r85 i10                   ; store word
addi $r89 $r87 i16                      ; get offset to aggregate element
sw $$locbase $r71 i11                   ; store word
move $r90 $r87                          ; return value from ASM block with return register buffer
addi $r91 $$locbase i24                 ; get offset to local __ptr { ptr, u64, u64 }
 mcpi $r91 $r90 i24                      ; copy memory
 mcpi $r91 $r87 i24                      ; copy memory
mcpi $r61 $r91 i24                      ; copy memory
mcpi $$arg2 $r61 i24                    ; copy memory
ji  .7
.7
cfsi i144                               ; free 144 bytes for locals and 0 slots for extra call arguments
popa .6                                 ; restore all registers
jal $zero $$reta i0                     ; return from call
DIFF------------------------------
.program:
.6                                      ; --- start of function: abi_encode_5 ---
pusha .6                                ; save all registers
move $$locbase $sp                      ; save locals base register for function abi_encode_5
cfei i144                               ; allocate 144 bytes for locals and 0 slots for call arguments
.29
addi $r60 $$locbase i120                ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r60 $$arg1 i24                    ; copy memory
addi $r61 $$locbase i96                 ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r62 $$locbase i120                ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $$locbase $r62 i24                 ; copy memory
addi $r64 $$locbase i48                 ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r64 $$locbase i24                 ; copy memory
lw $r65 $$locbase i6                    ; load word
lw $r67 $$locbase i7                    ; load word
lw $r69 $$locbase i8                    ; load word
movi $r70 i8                            ; initialize constant into register
add $r71 $r69 $r70
gt $r72 $r71 $r67
move $r73 $r65                          ; move parameter from branch to block argument
move $r74 $r67                          ; move parameter from branch to block argument
jnzi $r72 .30
ji  .31
.30
movi $r75 i2                            ; initialize constant into register
mul $r76 $r67 $r75
movi $r77 i8                            ; initialize constant into register
add $r78 $r76 $r77
aloc $r78
mcp $hp $r65 $r69
move $r73 $hp                           ; move parameter from branch to block argument
move $r74 $r78                          ; move parameter from branch to block argument
.31
move $r83 $r73                          ; move parameter from branch to block argument
move $r85 $r74                          ; move parameter from branch to block argument
add $r86 $r73 $r69
sw $r86 $$arg0 i0                       ; store word
addi $r87 $$locbase i72                 ; get offset to local __ptr { ptr, u64, u64 }
sw $$locbase $r83 i9                    ; store word
sw $$locbase $r85 i10                   ; store word
sw $$locbase $r71 i11                   ; store word
addi $r91 $$locbase i24                 ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r91 $r87 i24                      ; copy memory
mcpi $r61 $r91 i24                      ; copy memory
mcpi $$arg2 $r61 i24                    ; copy memory
.7
cfsi i144                               ; free 144 bytes for locals and 0 slots for extra call arguments
popa .6                                 ; restore all registers
jal $zero $$reta i0                     ; return from call
DIFF------------------------------
.program:
.6                                      ; --- start of function: abi_encode_5 ---
pusha .6                                ; save all registers
move $$locbase $sp                      ; save locals base register for function abi_encode_5
cfei i144                               ; allocate 144 bytes for locals and 0 slots for call arguments
.29
addi $r60 $$locbase i120                ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r60 $$arg1 i24                    ; copy memory
addi $r61 $$locbase i96                 ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r62 $$locbase i120                ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $$locbase $r62 i24                 ; copy memory
addi $r64 $$locbase i48                 ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r64 $$locbase i24                 ; copy memory
lw $r65 $$locbase i6                    ; load word
lw $r67 $$locbase i7                    ; load word
lw $r69 $$locbase i8                    ; load word
movi $r70 i8                            ; initialize constant into register
add $r71 $r69 $r70
gt $r72 $r71 $r67
move $r73 $r65                          ; move parameter from branch to block argument
move $r74 $r67                          ; move parameter from branch to block argument
jnzi $r72 .30
ji  .31
.30
movi $r75 i2                            ; initialize constant into register
mul $r76 $r67 $r75
movi $r77 i8                            ; initialize constant into register
add $r78 $r76 $r77
aloc $r78
mcp $hp $r65 $r69
move $r73 $hp                           ; move parameter from branch to block argument
move $r74 $r78                          ; move parameter from branch to block argument
.31
move $r83 $r73                          ; move parameter from branch to block argument
move $r85 $r74                          ; move parameter from branch to block argument
add $r86 $r73 $r69
sw $r86 $$arg0 i0                       ; store word
addi $r87 $$locbase i72                 ; get offset to local __ptr { ptr, u64, u64 }
sw $$locbase $r83 i9                    ; store word
sw $$locbase $r85 i10                   ; store word
sw $$locbase $r71 i11                   ; store word
addi $r91 $$locbase i24                 ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r91 $r87 i24                      ; copy memory
mcpi $r61 $r91 i24                      ; copy memory
mcpi $$arg2 $r61 i24                    ; copy memory
.7
cfsi i144                               ; free 144 bytes for locals and 0 slots for extra call arguments
popa .6                                 ; restore all registers
jal $zero $$reta i0                     ; return from call
DIFF------------------------------
.program:
.6                                      ; --- start of function: abi_encode_5 ---
pusha .6                                ; save all registers
move $$locbase $sp                      ; save locals base register for function abi_encode_5
cfei i144                               ; allocate 144 bytes for locals and 0 slots for call arguments
.29
addi $r60 $$locbase i120                ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r60 $$arg1 i24                    ; copy memory
addi $r61 $$locbase i96                 ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r62 $$locbase i120                ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $$locbase $r62 i24                 ; copy memory
addi $r64 $$locbase i48                 ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r64 $$locbase i24                 ; copy memory
lw $r65 $$locbase i6                    ; load word
lw $r67 $$locbase i7                    ; load word
lw $r69 $$locbase i8                    ; load word
movi $r70 i8                            ; initialize constant into register
add $r71 $r69 $r70
gt $r72 $r71 $r67
move $r73 $r65                          ; move parameter from branch to block argument
move $r74 $r67                          ; move parameter from branch to block argument
jnzi $r72 .30
ji  .31
.30
movi $r75 i2                            ; initialize constant into register
mul $r76 $r67 $r75
movi $r77 i8                            ; initialize constant into register
add $r78 $r76 $r77
aloc $r78
mcp $hp $r65 $r69
move $r73 $hp                           ; move parameter from branch to block argument
move $r74 $r78                          ; move parameter from branch to block argument
.31
move $r83 $r73                          ; move parameter from branch to block argument
move $r85 $r74                          ; move parameter from branch to block argument
add $r86 $r73 $r69
sw $r86 $$arg0 i0                       ; store word
addi $r87 $$locbase i72                 ; get offset to local __ptr { ptr, u64, u64 }
sw $$locbase $r83 i9                    ; store word
sw $$locbase $r85 i10                   ; store word
sw $$locbase $r71 i11                   ; store word
addi $r91 $$locbase i24                 ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r91 $r87 i24                      ; copy memory
mcpi $r61 $r91 i24                      ; copy memory
mcpi $$arg2 $r61 i24                    ; copy memory
.7
cfsi i144                               ; free 144 bytes for locals and 0 slots for extra call arguments
popa .6                                 ; restore all registers
jal $zero $$reta i0                     ; return from call
DIFF------------------------------
.program:
.8                                      ; --- start of function: new_6 ---
pusha .8                                ; save all registers
move $$locbase $sp                      ; save locals base register for function new_6
cfei i72                                ; allocate 72 bytes for locals and 0 slots for call arguments
.32
addi $r93 $$locbase i48                 ; get offset to local __ptr { { ptr, u64, u64 } }
movi $r94 i1024                         ; initialize constant into register
aloc $r94
move $r95 $hp                           ; return value from ASM block with return register hp
addi $r96 $$locbase i24                 ; get offset to local __ptr { ptr, u64, u64 }
 sw $$locbase $r95 i3                    ; store word
 sw $$locbase $hp i3                     ; store word
addi $r97 $r96 i8                       ; get offset to aggregate element
movi $r98 i1024                         ; initialize constant into register
sw $$locbase $r98 i4                    ; store word
addi $r99 $r96 i16                      ; get offset to aggregate element
sw $$locbase $zero i5                   ; store word
move $r100 $r96                         ; return value from ASM block with return register buffer
 mcpi $$locbase $r100 i24                ; copy memory
 mcpi $$locbase $r96 i24                 ; copy memory
mcpi $r93 $$locbase i24                 ; copy memory
mcpi $$arg0 $r93 i24                    ; copy memory
ji  .9
.9
cfsi i72                                ; free 72 bytes for locals and 0 slots for extra call arguments
popa .8                                 ; restore all registers
jal $zero $$reta i0                     ; return from call
DIFF------------------------------
.program:
.8                                      ; --- start of function: new_6 ---
pusha .8                                ; save all registers
move $$locbase $sp                      ; save locals base register for function new_6
cfei i72                                ; allocate 72 bytes for locals and 0 slots for call arguments
.32
addi $r93 $$locbase i48                 ; get offset to local __ptr { { ptr, u64, u64 } }
movi $r94 i1024                         ; initialize constant into register
aloc $r94
addi $r96 $$locbase i24                 ; get offset to local __ptr { ptr, u64, u64 }
sw $$locbase $hp i3                     ; store word
movi $r98 i1024                         ; initialize constant into register
sw $$locbase $r98 i4                    ; store word
sw $$locbase $zero i5                   ; store word
mcpi $$locbase $r96 i24                 ; copy memory
mcpi $r93 $$locbase i24                 ; copy memory
mcpi $$arg0 $r93 i24                    ; copy memory
.9
cfsi i72                                ; free 72 bytes for locals and 0 slots for extra call arguments
popa .8                                 ; restore all registers
jal $zero $$reta i0                     ; return from call
DIFF------------------------------
.program:
.8                                      ; --- start of function: new_6 ---
pusha .8                                ; save all registers
move $$locbase $sp                      ; save locals base register for function new_6
cfei i72                                ; allocate 72 bytes for locals and 0 slots for call arguments
.32
addi $r93 $$locbase i48                 ; get offset to local __ptr { { ptr, u64, u64 } }
movi $r94 i1024                         ; initialize constant into register
aloc $r94
addi $r96 $$locbase i24                 ; get offset to local __ptr { ptr, u64, u64 }
sw $$locbase $hp i3                     ; store word
movi $r98 i1024                         ; initialize constant into register
sw $$locbase $r98 i4                    ; store word
sw $$locbase $zero i5                   ; store word
mcpi $$locbase $r96 i24                 ; copy memory
mcpi $r93 $$locbase i24                 ; copy memory
mcpi $$arg0 $r93 i24                    ; copy memory
.9
cfsi i72                                ; free 72 bytes for locals and 0 slots for extra call arguments
popa .8                                 ; restore all registers
jal $zero $$reta i0                     ; return from call
DIFF------------------------------
.program:
.8                                      ; --- start of function: new_6 ---
pusha .8                                ; save all registers
move $$locbase $sp                      ; save locals base register for function new_6
cfei i72                                ; allocate 72 bytes for locals and 0 slots for call arguments
.32
addi $r93 $$locbase i48                 ; get offset to local __ptr { { ptr, u64, u64 } }
movi $r94 i1024                         ; initialize constant into register
aloc $r94
addi $r96 $$locbase i24                 ; get offset to local __ptr { ptr, u64, u64 }
sw $$locbase $hp i3                     ; store word
movi $r98 i1024                         ; initialize constant into register
sw $$locbase $r98 i4                    ; store word
sw $$locbase $zero i5                   ; store word
mcpi $$locbase $r96 i24                 ; copy memory
mcpi $r93 $$locbase i24                 ; copy memory
mcpi $$arg0 $r93 i24                    ; copy memory
.9
cfsi i72                                ; free 72 bytes for locals and 0 slots for extra call arguments
popa .8                                 ; restore all registers
jal $zero $$reta i0                     ; return from call
DIFF------------------------------
.program:
.10                                     ; --- start of function: as_raw_slice_7 ---
pusha .10                               ; save all registers
move $$locbase $sp                      ; save locals base register for function as_raw_slice_7
cfei i56                                ; allocate 56 bytes for locals and 0 slots for call arguments
.33
addi $r102 $$locbase i32                ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r102 $$arg0 i24                   ; copy memory
addi $r103 $$locbase i32                ; get offset to local __ptr { { ptr, u64, u64 } }
move $r104 $r103                        ; return value from ASM block with return register buffer
lw $r105 $r103 i0                       ; load word
 addi $r106 $r104 i16                    ; get offset to aggregate element
 addi $r106 $r103 i16                    ; get offset to aggregate element
lw $r107 $r103 i2                       ; load word
addi $r108 $$locbase i16                ; get offset to local __ptr { ptr, u64 }
sw $$locbase $r105 i2                   ; store word
addi $r109 $r108 i8                     ; get offset to aggregate element
sw $$locbase $r107 i3                   ; store word
move $r110 $r108                        ; return value from ASM block with return register s
 mcpi $$locbase $r110 i16                ; copy memory
 mcpi $$locbase $r108 i16                ; copy memory
mcpi $$arg1 $$locbase i16               ; copy memory
ji  .11
.11
cfsi i56                                ; free 56 bytes for locals and 0 slots for extra call arguments
popa .10                                ; restore all registers
jal $zero $$reta i0                     ; return from call
DIFF------------------------------
.program:
.10                                     ; --- start of function: as_raw_slice_7 ---
pusha .10                               ; save all registers
move $$locbase $sp                      ; save locals base register for function as_raw_slice_7
cfei i56                                ; allocate 56 bytes for locals and 0 slots for call arguments
.33
addi $r102 $$locbase i32                ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r102 $$arg0 i24                   ; copy memory
addi $r103 $$locbase i32                ; get offset to local __ptr { { ptr, u64, u64 } }
lw $r105 $$locbase i4                   ; load word
lw $r107 $$locbase i6                   ; load word
addi $r108 $$locbase i16                ; get offset to local __ptr { ptr, u64 }
sw $$locbase $r105 i2                   ; store word
sw $$locbase $r107 i3                   ; store word
mcpi $$locbase $r108 i16                ; copy memory
mcpi $$arg1 $$locbase i16               ; copy memory
.11
cfsi i56                                ; free 56 bytes for locals and 0 slots for extra call arguments
popa .10                                ; restore all registers
jal $zero $$reta i0                     ; return from call
DIFF------------------------------
.program:
.10                                     ; --- start of function: as_raw_slice_7 ---
pusha .10                               ; save all registers
move $$locbase $sp                      ; save locals base register for function as_raw_slice_7
cfei i56                                ; allocate 56 bytes for locals and 0 slots for call arguments
.33
addi $r102 $$locbase i32                ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r102 $$arg0 i24                   ; copy memory
lw $r105 $$locbase i4                   ; load word
lw $r107 $$locbase i6                   ; load word
addi $r108 $$locbase i16                ; get offset to local __ptr { ptr, u64 }
sw $$locbase $r105 i2                   ; store word
sw $$locbase $r107 i3                   ; store word
mcpi $$locbase $r108 i16                ; copy memory
mcpi $$arg1 $$locbase i16               ; copy memory
.11
cfsi i56                                ; free 56 bytes for locals and 0 slots for extra call arguments
popa .10                                ; restore all registers
jal $zero $$reta i0                     ; return from call
DIFF------------------------------
.program:
.10                                     ; --- start of function: as_raw_slice_7 ---
pusha .10                               ; save all registers
move $$locbase $sp                      ; save locals base register for function as_raw_slice_7
cfei i56                                ; allocate 56 bytes for locals and 0 slots for call arguments
.33
addi $r102 $$locbase i32                ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r102 $$arg0 i24                   ; copy memory
lw $r105 $$locbase i4                   ; load word
lw $r107 $$locbase i6                   ; load word
addi $r108 $$locbase i16                ; get offset to local __ptr { ptr, u64 }
sw $$locbase $r105 i2                   ; store word
sw $$locbase $r107 i3                   ; store word
mcpi $$locbase $r108 i16                ; copy memory
mcpi $$arg1 $$locbase i16               ; copy memory
.11
cfsi i56                                ; free 56 bytes for locals and 0 slots for extra call arguments
popa .10                                ; restore all registers
jal $zero $$reta i0                     ; return from call
DIFF------------------------------
.program:
.12                                     ; --- start of function: push_11 ---
pusha .12                               ; save all registers
move $$locbase $sp                      ; save locals base register for function push_11
cfei i0                                 ; allocate 0 bytes for locals and 0 slots for call arguments
.34
addi $r112 $$arg0 i16                   ; get offset to aggregate element
lw $r113 $$arg0 i2                      ; load word
addi $r114 $$arg0 i8                    ; get offset to aggregate element
lw $r115 $$arg0 i1                      ; load word
eq $r116 $r113 $r115
jnzi $r116 .35
ji  .36
.35
lw $r117 $r114 i0                       ; load word
eq $r118 $r117 $zero
 move $r119 $one                         ; move parameter from branch to block argument
 movi $r119 i1                           ; move parameter from branch to block argument
jnzi $r118 .37
ji  .38
.38
lw $r120 $r114 i0                       ; load word
movi $r121 i2                           ; initialize constant into register
mul $r122 $r121 $r120
move $r119 $r122                        ; move parameter from branch to block argument
ji  .37
.37
move $r125 $r119                        ; move parameter from branch to block argument
lw $r126 $$arg0 i0                      ; load word
lw $r127 $r114 i0                       ; load word
 gt $r128 $r125 $r127
 gt $r128 $r119 $r127
move $r129 $r126                        ; move parameter from branch to block argument
jnzi $r128 .39
ji  .40
.39
movi $r130 i8                           ; get size of allocation element type
mul $r130 $r130 $r125                   ; get total allocation size in bytes
aloc $r130                              ; allocate memory
move $r131 $hp                          ; save allocated memory pointer
gt $r132 $r127 $zero
 move $r129 $r131                        ; move parameter from branch to block argument
 move $r129 $hp                          ; move parameter from branch to block argument
jnzi $r132 .41
ji  .40
.41
movi $r134 i8                           ; initialize constant into register
mul $r135 $r127 $r134
mcp $r131 $r126 $r135                   ; mcp dst src len
 move $r136 $zero                        ; return unit value from ASM block without return register
 movi $r136 i0                           ; return unit value from ASM block without return register
move $r129 $r131                        ; move parameter from branch to block argument
ji  .40
.40
move $r139 $r129                        ; move parameter from branch to block argument
 sw $$arg0 $r139 i0                      ; store word
 sw $$arg0 $r129 i0                      ; store word
sw $r114 $r125 i0                       ; store word
ji  .36
.36
lw $r140 $$arg0 i0                      ; load word
lw $r141 $r112 i0                       ; load word
movi $r142 i8                           ; initialize constant into register
mul $r143 $r142 $r141
add $r144 $r140 $r143
move $r145 $$arg1                       ; copy ASM block argument's constant initial value to register
 sw $r144 $r145 i0                       ; sw ptr val i0
 move $r146 $zero                        ; return unit value from ASM block without return register
 sw $r144 $$arg1 i0                      ; sw ptr val i0
 movi $r146 i0                           ; return unit value from ASM block without return register
lw $r147 $r112 i0                       ; load word
add $r148 $r147 $one
sw $r112 $r148 i0                       ; store word
ji  .13
.13
cfsi i0                                 ; free 0 bytes for locals and 0 slots for extra call arguments
popa .12                                ; restore all registers
jal $zero $$reta i0                     ; return from call
DIFF------------------------------
.program:
.12                                     ; --- start of function: push_11 ---
pusha .12                               ; save all registers
move $$locbase $sp                      ; save locals base register for function push_11
.34
addi $r112 $$arg0 i16                   ; get offset to aggregate element
lw $r113 $$arg0 i2                      ; load word
addi $r114 $$arg0 i8                    ; get offset to aggregate element
lw $r115 $$arg0 i1                      ; load word
eq $r116 $r113 $r115
jnzi $r116 .35
ji  .36
.35
lw $r117 $r114 i0                       ; load word
eq $r118 $r117 $zero
movi $r119 i1                           ; move parameter from branch to block argument
jnzi $r118 .37
.38
lw $r120 $r114 i0                       ; load word
movi $r121 i2                           ; initialize constant into register
mul $r122 $r121 $r120
move $r119 $r122                        ; move parameter from branch to block argument
.37
move $r125 $r119                        ; move parameter from branch to block argument
lw $r126 $$arg0 i0                      ; load word
lw $r127 $r114 i0                       ; load word
gt $r128 $r119 $r127
move $r129 $r126                        ; move parameter from branch to block argument
jnzi $r128 .39
ji  .40
.39
movi $r130 i8                           ; get size of allocation element type
mul $r130 $r130 $r125                   ; get total allocation size in bytes
aloc $r130                              ; allocate memory
move $r131 $hp                          ; save allocated memory pointer
gt $r132 $r127 $zero
move $r129 $hp                          ; move parameter from branch to block argument
jnzi $r132 .41
ji  .40
.41
movi $r134 i8                           ; initialize constant into register
mul $r135 $r127 $r134
mcp $r131 $r126 $r135                   ; mcp dst src len
move $r129 $r131                        ; move parameter from branch to block argument
.40
sw $$arg0 $r129 i0                      ; store word
sw $r114 $r125 i0                       ; store word
.36
lw $r140 $$arg0 i0                      ; load word
lw $r141 $r112 i0                       ; load word
movi $r142 i8                           ; initialize constant into register
mul $r143 $r142 $r141
add $r144 $r140 $r143
sw $r144 $$arg1 i0                      ; sw ptr val i0
lw $r147 $r112 i0                       ; load word
add $r148 $r147 $one
sw $r112 $r148 i0                       ; store word
.13
popa .12                                ; restore all registers
jal $zero $$reta i0                     ; return from call
DIFF------------------------------
.program:
.12                                     ; --- start of function: push_11 ---
pusha .12                               ; save all registers
move $$locbase $sp                      ; save locals base register for function push_11
.34
addi $r112 $$arg0 i16                   ; get offset to aggregate element
lw $r113 $$arg0 i2                      ; load word
addi $r114 $$arg0 i8                    ; get offset to aggregate element
lw $r115 $$arg0 i1                      ; load word
eq $r116 $r113 $r115
jnzi $r116 .35
ji  .36
.35
lw $r117 $r114 i0                       ; load word
eq $r118 $r117 $zero
movi $r119 i1                           ; move parameter from branch to block argument
jnzi $r118 .37
.38
lw $r120 $r114 i0                       ; load word
movi $r121 i2                           ; initialize constant into register
mul $r122 $r121 $r120
move $r119 $r122                        ; move parameter from branch to block argument
.37
move $r125 $r119                        ; move parameter from branch to block argument
lw $r126 $$arg0 i0                      ; load word
lw $r127 $r114 i0                       ; load word
gt $r128 $r119 $r127
move $r129 $r126                        ; move parameter from branch to block argument
jnzi $r128 .39
ji  .40
.39
movi $r130 i8                           ; get size of allocation element type
mul $r130 $r130 $r125                   ; get total allocation size in bytes
aloc $r130                              ; allocate memory
move $r131 $hp                          ; save allocated memory pointer
gt $r132 $r127 $zero
move $r129 $hp                          ; move parameter from branch to block argument
jnzi $r132 .41
ji  .40
.41
movi $r134 i8                           ; initialize constant into register
mul $r135 $r127 $r134
mcp $r131 $r126 $r135                   ; mcp dst src len
move $r129 $r131                        ; move parameter from branch to block argument
.40
sw $$arg0 $r129 i0                      ; store word
sw $r114 $r125 i0                       ; store word
.36
lw $r140 $$arg0 i0                      ; load word
lw $r141 $r112 i0                       ; load word
movi $r142 i8                           ; initialize constant into register
mul $r143 $r142 $r141
add $r144 $r140 $r143
sw $r144 $$arg1 i0                      ; sw ptr val i0
lw $r147 $r112 i0                       ; load word
add $r148 $r147 $one
sw $r112 $r148 i0                       ; store word
.13
popa .12                                ; restore all registers
jal $zero $$reta i0                     ; return from call
DIFF------------------------------
.program:
.12                                     ; --- start of function: push_11 ---
pusha .12                               ; save all registers
move $$locbase $sp                      ; save locals base register for function push_11
.34
addi $r112 $$arg0 i16                   ; get offset to aggregate element
lw $r113 $$arg0 i2                      ; load word
addi $r114 $$arg0 i8                    ; get offset to aggregate element
lw $r115 $$arg0 i1                      ; load word
eq $r116 $r113 $r115
jnzi $r116 .35
ji  .36
.35
lw $r117 $r114 i0                       ; load word
eq $r118 $r117 $zero
movi $r119 i1                           ; move parameter from branch to block argument
jnzi $r118 .37
.38
lw $r120 $r114 i0                       ; load word
movi $r121 i2                           ; initialize constant into register
mul $r122 $r121 $r120
move $r119 $r122                        ; move parameter from branch to block argument
.37
move $r125 $r119                        ; move parameter from branch to block argument
lw $r126 $$arg0 i0                      ; load word
lw $r127 $r114 i0                       ; load word
gt $r128 $r119 $r127
move $r129 $r126                        ; move parameter from branch to block argument
jnzi $r128 .39
ji  .40
.39
movi $r130 i8                           ; get size of allocation element type
mul $r130 $r130 $r125                   ; get total allocation size in bytes
aloc $r130                              ; allocate memory
move $r131 $hp                          ; save allocated memory pointer
gt $r132 $r127 $zero
move $r129 $hp                          ; move parameter from branch to block argument
jnzi $r132 .41
ji  .40
.41
movi $r134 i8                           ; initialize constant into register
mul $r135 $r127 $r134
mcp $r131 $r126 $r135                   ; mcp dst src len
move $r129 $r131                        ; move parameter from branch to block argument
.40
sw $$arg0 $r129 i0                      ; store word
sw $r114 $r125 i0                       ; store word
.36
lw $r140 $$arg0 i0                      ; load word
lw $r141 $r112 i0                       ; load word
movi $r142 i8                           ; initialize constant into register
mul $r143 $r142 $r141
add $r144 $r140 $r143
sw $r144 $$arg1 i0                      ; sw ptr val i0
lw $r147 $r112 i0                       ; load word
add $r148 $r147 $one
sw $r112 $r148 i0                       ; store word
.13
popa .12                                ; restore all registers
jal $zero $$reta i0                     ; return from call
DIFF------------------------------
.program:
.14                                     ; --- start of function: local_log_21 ---
pusha .14                               ; save all registers
move $$locbase $sp                      ; save locals base register for function local_log_21
cfei i1672                              ; allocate 1672 bytes for locals and 0 slots for call arguments
move $r149 $$arg0                       ; save argument 0 (item)
move $r150 $$reta                       ; save return address
.42
addi $r151 $$locbase i1368              ; get offset to local __ptr { u64, u64, u64, u8, { { ptr, u64 }, u64 }, slice, u256 }
 mcpi $r151 $r149 i104                   ; copy memory
 mcpi $r151 $$arg0 i104                  ; copy memory
addi $r152 $$locbase i1368              ; get offset to local __ptr { u64, u64, u64, u8, { { ptr, u64 }, u64 }, slice, u256 }
 move $r153 $zero                        ; move parameter from branch to block argument
 jnzi $zero .43
 movi $r153 i0                           ; move parameter from branch to block argument
 
ji  .44
.43
 move $r153 $zero                        ; move parameter from branch to block argument
                                         ; move parameter from branch to block argument
ji  .44
.44
move $r156 $r153                        ; move parameter from branch to block argument
 move $r157 $r156                        ; move parameter from branch to block argument
 jnzi $r156 .45
 move $r157 $r153                        ; move parameter from branch to block argument
 jnzi $r153 .45
ji  .46
.45
 move $r157 $one                         ; move parameter from branch to block argument
 movi $r157 i1                           ; move parameter from branch to block argument
ji  .46
.46
move $r160 $r157                        ; move parameter from branch to block argument
 move $r161 $r160                        ; move parameter from branch to block argument
 jnzi $r160 .47
 move $r161 $r157                        ; move parameter from branch to block argument
 jnzi $r157 .47
ji  .48
.47
 move $r161 $zero                        ; move parameter from branch to block argument
 movi $r161 i0                           ; move parameter from branch to block argument
ji  .48
.48
move $r164 $r161                        ; move parameter from branch to block argument
 move $r165 $r164                        ; move parameter from branch to block argument
 jnzi $r164 .49
 move $r165 $r161                        ; move parameter from branch to block argument
 jnzi $r161 .49
ji  .50
.49
 move $r165 $zero                        ; move parameter from branch to block argument
 movi $r165 i0                           ; move parameter from branch to block argument
ji  .50
.50
move $r168 $r165                        ; move parameter from branch to block argument
 move $r169 $r168                        ; move parameter from branch to block argument
 jnzi $r168 .51
 move $r169 $r165                        ; move parameter from branch to block argument
 jnzi $r165 .51
ji  .52
.51
 move $r169 $one                         ; move parameter from branch to block argument
 movi $r169 i1                           ; move parameter from branch to block argument
ji  .52
.52
move $r172 $r169                        ; move parameter from branch to block argument
 jnzi $r172 .53
 jnzi $r169 .53
ji  .54
.54
addi $r173 $$locbase i696               ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r173                       ; [call]: pass argument 0
fncall .8                               ; [call]: call new_6
 move $r174 $zero                        ; [call]: return unit value
 movi $r174 i0                           ; [call]: return unit value
addi $r175 $$locbase i1472              ; get offset to local __ptr { u64, u64, u64, u8, { { ptr, u64 }, u64 }, slice, u256 }
mcpi $r175 $r152 i104                   ; copy memory
addi $r176 $$locbase i1008              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r176 $r173 i24                    ; copy memory
addi $r177 $$locbase i1472              ; get offset to local __ptr { u64, u64, u64, u8, { { ptr, u64 }, u64 }, slice, u256 }
lw $r178 $$locbase i184                 ; load word
addi $r179 $$locbase i1008              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r180 $$locbase i856               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r180 $r179 i24                    ; copy memory
addi $r181 $$locbase i624               ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r178                       ; [call]: pass argument 0
move $$arg1 $r180                       ; [call]: pass argument 1
move $$arg2 $r181                       ; [call]: pass argument 2
fncall .6                               ; [call]: call abi_encode_5
 move $r182 $zero                        ; [call]: return unit value
 movi $r182 i0                           ; [call]: return unit value
addi $r183 $$locbase i1176              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r183 $r181 i24                    ; copy memory
addi $r184 $$locbase i1472              ; get offset to local __ptr { u64, u64, u64, u8, { { ptr, u64 }, u64 }, slice, u256 }
addi $r185 $r184 i8                     ; get offset to aggregate element
addi $r186 $$locbase i1176              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r187 $$locbase i1032              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r187 $r186 i24                    ; copy memory
addi $r188 $$locbase i736               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r189 $$locbase i1032              ; get offset to local __ptr { { ptr, u64, u64 } }
move $r190 $r189                        ; return value from ASM block with return register buffer
 mcpi $$locbase $r190 i24                ; copy memory
 mcpi $$locbase $r189 i24                ; copy memory
addi $r191 $$locbase i288               ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r191 $$locbase i24                ; copy memory
lw $r192 $$locbase i36                  ; load word
addi $r193 $r191 i8                     ; get offset to aggregate element
lw $r194 $$locbase i37                  ; load word
addi $r195 $r191 i16                    ; get offset to aggregate element
lw $r196 $$locbase i38                  ; load word
movi $r197 i4                           ; initialize constant into register
add $r198 $r196 $r197
gt $r199 $r198 $r194
move $r200 $r192                        ; move parameter from branch to block argument
move $r201 $r194                        ; move parameter from branch to block argument
jnzi $r199 .55
ji  .56
.55
movi $r202 i2                           ; initialize constant into register
mul $r203 $r194 $r202
movi $r204 i4                           ; initialize constant into register
add $r205 $r203 $r204
aloc $r205
mcp $hp $r192 $r196
move $r206 $hp                          ; return value from ASM block with return register hp
 move $r200 $r206                        ; move parameter from branch to block argument
 move $r200 $hp                          ; move parameter from branch to block argument
move $r201 $r205                        ; move parameter from branch to block argument
ji  .56
.56
move $r210 $r200                        ; move parameter from branch to block argument
move $r212 $r201                        ; move parameter from branch to block argument
addi $r213 $$locbase i408               ; get offset to local __ptr u64
mcpi $r213 $r185 i8                     ; copy memory
movi $r214 i4                           ; initialize constant into register
add $r215 $r213 $r214
add $r216 $r210 $r196
mcpi $r216 $r215 i4                     ; copy memory
addi $r217 $$locbase i496               ; get offset to local __ptr { ptr, u64, u64 }
sw $$locbase $r210 i62                  ; store word
addi $r218 $r217 i8                     ; get offset to aggregate element
sw $$locbase $r212 i63                  ; store word
addi $r219 $r217 i16                    ; get offset to aggregate element
sw $$locbase $r198 i64                  ; store word
move $r220 $r217                        ; return value from ASM block with return register buffer
addi $r221 $$locbase i24                ; get offset to local __ptr { ptr, u64, u64 }
 mcpi $r221 $r220 i24                    ; copy memory
 mcpi $r221 $r217 i24                    ; copy memory
mcpi $r188 $r221 i24                    ; copy memory
addi $r222 $$locbase i1224              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r222 $r188 i24                    ; copy memory
addi $r223 $$locbase i1472              ; get offset to local __ptr { u64, u64, u64, u8, { { ptr, u64 }, u64 }, slice, u256 }
addi $r224 $r223 i16                    ; get offset to aggregate element
addi $r225 $$locbase i1224              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r226 $$locbase i1056              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r226 $r225 i24                    ; copy memory
addi $r227 $$locbase i760               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r228 $$locbase i1056              ; get offset to local __ptr { { ptr, u64, u64 } }
move $r229 $r228                        ; return value from ASM block with return register buffer
addi $r230 $$locbase i48                ; get offset to local __ptr { ptr, u64, u64 }
 mcpi $r230 $r229 i24                    ; copy memory
 mcpi $r230 $r228 i24                    ; copy memory
addi $r231 $$locbase i312               ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r231 $r230 i24                    ; copy memory
lw $r232 $$locbase i39                  ; load word
addi $r233 $r231 i8                     ; get offset to aggregate element
lw $r234 $$locbase i40                  ; load word
addi $r235 $r231 i16                    ; get offset to aggregate element
lw $r236 $$locbase i41                  ; load word
movi $r237 i2                           ; initialize constant into register
add $r238 $r236 $r237
gt $r239 $r238 $r234
move $r240 $r232                        ; move parameter from branch to block argument
move $r241 $r234                        ; move parameter from branch to block argument
jnzi $r239 .57
ji  .58
.57
movi $r242 i2                           ; initialize constant into register
mul $r243 $r234 $r242
movi $r244 i2                           ; initialize constant into register
add $r245 $r243 $r244
aloc $r245
mcp $hp $r232 $r236
move $r246 $hp                          ; return value from ASM block with return register hp
 move $r240 $r246                        ; move parameter from branch to block argument
 move $r240 $hp                          ; move parameter from branch to block argument
move $r241 $r245                        ; move parameter from branch to block argument
ji  .58
.58
move $r250 $r240                        ; move parameter from branch to block argument
move $r252 $r241                        ; move parameter from branch to block argument
addi $r253 $$locbase i416               ; get offset to local __ptr u64
mcpi $r253 $r224 i8                     ; copy memory
movi $r254 i6                           ; initialize constant into register
add $r255 $r253 $r254
add $r256 $r250 $r236
mcpi $r256 $r255 i2                     ; copy memory
addi $r257 $$locbase i520               ; get offset to local __ptr { ptr, u64, u64 }
sw $$locbase $r250 i65                  ; store word
addi $r258 $r257 i8                     ; get offset to aggregate element
sw $$locbase $r252 i66                  ; store word
addi $r259 $r257 i16                    ; get offset to aggregate element
sw $$locbase $r238 i67                  ; store word
move $r260 $r257                        ; return value from ASM block with return register buffer
addi $r261 $$locbase i96                ; get offset to local __ptr { ptr, u64, u64 }
 mcpi $r261 $r260 i24                    ; copy memory
 mcpi $r261 $r257 i24                    ; copy memory
mcpi $r227 $r261 i24                    ; copy memory
addi $r262 $$locbase i1248              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r262 $r227 i24                    ; copy memory
addi $r263 $$locbase i1472              ; get offset to local __ptr { u64, u64, u64, u8, { { ptr, u64 }, u64 }, slice, u256 }
addi $r264 $r263 i24                    ; get offset to aggregate element
lb $r265 $r264 i0                       ; load byte
addi $r266 $$locbase i1248              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r267 $$locbase i1080              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r267 $r266 i24                    ; copy memory
addi $r268 $$locbase i784               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r269 $$locbase i1080              ; get offset to local __ptr { { ptr, u64, u64 } }
move $r270 $r269                        ; return value from ASM block with return register buffer
addi $r271 $$locbase i120               ; get offset to local __ptr { ptr, u64, u64 }
 mcpi $r271 $r270 i24                    ; copy memory
 mcpi $r271 $r269 i24                    ; copy memory
addi $r272 $$locbase i336               ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r272 $r271 i24                    ; copy memory
lw $r273 $$locbase i42                  ; load word
addi $r274 $r272 i8                     ; get offset to aggregate element
lw $r275 $$locbase i43                  ; load word
addi $r276 $r272 i16                    ; get offset to aggregate element
lw $r277 $$locbase i44                  ; load word
add $r278 $r277 $one
gt $r279 $r278 $r275
move $r280 $r273                        ; move parameter from branch to block argument
move $r281 $r275                        ; move parameter from branch to block argument
jnzi $r279 .59
ji  .60
.59
movi $r282 i2                           ; initialize constant into register
mul $r283 $r275 $r282
add $r284 $r283 $one
aloc $r284
mcp $hp $r273 $r277
move $r285 $hp                          ; return value from ASM block with return register hp
 move $r280 $r285                        ; move parameter from branch to block argument
 move $r280 $hp                          ; move parameter from branch to block argument
move $r281 $r284                        ; move parameter from branch to block argument
ji  .60
.60
move $r289 $r280                        ; move parameter from branch to block argument
move $r291 $r281                        ; move parameter from branch to block argument
 add $r292 $r289 $r277
 add $r292 $r280 $r277
sb $r292 $r265 i0                       ; store byte
addi $r293 $$locbase i424               ; get offset to local __ptr { ptr, u64, u64 }
sw $$locbase $r289 i53                  ; store word
addi $r294 $r293 i8                     ; get offset to aggregate element
sw $$locbase $r291 i54                  ; store word
addi $r295 $r293 i16                    ; get offset to aggregate element
sw $$locbase $r278 i55                  ; store word
move $r296 $r293                        ; return value from ASM block with return register buffer
addi $r297 $$locbase i144               ; get offset to local __ptr { ptr, u64, u64 }
 mcpi $r297 $r296 i24                    ; copy memory
 mcpi $r297 $r293 i24                    ; copy memory
mcpi $r268 $r297 i24                    ; copy memory
addi $r298 $$locbase i1272              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r298 $r268 i24                    ; copy memory
addi $r299 $$locbase i1472              ; get offset to local __ptr { u64, u64, u64, u8, { { ptr, u64 }, u64 }, slice, u256 }
addi $r300 $r299 i32                    ; get offset to aggregate element
addi $r301 $$locbase i1272              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r302 $$locbase i1600              ; get offset to local __ptr { { ptr, u64 }, u64 }
mcpi $r302 $r300 i24                    ; copy memory
addi $r303 $$locbase i1104              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r303 $r301 i24                    ; copy memory
addi $r304 $$locbase i1600              ; get offset to local __ptr { { ptr, u64 }, u64 }
addi $r305 $r304 i16                    ; get offset to aggregate element
lw $r306 $$locbase i202                 ; load word
addi $r307 $$locbase i1104              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r308 $$locbase i880               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r308 $r307 i24                    ; copy memory
addi $r309 $$locbase i648               ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r306                       ; [call]: pass argument 0
move $$arg1 $r308                       ; [call]: pass argument 1
move $$arg2 $r309                       ; [call]: pass argument 2
fncall .6                               ; [call]: call abi_encode_5
 move $r310 $zero                        ; [call]: return unit value
 movi $r310 i0                           ; [call]: return unit value
addi $r311 $$locbase i1200              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r311 $r309 i24                    ; copy memory
 move $r312 $zero                        ; move parameter from branch to block argument
 movi $r312 i0                           ; move parameter from branch to block argument
ji  .61
.61
move $r314 $r312                        ; move parameter from branch to block argument
 lt $r315 $r314 $r306
 lt $r315 $r312 $r306
jnzi $r315 .62
ji  .63
.63
addi $r316 $$locbase i1200              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r317 $$locbase i1296              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r317 $r316 i24                    ; copy memory
addi $r318 $$locbase i1472              ; get offset to local __ptr { u64, u64, u64, u8, { { ptr, u64 }, u64 }, slice, u256 }
addi $r319 $r318 i56                    ; get offset to aggregate element
addi $r320 $$locbase i1296              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r321 $$locbase i1624              ; get offset to local __ptr slice
mcpi $r321 $r319 i16                    ; copy memory
addi $r322 $$locbase i1128              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r322 $r320 i24                    ; copy memory
addi $r323 $$locbase i808               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r324 $$locbase i1128              ; get offset to local __ptr { { ptr, u64, u64 } }
move $r325 $r324                        ; return value from ASM block with return register buffer
addi $r326 $$locbase i168               ; get offset to local __ptr { ptr, u64, u64 }
 mcpi $r326 $r325 i24                    ; copy memory
 mcpi $r326 $r324 i24                    ; copy memory
addi $r327 $$locbase i360               ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r327 $r326 i24                    ; copy memory
lw $r328 $$locbase i45                  ; load word
addi $r329 $r327 i8                     ; get offset to aggregate element
lw $r330 $$locbase i46                  ; load word
addi $r331 $r327 i16                    ; get offset to aggregate element
lw $r332 $$locbase i47                  ; load word
addi $r333 $$locbase i1624              ; get offset to local __ptr slice
addi $r334 $$locbase i208               ; get offset to local __ptr slice
mcpi $r334 $r333 i16                    ; copy memory
move $r335 $r333                        ; return value from ASM block with return register item
addi $r336 $$locbase i192               ; get offset to local __ptr { u64, u64 }
 mcpi $r336 $r335 i16                    ; copy memory
 mcpi $r336 $r333 i16                    ; copy memory
addi $r337 $$locbase i448               ; get offset to local __ptr { u64, u64 }
mcpi $r337 $r336 i16                    ; copy memory
addi $r338 $r337 i8                     ; get offset to aggregate element
lw $r339 $$locbase i57                  ; load word
movi $r340 i8                           ; initialize constant into register
add $r341 $r339 $r340
add $r342 $r332 $r341
gt $r343 $r342 $r330
move $r344 $r328                        ; move parameter from branch to block argument
move $r345 $r330                        ; move parameter from branch to block argument
jnzi $r343 .64
ji  .65
.64
movi $r346 i2                           ; initialize constant into register
mul $r347 $r330 $r346
add $r348 $r347 $r341
aloc $r348
mcp $hp $r328 $r332
move $r349 $hp                          ; return value from ASM block with return register hp
 move $r344 $r349                        ; move parameter from branch to block argument
 move $r344 $hp                          ; move parameter from branch to block argument
move $r345 $r348                        ; move parameter from branch to block argument
ji  .65
.65
move $r353 $r344                        ; move parameter from branch to block argument
move $r355 $r345                        ; move parameter from branch to block argument
addi $r356 $$locbase i544               ; get offset to local __ptr slice
mcpi $r356 $r334 i16                    ; copy memory
add $r357 $r353 $r332
lw $r359 $$locbase i69
sw $r357 $r359 i0
addi $r357 $r357 i8
lw $r358 $$locbase i68
mcp $r357 $r358 $r359
addi $r360 $r332 i8
add $r360 $r360 $r359
move $r361 $r360                        ; return value from ASM block with return register new_len
addi $r362 $$locbase i584               ; get offset to local __ptr { ptr, u64, u64 }
sw $$locbase $r353 i73                  ; store word
addi $r363 $r362 i8                     ; get offset to aggregate element
sw $$locbase $r355 i74                  ; store word
addi $r364 $r362 i16                    ; get offset to aggregate element
sw $$locbase $r361 i75                  ; store word
move $r365 $r362                        ; return value from ASM block with return register buffer
addi $r366 $$locbase i224               ; get offset to local __ptr { ptr, u64, u64 }
 mcpi $r366 $r365 i24                    ; copy memory
 mcpi $r366 $r362 i24                    ; copy memory
mcpi $r323 $r366 i24                    ; copy memory
addi $r367 $$locbase i1320              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r367 $r323 i24                    ; copy memory
addi $r368 $$locbase i1472              ; get offset to local __ptr { u64, u64, u64, u8, { { ptr, u64 }, u64 }, slice, u256 }
addi $r369 $r368 i72                    ; get offset to aggregate element
addi $r370 $$locbase i1320              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r371 $$locbase i1640              ; get offset to local __ptr u256
mcpi $r371 $r369 i32                    ; copy memory
addi $r372 $$locbase i1152              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r372 $r370 i24                    ; copy memory
addi $r373 $$locbase i832               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r374 $$locbase i1152              ; get offset to local __ptr { { ptr, u64, u64 } }
move $r375 $r374                        ; return value from ASM block with return register buffer
addi $r376 $$locbase i248               ; get offset to local __ptr { ptr, u64, u64 }
 mcpi $r376 $r375 i24                    ; copy memory
 mcpi $r376 $r374 i24                    ; copy memory
addi $r377 $$locbase i384               ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r377 $r376 i24                    ; copy memory
lw $r378 $$locbase i48                  ; load word
addi $r379 $r377 i8                     ; get offset to aggregate element
lw $r380 $$locbase i49                  ; load word
addi $r381 $r377 i16                    ; get offset to aggregate element
lw $r382 $$locbase i50                  ; load word
addi $r383 $$locbase i1640              ; get offset to local __ptr u256
movi $r384 i32                          ; initialize constant into register
add $r385 $r382 $r384
gt $r386 $r385 $r380
move $r387 $r378                        ; move parameter from branch to block argument
move $r388 $r380                        ; move parameter from branch to block argument
jnzi $r386 .66
ji  .67
.66
movi $r389 i2                           ; initialize constant into register
mul $r390 $r380 $r389
movi $r391 i32                          ; initialize constant into register
add $r392 $r390 $r391
aloc $r392
mcp $hp $r378 $r382
move $r393 $hp                          ; return value from ASM block with return register hp
 move $r387 $r393                        ; move parameter from branch to block argument
 move $r387 $hp                          ; move parameter from branch to block argument
move $r388 $r392                        ; move parameter from branch to block argument
ji  .67
.67
move $r397 $r387                        ; move parameter from branch to block argument
move $r399 $r388                        ; move parameter from branch to block argument
addi $r400 $$locbase i464               ; get offset to local __ptr u256
mcpi $r400 $r383 i32                    ; copy memory
add $r401 $r397 $r382
mcpi $r401 $r400 i32                    ; copy memory
addi $r402 $$locbase i560               ; get offset to local __ptr { ptr, u64, u64 }
sw $$locbase $r397 i70                  ; store word
addi $r403 $r402 i8                     ; get offset to aggregate element
sw $$locbase $r399 i71                  ; store word
addi $r404 $r402 i16                    ; get offset to aggregate element
sw $$locbase $r385 i72                  ; store word
move $r405 $r402                        ; return value from ASM block with return register buffer
addi $r406 $$locbase i72                ; get offset to local __ptr { ptr, u64, u64 }
 mcpi $r406 $r405 i24                    ; copy memory
 mcpi $r406 $r402 i24                    ; copy memory
mcpi $r373 $r406 i24                    ; copy memory
addi $r407 $$locbase i1344              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r407 $r373 i24                    ; copy memory
addi $r408 $$locbase i1344              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r409 $$locbase i984               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r409 $r408 i24                    ; copy memory
addi $r410 $$locbase i984               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r411 $$locbase i928               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r411 $r410 i24                    ; copy memory
addi $r412 $$locbase i720               ; get offset to local __ptr slice
move $$arg0 $r411                       ; [call]: pass argument 0
move $$arg1 $r412                       ; [call]: pass argument 1
fncall .10                              ; [call]: call as_raw_slice_7
 move $r413 $zero                        ; [call]: return unit value
 movi $r413 i0                           ; [call]: return unit value
addi $r414 $$locbase i952               ; get offset to local __ptr slice
mcpi $r414 $r412 i16                    ; copy memory
move $r415 $r414                        ; move parameter from branch to block argument
ji  .68
.62
addi $r416 $$locbase i1600              ; get offset to local __ptr { { ptr, u64 }, u64 }
addi $r417 $$locbase i1576              ; get offset to local __ptr { { ptr, u64 }, u64 }
mcpi $r417 $r416 i24                    ; copy memory
addi $r418 $$locbase i1576              ; get offset to local __ptr { { ptr, u64 }, u64 }
lw $r419 $$locbase i197                 ; load word
movi $r420 i8                           ; initialize constant into register
mul $r421 $r420 $r314
add $r422 $r419 $r421
lw $r423 $r422 i0                       ; lw val ptr i0
move $r424 $r423                        ; return value from ASM block with return register val
addi $r425 $$locbase i1200              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r426 $$locbase i904               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r426 $r425 i24                    ; copy memory
addi $r427 $$locbase i672               ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r424                       ; [call]: pass argument 0
move $$arg1 $r426                       ; [call]: pass argument 1
move $$arg2 $r427                       ; [call]: pass argument 2
fncall .6                               ; [call]: call abi_encode_5
 move $r428 $zero                        ; [call]: return unit value
 movi $r428 i0                           ; [call]: return unit value
addi $r429 $$locbase i1200              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r429 $r427 i24                    ; copy memory
add $r430 $r314 $one
move $r312 $r430                        ; move parameter from branch to block argument
ji  .61
.53
addi $r432 $$locbase i968               ; get offset to local __ptr { __ptr { u64, u64, u64, u8, { { ptr, u64 }, u64 }, slice, u256 }, u64 }
sw $$locbase $r152 i121                 ; store word
addi $r433 $r432 i8                     ; get offset to aggregate element
movi $r434 i104                         ; initialize constant into register
sw $$locbase $r434 i122                 ; store word
addi $r435 $$locbase i272               ; get offset to local __ptr { __ptr { u64, u64, u64, u8, { { ptr, u64 }, u64 }, slice, u256 }, u64 }
mcpi $r435 $r432 i16                    ; copy memory
addi $r436 $$locbase i952               ; get offset to local __ptr slice
mcpi $r436 $r435 i16                    ; copy memory
move $r415 $r436                        ; move parameter from branch to block argument
ji  .68
.68
move $r439 $r415                        ; move parameter from branch to block argument
addi $r440 $$locbase i608               ; get offset to local __ptr slice
 mcpi $r440 $r439 i16                    ; copy memory
 mcpi $r440 $r415 i16                    ; copy memory
load $r441 data_NonConfigurable_3       ; load constant from data section
lw $r442 $$locbase i76                  ; load slice pointer for logging data
lw $r443 $$locbase i77                  ; load slice size for logging data
logd $zero $r441 $r442 $r443            ; log slice
ji  .15
.15
cfsi i1672                              ; free 1672 bytes for locals and 0 slots for extra call arguments
move $$reta $r150                       ; restore return address
popa .14                                ; restore all registers
jal $zero $$reta i0                     ; return from call
DIFF------------------------------
.program:
.14                                     ; --- start of function: local_log_21 ---
pusha .14                               ; save all registers
move $$locbase $sp                      ; save locals base register for function local_log_21
cfei i1672                              ; allocate 1672 bytes for locals and 0 slots for call arguments
move $r150 $$reta                       ; save return address
.42
addi $r151 $$locbase i1368              ; get offset to local __ptr { u64, u64, u64, u8, { { ptr, u64 }, u64 }, slice, u256 }
mcpi $r151 $$arg0 i104                  ; copy memory
addi $r152 $$locbase i1368              ; get offset to local __ptr { u64, u64, u64, u8, { { ptr, u64 }, u64 }, slice, u256 }
movi $r153 i0                           ; move parameter from branch to block argument
.44
 move $r157 $r153                        ; move parameter from branch to block argument
 jnzi $r153 .45
 movi $r157 i0                           ; move parameter from branch to block argument
 
ji  .46
.45
movi $r157 i1                           ; move parameter from branch to block argument
.46
move $r161 $r157                        ; move parameter from branch to block argument
jnzi $r157 .47
ji  .48
.47
movi $r161 i0                           ; move parameter from branch to block argument
.48
move $r165 $r161                        ; move parameter from branch to block argument
jnzi $r161 .49
ji  .50
.49
movi $r165 i0                           ; move parameter from branch to block argument
.50
move $r169 $r165                        ; move parameter from branch to block argument
jnzi $r165 .51
ji  .52
.51
movi $r169 i1                           ; move parameter from branch to block argument
.52
jnzi $r169 .53
.54
addi $r173 $$locbase i696               ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r173                       ; [call]: pass argument 0
fncall .8                               ; [call]: call new_6
addi $r175 $$locbase i1472              ; get offset to local __ptr { u64, u64, u64, u8, { { ptr, u64 }, u64 }, slice, u256 }
mcpi $r175 $r152 i104                   ; copy memory
addi $r176 $$locbase i1008              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r176 $r173 i24                    ; copy memory
lw $r178 $$locbase i184                 ; load word
addi $r179 $$locbase i1008              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r180 $$locbase i856               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r180 $r179 i24                    ; copy memory
addi $r181 $$locbase i624               ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r178                       ; [call]: pass argument 0
move $$arg1 $r180                       ; [call]: pass argument 1
move $$arg2 $r181                       ; [call]: pass argument 2
fncall .6                               ; [call]: call abi_encode_5
addi $r183 $$locbase i1176              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r183 $r181 i24                    ; copy memory
addi $r184 $$locbase i1472              ; get offset to local __ptr { u64, u64, u64, u8, { { ptr, u64 }, u64 }, slice, u256 }
addi $r185 $r184 i8                     ; get offset to aggregate element
addi $r186 $$locbase i1176              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r187 $$locbase i1032              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r187 $r186 i24                    ; copy memory
addi $r188 $$locbase i736               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r189 $$locbase i1032              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $$locbase $r189 i24                ; copy memory
addi $r191 $$locbase i288               ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r191 $$locbase i24                ; copy memory
lw $r192 $$locbase i36                  ; load word
lw $r194 $$locbase i37                  ; load word
lw $r196 $$locbase i38                  ; load word
movi $r197 i4                           ; initialize constant into register
add $r198 $r196 $r197
gt $r199 $r198 $r194
move $r200 $r192                        ; move parameter from branch to block argument
move $r201 $r194                        ; move parameter from branch to block argument
jnzi $r199 .55
ji  .56
.55
movi $r202 i2                           ; initialize constant into register
mul $r203 $r194 $r202
movi $r204 i4                           ; initialize constant into register
add $r205 $r203 $r204
aloc $r205
mcp $hp $r192 $r196
move $r200 $hp                          ; move parameter from branch to block argument
move $r201 $r205                        ; move parameter from branch to block argument
.56
move $r210 $r200                        ; move parameter from branch to block argument
move $r212 $r201                        ; move parameter from branch to block argument
addi $r213 $$locbase i408               ; get offset to local __ptr u64
mcpi $r213 $r185 i8                     ; copy memory
movi $r214 i4                           ; initialize constant into register
add $r215 $r213 $r214
add $r216 $r210 $r196
mcpi $r216 $r215 i4                     ; copy memory
addi $r217 $$locbase i496               ; get offset to local __ptr { ptr, u64, u64 }
sw $$locbase $r210 i62                  ; store word
sw $$locbase $r212 i63                  ; store word
sw $$locbase $r198 i64                  ; store word
addi $r221 $$locbase i24                ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r221 $r217 i24                    ; copy memory
mcpi $r188 $r221 i24                    ; copy memory
addi $r222 $$locbase i1224              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r222 $r188 i24                    ; copy memory
addi $r223 $$locbase i1472              ; get offset to local __ptr { u64, u64, u64, u8, { { ptr, u64 }, u64 }, slice, u256 }
addi $r224 $r223 i16                    ; get offset to aggregate element
addi $r225 $$locbase i1224              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r226 $$locbase i1056              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r226 $r225 i24                    ; copy memory
addi $r227 $$locbase i760               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r228 $$locbase i1056              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r230 $$locbase i48                ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r230 $r228 i24                    ; copy memory
addi $r231 $$locbase i312               ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r231 $r230 i24                    ; copy memory
lw $r232 $$locbase i39                  ; load word
lw $r234 $$locbase i40                  ; load word
lw $r236 $$locbase i41                  ; load word
movi $r237 i2                           ; initialize constant into register
add $r238 $r236 $r237
gt $r239 $r238 $r234
move $r240 $r232                        ; move parameter from branch to block argument
move $r241 $r234                        ; move parameter from branch to block argument
jnzi $r239 .57
ji  .58
.57
movi $r242 i2                           ; initialize constant into register
mul $r243 $r234 $r242
movi $r244 i2                           ; initialize constant into register
add $r245 $r243 $r244
aloc $r245
mcp $hp $r232 $r236
move $r240 $hp                          ; move parameter from branch to block argument
move $r241 $r245                        ; move parameter from branch to block argument
.58
move $r250 $r240                        ; move parameter from branch to block argument
move $r252 $r241                        ; move parameter from branch to block argument
addi $r253 $$locbase i416               ; get offset to local __ptr u64
mcpi $r253 $r224 i8                     ; copy memory
movi $r254 i6                           ; initialize constant into register
add $r255 $r253 $r254
add $r256 $r250 $r236
mcpi $r256 $r255 i2                     ; copy memory
addi $r257 $$locbase i520               ; get offset to local __ptr { ptr, u64, u64 }
sw $$locbase $r250 i65                  ; store word
sw $$locbase $r252 i66                  ; store word
sw $$locbase $r238 i67                  ; store word
addi $r261 $$locbase i96                ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r261 $r257 i24                    ; copy memory
mcpi $r227 $r261 i24                    ; copy memory
addi $r262 $$locbase i1248              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r262 $r227 i24                    ; copy memory
addi $r263 $$locbase i1472              ; get offset to local __ptr { u64, u64, u64, u8, { { ptr, u64 }, u64 }, slice, u256 }
addi $r264 $r263 i24                    ; get offset to aggregate element
lb $r265 $r264 i0                       ; load byte
addi $r266 $$locbase i1248              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r267 $$locbase i1080              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r267 $r266 i24                    ; copy memory
addi $r268 $$locbase i784               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r269 $$locbase i1080              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r271 $$locbase i120               ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r271 $r269 i24                    ; copy memory
addi $r272 $$locbase i336               ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r272 $r271 i24                    ; copy memory
lw $r273 $$locbase i42                  ; load word
lw $r275 $$locbase i43                  ; load word
lw $r277 $$locbase i44                  ; load word
add $r278 $r277 $one
gt $r279 $r278 $r275
move $r280 $r273                        ; move parameter from branch to block argument
move $r281 $r275                        ; move parameter from branch to block argument
jnzi $r279 .59
ji  .60
.59
movi $r282 i2                           ; initialize constant into register
mul $r283 $r275 $r282
add $r284 $r283 $one
aloc $r284
mcp $hp $r273 $r277
move $r280 $hp                          ; move parameter from branch to block argument
move $r281 $r284                        ; move parameter from branch to block argument
.60
move $r289 $r280                        ; move parameter from branch to block argument
move $r291 $r281                        ; move parameter from branch to block argument
add $r292 $r280 $r277
sb $r292 $r265 i0                       ; store byte
addi $r293 $$locbase i424               ; get offset to local __ptr { ptr, u64, u64 }
sw $$locbase $r289 i53                  ; store word
sw $$locbase $r291 i54                  ; store word
sw $$locbase $r278 i55                  ; store word
addi $r297 $$locbase i144               ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r297 $r293 i24                    ; copy memory
mcpi $r268 $r297 i24                    ; copy memory
addi $r298 $$locbase i1272              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r298 $r268 i24                    ; copy memory
addi $r299 $$locbase i1472              ; get offset to local __ptr { u64, u64, u64, u8, { { ptr, u64 }, u64 }, slice, u256 }
addi $r300 $r299 i32                    ; get offset to aggregate element
addi $r301 $$locbase i1272              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r302 $$locbase i1600              ; get offset to local __ptr { { ptr, u64 }, u64 }
mcpi $r302 $r300 i24                    ; copy memory
addi $r303 $$locbase i1104              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r303 $r301 i24                    ; copy memory
lw $r306 $$locbase i202                 ; load word
addi $r307 $$locbase i1104              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r308 $$locbase i880               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r308 $r307 i24                    ; copy memory
addi $r309 $$locbase i648               ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r306                       ; [call]: pass argument 0
move $$arg1 $r308                       ; [call]: pass argument 1
move $$arg2 $r309                       ; [call]: pass argument 2
fncall .6                               ; [call]: call abi_encode_5
addi $r311 $$locbase i1200              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r311 $r309 i24                    ; copy memory
movi $r312 i0                           ; move parameter from branch to block argument
.61
move $r314 $r312                        ; move parameter from branch to block argument
lt $r315 $r312 $r306
jnzi $r315 .62
.63
addi $r316 $$locbase i1200              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r317 $$locbase i1296              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r317 $r316 i24                    ; copy memory
addi $r318 $$locbase i1472              ; get offset to local __ptr { u64, u64, u64, u8, { { ptr, u64 }, u64 }, slice, u256 }
addi $r319 $r318 i56                    ; get offset to aggregate element
addi $r320 $$locbase i1296              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r321 $$locbase i1624              ; get offset to local __ptr slice
mcpi $r321 $r319 i16                    ; copy memory
addi $r322 $$locbase i1128              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r322 $r320 i24                    ; copy memory
addi $r323 $$locbase i808               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r324 $$locbase i1128              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r326 $$locbase i168               ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r326 $r324 i24                    ; copy memory
addi $r327 $$locbase i360               ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r327 $r326 i24                    ; copy memory
lw $r328 $$locbase i45                  ; load word
lw $r330 $$locbase i46                  ; load word
lw $r332 $$locbase i47                  ; load word
addi $r333 $$locbase i1624              ; get offset to local __ptr slice
addi $r334 $$locbase i208               ; get offset to local __ptr slice
mcpi $r334 $r333 i16                    ; copy memory
addi $r336 $$locbase i192               ; get offset to local __ptr { u64, u64 }
mcpi $r336 $r333 i16                    ; copy memory
addi $r337 $$locbase i448               ; get offset to local __ptr { u64, u64 }
mcpi $r337 $r336 i16                    ; copy memory
lw $r339 $$locbase i57                  ; load word
movi $r340 i8                           ; initialize constant into register
add $r341 $r339 $r340
add $r342 $r332 $r341
gt $r343 $r342 $r330
move $r344 $r328                        ; move parameter from branch to block argument
move $r345 $r330                        ; move parameter from branch to block argument
jnzi $r343 .64
ji  .65
.64
movi $r346 i2                           ; initialize constant into register
mul $r347 $r330 $r346
add $r348 $r347 $r341
aloc $r348
mcp $hp $r328 $r332
move $r344 $hp                          ; move parameter from branch to block argument
move $r345 $r348                        ; move parameter from branch to block argument
.65
move $r353 $r344                        ; move parameter from branch to block argument
move $r355 $r345                        ; move parameter from branch to block argument
addi $r356 $$locbase i544               ; get offset to local __ptr slice
mcpi $r356 $r334 i16                    ; copy memory
add $r357 $r353 $r332
lw $r359 $$locbase i69
sw $r357 $r359 i0
addi $r357 $r357 i8
lw $r358 $$locbase i68
mcp $r357 $r358 $r359
addi $r360 $r332 i8
add $r360 $r360 $r359
move $r361 $r360                        ; return value from ASM block with return register new_len
addi $r362 $$locbase i584               ; get offset to local __ptr { ptr, u64, u64 }
sw $$locbase $r353 i73                  ; store word
sw $$locbase $r355 i74                  ; store word
sw $$locbase $r361 i75                  ; store word
addi $r366 $$locbase i224               ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r366 $r362 i24                    ; copy memory
mcpi $r323 $r366 i24                    ; copy memory
addi $r367 $$locbase i1320              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r367 $r323 i24                    ; copy memory
addi $r368 $$locbase i1472              ; get offset to local __ptr { u64, u64, u64, u8, { { ptr, u64 }, u64 }, slice, u256 }
addi $r369 $r368 i72                    ; get offset to aggregate element
addi $r370 $$locbase i1320              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r371 $$locbase i1640              ; get offset to local __ptr u256
mcpi $r371 $r369 i32                    ; copy memory
addi $r372 $$locbase i1152              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r372 $r370 i24                    ; copy memory
addi $r373 $$locbase i832               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r374 $$locbase i1152              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r376 $$locbase i248               ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r376 $r374 i24                    ; copy memory
addi $r377 $$locbase i384               ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r377 $r376 i24                    ; copy memory
lw $r378 $$locbase i48                  ; load word
lw $r380 $$locbase i49                  ; load word
lw $r382 $$locbase i50                  ; load word
addi $r383 $$locbase i1640              ; get offset to local __ptr u256
movi $r384 i32                          ; initialize constant into register
add $r385 $r382 $r384
gt $r386 $r385 $r380
move $r387 $r378                        ; move parameter from branch to block argument
move $r388 $r380                        ; move parameter from branch to block argument
jnzi $r386 .66
ji  .67
.66
movi $r389 i2                           ; initialize constant into register
mul $r390 $r380 $r389
movi $r391 i32                          ; initialize constant into register
add $r392 $r390 $r391
aloc $r392
mcp $hp $r378 $r382
move $r387 $hp                          ; move parameter from branch to block argument
move $r388 $r392                        ; move parameter from branch to block argument
.67
move $r397 $r387                        ; move parameter from branch to block argument
move $r399 $r388                        ; move parameter from branch to block argument
addi $r400 $$locbase i464               ; get offset to local __ptr u256
mcpi $r400 $r383 i32                    ; copy memory
add $r401 $r397 $r382
mcpi $r401 $r400 i32                    ; copy memory
addi $r402 $$locbase i560               ; get offset to local __ptr { ptr, u64, u64 }
sw $$locbase $r397 i70                  ; store word
sw $$locbase $r399 i71                  ; store word
sw $$locbase $r385 i72                  ; store word
addi $r406 $$locbase i72                ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r406 $r402 i24                    ; copy memory
mcpi $r373 $r406 i24                    ; copy memory
addi $r407 $$locbase i1344              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r407 $r373 i24                    ; copy memory
addi $r408 $$locbase i1344              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r409 $$locbase i984               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r409 $r408 i24                    ; copy memory
addi $r410 $$locbase i984               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r411 $$locbase i928               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r411 $r410 i24                    ; copy memory
addi $r412 $$locbase i720               ; get offset to local __ptr slice
move $$arg0 $r411                       ; [call]: pass argument 0
move $$arg1 $r412                       ; [call]: pass argument 1
fncall .10                              ; [call]: call as_raw_slice_7
addi $r414 $$locbase i952               ; get offset to local __ptr slice
mcpi $r414 $r412 i16                    ; copy memory
move $r415 $r414                        ; move parameter from branch to block argument
ji  .68
.62
addi $r416 $$locbase i1600              ; get offset to local __ptr { { ptr, u64 }, u64 }
addi $r417 $$locbase i1576              ; get offset to local __ptr { { ptr, u64 }, u64 }
mcpi $r417 $r416 i24                    ; copy memory
lw $r419 $$locbase i197                 ; load word
movi $r420 i8                           ; initialize constant into register
mul $r421 $r420 $r314
add $r422 $r419 $r421
lw $r423 $r422 i0                       ; lw val ptr i0
move $r424 $r423                        ; return value from ASM block with return register val
addi $r425 $$locbase i1200              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r426 $$locbase i904               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r426 $r425 i24                    ; copy memory
addi $r427 $$locbase i672               ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r424                       ; [call]: pass argument 0
move $$arg1 $r426                       ; [call]: pass argument 1
move $$arg2 $r427                       ; [call]: pass argument 2
fncall .6                               ; [call]: call abi_encode_5
addi $r429 $$locbase i1200              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r429 $r427 i24                    ; copy memory
add $r430 $r314 $one
move $r312 $r430                        ; move parameter from branch to block argument
ji  .61
.53
addi $r432 $$locbase i968               ; get offset to local __ptr { __ptr { u64, u64, u64, u8, { { ptr, u64 }, u64 }, slice, u256 }, u64 }
sw $$locbase $r152 i121                 ; store word
movi $r434 i104                         ; initialize constant into register
sw $$locbase $r434 i122                 ; store word
addi $r435 $$locbase i272               ; get offset to local __ptr { __ptr { u64, u64, u64, u8, { { ptr, u64 }, u64 }, slice, u256 }, u64 }
mcpi $r435 $r432 i16                    ; copy memory
addi $r436 $$locbase i952               ; get offset to local __ptr slice
mcpi $r436 $r435 i16                    ; copy memory
move $r415 $r436                        ; move parameter from branch to block argument
.68
addi $r440 $$locbase i608               ; get offset to local __ptr slice
mcpi $r440 $r415 i16                    ; copy memory
load $r441 data_NonConfigurable_3       ; load constant from data section
lw $r442 $$locbase i76                  ; load slice pointer for logging data
lw $r443 $$locbase i77                  ; load slice size for logging data
logd $zero $r441 $r442 $r443            ; log slice
.15
cfsi i1672                              ; free 1672 bytes for locals and 0 slots for extra call arguments
move $$reta $r150                       ; restore return address
popa .14                                ; restore all registers
jal $zero $$reta i0                     ; return from call
DIFF------------------------------
.program:
.14                                     ; --- start of function: local_log_21 ---
pusha .14                               ; save all registers
move $$locbase $sp                      ; save locals base register for function local_log_21
cfei i1672                              ; allocate 1672 bytes for locals and 0 slots for call arguments
move $r150 $$reta                       ; save return address
.42
addi $r151 $$locbase i1368              ; get offset to local __ptr { u64, u64, u64, u8, { { ptr, u64 }, u64 }, slice, u256 }
mcpi $r151 $$arg0 i104                  ; copy memory
addi $r152 $$locbase i1368              ; get offset to local __ptr { u64, u64, u64, u8, { { ptr, u64 }, u64 }, slice, u256 }
.44
movi $r157 i0                           ; move parameter from branch to block argument
.46
 move $r161 $r157                        ; move parameter from branch to block argument
 jnzi $r157 .47
 movi $r161 i0                           ; move parameter from branch to block argument
 
ji  .48
.47
 movi $r161 i0                           ; move parameter from branch to block argument
                                         ; move parameter from branch to block argument
.48
move $r165 $r161                        ; move parameter from branch to block argument
jnzi $r161 .49
ji  .50
.49
movi $r165 i0                           ; move parameter from branch to block argument
.50
move $r169 $r165                        ; move parameter from branch to block argument
jnzi $r165 .51
ji  .52
.51
movi $r169 i1                           ; move parameter from branch to block argument
.52
jnzi $r169 .53
.54
addi $r173 $$locbase i696               ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r173                       ; [call]: pass argument 0
fncall .8                               ; [call]: call new_6
addi $r175 $$locbase i1472              ; get offset to local __ptr { u64, u64, u64, u8, { { ptr, u64 }, u64 }, slice, u256 }
mcpi $r175 $r152 i104                   ; copy memory
addi $r176 $$locbase i1008              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r176 $r173 i24                    ; copy memory
lw $r178 $$locbase i184                 ; load word
addi $r179 $$locbase i1008              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r180 $$locbase i856               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r180 $r179 i24                    ; copy memory
addi $r181 $$locbase i624               ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r178                       ; [call]: pass argument 0
move $$arg1 $r180                       ; [call]: pass argument 1
move $$arg2 $r181                       ; [call]: pass argument 2
fncall .6                               ; [call]: call abi_encode_5
addi $r183 $$locbase i1176              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r183 $r181 i24                    ; copy memory
addi $r184 $$locbase i1472              ; get offset to local __ptr { u64, u64, u64, u8, { { ptr, u64 }, u64 }, slice, u256 }
addi $r185 $r184 i8                     ; get offset to aggregate element
addi $r186 $$locbase i1176              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r187 $$locbase i1032              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r187 $r186 i24                    ; copy memory
addi $r188 $$locbase i736               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r189 $$locbase i1032              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $$locbase $r189 i24                ; copy memory
addi $r191 $$locbase i288               ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r191 $$locbase i24                ; copy memory
lw $r192 $$locbase i36                  ; load word
lw $r194 $$locbase i37                  ; load word
lw $r196 $$locbase i38                  ; load word
movi $r197 i4                           ; initialize constant into register
add $r198 $r196 $r197
gt $r199 $r198 $r194
move $r200 $r192                        ; move parameter from branch to block argument
move $r201 $r194                        ; move parameter from branch to block argument
jnzi $r199 .55
ji  .56
.55
movi $r202 i2                           ; initialize constant into register
mul $r203 $r194 $r202
movi $r204 i4                           ; initialize constant into register
add $r205 $r203 $r204
aloc $r205
mcp $hp $r192 $r196
move $r200 $hp                          ; move parameter from branch to block argument
move $r201 $r205                        ; move parameter from branch to block argument
.56
move $r210 $r200                        ; move parameter from branch to block argument
move $r212 $r201                        ; move parameter from branch to block argument
addi $r213 $$locbase i408               ; get offset to local __ptr u64
mcpi $r213 $r185 i8                     ; copy memory
movi $r214 i4                           ; initialize constant into register
add $r215 $r213 $r214
add $r216 $r210 $r196
mcpi $r216 $r215 i4                     ; copy memory
addi $r217 $$locbase i496               ; get offset to local __ptr { ptr, u64, u64 }
sw $$locbase $r210 i62                  ; store word
sw $$locbase $r212 i63                  ; store word
sw $$locbase $r198 i64                  ; store word
addi $r221 $$locbase i24                ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r221 $r217 i24                    ; copy memory
mcpi $r188 $r221 i24                    ; copy memory
addi $r222 $$locbase i1224              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r222 $r188 i24                    ; copy memory
addi $r223 $$locbase i1472              ; get offset to local __ptr { u64, u64, u64, u8, { { ptr, u64 }, u64 }, slice, u256 }
addi $r224 $r223 i16                    ; get offset to aggregate element
addi $r225 $$locbase i1224              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r226 $$locbase i1056              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r226 $r225 i24                    ; copy memory
addi $r227 $$locbase i760               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r228 $$locbase i1056              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r230 $$locbase i48                ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r230 $r228 i24                    ; copy memory
addi $r231 $$locbase i312               ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r231 $r230 i24                    ; copy memory
lw $r232 $$locbase i39                  ; load word
lw $r234 $$locbase i40                  ; load word
lw $r236 $$locbase i41                  ; load word
movi $r237 i2                           ; initialize constant into register
add $r238 $r236 $r237
gt $r239 $r238 $r234
move $r240 $r232                        ; move parameter from branch to block argument
move $r241 $r234                        ; move parameter from branch to block argument
jnzi $r239 .57
ji  .58
.57
movi $r242 i2                           ; initialize constant into register
mul $r243 $r234 $r242
movi $r244 i2                           ; initialize constant into register
add $r245 $r243 $r244
aloc $r245
mcp $hp $r232 $r236
move $r240 $hp                          ; move parameter from branch to block argument
move $r241 $r245                        ; move parameter from branch to block argument
.58
move $r250 $r240                        ; move parameter from branch to block argument
move $r252 $r241                        ; move parameter from branch to block argument
addi $r253 $$locbase i416               ; get offset to local __ptr u64
mcpi $r253 $r224 i8                     ; copy memory
movi $r254 i6                           ; initialize constant into register
add $r255 $r253 $r254
add $r256 $r250 $r236
mcpi $r256 $r255 i2                     ; copy memory
addi $r257 $$locbase i520               ; get offset to local __ptr { ptr, u64, u64 }
sw $$locbase $r250 i65                  ; store word
sw $$locbase $r252 i66                  ; store word
sw $$locbase $r238 i67                  ; store word
addi $r261 $$locbase i96                ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r261 $r257 i24                    ; copy memory
mcpi $r227 $r261 i24                    ; copy memory
addi $r262 $$locbase i1248              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r262 $r227 i24                    ; copy memory
addi $r263 $$locbase i1472              ; get offset to local __ptr { u64, u64, u64, u8, { { ptr, u64 }, u64 }, slice, u256 }
addi $r264 $r263 i24                    ; get offset to aggregate element
lb $r265 $r264 i0                       ; load byte
addi $r266 $$locbase i1248              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r267 $$locbase i1080              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r267 $r266 i24                    ; copy memory
addi $r268 $$locbase i784               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r269 $$locbase i1080              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r271 $$locbase i120               ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r271 $r269 i24                    ; copy memory
addi $r272 $$locbase i336               ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r272 $r271 i24                    ; copy memory
lw $r273 $$locbase i42                  ; load word
lw $r275 $$locbase i43                  ; load word
lw $r277 $$locbase i44                  ; load word
add $r278 $r277 $one
gt $r279 $r278 $r275
move $r280 $r273                        ; move parameter from branch to block argument
move $r281 $r275                        ; move parameter from branch to block argument
jnzi $r279 .59
ji  .60
.59
movi $r282 i2                           ; initialize constant into register
mul $r283 $r275 $r282
add $r284 $r283 $one
aloc $r284
mcp $hp $r273 $r277
move $r280 $hp                          ; move parameter from branch to block argument
move $r281 $r284                        ; move parameter from branch to block argument
.60
move $r289 $r280                        ; move parameter from branch to block argument
move $r291 $r281                        ; move parameter from branch to block argument
add $r292 $r280 $r277
sb $r292 $r265 i0                       ; store byte
addi $r293 $$locbase i424               ; get offset to local __ptr { ptr, u64, u64 }
sw $$locbase $r289 i53                  ; store word
sw $$locbase $r291 i54                  ; store word
sw $$locbase $r278 i55                  ; store word
addi $r297 $$locbase i144               ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r297 $r293 i24                    ; copy memory
mcpi $r268 $r297 i24                    ; copy memory
addi $r298 $$locbase i1272              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r298 $r268 i24                    ; copy memory
addi $r299 $$locbase i1472              ; get offset to local __ptr { u64, u64, u64, u8, { { ptr, u64 }, u64 }, slice, u256 }
addi $r300 $r299 i32                    ; get offset to aggregate element
addi $r301 $$locbase i1272              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r302 $$locbase i1600              ; get offset to local __ptr { { ptr, u64 }, u64 }
mcpi $r302 $r300 i24                    ; copy memory
addi $r303 $$locbase i1104              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r303 $r301 i24                    ; copy memory
lw $r306 $$locbase i202                 ; load word
addi $r307 $$locbase i1104              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r308 $$locbase i880               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r308 $r307 i24                    ; copy memory
addi $r309 $$locbase i648               ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r306                       ; [call]: pass argument 0
move $$arg1 $r308                       ; [call]: pass argument 1
move $$arg2 $r309                       ; [call]: pass argument 2
fncall .6                               ; [call]: call abi_encode_5
addi $r311 $$locbase i1200              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r311 $r309 i24                    ; copy memory
movi $r312 i0                           ; move parameter from branch to block argument
.61
move $r314 $r312                        ; move parameter from branch to block argument
lt $r315 $r312 $r306
jnzi $r315 .62
.63
addi $r316 $$locbase i1200              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r317 $$locbase i1296              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r317 $r316 i24                    ; copy memory
addi $r318 $$locbase i1472              ; get offset to local __ptr { u64, u64, u64, u8, { { ptr, u64 }, u64 }, slice, u256 }
addi $r319 $r318 i56                    ; get offset to aggregate element
addi $r320 $$locbase i1296              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r321 $$locbase i1624              ; get offset to local __ptr slice
mcpi $r321 $r319 i16                    ; copy memory
addi $r322 $$locbase i1128              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r322 $r320 i24                    ; copy memory
addi $r323 $$locbase i808               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r324 $$locbase i1128              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r326 $$locbase i168               ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r326 $r324 i24                    ; copy memory
addi $r327 $$locbase i360               ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r327 $r326 i24                    ; copy memory
lw $r328 $$locbase i45                  ; load word
lw $r330 $$locbase i46                  ; load word
lw $r332 $$locbase i47                  ; load word
addi $r333 $$locbase i1624              ; get offset to local __ptr slice
addi $r334 $$locbase i208               ; get offset to local __ptr slice
mcpi $r334 $r333 i16                    ; copy memory
addi $r336 $$locbase i192               ; get offset to local __ptr { u64, u64 }
mcpi $r336 $r333 i16                    ; copy memory
addi $r337 $$locbase i448               ; get offset to local __ptr { u64, u64 }
mcpi $r337 $r336 i16                    ; copy memory
lw $r339 $$locbase i57                  ; load word
movi $r340 i8                           ; initialize constant into register
add $r341 $r339 $r340
add $r342 $r332 $r341
gt $r343 $r342 $r330
move $r344 $r328                        ; move parameter from branch to block argument
move $r345 $r330                        ; move parameter from branch to block argument
jnzi $r343 .64
ji  .65
.64
movi $r346 i2                           ; initialize constant into register
mul $r347 $r330 $r346
add $r348 $r347 $r341
aloc $r348
mcp $hp $r328 $r332
move $r344 $hp                          ; move parameter from branch to block argument
move $r345 $r348                        ; move parameter from branch to block argument
.65
move $r353 $r344                        ; move parameter from branch to block argument
move $r355 $r345                        ; move parameter from branch to block argument
addi $r356 $$locbase i544               ; get offset to local __ptr slice
mcpi $r356 $r334 i16                    ; copy memory
add $r357 $r353 $r332
lw $r359 $$locbase i69
sw $r357 $r359 i0
addi $r357 $r357 i8
lw $r358 $$locbase i68
mcp $r357 $r358 $r359
addi $r360 $r332 i8
add $r360 $r360 $r359
move $r361 $r360                        ; return value from ASM block with return register new_len
addi $r362 $$locbase i584               ; get offset to local __ptr { ptr, u64, u64 }
sw $$locbase $r353 i73                  ; store word
sw $$locbase $r355 i74                  ; store word
sw $$locbase $r361 i75                  ; store word
addi $r366 $$locbase i224               ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r366 $r362 i24                    ; copy memory
mcpi $r323 $r366 i24                    ; copy memory
addi $r367 $$locbase i1320              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r367 $r323 i24                    ; copy memory
addi $r368 $$locbase i1472              ; get offset to local __ptr { u64, u64, u64, u8, { { ptr, u64 }, u64 }, slice, u256 }
addi $r369 $r368 i72                    ; get offset to aggregate element
addi $r370 $$locbase i1320              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r371 $$locbase i1640              ; get offset to local __ptr u256
mcpi $r371 $r369 i32                    ; copy memory
addi $r372 $$locbase i1152              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r372 $r370 i24                    ; copy memory
addi $r373 $$locbase i832               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r374 $$locbase i1152              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r376 $$locbase i248               ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r376 $r374 i24                    ; copy memory
addi $r377 $$locbase i384               ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r377 $r376 i24                    ; copy memory
lw $r378 $$locbase i48                  ; load word
lw $r380 $$locbase i49                  ; load word
lw $r382 $$locbase i50                  ; load word
addi $r383 $$locbase i1640              ; get offset to local __ptr u256
movi $r384 i32                          ; initialize constant into register
add $r385 $r382 $r384
gt $r386 $r385 $r380
move $r387 $r378                        ; move parameter from branch to block argument
move $r388 $r380                        ; move parameter from branch to block argument
jnzi $r386 .66
ji  .67
.66
movi $r389 i2                           ; initialize constant into register
mul $r390 $r380 $r389
movi $r391 i32                          ; initialize constant into register
add $r392 $r390 $r391
aloc $r392
mcp $hp $r378 $r382
move $r387 $hp                          ; move parameter from branch to block argument
move $r388 $r392                        ; move parameter from branch to block argument
.67
move $r397 $r387                        ; move parameter from branch to block argument
move $r399 $r388                        ; move parameter from branch to block argument
addi $r400 $$locbase i464               ; get offset to local __ptr u256
mcpi $r400 $r383 i32                    ; copy memory
add $r401 $r397 $r382
mcpi $r401 $r400 i32                    ; copy memory
addi $r402 $$locbase i560               ; get offset to local __ptr { ptr, u64, u64 }
sw $$locbase $r397 i70                  ; store word
sw $$locbase $r399 i71                  ; store word
sw $$locbase $r385 i72                  ; store word
addi $r406 $$locbase i72                ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r406 $r402 i24                    ; copy memory
mcpi $r373 $r406 i24                    ; copy memory
addi $r407 $$locbase i1344              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r407 $r373 i24                    ; copy memory
addi $r408 $$locbase i1344              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r409 $$locbase i984               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r409 $r408 i24                    ; copy memory
addi $r410 $$locbase i984               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r411 $$locbase i928               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r411 $r410 i24                    ; copy memory
addi $r412 $$locbase i720               ; get offset to local __ptr slice
move $$arg0 $r411                       ; [call]: pass argument 0
move $$arg1 $r412                       ; [call]: pass argument 1
fncall .10                              ; [call]: call as_raw_slice_7
addi $r414 $$locbase i952               ; get offset to local __ptr slice
mcpi $r414 $r412 i16                    ; copy memory
move $r415 $r414                        ; move parameter from branch to block argument
ji  .68
.62
addi $r416 $$locbase i1600              ; get offset to local __ptr { { ptr, u64 }, u64 }
addi $r417 $$locbase i1576              ; get offset to local __ptr { { ptr, u64 }, u64 }
mcpi $r417 $r416 i24                    ; copy memory
lw $r419 $$locbase i197                 ; load word
movi $r420 i8                           ; initialize constant into register
mul $r421 $r420 $r314
add $r422 $r419 $r421
lw $r423 $r422 i0                       ; lw val ptr i0
move $r424 $r423                        ; return value from ASM block with return register val
addi $r425 $$locbase i1200              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r426 $$locbase i904               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r426 $r425 i24                    ; copy memory
addi $r427 $$locbase i672               ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r424                       ; [call]: pass argument 0
move $$arg1 $r426                       ; [call]: pass argument 1
move $$arg2 $r427                       ; [call]: pass argument 2
fncall .6                               ; [call]: call abi_encode_5
addi $r429 $$locbase i1200              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r429 $r427 i24                    ; copy memory
add $r430 $r314 $one
move $r312 $r430                        ; move parameter from branch to block argument
ji  .61
.53
addi $r432 $$locbase i968               ; get offset to local __ptr { __ptr { u64, u64, u64, u8, { { ptr, u64 }, u64 }, slice, u256 }, u64 }
sw $$locbase $r152 i121                 ; store word
movi $r434 i104                         ; initialize constant into register
sw $$locbase $r434 i122                 ; store word
addi $r435 $$locbase i272               ; get offset to local __ptr { __ptr { u64, u64, u64, u8, { { ptr, u64 }, u64 }, slice, u256 }, u64 }
mcpi $r435 $r432 i16                    ; copy memory
addi $r436 $$locbase i952               ; get offset to local __ptr slice
mcpi $r436 $r435 i16                    ; copy memory
move $r415 $r436                        ; move parameter from branch to block argument
.68
addi $r440 $$locbase i608               ; get offset to local __ptr slice
mcpi $r440 $r415 i16                    ; copy memory
load $r441 data_NonConfigurable_3       ; load constant from data section
lw $r442 $$locbase i76                  ; load slice pointer for logging data
lw $r443 $$locbase i77                  ; load slice size for logging data
logd $zero $r441 $r442 $r443            ; log slice
.15
cfsi i1672                              ; free 1672 bytes for locals and 0 slots for extra call arguments
move $$reta $r150                       ; restore return address
popa .14                                ; restore all registers
jal $zero $$reta i0                     ; return from call
DIFF------------------------------
.program:
.14                                     ; --- start of function: local_log_21 ---
pusha .14                               ; save all registers
move $$locbase $sp                      ; save locals base register for function local_log_21
cfei i1672                              ; allocate 1672 bytes for locals and 0 slots for call arguments
move $r150 $$reta                       ; save return address
.42
addi $r151 $$locbase i1368              ; get offset to local __ptr { u64, u64, u64, u8, { { ptr, u64 }, u64 }, slice, u256 }
mcpi $r151 $$arg0 i104                  ; copy memory
addi $r152 $$locbase i1368              ; get offset to local __ptr { u64, u64, u64, u8, { { ptr, u64 }, u64 }, slice, u256 }
.44
.46
movi $r161 i0                           ; move parameter from branch to block argument
.48
 move $r165 $r161                        ; move parameter from branch to block argument
 jnzi $r161 .49
 movi $r165 i0                           ; move parameter from branch to block argument
 
ji  .50
.49
 movi $r165 i0                           ; move parameter from branch to block argument
                                         ; move parameter from branch to block argument
.50
move $r169 $r165                        ; move parameter from branch to block argument
jnzi $r165 .51
ji  .52
.51
movi $r169 i1                           ; move parameter from branch to block argument
.52
jnzi $r169 .53
.54
addi $r173 $$locbase i696               ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r173                       ; [call]: pass argument 0
fncall .8                               ; [call]: call new_6
addi $r175 $$locbase i1472              ; get offset to local __ptr { u64, u64, u64, u8, { { ptr, u64 }, u64 }, slice, u256 }
mcpi $r175 $r152 i104                   ; copy memory
addi $r176 $$locbase i1008              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r176 $r173 i24                    ; copy memory
lw $r178 $$locbase i184                 ; load word
addi $r179 $$locbase i1008              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r180 $$locbase i856               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r180 $r179 i24                    ; copy memory
addi $r181 $$locbase i624               ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r178                       ; [call]: pass argument 0
move $$arg1 $r180                       ; [call]: pass argument 1
move $$arg2 $r181                       ; [call]: pass argument 2
fncall .6                               ; [call]: call abi_encode_5
addi $r183 $$locbase i1176              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r183 $r181 i24                    ; copy memory
addi $r184 $$locbase i1472              ; get offset to local __ptr { u64, u64, u64, u8, { { ptr, u64 }, u64 }, slice, u256 }
addi $r185 $r184 i8                     ; get offset to aggregate element
addi $r186 $$locbase i1176              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r187 $$locbase i1032              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r187 $r186 i24                    ; copy memory
addi $r188 $$locbase i736               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r189 $$locbase i1032              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $$locbase $r189 i24                ; copy memory
addi $r191 $$locbase i288               ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r191 $$locbase i24                ; copy memory
lw $r192 $$locbase i36                  ; load word
lw $r194 $$locbase i37                  ; load word
lw $r196 $$locbase i38                  ; load word
movi $r197 i4                           ; initialize constant into register
add $r198 $r196 $r197
gt $r199 $r198 $r194
move $r200 $r192                        ; move parameter from branch to block argument
move $r201 $r194                        ; move parameter from branch to block argument
jnzi $r199 .55
ji  .56
.55
movi $r202 i2                           ; initialize constant into register
mul $r203 $r194 $r202
movi $r204 i4                           ; initialize constant into register
add $r205 $r203 $r204
aloc $r205
mcp $hp $r192 $r196
move $r200 $hp                          ; move parameter from branch to block argument
move $r201 $r205                        ; move parameter from branch to block argument
.56
move $r210 $r200                        ; move parameter from branch to block argument
move $r212 $r201                        ; move parameter from branch to block argument
addi $r213 $$locbase i408               ; get offset to local __ptr u64
mcpi $r213 $r185 i8                     ; copy memory
movi $r214 i4                           ; initialize constant into register
add $r215 $r213 $r214
add $r216 $r210 $r196
mcpi $r216 $r215 i4                     ; copy memory
addi $r217 $$locbase i496               ; get offset to local __ptr { ptr, u64, u64 }
sw $$locbase $r210 i62                  ; store word
sw $$locbase $r212 i63                  ; store word
sw $$locbase $r198 i64                  ; store word
addi $r221 $$locbase i24                ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r221 $r217 i24                    ; copy memory
mcpi $r188 $r221 i24                    ; copy memory
addi $r222 $$locbase i1224              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r222 $r188 i24                    ; copy memory
addi $r223 $$locbase i1472              ; get offset to local __ptr { u64, u64, u64, u8, { { ptr, u64 }, u64 }, slice, u256 }
addi $r224 $r223 i16                    ; get offset to aggregate element
addi $r225 $$locbase i1224              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r226 $$locbase i1056              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r226 $r225 i24                    ; copy memory
addi $r227 $$locbase i760               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r228 $$locbase i1056              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r230 $$locbase i48                ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r230 $r228 i24                    ; copy memory
addi $r231 $$locbase i312               ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r231 $r230 i24                    ; copy memory
lw $r232 $$locbase i39                  ; load word
lw $r234 $$locbase i40                  ; load word
lw $r236 $$locbase i41                  ; load word
movi $r237 i2                           ; initialize constant into register
add $r238 $r236 $r237
gt $r239 $r238 $r234
move $r240 $r232                        ; move parameter from branch to block argument
move $r241 $r234                        ; move parameter from branch to block argument
jnzi $r239 .57
ji  .58
.57
movi $r242 i2                           ; initialize constant into register
mul $r243 $r234 $r242
movi $r244 i2                           ; initialize constant into register
add $r245 $r243 $r244
aloc $r245
mcp $hp $r232 $r236
move $r240 $hp                          ; move parameter from branch to block argument
move $r241 $r245                        ; move parameter from branch to block argument
.58
move $r250 $r240                        ; move parameter from branch to block argument
move $r252 $r241                        ; move parameter from branch to block argument
addi $r253 $$locbase i416               ; get offset to local __ptr u64
mcpi $r253 $r224 i8                     ; copy memory
movi $r254 i6                           ; initialize constant into register
add $r255 $r253 $r254
add $r256 $r250 $r236
mcpi $r256 $r255 i2                     ; copy memory
addi $r257 $$locbase i520               ; get offset to local __ptr { ptr, u64, u64 }
sw $$locbase $r250 i65                  ; store word
sw $$locbase $r252 i66                  ; store word
sw $$locbase $r238 i67                  ; store word
addi $r261 $$locbase i96                ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r261 $r257 i24                    ; copy memory
mcpi $r227 $r261 i24                    ; copy memory
addi $r262 $$locbase i1248              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r262 $r227 i24                    ; copy memory
addi $r263 $$locbase i1472              ; get offset to local __ptr { u64, u64, u64, u8, { { ptr, u64 }, u64 }, slice, u256 }
addi $r264 $r263 i24                    ; get offset to aggregate element
lb $r265 $r264 i0                       ; load byte
addi $r266 $$locbase i1248              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r267 $$locbase i1080              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r267 $r266 i24                    ; copy memory
addi $r268 $$locbase i784               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r269 $$locbase i1080              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r271 $$locbase i120               ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r271 $r269 i24                    ; copy memory
addi $r272 $$locbase i336               ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r272 $r271 i24                    ; copy memory
lw $r273 $$locbase i42                  ; load word
lw $r275 $$locbase i43                  ; load word
lw $r277 $$locbase i44                  ; load word
add $r278 $r277 $one
gt $r279 $r278 $r275
move $r280 $r273                        ; move parameter from branch to block argument
move $r281 $r275                        ; move parameter from branch to block argument
jnzi $r279 .59
ji  .60
.59
movi $r282 i2                           ; initialize constant into register
mul $r283 $r275 $r282
add $r284 $r283 $one
aloc $r284
mcp $hp $r273 $r277
move $r280 $hp                          ; move parameter from branch to block argument
move $r281 $r284                        ; move parameter from branch to block argument
.60
move $r289 $r280                        ; move parameter from branch to block argument
move $r291 $r281                        ; move parameter from branch to block argument
add $r292 $r280 $r277
sb $r292 $r265 i0                       ; store byte
addi $r293 $$locbase i424               ; get offset to local __ptr { ptr, u64, u64 }
sw $$locbase $r289 i53                  ; store word
sw $$locbase $r291 i54                  ; store word
sw $$locbase $r278 i55                  ; store word
addi $r297 $$locbase i144               ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r297 $r293 i24                    ; copy memory
mcpi $r268 $r297 i24                    ; copy memory
addi $r298 $$locbase i1272              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r298 $r268 i24                    ; copy memory
addi $r299 $$locbase i1472              ; get offset to local __ptr { u64, u64, u64, u8, { { ptr, u64 }, u64 }, slice, u256 }
addi $r300 $r299 i32                    ; get offset to aggregate element
addi $r301 $$locbase i1272              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r302 $$locbase i1600              ; get offset to local __ptr { { ptr, u64 }, u64 }
mcpi $r302 $r300 i24                    ; copy memory
addi $r303 $$locbase i1104              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r303 $r301 i24                    ; copy memory
lw $r306 $$locbase i202                 ; load word
addi $r307 $$locbase i1104              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r308 $$locbase i880               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r308 $r307 i24                    ; copy memory
addi $r309 $$locbase i648               ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r306                       ; [call]: pass argument 0
move $$arg1 $r308                       ; [call]: pass argument 1
move $$arg2 $r309                       ; [call]: pass argument 2
fncall .6                               ; [call]: call abi_encode_5
addi $r311 $$locbase i1200              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r311 $r309 i24                    ; copy memory
movi $r312 i0                           ; move parameter from branch to block argument
.61
move $r314 $r312                        ; move parameter from branch to block argument
lt $r315 $r312 $r306
jnzi $r315 .62
.63
addi $r316 $$locbase i1200              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r317 $$locbase i1296              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r317 $r316 i24                    ; copy memory
addi $r318 $$locbase i1472              ; get offset to local __ptr { u64, u64, u64, u8, { { ptr, u64 }, u64 }, slice, u256 }
addi $r319 $r318 i56                    ; get offset to aggregate element
addi $r320 $$locbase i1296              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r321 $$locbase i1624              ; get offset to local __ptr slice
mcpi $r321 $r319 i16                    ; copy memory
addi $r322 $$locbase i1128              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r322 $r320 i24                    ; copy memory
addi $r323 $$locbase i808               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r324 $$locbase i1128              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r326 $$locbase i168               ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r326 $r324 i24                    ; copy memory
addi $r327 $$locbase i360               ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r327 $r326 i24                    ; copy memory
lw $r328 $$locbase i45                  ; load word
lw $r330 $$locbase i46                  ; load word
lw $r332 $$locbase i47                  ; load word
addi $r333 $$locbase i1624              ; get offset to local __ptr slice
addi $r334 $$locbase i208               ; get offset to local __ptr slice
mcpi $r334 $r333 i16                    ; copy memory
addi $r336 $$locbase i192               ; get offset to local __ptr { u64, u64 }
mcpi $r336 $r333 i16                    ; copy memory
addi $r337 $$locbase i448               ; get offset to local __ptr { u64, u64 }
mcpi $r337 $r336 i16                    ; copy memory
lw $r339 $$locbase i57                  ; load word
movi $r340 i8                           ; initialize constant into register
add $r341 $r339 $r340
add $r342 $r332 $r341
gt $r343 $r342 $r330
move $r344 $r328                        ; move parameter from branch to block argument
move $r345 $r330                        ; move parameter from branch to block argument
jnzi $r343 .64
ji  .65
.64
movi $r346 i2                           ; initialize constant into register
mul $r347 $r330 $r346
add $r348 $r347 $r341
aloc $r348
mcp $hp $r328 $r332
move $r344 $hp                          ; move parameter from branch to block argument
move $r345 $r348                        ; move parameter from branch to block argument
.65
move $r353 $r344                        ; move parameter from branch to block argument
move $r355 $r345                        ; move parameter from branch to block argument
addi $r356 $$locbase i544               ; get offset to local __ptr slice
mcpi $r356 $r334 i16                    ; copy memory
add $r357 $r353 $r332
lw $r359 $$locbase i69
sw $r357 $r359 i0
addi $r357 $r357 i8
lw $r358 $$locbase i68
mcp $r357 $r358 $r359
addi $r360 $r332 i8
add $r360 $r360 $r359
move $r361 $r360                        ; return value from ASM block with return register new_len
addi $r362 $$locbase i584               ; get offset to local __ptr { ptr, u64, u64 }
sw $$locbase $r353 i73                  ; store word
sw $$locbase $r355 i74                  ; store word
sw $$locbase $r361 i75                  ; store word
addi $r366 $$locbase i224               ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r366 $r362 i24                    ; copy memory
mcpi $r323 $r366 i24                    ; copy memory
addi $r367 $$locbase i1320              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r367 $r323 i24                    ; copy memory
addi $r368 $$locbase i1472              ; get offset to local __ptr { u64, u64, u64, u8, { { ptr, u64 }, u64 }, slice, u256 }
addi $r369 $r368 i72                    ; get offset to aggregate element
addi $r370 $$locbase i1320              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r371 $$locbase i1640              ; get offset to local __ptr u256
mcpi $r371 $r369 i32                    ; copy memory
addi $r372 $$locbase i1152              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r372 $r370 i24                    ; copy memory
addi $r373 $$locbase i832               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r374 $$locbase i1152              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r376 $$locbase i248               ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r376 $r374 i24                    ; copy memory
addi $r377 $$locbase i384               ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r377 $r376 i24                    ; copy memory
lw $r378 $$locbase i48                  ; load word
lw $r380 $$locbase i49                  ; load word
lw $r382 $$locbase i50                  ; load word
addi $r383 $$locbase i1640              ; get offset to local __ptr u256
movi $r384 i32                          ; initialize constant into register
add $r385 $r382 $r384
gt $r386 $r385 $r380
move $r387 $r378                        ; move parameter from branch to block argument
move $r388 $r380                        ; move parameter from branch to block argument
jnzi $r386 .66
ji  .67
.66
movi $r389 i2                           ; initialize constant into register
mul $r390 $r380 $r389
movi $r391 i32                          ; initialize constant into register
add $r392 $r390 $r391
aloc $r392
mcp $hp $r378 $r382
move $r387 $hp                          ; move parameter from branch to block argument
move $r388 $r392                        ; move parameter from branch to block argument
.67
move $r397 $r387                        ; move parameter from branch to block argument
move $r399 $r388                        ; move parameter from branch to block argument
addi $r400 $$locbase i464               ; get offset to local __ptr u256
mcpi $r400 $r383 i32                    ; copy memory
add $r401 $r397 $r382
mcpi $r401 $r400 i32                    ; copy memory
addi $r402 $$locbase i560               ; get offset to local __ptr { ptr, u64, u64 }
sw $$locbase $r397 i70                  ; store word
sw $$locbase $r399 i71                  ; store word
sw $$locbase $r385 i72                  ; store word
addi $r406 $$locbase i72                ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r406 $r402 i24                    ; copy memory
mcpi $r373 $r406 i24                    ; copy memory
addi $r407 $$locbase i1344              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r407 $r373 i24                    ; copy memory
addi $r408 $$locbase i1344              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r409 $$locbase i984               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r409 $r408 i24                    ; copy memory
addi $r410 $$locbase i984               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r411 $$locbase i928               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r411 $r410 i24                    ; copy memory
addi $r412 $$locbase i720               ; get offset to local __ptr slice
move $$arg0 $r411                       ; [call]: pass argument 0
move $$arg1 $r412                       ; [call]: pass argument 1
fncall .10                              ; [call]: call as_raw_slice_7
addi $r414 $$locbase i952               ; get offset to local __ptr slice
mcpi $r414 $r412 i16                    ; copy memory
move $r415 $r414                        ; move parameter from branch to block argument
ji  .68
.62
addi $r416 $$locbase i1600              ; get offset to local __ptr { { ptr, u64 }, u64 }
addi $r417 $$locbase i1576              ; get offset to local __ptr { { ptr, u64 }, u64 }
mcpi $r417 $r416 i24                    ; copy memory
lw $r419 $$locbase i197                 ; load word
movi $r420 i8                           ; initialize constant into register
mul $r421 $r420 $r314
add $r422 $r419 $r421
lw $r423 $r422 i0                       ; lw val ptr i0
move $r424 $r423                        ; return value from ASM block with return register val
addi $r425 $$locbase i1200              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r426 $$locbase i904               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r426 $r425 i24                    ; copy memory
addi $r427 $$locbase i672               ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r424                       ; [call]: pass argument 0
move $$arg1 $r426                       ; [call]: pass argument 1
move $$arg2 $r427                       ; [call]: pass argument 2
fncall .6                               ; [call]: call abi_encode_5
addi $r429 $$locbase i1200              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r429 $r427 i24                    ; copy memory
add $r430 $r314 $one
move $r312 $r430                        ; move parameter from branch to block argument
ji  .61
.53
addi $r432 $$locbase i968               ; get offset to local __ptr { __ptr { u64, u64, u64, u8, { { ptr, u64 }, u64 }, slice, u256 }, u64 }
sw $$locbase $r152 i121                 ; store word
movi $r434 i104                         ; initialize constant into register
sw $$locbase $r434 i122                 ; store word
addi $r435 $$locbase i272               ; get offset to local __ptr { __ptr { u64, u64, u64, u8, { { ptr, u64 }, u64 }, slice, u256 }, u64 }
mcpi $r435 $r432 i16                    ; copy memory
addi $r436 $$locbase i952               ; get offset to local __ptr slice
mcpi $r436 $r435 i16                    ; copy memory
move $r415 $r436                        ; move parameter from branch to block argument
.68
addi $r440 $$locbase i608               ; get offset to local __ptr slice
mcpi $r440 $r415 i16                    ; copy memory
load $r441 data_NonConfigurable_3       ; load constant from data section
lw $r442 $$locbase i76                  ; load slice pointer for logging data
lw $r443 $$locbase i77                  ; load slice size for logging data
logd $zero $r441 $r442 $r443            ; log slice
.15
cfsi i1672                              ; free 1672 bytes for locals and 0 slots for extra call arguments
move $$reta $r150                       ; restore return address
popa .14                                ; restore all registers
jal $zero $$reta i0                     ; return from call
DIFF------------------------------
.program:
.14                                     ; --- start of function: local_log_21 ---
pusha .14                               ; save all registers
move $$locbase $sp                      ; save locals base register for function local_log_21
cfei i1672                              ; allocate 1672 bytes for locals and 0 slots for call arguments
move $r150 $$reta                       ; save return address
.42
addi $r151 $$locbase i1368              ; get offset to local __ptr { u64, u64, u64, u8, { { ptr, u64 }, u64 }, slice, u256 }
mcpi $r151 $$arg0 i104                  ; copy memory
addi $r152 $$locbase i1368              ; get offset to local __ptr { u64, u64, u64, u8, { { ptr, u64 }, u64 }, slice, u256 }
.44
.46
.48
movi $r165 i0                           ; move parameter from branch to block argument
.50
 move $r169 $r165                        ; move parameter from branch to block argument
 jnzi $r165 .51
 movi $r169 i0                           ; move parameter from branch to block argument
 
ji  .52
.51
movi $r169 i1                           ; move parameter from branch to block argument
.52
jnzi $r169 .53
.54
addi $r173 $$locbase i696               ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r173                       ; [call]: pass argument 0
fncall .8                               ; [call]: call new_6
addi $r175 $$locbase i1472              ; get offset to local __ptr { u64, u64, u64, u8, { { ptr, u64 }, u64 }, slice, u256 }
mcpi $r175 $r152 i104                   ; copy memory
addi $r176 $$locbase i1008              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r176 $r173 i24                    ; copy memory
lw $r178 $$locbase i184                 ; load word
addi $r179 $$locbase i1008              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r180 $$locbase i856               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r180 $r179 i24                    ; copy memory
addi $r181 $$locbase i624               ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r178                       ; [call]: pass argument 0
move $$arg1 $r180                       ; [call]: pass argument 1
move $$arg2 $r181                       ; [call]: pass argument 2
fncall .6                               ; [call]: call abi_encode_5
addi $r183 $$locbase i1176              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r183 $r181 i24                    ; copy memory
addi $r184 $$locbase i1472              ; get offset to local __ptr { u64, u64, u64, u8, { { ptr, u64 }, u64 }, slice, u256 }
addi $r185 $r184 i8                     ; get offset to aggregate element
addi $r186 $$locbase i1176              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r187 $$locbase i1032              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r187 $r186 i24                    ; copy memory
addi $r188 $$locbase i736               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r189 $$locbase i1032              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $$locbase $r189 i24                ; copy memory
addi $r191 $$locbase i288               ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r191 $$locbase i24                ; copy memory
lw $r192 $$locbase i36                  ; load word
lw $r194 $$locbase i37                  ; load word
lw $r196 $$locbase i38                  ; load word
movi $r197 i4                           ; initialize constant into register
add $r198 $r196 $r197
gt $r199 $r198 $r194
move $r200 $r192                        ; move parameter from branch to block argument
move $r201 $r194                        ; move parameter from branch to block argument
jnzi $r199 .55
ji  .56
.55
movi $r202 i2                           ; initialize constant into register
mul $r203 $r194 $r202
movi $r204 i4                           ; initialize constant into register
add $r205 $r203 $r204
aloc $r205
mcp $hp $r192 $r196
move $r200 $hp                          ; move parameter from branch to block argument
move $r201 $r205                        ; move parameter from branch to block argument
.56
move $r210 $r200                        ; move parameter from branch to block argument
move $r212 $r201                        ; move parameter from branch to block argument
addi $r213 $$locbase i408               ; get offset to local __ptr u64
mcpi $r213 $r185 i8                     ; copy memory
movi $r214 i4                           ; initialize constant into register
add $r215 $r213 $r214
add $r216 $r210 $r196
mcpi $r216 $r215 i4                     ; copy memory
addi $r217 $$locbase i496               ; get offset to local __ptr { ptr, u64, u64 }
sw $$locbase $r210 i62                  ; store word
sw $$locbase $r212 i63                  ; store word
sw $$locbase $r198 i64                  ; store word
addi $r221 $$locbase i24                ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r221 $r217 i24                    ; copy memory
mcpi $r188 $r221 i24                    ; copy memory
addi $r222 $$locbase i1224              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r222 $r188 i24                    ; copy memory
addi $r223 $$locbase i1472              ; get offset to local __ptr { u64, u64, u64, u8, { { ptr, u64 }, u64 }, slice, u256 }
addi $r224 $r223 i16                    ; get offset to aggregate element
addi $r225 $$locbase i1224              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r226 $$locbase i1056              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r226 $r225 i24                    ; copy memory
addi $r227 $$locbase i760               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r228 $$locbase i1056              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r230 $$locbase i48                ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r230 $r228 i24                    ; copy memory
addi $r231 $$locbase i312               ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r231 $r230 i24                    ; copy memory
lw $r232 $$locbase i39                  ; load word
lw $r234 $$locbase i40                  ; load word
lw $r236 $$locbase i41                  ; load word
movi $r237 i2                           ; initialize constant into register
add $r238 $r236 $r237
gt $r239 $r238 $r234
move $r240 $r232                        ; move parameter from branch to block argument
move $r241 $r234                        ; move parameter from branch to block argument
jnzi $r239 .57
ji  .58
.57
movi $r242 i2                           ; initialize constant into register
mul $r243 $r234 $r242
movi $r244 i2                           ; initialize constant into register
add $r245 $r243 $r244
aloc $r245
mcp $hp $r232 $r236
move $r240 $hp                          ; move parameter from branch to block argument
move $r241 $r245                        ; move parameter from branch to block argument
.58
move $r250 $r240                        ; move parameter from branch to block argument
move $r252 $r241                        ; move parameter from branch to block argument
addi $r253 $$locbase i416               ; get offset to local __ptr u64
mcpi $r253 $r224 i8                     ; copy memory
movi $r254 i6                           ; initialize constant into register
add $r255 $r253 $r254
add $r256 $r250 $r236
mcpi $r256 $r255 i2                     ; copy memory
addi $r257 $$locbase i520               ; get offset to local __ptr { ptr, u64, u64 }
sw $$locbase $r250 i65                  ; store word
sw $$locbase $r252 i66                  ; store word
sw $$locbase $r238 i67                  ; store word
addi $r261 $$locbase i96                ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r261 $r257 i24                    ; copy memory
mcpi $r227 $r261 i24                    ; copy memory
addi $r262 $$locbase i1248              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r262 $r227 i24                    ; copy memory
addi $r263 $$locbase i1472              ; get offset to local __ptr { u64, u64, u64, u8, { { ptr, u64 }, u64 }, slice, u256 }
addi $r264 $r263 i24                    ; get offset to aggregate element
lb $r265 $r264 i0                       ; load byte
addi $r266 $$locbase i1248              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r267 $$locbase i1080              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r267 $r266 i24                    ; copy memory
addi $r268 $$locbase i784               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r269 $$locbase i1080              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r271 $$locbase i120               ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r271 $r269 i24                    ; copy memory
addi $r272 $$locbase i336               ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r272 $r271 i24                    ; copy memory
lw $r273 $$locbase i42                  ; load word
lw $r275 $$locbase i43                  ; load word
lw $r277 $$locbase i44                  ; load word
add $r278 $r277 $one
gt $r279 $r278 $r275
move $r280 $r273                        ; move parameter from branch to block argument
move $r281 $r275                        ; move parameter from branch to block argument
jnzi $r279 .59
ji  .60
.59
movi $r282 i2                           ; initialize constant into register
mul $r283 $r275 $r282
add $r284 $r283 $one
aloc $r284
mcp $hp $r273 $r277
move $r280 $hp                          ; move parameter from branch to block argument
move $r281 $r284                        ; move parameter from branch to block argument
.60
move $r289 $r280                        ; move parameter from branch to block argument
move $r291 $r281                        ; move parameter from branch to block argument
add $r292 $r280 $r277
sb $r292 $r265 i0                       ; store byte
addi $r293 $$locbase i424               ; get offset to local __ptr { ptr, u64, u64 }
sw $$locbase $r289 i53                  ; store word
sw $$locbase $r291 i54                  ; store word
sw $$locbase $r278 i55                  ; store word
addi $r297 $$locbase i144               ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r297 $r293 i24                    ; copy memory
mcpi $r268 $r297 i24                    ; copy memory
addi $r298 $$locbase i1272              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r298 $r268 i24                    ; copy memory
addi $r299 $$locbase i1472              ; get offset to local __ptr { u64, u64, u64, u8, { { ptr, u64 }, u64 }, slice, u256 }
addi $r300 $r299 i32                    ; get offset to aggregate element
addi $r301 $$locbase i1272              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r302 $$locbase i1600              ; get offset to local __ptr { { ptr, u64 }, u64 }
mcpi $r302 $r300 i24                    ; copy memory
addi $r303 $$locbase i1104              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r303 $r301 i24                    ; copy memory
lw $r306 $$locbase i202                 ; load word
addi $r307 $$locbase i1104              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r308 $$locbase i880               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r308 $r307 i24                    ; copy memory
addi $r309 $$locbase i648               ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r306                       ; [call]: pass argument 0
move $$arg1 $r308                       ; [call]: pass argument 1
move $$arg2 $r309                       ; [call]: pass argument 2
fncall .6                               ; [call]: call abi_encode_5
addi $r311 $$locbase i1200              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r311 $r309 i24                    ; copy memory
movi $r312 i0                           ; move parameter from branch to block argument
.61
move $r314 $r312                        ; move parameter from branch to block argument
lt $r315 $r312 $r306
jnzi $r315 .62
.63
addi $r316 $$locbase i1200              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r317 $$locbase i1296              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r317 $r316 i24                    ; copy memory
addi $r318 $$locbase i1472              ; get offset to local __ptr { u64, u64, u64, u8, { { ptr, u64 }, u64 }, slice, u256 }
addi $r319 $r318 i56                    ; get offset to aggregate element
addi $r320 $$locbase i1296              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r321 $$locbase i1624              ; get offset to local __ptr slice
mcpi $r321 $r319 i16                    ; copy memory
addi $r322 $$locbase i1128              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r322 $r320 i24                    ; copy memory
addi $r323 $$locbase i808               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r324 $$locbase i1128              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r326 $$locbase i168               ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r326 $r324 i24                    ; copy memory
addi $r327 $$locbase i360               ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r327 $r326 i24                    ; copy memory
lw $r328 $$locbase i45                  ; load word
lw $r330 $$locbase i46                  ; load word
lw $r332 $$locbase i47                  ; load word
addi $r333 $$locbase i1624              ; get offset to local __ptr slice
addi $r334 $$locbase i208               ; get offset to local __ptr slice
mcpi $r334 $r333 i16                    ; copy memory
addi $r336 $$locbase i192               ; get offset to local __ptr { u64, u64 }
mcpi $r336 $r333 i16                    ; copy memory
addi $r337 $$locbase i448               ; get offset to local __ptr { u64, u64 }
mcpi $r337 $r336 i16                    ; copy memory
lw $r339 $$locbase i57                  ; load word
movi $r340 i8                           ; initialize constant into register
add $r341 $r339 $r340
add $r342 $r332 $r341
gt $r343 $r342 $r330
move $r344 $r328                        ; move parameter from branch to block argument
move $r345 $r330                        ; move parameter from branch to block argument
jnzi $r343 .64
ji  .65
.64
movi $r346 i2                           ; initialize constant into register
mul $r347 $r330 $r346
add $r348 $r347 $r341
aloc $r348
mcp $hp $r328 $r332
move $r344 $hp                          ; move parameter from branch to block argument
move $r345 $r348                        ; move parameter from branch to block argument
.65
move $r353 $r344                        ; move parameter from branch to block argument
move $r355 $r345                        ; move parameter from branch to block argument
addi $r356 $$locbase i544               ; get offset to local __ptr slice
mcpi $r356 $r334 i16                    ; copy memory
add $r357 $r353 $r332
lw $r359 $$locbase i69
sw $r357 $r359 i0
addi $r357 $r357 i8
lw $r358 $$locbase i68
mcp $r357 $r358 $r359
addi $r360 $r332 i8
add $r360 $r360 $r359
move $r361 $r360                        ; return value from ASM block with return register new_len
addi $r362 $$locbase i584               ; get offset to local __ptr { ptr, u64, u64 }
sw $$locbase $r353 i73                  ; store word
sw $$locbase $r355 i74                  ; store word
sw $$locbase $r361 i75                  ; store word
addi $r366 $$locbase i224               ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r366 $r362 i24                    ; copy memory
mcpi $r323 $r366 i24                    ; copy memory
addi $r367 $$locbase i1320              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r367 $r323 i24                    ; copy memory
addi $r368 $$locbase i1472              ; get offset to local __ptr { u64, u64, u64, u8, { { ptr, u64 }, u64 }, slice, u256 }
addi $r369 $r368 i72                    ; get offset to aggregate element
addi $r370 $$locbase i1320              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r371 $$locbase i1640              ; get offset to local __ptr u256
mcpi $r371 $r369 i32                    ; copy memory
addi $r372 $$locbase i1152              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r372 $r370 i24                    ; copy memory
addi $r373 $$locbase i832               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r374 $$locbase i1152              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r376 $$locbase i248               ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r376 $r374 i24                    ; copy memory
addi $r377 $$locbase i384               ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r377 $r376 i24                    ; copy memory
lw $r378 $$locbase i48                  ; load word
lw $r380 $$locbase i49                  ; load word
lw $r382 $$locbase i50                  ; load word
addi $r383 $$locbase i1640              ; get offset to local __ptr u256
movi $r384 i32                          ; initialize constant into register
add $r385 $r382 $r384
gt $r386 $r385 $r380
move $r387 $r378                        ; move parameter from branch to block argument
move $r388 $r380                        ; move parameter from branch to block argument
jnzi $r386 .66
ji  .67
.66
movi $r389 i2                           ; initialize constant into register
mul $r390 $r380 $r389
movi $r391 i32                          ; initialize constant into register
add $r392 $r390 $r391
aloc $r392
mcp $hp $r378 $r382
move $r387 $hp                          ; move parameter from branch to block argument
move $r388 $r392                        ; move parameter from branch to block argument
.67
move $r397 $r387                        ; move parameter from branch to block argument
move $r399 $r388                        ; move parameter from branch to block argument
addi $r400 $$locbase i464               ; get offset to local __ptr u256
mcpi $r400 $r383 i32                    ; copy memory
add $r401 $r397 $r382
mcpi $r401 $r400 i32                    ; copy memory
addi $r402 $$locbase i560               ; get offset to local __ptr { ptr, u64, u64 }
sw $$locbase $r397 i70                  ; store word
sw $$locbase $r399 i71                  ; store word
sw $$locbase $r385 i72                  ; store word
addi $r406 $$locbase i72                ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r406 $r402 i24                    ; copy memory
mcpi $r373 $r406 i24                    ; copy memory
addi $r407 $$locbase i1344              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r407 $r373 i24                    ; copy memory
addi $r408 $$locbase i1344              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r409 $$locbase i984               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r409 $r408 i24                    ; copy memory
addi $r410 $$locbase i984               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r411 $$locbase i928               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r411 $r410 i24                    ; copy memory
addi $r412 $$locbase i720               ; get offset to local __ptr slice
move $$arg0 $r411                       ; [call]: pass argument 0
move $$arg1 $r412                       ; [call]: pass argument 1
fncall .10                              ; [call]: call as_raw_slice_7
addi $r414 $$locbase i952               ; get offset to local __ptr slice
mcpi $r414 $r412 i16                    ; copy memory
move $r415 $r414                        ; move parameter from branch to block argument
ji  .68
.62
addi $r416 $$locbase i1600              ; get offset to local __ptr { { ptr, u64 }, u64 }
addi $r417 $$locbase i1576              ; get offset to local __ptr { { ptr, u64 }, u64 }
mcpi $r417 $r416 i24                    ; copy memory
lw $r419 $$locbase i197                 ; load word
movi $r420 i8                           ; initialize constant into register
mul $r421 $r420 $r314
add $r422 $r419 $r421
lw $r423 $r422 i0                       ; lw val ptr i0
move $r424 $r423                        ; return value from ASM block with return register val
addi $r425 $$locbase i1200              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r426 $$locbase i904               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r426 $r425 i24                    ; copy memory
addi $r427 $$locbase i672               ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r424                       ; [call]: pass argument 0
move $$arg1 $r426                       ; [call]: pass argument 1
move $$arg2 $r427                       ; [call]: pass argument 2
fncall .6                               ; [call]: call abi_encode_5
addi $r429 $$locbase i1200              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r429 $r427 i24                    ; copy memory
add $r430 $r314 $one
move $r312 $r430                        ; move parameter from branch to block argument
ji  .61
.53
addi $r432 $$locbase i968               ; get offset to local __ptr { __ptr { u64, u64, u64, u8, { { ptr, u64 }, u64 }, slice, u256 }, u64 }
sw $$locbase $r152 i121                 ; store word
movi $r434 i104                         ; initialize constant into register
sw $$locbase $r434 i122                 ; store word
addi $r435 $$locbase i272               ; get offset to local __ptr { __ptr { u64, u64, u64, u8, { { ptr, u64 }, u64 }, slice, u256 }, u64 }
mcpi $r435 $r432 i16                    ; copy memory
addi $r436 $$locbase i952               ; get offset to local __ptr slice
mcpi $r436 $r435 i16                    ; copy memory
move $r415 $r436                        ; move parameter from branch to block argument
.68
addi $r440 $$locbase i608               ; get offset to local __ptr slice
mcpi $r440 $r415 i16                    ; copy memory
load $r441 data_NonConfigurable_3       ; load constant from data section
lw $r442 $$locbase i76                  ; load slice pointer for logging data
lw $r443 $$locbase i77                  ; load slice size for logging data
logd $zero $r441 $r442 $r443            ; log slice
.15
cfsi i1672                              ; free 1672 bytes for locals and 0 slots for extra call arguments
move $$reta $r150                       ; restore return address
popa .14                                ; restore all registers
jal $zero $$reta i0                     ; return from call
DIFF------------------------------
.program:
.14                                     ; --- start of function: local_log_21 ---
pusha .14                               ; save all registers
move $$locbase $sp                      ; save locals base register for function local_log_21
cfei i1672                              ; allocate 1672 bytes for locals and 0 slots for call arguments
move $r150 $$reta                       ; save return address
.42
addi $r151 $$locbase i1368              ; get offset to local __ptr { u64, u64, u64, u8, { { ptr, u64 }, u64 }, slice, u256 }
mcpi $r151 $$arg0 i104                  ; copy memory
addi $r152 $$locbase i1368              ; get offset to local __ptr { u64, u64, u64, u8, { { ptr, u64 }, u64 }, slice, u256 }
.44
.46
.48
.50
movi $r169 i0                           ; move parameter from branch to block argument
.52
 jnzi $r169 .53
 
.54
addi $r173 $$locbase i696               ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r173                       ; [call]: pass argument 0
fncall .8                               ; [call]: call new_6
addi $r175 $$locbase i1472              ; get offset to local __ptr { u64, u64, u64, u8, { { ptr, u64 }, u64 }, slice, u256 }
mcpi $r175 $r152 i104                   ; copy memory
addi $r176 $$locbase i1008              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r176 $r173 i24                    ; copy memory
lw $r178 $$locbase i184                 ; load word
addi $r179 $$locbase i1008              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r180 $$locbase i856               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r180 $r179 i24                    ; copy memory
addi $r181 $$locbase i624               ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r178                       ; [call]: pass argument 0
move $$arg1 $r180                       ; [call]: pass argument 1
move $$arg2 $r181                       ; [call]: pass argument 2
fncall .6                               ; [call]: call abi_encode_5
addi $r183 $$locbase i1176              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r183 $r181 i24                    ; copy memory
addi $r184 $$locbase i1472              ; get offset to local __ptr { u64, u64, u64, u8, { { ptr, u64 }, u64 }, slice, u256 }
addi $r185 $r184 i8                     ; get offset to aggregate element
addi $r186 $$locbase i1176              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r187 $$locbase i1032              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r187 $r186 i24                    ; copy memory
addi $r188 $$locbase i736               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r189 $$locbase i1032              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $$locbase $r189 i24                ; copy memory
addi $r191 $$locbase i288               ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r191 $$locbase i24                ; copy memory
lw $r192 $$locbase i36                  ; load word
lw $r194 $$locbase i37                  ; load word
lw $r196 $$locbase i38                  ; load word
movi $r197 i4                           ; initialize constant into register
add $r198 $r196 $r197
gt $r199 $r198 $r194
move $r200 $r192                        ; move parameter from branch to block argument
move $r201 $r194                        ; move parameter from branch to block argument
jnzi $r199 .55
ji  .56
.55
movi $r202 i2                           ; initialize constant into register
mul $r203 $r194 $r202
movi $r204 i4                           ; initialize constant into register
add $r205 $r203 $r204
aloc $r205
mcp $hp $r192 $r196
move $r200 $hp                          ; move parameter from branch to block argument
move $r201 $r205                        ; move parameter from branch to block argument
.56
move $r210 $r200                        ; move parameter from branch to block argument
move $r212 $r201                        ; move parameter from branch to block argument
addi $r213 $$locbase i408               ; get offset to local __ptr u64
mcpi $r213 $r185 i8                     ; copy memory
movi $r214 i4                           ; initialize constant into register
add $r215 $r213 $r214
add $r216 $r210 $r196
mcpi $r216 $r215 i4                     ; copy memory
addi $r217 $$locbase i496               ; get offset to local __ptr { ptr, u64, u64 }
sw $$locbase $r210 i62                  ; store word
sw $$locbase $r212 i63                  ; store word
sw $$locbase $r198 i64                  ; store word
addi $r221 $$locbase i24                ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r221 $r217 i24                    ; copy memory
mcpi $r188 $r221 i24                    ; copy memory
addi $r222 $$locbase i1224              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r222 $r188 i24                    ; copy memory
addi $r223 $$locbase i1472              ; get offset to local __ptr { u64, u64, u64, u8, { { ptr, u64 }, u64 }, slice, u256 }
addi $r224 $r223 i16                    ; get offset to aggregate element
addi $r225 $$locbase i1224              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r226 $$locbase i1056              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r226 $r225 i24                    ; copy memory
addi $r227 $$locbase i760               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r228 $$locbase i1056              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r230 $$locbase i48                ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r230 $r228 i24                    ; copy memory
addi $r231 $$locbase i312               ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r231 $r230 i24                    ; copy memory
lw $r232 $$locbase i39                  ; load word
lw $r234 $$locbase i40                  ; load word
lw $r236 $$locbase i41                  ; load word
movi $r237 i2                           ; initialize constant into register
add $r238 $r236 $r237
gt $r239 $r238 $r234
move $r240 $r232                        ; move parameter from branch to block argument
move $r241 $r234                        ; move parameter from branch to block argument
jnzi $r239 .57
ji  .58
.57
movi $r242 i2                           ; initialize constant into register
mul $r243 $r234 $r242
movi $r244 i2                           ; initialize constant into register
add $r245 $r243 $r244
aloc $r245
mcp $hp $r232 $r236
move $r240 $hp                          ; move parameter from branch to block argument
move $r241 $r245                        ; move parameter from branch to block argument
.58
move $r250 $r240                        ; move parameter from branch to block argument
move $r252 $r241                        ; move parameter from branch to block argument
addi $r253 $$locbase i416               ; get offset to local __ptr u64
mcpi $r253 $r224 i8                     ; copy memory
movi $r254 i6                           ; initialize constant into register
add $r255 $r253 $r254
add $r256 $r250 $r236
mcpi $r256 $r255 i2                     ; copy memory
addi $r257 $$locbase i520               ; get offset to local __ptr { ptr, u64, u64 }
sw $$locbase $r250 i65                  ; store word
sw $$locbase $r252 i66                  ; store word
sw $$locbase $r238 i67                  ; store word
addi $r261 $$locbase i96                ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r261 $r257 i24                    ; copy memory
mcpi $r227 $r261 i24                    ; copy memory
addi $r262 $$locbase i1248              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r262 $r227 i24                    ; copy memory
addi $r263 $$locbase i1472              ; get offset to local __ptr { u64, u64, u64, u8, { { ptr, u64 }, u64 }, slice, u256 }
addi $r264 $r263 i24                    ; get offset to aggregate element
lb $r265 $r264 i0                       ; load byte
addi $r266 $$locbase i1248              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r267 $$locbase i1080              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r267 $r266 i24                    ; copy memory
addi $r268 $$locbase i784               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r269 $$locbase i1080              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r271 $$locbase i120               ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r271 $r269 i24                    ; copy memory
addi $r272 $$locbase i336               ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r272 $r271 i24                    ; copy memory
lw $r273 $$locbase i42                  ; load word
lw $r275 $$locbase i43                  ; load word
lw $r277 $$locbase i44                  ; load word
add $r278 $r277 $one
gt $r279 $r278 $r275
move $r280 $r273                        ; move parameter from branch to block argument
move $r281 $r275                        ; move parameter from branch to block argument
jnzi $r279 .59
ji  .60
.59
movi $r282 i2                           ; initialize constant into register
mul $r283 $r275 $r282
add $r284 $r283 $one
aloc $r284
mcp $hp $r273 $r277
move $r280 $hp                          ; move parameter from branch to block argument
move $r281 $r284                        ; move parameter from branch to block argument
.60
move $r289 $r280                        ; move parameter from branch to block argument
move $r291 $r281                        ; move parameter from branch to block argument
add $r292 $r280 $r277
sb $r292 $r265 i0                       ; store byte
addi $r293 $$locbase i424               ; get offset to local __ptr { ptr, u64, u64 }
sw $$locbase $r289 i53                  ; store word
sw $$locbase $r291 i54                  ; store word
sw $$locbase $r278 i55                  ; store word
addi $r297 $$locbase i144               ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r297 $r293 i24                    ; copy memory
mcpi $r268 $r297 i24                    ; copy memory
addi $r298 $$locbase i1272              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r298 $r268 i24                    ; copy memory
addi $r299 $$locbase i1472              ; get offset to local __ptr { u64, u64, u64, u8, { { ptr, u64 }, u64 }, slice, u256 }
addi $r300 $r299 i32                    ; get offset to aggregate element
addi $r301 $$locbase i1272              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r302 $$locbase i1600              ; get offset to local __ptr { { ptr, u64 }, u64 }
mcpi $r302 $r300 i24                    ; copy memory
addi $r303 $$locbase i1104              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r303 $r301 i24                    ; copy memory
lw $r306 $$locbase i202                 ; load word
addi $r307 $$locbase i1104              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r308 $$locbase i880               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r308 $r307 i24                    ; copy memory
addi $r309 $$locbase i648               ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r306                       ; [call]: pass argument 0
move $$arg1 $r308                       ; [call]: pass argument 1
move $$arg2 $r309                       ; [call]: pass argument 2
fncall .6                               ; [call]: call abi_encode_5
addi $r311 $$locbase i1200              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r311 $r309 i24                    ; copy memory
movi $r312 i0                           ; move parameter from branch to block argument
.61
move $r314 $r312                        ; move parameter from branch to block argument
lt $r315 $r312 $r306
jnzi $r315 .62
.63
addi $r316 $$locbase i1200              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r317 $$locbase i1296              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r317 $r316 i24                    ; copy memory
addi $r318 $$locbase i1472              ; get offset to local __ptr { u64, u64, u64, u8, { { ptr, u64 }, u64 }, slice, u256 }
addi $r319 $r318 i56                    ; get offset to aggregate element
addi $r320 $$locbase i1296              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r321 $$locbase i1624              ; get offset to local __ptr slice
mcpi $r321 $r319 i16                    ; copy memory
addi $r322 $$locbase i1128              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r322 $r320 i24                    ; copy memory
addi $r323 $$locbase i808               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r324 $$locbase i1128              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r326 $$locbase i168               ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r326 $r324 i24                    ; copy memory
addi $r327 $$locbase i360               ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r327 $r326 i24                    ; copy memory
lw $r328 $$locbase i45                  ; load word
lw $r330 $$locbase i46                  ; load word
lw $r332 $$locbase i47                  ; load word
addi $r333 $$locbase i1624              ; get offset to local __ptr slice
addi $r334 $$locbase i208               ; get offset to local __ptr slice
mcpi $r334 $r333 i16                    ; copy memory
addi $r336 $$locbase i192               ; get offset to local __ptr { u64, u64 }
mcpi $r336 $r333 i16                    ; copy memory
addi $r337 $$locbase i448               ; get offset to local __ptr { u64, u64 }
mcpi $r337 $r336 i16                    ; copy memory
lw $r339 $$locbase i57                  ; load word
movi $r340 i8                           ; initialize constant into register
add $r341 $r339 $r340
add $r342 $r332 $r341
gt $r343 $r342 $r330
move $r344 $r328                        ; move parameter from branch to block argument
move $r345 $r330                        ; move parameter from branch to block argument
jnzi $r343 .64
ji  .65
.64
movi $r346 i2                           ; initialize constant into register
mul $r347 $r330 $r346
add $r348 $r347 $r341
aloc $r348
mcp $hp $r328 $r332
move $r344 $hp                          ; move parameter from branch to block argument
move $r345 $r348                        ; move parameter from branch to block argument
.65
move $r353 $r344                        ; move parameter from branch to block argument
move $r355 $r345                        ; move parameter from branch to block argument
addi $r356 $$locbase i544               ; get offset to local __ptr slice
mcpi $r356 $r334 i16                    ; copy memory
add $r357 $r353 $r332
lw $r359 $$locbase i69
sw $r357 $r359 i0
addi $r357 $r357 i8
lw $r358 $$locbase i68
mcp $r357 $r358 $r359
addi $r360 $r332 i8
add $r360 $r360 $r359
move $r361 $r360                        ; return value from ASM block with return register new_len
addi $r362 $$locbase i584               ; get offset to local __ptr { ptr, u64, u64 }
sw $$locbase $r353 i73                  ; store word
sw $$locbase $r355 i74                  ; store word
sw $$locbase $r361 i75                  ; store word
addi $r366 $$locbase i224               ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r366 $r362 i24                    ; copy memory
mcpi $r323 $r366 i24                    ; copy memory
addi $r367 $$locbase i1320              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r367 $r323 i24                    ; copy memory
addi $r368 $$locbase i1472              ; get offset to local __ptr { u64, u64, u64, u8, { { ptr, u64 }, u64 }, slice, u256 }
addi $r369 $r368 i72                    ; get offset to aggregate element
addi $r370 $$locbase i1320              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r371 $$locbase i1640              ; get offset to local __ptr u256
mcpi $r371 $r369 i32                    ; copy memory
addi $r372 $$locbase i1152              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r372 $r370 i24                    ; copy memory
addi $r373 $$locbase i832               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r374 $$locbase i1152              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r376 $$locbase i248               ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r376 $r374 i24                    ; copy memory
addi $r377 $$locbase i384               ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r377 $r376 i24                    ; copy memory
lw $r378 $$locbase i48                  ; load word
lw $r380 $$locbase i49                  ; load word
lw $r382 $$locbase i50                  ; load word
addi $r383 $$locbase i1640              ; get offset to local __ptr u256
movi $r384 i32                          ; initialize constant into register
add $r385 $r382 $r384
gt $r386 $r385 $r380
move $r387 $r378                        ; move parameter from branch to block argument
move $r388 $r380                        ; move parameter from branch to block argument
jnzi $r386 .66
ji  .67
.66
movi $r389 i2                           ; initialize constant into register
mul $r390 $r380 $r389
movi $r391 i32                          ; initialize constant into register
add $r392 $r390 $r391
aloc $r392
mcp $hp $r378 $r382
move $r387 $hp                          ; move parameter from branch to block argument
move $r388 $r392                        ; move parameter from branch to block argument
.67
move $r397 $r387                        ; move parameter from branch to block argument
move $r399 $r388                        ; move parameter from branch to block argument
addi $r400 $$locbase i464               ; get offset to local __ptr u256
mcpi $r400 $r383 i32                    ; copy memory
add $r401 $r397 $r382
mcpi $r401 $r400 i32                    ; copy memory
addi $r402 $$locbase i560               ; get offset to local __ptr { ptr, u64, u64 }
sw $$locbase $r397 i70                  ; store word
sw $$locbase $r399 i71                  ; store word
sw $$locbase $r385 i72                  ; store word
addi $r406 $$locbase i72                ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r406 $r402 i24                    ; copy memory
mcpi $r373 $r406 i24                    ; copy memory
addi $r407 $$locbase i1344              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r407 $r373 i24                    ; copy memory
addi $r408 $$locbase i1344              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r409 $$locbase i984               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r409 $r408 i24                    ; copy memory
addi $r410 $$locbase i984               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r411 $$locbase i928               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r411 $r410 i24                    ; copy memory
addi $r412 $$locbase i720               ; get offset to local __ptr slice
move $$arg0 $r411                       ; [call]: pass argument 0
move $$arg1 $r412                       ; [call]: pass argument 1
fncall .10                              ; [call]: call as_raw_slice_7
addi $r414 $$locbase i952               ; get offset to local __ptr slice
mcpi $r414 $r412 i16                    ; copy memory
move $r415 $r414                        ; move parameter from branch to block argument
ji  .68
.62
addi $r416 $$locbase i1600              ; get offset to local __ptr { { ptr, u64 }, u64 }
addi $r417 $$locbase i1576              ; get offset to local __ptr { { ptr, u64 }, u64 }
mcpi $r417 $r416 i24                    ; copy memory
lw $r419 $$locbase i197                 ; load word
movi $r420 i8                           ; initialize constant into register
mul $r421 $r420 $r314
add $r422 $r419 $r421
lw $r423 $r422 i0                       ; lw val ptr i0
move $r424 $r423                        ; return value from ASM block with return register val
addi $r425 $$locbase i1200              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r426 $$locbase i904               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r426 $r425 i24                    ; copy memory
addi $r427 $$locbase i672               ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r424                       ; [call]: pass argument 0
move $$arg1 $r426                       ; [call]: pass argument 1
move $$arg2 $r427                       ; [call]: pass argument 2
fncall .6                               ; [call]: call abi_encode_5
addi $r429 $$locbase i1200              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r429 $r427 i24                    ; copy memory
add $r430 $r314 $one
move $r312 $r430                        ; move parameter from branch to block argument
ji  .61
.53
addi $r432 $$locbase i968               ; get offset to local __ptr { __ptr { u64, u64, u64, u8, { { ptr, u64 }, u64 }, slice, u256 }, u64 }
sw $$locbase $r152 i121                 ; store word
movi $r434 i104                         ; initialize constant into register
sw $$locbase $r434 i122                 ; store word
addi $r435 $$locbase i272               ; get offset to local __ptr { __ptr { u64, u64, u64, u8, { { ptr, u64 }, u64 }, slice, u256 }, u64 }
mcpi $r435 $r432 i16                    ; copy memory
addi $r436 $$locbase i952               ; get offset to local __ptr slice
mcpi $r436 $r435 i16                    ; copy memory
move $r415 $r436                        ; move parameter from branch to block argument
.68
addi $r440 $$locbase i608               ; get offset to local __ptr slice
mcpi $r440 $r415 i16                    ; copy memory
load $r441 data_NonConfigurable_3       ; load constant from data section
lw $r442 $$locbase i76                  ; load slice pointer for logging data
lw $r443 $$locbase i77                  ; load slice size for logging data
logd $zero $r441 $r442 $r443            ; log slice
.15
cfsi i1672                              ; free 1672 bytes for locals and 0 slots for extra call arguments
move $$reta $r150                       ; restore return address
popa .14                                ; restore all registers
jal $zero $$reta i0                     ; return from call
DIFF------------------------------
.program:
.14                                     ; --- start of function: local_log_21 ---
pusha .14                               ; save all registers
move $$locbase $sp                      ; save locals base register for function local_log_21
cfei i1672                              ; allocate 1672 bytes for locals and 0 slots for call arguments
move $r150 $$reta                       ; save return address
.42
addi $r151 $$locbase i1368              ; get offset to local __ptr { u64, u64, u64, u8, { { ptr, u64 }, u64 }, slice, u256 }
mcpi $r151 $$arg0 i104                  ; copy memory
addi $r152 $$locbase i1368              ; get offset to local __ptr { u64, u64, u64, u8, { { ptr, u64 }, u64 }, slice, u256 }
.44
.46
.48
.50
.52
.54
addi $r173 $$locbase i696               ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r173                       ; [call]: pass argument 0
fncall .8                               ; [call]: call new_6
addi $r175 $$locbase i1472              ; get offset to local __ptr { u64, u64, u64, u8, { { ptr, u64 }, u64 }, slice, u256 }
mcpi $r175 $r152 i104                   ; copy memory
addi $r176 $$locbase i1008              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r176 $r173 i24                    ; copy memory
lw $r178 $$locbase i184                 ; load word
addi $r179 $$locbase i1008              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r180 $$locbase i856               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r180 $r179 i24                    ; copy memory
addi $r181 $$locbase i624               ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r178                       ; [call]: pass argument 0
move $$arg1 $r180                       ; [call]: pass argument 1
move $$arg2 $r181                       ; [call]: pass argument 2
fncall .6                               ; [call]: call abi_encode_5
addi $r183 $$locbase i1176              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r183 $r181 i24                    ; copy memory
addi $r184 $$locbase i1472              ; get offset to local __ptr { u64, u64, u64, u8, { { ptr, u64 }, u64 }, slice, u256 }
addi $r185 $r184 i8                     ; get offset to aggregate element
addi $r186 $$locbase i1176              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r187 $$locbase i1032              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r187 $r186 i24                    ; copy memory
addi $r188 $$locbase i736               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r189 $$locbase i1032              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $$locbase $r189 i24                ; copy memory
addi $r191 $$locbase i288               ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r191 $$locbase i24                ; copy memory
lw $r192 $$locbase i36                  ; load word
lw $r194 $$locbase i37                  ; load word
lw $r196 $$locbase i38                  ; load word
movi $r197 i4                           ; initialize constant into register
add $r198 $r196 $r197
gt $r199 $r198 $r194
move $r200 $r192                        ; move parameter from branch to block argument
move $r201 $r194                        ; move parameter from branch to block argument
jnzi $r199 .55
ji  .56
.55
movi $r202 i2                           ; initialize constant into register
mul $r203 $r194 $r202
movi $r204 i4                           ; initialize constant into register
add $r205 $r203 $r204
aloc $r205
mcp $hp $r192 $r196
move $r200 $hp                          ; move parameter from branch to block argument
move $r201 $r205                        ; move parameter from branch to block argument
.56
move $r210 $r200                        ; move parameter from branch to block argument
move $r212 $r201                        ; move parameter from branch to block argument
addi $r213 $$locbase i408               ; get offset to local __ptr u64
mcpi $r213 $r185 i8                     ; copy memory
movi $r214 i4                           ; initialize constant into register
add $r215 $r213 $r214
add $r216 $r210 $r196
mcpi $r216 $r215 i4                     ; copy memory
addi $r217 $$locbase i496               ; get offset to local __ptr { ptr, u64, u64 }
sw $$locbase $r210 i62                  ; store word
sw $$locbase $r212 i63                  ; store word
sw $$locbase $r198 i64                  ; store word
addi $r221 $$locbase i24                ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r221 $r217 i24                    ; copy memory
mcpi $r188 $r221 i24                    ; copy memory
addi $r222 $$locbase i1224              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r222 $r188 i24                    ; copy memory
addi $r223 $$locbase i1472              ; get offset to local __ptr { u64, u64, u64, u8, { { ptr, u64 }, u64 }, slice, u256 }
addi $r224 $r223 i16                    ; get offset to aggregate element
addi $r225 $$locbase i1224              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r226 $$locbase i1056              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r226 $r225 i24                    ; copy memory
addi $r227 $$locbase i760               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r228 $$locbase i1056              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r230 $$locbase i48                ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r230 $r228 i24                    ; copy memory
addi $r231 $$locbase i312               ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r231 $r230 i24                    ; copy memory
lw $r232 $$locbase i39                  ; load word
lw $r234 $$locbase i40                  ; load word
lw $r236 $$locbase i41                  ; load word
movi $r237 i2                           ; initialize constant into register
add $r238 $r236 $r237
gt $r239 $r238 $r234
move $r240 $r232                        ; move parameter from branch to block argument
move $r241 $r234                        ; move parameter from branch to block argument
jnzi $r239 .57
ji  .58
.57
movi $r242 i2                           ; initialize constant into register
mul $r243 $r234 $r242
movi $r244 i2                           ; initialize constant into register
add $r245 $r243 $r244
aloc $r245
mcp $hp $r232 $r236
move $r240 $hp                          ; move parameter from branch to block argument
move $r241 $r245                        ; move parameter from branch to block argument
.58
move $r250 $r240                        ; move parameter from branch to block argument
move $r252 $r241                        ; move parameter from branch to block argument
addi $r253 $$locbase i416               ; get offset to local __ptr u64
mcpi $r253 $r224 i8                     ; copy memory
movi $r254 i6                           ; initialize constant into register
add $r255 $r253 $r254
add $r256 $r250 $r236
mcpi $r256 $r255 i2                     ; copy memory
addi $r257 $$locbase i520               ; get offset to local __ptr { ptr, u64, u64 }
sw $$locbase $r250 i65                  ; store word
sw $$locbase $r252 i66                  ; store word
sw $$locbase $r238 i67                  ; store word
addi $r261 $$locbase i96                ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r261 $r257 i24                    ; copy memory
mcpi $r227 $r261 i24                    ; copy memory
addi $r262 $$locbase i1248              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r262 $r227 i24                    ; copy memory
addi $r263 $$locbase i1472              ; get offset to local __ptr { u64, u64, u64, u8, { { ptr, u64 }, u64 }, slice, u256 }
addi $r264 $r263 i24                    ; get offset to aggregate element
lb $r265 $r264 i0                       ; load byte
addi $r266 $$locbase i1248              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r267 $$locbase i1080              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r267 $r266 i24                    ; copy memory
addi $r268 $$locbase i784               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r269 $$locbase i1080              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r271 $$locbase i120               ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r271 $r269 i24                    ; copy memory
addi $r272 $$locbase i336               ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r272 $r271 i24                    ; copy memory
lw $r273 $$locbase i42                  ; load word
lw $r275 $$locbase i43                  ; load word
lw $r277 $$locbase i44                  ; load word
add $r278 $r277 $one
gt $r279 $r278 $r275
move $r280 $r273                        ; move parameter from branch to block argument
move $r281 $r275                        ; move parameter from branch to block argument
jnzi $r279 .59
ji  .60
.59
movi $r282 i2                           ; initialize constant into register
mul $r283 $r275 $r282
add $r284 $r283 $one
aloc $r284
mcp $hp $r273 $r277
move $r280 $hp                          ; move parameter from branch to block argument
move $r281 $r284                        ; move parameter from branch to block argument
.60
move $r289 $r280                        ; move parameter from branch to block argument
move $r291 $r281                        ; move parameter from branch to block argument
add $r292 $r280 $r277
sb $r292 $r265 i0                       ; store byte
addi $r293 $$locbase i424               ; get offset to local __ptr { ptr, u64, u64 }
sw $$locbase $r289 i53                  ; store word
sw $$locbase $r291 i54                  ; store word
sw $$locbase $r278 i55                  ; store word
addi $r297 $$locbase i144               ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r297 $r293 i24                    ; copy memory
mcpi $r268 $r297 i24                    ; copy memory
addi $r298 $$locbase i1272              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r298 $r268 i24                    ; copy memory
addi $r299 $$locbase i1472              ; get offset to local __ptr { u64, u64, u64, u8, { { ptr, u64 }, u64 }, slice, u256 }
addi $r300 $r299 i32                    ; get offset to aggregate element
addi $r301 $$locbase i1272              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r302 $$locbase i1600              ; get offset to local __ptr { { ptr, u64 }, u64 }
mcpi $r302 $r300 i24                    ; copy memory
addi $r303 $$locbase i1104              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r303 $r301 i24                    ; copy memory
lw $r306 $$locbase i202                 ; load word
addi $r307 $$locbase i1104              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r308 $$locbase i880               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r308 $r307 i24                    ; copy memory
addi $r309 $$locbase i648               ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r306                       ; [call]: pass argument 0
move $$arg1 $r308                       ; [call]: pass argument 1
move $$arg2 $r309                       ; [call]: pass argument 2
fncall .6                               ; [call]: call abi_encode_5
addi $r311 $$locbase i1200              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r311 $r309 i24                    ; copy memory
movi $r312 i0                           ; move parameter from branch to block argument
.61
move $r314 $r312                        ; move parameter from branch to block argument
lt $r315 $r312 $r306
jnzi $r315 .62
.63
addi $r316 $$locbase i1200              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r317 $$locbase i1296              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r317 $r316 i24                    ; copy memory
addi $r318 $$locbase i1472              ; get offset to local __ptr { u64, u64, u64, u8, { { ptr, u64 }, u64 }, slice, u256 }
addi $r319 $r318 i56                    ; get offset to aggregate element
addi $r320 $$locbase i1296              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r321 $$locbase i1624              ; get offset to local __ptr slice
mcpi $r321 $r319 i16                    ; copy memory
addi $r322 $$locbase i1128              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r322 $r320 i24                    ; copy memory
addi $r323 $$locbase i808               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r324 $$locbase i1128              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r326 $$locbase i168               ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r326 $r324 i24                    ; copy memory
addi $r327 $$locbase i360               ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r327 $r326 i24                    ; copy memory
lw $r328 $$locbase i45                  ; load word
lw $r330 $$locbase i46                  ; load word
lw $r332 $$locbase i47                  ; load word
addi $r333 $$locbase i1624              ; get offset to local __ptr slice
addi $r334 $$locbase i208               ; get offset to local __ptr slice
mcpi $r334 $r333 i16                    ; copy memory
addi $r336 $$locbase i192               ; get offset to local __ptr { u64, u64 }
mcpi $r336 $r333 i16                    ; copy memory
addi $r337 $$locbase i448               ; get offset to local __ptr { u64, u64 }
mcpi $r337 $r336 i16                    ; copy memory
lw $r339 $$locbase i57                  ; load word
movi $r340 i8                           ; initialize constant into register
add $r341 $r339 $r340
add $r342 $r332 $r341
gt $r343 $r342 $r330
move $r344 $r328                        ; move parameter from branch to block argument
move $r345 $r330                        ; move parameter from branch to block argument
jnzi $r343 .64
ji  .65
.64
movi $r346 i2                           ; initialize constant into register
mul $r347 $r330 $r346
add $r348 $r347 $r341
aloc $r348
mcp $hp $r328 $r332
move $r344 $hp                          ; move parameter from branch to block argument
move $r345 $r348                        ; move parameter from branch to block argument
.65
move $r353 $r344                        ; move parameter from branch to block argument
move $r355 $r345                        ; move parameter from branch to block argument
addi $r356 $$locbase i544               ; get offset to local __ptr slice
mcpi $r356 $r334 i16                    ; copy memory
add $r357 $r353 $r332
lw $r359 $$locbase i69
sw $r357 $r359 i0
addi $r357 $r357 i8
lw $r358 $$locbase i68
mcp $r357 $r358 $r359
addi $r360 $r332 i8
add $r360 $r360 $r359
move $r361 $r360                        ; return value from ASM block with return register new_len
addi $r362 $$locbase i584               ; get offset to local __ptr { ptr, u64, u64 }
sw $$locbase $r353 i73                  ; store word
sw $$locbase $r355 i74                  ; store word
sw $$locbase $r361 i75                  ; store word
addi $r366 $$locbase i224               ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r366 $r362 i24                    ; copy memory
mcpi $r323 $r366 i24                    ; copy memory
addi $r367 $$locbase i1320              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r367 $r323 i24                    ; copy memory
addi $r368 $$locbase i1472              ; get offset to local __ptr { u64, u64, u64, u8, { { ptr, u64 }, u64 }, slice, u256 }
addi $r369 $r368 i72                    ; get offset to aggregate element
addi $r370 $$locbase i1320              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r371 $$locbase i1640              ; get offset to local __ptr u256
mcpi $r371 $r369 i32                    ; copy memory
addi $r372 $$locbase i1152              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r372 $r370 i24                    ; copy memory
addi $r373 $$locbase i832               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r374 $$locbase i1152              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r376 $$locbase i248               ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r376 $r374 i24                    ; copy memory
addi $r377 $$locbase i384               ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r377 $r376 i24                    ; copy memory
lw $r378 $$locbase i48                  ; load word
lw $r380 $$locbase i49                  ; load word
lw $r382 $$locbase i50                  ; load word
addi $r383 $$locbase i1640              ; get offset to local __ptr u256
movi $r384 i32                          ; initialize constant into register
add $r385 $r382 $r384
gt $r386 $r385 $r380
move $r387 $r378                        ; move parameter from branch to block argument
move $r388 $r380                        ; move parameter from branch to block argument
jnzi $r386 .66
ji  .67
.66
movi $r389 i2                           ; initialize constant into register
mul $r390 $r380 $r389
movi $r391 i32                          ; initialize constant into register
add $r392 $r390 $r391
aloc $r392
mcp $hp $r378 $r382
move $r387 $hp                          ; move parameter from branch to block argument
move $r388 $r392                        ; move parameter from branch to block argument
.67
move $r397 $r387                        ; move parameter from branch to block argument
move $r399 $r388                        ; move parameter from branch to block argument
addi $r400 $$locbase i464               ; get offset to local __ptr u256
mcpi $r400 $r383 i32                    ; copy memory
add $r401 $r397 $r382
mcpi $r401 $r400 i32                    ; copy memory
addi $r402 $$locbase i560               ; get offset to local __ptr { ptr, u64, u64 }
sw $$locbase $r397 i70                  ; store word
sw $$locbase $r399 i71                  ; store word
sw $$locbase $r385 i72                  ; store word
addi $r406 $$locbase i72                ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r406 $r402 i24                    ; copy memory
mcpi $r373 $r406 i24                    ; copy memory
addi $r407 $$locbase i1344              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r407 $r373 i24                    ; copy memory
addi $r408 $$locbase i1344              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r409 $$locbase i984               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r409 $r408 i24                    ; copy memory
addi $r410 $$locbase i984               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r411 $$locbase i928               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r411 $r410 i24                    ; copy memory
addi $r412 $$locbase i720               ; get offset to local __ptr slice
move $$arg0 $r411                       ; [call]: pass argument 0
move $$arg1 $r412                       ; [call]: pass argument 1
fncall .10                              ; [call]: call as_raw_slice_7
addi $r414 $$locbase i952               ; get offset to local __ptr slice
mcpi $r414 $r412 i16                    ; copy memory
move $r415 $r414                        ; move parameter from branch to block argument
ji  .68
.62
addi $r416 $$locbase i1600              ; get offset to local __ptr { { ptr, u64 }, u64 }
addi $r417 $$locbase i1576              ; get offset to local __ptr { { ptr, u64 }, u64 }
mcpi $r417 $r416 i24                    ; copy memory
lw $r419 $$locbase i197                 ; load word
movi $r420 i8                           ; initialize constant into register
mul $r421 $r420 $r314
add $r422 $r419 $r421
lw $r423 $r422 i0                       ; lw val ptr i0
move $r424 $r423                        ; return value from ASM block with return register val
addi $r425 $$locbase i1200              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r426 $$locbase i904               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r426 $r425 i24                    ; copy memory
addi $r427 $$locbase i672               ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r424                       ; [call]: pass argument 0
move $$arg1 $r426                       ; [call]: pass argument 1
move $$arg2 $r427                       ; [call]: pass argument 2
fncall .6                               ; [call]: call abi_encode_5
addi $r429 $$locbase i1200              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r429 $r427 i24                    ; copy memory
add $r430 $r314 $one
move $r312 $r430                        ; move parameter from branch to block argument
ji  .61
.68
addi $r440 $$locbase i608               ; get offset to local __ptr slice
mcpi $r440 $r415 i16                    ; copy memory
load $r441 data_NonConfigurable_3       ; load constant from data section
lw $r442 $$locbase i76                  ; load slice pointer for logging data
lw $r443 $$locbase i77                  ; load slice size for logging data
logd $zero $r441 $r442 $r443            ; log slice
.15
cfsi i1672                              ; free 1672 bytes for locals and 0 slots for extra call arguments
move $$reta $r150                       ; restore return address
popa .14                                ; restore all registers
jal $zero $$reta i0                     ; return from call
DIFF------------------------------
.program:
.14                                     ; --- start of function: local_log_21 ---
pusha .14                               ; save all registers
move $$locbase $sp                      ; save locals base register for function local_log_21
cfei i1672                              ; allocate 1672 bytes for locals and 0 slots for call arguments
move $r150 $$reta                       ; save return address
.42
addi $r151 $$locbase i1368              ; get offset to local __ptr { u64, u64, u64, u8, { { ptr, u64 }, u64 }, slice, u256 }
mcpi $r151 $$arg0 i104                  ; copy memory
addi $r152 $$locbase i1368              ; get offset to local __ptr { u64, u64, u64, u8, { { ptr, u64 }, u64 }, slice, u256 }
.44
.46
.48
.50
.52
.54
addi $r173 $$locbase i696               ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r173                       ; [call]: pass argument 0
fncall .8                               ; [call]: call new_6
addi $r175 $$locbase i1472              ; get offset to local __ptr { u64, u64, u64, u8, { { ptr, u64 }, u64 }, slice, u256 }
mcpi $r175 $r152 i104                   ; copy memory
addi $r176 $$locbase i1008              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r176 $r173 i24                    ; copy memory
lw $r178 $$locbase i184                 ; load word
addi $r179 $$locbase i1008              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r180 $$locbase i856               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r180 $r179 i24                    ; copy memory
addi $r181 $$locbase i624               ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r178                       ; [call]: pass argument 0
move $$arg1 $r180                       ; [call]: pass argument 1
move $$arg2 $r181                       ; [call]: pass argument 2
fncall .6                               ; [call]: call abi_encode_5
addi $r183 $$locbase i1176              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r183 $r181 i24                    ; copy memory
addi $r184 $$locbase i1472              ; get offset to local __ptr { u64, u64, u64, u8, { { ptr, u64 }, u64 }, slice, u256 }
addi $r185 $r184 i8                     ; get offset to aggregate element
addi $r186 $$locbase i1176              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r187 $$locbase i1032              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r187 $r186 i24                    ; copy memory
addi $r188 $$locbase i736               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r189 $$locbase i1032              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $$locbase $r189 i24                ; copy memory
addi $r191 $$locbase i288               ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r191 $$locbase i24                ; copy memory
lw $r192 $$locbase i36                  ; load word
lw $r194 $$locbase i37                  ; load word
lw $r196 $$locbase i38                  ; load word
movi $r197 i4                           ; initialize constant into register
add $r198 $r196 $r197
gt $r199 $r198 $r194
move $r200 $r192                        ; move parameter from branch to block argument
move $r201 $r194                        ; move parameter from branch to block argument
jnzi $r199 .55
ji  .56
.55
movi $r202 i2                           ; initialize constant into register
mul $r203 $r194 $r202
movi $r204 i4                           ; initialize constant into register
add $r205 $r203 $r204
aloc $r205
mcp $hp $r192 $r196
move $r200 $hp                          ; move parameter from branch to block argument
move $r201 $r205                        ; move parameter from branch to block argument
.56
move $r210 $r200                        ; move parameter from branch to block argument
move $r212 $r201                        ; move parameter from branch to block argument
addi $r213 $$locbase i408               ; get offset to local __ptr u64
mcpi $r213 $r185 i8                     ; copy memory
movi $r214 i4                           ; initialize constant into register
add $r215 $r213 $r214
add $r216 $r210 $r196
mcpi $r216 $r215 i4                     ; copy memory
addi $r217 $$locbase i496               ; get offset to local __ptr { ptr, u64, u64 }
sw $$locbase $r210 i62                  ; store word
sw $$locbase $r212 i63                  ; store word
sw $$locbase $r198 i64                  ; store word
addi $r221 $$locbase i24                ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r221 $r217 i24                    ; copy memory
mcpi $r188 $r221 i24                    ; copy memory
addi $r222 $$locbase i1224              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r222 $r188 i24                    ; copy memory
addi $r223 $$locbase i1472              ; get offset to local __ptr { u64, u64, u64, u8, { { ptr, u64 }, u64 }, slice, u256 }
addi $r224 $r223 i16                    ; get offset to aggregate element
addi $r225 $$locbase i1224              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r226 $$locbase i1056              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r226 $r225 i24                    ; copy memory
addi $r227 $$locbase i760               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r228 $$locbase i1056              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r230 $$locbase i48                ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r230 $r228 i24                    ; copy memory
addi $r231 $$locbase i312               ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r231 $r230 i24                    ; copy memory
lw $r232 $$locbase i39                  ; load word
lw $r234 $$locbase i40                  ; load word
lw $r236 $$locbase i41                  ; load word
movi $r237 i2                           ; initialize constant into register
add $r238 $r236 $r237
gt $r239 $r238 $r234
move $r240 $r232                        ; move parameter from branch to block argument
move $r241 $r234                        ; move parameter from branch to block argument
jnzi $r239 .57
ji  .58
.57
movi $r242 i2                           ; initialize constant into register
mul $r243 $r234 $r242
movi $r244 i2                           ; initialize constant into register
add $r245 $r243 $r244
aloc $r245
mcp $hp $r232 $r236
move $r240 $hp                          ; move parameter from branch to block argument
move $r241 $r245                        ; move parameter from branch to block argument
.58
move $r250 $r240                        ; move parameter from branch to block argument
move $r252 $r241                        ; move parameter from branch to block argument
addi $r253 $$locbase i416               ; get offset to local __ptr u64
mcpi $r253 $r224 i8                     ; copy memory
movi $r254 i6                           ; initialize constant into register
add $r255 $r253 $r254
add $r256 $r250 $r236
mcpi $r256 $r255 i2                     ; copy memory
addi $r257 $$locbase i520               ; get offset to local __ptr { ptr, u64, u64 }
sw $$locbase $r250 i65                  ; store word
sw $$locbase $r252 i66                  ; store word
sw $$locbase $r238 i67                  ; store word
addi $r261 $$locbase i96                ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r261 $r257 i24                    ; copy memory
mcpi $r227 $r261 i24                    ; copy memory
addi $r262 $$locbase i1248              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r262 $r227 i24                    ; copy memory
addi $r263 $$locbase i1472              ; get offset to local __ptr { u64, u64, u64, u8, { { ptr, u64 }, u64 }, slice, u256 }
addi $r264 $r263 i24                    ; get offset to aggregate element
lb $r265 $r264 i0                       ; load byte
addi $r266 $$locbase i1248              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r267 $$locbase i1080              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r267 $r266 i24                    ; copy memory
addi $r268 $$locbase i784               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r269 $$locbase i1080              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r271 $$locbase i120               ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r271 $r269 i24                    ; copy memory
addi $r272 $$locbase i336               ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r272 $r271 i24                    ; copy memory
lw $r273 $$locbase i42                  ; load word
lw $r275 $$locbase i43                  ; load word
lw $r277 $$locbase i44                  ; load word
add $r278 $r277 $one
gt $r279 $r278 $r275
move $r280 $r273                        ; move parameter from branch to block argument
move $r281 $r275                        ; move parameter from branch to block argument
jnzi $r279 .59
ji  .60
.59
movi $r282 i2                           ; initialize constant into register
mul $r283 $r275 $r282
add $r284 $r283 $one
aloc $r284
mcp $hp $r273 $r277
move $r280 $hp                          ; move parameter from branch to block argument
move $r281 $r284                        ; move parameter from branch to block argument
.60
move $r289 $r280                        ; move parameter from branch to block argument
move $r291 $r281                        ; move parameter from branch to block argument
add $r292 $r280 $r277
sb $r292 $r265 i0                       ; store byte
addi $r293 $$locbase i424               ; get offset to local __ptr { ptr, u64, u64 }
sw $$locbase $r289 i53                  ; store word
sw $$locbase $r291 i54                  ; store word
sw $$locbase $r278 i55                  ; store word
addi $r297 $$locbase i144               ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r297 $r293 i24                    ; copy memory
mcpi $r268 $r297 i24                    ; copy memory
addi $r298 $$locbase i1272              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r298 $r268 i24                    ; copy memory
addi $r299 $$locbase i1472              ; get offset to local __ptr { u64, u64, u64, u8, { { ptr, u64 }, u64 }, slice, u256 }
addi $r300 $r299 i32                    ; get offset to aggregate element
addi $r301 $$locbase i1272              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r302 $$locbase i1600              ; get offset to local __ptr { { ptr, u64 }, u64 }
mcpi $r302 $r300 i24                    ; copy memory
addi $r303 $$locbase i1104              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r303 $r301 i24                    ; copy memory
lw $r306 $$locbase i202                 ; load word
addi $r307 $$locbase i1104              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r308 $$locbase i880               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r308 $r307 i24                    ; copy memory
addi $r309 $$locbase i648               ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r306                       ; [call]: pass argument 0
move $$arg1 $r308                       ; [call]: pass argument 1
move $$arg2 $r309                       ; [call]: pass argument 2
fncall .6                               ; [call]: call abi_encode_5
addi $r311 $$locbase i1200              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r311 $r309 i24                    ; copy memory
movi $r312 i0                           ; move parameter from branch to block argument
.61
move $r314 $r312                        ; move parameter from branch to block argument
lt $r315 $r312 $r306
jnzi $r315 .62
.63
addi $r316 $$locbase i1200              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r317 $$locbase i1296              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r317 $r316 i24                    ; copy memory
addi $r318 $$locbase i1472              ; get offset to local __ptr { u64, u64, u64, u8, { { ptr, u64 }, u64 }, slice, u256 }
addi $r319 $r318 i56                    ; get offset to aggregate element
addi $r320 $$locbase i1296              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r321 $$locbase i1624              ; get offset to local __ptr slice
mcpi $r321 $r319 i16                    ; copy memory
addi $r322 $$locbase i1128              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r322 $r320 i24                    ; copy memory
addi $r323 $$locbase i808               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r324 $$locbase i1128              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r326 $$locbase i168               ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r326 $r324 i24                    ; copy memory
addi $r327 $$locbase i360               ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r327 $r326 i24                    ; copy memory
lw $r328 $$locbase i45                  ; load word
lw $r330 $$locbase i46                  ; load word
lw $r332 $$locbase i47                  ; load word
addi $r333 $$locbase i1624              ; get offset to local __ptr slice
addi $r334 $$locbase i208               ; get offset to local __ptr slice
mcpi $r334 $r333 i16                    ; copy memory
addi $r336 $$locbase i192               ; get offset to local __ptr { u64, u64 }
mcpi $r336 $r333 i16                    ; copy memory
addi $r337 $$locbase i448               ; get offset to local __ptr { u64, u64 }
mcpi $r337 $r336 i16                    ; copy memory
lw $r339 $$locbase i57                  ; load word
movi $r340 i8                           ; initialize constant into register
add $r341 $r339 $r340
add $r342 $r332 $r341
gt $r343 $r342 $r330
move $r344 $r328                        ; move parameter from branch to block argument
move $r345 $r330                        ; move parameter from branch to block argument
jnzi $r343 .64
ji  .65
.64
movi $r346 i2                           ; initialize constant into register
mul $r347 $r330 $r346
add $r348 $r347 $r341
aloc $r348
mcp $hp $r328 $r332
move $r344 $hp                          ; move parameter from branch to block argument
move $r345 $r348                        ; move parameter from branch to block argument
.65
move $r353 $r344                        ; move parameter from branch to block argument
move $r355 $r345                        ; move parameter from branch to block argument
addi $r356 $$locbase i544               ; get offset to local __ptr slice
mcpi $r356 $r334 i16                    ; copy memory
add $r357 $r353 $r332
lw $r359 $$locbase i69
sw $r357 $r359 i0
addi $r357 $r357 i8
lw $r358 $$locbase i68
mcp $r357 $r358 $r359
addi $r360 $r332 i8
add $r360 $r360 $r359
move $r361 $r360                        ; return value from ASM block with return register new_len
addi $r362 $$locbase i584               ; get offset to local __ptr { ptr, u64, u64 }
sw $$locbase $r353 i73                  ; store word
sw $$locbase $r355 i74                  ; store word
sw $$locbase $r361 i75                  ; store word
addi $r366 $$locbase i224               ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r366 $r362 i24                    ; copy memory
mcpi $r323 $r366 i24                    ; copy memory
addi $r367 $$locbase i1320              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r367 $r323 i24                    ; copy memory
addi $r368 $$locbase i1472              ; get offset to local __ptr { u64, u64, u64, u8, { { ptr, u64 }, u64 }, slice, u256 }
addi $r369 $r368 i72                    ; get offset to aggregate element
addi $r370 $$locbase i1320              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r371 $$locbase i1640              ; get offset to local __ptr u256
mcpi $r371 $r369 i32                    ; copy memory
addi $r372 $$locbase i1152              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r372 $r370 i24                    ; copy memory
addi $r373 $$locbase i832               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r374 $$locbase i1152              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r376 $$locbase i248               ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r376 $r374 i24                    ; copy memory
addi $r377 $$locbase i384               ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r377 $r376 i24                    ; copy memory
lw $r378 $$locbase i48                  ; load word
lw $r380 $$locbase i49                  ; load word
lw $r382 $$locbase i50                  ; load word
addi $r383 $$locbase i1640              ; get offset to local __ptr u256
movi $r384 i32                          ; initialize constant into register
add $r385 $r382 $r384
gt $r386 $r385 $r380
move $r387 $r378                        ; move parameter from branch to block argument
move $r388 $r380                        ; move parameter from branch to block argument
jnzi $r386 .66
ji  .67
.66
movi $r389 i2                           ; initialize constant into register
mul $r390 $r380 $r389
movi $r391 i32                          ; initialize constant into register
add $r392 $r390 $r391
aloc $r392
mcp $hp $r378 $r382
move $r387 $hp                          ; move parameter from branch to block argument
move $r388 $r392                        ; move parameter from branch to block argument
.67
move $r397 $r387                        ; move parameter from branch to block argument
move $r399 $r388                        ; move parameter from branch to block argument
addi $r400 $$locbase i464               ; get offset to local __ptr u256
mcpi $r400 $r383 i32                    ; copy memory
add $r401 $r397 $r382
mcpi $r401 $r400 i32                    ; copy memory
addi $r402 $$locbase i560               ; get offset to local __ptr { ptr, u64, u64 }
sw $$locbase $r397 i70                  ; store word
sw $$locbase $r399 i71                  ; store word
sw $$locbase $r385 i72                  ; store word
addi $r406 $$locbase i72                ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r406 $r402 i24                    ; copy memory
mcpi $r373 $r406 i24                    ; copy memory
addi $r407 $$locbase i1344              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r407 $r373 i24                    ; copy memory
addi $r408 $$locbase i1344              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r409 $$locbase i984               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r409 $r408 i24                    ; copy memory
addi $r410 $$locbase i984               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r411 $$locbase i928               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r411 $r410 i24                    ; copy memory
addi $r412 $$locbase i720               ; get offset to local __ptr slice
move $$arg0 $r411                       ; [call]: pass argument 0
move $$arg1 $r412                       ; [call]: pass argument 1
fncall .10                              ; [call]: call as_raw_slice_7
addi $r414 $$locbase i952               ; get offset to local __ptr slice
mcpi $r414 $r412 i16                    ; copy memory
move $r415 $r414                        ; move parameter from branch to block argument
ji  .68
.62
addi $r416 $$locbase i1600              ; get offset to local __ptr { { ptr, u64 }, u64 }
addi $r417 $$locbase i1576              ; get offset to local __ptr { { ptr, u64 }, u64 }
mcpi $r417 $r416 i24                    ; copy memory
lw $r419 $$locbase i197                 ; load word
movi $r420 i8                           ; initialize constant into register
mul $r421 $r420 $r314
add $r422 $r419 $r421
lw $r423 $r422 i0                       ; lw val ptr i0
move $r424 $r423                        ; return value from ASM block with return register val
addi $r425 $$locbase i1200              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r426 $$locbase i904               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r426 $r425 i24                    ; copy memory
addi $r427 $$locbase i672               ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r424                       ; [call]: pass argument 0
move $$arg1 $r426                       ; [call]: pass argument 1
move $$arg2 $r427                       ; [call]: pass argument 2
fncall .6                               ; [call]: call abi_encode_5
addi $r429 $$locbase i1200              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r429 $r427 i24                    ; copy memory
add $r430 $r314 $one
move $r312 $r430                        ; move parameter from branch to block argument
ji  .61
.68
addi $r440 $$locbase i608               ; get offset to local __ptr slice
mcpi $r440 $r415 i16                    ; copy memory
load $r441 data_NonConfigurable_3       ; load constant from data section
lw $r442 $$locbase i76                  ; load slice pointer for logging data
lw $r443 $$locbase i77                  ; load slice size for logging data
logd $zero $r441 $r442 $r443            ; log slice
.15
cfsi i1672                              ; free 1672 bytes for locals and 0 slots for extra call arguments
move $$reta $r150                       ; restore return address
popa .14                                ; restore all registers
jal $zero $$reta i0                     ; return from call
DIFF------------------------------
.program:
.16                                     ; --- start of function: local_log_48 ---
pusha .16                               ; save all registers
move $$locbase $sp                      ; save locals base register for function local_log_48
cfei i40                                ; allocate 40 bytes for locals and 0 slots for call arguments
.69
addi $r445 $$locbase i32                ; get offset to local __ptr { u64 }
mcpi $r445 $$arg0 i8                    ; copy memory
addi $r446 $$locbase i32                ; get offset to local __ptr { u64 }
sw $$locbase $r446 i0                   ; store word
addi $r447 $$locbase i8                 ; get offset to aggregate element
movi $r448 i8                           ; initialize constant into register
sw $$locbase $r448 i1                   ; store word
addi $r449 $$locbase i16                ; get offset to local __ptr slice
mcpi $r449 $$locbase i16                ; copy memory
load $r450 data_NonConfigurable_4       ; load constant from data section
lw $r451 $$locbase i2                   ; load slice pointer for logging data
lw $r452 $$locbase i3                   ; load slice size for logging data
logd $zero $r450 $r451 $r452            ; log slice
ji  .17
.17
cfsi i40                                ; free 40 bytes for locals and 0 slots for extra call arguments
popa .16                                ; restore all registers
jal $zero $$reta i0                     ; return from call
DIFF------------------------------
.program:
.16                                     ; --- start of function: local_log_48 ---
pusha .16                               ; save all registers
move $$locbase $sp                      ; save locals base register for function local_log_48
cfei i40                                ; allocate 40 bytes for locals and 0 slots for call arguments
.69
addi $r445 $$locbase i32                ; get offset to local __ptr { u64 }
mcpi $r445 $$arg0 i8                    ; copy memory
addi $r446 $$locbase i32                ; get offset to local __ptr { u64 }
sw $$locbase $r446 i0                   ; store word
movi $r448 i8                           ; initialize constant into register
sw $$locbase $r448 i1                   ; store word
addi $r449 $$locbase i16                ; get offset to local __ptr slice
mcpi $r449 $$locbase i16                ; copy memory
load $r450 data_NonConfigurable_4       ; load constant from data section
lw $r451 $$locbase i2                   ; load slice pointer for logging data
lw $r452 $$locbase i3                   ; load slice size for logging data
logd $zero $r450 $r451 $r452            ; log slice
.17
cfsi i40                                ; free 40 bytes for locals and 0 slots for extra call arguments
popa .16                                ; restore all registers
jal $zero $$reta i0                     ; return from call
DIFF------------------------------
.program:
.16                                     ; --- start of function: local_log_48 ---
pusha .16                               ; save all registers
move $$locbase $sp                      ; save locals base register for function local_log_48
cfei i40                                ; allocate 40 bytes for locals and 0 slots for call arguments
.69
addi $r445 $$locbase i32                ; get offset to local __ptr { u64 }
mcpi $r445 $$arg0 i8                    ; copy memory
addi $r446 $$locbase i32                ; get offset to local __ptr { u64 }
sw $$locbase $r446 i0                   ; store word
movi $r448 i8                           ; initialize constant into register
sw $$locbase $r448 i1                   ; store word
addi $r449 $$locbase i16                ; get offset to local __ptr slice
mcpi $r449 $$locbase i16                ; copy memory
load $r450 data_NonConfigurable_4       ; load constant from data section
lw $r451 $$locbase i2                   ; load slice pointer for logging data
lw $r452 $$locbase i3                   ; load slice size for logging data
logd $zero $r450 $r451 $r452            ; log slice
.17
cfsi i40                                ; free 40 bytes for locals and 0 slots for extra call arguments
popa .16                                ; restore all registers
jal $zero $$reta i0                     ; return from call
DIFF------------------------------
.program:
.16                                     ; --- start of function: local_log_48 ---
pusha .16                               ; save all registers
move $$locbase $sp                      ; save locals base register for function local_log_48
cfei i40                                ; allocate 40 bytes for locals and 0 slots for call arguments
.69
addi $r445 $$locbase i32                ; get offset to local __ptr { u64 }
mcpi $r445 $$arg0 i8                    ; copy memory
addi $r446 $$locbase i32                ; get offset to local __ptr { u64 }
sw $$locbase $r446 i0                   ; store word
movi $r448 i8                           ; initialize constant into register
sw $$locbase $r448 i1                   ; store word
addi $r449 $$locbase i16                ; get offset to local __ptr slice
mcpi $r449 $$locbase i16                ; copy memory
load $r450 data_NonConfigurable_4       ; load constant from data section
lw $r451 $$locbase i2                   ; load slice pointer for logging data
lw $r452 $$locbase i3                   ; load slice size for logging data
logd $zero $r450 $r451 $r452            ; log slice
.17
cfsi i40                                ; free 40 bytes for locals and 0 slots for extra call arguments
popa .16                                ; restore all registers
jal $zero $$reta i0                     ; return from call
DIFF------------------------------
.program:
.18                                     ; --- start of function: abi_encode_52 ---
pusha .18                               ; save all registers
move $$locbase $sp                      ; save locals base register for function abi_encode_52
cfei i0                                 ; allocate 0 bytes for locals and 0 slots for call arguments
move $r453 $$arg0                       ; save argument 0 (self)
move $r454 $$arg1                       ; save argument 1 (buffer)
move $r455 $$arg2                       ; save argument 2 (__ret_value)
move $r456 $$reta                       ; save return address
.70
 lw $r457 $r453 i0                       ; load word
 lw $r457 $$arg0 i0                      ; load word
move $$arg0 $r457                       ; [call]: pass argument 0
 move $$arg1 $r454                       ; [call]: pass argument 1
 move $$arg2 $r455                       ; [call]: pass argument 2
 move $$arg1 $$arg1                      ; [call]: pass argument 1
 move $$arg2 $$arg2                      ; [call]: pass argument 2
fncall .6                               ; [call]: call abi_encode_5
 move $r458 $zero                        ; [call]: return unit value
 movi $r458 i0                           ; [call]: return unit value
ji  .19
.19
cfsi i0                                 ; free 0 bytes for locals and 0 slots for extra call arguments
move $$reta $r456                       ; restore return address
popa .18                                ; restore all registers
jal $zero $$reta i0                     ; return from call
DIFF------------------------------
.program:
.18                                     ; --- start of function: abi_encode_52 ---
pusha .18                               ; save all registers
move $$locbase $sp                      ; save locals base register for function abi_encode_52
move $r456 $$reta                       ; save return address
.70
lw $r457 $$arg0 i0                      ; load word
move $$arg0 $r457                       ; [call]: pass argument 0
fncall .6                               ; [call]: call abi_encode_5
.19
move $$reta $r456                       ; restore return address
popa .18                                ; restore all registers
jal $zero $$reta i0                     ; return from call
DIFF------------------------------
.program:
.18                                     ; --- start of function: abi_encode_52 ---
pusha .18                               ; save all registers
move $$locbase $sp                      ; save locals base register for function abi_encode_52
move $r456 $$reta                       ; save return address
.70
lw $r457 $$arg0 i0                      ; load word
move $$arg0 $r457                       ; [call]: pass argument 0
fncall .6                               ; [call]: call abi_encode_5
.19
move $$reta $r456                       ; restore return address
popa .18                                ; restore all registers
jal $zero $$reta i0                     ; return from call
DIFF------------------------------
.program:
.18                                     ; --- start of function: abi_encode_52 ---
pusha .18                               ; save all registers
move $$locbase $sp                      ; save locals base register for function abi_encode_52
move $r456 $$reta                       ; save return address
.70
lw $r457 $$arg0 i0                      ; load word
move $$arg0 $r457                       ; [call]: pass argument 0
fncall .6                               ; [call]: call abi_encode_5
.19
move $$reta $r456                       ; restore return address
popa .18                                ; restore all registers
jal $zero $$reta i0                     ; return from call
DIFF------------------------------
.program:
.20                                     ; --- start of function: local_log_53 ---
pusha .20                               ; save all registers
move $$locbase $sp                      ; save locals base register for function local_log_53
cfei i120                               ; allocate 120 bytes for locals and 0 slots for call arguments
move $r459 $$arg0                       ; save argument 0 (item)
move $r460 $$reta                       ; save return address
.71
addi $r461 $$locbase i32                ; get offset to local __ptr { u64, ( { u64 } | () ) }
 mcpi $r461 $r459 i16                    ; copy memory
 mcpi $r461 $$arg0 i16                   ; copy memory
addi $r462 $$locbase i32                ; get offset to local __ptr { u64, ( { u64 } | () ) }
 jnzi $zero .72
 
ji  .73
.73
addi $r463 $$locbase i72                ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r463                       ; [call]: pass argument 0
fncall .8                               ; [call]: call new_6
 move $r464 $zero                        ; [call]: return unit value
 movi $r464 i0                           ; [call]: return unit value
addi $r465 $$locbase i32                ; get offset to local __ptr { u64, ( { u64 } | () ) }
lw $r466 $$locbase i4                   ; load word
eq $r467 $r466 $zero
jnzi $r467 .74
ji  .75
.75
addi $r468 $$locbase i32                ; get offset to local __ptr { u64, ( { u64 } | () ) }
lw $r469 $$locbase i4                   ; load word
eq $r470 $r469 $one
jnzi $r470 .76
ji  .77
.77
load $r471 data_NonConfigurable_5       ; load constant from data section
rvrt $r471
.76
addi $r472 $$locbase i72                ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r473 $$locbase i48                ; get offset to local __ptr { { ptr, u64, u64 } }
 move $$arg0 $one                        ; [call]: pass argument 0
 movi $$arg0 i1                          ; [call]: pass argument 0
move $$arg1 $r472                       ; [call]: pass argument 1
move $$arg2 $r473                       ; [call]: pass argument 2
fncall .6                               ; [call]: call abi_encode_5
 move $r474 $zero                        ; [call]: return unit value
 movi $r474 i0                           ; [call]: return unit value
addi $r475 $$locbase i48                ; get offset to local __ptr { { ptr, u64, u64 } }
move $r476 $r475                        ; move parameter from branch to block argument
ji  .78
.74
addi $r477 $$locbase i32                ; get offset to local __ptr { u64, ( { u64 } | () ) }
addi $r478 $r477 i8                     ; get offset to aggregate element
addi $r479 $$locbase i72                ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r480 $$locbase i96                ; get offset to local __ptr { { ptr, u64, u64 } }
 move $$arg0 $zero                       ; [call]: pass argument 0
 movi $$arg0 i0                          ; [call]: pass argument 0
move $$arg1 $r479                       ; [call]: pass argument 1
move $$arg2 $r480                       ; [call]: pass argument 2
fncall .6                               ; [call]: call abi_encode_5
 move $r481 $zero                        ; [call]: return unit value
 movi $r481 i0                           ; [call]: return unit value
addi $r482 $$locbase i96                ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r483 $$locbase i48                ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r478                       ; [call]: pass argument 0
move $$arg1 $r482                       ; [call]: pass argument 1
move $$arg2 $r483                       ; [call]: pass argument 2
fncall .18                              ; [call]: call abi_encode_52
 move $r484 $zero                        ; [call]: return unit value
 movi $r484 i0                           ; [call]: return unit value
addi $r485 $$locbase i48                ; get offset to local __ptr { { ptr, u64, u64 } }
move $r476 $r485                        ; move parameter from branch to block argument
ji  .78
.78
move $r488 $r476                        ; move parameter from branch to block argument
addi $r489 $$locbase i16                ; get offset to local __ptr slice
 move $$arg0 $r488                       ; [call]: pass argument 0
 move $$arg0 $r476                       ; [call]: pass argument 0
move $$arg1 $r489                       ; [call]: pass argument 1
fncall .10                              ; [call]: call as_raw_slice_7
 move $r490 $zero                        ; [call]: return unit value
 movi $r490 i0                           ; [call]: return unit value
ji  .79
.72
sw $$locbase $r462 i0                   ; store word
addi $r491 $$locbase i8                 ; get offset to aggregate element
movi $r492 i16                          ; initialize constant into register
sw $$locbase $r492 i1                   ; store word
addi $r493 $$locbase i16                ; get offset to local __ptr slice
mcpi $r493 $$locbase i16                ; copy memory
ji  .79
.79
addi $r494 $$locbase i16                ; get offset to local __ptr slice
load $r495 data_NonConfigurable_6       ; load constant from data section
lw $r496 $$locbase i2                   ; load slice pointer for logging data
lw $r497 $$locbase i3                   ; load slice size for logging data
logd $zero $r495 $r496 $r497            ; log slice
ji  .21
.21
cfsi i120                               ; free 120 bytes for locals and 0 slots for extra call arguments
move $$reta $r460                       ; restore return address
popa .20                                ; restore all registers
jal $zero $$reta i0                     ; return from call
DIFF------------------------------
.program:
.20                                     ; --- start of function: local_log_53 ---
pusha .20                               ; save all registers
move $$locbase $sp                      ; save locals base register for function local_log_53
cfei i120                               ; allocate 120 bytes for locals and 0 slots for call arguments
move $r460 $$reta                       ; save return address
.71
addi $r461 $$locbase i32                ; get offset to local __ptr { u64, ( { u64 } | () ) }
mcpi $r461 $$arg0 i16                   ; copy memory
.73
addi $r463 $$locbase i72                ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r463                       ; [call]: pass argument 0
fncall .8                               ; [call]: call new_6
lw $r466 $$locbase i4                   ; load word
eq $r467 $r466 $zero
jnzi $r467 .74
.75
lw $r469 $$locbase i4                   ; load word
eq $r470 $r469 $one
jnzi $r470 .76
.77
load $r471 data_NonConfigurable_5       ; load constant from data section
rvrt $r471
.76
addi $r472 $$locbase i72                ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r473 $$locbase i48                ; get offset to local __ptr { { ptr, u64, u64 } }
movi $$arg0 i1                          ; [call]: pass argument 0
move $$arg1 $r472                       ; [call]: pass argument 1
move $$arg2 $r473                       ; [call]: pass argument 2
fncall .6                               ; [call]: call abi_encode_5
addi $r475 $$locbase i48                ; get offset to local __ptr { { ptr, u64, u64 } }
move $r476 $r475                        ; move parameter from branch to block argument
ji  .78
.74
addi $r477 $$locbase i32                ; get offset to local __ptr { u64, ( { u64 } | () ) }
addi $r478 $r477 i8                     ; get offset to aggregate element
addi $r479 $$locbase i72                ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r480 $$locbase i96                ; get offset to local __ptr { { ptr, u64, u64 } }
movi $$arg0 i0                          ; [call]: pass argument 0
move $$arg1 $r479                       ; [call]: pass argument 1
move $$arg2 $r480                       ; [call]: pass argument 2
fncall .6                               ; [call]: call abi_encode_5
addi $r482 $$locbase i96                ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r483 $$locbase i48                ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r478                       ; [call]: pass argument 0
move $$arg1 $r482                       ; [call]: pass argument 1
move $$arg2 $r483                       ; [call]: pass argument 2
fncall .18                              ; [call]: call abi_encode_52
addi $r485 $$locbase i48                ; get offset to local __ptr { { ptr, u64, u64 } }
move $r476 $r485                        ; move parameter from branch to block argument
.78
addi $r489 $$locbase i16                ; get offset to local __ptr slice
move $$arg0 $r476                       ; [call]: pass argument 0
move $$arg1 $r489                       ; [call]: pass argument 1
fncall .10                              ; [call]: call as_raw_slice_7
.79
load $r495 data_NonConfigurable_6       ; load constant from data section
lw $r496 $$locbase i2                   ; load slice pointer for logging data
lw $r497 $$locbase i3                   ; load slice size for logging data
logd $zero $r495 $r496 $r497            ; log slice
.21
cfsi i120                               ; free 120 bytes for locals and 0 slots for extra call arguments
move $$reta $r460                       ; restore return address
popa .20                                ; restore all registers
jal $zero $$reta i0                     ; return from call
DIFF------------------------------
.program:
.20                                     ; --- start of function: local_log_53 ---
pusha .20                               ; save all registers
move $$locbase $sp                      ; save locals base register for function local_log_53
cfei i120                               ; allocate 120 bytes for locals and 0 slots for call arguments
move $r460 $$reta                       ; save return address
.71
addi $r461 $$locbase i32                ; get offset to local __ptr { u64, ( { u64 } | () ) }
mcpi $r461 $$arg0 i16                   ; copy memory
.73
addi $r463 $$locbase i72                ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r463                       ; [call]: pass argument 0
fncall .8                               ; [call]: call new_6
lw $r466 $$locbase i4                   ; load word
eq $r467 $r466 $zero
jnzi $r467 .74
.75
lw $r469 $$locbase i4                   ; load word
eq $r470 $r469 $one
jnzi $r470 .76
.77
load $r471 data_NonConfigurable_5       ; load constant from data section
rvrt $r471
.76
addi $r472 $$locbase i72                ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r473 $$locbase i48                ; get offset to local __ptr { { ptr, u64, u64 } }
movi $$arg0 i1                          ; [call]: pass argument 0
move $$arg1 $r472                       ; [call]: pass argument 1
move $$arg2 $r473                       ; [call]: pass argument 2
fncall .6                               ; [call]: call abi_encode_5
addi $r475 $$locbase i48                ; get offset to local __ptr { { ptr, u64, u64 } }
move $r476 $r475                        ; move parameter from branch to block argument
ji  .78
.74
addi $r477 $$locbase i32                ; get offset to local __ptr { u64, ( { u64 } | () ) }
addi $r478 $r477 i8                     ; get offset to aggregate element
addi $r479 $$locbase i72                ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r480 $$locbase i96                ; get offset to local __ptr { { ptr, u64, u64 } }
movi $$arg0 i0                          ; [call]: pass argument 0
move $$arg1 $r479                       ; [call]: pass argument 1
move $$arg2 $r480                       ; [call]: pass argument 2
fncall .6                               ; [call]: call abi_encode_5
addi $r482 $$locbase i96                ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r483 $$locbase i48                ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r478                       ; [call]: pass argument 0
move $$arg1 $r482                       ; [call]: pass argument 1
move $$arg2 $r483                       ; [call]: pass argument 2
fncall .18                              ; [call]: call abi_encode_52
addi $r485 $$locbase i48                ; get offset to local __ptr { { ptr, u64, u64 } }
move $r476 $r485                        ; move parameter from branch to block argument
.78
addi $r489 $$locbase i16                ; get offset to local __ptr slice
move $$arg0 $r476                       ; [call]: pass argument 0
move $$arg1 $r489                       ; [call]: pass argument 1
fncall .10                              ; [call]: call as_raw_slice_7
.79
load $r495 data_NonConfigurable_6       ; load constant from data section
lw $r496 $$locbase i2                   ; load slice pointer for logging data
lw $r497 $$locbase i3                   ; load slice size for logging data
logd $zero $r495 $r496 $r497            ; log slice
.21
cfsi i120                               ; free 120 bytes for locals and 0 slots for extra call arguments
move $$reta $r460                       ; restore return address
popa .20                                ; restore all registers
jal $zero $$reta i0                     ; return from call
DIFF------------------------------
.program:
.20                                     ; --- start of function: local_log_53 ---
pusha .20                               ; save all registers
move $$locbase $sp                      ; save locals base register for function local_log_53
cfei i120                               ; allocate 120 bytes for locals and 0 slots for call arguments
move $r460 $$reta                       ; save return address
.71
addi $r461 $$locbase i32                ; get offset to local __ptr { u64, ( { u64 } | () ) }
mcpi $r461 $$arg0 i16                   ; copy memory
.73
addi $r463 $$locbase i72                ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r463                       ; [call]: pass argument 0
fncall .8                               ; [call]: call new_6
lw $r466 $$locbase i4                   ; load word
eq $r467 $r466 $zero
jnzi $r467 .74
.75
lw $r469 $$locbase i4                   ; load word
eq $r470 $r469 $one
jnzi $r470 .76
.77
load $r471 data_NonConfigurable_5       ; load constant from data section
rvrt $r471
.76
addi $r472 $$locbase i72                ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r473 $$locbase i48                ; get offset to local __ptr { { ptr, u64, u64 } }
movi $$arg0 i1                          ; [call]: pass argument 0
move $$arg1 $r472                       ; [call]: pass argument 1
move $$arg2 $r473                       ; [call]: pass argument 2
fncall .6                               ; [call]: call abi_encode_5
addi $r475 $$locbase i48                ; get offset to local __ptr { { ptr, u64, u64 } }
move $r476 $r475                        ; move parameter from branch to block argument
ji  .78
.74
addi $r477 $$locbase i32                ; get offset to local __ptr { u64, ( { u64 } | () ) }
addi $r478 $r477 i8                     ; get offset to aggregate element
addi $r479 $$locbase i72                ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r480 $$locbase i96                ; get offset to local __ptr { { ptr, u64, u64 } }
movi $$arg0 i0                          ; [call]: pass argument 0
move $$arg1 $r479                       ; [call]: pass argument 1
move $$arg2 $r480                       ; [call]: pass argument 2
fncall .6                               ; [call]: call abi_encode_5
addi $r482 $$locbase i96                ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r483 $$locbase i48                ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r478                       ; [call]: pass argument 0
move $$arg1 $r482                       ; [call]: pass argument 1
move $$arg2 $r483                       ; [call]: pass argument 2
fncall .18                              ; [call]: call abi_encode_52
addi $r485 $$locbase i48                ; get offset to local __ptr { { ptr, u64, u64 } }
move $r476 $r485                        ; move parameter from branch to block argument
.78
addi $r489 $$locbase i16                ; get offset to local __ptr slice
move $$arg0 $r476                       ; [call]: pass argument 0
move $$arg1 $r489                       ; [call]: pass argument 1
fncall .10                              ; [call]: call as_raw_slice_7
.79
load $r495 data_NonConfigurable_6       ; load constant from data section
lw $r496 $$locbase i2                   ; load slice pointer for logging data
lw $r497 $$locbase i3                   ; load slice size for logging data
logd $zero $r495 $r496 $r497            ; log slice
.21
cfsi i120                               ; free 120 bytes for locals and 0 slots for extra call arguments
move $$reta $r460                       ; restore return address
popa .20                                ; restore all registers
jal $zero $$reta i0                     ; return from call
DIFF------------------------------
.program:
.22                                     ; --- start of function: local_log_60 ---
pusha .22                               ; save all registers
move $$locbase $sp                      ; save locals base register for function local_log_60
cfei i64                                ; allocate 64 bytes for locals and 0 slots for call arguments
move $r498 $$arg0                       ; save argument 0 (item)
move $r499 $$reta                       ; save return address
.80
addi $r500 $$locbase i40                ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r500                       ; [call]: pass argument 0
fncall .8                               ; [call]: call new_6
 move $r501 $zero                        ; [call]: return unit value
 movi $r501 i0                           ; [call]: return unit value
addi $r502 $$locbase i40                ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r503 $$locbase i16                ; get offset to local __ptr { { ptr, u64, u64 } }
movi $r504 i77                          ; initialize constant into register
 move $$arg0 $r504                       ; [call]: pass argument 0
 movi $$arg0 i77                         ; [call]: pass argument 0
move $$arg1 $r502                       ; [call]: pass argument 1
move $$arg2 $r503                       ; [call]: pass argument 2
fncall .6                               ; [call]: call abi_encode_5
 move $r505 $zero                        ; [call]: return unit value
 movi $r505 i0                           ; [call]: return unit value
addi $r506 $$locbase i16                ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r506                       ; [call]: pass argument 0
move $$arg1 $$locbase                   ; [call]: pass argument 1
fncall .10                              ; [call]: call as_raw_slice_7
 move $r507 $zero                        ; [call]: return unit value
 movi $r507 i0                           ; [call]: return unit value
load $r508 data_NonConfigurable_7       ; load constant from data section
lw $r509 $$locbase i0                   ; load slice pointer for logging data
lw $r510 $$locbase i1                   ; load slice size for logging data
logd $zero $r508 $r509 $r510            ; log slice
ji  .23
.23
cfsi i64                                ; free 64 bytes for locals and 0 slots for extra call arguments
move $$reta $r499                       ; restore return address
popa .22                                ; restore all registers
jal $zero $$reta i0                     ; return from call
DIFF------------------------------
.program:
.22                                     ; --- start of function: local_log_60 ---
pusha .22                               ; save all registers
move $$locbase $sp                      ; save locals base register for function local_log_60
cfei i64                                ; allocate 64 bytes for locals and 0 slots for call arguments
move $r499 $$reta                       ; save return address
.80
addi $r500 $$locbase i40                ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r500                       ; [call]: pass argument 0
fncall .8                               ; [call]: call new_6
addi $r502 $$locbase i40                ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r503 $$locbase i16                ; get offset to local __ptr { { ptr, u64, u64 } }
movi $$arg0 i77                         ; [call]: pass argument 0
move $$arg1 $r502                       ; [call]: pass argument 1
move $$arg2 $r503                       ; [call]: pass argument 2
fncall .6                               ; [call]: call abi_encode_5
addi $r506 $$locbase i16                ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r506                       ; [call]: pass argument 0
move $$arg1 $$locbase                   ; [call]: pass argument 1
fncall .10                              ; [call]: call as_raw_slice_7
load $r508 data_NonConfigurable_7       ; load constant from data section
lw $r509 $$locbase i0                   ; load slice pointer for logging data
lw $r510 $$locbase i1                   ; load slice size for logging data
logd $zero $r508 $r509 $r510            ; log slice
.23
cfsi i64                                ; free 64 bytes for locals and 0 slots for extra call arguments
move $$reta $r499                       ; restore return address
popa .22                                ; restore all registers
jal $zero $$reta i0                     ; return from call
DIFF------------------------------
.program:
.22                                     ; --- start of function: local_log_60 ---
pusha .22                               ; save all registers
move $$locbase $sp                      ; save locals base register for function local_log_60
cfei i64                                ; allocate 64 bytes for locals and 0 slots for call arguments
move $r499 $$reta                       ; save return address
.80
addi $r500 $$locbase i40                ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r500                       ; [call]: pass argument 0
fncall .8                               ; [call]: call new_6
addi $r502 $$locbase i40                ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r503 $$locbase i16                ; get offset to local __ptr { { ptr, u64, u64 } }
movi $$arg0 i77                         ; [call]: pass argument 0
move $$arg1 $r502                       ; [call]: pass argument 1
move $$arg2 $r503                       ; [call]: pass argument 2
fncall .6                               ; [call]: call abi_encode_5
addi $r506 $$locbase i16                ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r506                       ; [call]: pass argument 0
move $$arg1 $$locbase                   ; [call]: pass argument 1
fncall .10                              ; [call]: call as_raw_slice_7
load $r508 data_NonConfigurable_7       ; load constant from data section
lw $r509 $$locbase i0                   ; load slice pointer for logging data
lw $r510 $$locbase i1                   ; load slice size for logging data
logd $zero $r508 $r509 $r510            ; log slice
.23
cfsi i64                                ; free 64 bytes for locals and 0 slots for extra call arguments
move $$reta $r499                       ; restore return address
popa .22                                ; restore all registers
jal $zero $$reta i0                     ; return from call
DIFF------------------------------
.program:
.22                                     ; --- start of function: local_log_60 ---
pusha .22                               ; save all registers
move $$locbase $sp                      ; save locals base register for function local_log_60
cfei i64                                ; allocate 64 bytes for locals and 0 slots for call arguments
move $r499 $$reta                       ; save return address
.80
addi $r500 $$locbase i40                ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r500                       ; [call]: pass argument 0
fncall .8                               ; [call]: call new_6
addi $r502 $$locbase i40                ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r503 $$locbase i16                ; get offset to local __ptr { { ptr, u64, u64 } }
movi $$arg0 i77                         ; [call]: pass argument 0
move $$arg1 $r502                       ; [call]: pass argument 1
move $$arg2 $r503                       ; [call]: pass argument 2
fncall .6                               ; [call]: call abi_encode_5
addi $r506 $$locbase i16                ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r506                       ; [call]: pass argument 0
move $$arg1 $$locbase                   ; [call]: pass argument 1
fncall .10                              ; [call]: call as_raw_slice_7
load $r508 data_NonConfigurable_7       ; load constant from data section
lw $r509 $$locbase i0                   ; load slice pointer for logging data
lw $r510 $$locbase i1                   ; load slice size for logging data
logd $zero $r508 $r509 $r510            ; log slice
.23
cfsi i64                                ; free 64 bytes for locals and 0 slots for extra call arguments
move $$reta $r499                       ; restore return address
popa .22                                ; restore all registers
jal $zero $$reta i0                     ; return from call
warning: Returned value is ignored
  --> test/src/e2e_vm_tests/test_programs/should_pass/language/logging/src/main.sw:80:5
   |
...
80 |     main();
   |     ------ This returns a value which is not assigned to anything and is ignored.
   |     ------ help: The returned value has type "u64".
   |
   = help: If you want to intentionally ignore the returned value, use `let _ = ...`:
   = help:   let _ = main();
____

warning
  --> test/src/e2e_vm_tests/test_programs/should_pass/language/logging/src/main.sw:27:5
   |
25 | 
26 | enum F {
27 |     A: ()
   |     - Enum variant A is never constructed.
28 | }
29 | 
   |
____

warning
  --> test/src/e2e_vm_tests/test_programs/should_pass/language/logging/src/main.sw:26:6
   |
24 | }
25 | 
26 | enum F {
   |      - This enum is never used.
27 |     A: ()
28 | }
   |
____

warning
  --> test/src/e2e_vm_tests/test_programs/should_pass/language/logging/src/main.sw:35:5
   |
33 |   impl AbiEncode for CustomAbiEncode {
34 |       fn is_encode_trivial() -> bool { false }
35 |       fn abi_encode(self, buffer: Buffer) -> Buffer {
   |  _____-
36 | |         77u64.abi_encode(buffer)
37 | |     }
   | |_____- This method is never called.
38 |   }
39 |   
   |
____

warning
  --> test/src/e2e_vm_tests/test_programs/should_pass/language/logging/src/main.sw:34:5
   |
32 | 
33 | impl AbiEncode for CustomAbiEncode {
34 |     fn is_encode_trivial() -> bool { false }
   |     ---------------------------------------- This method is never called.
35 |     fn abi_encode(self, buffer: Buffer) -> Buffer {
36 |         77u64.abi_encode(buffer)
   |
____

warning
  --> test/src/e2e_vm_tests/test_programs/should_pass/language/logging/src/main.sw:40:8
   |
38 | }
39 | 
40 | struct NotAutoEncodable {
   |        ---------------- This struct is never used.
41 |     p: raw_ptr
42 | }
   |
____

warning
  --> test/src/e2e_vm_tests/test_programs/should_pass/language/logging/src/main.sw:41:5
   |
39 | 
40 | struct NotAutoEncodable {
41 |     p: raw_ptr
   |     - This struct field is never accessed.
42 | }
43 | 
   |
____

  Compiled script "logging" with 7 warnings.
    Finished release [optimized + fuel] target(s) [2.8 KB] in ???
     Running 1 test, filtered 0 tests

tested -- logging

<<<<<<< HEAD
      test call_main ... ok (???, 5570 gas)
=======
      test call_main ... ok (???, 5572 gas)
>>>>>>> 0f3fd4cde (replave move by movi when possible on asm optimisation)

test result: OK. 1 passed; 0 failed; finished in ???

    Finished in ???
