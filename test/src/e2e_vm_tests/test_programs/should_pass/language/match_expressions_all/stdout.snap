---
source: test/src/snapshot/mod.rs
---
> forc build --path test/src/e2e_vm_tests/test_programs/should_pass/language/match_expressions_all
exit status: 0
output:
    Building test/src/e2e_vm_tests/test_programs/should_pass/language/match_expressions_all
   Compiling library std (test/src/e2e_vm_tests/reduced_std_libs/sway-lib-std-assert)
DIFF------------------------------
.program:
   Compiling script match_expressions_all (test/src/e2e_vm_tests/test_programs/should_pass/language/match_expressions_all)
DIFF------------------------------
.program:
DIFF------------------------------
.program:
.0                                      ; --- start of function: __entry ---
move $$locbase $sp                      ; save locals base register for function __entry
cfei i0                                 ; allocate 0 bytes for locals and 0 slots for call arguments
.18
fncall .2                               ; [call]: call main_0
 move $r1 $zero                          ; [call]: return unit value
 movi $r1 i0                             ; [call]: return unit value
retd $zero $zero
DIFF------------------------------
.program:
.2                                      ; --- start of function: main_0 ---
pusha .2                                ; save all registers
move $$locbase $sp                      ; save locals base register for function main_0
cfei i1064                              ; allocate 1064 bytes for locals and 0 slots for call arguments
move $r2 $$reta                         ; save return address
.19
addi $r3 $$locbase i360                 ; get offset to local __ptr u64
movi $r4 i8                             ; initialize constant into register
sw $$locbase $r4 i45                    ; store word
addi $r5 $$locbase i576                 ; get offset to local __ptr u64
movi $r6 i7                             ; initialize constant into register
sw $$locbase $r6 i72                    ; store word
addi $r7 $$locbase i360                 ; get offset to local __ptr u64
lw $r8 $$locbase i45                    ; load word
addi $r9 $$locbase i576                 ; get offset to local __ptr u64
lw $r10 $$locbase i72                   ; load word
eq $r11 $r8 $r10
movi $r12 i4                            ; initialize constant into register
 move $r13 $r12                          ; move parameter from branch to block argument
 movi $r13 i4                            ; move parameter from branch to block argument
jnzi $r11 .20
ji  .21
.21
addi $r14 $$locbase i360                ; get offset to local __ptr u64
addi $r15 $$locbase i584                ; get offset to local __ptr u64
movi $r16 i9                            ; initialize constant into register
sw $$locbase $r16 i73                   ; store word
lw $r17 $$locbase i45                   ; load word
addi $r18 $$locbase i584                ; get offset to local __ptr u64
lw $r19 $$locbase i73                   ; load word
eq $r20 $r17 $r19
movi $r21 i5                            ; initialize constant into register
 move $r22 $r21                          ; move parameter from branch to block argument
 movi $r22 i5                            ; move parameter from branch to block argument
jnzi $r20 .22
ji  .23
.23
addi $r23 $$locbase i360                ; get offset to local __ptr u64
addi $r24 $$locbase i592                ; get offset to local __ptr u64
movi $r25 i8                            ; initialize constant into register
sw $$locbase $r25 i74                   ; store word
lw $r26 $$locbase i45                   ; load word
addi $r27 $$locbase i592                ; get offset to local __ptr u64
lw $r28 $$locbase i74                   ; load word
eq $r29 $r26 $r28
movi $r30 i42                           ; initialize constant into register
 move $r31 $r30                          ; move parameter from branch to block argument
 movi $r31 i42                           ; move parameter from branch to block argument
jnzi $r29 .24
ji  .25
.25
movi $r32 i100                          ; initialize constant into register
 move $r31 $r32                          ; move parameter from branch to block argument
 movi $r31 i100                          ; move parameter from branch to block argument
ji  .24
.24
move $r35 $r31                          ; move parameter from branch to block argument
 move $r22 $r35                          ; move parameter from branch to block argument
 move $r22 $r31                          ; move parameter from branch to block argument
ji  .22
.22
move $r38 $r22                          ; move parameter from branch to block argument
 move $r13 $r38                          ; move parameter from branch to block argument
 move $r13 $r22                          ; move parameter from branch to block argument
ji  .20
.20
move $r41 $r13                          ; move parameter from branch to block argument
addi $r42 $$locbase i1008               ; get offset to local __ptr u64
 sw $$locbase $r41 i126                  ; store word
 sw $$locbase $r13 i126                  ; store word
addi $r43 $$locbase i664                ; get offset to local __ptr u64
movi $r44 i42                           ; initialize constant into register
sw $$locbase $r44 i83                   ; store word
addi $r45 $$locbase i1008               ; get offset to local __ptr u64
lw $r46 $$locbase i126                  ; load word
addi $r47 $$locbase i664                ; get offset to local __ptr u64
lw $r48 $$locbase i83                   ; load word
eq $r49 $r46 $r48
move $$arg0 $r49                        ; [call]: pass argument 0
fncall .4                               ; [call]: call assert_2
 move $r50 $zero                         ; [call]: return unit value
 movi $r50 i0                            ; [call]: return unit value
addi $r51 $$locbase i520                ; get offset to local __ptr u64
movi $r52 i5                            ; initialize constant into register
sw $$locbase $r52 i65                   ; store word
addi $r53 $$locbase i520                ; get offset to local __ptr u64
addi $r54 $$locbase i368                ; get offset to local __ptr u64
mcpi $r54 $r53 i8                       ; copy memory
addi $r55 $$locbase i752                ; get offset to local __ptr u64
movi $r56 i7                            ; initialize constant into register
sw $$locbase $r56 i94                   ; store word
lw $r57 $$locbase i65                   ; load word
addi $r58 $$locbase i752                ; get offset to local __ptr u64
lw $r59 $$locbase i94                   ; load word
eq $r60 $r57 $r59
movi $r61 i4                            ; initialize constant into register
 move $r62 $r61                          ; move parameter from branch to block argument
 movi $r62 i4                            ; move parameter from branch to block argument
jnzi $r60 .26
ji  .27
.27
addi $r63 $$locbase i368                ; get offset to local __ptr u64
addi $r64 $$locbase i840                ; get offset to local __ptr u64
movi $r65 i5                            ; initialize constant into register
sw $$locbase $r65 i105                  ; store word
lw $r66 $$locbase i46                   ; load word
addi $r67 $$locbase i840                ; get offset to local __ptr u64
lw $r68 $$locbase i105                  ; load word
eq $r69 $r66 $r68
movi $r70 i42                           ; initialize constant into register
 move $r71 $r70                          ; move parameter from branch to block argument
 movi $r71 i42                           ; move parameter from branch to block argument
jnzi $r69 .28
ji  .29
.29
movi $r72 i24                           ; initialize constant into register
 move $r71 $r72                          ; move parameter from branch to block argument
 movi $r71 i24                           ; move parameter from branch to block argument
ji  .28
.28
move $r75 $r71                          ; move parameter from branch to block argument
 move $r62 $r75                          ; move parameter from branch to block argument
 move $r62 $r71                          ; move parameter from branch to block argument
ji  .26
.26
move $r78 $r62                          ; move parameter from branch to block argument
addi $r79 $$locbase i1016               ; get offset to local __ptr u64
 sw $$locbase $r78 i127                  ; store word
 sw $$locbase $r62 i127                  ; store word
addi $r80 $$locbase i864                ; get offset to local __ptr u64
movi $r81 i42                           ; initialize constant into register
sw $$locbase $r81 i108                  ; store word
addi $r82 $$locbase i1016               ; get offset to local __ptr u64
lw $r83 $$locbase i127                  ; load word
addi $r84 $$locbase i864                ; get offset to local __ptr u64
lw $r85 $$locbase i108                  ; load word
eq $r86 $r83 $r85
move $$arg0 $r86                        ; [call]: pass argument 0
fncall .4                               ; [call]: call assert_2
 move $r87 $zero                         ; [call]: return unit value
 movi $r87 i0                            ; [call]: return unit value
addi $r88 $$locbase i528                ; get offset to local __ptr u64
movi $r89 i5                            ; initialize constant into register
sw $$locbase $r89 i66                   ; store word
addi $r90 $$locbase i528                ; get offset to local __ptr u64
addi $r91 $$locbase i376                ; get offset to local __ptr u64
mcpi $r91 $r90 i8                       ; copy memory
addi $r92 $$locbase i872                ; get offset to local __ptr u64
movi $r93 i7                            ; initialize constant into register
sw $$locbase $r93 i109                  ; store word
lw $r94 $$locbase i66                   ; load word
addi $r95 $$locbase i872                ; get offset to local __ptr u64
lw $r96 $$locbase i109                  ; load word
eq $r97 $r94 $r96
move $r98 $r97                          ; move parameter from branch to block argument
jnzi $r97 .30
ji  .31
.31
addi $r99 $$locbase i376                ; get offset to local __ptr u64
addi $r100 $$locbase i880               ; get offset to local __ptr u64
movi $r101 i8                           ; initialize constant into register
sw $$locbase $r101 i110                 ; store word
lw $r102 $$locbase i47                  ; load word
addi $r103 $$locbase i880               ; get offset to local __ptr u64
lw $r104 $$locbase i110                 ; load word
eq $r105 $r102 $r104
move $r106 $r105                        ; move parameter from branch to block argument
jnzi $r105 .32
ji  .33
.33
addi $r107 $$locbase i376               ; get offset to local __ptr u64
addi $r108 $$locbase i888               ; get offset to local __ptr u64
movi $r109 i9                           ; initialize constant into register
sw $$locbase $r109 i111                 ; store word
lw $r110 $$locbase i47                  ; load word
addi $r111 $$locbase i888               ; get offset to local __ptr u64
lw $r112 $$locbase i111                 ; load word
eq $r113 $r110 $r112
move $r106 $r113                        ; move parameter from branch to block argument
ji  .32
.32
move $r116 $r106                        ; move parameter from branch to block argument
 move $r98 $r116                         ; move parameter from branch to block argument
 move $r98 $r106                         ; move parameter from branch to block argument
ji  .30
.30
move $r119 $r98                         ; move parameter from branch to block argument
movi $r120 i4                           ; initialize constant into register
 move $r121 $r120                        ; move parameter from branch to block argument
 jnzi $r119 .34
 movi $r121 i4                           ; move parameter from branch to block argument
 jnzi $r98 .34
ji  .35
.35
addi $r122 $$locbase i376               ; get offset to local __ptr u64
addi $r123 $$locbase i896               ; get offset to local __ptr u64
movi $r124 i3                           ; initialize constant into register
sw $$locbase $r124 i112                 ; store word
lw $r125 $$locbase i47                  ; load word
addi $r126 $$locbase i896               ; get offset to local __ptr u64
lw $r127 $$locbase i112                 ; load word
eq $r128 $r125 $r127
move $r129 $r128                        ; move parameter from branch to block argument
jnzi $r128 .36
ji  .37
.37
addi $r130 $$locbase i376               ; get offset to local __ptr u64
addi $r131 $$locbase i600               ; get offset to local __ptr u64
movi $r132 i4                           ; initialize constant into register
sw $$locbase $r132 i75                  ; store word
lw $r133 $$locbase i47                  ; load word
addi $r134 $$locbase i600               ; get offset to local __ptr u64
lw $r135 $$locbase i75                  ; load word
eq $r136 $r133 $r135
move $r137 $r136                        ; move parameter from branch to block argument
jnzi $r136 .38
ji  .39
.39
addi $r138 $$locbase i376               ; get offset to local __ptr u64
addi $r139 $$locbase i608               ; get offset to local __ptr u64
movi $r140 i5                           ; initialize constant into register
sw $$locbase $r140 i76                  ; store word
lw $r141 $$locbase i47                  ; load word
addi $r142 $$locbase i608               ; get offset to local __ptr u64
lw $r143 $$locbase i76                  ; load word
eq $r144 $r141 $r143
move $r137 $r144                        ; move parameter from branch to block argument
ji  .38
.38
move $r147 $r137                        ; move parameter from branch to block argument
 move $r129 $r147                        ; move parameter from branch to block argument
 move $r129 $r137                        ; move parameter from branch to block argument
ji  .36
.36
move $r150 $r129                        ; move parameter from branch to block argument
movi $r151 i42                          ; initialize constant into register
 move $r152 $r151                        ; move parameter from branch to block argument
 jnzi $r150 .40
 movi $r152 i42                          ; move parameter from branch to block argument
 jnzi $r129 .40
ji  .41
.41
movi $r153 i24                          ; initialize constant into register
 move $r152 $r153                        ; move parameter from branch to block argument
 movi $r152 i24                          ; move parameter from branch to block argument
ji  .40
.40
move $r156 $r152                        ; move parameter from branch to block argument
 move $r121 $r156                        ; move parameter from branch to block argument
 move $r121 $r152                        ; move parameter from branch to block argument
ji  .34
.34
move $r159 $r121                        ; move parameter from branch to block argument
addi $r160 $$locbase i1024              ; get offset to local __ptr u64
 sw $$locbase $r159 i128                 ; store word
 sw $$locbase $r121 i128                 ; store word
addi $r161 $$locbase i616               ; get offset to local __ptr u64
movi $r162 i42                          ; initialize constant into register
sw $$locbase $r162 i77                  ; store word
addi $r163 $$locbase i1024              ; get offset to local __ptr u64
lw $r164 $$locbase i128                 ; load word
addi $r165 $$locbase i616               ; get offset to local __ptr u64
lw $r166 $$locbase i77                  ; load word
eq $r167 $r164 $r166
move $$arg0 $r167                       ; [call]: pass argument 0
fncall .4                               ; [call]: call assert_2
 move $r168 $zero                        ; [call]: return unit value
 movi $r168 i0                           ; [call]: return unit value
addi $r169 $$locbase i560               ; get offset to local __ptr u64
sw $$locbase $zero i70                  ; store word
addi $r170 $$locbase i560               ; get offset to local __ptr u64
addi $r171 $$locbase i440               ; get offset to local __ptr { u64, u64, u64 }
move $$arg0 $r170                       ; [call]: pass argument 0
move $$arg1 $r171                       ; [call]: pass argument 1
fncall .6                               ; [call]: call inc_i_5
 move $r172 $zero                        ; [call]: return unit value
 movi $r172 i0                           ; [call]: return unit value
addi $r173 $$locbase i384               ; get offset to local __ptr { u64, u64, u64 }
mcpi $r173 $r171 i24                    ; copy memory
addi $r174 $$locbase i384               ; get offset to local __ptr { u64, u64, u64 }
addi $r175 $r174 i16                    ; get offset to aggregate element
addi $r176 $$locbase i624               ; get offset to local __ptr u64
sw $$locbase $zero i78                  ; store word
lw $r177 $$locbase i50                  ; load word
addi $r178 $$locbase i624               ; get offset to local __ptr u64
lw $r179 $$locbase i78                  ; load word
eq $r180 $r177 $r179
jnzi $r180 .42
ji  .43
.43
addi $r181 $$locbase i384               ; get offset to local __ptr { u64, u64, u64 }
addi $r182 $r181 i16                    ; get offset to aggregate element
addi $r183 $$locbase i632               ; get offset to local __ptr u64
sw $$locbase $one i79                   ; store word
lw $r184 $$locbase i50                  ; load word
addi $r185 $$locbase i632               ; get offset to local __ptr u64
lw $r186 $$locbase i79                  ; load word
eq $r187 $r184 $r186
movi $r188 i24                          ; initialize constant into register
 move $r189 $r188                        ; move parameter from branch to block argument
 movi $r189 i24                          ; move parameter from branch to block argument
jnzi $r187 .44
ji  .45
.44
addi $r190 $$locbase i384               ; get offset to local __ptr { u64, u64, u64 }
addi $r191 $$locbase i384               ; get offset to local __ptr { u64, u64, u64 }
addi $r192 $r191 i8                     ; get offset to aggregate element
lw $r193 $$locbase i48                  ; load word
lw $r194 $$locbase i49                  ; load word
add $r195 $r193 $r194
move $r189 $r195                        ; move parameter from branch to block argument
ji  .45
.45
move $r198 $r189                        ; move parameter from branch to block argument
 move $r199 $r198                        ; move parameter from branch to block argument
 move $r199 $r189                        ; move parameter from branch to block argument
ji  .46
.42
addi $r200 $$locbase i384               ; get offset to local __ptr { u64, u64, u64 }
addi $r201 $$locbase i384               ; get offset to local __ptr { u64, u64, u64 }
addi $r202 $r201 i8                     ; get offset to aggregate element
lw $r203 $$locbase i48                  ; load word
lw $r204 $$locbase i49                  ; load word
add $r205 $r203 $r204
move $r199 $r205                        ; move parameter from branch to block argument
ji  .46
.46
move $r208 $r199                        ; move parameter from branch to block argument
addi $r209 $$locbase i1032              ; get offset to local __ptr u64
 sw $$locbase $r208 i129                 ; store word
 sw $$locbase $r199 i129                 ; store word
addi $r210 $$locbase i560               ; get offset to local __ptr u64
addi $r211 $$locbase i912               ; get offset to local __ptr u64
mcpi $r211 $r210 i8                     ; copy memory
addi $r212 $$locbase i640               ; get offset to local __ptr u64
movi $r213 i11                          ; initialize constant into register
sw $$locbase $r213 i80                  ; store word
addi $r214 $$locbase i912               ; get offset to local __ptr u64
lw $r215 $$locbase i114                 ; load word
addi $r216 $$locbase i640               ; get offset to local __ptr u64
lw $r217 $$locbase i80                  ; load word
eq $r218 $r215 $r217
move $$arg0 $r218                       ; [call]: pass argument 0
fncall .4                               ; [call]: call assert_2
 move $r219 $zero                        ; [call]: return unit value
 movi $r219 i0                           ; [call]: return unit value
addi $r220 $$locbase i1032              ; get offset to local __ptr u64
addi $r221 $$locbase i648               ; get offset to local __ptr u64
movi $r222 i42                          ; initialize constant into register
sw $$locbase $r222 i81                  ; store word
lw $r223 $$locbase i129                 ; load word
addi $r224 $$locbase i648               ; get offset to local __ptr u64
lw $r225 $$locbase i81                  ; load word
eq $r226 $r223 $r225
move $$arg0 $r226                       ; [call]: pass argument 0
fncall .4                               ; [call]: call assert_2
 move $r227 $zero                        ; [call]: return unit value
 movi $r227 i0                           ; [call]: return unit value
addi $r228 $$locbase i1040              ; get offset to local __ptr u64
movi $r229 i9999                        ; initialize constant into register
sw $$locbase $r229 i130                 ; store word
addi $r230 $$locbase i656               ; get offset to local __ptr u64
movi $r231 i9999                        ; initialize constant into register
sw $$locbase $r231 i82                  ; store word
addi $r232 $$locbase i1040              ; get offset to local __ptr u64
lw $r233 $$locbase i130                 ; load word
addi $r234 $$locbase i656               ; get offset to local __ptr u64
lw $r235 $$locbase i82                  ; load word
eq $r236 $r233 $r235
move $$arg0 $r236                       ; [call]: pass argument 0
fncall .4                               ; [call]: call assert_2
 move $r237 $zero                        ; [call]: return unit value
 movi $r237 i0                           ; [call]: return unit value
sw $$locbase $one i0                    ; store word
addi $r238 $$locbase i8                 ; get offset to aggregate element
movi $r239 i42                          ; initialize constant into register
sw $$locbase $r239 i1                   ; store word
addi $r240 $$locbase i536               ; get offset to local __ptr { u64, ( u64 | u64 ) }
mcpi $r240 $$locbase i16                ; copy memory
addi $r241 $$locbase i408               ; get offset to local __ptr { u64, ( u64 | u64 ) }
mcpi $r241 $$locbase i16                ; copy memory
addi $r242 $$locbase i672               ; get offset to local __ptr u64
sw $$locbase $zero i84                  ; store word
lw $r243 $$locbase i0                   ; load word
addi $r244 $$locbase i672               ; get offset to local __ptr u64
lw $r245 $$locbase i84                  ; load word
eq $r246 $r243 $r245
 move $r247 $one                         ; move parameter from branch to block argument
 movi $r247 i1                           ; move parameter from branch to block argument
jnzi $r246 .47
ji  .48
.48
addi $r248 $$locbase i408               ; get offset to local __ptr { u64, ( u64 | u64 ) }
addi $r249 $$locbase i680               ; get offset to local __ptr u64
sw $$locbase $one i85                   ; store word
lw $r250 $$locbase i51                  ; load word
addi $r251 $$locbase i680               ; get offset to local __ptr u64
lw $r252 $$locbase i85                  ; load word
eq $r253 $r250 $r252
movi $r254 i2                           ; initialize constant into register
 move $r255 $r254                        ; move parameter from branch to block argument
 movi $r255 i2                           ; move parameter from branch to block argument
jnzi $r253 .49
ji  .50
.50
 move $r255 $zero                        ; move parameter from branch to block argument
 movi $r255 i0                           ; move parameter from branch to block argument
ji  .49
.49
move $r258 $r255                        ; move parameter from branch to block argument
 move $r247 $r258                        ; move parameter from branch to block argument
 move $r247 $r255                        ; move parameter from branch to block argument
ji  .47
.47
move $r261 $r247                        ; move parameter from branch to block argument
addi $r262 $$locbase i336               ; get offset to local __ptr u64
 sw $$locbase $r261 i42                  ; store word
 sw $$locbase $r247 i42                  ; store word
addi $r263 $$locbase i336               ; get offset to local __ptr u64
lw $r264 $$locbase i42                  ; load word
move $$arg0 $r264                       ; [call]: pass argument 0
 move $$arg1 $zero                       ; [call]: pass argument 1
 movi $$arg1 i0                          ; [call]: pass argument 1
fncall .8                               ; [call]: call neq_7
move $r265 $$retv                       ; [call]: copy the return value
 jnzi $r265 .51
 jnzi $$retv .51
ji  .52
.52
load $r266 data_NonConfigurable_0       ; load constant from data section
rvrt $r266
.51
addi $r267 $$locbase i336               ; get offset to local __ptr u64
addi $r268 $$locbase i688               ; get offset to local __ptr u64
sw $$locbase $one i86                   ; store word
lw $r269 $$locbase i42                  ; load word
addi $r270 $$locbase i688               ; get offset to local __ptr u64
lw $r271 $$locbase i86                  ; load word
eq $r272 $r269 $r271
jnzi $r272 .53
ji  .54
.54
addi $r273 $$locbase i336               ; get offset to local __ptr u64
addi $r274 $$locbase i696               ; get offset to local __ptr u64
movi $r275 i2                           ; initialize constant into register
sw $$locbase $r275 i87                  ; store word
lw $r276 $$locbase i42                  ; load word
addi $r277 $$locbase i696               ; get offset to local __ptr u64
lw $r278 $$locbase i87                  ; load word
eq $r279 $r276 $r278
jnzi $r279 .55
ji  .56
.56
load $r280 data_NonConfigurable_1       ; load constant from data section
rvrt $r280
.55
addi $r281 $$locbase i512               ; get offset to local __ptr { u64 }
addi $r282 $$locbase i408               ; get offset to local __ptr { u64, ( u64 | u64 ) }
addi $r283 $r282 i8                     ; get offset to aggregate element
mcpi $r281 $r283 i8                     ; copy memory
addi $r284 $$locbase i488               ; get offset to local __ptr { u64 }
mcpi $r284 $r281 i8                     ; copy memory
addi $r285 $$locbase i496               ; get offset to local __ptr { u64 }
mcpi $r285 $r284 i8                     ; copy memory
move $r286 $r285                        ; move parameter from branch to block argument
ji  .57
.53
addi $r287 $$locbase i504               ; get offset to local __ptr { u64 }
addi $r288 $$locbase i408               ; get offset to local __ptr { u64, ( u64 | u64 ) }
addi $r289 $r288 i8                     ; get offset to aggregate element
mcpi $r287 $r289 i8                     ; copy memory
addi $r290 $$locbase i496               ; get offset to local __ptr { u64 }
mcpi $r290 $r287 i8                     ; copy memory
move $r286 $r290                        ; move parameter from branch to block argument
ji  .57
.57
move $r293 $r286                        ; move parameter from branch to block argument
addi $r294 $$locbase i344               ; get offset to local __ptr { u64 }
 mcpi $r294 $r293 i8                     ; copy memory
 mcpi $r294 $r286 i8                     ; copy memory
addi $r295 $$locbase i344               ; get offset to local __ptr { u64 }
lw $r296 $$locbase i43                  ; load word
addi $r297 $$locbase i1048              ; get offset to local __ptr u64
sw $$locbase $r296 i131                 ; store word
addi $r298 $$locbase i704               ; get offset to local __ptr u64
movi $r299 i42                          ; initialize constant into register
sw $$locbase $r299 i88                  ; store word
addi $r300 $$locbase i1048              ; get offset to local __ptr u64
lw $r301 $$locbase i131                 ; load word
addi $r302 $$locbase i704               ; get offset to local __ptr u64
lw $r303 $$locbase i88                  ; load word
eq $r304 $r301 $r303
move $$arg0 $r304                       ; [call]: pass argument 0
fncall .4                               ; [call]: call assert_2
 move $r305 $zero                        ; [call]: return unit value
 movi $r305 i0                           ; [call]: return unit value
addi $r306 $$locbase i536               ; get offset to local __ptr { u64, ( u64 | u64 ) }
addi $r307 $$locbase i424               ; get offset to local __ptr { u64, ( u64 | u64 ) }
mcpi $r307 $r306 i16                    ; copy memory
addi $r308 $$locbase i536               ; get offset to local __ptr { u64, ( u64 | u64 ) }
addi $r309 $$locbase i712               ; get offset to local __ptr u64
sw $$locbase $zero i89                  ; store word
lw $r310 $$locbase i67                  ; load word
addi $r311 $$locbase i712               ; get offset to local __ptr u64
lw $r312 $$locbase i89                  ; load word
eq $r313 $r310 $r312
move $r314 $r313                        ; move parameter from branch to block argument
jnzi $r313 .58
ji  .59
.59
addi $r315 $$locbase i424               ; get offset to local __ptr { u64, ( u64 | u64 ) }
addi $r316 $$locbase i720               ; get offset to local __ptr u64
sw $$locbase $one i90                   ; store word
lw $r317 $$locbase i53                  ; load word
addi $r318 $$locbase i720               ; get offset to local __ptr u64
lw $r319 $$locbase i90                  ; load word
eq $r320 $r317 $r319
move $r314 $r320                        ; move parameter from branch to block argument
ji  .58
.58
move $r323 $r314                        ; move parameter from branch to block argument
 jnzi $r323 .60
 jnzi $r314 .60
ji  .61
.61
load $r324 data_NonConfigurable_0       ; load constant from data section
rvrt $r324
.60
addi $r325 $$locbase i1056              ; get offset to local __ptr u64
movi $r326 i9999                        ; initialize constant into register
sw $$locbase $r326 i132                 ; store word
addi $r327 $$locbase i728               ; get offset to local __ptr u64
movi $r328 i9999                        ; initialize constant into register
sw $$locbase $r328 i91                  ; store word
addi $r329 $$locbase i1056              ; get offset to local __ptr u64
lw $r330 $$locbase i132                 ; load word
addi $r331 $$locbase i728               ; get offset to local __ptr u64
lw $r332 $$locbase i91                  ; load word
eq $r333 $r330 $r332
move $$arg0 $r333                       ; [call]: pass argument 0
fncall .4                               ; [call]: call assert_2
 move $r334 $zero                        ; [call]: return unit value
 movi $r334 i0                           ; [call]: return unit value
addi $r335 $$locbase i552               ; get offset to local __ptr u64
movi $r336 i42                          ; initialize constant into register
sw $$locbase $r336 i69                  ; store word
addi $r337 $$locbase i736               ; get offset to local __ptr u64
movi $r338 i42                          ; initialize constant into register
sw $$locbase $r338 i92                  ; store word
addi $r339 $$locbase i552               ; get offset to local __ptr u64
lw $r340 $$locbase i69                  ; load word
addi $r341 $$locbase i736               ; get offset to local __ptr u64
lw $r342 $$locbase i92                  ; load word
eq $r343 $r340 $r342
move $$arg0 $r343                       ; [call]: pass argument 0
fncall .4                               ; [call]: call assert_2
 move $r344 $zero                        ; [call]: return unit value
 movi $r344 i0                           ; [call]: return unit value
addi $r345 $$locbase i568               ; get offset to local __ptr u64
sw $$locbase $zero i71                  ; store word
addi $r346 $$locbase i568               ; get offset to local __ptr u64
addi $r347 $$locbase i464               ; get offset to local __ptr { u64, u64, u64 }
move $$arg0 $r346                       ; [call]: pass argument 0
move $$arg1 $r347                       ; [call]: pass argument 1
fncall .6                               ; [call]: call inc_i_5
 move $r348 $zero                        ; [call]: return unit value
 movi $r348 i0                           ; [call]: return unit value
addi $r349 $$locbase i568               ; get offset to local __ptr u64
addi $r350 $$locbase i920               ; get offset to local __ptr u64
mcpi $r350 $r349 i8                     ; copy memory
addi $r351 $$locbase i744               ; get offset to local __ptr u64
movi $r352 i11                          ; initialize constant into register
sw $$locbase $r352 i93                  ; store word
addi $r353 $$locbase i920               ; get offset to local __ptr u64
lw $r354 $$locbase i115                 ; load word
addi $r355 $$locbase i744               ; get offset to local __ptr u64
lw $r356 $$locbase i93                  ; load word
eq $r357 $r354 $r356
move $$arg0 $r357                       ; [call]: pass argument 0
fncall .4                               ; [call]: call assert_2
 move $r358 $zero                        ; [call]: return unit value
 movi $r358 i0                           ; [call]: return unit value
addi $r359 $$locbase i352               ; get offset to local __ptr u64
movi $r360 i42                          ; initialize constant into register
sw $$locbase $r360 i44                  ; store word
addi $r361 $$locbase i760               ; get offset to local __ptr u64
sw $$locbase $zero i95                  ; store word
addi $r362 $$locbase i352               ; get offset to local __ptr u64
lw $r363 $$locbase i44                  ; load word
addi $r364 $$locbase i760               ; get offset to local __ptr u64
lw $r365 $$locbase i95                  ; load word
eq $r366 $r363 $r365
movi $r367 i24                          ; initialize constant into register
 move $r368 $r367                        ; move parameter from branch to block argument
 movi $r368 i24                          ; move parameter from branch to block argument
jnzi $r366 .62
ji  .63
.63
addi $r369 $$locbase i352               ; get offset to local __ptr u64
lw $r370 $$locbase i44                  ; load word
move $r368 $r370                        ; move parameter from branch to block argument
ji  .62
.62
move $r373 $r368                        ; move parameter from branch to block argument
addi $r374 $$locbase i904               ; get offset to local __ptr u64
 sw $$locbase $r373 i113                 ; store word
 sw $$locbase $r368 i113                 ; store word
addi $r375 $$locbase i768               ; get offset to local __ptr u64
movi $r376 i42                          ; initialize constant into register
sw $$locbase $r376 i96                  ; store word
addi $r377 $$locbase i904               ; get offset to local __ptr u64
lw $r378 $$locbase i113                 ; load word
addi $r379 $$locbase i768               ; get offset to local __ptr u64
lw $r380 $$locbase i96                  ; load word
eq $r381 $r378 $r380
move $$arg0 $r381                       ; [call]: pass argument 0
fncall .4                               ; [call]: call assert_2
 move $r382 $zero                        ; [call]: return unit value
 movi $r382 i0                           ; [call]: return unit value
addr $r383 data_NonConfigurable_2       ; get __const_global2's address in data section
addi $r384 $$locbase i176               ; get offset to local __ptr { ptr, u64 }
sw $$locbase $r383 i22                  ; store word
addi $r385 $r384 i8                     ; get offset to aggregate element
sw $$locbase $zero i23                  ; store word
addi $r386 $$locbase i224               ; get offset to local __ptr slice
mcpi $r386 $r384 i16                    ; copy memory
addi $r387 $$locbase i224               ; get offset to local __ptr slice
move $$arg0 $r387                       ; [call]: pass argument 0
fncall .10                              ; [call]: call return_match_on_str_slice_8
move $r388 $$retv                       ; [call]: copy the return value
addi $r389 $$locbase i928               ; get offset to local __ptr u64
 sw $$locbase $r388 i116                 ; store word
 sw $$locbase $$retv i116                ; store word
addi $r390 $$locbase i776               ; get offset to local __ptr u64
movi $r391 i1000                        ; initialize constant into register
sw $$locbase $r391 i97                  ; store word
addi $r392 $$locbase i928               ; get offset to local __ptr u64
lw $r393 $$locbase i116                 ; load word
addi $r394 $$locbase i776               ; get offset to local __ptr u64
lw $r395 $$locbase i97                  ; load word
eq $r396 $r393 $r395
move $$arg0 $r396                       ; [call]: pass argument 0
fncall .4                               ; [call]: call assert_2
 move $r397 $zero                        ; [call]: return unit value
 movi $r397 i0                           ; [call]: return unit value
addr $r398 data_NonConfigurable_3       ; get __const_global3's address in data section
addi $r399 $$locbase i240               ; get offset to local __ptr { ptr, u64 }
sw $$locbase $r398 i30                  ; store word
addi $r400 $r399 i8                     ; get offset to aggregate element
sw $$locbase $one i31                   ; store word
addi $r401 $$locbase i256               ; get offset to local __ptr slice
mcpi $r401 $r399 i16                    ; copy memory
addi $r402 $$locbase i256               ; get offset to local __ptr slice
move $$arg0 $r402                       ; [call]: pass argument 0
fncall .10                              ; [call]: call return_match_on_str_slice_8
move $r403 $$retv                       ; [call]: copy the return value
addi $r404 $$locbase i936               ; get offset to local __ptr u64
 sw $$locbase $r403 i117                 ; store word
 sw $$locbase $$retv i117                ; store word
addi $r405 $$locbase i784               ; get offset to local __ptr u64
movi $r406 i1000                        ; initialize constant into register
sw $$locbase $r406 i98                  ; store word
addi $r407 $$locbase i936               ; get offset to local __ptr u64
lw $r408 $$locbase i117                 ; load word
addi $r409 $$locbase i784               ; get offset to local __ptr u64
lw $r410 $$locbase i98                  ; load word
eq $r411 $r408 $r410
move $$arg0 $r411                       ; [call]: pass argument 0
fncall .4                               ; [call]: call assert_2
 move $r412 $zero                        ; [call]: return unit value
 movi $r412 i0                           ; [call]: return unit value
addr $r413 data_NonConfigurable_4       ; get __const_global4's address in data section
addi $r414 $$locbase i272               ; get offset to local __ptr { ptr, u64 }
sw $$locbase $r413 i34                  ; store word
addi $r415 $r414 i8                     ; get offset to aggregate element
movi $r416 i2                           ; initialize constant into register
sw $$locbase $r416 i35                  ; store word
addi $r417 $$locbase i288               ; get offset to local __ptr slice
mcpi $r417 $r414 i16                    ; copy memory
addi $r418 $$locbase i288               ; get offset to local __ptr slice
move $$arg0 $r418                       ; [call]: pass argument 0
fncall .10                              ; [call]: call return_match_on_str_slice_8
move $r419 $$retv                       ; [call]: copy the return value
addi $r420 $$locbase i944               ; get offset to local __ptr u64
 sw $$locbase $r419 i118                 ; store word
 sw $$locbase $$retv i118                ; store word
addi $r421 $$locbase i792               ; get offset to local __ptr u64
movi $r422 i1000                        ; initialize constant into register
sw $$locbase $r422 i99                  ; store word
addi $r423 $$locbase i944               ; get offset to local __ptr u64
lw $r424 $$locbase i118                 ; load word
addi $r425 $$locbase i792               ; get offset to local __ptr u64
lw $r426 $$locbase i99                  ; load word
eq $r427 $r424 $r426
move $$arg0 $r427                       ; [call]: pass argument 0
fncall .4                               ; [call]: call assert_2
 move $r428 $zero                        ; [call]: return unit value
 movi $r428 i0                           ; [call]: return unit value
addr $r429 data_NonConfigurable_5       ; get __const_global5's address in data section
addi $r430 $$locbase i304               ; get offset to local __ptr { ptr, u64 }
sw $$locbase $r429 i38                  ; store word
addi $r431 $r430 i8                     ; get offset to aggregate element
movi $r432 i3                           ; initialize constant into register
sw $$locbase $r432 i39                  ; store word
addi $r433 $$locbase i320               ; get offset to local __ptr slice
mcpi $r433 $r430 i16                    ; copy memory
addi $r434 $$locbase i320               ; get offset to local __ptr slice
move $$arg0 $r434                       ; [call]: pass argument 0
fncall .10                              ; [call]: call return_match_on_str_slice_8
move $r435 $$retv                       ; [call]: copy the return value
addi $r436 $$locbase i952               ; get offset to local __ptr u64
 sw $$locbase $r435 i119                 ; store word
 sw $$locbase $$retv i119                ; store word
addi $r437 $$locbase i800               ; get offset to local __ptr u64
movi $r438 i1000                        ; initialize constant into register
sw $$locbase $r438 i100                 ; store word
addi $r439 $$locbase i952               ; get offset to local __ptr u64
lw $r440 $$locbase i119                 ; load word
addi $r441 $$locbase i800               ; get offset to local __ptr u64
lw $r442 $$locbase i100                 ; load word
eq $r443 $r440 $r442
move $$arg0 $r443                       ; [call]: pass argument 0
fncall .4                               ; [call]: call assert_2
 move $r444 $zero                        ; [call]: return unit value
 movi $r444 i0                           ; [call]: return unit value
addr $r445 data_NonConfigurable_6       ; get __const_global6's address in data section
addi $r446 $$locbase i16                ; get offset to local __ptr { ptr, u64 }
sw $$locbase $r445 i2                   ; store word
addi $r447 $r446 i8                     ; get offset to aggregate element
movi $r448 i4                           ; initialize constant into register
sw $$locbase $r448 i3                   ; store word
addi $r449 $$locbase i32                ; get offset to local __ptr slice
mcpi $r449 $r446 i16                    ; copy memory
addi $r450 $$locbase i32                ; get offset to local __ptr slice
move $$arg0 $r450                       ; [call]: pass argument 0
fncall .10                              ; [call]: call return_match_on_str_slice_8
move $r451 $$retv                       ; [call]: copy the return value
addi $r452 $$locbase i960               ; get offset to local __ptr u64
 sw $$locbase $r451 i120                 ; store word
 sw $$locbase $$retv i120                ; store word
addi $r453 $$locbase i808               ; get offset to local __ptr u64
movi $r454 i1000                        ; initialize constant into register
sw $$locbase $r454 i101                 ; store word
addi $r455 $$locbase i960               ; get offset to local __ptr u64
lw $r456 $$locbase i120                 ; load word
addi $r457 $$locbase i808               ; get offset to local __ptr u64
lw $r458 $$locbase i101                 ; load word
eq $r459 $r456 $r458
move $$arg0 $r459                       ; [call]: pass argument 0
fncall .4                               ; [call]: call assert_2
 move $r460 $zero                        ; [call]: return unit value
 movi $r460 i0                           ; [call]: return unit value
addr $r461 data_NonConfigurable_7       ; get __const_global7's address in data section
addi $r462 $$locbase i48                ; get offset to local __ptr { ptr, u64 }
sw $$locbase $r461 i6                   ; store word
addi $r463 $r462 i8                     ; get offset to aggregate element
movi $r464 i5                           ; initialize constant into register
sw $$locbase $r464 i7                   ; store word
addi $r465 $$locbase i64                ; get offset to local __ptr slice
mcpi $r465 $r462 i16                    ; copy memory
addi $r466 $$locbase i64                ; get offset to local __ptr slice
move $$arg0 $r466                       ; [call]: pass argument 0
fncall .10                              ; [call]: call return_match_on_str_slice_8
move $r467 $$retv                       ; [call]: copy the return value
addi $r468 $$locbase i968               ; get offset to local __ptr u64
 sw $$locbase $r467 i121                 ; store word
 sw $$locbase $$retv i121                ; store word
addi $r469 $$locbase i816               ; get offset to local __ptr u64
sw $$locbase $one i102                  ; store word
addi $r470 $$locbase i968               ; get offset to local __ptr u64
lw $r471 $$locbase i121                 ; load word
addi $r472 $$locbase i816               ; get offset to local __ptr u64
lw $r473 $$locbase i102                 ; load word
eq $r474 $r471 $r473
move $$arg0 $r474                       ; [call]: pass argument 0
fncall .4                               ; [call]: call assert_2
 move $r475 $zero                        ; [call]: return unit value
 movi $r475 i0                           ; [call]: return unit value
addr $r476 data_NonConfigurable_8       ; get __const_global8's address in data section
addi $r477 $$locbase i80                ; get offset to local __ptr { ptr, u64 }
sw $$locbase $r476 i10                  ; store word
addi $r478 $r477 i8                     ; get offset to aggregate element
movi $r479 i6                           ; initialize constant into register
sw $$locbase $r479 i11                  ; store word
addi $r480 $$locbase i96                ; get offset to local __ptr slice
mcpi $r480 $r477 i16                    ; copy memory
addi $r481 $$locbase i96                ; get offset to local __ptr slice
move $$arg0 $r481                       ; [call]: pass argument 0
fncall .10                              ; [call]: call return_match_on_str_slice_8
move $r482 $$retv                       ; [call]: copy the return value
addi $r483 $$locbase i976               ; get offset to local __ptr u64
 sw $$locbase $r482 i122                 ; store word
 sw $$locbase $$retv i122                ; store word
addi $r484 $$locbase i824               ; get offset to local __ptr u64
movi $r485 i1000                        ; initialize constant into register
sw $$locbase $r485 i103                 ; store word
addi $r486 $$locbase i976               ; get offset to local __ptr u64
lw $r487 $$locbase i122                 ; load word
addi $r488 $$locbase i824               ; get offset to local __ptr u64
lw $r489 $$locbase i103                 ; load word
eq $r490 $r487 $r489
move $$arg0 $r490                       ; [call]: pass argument 0
fncall .4                               ; [call]: call assert_2
 move $r491 $zero                        ; [call]: return unit value
 movi $r491 i0                           ; [call]: return unit value
addr $r492 data_NonConfigurable_9       ; get __const_global9's address in data section
addi $r493 $$locbase i112               ; get offset to local __ptr { ptr, u64 }
sw $$locbase $r492 i14                  ; store word
addi $r494 $r493 i8                     ; get offset to aggregate element
movi $r495 i7                           ; initialize constant into register
sw $$locbase $r495 i15                  ; store word
addi $r496 $$locbase i128               ; get offset to local __ptr slice
mcpi $r496 $r493 i16                    ; copy memory
addi $r497 $$locbase i128               ; get offset to local __ptr slice
move $$arg0 $r497                       ; [call]: pass argument 0
fncall .10                              ; [call]: call return_match_on_str_slice_8
move $r498 $$retv                       ; [call]: copy the return value
addi $r499 $$locbase i984               ; get offset to local __ptr u64
 sw $$locbase $r498 i123                 ; store word
 sw $$locbase $$retv i123                ; store word
addi $r500 $$locbase i832               ; get offset to local __ptr u64
movi $r501 i2                           ; initialize constant into register
sw $$locbase $r501 i104                 ; store word
addi $r502 $$locbase i984               ; get offset to local __ptr u64
lw $r503 $$locbase i123                 ; load word
addi $r504 $$locbase i832               ; get offset to local __ptr u64
lw $r505 $$locbase i104                 ; load word
eq $r506 $r503 $r505
move $$arg0 $r506                       ; [call]: pass argument 0
fncall .4                               ; [call]: call assert_2
 move $r507 $zero                        ; [call]: return unit value
 movi $r507 i0                           ; [call]: return unit value
addr $r508 data_NonConfigurable_10      ; get __const_global10's address in data section
addi $r509 $$locbase i144               ; get offset to local __ptr { ptr, u64 }
sw $$locbase $r508 i18                  ; store word
addi $r510 $r509 i8                     ; get offset to aggregate element
movi $r511 i5                           ; initialize constant into register
sw $$locbase $r511 i19                  ; store word
addi $r512 $$locbase i160               ; get offset to local __ptr slice
mcpi $r512 $r509 i16                    ; copy memory
addi $r513 $$locbase i160               ; get offset to local __ptr slice
move $$arg0 $r513                       ; [call]: pass argument 0
fncall .10                              ; [call]: call return_match_on_str_slice_8
move $r514 $$retv                       ; [call]: copy the return value
addi $r515 $$locbase i992               ; get offset to local __ptr u64
 sw $$locbase $r514 i124                 ; store word
 sw $$locbase $$retv i124                ; store word
addi $r516 $$locbase i848               ; get offset to local __ptr u64
movi $r517 i3                           ; initialize constant into register
sw $$locbase $r517 i106                 ; store word
addi $r518 $$locbase i992               ; get offset to local __ptr u64
lw $r519 $$locbase i124                 ; load word
addi $r520 $$locbase i848               ; get offset to local __ptr u64
lw $r521 $$locbase i106                 ; load word
eq $r522 $r519 $r521
move $$arg0 $r522                       ; [call]: pass argument 0
fncall .4                               ; [call]: call assert_2
 move $r523 $zero                        ; [call]: return unit value
 movi $r523 i0                           ; [call]: return unit value
addr $r524 data_NonConfigurable_11      ; get __const_global11's address in data section
addi $r525 $$locbase i192               ; get offset to local __ptr { ptr, u64 }
sw $$locbase $r524 i24                  ; store word
addi $r526 $r525 i8                     ; get offset to aggregate element
movi $r527 i5                           ; initialize constant into register
sw $$locbase $r527 i25                  ; store word
addi $r528 $$locbase i208               ; get offset to local __ptr slice
mcpi $r528 $r525 i16                    ; copy memory
addi $r529 $$locbase i208               ; get offset to local __ptr slice
move $$arg0 $r529                       ; [call]: pass argument 0
fncall .10                              ; [call]: call return_match_on_str_slice_8
move $r530 $$retv                       ; [call]: copy the return value
addi $r531 $$locbase i1000              ; get offset to local __ptr u64
 sw $$locbase $r530 i125                 ; store word
 sw $$locbase $$retv i125                ; store word
addi $r532 $$locbase i856               ; get offset to local __ptr u64
movi $r533 i1000                        ; initialize constant into register
sw $$locbase $r533 i107                 ; store word
addi $r534 $$locbase i1000              ; get offset to local __ptr u64
lw $r535 $$locbase i125                 ; load word
addi $r536 $$locbase i856               ; get offset to local __ptr u64
lw $r537 $$locbase i107                 ; load word
eq $r538 $r535 $r537
move $$arg0 $r538                       ; [call]: pass argument 0
fncall .4                               ; [call]: call assert_2
 move $r539 $zero                        ; [call]: return unit value
 movi $r539 i0                           ; [call]: return unit value
ji  .3
.3
cfsi i1064                              ; free 1064 bytes for locals and 0 slots for extra call arguments
move $$reta $r2                         ; restore return address
popa .2                                 ; restore all registers
jal $zero $$reta i0                     ; return from call
DIFF------------------------------
.program:
.4                                      ; --- start of function: assert_2 ---
pusha .4                                ; save all registers
move $$locbase $sp                      ; save locals base register for function assert_2
cfei i16                                ; allocate 16 bytes for locals and 0 slots for call arguments
.64
addi $r541 $$locbase i8                 ; get offset to local __ptr bool
sb $r541 $$arg0 i0                      ; store byte
addi $r542 $$locbase i8                 ; get offset to local __ptr bool
lb $r543 $r542 i0                       ; load byte
eq $r544 $r543 $zero
jnzi $r544 .65
ji  .66
.66
ji  .5
.65
addr $r545 data_NonConfigurable_12      ; get std::error_signals::FAILED_ASSERT_SIGNAL's address in data section
mcpi $$locbase $r545 i8                 ; copy memory
lw $r546 $$locbase i0                   ; load word
rvrt $r546
.5
cfsi i16                                ; free 16 bytes for locals and 0 slots for extra call arguments
popa .4                                 ; restore all registers
jal $zero $$reta i0                     ; return from call
DIFF------------------------------
.program:
.6                                      ; --- start of function: inc_i_5 ---
pusha .6                                ; save all registers
move $$locbase $sp                      ; save locals base register for function inc_i_5
cfei i48                                ; allocate 48 bytes for locals and 0 slots for call arguments
.67
addi $r548 $$locbase i24                ; get offset to local __ptr __ptr u64
sw $$locbase $$arg0 i3                  ; store word
addi $r549 $$locbase i24                ; get offset to local __ptr __ptr u64
lw $r550 $$locbase i3                   ; load word
addi $r551 $$locbase i40                ; get offset to local __ptr u64
mcpi $r551 $r550 i8                     ; copy memory
addi $r552 $$locbase i32                ; get offset to local __ptr u64
movi $r553 i11                          ; initialize constant into register
sw $$locbase $r553 i4                   ; store word
addi $r554 $$locbase i40                ; get offset to local __ptr u64
lw $r555 $$locbase i5                   ; load word
addi $r556 $$locbase i32                ; get offset to local __ptr u64
lw $r557 $$locbase i4                   ; load word
add $r558 $r555 $r557
addi $r559 $$locbase i24                ; get offset to local __ptr __ptr u64
lw $r560 $$locbase i3                   ; load word
sw $r560 $r558 i0                       ; store word
movi $r561 i21                          ; initialize constant into register
sw $$locbase $r561 i0                   ; store word
addi $r562 $$locbase i8                 ; get offset to aggregate element
movi $r563 i21                          ; initialize constant into register
sw $$locbase $r563 i1                   ; store word
addi $r564 $$locbase i16                ; get offset to aggregate element
sw $$locbase $one i2                    ; store word
mcpi $$arg1 $$locbase i24               ; copy memory
ji  .7
.7
cfsi i48                                ; free 48 bytes for locals and 0 slots for extra call arguments
popa .6                                 ; restore all registers
jal $zero $$reta i0                     ; return from call
DIFF------------------------------
.program:
.8                                      ; --- start of function: neq_7 ---
pusha .8                                ; save all registers
move $$locbase $sp                      ; save locals base register for function neq_7
cfei i24                                ; allocate 24 bytes for locals and 0 slots for call arguments
.68
addi $r566 $$locbase i8                 ; get offset to local __ptr u64
sw $$locbase $$arg0 i1                  ; store word
sw $$locbase $$arg1 i0                  ; store word
addi $r567 $$locbase i8                 ; get offset to local __ptr u64
lw $r568 $$locbase i1                   ; load word
lw $r569 $$locbase i0                   ; load word
eq $r570 $r568 $r569
addi $r571 $$locbase i16                ; get offset to local __ptr bool
sb $r571 $r570 i0                       ; store byte
addi $r572 $$locbase i16                ; get offset to local __ptr bool
lb $r573 $r572 i0                       ; load byte
eq $r574 $r573 $zero
move $$retv $r574                       ; set return value
ji  .9
.9
cfsi i24                                ; free 24 bytes for locals and 0 slots for extra call arguments
popa .8                                 ; restore all registers
jal $zero $$reta i0                     ; return from call
DIFF------------------------------
.program:
.10                                     ; --- start of function: return_match_on_str_slice_8 ---
pusha .10                               ; save all registers
move $$locbase $sp                      ; save locals base register for function return_match_on_str_slice_8
cfei i112                               ; allocate 112 bytes for locals and 0 slots for call arguments
move $r575 $$arg0                       ; save argument 0 (param)
move $r576 $$reta                       ; save return address
.69
addi $r577 $$locbase i96                ; get offset to local __ptr slice
 mcpi $r577 $r575 i16                    ; copy memory
 mcpi $r577 $$arg0 i16                   ; copy memory
addr $r578 data_NonConfigurable_7       ; get __const_global's address in data section
sw $$locbase $r578 i0                   ; store word
addi $r579 $$locbase i8                 ; get offset to aggregate element
movi $r580 i5                           ; initialize constant into register
sw $$locbase $r580 i1                   ; store word
addi $r581 $$locbase i16                ; get offset to local __ptr slice
mcpi $r581 $$locbase i16                ; copy memory
addi $r582 $$locbase i16                ; get offset to local __ptr slice
move $$arg0 $r575                       ; [call]: pass argument 0
move $$arg1 $r582                       ; [call]: pass argument 1
fncall .12                              ; [call]: call eq_9
move $r583 $$retv                       ; [call]: copy the return value
 move $r584 $one                         ; move parameter from branch to block argument
 jnzi $r583 .70
 movi $r584 i1                           ; move parameter from branch to block argument
 jnzi $$retv .70
ji  .71
.71
addi $r585 $$locbase i96                ; get offset to local __ptr slice
addr $r586 data_NonConfigurable_9       ; get __const_global0's address in data section
addi $r587 $$locbase i32                ; get offset to local __ptr { ptr, u64 }
sw $$locbase $r586 i4                   ; store word
addi $r588 $r587 i8                     ; get offset to aggregate element
movi $r589 i7                           ; initialize constant into register
sw $$locbase $r589 i5                   ; store word
addi $r590 $$locbase i48                ; get offset to local __ptr slice
mcpi $r590 $r587 i16                    ; copy memory
addi $r591 $$locbase i48                ; get offset to local __ptr slice
move $$arg0 $r585                       ; [call]: pass argument 0
move $$arg1 $r591                       ; [call]: pass argument 1
fncall .12                              ; [call]: call eq_9
move $r592 $$retv                       ; [call]: copy the return value
movi $r593 i2                           ; initialize constant into register
 move $r594 $r593                        ; move parameter from branch to block argument
 jnzi $r592 .72
 movi $r594 i2                           ; move parameter from branch to block argument
 jnzi $$retv .72
ji  .73
.73
addi $r595 $$locbase i96                ; get offset to local __ptr slice
addr $r596 data_NonConfigurable_10      ; get __const_global1's address in data section
addi $r597 $$locbase i64                ; get offset to local __ptr { ptr, u64 }
sw $$locbase $r596 i8                   ; store word
addi $r598 $r597 i8                     ; get offset to aggregate element
movi $r599 i5                           ; initialize constant into register
sw $$locbase $r599 i9                   ; store word
addi $r600 $$locbase i80                ; get offset to local __ptr slice
mcpi $r600 $r597 i16                    ; copy memory
addi $r601 $$locbase i80                ; get offset to local __ptr slice
move $$arg0 $r595                       ; [call]: pass argument 0
move $$arg1 $r601                       ; [call]: pass argument 1
fncall .12                              ; [call]: call eq_9
move $r602 $$retv                       ; [call]: copy the return value
movi $r603 i3                           ; initialize constant into register
 move $r604 $r603                        ; move parameter from branch to block argument
 jnzi $r602 .74
 movi $r604 i3                           ; move parameter from branch to block argument
 jnzi $$retv .74
ji  .75
.75
movi $r605 i1000                        ; initialize constant into register
 move $r604 $r605                        ; move parameter from branch to block argument
 movi $r604 i1000                        ; move parameter from branch to block argument
ji  .74
.74
move $r608 $r604                        ; move parameter from branch to block argument
 move $r594 $r608                        ; move parameter from branch to block argument
 move $r594 $r604                        ; move parameter from branch to block argument
ji  .72
.72
move $r611 $r594                        ; move parameter from branch to block argument
 move $r584 $r611                        ; move parameter from branch to block argument
 move $r584 $r594                        ; move parameter from branch to block argument
ji  .70
.70
move $r614 $r584                        ; move parameter from branch to block argument
 move $$retv $r614                       ; set return value
 move $$retv $r584                       ; set return value
ji  .11
.11
cfsi i112                               ; free 112 bytes for locals and 0 slots for extra call arguments
move $$reta $r576                       ; restore return address
popa .10                                ; restore all registers
jal $zero $$reta i0                     ; return from call
DIFF------------------------------
.program:
.12                                     ; --- start of function: eq_9 ---
pusha .12                               ; save all registers
move $$locbase $sp                      ; save locals base register for function eq_9
cfei i136                               ; allocate 136 bytes for locals and 0 slots for call arguments
move $r615 $$arg0                       ; save argument 0 (self)
move $r616 $$arg1                       ; save argument 1 (other)
move $r617 $$reta                       ; save return address
.76
addi $r618 $$locbase i112               ; get offset to local __ptr slice
 mcpi $r618 $r615 i16                    ; copy memory
 mcpi $r618 $$arg0 i16                   ; copy memory
addi $r619 $$locbase i88                ; get offset to local __ptr slice
mcpi $r619 $r616 i16                    ; copy memory
addi $r620 $$locbase i112               ; get offset to local __ptr slice
mcpi $$locbase $r620 i16                ; copy memory
move $$arg0 $$locbase                   ; [call]: pass argument 0
fncall .14                              ; [call]: call len_10
move $r621 $$retv                       ; [call]: copy the return value
addi $r622 $$locbase i88                ; get offset to local __ptr slice
addi $r623 $$locbase i16                ; get offset to local __ptr slice
mcpi $r623 $r622 i16                    ; copy memory
move $$arg0 $r623                       ; [call]: pass argument 0
fncall .14                              ; [call]: call len_10
move $r624 $$retv                       ; [call]: copy the return value
move $$arg0 $r621                       ; [call]: pass argument 0
 move $$arg1 $r624                       ; [call]: pass argument 1
 move $$arg1 $$retv                      ; [call]: pass argument 1
fncall .8                               ; [call]: call neq_7
move $r625 $$retv                       ; [call]: copy the return value
 move $r626 $zero                        ; move parameter from branch to block argument
 jnzi $r625 .77
 movi $r626 i0                           ; move parameter from branch to block argument
 jnzi $$retv .77
ji  .78
.78
addi $r627 $$locbase i112               ; get offset to local __ptr slice
addi $r628 $$locbase i48                ; get offset to local __ptr slice
mcpi $r628 $r627 i16                    ; copy memory
move $$arg0 $r628                       ; [call]: pass argument 0
fncall .16                              ; [call]: call as_ptr_11
move $r629 $$retv                       ; [call]: copy the return value
addi $r630 $$locbase i128               ; get offset to local __ptr ptr
 sw $$locbase $r629 i16                  ; store word
 sw $$locbase $$retv i16                 ; store word
addi $r631 $$locbase i88                ; get offset to local __ptr slice
addi $r632 $$locbase i64                ; get offset to local __ptr slice
mcpi $r632 $r631 i16                    ; copy memory
move $$arg0 $r632                       ; [call]: pass argument 0
fncall .16                              ; [call]: call as_ptr_11
move $r633 $$retv                       ; [call]: copy the return value
addi $r634 $$locbase i104               ; get offset to local __ptr ptr
 sw $$locbase $r633 i13                  ; store word
 sw $$locbase $$retv i13                 ; store word
addi $r635 $$locbase i112               ; get offset to local __ptr slice
addi $r636 $$locbase i32                ; get offset to local __ptr slice
mcpi $r636 $r635 i16                    ; copy memory
move $$arg0 $r636                       ; [call]: pass argument 0
fncall .14                              ; [call]: call len_10
move $r637 $$retv                       ; [call]: copy the return value
addi $r638 $$locbase i80                ; get offset to local __ptr u64
 sw $$locbase $r637 i10                  ; store word
 sw $$locbase $$retv i10                 ; store word
addi $r639 $$locbase i128               ; get offset to local __ptr ptr
lw $r640 $$locbase i16                  ; load word
addi $r641 $$locbase i104               ; get offset to local __ptr ptr
lw $r642 $$locbase i13                  ; load word
addi $r643 $$locbase i80                ; get offset to local __ptr u64
lw $r644 $$locbase i10                  ; load word
meq $r645 $r640 $r642 $r644             ; meq r4 r1 r2 r3
move $r646 $r645                        ; return value from ASM block with return register r4
 move $r626 $r646                        ; move parameter from branch to block argument
 move $r626 $r645                        ; move parameter from branch to block argument
ji  .77
.77
move $r649 $r626                        ; move parameter from branch to block argument
 move $$retv $r649                       ; set return value
 move $$retv $r626                       ; set return value
ji  .13
.13
cfsi i136                               ; free 136 bytes for locals and 0 slots for extra call arguments
move $$reta $r617                       ; restore return address
popa .12                                ; restore all registers
jal $zero $$reta i0                     ; return from call
DIFF------------------------------
.program:
.14                                     ; --- start of function: len_10 ---
pusha .14                               ; save all registers
move $$locbase $sp                      ; save locals base register for function len_10
cfei i56                                ; allocate 56 bytes for locals and 0 slots for call arguments
.79
addi $r651 $$locbase i40                ; get offset to local __ptr slice
mcpi $r651 $$arg0 i16                   ; copy memory
addi $r652 $$locbase i40                ; get offset to local __ptr slice
move $r653 $r652                        ; return value from ASM block with return register s
 mcpi $$locbase $r653 i16                ; copy memory
 mcpi $$locbase $r652 i16                ; copy memory
addi $r654 $$locbase i16                ; get offset to local __ptr { ptr, u64 }
mcpi $r654 $$locbase i16                ; copy memory
addi $r655 $$locbase i32                ; get offset to local __ptr u64
addi $r656 $$locbase i8                 ; get offset to aggregate element
mcpi $r655 $r656 i8                     ; copy memory
lw $r657 $$locbase i1                   ; load word
move $$retv $r657                       ; set return value
ji  .15
.15
cfsi i56                                ; free 56 bytes for locals and 0 slots for extra call arguments
popa .14                                ; restore all registers
jal $zero $$reta i0                     ; return from call
DIFF------------------------------
.program:
.16                                     ; --- start of function: as_ptr_11 ---
pusha .16                               ; save all registers
move $$locbase $sp                      ; save locals base register for function as_ptr_11
cfei i72                                ; allocate 72 bytes for locals and 0 slots for call arguments
.80
addi $r659 $$locbase i56                ; get offset to local __ptr slice
mcpi $r659 $$arg0 i16                   ; copy memory
addi $r660 $$locbase i56                ; get offset to local __ptr slice
move $r661 $r660                        ; return value from ASM block with return register s
 mcpi $$locbase $r661 i16                ; copy memory
 mcpi $$locbase $r660 i16                ; copy memory
addi $r662 $$locbase i16                ; get offset to local __ptr { ptr, u64 }
mcpi $r662 $$locbase i16                ; copy memory
addi $r663 $$locbase i32                ; get offset to local __ptr { ptr, u64 }
mcpi $r663 $$locbase i16                ; copy memory
addi $r664 $$locbase i32                ; get offset to local __ptr { ptr, u64 }
addi $r665 $$locbase i48                ; get offset to local __ptr ptr
mcpi $r665 $r664 i8                     ; copy memory
addi $r666 $$locbase i48                ; get offset to local __ptr ptr
lw $r667 $$locbase i6                   ; load word
move $$retv $r667                       ; set return value
ji  .17
.17
cfsi i72                                ; free 72 bytes for locals and 0 slots for extra call arguments
popa .16                                ; restore all registers
jal $zero $$reta i0                     ; return from call
    Finished debug [unoptimized + fuel] target(s) [2.992 KB] in ???

> forc build --path test/src/e2e_vm_tests/test_programs/should_pass/language/match_expressions_all --ir final --asm final --release | filter-fn match_expressions_all return_match_on_str_slice

fn return_match_on_str_slice_8(param: __ptr slice) -> u64 {
    local { ptr, u64 } __anon_0
    local slice __anon_1
    local { ptr, u64 } __anon_2
    local slice __anon_3
    local { ptr, u64 } __anon_4
    local slice __anon_5
    local slice __matched_value_1

    entry(param: __ptr slice):
    v329v1 = get_local __ptr slice, __matched_value_1
    mem_copy_val v329v1, param
    v331v1 = get_global __ptr string<5>, __const_global
    v332v1 = cast_ptr v331v1 to ptr
    v333v1 = get_local __ptr { ptr, u64 }, __anon_0
    v334v1 = const u64 0
    v335v1 = get_elem_ptr v333v1, __ptr ptr, v334v1
    store v332v1 to v335v1
    v337v1 = const u64 1
    v338v1 = get_elem_ptr v333v1, __ptr u64, v337v1
    v339v1 = const u64 5
    store v339v1 to v338v1
    v341v1 = get_local __ptr slice, __anon_1
    mem_copy_bytes v341v1, v333v1, 16
    v343v1 = get_local __ptr slice, __anon_1
    v344v1 = call eq_9(param, v343v1)
    v345v1 = const u64 1
    cbr v344v1, block8(v345v1), block1()

    block1():
    v347v1 = get_local __ptr slice, __matched_value_1
    v348v1 = get_global __ptr string<7>, __const_global0
    v349v1 = cast_ptr v348v1 to ptr
    v350v1 = get_local __ptr { ptr, u64 }, __anon_2
    v351v1 = const u64 0
    v352v1 = get_elem_ptr v350v1, __ptr ptr, v351v1
    store v349v1 to v352v1
    v354v1 = const u64 1
    v355v1 = get_elem_ptr v350v1, __ptr u64, v354v1
    v356v1 = const u64 7
    store v356v1 to v355v1
    v358v1 = get_local __ptr slice, __anon_3
    mem_copy_bytes v358v1, v350v1, 16
    v360v1 = get_local __ptr slice, __anon_3
    v361v1 = call eq_9(v347v1, v360v1)
    v362v1 = const u64 2
    cbr v361v1, block7(v362v1), block3()

    block3():
    v364v1 = get_local __ptr slice, __matched_value_1
    v365v1 = get_global __ptr string<5>, __const_global1
    v366v1 = cast_ptr v365v1 to ptr
    v367v1 = get_local __ptr { ptr, u64 }, __anon_4
    v368v1 = const u64 0
    v369v1 = get_elem_ptr v367v1, __ptr ptr, v368v1
    store v366v1 to v369v1
    v371v1 = const u64 1
    v372v1 = get_elem_ptr v367v1, __ptr u64, v371v1
    v373v1 = const u64 5
    store v373v1 to v372v1
    v375v1 = get_local __ptr slice, __anon_5
    mem_copy_bytes v375v1, v367v1, 16
    v377v1 = get_local __ptr slice, __anon_5
    v378v1 = call eq_9(v364v1, v377v1)
    v379v1 = const u64 3
    cbr v378v1, block6(v379v1), block5()

    block5():
    v381v1 = const u64 1000
    br block6(v381v1)

    block6(v326v1: u64):
    br block7(v326v1)

    block7(v327v1: u64):
    br block8(v327v1)

    block8(v328v1: u64):
    ret u64 v328v1
}







pshl i15                      ; [fn init: return_match_on_str_slice_8]: push used low registers 16..40
pshh i524288                  ; [fn init: return_match_on_str_slice_8]: push used high registers 40..64
move $$locbase $sp            ; [fn init: return_match_on_str_slice_8]: set locals base register
cfei i112                     ; [fn init: return_match_on_str_slice_8]: allocate: locals 112 byte(s), call args 0 slot(s)
move $r0 $$arg0               ; [fn init: return_match_on_str_slice_8]: copy argument 0 (param)
move $r1 $$reta               ; [fn init: return_match_on_str_slice_8]: save return address
addi $r2 $$locbase i96        ; get offset to local __ptr slice
mcpi $r2 $$arg0 i16           ; copy memory
addr $r2 data_NonConfigurable_7; get __const_global's address in data section
sw   $$locbase $r2 i0         ; store word
movi $r2 i5                   ; initialize constant into register
sw   $$locbase $r2 i1         ; store word
addi $r2 $$locbase i16        ; get offset to local __ptr slice
mcpi $r2 $$locbase i16        ; copy memory
addi $r2 $$locbase i16        ; get offset to local __ptr slice
<<<<<<< HEAD
move $$arg0 $r0               ; [call: eq_9]: pass argument 0
move $$arg1 $r2               ; [call: eq_9]: pass argument 1
jal  $$reta $pc i40           ; [call: eq_9]: call function
move $r0 $one                 ; move parameter from branch to block argument
=======
move $$arg0 $r0               ; [call]: pass argument 0
move $$arg1 $r2               ; [call]: pass argument 1
jal  $$reta $pc i40           ; [call]: call eq_9
movi $r0 i1                   ; move parameter from branch to block argument
>>>>>>> 0f3fd4cde (replave move by movi when possible on asm optimisation)
jnzf $$retv $zero i31
addi $r0 $$locbase i96        ; get offset to local __ptr slice
addr $r2 data_NonConfigurable_9; get __const_global0's address in data section
addi $r3 $$locbase i32        ; get offset to local __ptr { ptr, u64 }
sw   $$locbase $r2 i4         ; store word
movi $r2 i7                   ; initialize constant into register
sw   $$locbase $r2 i5         ; store word
addi $r2 $$locbase i48        ; get offset to local __ptr slice
mcpi $r2 $r3 i16              ; copy memory
addi $r2 $$locbase i48        ; get offset to local __ptr slice
<<<<<<< HEAD
move $$arg0 $r0               ; [call: eq_9]: pass argument 0
move $$arg1 $r2               ; [call: eq_9]: pass argument 1
jal  $$reta $pc i25           ; [call: eq_9]: call function
movi $r0 i2                   ; initialize constant into register
=======
move $$arg0 $r0               ; [call]: pass argument 0
move $$arg1 $r2               ; [call]: pass argument 1
jal  $$reta $pc i25           ; [call]: call eq_9
movi $r0 i2                   ; move parameter from branch to block argument
>>>>>>> 0f3fd4cde (replave move by movi when possible on asm optimisation)
jnzf $$retv $zero i16
addi $r0 $$locbase i96        ; get offset to local __ptr slice
addr $r2 data_NonConfigurable_10; get __const_global1's address in data section
addi $r3 $$locbase i64        ; get offset to local __ptr { ptr, u64 }
sw   $$locbase $r2 i8         ; store word
movi $r2 i5                   ; initialize constant into register
sw   $$locbase $r2 i9         ; store word
addi $r2 $$locbase i80        ; get offset to local __ptr slice
mcpi $r2 $r3 i16              ; copy memory
addi $r2 $$locbase i80        ; get offset to local __ptr slice
<<<<<<< HEAD
move $$arg0 $r0               ; [call: eq_9]: pass argument 0
move $$arg1 $r2               ; [call: eq_9]: pass argument 1
jal  $$reta $pc i10           ; [call: eq_9]: call function
movi $r0 i3                   ; initialize constant into register
jnzf $$retv $zero i1
movi $r0 i1000                ; initialize constant into register
move $$retv $r0               ; [fn end: return_match_on_str_slice_8] set return value
cfsi i112                     ; [fn end: return_match_on_str_slice_8] free: locals 112 byte(s), call args 0 slot(s)
move $$reta $r1               ; [fn end: return_match_on_str_slice_8] restore return address
poph i524288                  ; [fn end: return_match_on_str_slice_8]: restore used high registers 40..64
popl i15                      ; [fn end: return_match_on_str_slice_8]: restore used low registers 16..40
jal  $zero $$reta i0          ; [fn end: return_match_on_str_slice_8] return from call
=======
move $$arg0 $r0               ; [call]: pass argument 0
move $$arg1 $r2               ; [call]: pass argument 1
jal  $$reta $pc i10           ; [call]: call eq_9
movi $r0 i3                   ; move parameter from branch to block argument
jnzf $$retv $zero i1
movi $r0 i1000                ; move parameter from branch to block argument
move $$retv $r0               ; set return value
cfsi i112                     ; free 112 bytes for locals and 0 slots for extra call arguments
move $$reta $r1               ; restore return address
poph i524288                  ; restore registers 40..64
popl i15                      ; restore registers 16..40
jal  $zero $$reta i0          ; return from call
>>>>>>> 0f3fd4cde (replave move by movi when possible on asm optimisation)
