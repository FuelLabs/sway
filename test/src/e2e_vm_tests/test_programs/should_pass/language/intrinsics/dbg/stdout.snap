---
source: test/tests/tests.rs
---
> forc build --path test/src/e2e_vm_tests/test_programs/should_pass/language/intrinsics/dbg --asm final
exit status: 0
output:
    Building test/src/e2e_vm_tests/test_programs/should_pass/language/intrinsics/dbg
   Compiling library std (test/src/e2e_vm_tests/reduced_std_libs/sway-lib-std-core)
   Compiling script dbg (test/src/e2e_vm_tests/test_programs/should_pass/language/intrinsics/dbg)
;; ASM: Final program
;; Program kind: Script
.program:
move $$tmp $pc
jmpf $zero i4
DATA_SECTION_OFFSET[0..32]
DATA_SECTION_OFFSET[32..64]
CONFIGURABLES_OFFSET[0..32]
CONFIGURABLES_OFFSET[32..64]
lw   $$ds $$tmp i1
add  $$ds $$ds $$tmp
cfei i0                       ; allocate stack space for globals
move $$locbase $sp            ; save locals base register for function __entry
cfei i448                     ; allocate 448 bytes for locals and 0 slots for call arguments
addi $r5 $$locbase i320       ; get offset to local
sub  $$reta $pc $is           ; get current instruction offset from instructions start ($is)
srli $$reta $$reta i2         ; get current instruction offset in 32-bit words
addi $$reta $$reta i4         ; [call]: set new return address
jmpf $zero i76                ; [call]: call main_0
move $r0 $$retv               ; [call]: copy the return value
sw   $$locbase $r0 i55        ; store word
lw   $r4 $$locbase i55        ; load word
movi $r0 i1024                ; initialize constant into register
aloc $r0
move $r0 $hp                  ; return value from ASM block with return register hp
addi $r1 $$locbase i112       ; get offset to local
sw   $$locbase $r0 i14        ; store word
movi $r0 i1024                ; initialize constant into register
sw   $$locbase $r0 i15        ; store word
sw   $$locbase $zero i16      ; store word
mcpi $$locbase $r1 i24        ; copy memory
addi $r0 $$locbase i184       ; get offset to local
mcpi $r0 $$locbase i24        ; copy memory
addi $r1 $$locbase i336       ; get offset to local
mcpi $r1 $r0 i24              ; copy memory
addi $r0 $$locbase i272       ; get offset to local
mcpi $r0 $r1 i24              ; copy memory
addi $r1 $$locbase i24        ; get offset to local
mcpi $r1 $r0 i24              ; copy memory
addi $r0 $$locbase i136       ; get offset to local
mcpi $r0 $r1 i24              ; copy memory
lw   $r3 $$locbase i17        ; load word
lw   $r2 $$locbase i18        ; load word
lw   $r0 $$locbase i19        ; load word
movi $r1 i8                   ; initialize constant into register
add  $r1 $r0 $r1
gt   $r1 $r1 $r2
jnzf $r1 $zero i1
jmpf $zero i7
movi $r1 i2                   ; initialize constant into register
mul  $r1 $r2 $r1
movi $r2 i8                   ; initialize constant into register
add  $r2 $r1 $r2
aloc $r2
mcp  $hp $r3 $r0
move $r3 $hp                  ; return value from ASM block with return register hp
add  $r1 $r3 $r0
sw   $r1 $r4 i0               ; store word
movi $r1 i8                   ; initialize constant into register
add  $r0 $r0 $r1
addi $r1 $$locbase i208       ; get offset to local
sw   $$locbase $r3 i26        ; store word
sw   $$locbase $r2 i27        ; store word
sw   $$locbase $r0 i28        ; store word
addi $r0 $$locbase i48        ; get offset to local
mcpi $r0 $r1 i24              ; copy memory
addi $r1 $$locbase i248       ; get offset to local
mcpi $r1 $r0 i24              ; copy memory
addi $r0 $$locbase i360       ; get offset to local
mcpi $r0 $r1 i24              ; copy memory
addi $r1 $$locbase i416       ; get offset to local
mcpi $r1 $r0 i24              ; copy memory
addi $r0 $$locbase i416       ; get offset to local
addi $r1 $$locbase i296       ; get offset to local
mcpi $r1 $r0 i24              ; copy memory
addi $r0 $$locbase i72        ; get offset to local
mcpi $r0 $r1 i24              ; copy memory
addi $r1 $$locbase i160       ; get offset to local
mcpi $r1 $r0 i24              ; copy memory
lw   $r0 $$locbase i20        ; load word
addi $r1 $r1 i16              ; get offset to aggregate element
addi $r2 $$locbase i232       ; get offset to local
sw   $$locbase $r0 i29        ; store word
addi $r0 $r2 i8               ; get offset to aggregate element
mcpi $r0 $r1 i8               ; copy memory
addi $r0 $$locbase i96        ; get offset to local
mcpi $r0 $r2 i16              ; copy memory
addi $r1 $$locbase i384       ; get offset to local
mcpi $r1 $r0 i16              ; copy memory
addi $r0 $$locbase i400       ; get offset to local
mcpi $r0 $r1 i16              ; copy memory
mcpi $r5 $r0 i16              ; copy memory
lw   $r0 $r5 i1               ; load size of returned slice
lw   $r5 $r5 i0               ; load pointer to returned slice
retd  $r5 $r0
pshl i31                      ; save registers 16..40
pshh i524288                  ; save registers 40..64
move $$locbase $sp            ; save locals base register for function main_0
cfei i272                     ; allocate 272 bytes for locals and 0 slots for call arguments
move $r4 $$reta               ; save return address
load $r0 data_NonConfigurable_0; get local constant
movi $r1 i11                  ; initialize constant into register
sw   $$locbase $r1 i20        ; store word
addi $r1 $$locbase i64        ; get offset to local
sw   $$locbase $r0 i8         ; store word
movi $r0 i20                  ; initialize constant into register
sw   $$locbase $r0 i9         ; store word
addi $r0 $$locbase i80        ; get offset to local
mcpi $r0 $r1 i16              ; copy memory
addi $r1 $$locbase i128       ; get offset to local
addi $r2 $$locbase i128       ; get offset to local
mcpi $r2 $r0 i16              ; copy memory
move $$arg0 $r1               ; [call]: pass argument 0
move $$arg1 $r2               ; [call]: pass argument 1
sub  $$reta $pc $is           ; get current instruction offset from instructions start ($is)
srli $$reta $$reta i2         ; get current instruction offset in 32-bit words
addi $$reta $$reta i4         ; [call]: set new return address
jmpf $zero i96                ; [call]: call print_str_1
addi $r0 $$locbase i160       ; get offset to local
addi $r1 $$locbase i264       ; get offset to local
mcpi $r1 $r0 i8               ; copy memory
move $r1 $zero                ; move parameter from branch to block argument
movi $r0 i1                   ; get array element size
mul  $r0 $r1 $r0              ; get offset to array element
add  $r0 $$locbase $r0        ; add array element offset to array base
sb   $r0 $zero i0             ; store byte
add  $r1 $r1 $one
movi $r0 i64                  ; initialize constant into register
lt   $r0 $r1 $r0
jnzb $r0 $zero i6
addi $r0 $$locbase i176       ; get offset to local
mcpi $r0 $$locbase i64        ; copy memory
movi $r0 i63                  ; initialize constant into register
sw   $$locbase $r0 i30        ; store word
lw   $r0 $$locbase i33        ; load word
gt   $r0 $r0 $zero
jnzf $r0 $zero i29
addi $r0 $$locbase i176       ; get offset to local
lw   $r1 $$locbase i30        ; load word
mul  $r1 $one $r1
add  $r3 $r0 $r1
lw   $r0 $$locbase i30        ; load word
movi $r1 i64                  ; initialize constant into register
sub  $r0 $r1 $r0
movi $r1 i1000                ; initialize constant into register
move $r2 $zero                ; copy ASM block argument's constant initial value to register
ecal $r1 $r2 $r3 $r0          ; ecal id fd buf count
load $r0 data_NonConfigurable_1; get local constant
addi $r1 $$locbase i96        ; get offset to local
sw   $$locbase $r0 i12        ; store word
sw   $$locbase $one i13       ; store word
addi $r0 $$locbase i112       ; get offset to local
mcpi $r0 $r1 i16              ; copy memory
addi $r1 $$locbase i144       ; get offset to local
addi $r2 $$locbase i144       ; get offset to local
mcpi $r2 $r0 i16              ; copy memory
move $$arg0 $r1               ; [call]: pass argument 0
move $$arg1 $r2               ; [call]: pass argument 1
sub  $$reta $pc $is           ; get current instruction offset from instructions start ($is)
srli $$reta $$reta i2         ; get current instruction offset in 32-bit words
addi $$reta $$reta i4         ; [call]: set new return address
jmpf $zero i51                ; [call]: call print_str_1
lw   $r0 $$locbase i20        ; load word
move $$retv $r0               ; set return value
jmpf $zero i43
lw   $r0 $$locbase i33        ; load word
movi $r1 i10                  ; initialize constant into register
mod  $r0 $r0 $r1
addi $r1 $$locbase i168       ; get offset to local
sb   $r1 $r0 i0               ; store byte
addi $r0 $$locbase i168       ; get offset to local
lb   $r0 $r0 i0               ; load byte
movi $r1 i48                  ; initialize constant into register
add  $r0 $r0 $r1
sw   $$locbase $r0 i32        ; store word
movi $r0 i255                 ; initialize constant into register
sw   $$locbase $r0 i31        ; store word
lw   $r0 $$locbase i32        ; load word
lw   $r1 $$locbase i31        ; load word
gt   $r0 $r0 $r1
jnzf $r0 $zero i2
lw   $r0 $$locbase i32        ; load word
jmpf $zero i10
move $r0 $flag                ; return value from ASM block with return register flag
addr $r1 data_NonConfigurable_2; get constant's address in data section
lw   $r1 $r1 i0               ; load word
and  $r0 $r0 $r1
eq   $r0 $r0 $zero
jnzf $r0 $zero i18
lw   $r0 $$locbase i32        ; load word
lw   $r1 $$locbase i31        ; load word
add  $r1 $r1 $one
mod  $r0 $r0 $r1
addi $r1 $$locbase i176       ; get offset to local
lw   $r2 $$locbase i30        ; load word
movi $r3 i1                   ; get array element size
mul  $r2 $r2 $r3              ; get offset to array element
add  $r2 $r1 $r2              ; add array element offset to array base
sb   $r2 $r0 i0               ; store byte
lw   $r0 $$locbase i30        ; load word
sub  $r0 $r0 $one
sw   $$locbase $r0 i30        ; store word
lw   $r0 $$locbase i33        ; load word
movi $r1 i10                  ; initialize constant into register
div  $r0 $r0 $r1
sw   $$locbase $r0 i33        ; store word
jmpb $zero i72
rvrt $zero
cfsi i272                     ; free 272 bytes for locals and 0 slots for extra call arguments
move $$reta $r4               ; restore return address
poph i524288                  ; restore registers 40..64
popl i31                      ; restore registers 16..40
jmp $$reta                    ; return from call
pshl i31                      ; save registers 16..40
pshh i524288                  ; save registers 40..64
move $$locbase $sp            ; save locals base register for function print_str_1
cfei i112                     ; allocate 112 bytes for locals and 0 slots for call arguments
move $r0 $$arg1               ; save argument 1 (s)
move $r1 $$reta               ; save return address
addi $r2 $$locbase i32        ; get offset to local
mcpi $r2 $r0 i16              ; copy memory
mcpi $$locbase $r2 i16        ; copy memory
addi $r2 $$locbase i64        ; get offset to local
mcpi $r2 $$locbase i16        ; copy memory
addi $r2 $$locbase i104       ; get offset to local
mcpi $r2 $$locbase i8         ; copy memory
lw   $r2 $$locbase i0         ; load word
addi $r3 $$locbase i48        ; get offset to local
mcpi $r3 $r0 i16              ; copy memory
addi $r0 $$locbase i16        ; get offset to local
mcpi $r0 $r3 i16              ; copy memory
addi $r3 $$locbase i80        ; get offset to local
mcpi $r3 $r0 i16              ; copy memory
addi $r0 $$locbase i96        ; get offset to local
addi $r3 $$locbase i16        ; get offset to local
addi $r3 $r3 i8               ; get offset to aggregate element
mcpi $r0 $r3 i8               ; copy memory
lw   $r0 $$locbase i3         ; load word
movi $r3 i1000                ; initialize constant into register
move $r4 $zero                ; copy ASM block argument's constant initial value to register
ecal $r3 $r4 $r2 $r0          ; ecal id fd buf count
move $$retv $zero             ; set return value
cfsi i112                     ; free 112 bytes for locals and 0 slots for extra call arguments
move $$reta $r1               ; restore return address
poph i524288                  ; restore registers 40..64
popl i31                      ; restore registers 16..40
jmp $$reta                    ; return from call
.data:
data_NonConfigurable_0 .bytes[20] 5b 73 72 63 2f 6d 61 69 6e 2e 73 77 3a 34 3a 35 5d 20 3d 20  [src/main.sw:4:5] = 
data_NonConfigurable_1 .bytes[1] 0a  .
data_NonConfigurable_2 .word 2


    Finished debug [unoptimized + fuel] target(s) [1.04 KB] in ???

> forc build --path test/src/e2e_vm_tests/test_programs/should_pass/language/intrinsics/dbg --release --asm final
exit status: 0
output:
    Building test/src/e2e_vm_tests/test_programs/should_pass/language/intrinsics/dbg
   Compiling library std (test/src/e2e_vm_tests/reduced_std_libs/sway-lib-std-core)
   Compiling script dbg (test/src/e2e_vm_tests/test_programs/should_pass/language/intrinsics/dbg)
;; ASM: Final program
;; Program kind: Script
.program:
move $$tmp $pc
jmpf $zero i4
DATA_SECTION_OFFSET[0..32]
DATA_SECTION_OFFSET[32..64]
CONFIGURABLES_OFFSET[0..32]
CONFIGURABLES_OFFSET[32..64]
lw   $$ds $$tmp i1
add  $$ds $$ds $$tmp
cfei i0                       ; allocate stack space for globals
move $$locbase $sp            ; save locals base register for function __entry
cfei i360                     ; allocate 360 bytes for locals and 0 slots for call arguments
addi $r0 $$locbase i320       ; get offset to local
sub  $$reta $pc $is           ; get current instruction offset from instructions start ($is)
srli $$reta $$reta i2         ; get current instruction offset in 32-bit words
addi $$reta $$reta i4         ; [call]: set new return address
jmpf $zero i64                ; [call]: call main_0
move $r3 $$retv               ; [call]: copy the return value
movi $r1 i1024                ; initialize constant into register
aloc $r1
move $r1 $hp                  ; return value from ASM block with return register hp
addi $r2 $$locbase i112       ; get offset to local
sw   $$locbase $r1 i14        ; store word
movi $r1 i1024                ; initialize constant into register
sw   $$locbase $r1 i15        ; store word
sw   $$locbase $zero i16      ; store word
mcpi $$locbase $r2 i24        ; copy memory
addi $r1 $$locbase i184       ; get offset to local
mcpi $r1 $$locbase i24        ; copy memory
addi $r2 $$locbase i272       ; get offset to local
mcpi $r2 $r1 i24              ; copy memory
addi $r1 $$locbase i24        ; get offset to local
mcpi $r1 $r2 i24              ; copy memory
addi $r2 $$locbase i136       ; get offset to local
mcpi $r2 $r1 i24              ; copy memory
lw   $r6 $$locbase i17        ; load word
lw   $r5 $$locbase i18        ; load word
lw   $r1 $$locbase i19        ; load word
movi $r2 i8                   ; initialize constant into register
add  $r2 $r1 $r2
gt   $r4 $r2 $r5
jnzf $r4 $zero i1
jmpf $zero i7
movi $r4 i2                   ; initialize constant into register
mul  $r4 $r5 $r4
movi $r5 i8                   ; initialize constant into register
add  $r5 $r4 $r5
aloc $r5
mcp  $hp $r6 $r1
move $r6 $hp                  ; return value from ASM block with return register hp
add  $r1 $r6 $r1
sw   $r1 $r3 i0               ; store word
addi $r1 $$locbase i208       ; get offset to local
sw   $$locbase $r6 i26        ; store word
sw   $$locbase $r5 i27        ; store word
sw   $$locbase $r2 i28        ; store word
addi $r2 $$locbase i48        ; get offset to local
mcpi $r2 $r1 i24              ; copy memory
addi $r1 $$locbase i248       ; get offset to local
mcpi $r1 $r2 i24              ; copy memory
addi $r2 $$locbase i336       ; get offset to local
mcpi $r2 $r1 i24              ; copy memory
addi $r1 $$locbase i336       ; get offset to local
addi $r2 $$locbase i296       ; get offset to local
mcpi $r2 $r1 i24              ; copy memory
addi $r1 $$locbase i72        ; get offset to local
mcpi $r1 $r2 i24              ; copy memory
addi $r2 $$locbase i160       ; get offset to local
mcpi $r2 $r1 i24              ; copy memory
lw   $r1 $$locbase i20        ; load word
addi $r2 $r2 i16              ; get offset to aggregate element
addi $r3 $$locbase i232       ; get offset to local
sw   $$locbase $r1 i29        ; store word
addi $r1 $r3 i8               ; get offset to aggregate element
mcpi $r1 $r2 i8               ; copy memory
addi $r1 $$locbase i96        ; get offset to local
mcpi $r1 $r3 i16              ; copy memory
mcpi $r0 $r1 i16              ; copy memory
lw   $r1 $r0 i1               ; load size of returned slice
lw   $r0 $r0 i0               ; load pointer to returned slice
retd  $r0 $r1
pshl i3                       ; save registers 16..40
pshh i524288                  ; save registers 40..64
move $$locbase $sp            ; save locals base register for function main_0
move $r0 $$reta               ; save return address
movi $r1 i11                  ; initialize constant into register
move $$retv $r1               ; set return value
move $$reta $r0               ; restore return address
poph i524288                  ; restore registers 40..64
popl i3                       ; restore registers 16..40
jmp $$reta                    ; return from call
.data:


    Finished release [optimized + fuel] target(s) [360 B] in ???
