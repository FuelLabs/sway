---
source: test/src/snapshot/mod.rs
---
> forc build  --path test/src/e2e_vm_tests/test_programs/should_pass/language/array/array_repeat --experimental const_generics --ir final --asm final --bytecode | filter-fn array_repeat array_fn

pshl i3                       ; save registers 16..40
pshh i524288                  ; save registers 40..64
move $$locbase $sp            ; save locals base register for function array_fn_should_use_mcli_small_u8_1
cfei i8                       ; allocate 8 bytes for locals and 0 slots for call arguments
move $r0 $$arg0               ; save argument 0 (__ret_value)
move $r1 $$reta               ; save return address
mcli $$locbase i5             ; clear memory [u8; 5], 5 bytes
mcpi $r0 $$locbase i5         ; copy memory
cfsi i8                       ; free 8 bytes for locals and 0 slots for extra call arguments
move $$reta $r1               ; restore return address
poph i524288                  ; restore registers 40..64
popl i3                       ; restore registers 16..40
jal  $zero $$reta i0          ; return from call

pshl i3                       ; save registers 16..40
pshh i524288                  ; save registers 40..64
move $$locbase $sp            ; save locals base register for function array_fn_should_use_mcli_small_u16_2
cfei i40                      ; allocate 40 bytes for locals and 0 slots for call arguments
move $r0 $$arg0               ; save argument 0 (__ret_value)
move $r1 $$reta               ; save return address
mcli $$locbase i40            ; clear memory [u64; 5], 40 bytes
mcpi $r0 $$locbase i40        ; copy memory
cfsi i40                      ; free 40 bytes for locals and 0 slots for extra call arguments
move $$reta $r1               ; restore return address
poph i524288                  ; restore registers 40..64
popl i3                       ; restore registers 16..40
jal  $zero $$reta i0          ; return from call

pshl i3                       ; save registers 16..40
pshh i524288                  ; save registers 40..64
move $$locbase $sp            ; save locals base register for function array_fn_should_use_mcli_small_u32_3
cfei i40                      ; allocate 40 bytes for locals and 0 slots for call arguments
move $r0 $$arg0               ; save argument 0 (__ret_value)
move $r1 $$reta               ; save return address
mcli $$locbase i40            ; clear memory [u64; 5], 40 bytes
mcpi $r0 $$locbase i40        ; copy memory
cfsi i40                      ; free 40 bytes for locals and 0 slots for extra call arguments
move $$reta $r1               ; restore return address
poph i524288                  ; restore registers 40..64
popl i3                       ; restore registers 16..40
jal  $zero $$reta i0          ; return from call

pshl i3                       ; save registers 16..40
pshh i524288                  ; save registers 40..64
move $$locbase $sp            ; save locals base register for function array_fn_should_use_mcli_small_u64_4
cfei i40                      ; allocate 40 bytes for locals and 0 slots for call arguments
move $r0 $$arg0               ; save argument 0 (__ret_value)
move $r1 $$reta               ; save return address
mcli $$locbase i40            ; clear memory [u64; 5], 40 bytes
mcpi $r0 $$locbase i40        ; copy memory
cfsi i40                      ; free 40 bytes for locals and 0 slots for extra call arguments
move $$reta $r1               ; restore return address
poph i524288                  ; restore registers 40..64
popl i3                       ; restore registers 16..40
jal  $zero $$reta i0          ; return from call

pshl i3                       ; save registers 16..40
pshh i524288                  ; save registers 40..64
move $$locbase $sp            ; save locals base register for function array_fn_should_use_mcli_small_u256_5
cfei i160                     ; allocate 160 bytes for locals and 0 slots for call arguments
move $r0 $$arg0               ; save argument 0 (__ret_value)
move $r1 $$reta               ; save return address
mcli $$locbase i160           ; clear memory [u256; 5], 160 bytes
mcpi $r0 $$locbase i160       ; copy memory
cfsi i160                     ; free 160 bytes for locals and 0 slots for extra call arguments
move $$reta $r1               ; restore return address
poph i524288                  ; restore registers 40..64
popl i3                       ; restore registers 16..40
jal  $zero $$reta i0          ; return from call

pshl i3                       ; save registers 16..40
pshh i524288                  ; save registers 40..64
move $$locbase $sp            ; save locals base register for function array_fn_should_use_mcli_small_b256_6
cfei i160                     ; allocate 160 bytes for locals and 0 slots for call arguments
move $r0 $$arg0               ; save argument 0 (__ret_value)
move $r1 $$reta               ; save return address
mcli $$locbase i160           ; clear memory [b256; 5], 160 bytes
mcpi $r0 $$locbase i160       ; copy memory
cfsi i160                     ; free 160 bytes for locals and 0 slots for extra call arguments
move $$reta $r1               ; restore return address
poph i524288                  ; restore registers 40..64
popl i3                       ; restore registers 16..40
jal  $zero $$reta i0          ; return from call

pshl i3                       ; save registers 16..40
pshh i524288                  ; save registers 40..64
move $$locbase $sp            ; save locals base register for function array_fn_should_use_mcli_small_bool_7
cfei i8                       ; allocate 8 bytes for locals and 0 slots for call arguments
move $r0 $$arg0               ; save argument 0 (__ret_value)
move $r1 $$reta               ; save return address
mcli $$locbase i5             ; clear memory [bool; 5], 5 bytes
mcpi $r0 $$locbase i5         ; copy memory
cfsi i8                       ; free 8 bytes for locals and 0 slots for extra call arguments
move $$reta $r1               ; restore return address
poph i524288                  ; restore registers 40..64
popl i3                       ; restore registers 16..40
jal  $zero $$reta i0          ; return from call

pshl i3                       ; save registers 16..40
pshh i524288                  ; save registers 40..64
move $$locbase $sp            ; save locals base register for function array_fn_should_use_mcli_big_u8_8
cfei i32                      ; allocate 32 bytes for locals and 0 slots for call arguments
move $r0 $$arg0               ; save argument 0 (__ret_value)
move $r1 $$reta               ; save return address
mcli $$locbase i25            ; clear memory [u8; 25], 25 bytes
mcpi $r0 $$locbase i25        ; copy memory
cfsi i32                      ; free 32 bytes for locals and 0 slots for extra call arguments
move $$reta $r1               ; restore return address
poph i524288                  ; restore registers 40..64
popl i3                       ; restore registers 16..40
jal  $zero $$reta i0          ; return from call

pshl i3                       ; save registers 16..40
pshh i524288                  ; save registers 40..64
move $$locbase $sp            ; save locals base register for function array_fn_should_use_mcli_big_u16_9
cfei i200                     ; allocate 200 bytes for locals and 0 slots for call arguments
move $r1 $$arg0               ; save argument 0 (__ret_value)
move $r0 $$reta               ; save return address
mcli $$locbase i200           ; clear memory [u64; 25], 200 bytes
mcpi $r1 $$locbase i200       ; copy memory
cfsi i200                     ; free 200 bytes for locals and 0 slots for extra call arguments
move $$reta $r0               ; restore return address
poph i524288                  ; restore registers 40..64
popl i3                       ; restore registers 16..40
jal  $zero $$reta i0          ; return from call

pshl i3                       ; save registers 16..40
pshh i524288                  ; save registers 40..64
move $$locbase $sp            ; save locals base register for function array_fn_should_use_mcli_big_u32_10
cfei i200                     ; allocate 200 bytes for locals and 0 slots for call arguments
move $r0 $$arg0               ; save argument 0 (__ret_value)
move $r1 $$reta               ; save return address
mcli $$locbase i200           ; clear memory [u64; 25], 200 bytes
mcpi $r0 $$locbase i200       ; copy memory
cfsi i200                     ; free 200 bytes for locals and 0 slots for extra call arguments
move $$reta $r1               ; restore return address
poph i524288                  ; restore registers 40..64
popl i3                       ; restore registers 16..40
jal  $zero $$reta i0          ; return from call

pshl i3                       ; save registers 16..40
pshh i524288                  ; save registers 40..64
move $$locbase $sp            ; save locals base register for function array_fn_should_use_mcli_big_u64_11
cfei i200                     ; allocate 200 bytes for locals and 0 slots for call arguments
move $r0 $$arg0               ; save argument 0 (__ret_value)
move $r1 $$reta               ; save return address
mcli $$locbase i200           ; clear memory [u64; 25], 200 bytes
mcpi $r0 $$locbase i200       ; copy memory
cfsi i200                     ; free 200 bytes for locals and 0 slots for extra call arguments
move $$reta $r1               ; restore return address
poph i524288                  ; restore registers 40..64
popl i3                       ; restore registers 16..40
jal  $zero $$reta i0          ; return from call

pshl i3                       ; save registers 16..40
pshh i524288                  ; save registers 40..64
move $$locbase $sp            ; save locals base register for function array_fn_should_use_mcli_big_u256_12
cfei i800                     ; allocate 800 bytes for locals and 0 slots for call arguments
move $r0 $$arg0               ; save argument 0 (__ret_value)
move $r1 $$reta               ; save return address
mcli $$locbase i800           ; clear memory [u256; 25], 800 bytes
mcpi $r0 $$locbase i800       ; copy memory
cfsi i800                     ; free 800 bytes for locals and 0 slots for extra call arguments
move $$reta $r1               ; restore return address
poph i524288                  ; restore registers 40..64
popl i3                       ; restore registers 16..40
jal  $zero $$reta i0          ; return from call

pshl i3                       ; save registers 16..40
pshh i524288                  ; save registers 40..64
move $$locbase $sp            ; save locals base register for function array_fn_should_use_mcli_big_b256_13
cfei i800                     ; allocate 800 bytes for locals and 0 slots for call arguments
move $r0 $$arg0               ; save argument 0 (__ret_value)
move $r1 $$reta               ; save return address
mcli $$locbase i800           ; clear memory [b256; 25], 800 bytes
mcpi $r0 $$locbase i800       ; copy memory
cfsi i800                     ; free 800 bytes for locals and 0 slots for extra call arguments
move $$reta $r1               ; restore return address
poph i524288                  ; restore registers 40..64
popl i3                       ; restore registers 16..40
jal  $zero $$reta i0          ; return from call

pshl i3                       ; save registers 16..40
pshh i524288                  ; save registers 40..64
move $$locbase $sp            ; save locals base register for function array_fn_should_use_mcli_big_bool_14
cfei i32                      ; allocate 32 bytes for locals and 0 slots for call arguments
move $r0 $$arg0               ; save argument 0 (__ret_value)
move $r1 $$reta               ; save return address
mcli $$locbase i25            ; clear memory [bool; 25], 25 bytes
mcpi $r0 $$locbase i25        ; copy memory
cfsi i32                      ; free 32 bytes for locals and 0 slots for extra call arguments
move $$reta $r1               ; restore return address
poph i524288                  ; restore registers 40..64
popl i3                       ; restore registers 16..40
jal  $zero $$reta i0          ; return from call

pshl i7                       ; save registers 16..40
pshh i524288                  ; save registers 40..64
move $$locbase $sp            ; save locals base register for function array_fn_should_store_each_item_bool_15
cfei i8                       ; allocate 8 bytes for locals and 0 slots for call arguments
move $r0 $$arg0               ; save argument 0 (__ret_value)
move $r1 $$reta               ; save return address
mul  $r2 $zero $one           ; get offset to array element
add  $r2 $$locbase $r2        ; add array element offset to array base
sb   $r2 $one i0              ; store byte
mul  $r2 $one $one            ; get offset to array element
add  $r2 $$locbase $r2        ; add array element offset to array base
sb   $r2 $one i0              ; store byte
movi $r2 i2                   ; initialize constant into register
mul  $r2 $r2 $one             ; get offset to array element
add  $r2 $$locbase $r2        ; add array element offset to array base
sb   $r2 $one i0              ; store byte
movi $r2 i3                   ; initialize constant into register
mul  $r2 $r2 $one             ; get offset to array element
add  $r2 $$locbase $r2        ; add array element offset to array base
sb   $r2 $one i0              ; store byte
movi $r2 i4                   ; initialize constant into register
mul  $r2 $r2 $one             ; get offset to array element
add  $r2 $$locbase $r2        ; add array element offset to array base
sb   $r2 $one i0              ; store byte
mcpi $r0 $$locbase i5         ; copy memory
cfsi i8                       ; free 8 bytes for locals and 0 slots for extra call arguments
move $$reta $r1               ; restore return address
poph i524288                  ; restore registers 40..64
popl i7                       ; restore registers 16..40
jal  $zero $$reta i0          ; return from call

pshl i15                      ; save registers 16..40
pshh i524288                  ; save registers 40..64
move $$locbase $sp            ; save locals base register for function array_fn_should_loop_bool_16
cfei i32                      ; allocate 32 bytes for locals and 0 slots for call arguments
move $r0 $$arg0               ; save argument 0 (__ret_value)
move $r1 $$reta               ; save return address
move $r3 $zero                ; move parameter from branch to block argument
mul  $r2 $r3 $one             ; get offset to array element
add  $r2 $$locbase $r2        ; add array element offset to array base
sb   $r2 $one i0              ; store byte
add  $r3 $r3 $one
movi $r2 i25                  ; initialize constant into register
lt   $r2 $r3 $r2
jnzb $r2 $zero i5
mcpi $r0 $$locbase i25        ; copy memory
cfsi i32                      ; free 32 bytes for locals and 0 slots for extra call arguments
move $$reta $r1               ; restore return address
poph i524288                  ; restore registers 40..64
popl i15                      ; restore registers 16..40
jal  $zero $$reta i0          ; return from call

pshl i3                       ; save registers 16..40
pshh i524288                  ; save registers 40..64
move $$locbase $sp            ; save locals base register for function array_fn_should_use_mcl_u8_17
cfei i262152                  ; allocate 262152 bytes for locals and 0 slots for call arguments
move $r0 $$arg0               ; save argument 0 (__ret_value)
move $r1 $$reta               ; save return address
load $$tmp data_NonConfigurable_2; loading clear size in bytes
mcl  $$locbase $$tmp          ; clear memory [u8; 262145]
load $$tmp data_NonConfigurable_2; loading copy size in bytes
mcp  $r0 $$locbase $$tmp      ; copy memory
cfsi i262152                  ; free 262152 bytes for locals and 0 slots for extra call arguments
move $$reta $r1               ; restore return address
poph i524288                  ; restore registers 40..64
popl i3                       ; restore registers 16..40
jal  $zero $$reta i0          ; return from call

> forc test --path test/src/e2e_vm_tests/test_programs/should_pass/language/array/array_repeat --experimental const_generics --verbose
exit status: 0
output:
    Building test/src/e2e_vm_tests/test_programs/should_pass/language/array/array_repeat
   Compiling library std (test/src/e2e_vm_tests/reduced_std_libs/sway-lib-std-assert)
   Compiling script array_repeat (test/src/e2e_vm_tests/test_programs/should_pass/language/array/array_repeat)
<<<<<<< HEAD
    Finished debug [unoptimized + fuel] target(s) [7.064 KB] in ???
=======
    Finished debug [unoptimized + fuel] target(s) [7.072 KB] in ???
    script array_repeat
      Bytecode size: 7072 bytes (7.072 KB)
      Bytecode hash: 0x219d14849a80aedeb7c7eb544d4ca32ad257c99a51a713e943d1dd2596fcf797
>>>>>>> 150dba742 (optimize encoding for u64)
     Running 1 test, filtered 0 tests

tested -- array_repeat

      test test ... ok (???, 22829177 gas)

test result: OK. 1 passed; 0 failed; finished in ???

    Finished in ???
