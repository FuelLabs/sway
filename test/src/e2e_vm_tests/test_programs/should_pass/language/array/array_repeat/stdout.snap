---
source: test/src/snapshot/mod.rs
---
> forc build  --path test/src/e2e_vm_tests/test_programs/should_pass/language/array/array_repeat --experimental const_generics --ir final --asm final --bytecode | filter-fn array_repeat array_fn

fn array_fn_should_use_mcli_small_u8_1(__ret_value: __ptr [u8; 5]) -> () {
    local [u8; 5] __anon_0

    entry(__ret_value: __ptr [u8; 5]):
    v0 = get_local __ptr [u8; 5], __anon_0
    mem_clear_val v0
    mem_copy_val __ret_value, v0
    v1 = const unit ()
    ret () v1
}


fn array_fn_should_use_mcli_small_u16_2(__ret_value: __ptr [u64; 5]) -> () {
    local [u64; 5] __anon_0

    entry(__ret_value: __ptr [u64; 5]):
    v0 = get_local __ptr [u64; 5], __anon_0
    mem_clear_val v0
    mem_copy_val __ret_value, v0
    v1 = const unit ()
    ret () v1
}


fn array_fn_should_use_mcli_small_u32_3(__ret_value: __ptr [u64; 5]) -> () {
    local [u64; 5] __anon_0

    entry(__ret_value: __ptr [u64; 5]):
    v0 = get_local __ptr [u64; 5], __anon_0
    mem_clear_val v0
    mem_copy_val __ret_value, v0
    v1 = const unit ()
    ret () v1
}


fn array_fn_should_use_mcli_small_u64_4(__ret_value: __ptr [u64; 5]) -> () {
    local [u64; 5] __anon_0

    entry(__ret_value: __ptr [u64; 5]):
    v0 = get_local __ptr [u64; 5], __anon_0
    mem_clear_val v0
    mem_copy_val __ret_value, v0
    v1 = const unit ()
    ret () v1
}


fn array_fn_should_use_mcli_small_u256_5(__ret_value: __ptr [u256; 5]) -> () {
    local [u256; 5] __anon_0

    entry(__ret_value: __ptr [u256; 5]):
    v0 = get_local __ptr [u256; 5], __anon_0
    mem_clear_val v0
    mem_copy_val __ret_value, v0
    v1 = const unit ()
    ret () v1
}


fn array_fn_should_use_mcli_small_b256_6(__ret_value: __ptr [b256; 5]) -> () {
    local [b256; 5] __anon_0

    entry(__ret_value: __ptr [b256; 5]):
    v0 = get_local __ptr [b256; 5], __anon_0
    mem_clear_val v0
    mem_copy_val __ret_value, v0
    v1 = const unit ()
    ret () v1
}


fn array_fn_should_use_mcli_small_bool_7(__ret_value: __ptr [bool; 5]) -> () {
    local [bool; 5] __anon_0

    entry(__ret_value: __ptr [bool; 5]):
    v0 = get_local __ptr [bool; 5], __anon_0
    mem_clear_val v0
    mem_copy_val __ret_value, v0
    v1 = const unit ()
    ret () v1
}


fn array_fn_should_use_mcli_big_u8_8(__ret_value: __ptr [u8; 25]) -> () {
    local [u8; 25] __anon_0

    entry(__ret_value: __ptr [u8; 25]):
    v0 = get_local __ptr [u8; 25], __anon_0
    mem_clear_val v0
    mem_copy_val __ret_value, v0
    v1 = const unit ()
    ret () v1
}


fn array_fn_should_use_mcli_big_u16_9(__ret_value: __ptr [u64; 25]) -> () {
    local [u64; 25] __anon_0

    entry(__ret_value: __ptr [u64; 25]):
    v0 = get_local __ptr [u64; 25], __anon_0
    mem_clear_val v0
    mem_copy_val __ret_value, v0
    v1 = const unit ()
    ret () v1
}


fn array_fn_should_use_mcli_big_u32_10(__ret_value: __ptr [u64; 25]) -> () {
    local [u64; 25] __anon_0

    entry(__ret_value: __ptr [u64; 25]):
    v0 = get_local __ptr [u64; 25], __anon_0
    mem_clear_val v0
    mem_copy_val __ret_value, v0
    v1 = const unit ()
    ret () v1
}


fn array_fn_should_use_mcli_big_u64_11(__ret_value: __ptr [u64; 25]) -> () {
    local [u64; 25] __anon_0

    entry(__ret_value: __ptr [u64; 25]):
    v0 = get_local __ptr [u64; 25], __anon_0
    mem_clear_val v0
    mem_copy_val __ret_value, v0
    v1 = const unit ()
    ret () v1
}


fn array_fn_should_use_mcli_big_u256_12(__ret_value: __ptr [u256; 25]) -> () {
    local [u256; 25] __anon_0

    entry(__ret_value: __ptr [u256; 25]):
    v0 = get_local __ptr [u256; 25], __anon_0
    mem_clear_val v0
    mem_copy_val __ret_value, v0
    v1 = const unit ()
    ret () v1
}


fn array_fn_should_use_mcli_big_b256_13(__ret_value: __ptr [b256; 25]) -> () {
    local [b256; 25] __anon_0

    entry(__ret_value: __ptr [b256; 25]):
    v0 = get_local __ptr [b256; 25], __anon_0
    mem_clear_val v0
    mem_copy_val __ret_value, v0
    v1 = const unit ()
    ret () v1
}


fn array_fn_should_use_mcli_big_bool_14(__ret_value: __ptr [bool; 25]) -> () {
    local [bool; 25] __anon_0

    entry(__ret_value: __ptr [bool; 25]):
    v0 = get_local __ptr [bool; 25], __anon_0
    mem_clear_val v0
    mem_copy_val __ret_value, v0
    v1 = const unit ()
    ret () v1
}


fn array_fn_should_store_each_item_bool_15(__ret_value: __ptr [bool; 5]) -> () {
    local [bool; 5] __anon_0

    entry(__ret_value: __ptr [bool; 5]):
    v0 = get_local __ptr [bool; 5], __anon_0
    v1 = const u64 0
    v2 = get_elem_ptr v0, __ptr bool, v1
    v3 = const bool true
    store v3 to v2
    v4 = const u64 1
    v5 = get_elem_ptr v0, __ptr bool, v4
    store v3 to v5
    v6 = const u64 2
    v7 = get_elem_ptr v0, __ptr bool, v6
    store v3 to v7
    v8 = const u64 3
    v9 = get_elem_ptr v0, __ptr bool, v8
    store v3 to v9
    v10 = const u64 4
    v11 = get_elem_ptr v0, __ptr bool, v10
    store v3 to v11
    mem_copy_val __ret_value, v0
    v12 = const unit ()
    ret () v12
}


fn array_fn_should_loop_bool_16(__ret_value: __ptr [bool; 25]) -> () {
    local [bool; 25] __anon_0

    entry(__ret_value: __ptr [bool; 25]):
    v0 = get_local __ptr [bool; 25], __anon_0
    v1 = const u64 0
    br array_init_loop(v1)

    array_init_loop(v2: u64):
    v3 = get_elem_ptr v0, __ptr bool, v2
    v4 = const bool true
    store v4 to v3
    v5 = const u64 1
    v6 = add v2, v5
    v7 = const u64 25
    v8 = cmp lt v6 v7
    cbr v8, array_init_loop(v6), array_init_exit()

    array_init_exit():
    mem_copy_val __ret_value, v0
    v9 = const unit ()
    ret () v9
}


fn array_fn_should_use_mcl_u8_17(__ret_value: __ptr [u8; 262145]) -> () {
    local [u8; 262145] __anon_0

    entry(__ret_value: __ptr [u8; 262145]):
    v0 = get_local __ptr [u8; 262145], __anon_0
    mem_clear_val v0
    mem_copy_val __ret_value, v0
    v1 = const unit ()
    ret () v1
}


pshl i3                       ; save registers 16..40
pshh i524288                  ; save registers 40..64
move $$locbase $sp            ; save locals base register for function array_fn_should_use_mcli_small_u8_1
cfei i8                       ; allocate 8 bytes for locals and 0 slots for call arguments
move $r0 $$arg0               ; save argument 0 (__ret_value)
move $r1 $$reta               ; save return address
mcli $$locbase i5             ; clear memory [u8; 5], 5 bytes
mcpi $r0 $$locbase i5         ; copy memory
cfsi i8                       ; free 8 bytes for locals and 0 slots for extra call arguments
move $$reta $r1               ; restore return address
poph i524288                  ; restore registers 40..64
popl i3                       ; restore registers 16..40
jal  $zero $$reta i0          ; return from call

pshl i3                       ; save registers 16..40
pshh i524288                  ; save registers 40..64
move $$locbase $sp            ; save locals base register for function array_fn_should_use_mcli_small_u16_2
cfei i40                      ; allocate 40 bytes for locals and 0 slots for call arguments
move $r0 $$arg0               ; save argument 0 (__ret_value)
move $r1 $$reta               ; save return address
mcli $$locbase i40            ; clear memory [u64; 5], 40 bytes
mcpi $r0 $$locbase i40        ; copy memory
cfsi i40                      ; free 40 bytes for locals and 0 slots for extra call arguments
move $$reta $r1               ; restore return address
poph i524288                  ; restore registers 40..64
popl i3                       ; restore registers 16..40
jal  $zero $$reta i0          ; return from call

pshl i3                       ; save registers 16..40
pshh i524288                  ; save registers 40..64
move $$locbase $sp            ; save locals base register for function array_fn_should_use_mcli_small_u32_3
cfei i40                      ; allocate 40 bytes for locals and 0 slots for call arguments
move $r0 $$arg0               ; save argument 0 (__ret_value)
move $r1 $$reta               ; save return address
mcli $$locbase i40            ; clear memory [u64; 5], 40 bytes
mcpi $r0 $$locbase i40        ; copy memory
cfsi i40                      ; free 40 bytes for locals and 0 slots for extra call arguments
move $$reta $r1               ; restore return address
poph i524288                  ; restore registers 40..64
popl i3                       ; restore registers 16..40
jal  $zero $$reta i0          ; return from call

pshl i3                       ; save registers 16..40
pshh i524288                  ; save registers 40..64
move $$locbase $sp            ; save locals base register for function array_fn_should_use_mcli_small_u64_4
cfei i40                      ; allocate 40 bytes for locals and 0 slots for call arguments
move $r0 $$arg0               ; save argument 0 (__ret_value)
move $r1 $$reta               ; save return address
mcli $$locbase i40            ; clear memory [u64; 5], 40 bytes
mcpi $r0 $$locbase i40        ; copy memory
cfsi i40                      ; free 40 bytes for locals and 0 slots for extra call arguments
move $$reta $r1               ; restore return address
poph i524288                  ; restore registers 40..64
popl i3                       ; restore registers 16..40
jal  $zero $$reta i0          ; return from call

pshl i3                       ; save registers 16..40
pshh i524288                  ; save registers 40..64
move $$locbase $sp            ; save locals base register for function array_fn_should_use_mcli_small_u256_5
cfei i160                     ; allocate 160 bytes for locals and 0 slots for call arguments
move $r0 $$arg0               ; save argument 0 (__ret_value)
move $r1 $$reta               ; save return address
mcli $$locbase i160           ; clear memory [u256; 5], 160 bytes
mcpi $r0 $$locbase i160       ; copy memory
cfsi i160                     ; free 160 bytes for locals and 0 slots for extra call arguments
move $$reta $r1               ; restore return address
poph i524288                  ; restore registers 40..64
popl i3                       ; restore registers 16..40
jal  $zero $$reta i0          ; return from call

pshl i3                       ; save registers 16..40
pshh i524288                  ; save registers 40..64
move $$locbase $sp            ; save locals base register for function array_fn_should_use_mcli_small_b256_6
cfei i160                     ; allocate 160 bytes for locals and 0 slots for call arguments
move $r0 $$arg0               ; save argument 0 (__ret_value)
move $r1 $$reta               ; save return address
mcli $$locbase i160           ; clear memory [b256; 5], 160 bytes
mcpi $r0 $$locbase i160       ; copy memory
cfsi i160                     ; free 160 bytes for locals and 0 slots for extra call arguments
move $$reta $r1               ; restore return address
poph i524288                  ; restore registers 40..64
popl i3                       ; restore registers 16..40
jal  $zero $$reta i0          ; return from call

pshl i3                       ; save registers 16..40
pshh i524288                  ; save registers 40..64
move $$locbase $sp            ; save locals base register for function array_fn_should_use_mcli_small_bool_7
cfei i8                       ; allocate 8 bytes for locals and 0 slots for call arguments
move $r0 $$arg0               ; save argument 0 (__ret_value)
move $r1 $$reta               ; save return address
mcli $$locbase i5             ; clear memory [bool; 5], 5 bytes
mcpi $r0 $$locbase i5         ; copy memory
cfsi i8                       ; free 8 bytes for locals and 0 slots for extra call arguments
move $$reta $r1               ; restore return address
poph i524288                  ; restore registers 40..64
popl i3                       ; restore registers 16..40
jal  $zero $$reta i0          ; return from call

pshl i3                       ; save registers 16..40
pshh i524288                  ; save registers 40..64
move $$locbase $sp            ; save locals base register for function array_fn_should_use_mcli_big_u8_8
cfei i32                      ; allocate 32 bytes for locals and 0 slots for call arguments
move $r0 $$arg0               ; save argument 0 (__ret_value)
move $r1 $$reta               ; save return address
mcli $$locbase i25            ; clear memory [u8; 25], 25 bytes
mcpi $r0 $$locbase i25        ; copy memory
cfsi i32                      ; free 32 bytes for locals and 0 slots for extra call arguments
move $$reta $r1               ; restore return address
poph i524288                  ; restore registers 40..64
popl i3                       ; restore registers 16..40
jal  $zero $$reta i0          ; return from call

pshl i3                       ; save registers 16..40
pshh i524288                  ; save registers 40..64
move $$locbase $sp            ; save locals base register for function array_fn_should_use_mcli_big_u16_9
cfei i200                     ; allocate 200 bytes for locals and 0 slots for call arguments
move $r1 $$arg0               ; save argument 0 (__ret_value)
move $r0 $$reta               ; save return address
mcli $$locbase i200           ; clear memory [u64; 25], 200 bytes
mcpi $r1 $$locbase i200       ; copy memory
cfsi i200                     ; free 200 bytes for locals and 0 slots for extra call arguments
move $$reta $r0               ; restore return address
poph i524288                  ; restore registers 40..64
popl i3                       ; restore registers 16..40
jal  $zero $$reta i0          ; return from call

pshl i3                       ; save registers 16..40
pshh i524288                  ; save registers 40..64
move $$locbase $sp            ; save locals base register for function array_fn_should_use_mcli_big_u32_10
cfei i200                     ; allocate 200 bytes for locals and 0 slots for call arguments
move $r0 $$arg0               ; save argument 0 (__ret_value)
move $r1 $$reta               ; save return address
mcli $$locbase i200           ; clear memory [u64; 25], 200 bytes
mcpi $r0 $$locbase i200       ; copy memory
cfsi i200                     ; free 200 bytes for locals and 0 slots for extra call arguments
move $$reta $r1               ; restore return address
poph i524288                  ; restore registers 40..64
popl i3                       ; restore registers 16..40
jal  $zero $$reta i0          ; return from call

pshl i3                       ; save registers 16..40
pshh i524288                  ; save registers 40..64
move $$locbase $sp            ; save locals base register for function array_fn_should_use_mcli_big_u64_11
cfei i200                     ; allocate 200 bytes for locals and 0 slots for call arguments
move $r0 $$arg0               ; save argument 0 (__ret_value)
move $r1 $$reta               ; save return address
mcli $$locbase i200           ; clear memory [u64; 25], 200 bytes
mcpi $r0 $$locbase i200       ; copy memory
cfsi i200                     ; free 200 bytes for locals and 0 slots for extra call arguments
move $$reta $r1               ; restore return address
poph i524288                  ; restore registers 40..64
popl i3                       ; restore registers 16..40
jal  $zero $$reta i0          ; return from call

pshl i3                       ; save registers 16..40
pshh i524288                  ; save registers 40..64
move $$locbase $sp            ; save locals base register for function array_fn_should_use_mcli_big_u256_12
cfei i800                     ; allocate 800 bytes for locals and 0 slots for call arguments
move $r0 $$arg0               ; save argument 0 (__ret_value)
move $r1 $$reta               ; save return address
mcli $$locbase i800           ; clear memory [u256; 25], 800 bytes
mcpi $r0 $$locbase i800       ; copy memory
cfsi i800                     ; free 800 bytes for locals and 0 slots for extra call arguments
move $$reta $r1               ; restore return address
poph i524288                  ; restore registers 40..64
popl i3                       ; restore registers 16..40
jal  $zero $$reta i0          ; return from call

pshl i3                       ; save registers 16..40
pshh i524288                  ; save registers 40..64
move $$locbase $sp            ; save locals base register for function array_fn_should_use_mcli_big_b256_13
cfei i800                     ; allocate 800 bytes for locals and 0 slots for call arguments
move $r0 $$arg0               ; save argument 0 (__ret_value)
move $r1 $$reta               ; save return address
mcli $$locbase i800           ; clear memory [b256; 25], 800 bytes
mcpi $r0 $$locbase i800       ; copy memory
cfsi i800                     ; free 800 bytes for locals and 0 slots for extra call arguments
move $$reta $r1               ; restore return address
poph i524288                  ; restore registers 40..64
popl i3                       ; restore registers 16..40
jal  $zero $$reta i0          ; return from call

pshl i3                       ; save registers 16..40
pshh i524288                  ; save registers 40..64
move $$locbase $sp            ; save locals base register for function array_fn_should_use_mcli_big_bool_14
cfei i32                      ; allocate 32 bytes for locals and 0 slots for call arguments
move $r0 $$arg0               ; save argument 0 (__ret_value)
move $r1 $$reta               ; save return address
mcli $$locbase i25            ; clear memory [bool; 25], 25 bytes
mcpi $r0 $$locbase i25        ; copy memory
cfsi i32                      ; free 32 bytes for locals and 0 slots for extra call arguments
move $$reta $r1               ; restore return address
poph i524288                  ; restore registers 40..64
popl i3                       ; restore registers 16..40
jal  $zero $$reta i0          ; return from call

pshl i7                       ; save registers 16..40
pshh i524288                  ; save registers 40..64
move $$locbase $sp            ; save locals base register for function array_fn_should_store_each_item_bool_15
cfei i8                       ; allocate 8 bytes for locals and 0 slots for call arguments
move $r0 $$arg0               ; save argument 0 (__ret_value)
move $r1 $$reta               ; save return address
mul  $r2 $zero $one           ; get offset to array element
add  $r2 $$locbase $r2        ; add array element offset to array base
sb   $r2 $one i0              ; store byte
mul  $r2 $one $one            ; get offset to array element
add  $r2 $$locbase $r2        ; add array element offset to array base
sb   $r2 $one i0              ; store byte
movi $r2 i2                   ; initialize constant into register
mul  $r2 $r2 $one             ; get offset to array element
add  $r2 $$locbase $r2        ; add array element offset to array base
sb   $r2 $one i0              ; store byte
movi $r2 i3                   ; initialize constant into register
mul  $r2 $r2 $one             ; get offset to array element
add  $r2 $$locbase $r2        ; add array element offset to array base
sb   $r2 $one i0              ; store byte
movi $r2 i4                   ; initialize constant into register
mul  $r2 $r2 $one             ; get offset to array element
add  $r2 $$locbase $r2        ; add array element offset to array base
sb   $r2 $one i0              ; store byte
mcpi $r0 $$locbase i5         ; copy memory
cfsi i8                       ; free 8 bytes for locals and 0 slots for extra call arguments
move $$reta $r1               ; restore return address
poph i524288                  ; restore registers 40..64
popl i7                       ; restore registers 16..40
jal  $zero $$reta i0          ; return from call

pshl i15                      ; save registers 16..40
pshh i524288                  ; save registers 40..64
move $$locbase $sp            ; save locals base register for function array_fn_should_loop_bool_16
cfei i32                      ; allocate 32 bytes for locals and 0 slots for call arguments
move $r0 $$arg0               ; save argument 0 (__ret_value)
move $r1 $$reta               ; save return address
move $r3 $zero                ; move parameter from branch to block argument
mul  $r2 $r3 $one             ; get offset to array element
add  $r2 $$locbase $r2        ; add array element offset to array base
sb   $r2 $one i0              ; store byte
add  $r3 $r3 $one
movi $r2 i25                  ; initialize constant into register
lt   $r2 $r3 $r2
jnzb $r2 $zero i5
mcpi $r0 $$locbase i25        ; copy memory
cfsi i32                      ; free 32 bytes for locals and 0 slots for extra call arguments
move $$reta $r1               ; restore return address
poph i524288                  ; restore registers 40..64
popl i15                      ; restore registers 16..40
jal  $zero $$reta i0          ; return from call

pshl i3                       ; save registers 16..40
pshh i524288                  ; save registers 40..64
move $$locbase $sp            ; save locals base register for function array_fn_should_use_mcl_u8_17
cfei i262152                  ; allocate 262152 bytes for locals and 0 slots for call arguments
move $r0 $$arg0               ; save argument 0 (__ret_value)
move $r1 $$reta               ; save return address
load $$tmp data_NonConfigurable_2; loading clear size in bytes
mcl  $$locbase $$tmp          ; clear memory [u8; 262145]
load $$tmp data_NonConfigurable_2; loading copy size in bytes
mcp  $r0 $$locbase $$tmp      ; copy memory
cfsi i262152                  ; free 262152 bytes for locals and 0 slots for extra call arguments
move $$reta $r1               ; restore return address
poph i524288                  ; restore registers 40..64
popl i3                       ; restore registers 16..40
jal  $zero $$reta i0          ; return from call

> forc test --path test/src/e2e_vm_tests/test_programs/should_pass/language/array/array_repeat --experimental const_generics --verbose
exit status: 0
output:
    Building test/src/e2e_vm_tests/test_programs/should_pass/language/array/array_repeat
   Compiling library std (test/src/e2e_vm_tests/reduced_std_libs/sway-lib-std-assert)
   Compiling script array_repeat (test/src/e2e_vm_tests/test_programs/should_pass/language/array/array_repeat)
    Finished debug [unoptimized + fuel] target(s) [7.072 KB] in ???
     Running 1 test, filtered 0 tests

tested -- array_repeat

      test test ... ok (???, 22829177 gas)

test result: OK. 1 passed; 0 failed; finished in ???

    Finished in ???
