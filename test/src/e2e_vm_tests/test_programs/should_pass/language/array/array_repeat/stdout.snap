---
source: test/src/snapshot/mod.rs
---
> forc build  --path test/src/e2e_vm_tests/test_programs/should_pass/language/array/array_repeat --ir final --asm final --bytecode --release
exit status: 0
output:
    Building test/src/e2e_vm_tests/test_programs/should_pass/language/array/array_repeat
   Compiling library std (test/src/e2e_vm_tests/reduced_std_libs/sway-lib-std-assert)
// IR: Final
library {
}

DIFF------------------------------
.program:
DIFF------------------------------
.program:
;; --- START OF TARGET BYTECODE ---

0x00000000 MOVE R60 $pc                                    ;; [26, 240, 48, 0]
0x00000004 JMPF $zero 0x4                                  ;; [116, 0, 0, 4]
0x00000008                                                 ;; [0, 0, 0, 0, 0, 0, 0, 32]
0x00000010                                                 ;; [0, 0, 0, 0, 0, 0, 0, 0]
0x00000018 LW R63 R60 0x1                                  ;; [93, 255, 192, 1]
0x0000001c ADD R63 R63 R60                                 ;; [16, 255, 255, 0]
.data_section:
;; --- END OF TARGET BYTECODE ---

   Compiling script array_repeat (test/src/e2e_vm_tests/test_programs/should_pass/language/array/array_repeat)
// IR: Final
script {
    pub entry fn __entry() -> __ptr never, !3 {
        entry():
        v783v1 = call main_0(), !6
        v786v1 = const u64 0, !7
        v787v1 = const u64 0, !8
        retd v786v1 v787v1, !9
    }

    entry_orig fn main_0() -> (), !13 {
        local [u8; 5] __ret_val
        local [u64; 5] __ret_val0
        local [u64; 5] __ret_val1
        local [u256; 25] __ret_val10
        local [b256; 25] __ret_val11
        local [bool; 25] __ret_val12
        local [bool; 5] __ret_val13
        local [bool; 25] __ret_val14
        local [u8; 262145] __ret_val15
        local [u64; 5] __ret_val2
        local [u256; 5] __ret_val3
        local [b256; 5] __ret_val4
        local [bool; 5] __ret_val5
        local [u8; 25] __ret_val6
        local [u64; 25] __ret_val7
        local [u64; 25] __ret_val8
        local [u64; 25] __ret_val9
        local [u8; 1] array

        entry():
        v1813v1 = get_local __ptr [u8; 5], __ret_val
        v1814v1 = call array_repeat_zero_small_u8_1(v1813v1)
        v1820v1 = get_local __ptr [u64; 5], __ret_val0
        v1821v1 = call array_repeat_zero_small_u16_2(v1820v1)
        v1823v1 = get_local __ptr [u64; 5], __ret_val1
        v1824v1 = call array_repeat_zero_small_u16_2(v1823v1)
        v1826v1 = get_local __ptr [u64; 5], __ret_val2
        v1827v1 = call array_repeat_zero_small_u16_2(v1826v1)
        v1833v1 = get_local __ptr [u256; 5], __ret_val3
        v1834v1 = call array_repeat_zero_small_u256_5(v1833v1)
        v1840v1 = get_local __ptr [b256; 5], __ret_val4
        v1841v1 = call array_repeat_zero_small_b256_6(v1840v1)
        v1847v1 = get_local __ptr [bool; 5], __ret_val5
        v1848v1 = call array_repeat_zero_small_bool_7(v1847v1)
        v1854v1 = get_local __ptr [u8; 25], __ret_val6
        v1855v1 = call array_repeat_zero_big_u8_8(v1854v1)
        v1861v1 = get_local __ptr [u64; 25], __ret_val7
        v1862v1 = call array_repeat_zero_big_u32_10(v1861v1)
        v1864v1 = get_local __ptr [u64; 25], __ret_val8
        v1865v1 = call array_repeat_zero_big_u32_10(v1864v1)
        v1867v1 = get_local __ptr [u64; 25], __ret_val9
        v1868v1 = call array_repeat_zero_big_u32_10(v1867v1)
        v1874v1 = get_local __ptr [u256; 25], __ret_val10
        v1875v1 = call array_repeat_zero_big_u256_12(v1874v1)
        v1881v1 = get_local __ptr [b256; 25], __ret_val11
        v1882v1 = call array_repeat_zero_big_b256_13(v1881v1)
        v1888v1 = get_local __ptr [bool; 25], __ret_val12
        v1889v1 = call array_repeat_zero_big_bool_14(v1888v1)
        v1895v1 = get_local __ptr [bool; 5], __ret_val13
        v1896v1 = call small_array_repeat_15(v1895v1)
        v1902v1 = get_local __ptr [bool; 25], __ret_val14
        v1903v1 = call big_array_repeat_16(v1902v1)
        v1909v1 = get_local __ptr [u8; 262145], __ret_val15
        v1910v1 = call u8_array_bigger_than_18_bits_17(v1909v1)
        v190v1 = call arrays_with_const_length_18(), !16
        v1916v1 = get_local __ptr [u8; 1], array
        v1917v1 = call decode_array_19(v1916v1)
        v774v1 = get_local __ptr [u8; 1], array, !17
        v775v1 = const u64 0, !18
        v776v1 = get_elem_ptr v774v1, __ptr u8, v775v1, !19
        v777v1 = load v776v1
        v778v1 = const u8 255, !20
        v1758v1 = cmp eq v777v1 v778v1, !29
        v573v1 = const bool false, !30
        v1762v1 = cmp eq v1758v1 v573v1, !33
        cbr v1762v1, assert_eq_42_block0(), assert_eq_42_block1(), !34

        assert_eq_42_block0():
        v1769v1 = call log_46(v777v1), !37
        v1771v1 = call log_46(v778v1), !40
        v870v1 = const u64 18446744073709486083
        revert v870v1, !45

        assert_eq_42_block1():
        v781v1 = const unit ()
        ret () v781v1
    }

    fn array_repeat_zero_small_u8_1(__ret_value: __ptr [u8; 5]) -> (), !49 {
        entry(__ret_value: __ptr [u8; 5]):
        mem_clear_val __ret_value, !50
        v1811v1 = const unit ()
        ret () v1811v1
    }

    fn array_repeat_zero_small_u16_2(__ret_value: __ptr [u64; 5]) -> (), !53 {
        entry(__ret_value: __ptr [u64; 5]):
        mem_clear_val __ret_value, !54
        v1818v1 = const unit ()
        ret () v1818v1
    }

    fn array_repeat_zero_small_u256_5(__ret_value: __ptr [u256; 5]) -> (), !57 {
        entry(__ret_value: __ptr [u256; 5]):
        mem_clear_val __ret_value, !58
        v1831v1 = const unit ()
        ret () v1831v1
    }

    fn array_repeat_zero_small_b256_6(__ret_value: __ptr [b256; 5]) -> (), !61 {
        entry(__ret_value: __ptr [b256; 5]):
        mem_clear_val __ret_value, !62
        v1838v1 = const unit ()
        ret () v1838v1
    }

    fn array_repeat_zero_small_bool_7(__ret_value: __ptr [bool; 5]) -> (), !65 {
        entry(__ret_value: __ptr [bool; 5]):
        mem_clear_val __ret_value, !66
        v1845v1 = const unit ()
        ret () v1845v1
    }

    fn array_repeat_zero_big_u8_8(__ret_value: __ptr [u8; 25]) -> (), !69 {
        entry(__ret_value: __ptr [u8; 25]):
        mem_clear_val __ret_value, !70
        v1852v1 = const unit ()
        ret () v1852v1
    }

    fn array_repeat_zero_big_u32_10(__ret_value: __ptr [u64; 25]) -> (), !73 {
        entry(__ret_value: __ptr [u64; 25]):
        mem_clear_val __ret_value, !74
        v1859v1 = const unit ()
        ret () v1859v1
    }

    fn array_repeat_zero_big_u256_12(__ret_value: __ptr [u256; 25]) -> (), !77 {
        entry(__ret_value: __ptr [u256; 25]):
        mem_clear_val __ret_value, !78
        v1872v1 = const unit ()
        ret () v1872v1
    }

    fn array_repeat_zero_big_b256_13(__ret_value: __ptr [b256; 25]) -> (), !81 {
        entry(__ret_value: __ptr [b256; 25]):
        mem_clear_val __ret_value, !82
        v1879v1 = const unit ()
        ret () v1879v1
    }

    fn array_repeat_zero_big_bool_14(__ret_value: __ptr [bool; 25]) -> (), !85 {
        entry(__ret_value: __ptr [bool; 25]):
        mem_clear_val __ret_value, !86
        v1886v1 = const unit ()
        ret () v1886v1
    }

    fn small_array_repeat_15(__ret_value: __ptr [bool; 5]) -> (), !89 {
        entry(__ret_value: __ptr [bool; 5]):
        v799v1 = const u64 0
        v800v1 = get_elem_ptr __ret_value, __ptr bool, v799v1, !90
        v114v1 = const bool true
        store v114v1 to v800v1, !90
        v802v1 = const u64 1
        v803v1 = get_elem_ptr __ret_value, __ptr bool, v802v1, !90
        store v114v1 to v803v1, !90
        v805v1 = const u64 2
        v806v1 = get_elem_ptr __ret_value, __ptr bool, v805v1, !90
        store v114v1 to v806v1, !90
        v808v1 = const u64 3
        v809v1 = get_elem_ptr __ret_value, __ptr bool, v808v1, !90
        store v114v1 to v809v1, !90
        v811v1 = const u64 4
        v812v1 = get_elem_ptr __ret_value, __ptr bool, v811v1, !90
        store v114v1 to v812v1, !90
        v1893v1 = const unit ()
        ret () v1893v1
    }

    fn big_array_repeat_16(__ret_value: __ptr [bool; 25]) -> (), !93 {
        entry(__ret_value: __ptr [bool; 25]):
        v815v1 = const u64 0
        br array_init_loop(v815v1)

        array_init_loop(v814v1: u64):
        v817v1 = get_elem_ptr __ret_value, __ptr bool, v814v1
        v122v1 = const bool true
        store v122v1 to v817v1, !94
        v819v1 = const u64 1
        v820v1 = add v814v1, v819v1
        v821v1 = const u64 25
        v822v1 = cmp lt v820v1 v821v1
        cbr v822v1, array_init_loop(v820v1), array_init_loop_exit()

        array_init_loop_exit():
        v1900v1 = const unit ()
        ret () v1900v1
    }

    fn u8_array_bigger_than_18_bits_17(__ret_value: __ptr [u8; 262145]) -> (), !97 {
        entry(__ret_value: __ptr [u8; 262145]):
        mem_clear_val __ret_value, !98
        v1907v1 = const unit ()
        ret () v1907v1
    }

    fn arrays_with_const_length_18() -> (), !101 {
        entry():
        v188v1 = const unit ()
        ret () v188v1
    }

    fn decode_array_19(__ret_value: __ptr [u8; 1]) -> (), !104 {
        local { ptr, u64 } __anon_00
        local [u8; 1] __array_init_0
        local slice __ret_val
        local slice s
        local slice slice_0

        entry(__ret_value: __ptr [u8; 1]):
        v241v1 = get_local __ptr [u8; 1], __array_init_0, !105
        v842v1 = const u64 0
        v843v1 = get_elem_ptr v241v1, __ptr u8, v842v1, !105
        v242v1 = const u8 255, !106
        store v242v1 to v843v1, !105
        v1805v1 = get_local __ptr [u8; 1], __array_init_0
        v1923v1 = get_local __ptr slice, __ret_val
        v1924v1 = call to_slice_20(v1805v1, v1923v1)
        v246v1 = get_local __ptr slice, s, !107
        mem_copy_val v246v1, v1923v1
        v1779v1 = get_local __ptr slice, s, !115
        v1781v1 = get_local __ptr slice, slice_0, !118
        mem_copy_val v1781v1, v1779v1
        v1783v1 = get_local __ptr slice, slice_0, !120
        v1926v1 = asm(ptr: v1783v1) -> __ptr { ptr, u64 } ptr {
        }
        v1962v1 = const u64 0
        v1963v1 = get_elem_ptr v1926v1, __ptr ptr, v1962v1
        v1964v1 = load v1963v1
        v1965v1 = const u64 1
        v1966v1 = get_elem_ptr v1926v1, __ptr u64, v1965v1
        v1967v1 = load v1966v1
        v1785v1 = get_local __ptr { ptr, u64 }, __anon_00, !121
        v1976v1 = const u64 0
        v1977v1 = get_elem_ptr v1785v1, __ptr ptr, v1976v1
        store v1964v1 to v1977v1
        v1979v1 = const u64 1
        v1980v1 = get_elem_ptr v1785v1, __ptr u64, v1979v1
        store v1967v1 to v1980v1
        v280v1 = const u64 0
        v1787v1 = get_elem_ptr v1785v1, __ptr ptr, v280v1, !123
        v1788v1 = load v1787v1, !121
        v260v1 = const u64 1
        v1514v1 = asm(size: v260v1, src: v1788v1) -> __ptr [u8; 1] hp, !125 {
            aloc   size, !126
            mcp    hp src size, !127
        }
        v1982v1 = const u64 0
        v1983v1 = get_elem_ptr v1514v1, __ptr u8, v1982v1
        v1984v1 = load v1983v1
        v1989v1 = const u64 0
        v1990v1 = get_elem_ptr __ret_value, __ptr u8, v1989v1
        store v1984v1 to v1990v1
        v1914v1 = const unit ()
        ret () v1914v1
    }

    fn to_slice_20(array: __ptr [u8; 1], __ret_value: __ptr slice) -> (), !130 {
        local mut slice __aggr_memcpy_0
        local [u8; 1] array_
        local { ptr, u64 } parts_

        entry(array: __ptr [u8; 1], __ret_value: __ptr slice):
        v194v1 = get_local __ptr [u8; 1], array_
        mem_copy_val v194v1, array
        v235v1 = get_local __ptr [u8; 1], array_, !131
        v236v1 = cast_ptr v235v1 to ptr, !132
        v901v1 = get_local __ptr { ptr, u64 }, parts_, !137
        v1998v1 = const u64 0
        v1999v1 = get_elem_ptr v901v1, __ptr ptr, v1998v1
        store v236v1 to v1999v1
        v2001v1 = const u64 1
        v2002v1 = get_elem_ptr v901v1, __ptr u64, v2001v1
        v894v1 = const u64 1, !140
        store v894v1 to v2002v1
        v903v1 = get_local __ptr { ptr, u64 }, parts_, !142
        v1928v1 = asm(ptr: v903v1) -> __ptr slice ptr {
        }
        v1957v1 = get_local __ptr slice, __aggr_memcpy_0
        mem_copy_val v1957v1, v1928v1
        mem_copy_val __ret_value, v1957v1
        v1921v1 = const unit ()
        ret () v1921v1
    }

    pub fn log_46(value !144: u8) -> (), !147 {
        local { __ptr u8, u64 } __anon_0
        local slice __log_arg
        local u8 value_

        entry(value: u8):
        v601v1 = get_local __ptr u8, value_
        store value to v601v1
        v742v1 = get_local __ptr u8, value_, !148
        v1707v1 = get_local __ptr { __ptr u8, u64 }, __anon_0, !150
        v857v1 = const u64 0
        v1710v1 = get_elem_ptr v1707v1, __ptr __ptr u8, v857v1, !151
        store v742v1 to v1710v1, !152
        v860v1 = const u64 1
        v1712v1 = get_elem_ptr v1707v1, __ptr u64, v860v1, !153
        v611v1 = const u64 1
        store v611v1 to v1712v1, !154
        v1715v1 = get_local __ptr { __ptr u8, u64 }, __anon_0, !148
        v1717v1 = cast_ptr v1715v1 to __ptr slice, !148
        v1930v1 = get_local __ptr slice, __log_arg
        mem_copy_val v1930v1, v1717v1
        v744v1 = const u64 14454674236531057292
        log __ptr slice v1930v1, v744v1
        v747v1 = const unit ()
        ret () v747v1
    }
}

!0 = "test/src/e2e_vm_tests/test_programs/should_pass/language/array/array_repeat/src/main.<autogenerated>.sw"
!1 = span !0 0 116
!2 = fn_name_span !0 7 14
!3 = (!1 !2)
!4 = span !0 58 64
!5 = fn_call_path_span !0 58 62
!6 = (!4 !5)
!7 = span !0 97 98
!8 = span !0 100 101
!9 = span !0 82 102
!10 = "test/src/e2e_vm_tests/test_programs/should_pass/language/array/array_repeat/src/main.sw"
!11 = span !10 2198 3051
!12 = fn_name_span !10 2201 2205
!13 = (!11 !12)
!14 = span !10 2928 2954
!15 = fn_call_path_span !10 2928 2952
!16 = (!14 !15)
!17 = span !10 3032 3037
!18 = span !10 3038 3039
!19 = span !10 3032 3040
!20 = span !10 3042 3047
!21 = span !10 3022 3048
!22 = fn_call_path_span !10 3022 3031
!23 = "test/src/e2e_vm_tests/reduced_std_libs/sway-lib-std-assert/src/assert.sw"
!24 = span !23 1863 1871
!25 = fn_call_path_span !23 1866 1868
!26 = "test/src/e2e_vm_tests/reduced_std_libs/sway-lib-std-assert/src/ops.sw"
!27 = span !26 15555 15569
!28 = fn_call_path_span !26 15560 15562
!29 = (!21 !22 !24 !25 !27 !28)
!30 = span !26 12573 12578
!31 = span !26 15554 15576
!32 = fn_call_path_span !26 15571 15574
!33 = (!21 !22 !24 !25 !31 !32)
!34 = (!21 !22 !24)
!35 = span !23 1883 1890
!36 = fn_call_path_span !23 1883 1886
!37 = (!21 !22 !35 !36)
!38 = span !23 1900 1907
!39 = fn_call_path_span !23 1900 1903
!40 = (!21 !22 !38 !39)
!41 = span !23 1917 1948
!42 = fn_call_path_span !23 1917 1923
!43 = "test/src/e2e_vm_tests/reduced_std_libs/sway-lib-std-assert/src/revert.sw"
!44 = span !43 757 771
!45 = (!21 !22 !41 !42 !44)
!46 = span !10 58 117
!47 = fn_name_span !10 61 87
!48 = inline "never"
!49 = (!46 !47 !48)
!50 = span !10 107 115
!51 = span !10 220 282
!52 = fn_name_span !10 223 250
!53 = (!51 !52 !48)
!54 = span !10 271 280
!55 = span !10 725 855
!56 = fn_name_span !10 728 756
!57 = (!55 !56 !48)
!58 = span !10 778 853
!59 = span !10 1030 1156
!60 = fn_name_span !10 1033 1061
!61 = (!59 !60 !48)
!62 = span !10 1083 1154
!63 = span !10 1327 1392
!64 = fn_name_span !10 1330 1358
!65 = (!63 !64 !48)
!66 = span !10 1380 1390
!67 = span !10 135 194
!68 = fn_name_span !10 138 162
!69 = (!67 !68 !48)
!70 = span !10 183 192
!71 = span !10 468 530
!72 = fn_name_span !10 471 496
!73 = (!71 !72 !48)
!74 = span !10 518 528
!75 = span !10 873 1003
!76 = fn_name_span !10 876 902
!77 = (!75 !76 !48)
!78 = span !10 925 1001
!79 = span !10 1174 1300
!80 = fn_name_span !10 1177 1203
!81 = (!79 !80 !48)
!82 = span !10 1226 1298
!83 = span !10 1410 1475
!84 = fn_name_span !10 1413 1439
!85 = (!83 !84 !48)
!86 = span !10 1462 1473
!87 = span !10 1536 1590
!88 = fn_name_span !10 1539 1557
!89 = (!87 !88 !48)
!90 = span !10 1579 1588
!91 = span !10 1633 1687
!92 = fn_name_span !10 1636 1652
!93 = (!91 !92 !48)
!94 = span !10 1675 1685
!95 = span !10 1781 1852
!96 = fn_name_span !10 1784 1812
!97 = (!95 !96 !48)
!98 = span !10 1837 1850
!99 = span !10 1947 2196
!100 = fn_name_span !10 1950 1974
!101 = (!99 !100 !48)
!102 = span !10 3070 3173
!103 = fn_name_span !10 3073 3085
!104 = (!102 !103 !48)
!105 = span !10 3133 3140
!106 = span !10 3134 3139
!107 = span !10 3105 3142
!108 = span !10 3147 3171
!109 = fn_call_path_span !10 3147 3157
!110 = "test/src/e2e_vm_tests/reduced_std_libs/sway-lib-std-assert/src/codec.sw"
!111 = span !110 94607 94617
!112 = fn_call_path_span !110 94612 94615
!113 = "test/src/e2e_vm_tests/reduced_std_libs/sway-lib-std-assert/src/raw_slice.sw"
!114 = span !113 2922 2926
!115 = (!108 !109 !111 !112 !114)
!116 = span !113 2911 2927
!117 = fn_call_path_span !113 2911 2921
!118 = (!108 !109 !111 !112 !116 !117)
!119 = span !113 1633 1638
!120 = (!108 !109 !111 !112 !116 !117 !119)
!121 = (!108 !109 !111 !112)
!122 = span !113 2928 2929
!123 = (!108 !109 !111 !112 !122)
!124 = span !110 94586 94701
!125 = (!108 !109 !124)
!126 = span !110 94633 94642
!127 = span !110 94656 94671
!128 = span !10 3192 3320
!129 = fn_name_span !10 3195 3203
!130 = (!128 !129 !48)
!131 = span !10 3306 3311
!132 = span !10 3296 3312
!133 = span !10 3268 3318
!134 = fn_call_path_span !10 3268 3289
!135 = span !113 2351 2394
!136 = fn_call_path_span !113 2351 2361
!137 = (!133 !134 !135 !136)
!138 = span !113 2368 2392
!139 = fn_call_path_span !113 2374 2375
!140 = (!133 !134 !138 !139)
!141 = span !113 1257 1262
!142 = (!133 !134 !135 !136 !141)
!143 = "test/src/e2e_vm_tests/reduced_std_libs/sway-lib-std-assert/src/logging.sw"
!144 = span !143 591 596
!145 = span !143 577 651
!146 = fn_name_span !143 584 587
!147 = (!145 !146)
!148 = span !143 642 647
!149 = span !110 93769 93781
!150 = (!148 !149)
!151 = (!148 !149)
!152 = (!148 !149)
!153 = (!148 !149)
!154 = (!148 !149)

DIFF------------------------------
.program:
DIFF------------------------------
.program:
DIFF------------------------------
.program:
.0                                      ; --- start of function: __entry ---
move $$locbase $sp                      ; [entry init: __entry]: set locals base register
cfei i0                                 ; [entry init: __entry]: allocate: locals 0 byte(s), call args 0 slot(s)
.38
fncall .2                               ; [call: main_0]: call function
 move $r1 $zero                          ; [call: main_0]: copy returned unit value
 movi $r1 i0                             ; [call: main_0]: copy returned unit value
retd $zero $zero                        ; [entry end: __entry] return slice
DIFF------------------------------
.program:
.0                                      ; --- start of function: __entry ---
move $$locbase $sp                      ; [entry init: __entry]: set locals base register
cfei i0                                 ; [entry init: __entry]: allocate: locals 0 byte(s), call args 0 slot(s)
.38
fncall .2                               ; [call: main_0]: call function
retd $zero $zero                        ; [entry end: __entry] return slice
DIFF------------------------------
.program:
.0                                      ; --- start of function: __entry ---
move $$locbase $sp                      ; [entry init: __entry]: set locals base register
cfei i0                                 ; [entry init: __entry]: allocate: locals 0 byte(s), call args 0 slot(s)
.38
fncall .2                               ; [call: main_0]: call function
retd $zero $zero                        ; [entry end: __entry] return slice
DIFF------------------------------
.program:
.0                                      ; --- start of function: __entry ---
move $$locbase $sp                      ; [entry init: __entry]: set locals base register
cfei i0                                 ; [entry init: __entry]: allocate: locals 0 byte(s), call args 0 slot(s)
.38
fncall .2                               ; [call: main_0]: call function
retd $zero $zero                        ; [entry end: __entry] return slice
DIFF------------------------------
.program:
.2                                      ; --- start of function: main_0 ---
pusha .2                                ; [fn init: main_0]: push all used registers to stack
move $$locbase $sp                      ; [fn init: main_0]: set locals base register
cfei i264920                            ; [fn init: main_0]: allocate: locals 264920 byte(s), call args 0 slot(s)
move $r2 $$reta                         ; [fn init: main_0]: save return address
.39
move $$arg0 $$locbase                   ; [call: array_repeat_zero_small_u8_1]: pass argument 0
fncall .4                               ; [call: array_repeat_zero_small_u8_1]: call function
 move $r3 $zero                          ; [call: array_repeat_zero_small_u8_1]: copy returned unit value
 movi $r3 i0                             ; [call: array_repeat_zero_small_u8_1]: copy returned unit value
addi $r4 $$locbase i8                   ; get offset to local __ptr [u64; 5]
move $$arg0 $r4                         ; [call: array_repeat_zero_small_u16_2]: pass argument 0
fncall .6                               ; [call: array_repeat_zero_small_u16_2]: call function
 move $r5 $zero                          ; [call: array_repeat_zero_small_u16_2]: copy returned unit value
 movi $r5 i0                             ; [call: array_repeat_zero_small_u16_2]: copy returned unit value
addi $r6 $$locbase i48                  ; get offset to local __ptr [u64; 5]
move $$arg0 $r6                         ; [call: array_repeat_zero_small_u16_2]: pass argument 0
fncall .6                               ; [call: array_repeat_zero_small_u16_2]: call function
 move $r7 $zero                          ; [call: array_repeat_zero_small_u16_2]: copy returned unit value
 movi $r7 i0                             ; [call: array_repeat_zero_small_u16_2]: copy returned unit value
movi $r8 i32989                         ; get word offset to local from base
muli $r8 $r8 i8                         ; get byte offset to local from base
add $r8 $$locbase $r8                   ; get absolute byte offset to local
move $$arg0 $r8                         ; [call: array_repeat_zero_small_u16_2]: pass argument 0
fncall .6                               ; [call: array_repeat_zero_small_u16_2]: call function
 move $r9 $zero                          ; [call: array_repeat_zero_small_u16_2]: copy returned unit value
 movi $r9 i0                             ; [call: array_repeat_zero_small_u16_2]: copy returned unit value
movi $r10 i32994                        ; get word offset to local from base
muli $r10 $r10 i8                       ; get byte offset to local from base
add $r10 $$locbase $r10                 ; get absolute byte offset to local
move $$arg0 $r10                        ; [call: array_repeat_zero_small_u256_5]: pass argument 0
fncall .8                               ; [call: array_repeat_zero_small_u256_5]: call function
 move $r11 $zero                         ; [call: array_repeat_zero_small_u256_5]: copy returned unit value
 movi $r11 i0                            ; [call: array_repeat_zero_small_u256_5]: copy returned unit value
movi $r12 i33014                        ; get word offset to local from base
muli $r12 $r12 i8                       ; get byte offset to local from base
add $r12 $$locbase $r12                 ; get absolute byte offset to local
move $$arg0 $r12                        ; [call: array_repeat_zero_small_b256_6]: pass argument 0
fncall .10                              ; [call: array_repeat_zero_small_b256_6]: call function
 move $r13 $zero                         ; [call: array_repeat_zero_small_b256_6]: copy returned unit value
 movi $r13 i0                            ; [call: array_repeat_zero_small_b256_6]: copy returned unit value
movi $r14 i33034                        ; get word offset to local from base
muli $r14 $r14 i8                       ; get byte offset to local from base
add $r14 $$locbase $r14                 ; get absolute byte offset to local
move $$arg0 $r14                        ; [call: array_repeat_zero_small_bool_7]: pass argument 0
fncall .12                              ; [call: array_repeat_zero_small_bool_7]: call function
 move $r15 $zero                         ; [call: array_repeat_zero_small_bool_7]: copy returned unit value
 movi $r15 i0                            ; [call: array_repeat_zero_small_bool_7]: copy returned unit value
movi $r16 i33035                        ; get word offset to local from base
muli $r16 $r16 i8                       ; get byte offset to local from base
add $r16 $$locbase $r16                 ; get absolute byte offset to local
move $$arg0 $r16                        ; [call: array_repeat_zero_big_u8_8]: pass argument 0
fncall .14                              ; [call: array_repeat_zero_big_u8_8]: call function
 move $r17 $zero                         ; [call: array_repeat_zero_big_u8_8]: copy returned unit value
 movi $r17 i0                            ; [call: array_repeat_zero_big_u8_8]: copy returned unit value
movi $r18 i33039                        ; get word offset to local from base
muli $r18 $r18 i8                       ; get byte offset to local from base
add $r18 $$locbase $r18                 ; get absolute byte offset to local
move $$arg0 $r18                        ; [call: array_repeat_zero_big_u32_10]: pass argument 0
fncall .16                              ; [call: array_repeat_zero_big_u32_10]: call function
 move $r19 $zero                         ; [call: array_repeat_zero_big_u32_10]: copy returned unit value
 movi $r19 i0                            ; [call: array_repeat_zero_big_u32_10]: copy returned unit value
movi $r20 i33064                        ; get word offset to local from base
muli $r20 $r20 i8                       ; get byte offset to local from base
add $r20 $$locbase $r20                 ; get absolute byte offset to local
move $$arg0 $r20                        ; [call: array_repeat_zero_big_u32_10]: pass argument 0
fncall .16                              ; [call: array_repeat_zero_big_u32_10]: call function
 move $r21 $zero                         ; [call: array_repeat_zero_big_u32_10]: copy returned unit value
 movi $r21 i0                            ; [call: array_repeat_zero_big_u32_10]: copy returned unit value
movi $r22 i33089                        ; get word offset to local from base
muli $r22 $r22 i8                       ; get byte offset to local from base
add $r22 $$locbase $r22                 ; get absolute byte offset to local
move $$arg0 $r22                        ; [call: array_repeat_zero_big_u32_10]: pass argument 0
fncall .16                              ; [call: array_repeat_zero_big_u32_10]: call function
 move $r23 $zero                         ; [call: array_repeat_zero_big_u32_10]: copy returned unit value
 movi $r23 i0                            ; [call: array_repeat_zero_big_u32_10]: copy returned unit value
addi $r24 $$locbase i88                 ; get offset to local __ptr [u256; 25]
move $$arg0 $r24                        ; [call: array_repeat_zero_big_u256_12]: pass argument 0
fncall .18                              ; [call: array_repeat_zero_big_u256_12]: call function
 move $r25 $zero                         ; [call: array_repeat_zero_big_u256_12]: copy returned unit value
 movi $r25 i0                            ; [call: array_repeat_zero_big_u256_12]: copy returned unit value
addi $r26 $$locbase i888                ; get offset to local __ptr [b256; 25]
move $$arg0 $r26                        ; [call: array_repeat_zero_big_b256_13]: pass argument 0
fncall .20                              ; [call: array_repeat_zero_big_b256_13]: call function
 move $r27 $zero                         ; [call: array_repeat_zero_big_b256_13]: copy returned unit value
 movi $r27 i0                            ; [call: array_repeat_zero_big_b256_13]: copy returned unit value
addi $r28 $$locbase i1688               ; get offset to local __ptr [bool; 25]
move $$arg0 $r28                        ; [call: array_repeat_zero_big_bool_14]: pass argument 0
fncall .22                              ; [call: array_repeat_zero_big_bool_14]: call function
 move $r29 $zero                         ; [call: array_repeat_zero_big_bool_14]: copy returned unit value
 movi $r29 i0                            ; [call: array_repeat_zero_big_bool_14]: copy returned unit value
addi $r30 $$locbase i1720               ; get offset to local __ptr [bool; 5]
move $$arg0 $r30                        ; [call: small_array_repeat_15]: pass argument 0
fncall .24                              ; [call: small_array_repeat_15]: call function
 move $r31 $zero                         ; [call: small_array_repeat_15]: copy returned unit value
 movi $r31 i0                            ; [call: small_array_repeat_15]: copy returned unit value
addi $r32 $$locbase i1728               ; get offset to local __ptr [bool; 25]
move $$arg0 $r32                        ; [call: big_array_repeat_16]: pass argument 0
fncall .26                              ; [call: big_array_repeat_16]: call function
 move $r33 $zero                         ; [call: big_array_repeat_16]: copy returned unit value
 movi $r33 i0                            ; [call: big_array_repeat_16]: copy returned unit value
addi $r34 $$locbase i1760               ; get offset to local __ptr [u8; 262145]
move $$arg0 $r34                        ; [call: u8_array_bigger_than_18_bits_17]: pass argument 0
fncall .28                              ; [call: u8_array_bigger_than_18_bits_17]: call function
 move $r35 $zero                         ; [call: u8_array_bigger_than_18_bits_17]: copy returned unit value
 movi $r35 i0                            ; [call: u8_array_bigger_than_18_bits_17]: copy returned unit value
fncall .30                              ; [call: arrays_with_const_length_18]: call function
 move $r36 $zero                         ; [call: arrays_with_const_length_18]: copy returned unit value
 movi $r36 i0                            ; [call: arrays_with_const_length_18]: copy returned unit value
movi $r37 i33114                        ; get word offset to local from base
muli $r37 $r37 i8                       ; get byte offset to local from base
add $r37 $$locbase $r37                 ; get absolute byte offset to local
move $$arg0 $r37                        ; [call: decode_array_19]: pass argument 0
fncall .32                              ; [call: decode_array_19]: call function
 move $r38 $zero                         ; [call: decode_array_19]: copy returned unit value
 movi $r38 i0                            ; [call: decode_array_19]: copy returned unit value
movi $r39 i33114                        ; get word offset to local from base
muli $r39 $r39 i8                       ; get byte offset to local from base
add $r39 $$locbase $r39                 ; get absolute byte offset to local
movi $r40 i1                            ; get array element size
 mul $r41 $zero $r40                     ; get offset to array element
 add $r41 $r39 $r41                      ; add array element offset to array base
 lb $r42 $r41 i0                         ; load byte
 movi $r41 i0                            ; get offset to array element
 move $r41 $r39                          ; add array element offset to array base
 lb $r42 $r39 i0                         ; load byte
movi $r43 i255                          ; initialize constant into register
eq $r44 $r42 $r43
eq $r45 $r44 $zero
jnzi $r45 .40
ji  .41
.41
ji  .3
.40
move $$arg0 $r42                        ; [call: log_46]: pass argument 0
fncall .36                              ; [call: log_46]: call function
 move $r46 $zero                         ; [call: log_46]: copy returned unit value
 movi $r46 i0                            ; [call: log_46]: copy returned unit value
movi $r47 i255                          ; initialize constant into register
 move $$arg0 $r47                        ; [call: log_46]: pass argument 0
 movi $$arg0 i255                        ; [call: log_46]: pass argument 0
fncall .36                              ; [call: log_46]: call function
 move $r48 $zero                         ; [call: log_46]: copy returned unit value
 movi $r48 i0                            ; [call: log_46]: copy returned unit value
load $r49 data_NonConfigurable_0        ; load constant from data section
rvrt $r49
.3
cfsi i264920                            ; [fn end: main_0] free: locals 264920 byte(s), call args 0 slot(s)
move $$reta $r2                         ; [fn end: main_0] restore return address
popa .2                                 ; [fn end: main_0] restore all used registers
jal $zero $$reta i0                     ; [fn end: main_0] return from call
DIFF------------------------------
.program:
.2                                      ; --- start of function: main_0 ---
pusha .2                                ; [fn init: main_0]: push all used registers to stack
move $$locbase $sp                      ; [fn init: main_0]: set locals base register
cfei i264920                            ; [fn init: main_0]: allocate: locals 264920 byte(s), call args 0 slot(s)
move $r2 $$reta                         ; [fn init: main_0]: save return address
.39
move $$arg0 $$locbase                   ; [call: array_repeat_zero_small_u8_1]: pass argument 0
fncall .4                               ; [call: array_repeat_zero_small_u8_1]: call function
addi $r4 $$locbase i8                   ; get offset to local __ptr [u64; 5]
move $$arg0 $r4                         ; [call: array_repeat_zero_small_u16_2]: pass argument 0
fncall .6                               ; [call: array_repeat_zero_small_u16_2]: call function
addi $r6 $$locbase i48                  ; get offset to local __ptr [u64; 5]
move $$arg0 $r6                         ; [call: array_repeat_zero_small_u16_2]: pass argument 0
fncall .6                               ; [call: array_repeat_zero_small_u16_2]: call function
movi $r8 i32989                         ; get word offset to local from base
muli $r8 $r8 i8                         ; get byte offset to local from base
add $r8 $$locbase $r8                   ; get absolute byte offset to local
move $$arg0 $r8                         ; [call: array_repeat_zero_small_u16_2]: pass argument 0
fncall .6                               ; [call: array_repeat_zero_small_u16_2]: call function
movi $r10 i32994                        ; get word offset to local from base
muli $r10 $r10 i8                       ; get byte offset to local from base
add $r10 $$locbase $r10                 ; get absolute byte offset to local
move $$arg0 $r10                        ; [call: array_repeat_zero_small_u256_5]: pass argument 0
fncall .8                               ; [call: array_repeat_zero_small_u256_5]: call function
movi $r12 i33014                        ; get word offset to local from base
muli $r12 $r12 i8                       ; get byte offset to local from base
add $r12 $$locbase $r12                 ; get absolute byte offset to local
move $$arg0 $r12                        ; [call: array_repeat_zero_small_b256_6]: pass argument 0
fncall .10                              ; [call: array_repeat_zero_small_b256_6]: call function
movi $r14 i33034                        ; get word offset to local from base
muli $r14 $r14 i8                       ; get byte offset to local from base
add $r14 $$locbase $r14                 ; get absolute byte offset to local
move $$arg0 $r14                        ; [call: array_repeat_zero_small_bool_7]: pass argument 0
fncall .12                              ; [call: array_repeat_zero_small_bool_7]: call function
movi $r16 i33035                        ; get word offset to local from base
muli $r16 $r16 i8                       ; get byte offset to local from base
add $r16 $$locbase $r16                 ; get absolute byte offset to local
move $$arg0 $r16                        ; [call: array_repeat_zero_big_u8_8]: pass argument 0
fncall .14                              ; [call: array_repeat_zero_big_u8_8]: call function
movi $r18 i33039                        ; get word offset to local from base
muli $r18 $r18 i8                       ; get byte offset to local from base
add $r18 $$locbase $r18                 ; get absolute byte offset to local
move $$arg0 $r18                        ; [call: array_repeat_zero_big_u32_10]: pass argument 0
fncall .16                              ; [call: array_repeat_zero_big_u32_10]: call function
movi $r20 i33064                        ; get word offset to local from base
muli $r20 $r20 i8                       ; get byte offset to local from base
add $r20 $$locbase $r20                 ; get absolute byte offset to local
move $$arg0 $r20                        ; [call: array_repeat_zero_big_u32_10]: pass argument 0
fncall .16                              ; [call: array_repeat_zero_big_u32_10]: call function
movi $r22 i33089                        ; get word offset to local from base
muli $r22 $r22 i8                       ; get byte offset to local from base
add $r22 $$locbase $r22                 ; get absolute byte offset to local
move $$arg0 $r22                        ; [call: array_repeat_zero_big_u32_10]: pass argument 0
fncall .16                              ; [call: array_repeat_zero_big_u32_10]: call function
addi $r24 $$locbase i88                 ; get offset to local __ptr [u256; 25]
move $$arg0 $r24                        ; [call: array_repeat_zero_big_u256_12]: pass argument 0
fncall .18                              ; [call: array_repeat_zero_big_u256_12]: call function
addi $r26 $$locbase i888                ; get offset to local __ptr [b256; 25]
move $$arg0 $r26                        ; [call: array_repeat_zero_big_b256_13]: pass argument 0
fncall .20                              ; [call: array_repeat_zero_big_b256_13]: call function
addi $r28 $$locbase i1688               ; get offset to local __ptr [bool; 25]
move $$arg0 $r28                        ; [call: array_repeat_zero_big_bool_14]: pass argument 0
fncall .22                              ; [call: array_repeat_zero_big_bool_14]: call function
addi $r30 $$locbase i1720               ; get offset to local __ptr [bool; 5]
move $$arg0 $r30                        ; [call: small_array_repeat_15]: pass argument 0
fncall .24                              ; [call: small_array_repeat_15]: call function
addi $r32 $$locbase i1728               ; get offset to local __ptr [bool; 25]
move $$arg0 $r32                        ; [call: big_array_repeat_16]: pass argument 0
fncall .26                              ; [call: big_array_repeat_16]: call function
addi $r34 $$locbase i1760               ; get offset to local __ptr [u8; 262145]
move $$arg0 $r34                        ; [call: u8_array_bigger_than_18_bits_17]: pass argument 0
fncall .28                              ; [call: u8_array_bigger_than_18_bits_17]: call function
fncall .30                              ; [call: arrays_with_const_length_18]: call function
movi $r37 i33114                        ; get word offset to local from base
muli $r37 $r37 i8                       ; get byte offset to local from base
add $r37 $$locbase $r37                 ; get absolute byte offset to local
move $$arg0 $r37                        ; [call: decode_array_19]: pass argument 0
fncall .32                              ; [call: decode_array_19]: call function
movi $r39 i33114                        ; get word offset to local from base
muli $r39 $r39 i8                       ; get byte offset to local from base
add $r39 $$locbase $r39                 ; get absolute byte offset to local
lb $r42 $r39 i0                         ; load byte
movi $r43 i255                          ; initialize constant into register
eq $r44 $r42 $r43
eq $r45 $r44 $zero
jnzi $r45 .40
.41
ji  .3
.40
move $$arg0 $r42                        ; [call: log_46]: pass argument 0
fncall .36                              ; [call: log_46]: call function
movi $$arg0 i255                        ; [call: log_46]: pass argument 0
fncall .36                              ; [call: log_46]: call function
load $r49 data_NonConfigurable_0        ; load constant from data section
rvrt $r49
.3
cfsi i264920                            ; [fn end: main_0] free: locals 264920 byte(s), call args 0 slot(s)
move $$reta $r2                         ; [fn end: main_0] restore return address
popa .2                                 ; [fn end: main_0] restore all used registers
jal $zero $$reta i0                     ; [fn end: main_0] return from call
DIFF------------------------------
.program:
.2                                      ; --- start of function: main_0 ---
pusha .2                                ; [fn init: main_0]: push all used registers to stack
move $$locbase $sp                      ; [fn init: main_0]: set locals base register
cfei i264920                            ; [fn init: main_0]: allocate: locals 264920 byte(s), call args 0 slot(s)
move $r2 $$reta                         ; [fn init: main_0]: save return address
.39
move $$arg0 $$locbase                   ; [call: array_repeat_zero_small_u8_1]: pass argument 0
fncall .4                               ; [call: array_repeat_zero_small_u8_1]: call function
addi $r4 $$locbase i8                   ; get offset to local __ptr [u64; 5]
move $$arg0 $r4                         ; [call: array_repeat_zero_small_u16_2]: pass argument 0
fncall .6                               ; [call: array_repeat_zero_small_u16_2]: call function
addi $r6 $$locbase i48                  ; get offset to local __ptr [u64; 5]
move $$arg0 $r6                         ; [call: array_repeat_zero_small_u16_2]: pass argument 0
fncall .6                               ; [call: array_repeat_zero_small_u16_2]: call function
movi $r8 i32989                         ; get word offset to local from base
muli $r8 $r8 i8                         ; get byte offset to local from base
add $r8 $$locbase $r8                   ; get absolute byte offset to local
move $$arg0 $r8                         ; [call: array_repeat_zero_small_u16_2]: pass argument 0
fncall .6                               ; [call: array_repeat_zero_small_u16_2]: call function
movi $r10 i32994                        ; get word offset to local from base
muli $r10 $r10 i8                       ; get byte offset to local from base
add $r10 $$locbase $r10                 ; get absolute byte offset to local
move $$arg0 $r10                        ; [call: array_repeat_zero_small_u256_5]: pass argument 0
fncall .8                               ; [call: array_repeat_zero_small_u256_5]: call function
movi $r12 i33014                        ; get word offset to local from base
muli $r12 $r12 i8                       ; get byte offset to local from base
add $r12 $$locbase $r12                 ; get absolute byte offset to local
move $$arg0 $r12                        ; [call: array_repeat_zero_small_b256_6]: pass argument 0
fncall .10                              ; [call: array_repeat_zero_small_b256_6]: call function
movi $r14 i33034                        ; get word offset to local from base
muli $r14 $r14 i8                       ; get byte offset to local from base
add $r14 $$locbase $r14                 ; get absolute byte offset to local
move $$arg0 $r14                        ; [call: array_repeat_zero_small_bool_7]: pass argument 0
fncall .12                              ; [call: array_repeat_zero_small_bool_7]: call function
movi $r16 i33035                        ; get word offset to local from base
muli $r16 $r16 i8                       ; get byte offset to local from base
add $r16 $$locbase $r16                 ; get absolute byte offset to local
move $$arg0 $r16                        ; [call: array_repeat_zero_big_u8_8]: pass argument 0
fncall .14                              ; [call: array_repeat_zero_big_u8_8]: call function
movi $r18 i33039                        ; get word offset to local from base
muli $r18 $r18 i8                       ; get byte offset to local from base
add $r18 $$locbase $r18                 ; get absolute byte offset to local
move $$arg0 $r18                        ; [call: array_repeat_zero_big_u32_10]: pass argument 0
fncall .16                              ; [call: array_repeat_zero_big_u32_10]: call function
movi $r20 i33064                        ; get word offset to local from base
muli $r20 $r20 i8                       ; get byte offset to local from base
add $r20 $$locbase $r20                 ; get absolute byte offset to local
move $$arg0 $r20                        ; [call: array_repeat_zero_big_u32_10]: pass argument 0
fncall .16                              ; [call: array_repeat_zero_big_u32_10]: call function
movi $r22 i33089                        ; get word offset to local from base
muli $r22 $r22 i8                       ; get byte offset to local from base
add $r22 $$locbase $r22                 ; get absolute byte offset to local
move $$arg0 $r22                        ; [call: array_repeat_zero_big_u32_10]: pass argument 0
fncall .16                              ; [call: array_repeat_zero_big_u32_10]: call function
addi $r24 $$locbase i88                 ; get offset to local __ptr [u256; 25]
move $$arg0 $r24                        ; [call: array_repeat_zero_big_u256_12]: pass argument 0
fncall .18                              ; [call: array_repeat_zero_big_u256_12]: call function
addi $r26 $$locbase i888                ; get offset to local __ptr [b256; 25]
move $$arg0 $r26                        ; [call: array_repeat_zero_big_b256_13]: pass argument 0
fncall .20                              ; [call: array_repeat_zero_big_b256_13]: call function
addi $r28 $$locbase i1688               ; get offset to local __ptr [bool; 25]
move $$arg0 $r28                        ; [call: array_repeat_zero_big_bool_14]: pass argument 0
fncall .22                              ; [call: array_repeat_zero_big_bool_14]: call function
addi $r30 $$locbase i1720               ; get offset to local __ptr [bool; 5]
move $$arg0 $r30                        ; [call: small_array_repeat_15]: pass argument 0
fncall .24                              ; [call: small_array_repeat_15]: call function
addi $r32 $$locbase i1728               ; get offset to local __ptr [bool; 25]
move $$arg0 $r32                        ; [call: big_array_repeat_16]: pass argument 0
fncall .26                              ; [call: big_array_repeat_16]: call function
addi $r34 $$locbase i1760               ; get offset to local __ptr [u8; 262145]
move $$arg0 $r34                        ; [call: u8_array_bigger_than_18_bits_17]: pass argument 0
fncall .28                              ; [call: u8_array_bigger_than_18_bits_17]: call function
fncall .30                              ; [call: arrays_with_const_length_18]: call function
movi $r37 i33114                        ; get word offset to local from base
muli $r37 $r37 i8                       ; get byte offset to local from base
add $r37 $$locbase $r37                 ; get absolute byte offset to local
move $$arg0 $r37                        ; [call: decode_array_19]: pass argument 0
fncall .32                              ; [call: decode_array_19]: call function
movi $r39 i33114                        ; get word offset to local from base
muli $r39 $r39 i8                       ; get byte offset to local from base
add $r39 $$locbase $r39                 ; get absolute byte offset to local
lb $r42 $r39 i0                         ; load byte
movi $r43 i255                          ; initialize constant into register
eq $r44 $r42 $r43
eq $r45 $r44 $zero
jnzi $r45 .40
.41
ji  .3
.40
move $$arg0 $r42                        ; [call: log_46]: pass argument 0
fncall .36                              ; [call: log_46]: call function
movi $$arg0 i255                        ; [call: log_46]: pass argument 0
fncall .36                              ; [call: log_46]: call function
load $r49 data_NonConfigurable_0        ; load constant from data section
rvrt $r49
.3
cfsi i264920                            ; [fn end: main_0] free: locals 264920 byte(s), call args 0 slot(s)
move $$reta $r2                         ; [fn end: main_0] restore return address
popa .2                                 ; [fn end: main_0] restore all used registers
jal $zero $$reta i0                     ; [fn end: main_0] return from call
DIFF------------------------------
.program:
.2                                      ; --- start of function: main_0 ---
pusha .2                                ; [fn init: main_0]: push all used registers to stack
move $$locbase $sp                      ; [fn init: main_0]: set locals base register
cfei i264920                            ; [fn init: main_0]: allocate: locals 264920 byte(s), call args 0 slot(s)
move $r2 $$reta                         ; [fn init: main_0]: save return address
.39
move $$arg0 $$locbase                   ; [call: array_repeat_zero_small_u8_1]: pass argument 0
fncall .4                               ; [call: array_repeat_zero_small_u8_1]: call function
addi $r4 $$locbase i8                   ; get offset to local __ptr [u64; 5]
move $$arg0 $r4                         ; [call: array_repeat_zero_small_u16_2]: pass argument 0
fncall .6                               ; [call: array_repeat_zero_small_u16_2]: call function
addi $r6 $$locbase i48                  ; get offset to local __ptr [u64; 5]
move $$arg0 $r6                         ; [call: array_repeat_zero_small_u16_2]: pass argument 0
fncall .6                               ; [call: array_repeat_zero_small_u16_2]: call function
movi $r8 i32989                         ; get word offset to local from base
muli $r8 $r8 i8                         ; get byte offset to local from base
add $r8 $$locbase $r8                   ; get absolute byte offset to local
move $$arg0 $r8                         ; [call: array_repeat_zero_small_u16_2]: pass argument 0
fncall .6                               ; [call: array_repeat_zero_small_u16_2]: call function
movi $r10 i32994                        ; get word offset to local from base
muli $r10 $r10 i8                       ; get byte offset to local from base
add $r10 $$locbase $r10                 ; get absolute byte offset to local
move $$arg0 $r10                        ; [call: array_repeat_zero_small_u256_5]: pass argument 0
fncall .8                               ; [call: array_repeat_zero_small_u256_5]: call function
movi $r12 i33014                        ; get word offset to local from base
muli $r12 $r12 i8                       ; get byte offset to local from base
add $r12 $$locbase $r12                 ; get absolute byte offset to local
move $$arg0 $r12                        ; [call: array_repeat_zero_small_b256_6]: pass argument 0
fncall .10                              ; [call: array_repeat_zero_small_b256_6]: call function
movi $r14 i33034                        ; get word offset to local from base
muli $r14 $r14 i8                       ; get byte offset to local from base
add $r14 $$locbase $r14                 ; get absolute byte offset to local
move $$arg0 $r14                        ; [call: array_repeat_zero_small_bool_7]: pass argument 0
fncall .12                              ; [call: array_repeat_zero_small_bool_7]: call function
movi $r16 i33035                        ; get word offset to local from base
muli $r16 $r16 i8                       ; get byte offset to local from base
add $r16 $$locbase $r16                 ; get absolute byte offset to local
move $$arg0 $r16                        ; [call: array_repeat_zero_big_u8_8]: pass argument 0
fncall .14                              ; [call: array_repeat_zero_big_u8_8]: call function
movi $r18 i33039                        ; get word offset to local from base
muli $r18 $r18 i8                       ; get byte offset to local from base
add $r18 $$locbase $r18                 ; get absolute byte offset to local
move $$arg0 $r18                        ; [call: array_repeat_zero_big_u32_10]: pass argument 0
fncall .16                              ; [call: array_repeat_zero_big_u32_10]: call function
movi $r20 i33064                        ; get word offset to local from base
muli $r20 $r20 i8                       ; get byte offset to local from base
add $r20 $$locbase $r20                 ; get absolute byte offset to local
move $$arg0 $r20                        ; [call: array_repeat_zero_big_u32_10]: pass argument 0
fncall .16                              ; [call: array_repeat_zero_big_u32_10]: call function
movi $r22 i33089                        ; get word offset to local from base
muli $r22 $r22 i8                       ; get byte offset to local from base
add $r22 $$locbase $r22                 ; get absolute byte offset to local
move $$arg0 $r22                        ; [call: array_repeat_zero_big_u32_10]: pass argument 0
fncall .16                              ; [call: array_repeat_zero_big_u32_10]: call function
addi $r24 $$locbase i88                 ; get offset to local __ptr [u256; 25]
move $$arg0 $r24                        ; [call: array_repeat_zero_big_u256_12]: pass argument 0
fncall .18                              ; [call: array_repeat_zero_big_u256_12]: call function
addi $r26 $$locbase i888                ; get offset to local __ptr [b256; 25]
move $$arg0 $r26                        ; [call: array_repeat_zero_big_b256_13]: pass argument 0
fncall .20                              ; [call: array_repeat_zero_big_b256_13]: call function
addi $r28 $$locbase i1688               ; get offset to local __ptr [bool; 25]
move $$arg0 $r28                        ; [call: array_repeat_zero_big_bool_14]: pass argument 0
fncall .22                              ; [call: array_repeat_zero_big_bool_14]: call function
addi $r30 $$locbase i1720               ; get offset to local __ptr [bool; 5]
move $$arg0 $r30                        ; [call: small_array_repeat_15]: pass argument 0
fncall .24                              ; [call: small_array_repeat_15]: call function
addi $r32 $$locbase i1728               ; get offset to local __ptr [bool; 25]
move $$arg0 $r32                        ; [call: big_array_repeat_16]: pass argument 0
fncall .26                              ; [call: big_array_repeat_16]: call function
addi $r34 $$locbase i1760               ; get offset to local __ptr [u8; 262145]
move $$arg0 $r34                        ; [call: u8_array_bigger_than_18_bits_17]: pass argument 0
fncall .28                              ; [call: u8_array_bigger_than_18_bits_17]: call function
fncall .30                              ; [call: arrays_with_const_length_18]: call function
movi $r37 i33114                        ; get word offset to local from base
muli $r37 $r37 i8                       ; get byte offset to local from base
add $r37 $$locbase $r37                 ; get absolute byte offset to local
move $$arg0 $r37                        ; [call: decode_array_19]: pass argument 0
fncall .32                              ; [call: decode_array_19]: call function
movi $r39 i33114                        ; get word offset to local from base
muli $r39 $r39 i8                       ; get byte offset to local from base
add $r39 $$locbase $r39                 ; get absolute byte offset to local
lb $r42 $r39 i0                         ; load byte
movi $r43 i255                          ; initialize constant into register
eq $r44 $r42 $r43
eq $r45 $r44 $zero
jnzi $r45 .40
.41
ji  .3
.40
move $$arg0 $r42                        ; [call: log_46]: pass argument 0
fncall .36                              ; [call: log_46]: call function
movi $$arg0 i255                        ; [call: log_46]: pass argument 0
fncall .36                              ; [call: log_46]: call function
load $r49 data_NonConfigurable_0        ; load constant from data section
rvrt $r49
.3
cfsi i264920                            ; [fn end: main_0] free: locals 264920 byte(s), call args 0 slot(s)
move $$reta $r2                         ; [fn end: main_0] restore return address
popa .2                                 ; [fn end: main_0] restore all used registers
jal $zero $$reta i0                     ; [fn end: main_0] return from call
DIFF------------------------------
.program:
.4                                      ; --- start of function: array_repeat_zero_small_u8_1 ---
pusha .4                                ; [fn init: array_repeat_zero_small_u8_1]: push all used registers to stack
move $$locbase $sp                      ; [fn init: array_repeat_zero_small_u8_1]: set locals base register
cfei i0                                 ; [fn init: array_repeat_zero_small_u8_1]: allocate: locals 0 byte(s), call args 0 slot(s)
.42
mcli $$arg0 i5                          ; clear memory [u8; 5], 5 bytes
ji  .5
.5
cfsi i0                                 ; [fn end: array_repeat_zero_small_u8_1] free: locals 0 byte(s), call args 0 slot(s)
popa .4                                 ; [fn end: array_repeat_zero_small_u8_1] restore all used registers
jal $zero $$reta i0                     ; [fn end: array_repeat_zero_small_u8_1] return from call
DIFF------------------------------
.program:
.4                                      ; --- start of function: array_repeat_zero_small_u8_1 ---
pusha .4                                ; [fn init: array_repeat_zero_small_u8_1]: push all used registers to stack
move $$locbase $sp                      ; [fn init: array_repeat_zero_small_u8_1]: set locals base register
cfei i0                                 ; [fn init: array_repeat_zero_small_u8_1]: allocate: locals 0 byte(s), call args 0 slot(s)
.42
mcli $$arg0 i5                          ; clear memory [u8; 5], 5 bytes
.5
cfsi i0                                 ; [fn end: array_repeat_zero_small_u8_1] free: locals 0 byte(s), call args 0 slot(s)
popa .4                                 ; [fn end: array_repeat_zero_small_u8_1] restore all used registers
jal $zero $$reta i0                     ; [fn end: array_repeat_zero_small_u8_1] return from call
DIFF------------------------------
.program:
.4                                      ; --- start of function: array_repeat_zero_small_u8_1 ---
pusha .4                                ; [fn init: array_repeat_zero_small_u8_1]: push all used registers to stack
move $$locbase $sp                      ; [fn init: array_repeat_zero_small_u8_1]: set locals base register
cfei i0                                 ; [fn init: array_repeat_zero_small_u8_1]: allocate: locals 0 byte(s), call args 0 slot(s)
.42
mcli $$arg0 i5                          ; clear memory [u8; 5], 5 bytes
.5
cfsi i0                                 ; [fn end: array_repeat_zero_small_u8_1] free: locals 0 byte(s), call args 0 slot(s)
popa .4                                 ; [fn end: array_repeat_zero_small_u8_1] restore all used registers
jal $zero $$reta i0                     ; [fn end: array_repeat_zero_small_u8_1] return from call
DIFF------------------------------
.program:
.4                                      ; --- start of function: array_repeat_zero_small_u8_1 ---
pusha .4                                ; [fn init: array_repeat_zero_small_u8_1]: push all used registers to stack
move $$locbase $sp                      ; [fn init: array_repeat_zero_small_u8_1]: set locals base register
cfei i0                                 ; [fn init: array_repeat_zero_small_u8_1]: allocate: locals 0 byte(s), call args 0 slot(s)
.42
mcli $$arg0 i5                          ; clear memory [u8; 5], 5 bytes
.5
cfsi i0                                 ; [fn end: array_repeat_zero_small_u8_1] free: locals 0 byte(s), call args 0 slot(s)
popa .4                                 ; [fn end: array_repeat_zero_small_u8_1] restore all used registers
jal $zero $$reta i0                     ; [fn end: array_repeat_zero_small_u8_1] return from call
DIFF------------------------------
.program:
.6                                      ; --- start of function: array_repeat_zero_small_u16_2 ---
pusha .6                                ; [fn init: array_repeat_zero_small_u16_2]: push all used registers to stack
move $$locbase $sp                      ; [fn init: array_repeat_zero_small_u16_2]: set locals base register
cfei i0                                 ; [fn init: array_repeat_zero_small_u16_2]: allocate: locals 0 byte(s), call args 0 slot(s)
.43
mcli $$arg0 i40                         ; clear memory [u64; 5], 40 bytes
ji  .7
.7
cfsi i0                                 ; [fn end: array_repeat_zero_small_u16_2] free: locals 0 byte(s), call args 0 slot(s)
popa .6                                 ; [fn end: array_repeat_zero_small_u16_2] restore all used registers
jal $zero $$reta i0                     ; [fn end: array_repeat_zero_small_u16_2] return from call
DIFF------------------------------
.program:
.6                                      ; --- start of function: array_repeat_zero_small_u16_2 ---
pusha .6                                ; [fn init: array_repeat_zero_small_u16_2]: push all used registers to stack
move $$locbase $sp                      ; [fn init: array_repeat_zero_small_u16_2]: set locals base register
cfei i0                                 ; [fn init: array_repeat_zero_small_u16_2]: allocate: locals 0 byte(s), call args 0 slot(s)
.43
mcli $$arg0 i40                         ; clear memory [u64; 5], 40 bytes
.7
cfsi i0                                 ; [fn end: array_repeat_zero_small_u16_2] free: locals 0 byte(s), call args 0 slot(s)
popa .6                                 ; [fn end: array_repeat_zero_small_u16_2] restore all used registers
jal $zero $$reta i0                     ; [fn end: array_repeat_zero_small_u16_2] return from call
DIFF------------------------------
.program:
.6                                      ; --- start of function: array_repeat_zero_small_u16_2 ---
pusha .6                                ; [fn init: array_repeat_zero_small_u16_2]: push all used registers to stack
move $$locbase $sp                      ; [fn init: array_repeat_zero_small_u16_2]: set locals base register
cfei i0                                 ; [fn init: array_repeat_zero_small_u16_2]: allocate: locals 0 byte(s), call args 0 slot(s)
.43
mcli $$arg0 i40                         ; clear memory [u64; 5], 40 bytes
.7
cfsi i0                                 ; [fn end: array_repeat_zero_small_u16_2] free: locals 0 byte(s), call args 0 slot(s)
popa .6                                 ; [fn end: array_repeat_zero_small_u16_2] restore all used registers
jal $zero $$reta i0                     ; [fn end: array_repeat_zero_small_u16_2] return from call
DIFF------------------------------
.program:
.6                                      ; --- start of function: array_repeat_zero_small_u16_2 ---
pusha .6                                ; [fn init: array_repeat_zero_small_u16_2]: push all used registers to stack
move $$locbase $sp                      ; [fn init: array_repeat_zero_small_u16_2]: set locals base register
cfei i0                                 ; [fn init: array_repeat_zero_small_u16_2]: allocate: locals 0 byte(s), call args 0 slot(s)
.43
mcli $$arg0 i40                         ; clear memory [u64; 5], 40 bytes
.7
cfsi i0                                 ; [fn end: array_repeat_zero_small_u16_2] free: locals 0 byte(s), call args 0 slot(s)
popa .6                                 ; [fn end: array_repeat_zero_small_u16_2] restore all used registers
jal $zero $$reta i0                     ; [fn end: array_repeat_zero_small_u16_2] return from call
DIFF------------------------------
.program:
.8                                      ; --- start of function: array_repeat_zero_small_u256_5 ---
pusha .8                                ; [fn init: array_repeat_zero_small_u256_5]: push all used registers to stack
move $$locbase $sp                      ; [fn init: array_repeat_zero_small_u256_5]: set locals base register
cfei i0                                 ; [fn init: array_repeat_zero_small_u256_5]: allocate: locals 0 byte(s), call args 0 slot(s)
.44
mcli $$arg0 i160                        ; clear memory [u256; 5], 160 bytes
ji  .9
.9
cfsi i0                                 ; [fn end: array_repeat_zero_small_u256_5] free: locals 0 byte(s), call args 0 slot(s)
popa .8                                 ; [fn end: array_repeat_zero_small_u256_5] restore all used registers
jal $zero $$reta i0                     ; [fn end: array_repeat_zero_small_u256_5] return from call
DIFF------------------------------
.program:
.8                                      ; --- start of function: array_repeat_zero_small_u256_5 ---
pusha .8                                ; [fn init: array_repeat_zero_small_u256_5]: push all used registers to stack
move $$locbase $sp                      ; [fn init: array_repeat_zero_small_u256_5]: set locals base register
cfei i0                                 ; [fn init: array_repeat_zero_small_u256_5]: allocate: locals 0 byte(s), call args 0 slot(s)
.44
mcli $$arg0 i160                        ; clear memory [u256; 5], 160 bytes
.9
cfsi i0                                 ; [fn end: array_repeat_zero_small_u256_5] free: locals 0 byte(s), call args 0 slot(s)
popa .8                                 ; [fn end: array_repeat_zero_small_u256_5] restore all used registers
jal $zero $$reta i0                     ; [fn end: array_repeat_zero_small_u256_5] return from call
DIFF------------------------------
.program:
.8                                      ; --- start of function: array_repeat_zero_small_u256_5 ---
pusha .8                                ; [fn init: array_repeat_zero_small_u256_5]: push all used registers to stack
move $$locbase $sp                      ; [fn init: array_repeat_zero_small_u256_5]: set locals base register
cfei i0                                 ; [fn init: array_repeat_zero_small_u256_5]: allocate: locals 0 byte(s), call args 0 slot(s)
.44
mcli $$arg0 i160                        ; clear memory [u256; 5], 160 bytes
.9
cfsi i0                                 ; [fn end: array_repeat_zero_small_u256_5] free: locals 0 byte(s), call args 0 slot(s)
popa .8                                 ; [fn end: array_repeat_zero_small_u256_5] restore all used registers
jal $zero $$reta i0                     ; [fn end: array_repeat_zero_small_u256_5] return from call
DIFF------------------------------
.program:
.8                                      ; --- start of function: array_repeat_zero_small_u256_5 ---
pusha .8                                ; [fn init: array_repeat_zero_small_u256_5]: push all used registers to stack
move $$locbase $sp                      ; [fn init: array_repeat_zero_small_u256_5]: set locals base register
cfei i0                                 ; [fn init: array_repeat_zero_small_u256_5]: allocate: locals 0 byte(s), call args 0 slot(s)
.44
mcli $$arg0 i160                        ; clear memory [u256; 5], 160 bytes
.9
cfsi i0                                 ; [fn end: array_repeat_zero_small_u256_5] free: locals 0 byte(s), call args 0 slot(s)
popa .8                                 ; [fn end: array_repeat_zero_small_u256_5] restore all used registers
jal $zero $$reta i0                     ; [fn end: array_repeat_zero_small_u256_5] return from call
DIFF------------------------------
.program:
.10                                     ; --- start of function: array_repeat_zero_small_b256_6 ---
pusha .10                               ; [fn init: array_repeat_zero_small_b256_6]: push all used registers to stack
move $$locbase $sp                      ; [fn init: array_repeat_zero_small_b256_6]: set locals base register
cfei i0                                 ; [fn init: array_repeat_zero_small_b256_6]: allocate: locals 0 byte(s), call args 0 slot(s)
.45
mcli $$arg0 i160                        ; clear memory [b256; 5], 160 bytes
ji  .11
.11
cfsi i0                                 ; [fn end: array_repeat_zero_small_b256_6] free: locals 0 byte(s), call args 0 slot(s)
popa .10                                ; [fn end: array_repeat_zero_small_b256_6] restore all used registers
jal $zero $$reta i0                     ; [fn end: array_repeat_zero_small_b256_6] return from call
DIFF------------------------------
.program:
.10                                     ; --- start of function: array_repeat_zero_small_b256_6 ---
pusha .10                               ; [fn init: array_repeat_zero_small_b256_6]: push all used registers to stack
move $$locbase $sp                      ; [fn init: array_repeat_zero_small_b256_6]: set locals base register
cfei i0                                 ; [fn init: array_repeat_zero_small_b256_6]: allocate: locals 0 byte(s), call args 0 slot(s)
.45
mcli $$arg0 i160                        ; clear memory [b256; 5], 160 bytes
.11
cfsi i0                                 ; [fn end: array_repeat_zero_small_b256_6] free: locals 0 byte(s), call args 0 slot(s)
popa .10                                ; [fn end: array_repeat_zero_small_b256_6] restore all used registers
jal $zero $$reta i0                     ; [fn end: array_repeat_zero_small_b256_6] return from call
DIFF------------------------------
.program:
.10                                     ; --- start of function: array_repeat_zero_small_b256_6 ---
pusha .10                               ; [fn init: array_repeat_zero_small_b256_6]: push all used registers to stack
move $$locbase $sp                      ; [fn init: array_repeat_zero_small_b256_6]: set locals base register
cfei i0                                 ; [fn init: array_repeat_zero_small_b256_6]: allocate: locals 0 byte(s), call args 0 slot(s)
.45
mcli $$arg0 i160                        ; clear memory [b256; 5], 160 bytes
.11
cfsi i0                                 ; [fn end: array_repeat_zero_small_b256_6] free: locals 0 byte(s), call args 0 slot(s)
popa .10                                ; [fn end: array_repeat_zero_small_b256_6] restore all used registers
jal $zero $$reta i0                     ; [fn end: array_repeat_zero_small_b256_6] return from call
DIFF------------------------------
.program:
.10                                     ; --- start of function: array_repeat_zero_small_b256_6 ---
pusha .10                               ; [fn init: array_repeat_zero_small_b256_6]: push all used registers to stack
move $$locbase $sp                      ; [fn init: array_repeat_zero_small_b256_6]: set locals base register
cfei i0                                 ; [fn init: array_repeat_zero_small_b256_6]: allocate: locals 0 byte(s), call args 0 slot(s)
.45
mcli $$arg0 i160                        ; clear memory [b256; 5], 160 bytes
.11
cfsi i0                                 ; [fn end: array_repeat_zero_small_b256_6] free: locals 0 byte(s), call args 0 slot(s)
popa .10                                ; [fn end: array_repeat_zero_small_b256_6] restore all used registers
jal $zero $$reta i0                     ; [fn end: array_repeat_zero_small_b256_6] return from call
DIFF------------------------------
.program:
.12                                     ; --- start of function: array_repeat_zero_small_bool_7 ---
pusha .12                               ; [fn init: array_repeat_zero_small_bool_7]: push all used registers to stack
move $$locbase $sp                      ; [fn init: array_repeat_zero_small_bool_7]: set locals base register
cfei i0                                 ; [fn init: array_repeat_zero_small_bool_7]: allocate: locals 0 byte(s), call args 0 slot(s)
.46
mcli $$arg0 i5                          ; clear memory [bool; 5], 5 bytes
ji  .13
.13
cfsi i0                                 ; [fn end: array_repeat_zero_small_bool_7] free: locals 0 byte(s), call args 0 slot(s)
popa .12                                ; [fn end: array_repeat_zero_small_bool_7] restore all used registers
jal $zero $$reta i0                     ; [fn end: array_repeat_zero_small_bool_7] return from call
DIFF------------------------------
.program:
.12                                     ; --- start of function: array_repeat_zero_small_bool_7 ---
pusha .12                               ; [fn init: array_repeat_zero_small_bool_7]: push all used registers to stack
move $$locbase $sp                      ; [fn init: array_repeat_zero_small_bool_7]: set locals base register
cfei i0                                 ; [fn init: array_repeat_zero_small_bool_7]: allocate: locals 0 byte(s), call args 0 slot(s)
.46
mcli $$arg0 i5                          ; clear memory [bool; 5], 5 bytes
.13
cfsi i0                                 ; [fn end: array_repeat_zero_small_bool_7] free: locals 0 byte(s), call args 0 slot(s)
popa .12                                ; [fn end: array_repeat_zero_small_bool_7] restore all used registers
jal $zero $$reta i0                     ; [fn end: array_repeat_zero_small_bool_7] return from call
DIFF------------------------------
.program:
.12                                     ; --- start of function: array_repeat_zero_small_bool_7 ---
pusha .12                               ; [fn init: array_repeat_zero_small_bool_7]: push all used registers to stack
move $$locbase $sp                      ; [fn init: array_repeat_zero_small_bool_7]: set locals base register
cfei i0                                 ; [fn init: array_repeat_zero_small_bool_7]: allocate: locals 0 byte(s), call args 0 slot(s)
.46
mcli $$arg0 i5                          ; clear memory [bool; 5], 5 bytes
.13
cfsi i0                                 ; [fn end: array_repeat_zero_small_bool_7] free: locals 0 byte(s), call args 0 slot(s)
popa .12                                ; [fn end: array_repeat_zero_small_bool_7] restore all used registers
jal $zero $$reta i0                     ; [fn end: array_repeat_zero_small_bool_7] return from call
DIFF------------------------------
.program:
.12                                     ; --- start of function: array_repeat_zero_small_bool_7 ---
pusha .12                               ; [fn init: array_repeat_zero_small_bool_7]: push all used registers to stack
move $$locbase $sp                      ; [fn init: array_repeat_zero_small_bool_7]: set locals base register
cfei i0                                 ; [fn init: array_repeat_zero_small_bool_7]: allocate: locals 0 byte(s), call args 0 slot(s)
.46
mcli $$arg0 i5                          ; clear memory [bool; 5], 5 bytes
.13
cfsi i0                                 ; [fn end: array_repeat_zero_small_bool_7] free: locals 0 byte(s), call args 0 slot(s)
popa .12                                ; [fn end: array_repeat_zero_small_bool_7] restore all used registers
jal $zero $$reta i0                     ; [fn end: array_repeat_zero_small_bool_7] return from call
DIFF------------------------------
.program:
.14                                     ; --- start of function: array_repeat_zero_big_u8_8 ---
pusha .14                               ; [fn init: array_repeat_zero_big_u8_8]: push all used registers to stack
move $$locbase $sp                      ; [fn init: array_repeat_zero_big_u8_8]: set locals base register
cfei i0                                 ; [fn init: array_repeat_zero_big_u8_8]: allocate: locals 0 byte(s), call args 0 slot(s)
.47
mcli $$arg0 i25                         ; clear memory [u8; 25], 25 bytes
ji  .15
.15
cfsi i0                                 ; [fn end: array_repeat_zero_big_u8_8] free: locals 0 byte(s), call args 0 slot(s)
popa .14                                ; [fn end: array_repeat_zero_big_u8_8] restore all used registers
jal $zero $$reta i0                     ; [fn end: array_repeat_zero_big_u8_8] return from call
DIFF------------------------------
.program:
.14                                     ; --- start of function: array_repeat_zero_big_u8_8 ---
pusha .14                               ; [fn init: array_repeat_zero_big_u8_8]: push all used registers to stack
move $$locbase $sp                      ; [fn init: array_repeat_zero_big_u8_8]: set locals base register
cfei i0                                 ; [fn init: array_repeat_zero_big_u8_8]: allocate: locals 0 byte(s), call args 0 slot(s)
.47
mcli $$arg0 i25                         ; clear memory [u8; 25], 25 bytes
.15
cfsi i0                                 ; [fn end: array_repeat_zero_big_u8_8] free: locals 0 byte(s), call args 0 slot(s)
popa .14                                ; [fn end: array_repeat_zero_big_u8_8] restore all used registers
jal $zero $$reta i0                     ; [fn end: array_repeat_zero_big_u8_8] return from call
DIFF------------------------------
.program:
.14                                     ; --- start of function: array_repeat_zero_big_u8_8 ---
pusha .14                               ; [fn init: array_repeat_zero_big_u8_8]: push all used registers to stack
move $$locbase $sp                      ; [fn init: array_repeat_zero_big_u8_8]: set locals base register
cfei i0                                 ; [fn init: array_repeat_zero_big_u8_8]: allocate: locals 0 byte(s), call args 0 slot(s)
.47
mcli $$arg0 i25                         ; clear memory [u8; 25], 25 bytes
.15
cfsi i0                                 ; [fn end: array_repeat_zero_big_u8_8] free: locals 0 byte(s), call args 0 slot(s)
popa .14                                ; [fn end: array_repeat_zero_big_u8_8] restore all used registers
jal $zero $$reta i0                     ; [fn end: array_repeat_zero_big_u8_8] return from call
DIFF------------------------------
.program:
.14                                     ; --- start of function: array_repeat_zero_big_u8_8 ---
pusha .14                               ; [fn init: array_repeat_zero_big_u8_8]: push all used registers to stack
move $$locbase $sp                      ; [fn init: array_repeat_zero_big_u8_8]: set locals base register
cfei i0                                 ; [fn init: array_repeat_zero_big_u8_8]: allocate: locals 0 byte(s), call args 0 slot(s)
.47
mcli $$arg0 i25                         ; clear memory [u8; 25], 25 bytes
.15
cfsi i0                                 ; [fn end: array_repeat_zero_big_u8_8] free: locals 0 byte(s), call args 0 slot(s)
popa .14                                ; [fn end: array_repeat_zero_big_u8_8] restore all used registers
jal $zero $$reta i0                     ; [fn end: array_repeat_zero_big_u8_8] return from call
DIFF------------------------------
.program:
.16                                     ; --- start of function: array_repeat_zero_big_u32_10 ---
pusha .16                               ; [fn init: array_repeat_zero_big_u32_10]: push all used registers to stack
move $$locbase $sp                      ; [fn init: array_repeat_zero_big_u32_10]: set locals base register
cfei i0                                 ; [fn init: array_repeat_zero_big_u32_10]: allocate: locals 0 byte(s), call args 0 slot(s)
.48
mcli $$arg0 i200                        ; clear memory [u64; 25], 200 bytes
ji  .17
.17
cfsi i0                                 ; [fn end: array_repeat_zero_big_u32_10] free: locals 0 byte(s), call args 0 slot(s)
popa .16                                ; [fn end: array_repeat_zero_big_u32_10] restore all used registers
jal $zero $$reta i0                     ; [fn end: array_repeat_zero_big_u32_10] return from call
DIFF------------------------------
.program:
.16                                     ; --- start of function: array_repeat_zero_big_u32_10 ---
pusha .16                               ; [fn init: array_repeat_zero_big_u32_10]: push all used registers to stack
move $$locbase $sp                      ; [fn init: array_repeat_zero_big_u32_10]: set locals base register
cfei i0                                 ; [fn init: array_repeat_zero_big_u32_10]: allocate: locals 0 byte(s), call args 0 slot(s)
.48
mcli $$arg0 i200                        ; clear memory [u64; 25], 200 bytes
.17
cfsi i0                                 ; [fn end: array_repeat_zero_big_u32_10] free: locals 0 byte(s), call args 0 slot(s)
popa .16                                ; [fn end: array_repeat_zero_big_u32_10] restore all used registers
jal $zero $$reta i0                     ; [fn end: array_repeat_zero_big_u32_10] return from call
DIFF------------------------------
.program:
.16                                     ; --- start of function: array_repeat_zero_big_u32_10 ---
pusha .16                               ; [fn init: array_repeat_zero_big_u32_10]: push all used registers to stack
move $$locbase $sp                      ; [fn init: array_repeat_zero_big_u32_10]: set locals base register
cfei i0                                 ; [fn init: array_repeat_zero_big_u32_10]: allocate: locals 0 byte(s), call args 0 slot(s)
.48
mcli $$arg0 i200                        ; clear memory [u64; 25], 200 bytes
.17
cfsi i0                                 ; [fn end: array_repeat_zero_big_u32_10] free: locals 0 byte(s), call args 0 slot(s)
popa .16                                ; [fn end: array_repeat_zero_big_u32_10] restore all used registers
jal $zero $$reta i0                     ; [fn end: array_repeat_zero_big_u32_10] return from call
DIFF------------------------------
.program:
.16                                     ; --- start of function: array_repeat_zero_big_u32_10 ---
pusha .16                               ; [fn init: array_repeat_zero_big_u32_10]: push all used registers to stack
move $$locbase $sp                      ; [fn init: array_repeat_zero_big_u32_10]: set locals base register
cfei i0                                 ; [fn init: array_repeat_zero_big_u32_10]: allocate: locals 0 byte(s), call args 0 slot(s)
.48
mcli $$arg0 i200                        ; clear memory [u64; 25], 200 bytes
.17
cfsi i0                                 ; [fn end: array_repeat_zero_big_u32_10] free: locals 0 byte(s), call args 0 slot(s)
popa .16                                ; [fn end: array_repeat_zero_big_u32_10] restore all used registers
jal $zero $$reta i0                     ; [fn end: array_repeat_zero_big_u32_10] return from call
DIFF------------------------------
.program:
.18                                     ; --- start of function: array_repeat_zero_big_u256_12 ---
pusha .18                               ; [fn init: array_repeat_zero_big_u256_12]: push all used registers to stack
move $$locbase $sp                      ; [fn init: array_repeat_zero_big_u256_12]: set locals base register
cfei i0                                 ; [fn init: array_repeat_zero_big_u256_12]: allocate: locals 0 byte(s), call args 0 slot(s)
.49
mcli $$arg0 i800                        ; clear memory [u256; 25], 800 bytes
ji  .19
.19
cfsi i0                                 ; [fn end: array_repeat_zero_big_u256_12] free: locals 0 byte(s), call args 0 slot(s)
popa .18                                ; [fn end: array_repeat_zero_big_u256_12] restore all used registers
jal $zero $$reta i0                     ; [fn end: array_repeat_zero_big_u256_12] return from call
DIFF------------------------------
.program:
.18                                     ; --- start of function: array_repeat_zero_big_u256_12 ---
pusha .18                               ; [fn init: array_repeat_zero_big_u256_12]: push all used registers to stack
move $$locbase $sp                      ; [fn init: array_repeat_zero_big_u256_12]: set locals base register
cfei i0                                 ; [fn init: array_repeat_zero_big_u256_12]: allocate: locals 0 byte(s), call args 0 slot(s)
.49
mcli $$arg0 i800                        ; clear memory [u256; 25], 800 bytes
.19
cfsi i0                                 ; [fn end: array_repeat_zero_big_u256_12] free: locals 0 byte(s), call args 0 slot(s)
popa .18                                ; [fn end: array_repeat_zero_big_u256_12] restore all used registers
jal $zero $$reta i0                     ; [fn end: array_repeat_zero_big_u256_12] return from call
DIFF------------------------------
.program:
.18                                     ; --- start of function: array_repeat_zero_big_u256_12 ---
pusha .18                               ; [fn init: array_repeat_zero_big_u256_12]: push all used registers to stack
move $$locbase $sp                      ; [fn init: array_repeat_zero_big_u256_12]: set locals base register
cfei i0                                 ; [fn init: array_repeat_zero_big_u256_12]: allocate: locals 0 byte(s), call args 0 slot(s)
.49
mcli $$arg0 i800                        ; clear memory [u256; 25], 800 bytes
.19
cfsi i0                                 ; [fn end: array_repeat_zero_big_u256_12] free: locals 0 byte(s), call args 0 slot(s)
popa .18                                ; [fn end: array_repeat_zero_big_u256_12] restore all used registers
jal $zero $$reta i0                     ; [fn end: array_repeat_zero_big_u256_12] return from call
DIFF------------------------------
.program:
.18                                     ; --- start of function: array_repeat_zero_big_u256_12 ---
pusha .18                               ; [fn init: array_repeat_zero_big_u256_12]: push all used registers to stack
move $$locbase $sp                      ; [fn init: array_repeat_zero_big_u256_12]: set locals base register
cfei i0                                 ; [fn init: array_repeat_zero_big_u256_12]: allocate: locals 0 byte(s), call args 0 slot(s)
.49
mcli $$arg0 i800                        ; clear memory [u256; 25], 800 bytes
.19
cfsi i0                                 ; [fn end: array_repeat_zero_big_u256_12] free: locals 0 byte(s), call args 0 slot(s)
popa .18                                ; [fn end: array_repeat_zero_big_u256_12] restore all used registers
jal $zero $$reta i0                     ; [fn end: array_repeat_zero_big_u256_12] return from call
DIFF------------------------------
.program:
.20                                     ; --- start of function: array_repeat_zero_big_b256_13 ---
pusha .20                               ; [fn init: array_repeat_zero_big_b256_13]: push all used registers to stack
move $$locbase $sp                      ; [fn init: array_repeat_zero_big_b256_13]: set locals base register
cfei i0                                 ; [fn init: array_repeat_zero_big_b256_13]: allocate: locals 0 byte(s), call args 0 slot(s)
.50
mcli $$arg0 i800                        ; clear memory [b256; 25], 800 bytes
ji  .21
.21
cfsi i0                                 ; [fn end: array_repeat_zero_big_b256_13] free: locals 0 byte(s), call args 0 slot(s)
popa .20                                ; [fn end: array_repeat_zero_big_b256_13] restore all used registers
jal $zero $$reta i0                     ; [fn end: array_repeat_zero_big_b256_13] return from call
DIFF------------------------------
.program:
.20                                     ; --- start of function: array_repeat_zero_big_b256_13 ---
pusha .20                               ; [fn init: array_repeat_zero_big_b256_13]: push all used registers to stack
move $$locbase $sp                      ; [fn init: array_repeat_zero_big_b256_13]: set locals base register
cfei i0                                 ; [fn init: array_repeat_zero_big_b256_13]: allocate: locals 0 byte(s), call args 0 slot(s)
.50
mcli $$arg0 i800                        ; clear memory [b256; 25], 800 bytes
.21
cfsi i0                                 ; [fn end: array_repeat_zero_big_b256_13] free: locals 0 byte(s), call args 0 slot(s)
popa .20                                ; [fn end: array_repeat_zero_big_b256_13] restore all used registers
jal $zero $$reta i0                     ; [fn end: array_repeat_zero_big_b256_13] return from call
DIFF------------------------------
.program:
.20                                     ; --- start of function: array_repeat_zero_big_b256_13 ---
pusha .20                               ; [fn init: array_repeat_zero_big_b256_13]: push all used registers to stack
move $$locbase $sp                      ; [fn init: array_repeat_zero_big_b256_13]: set locals base register
cfei i0                                 ; [fn init: array_repeat_zero_big_b256_13]: allocate: locals 0 byte(s), call args 0 slot(s)
.50
mcli $$arg0 i800                        ; clear memory [b256; 25], 800 bytes
.21
cfsi i0                                 ; [fn end: array_repeat_zero_big_b256_13] free: locals 0 byte(s), call args 0 slot(s)
popa .20                                ; [fn end: array_repeat_zero_big_b256_13] restore all used registers
jal $zero $$reta i0                     ; [fn end: array_repeat_zero_big_b256_13] return from call
DIFF------------------------------
.program:
.20                                     ; --- start of function: array_repeat_zero_big_b256_13 ---
pusha .20                               ; [fn init: array_repeat_zero_big_b256_13]: push all used registers to stack
move $$locbase $sp                      ; [fn init: array_repeat_zero_big_b256_13]: set locals base register
cfei i0                                 ; [fn init: array_repeat_zero_big_b256_13]: allocate: locals 0 byte(s), call args 0 slot(s)
.50
mcli $$arg0 i800                        ; clear memory [b256; 25], 800 bytes
.21
cfsi i0                                 ; [fn end: array_repeat_zero_big_b256_13] free: locals 0 byte(s), call args 0 slot(s)
popa .20                                ; [fn end: array_repeat_zero_big_b256_13] restore all used registers
jal $zero $$reta i0                     ; [fn end: array_repeat_zero_big_b256_13] return from call
DIFF------------------------------
.program:
.22                                     ; --- start of function: array_repeat_zero_big_bool_14 ---
pusha .22                               ; [fn init: array_repeat_zero_big_bool_14]: push all used registers to stack
move $$locbase $sp                      ; [fn init: array_repeat_zero_big_bool_14]: set locals base register
cfei i0                                 ; [fn init: array_repeat_zero_big_bool_14]: allocate: locals 0 byte(s), call args 0 slot(s)
.51
mcli $$arg0 i25                         ; clear memory [bool; 25], 25 bytes
ji  .23
.23
cfsi i0                                 ; [fn end: array_repeat_zero_big_bool_14] free: locals 0 byte(s), call args 0 slot(s)
popa .22                                ; [fn end: array_repeat_zero_big_bool_14] restore all used registers
jal $zero $$reta i0                     ; [fn end: array_repeat_zero_big_bool_14] return from call
DIFF------------------------------
.program:
.22                                     ; --- start of function: array_repeat_zero_big_bool_14 ---
pusha .22                               ; [fn init: array_repeat_zero_big_bool_14]: push all used registers to stack
move $$locbase $sp                      ; [fn init: array_repeat_zero_big_bool_14]: set locals base register
cfei i0                                 ; [fn init: array_repeat_zero_big_bool_14]: allocate: locals 0 byte(s), call args 0 slot(s)
.51
mcli $$arg0 i25                         ; clear memory [bool; 25], 25 bytes
.23
cfsi i0                                 ; [fn end: array_repeat_zero_big_bool_14] free: locals 0 byte(s), call args 0 slot(s)
popa .22                                ; [fn end: array_repeat_zero_big_bool_14] restore all used registers
jal $zero $$reta i0                     ; [fn end: array_repeat_zero_big_bool_14] return from call
DIFF------------------------------
.program:
.22                                     ; --- start of function: array_repeat_zero_big_bool_14 ---
pusha .22                               ; [fn init: array_repeat_zero_big_bool_14]: push all used registers to stack
move $$locbase $sp                      ; [fn init: array_repeat_zero_big_bool_14]: set locals base register
cfei i0                                 ; [fn init: array_repeat_zero_big_bool_14]: allocate: locals 0 byte(s), call args 0 slot(s)
.51
mcli $$arg0 i25                         ; clear memory [bool; 25], 25 bytes
.23
cfsi i0                                 ; [fn end: array_repeat_zero_big_bool_14] free: locals 0 byte(s), call args 0 slot(s)
popa .22                                ; [fn end: array_repeat_zero_big_bool_14] restore all used registers
jal $zero $$reta i0                     ; [fn end: array_repeat_zero_big_bool_14] return from call
DIFF------------------------------
.program:
.22                                     ; --- start of function: array_repeat_zero_big_bool_14 ---
pusha .22                               ; [fn init: array_repeat_zero_big_bool_14]: push all used registers to stack
move $$locbase $sp                      ; [fn init: array_repeat_zero_big_bool_14]: set locals base register
cfei i0                                 ; [fn init: array_repeat_zero_big_bool_14]: allocate: locals 0 byte(s), call args 0 slot(s)
.51
mcli $$arg0 i25                         ; clear memory [bool; 25], 25 bytes
.23
cfsi i0                                 ; [fn end: array_repeat_zero_big_bool_14] free: locals 0 byte(s), call args 0 slot(s)
popa .22                                ; [fn end: array_repeat_zero_big_bool_14] restore all used registers
jal $zero $$reta i0                     ; [fn end: array_repeat_zero_big_bool_14] return from call
DIFF------------------------------
.program:
.24                                     ; --- start of function: small_array_repeat_15 ---
pusha .24                               ; [fn init: small_array_repeat_15]: push all used registers to stack
move $$locbase $sp                      ; [fn init: small_array_repeat_15]: set locals base register
cfei i0                                 ; [fn init: small_array_repeat_15]: allocate: locals 0 byte(s), call args 0 slot(s)
.52
movi $r61 i1                            ; get array element size
 mul $r62 $zero $r61                     ; get offset to array element
 add $r62 $$arg0 $r62                    ; add array element offset to array base
 sb $r62 $one i0                         ; store byte
 movi $r62 i0                            ; get offset to array element
 move $r62 $$arg0                        ; add array element offset to array base
 sb $$arg0 $one i0                       ; store byte
movi $r63 i1                            ; get array element size
 mul $r64 $one $r63                      ; get offset to array element
 add $r64 $$arg0 $r64                    ; add array element offset to array base
 movi $r64 i1                            ; get offset to array element
 addi $r64 $$arg0 i1                     ; add array element offset to array base
sb $r64 $one i0                         ; store byte
movi $r65 i1                            ; get array element size
movi $r66 i2                            ; initialize constant into register
 mul $r67 $r66 $r65                      ; get offset to array element
 add $r67 $$arg0 $r67                    ; add array element offset to array base
 movi $r67 i2                            ; get offset to array element
 addi $r67 $$arg0 i2                     ; add array element offset to array base
sb $r67 $one i0                         ; store byte
movi $r68 i1                            ; get array element size
movi $r69 i3                            ; initialize constant into register
 mul $r70 $r69 $r68                      ; get offset to array element
 add $r70 $$arg0 $r70                    ; add array element offset to array base
 movi $r70 i3                            ; get offset to array element
 addi $r70 $$arg0 i3                     ; add array element offset to array base
sb $r70 $one i0                         ; store byte
movi $r71 i1                            ; get array element size
movi $r72 i4                            ; initialize constant into register
 mul $r73 $r72 $r71                      ; get offset to array element
 add $r73 $$arg0 $r73                    ; add array element offset to array base
 movi $r73 i4                            ; get offset to array element
 addi $r73 $$arg0 i4                     ; add array element offset to array base
sb $r73 $one i0                         ; store byte
ji  .25
.25
cfsi i0                                 ; [fn end: small_array_repeat_15] free: locals 0 byte(s), call args 0 slot(s)
popa .24                                ; [fn end: small_array_repeat_15] restore all used registers
jal $zero $$reta i0                     ; [fn end: small_array_repeat_15] return from call
DIFF------------------------------
.program:
.24                                     ; --- start of function: small_array_repeat_15 ---
pusha .24                               ; [fn init: small_array_repeat_15]: push all used registers to stack
move $$locbase $sp                      ; [fn init: small_array_repeat_15]: set locals base register
cfei i0                                 ; [fn init: small_array_repeat_15]: allocate: locals 0 byte(s), call args 0 slot(s)
.52
sb $$arg0 $one i0                       ; store byte
addi $r64 $$arg0 i1                     ; add array element offset to array base
sb $r64 $one i0                         ; store byte
addi $r67 $$arg0 i2                     ; add array element offset to array base
sb $r67 $one i0                         ; store byte
addi $r70 $$arg0 i3                     ; add array element offset to array base
sb $r70 $one i0                         ; store byte
addi $r73 $$arg0 i4                     ; add array element offset to array base
sb $r73 $one i0                         ; store byte
.25
cfsi i0                                 ; [fn end: small_array_repeat_15] free: locals 0 byte(s), call args 0 slot(s)
popa .24                                ; [fn end: small_array_repeat_15] restore all used registers
jal $zero $$reta i0                     ; [fn end: small_array_repeat_15] return from call
DIFF------------------------------
.program:
.24                                     ; --- start of function: small_array_repeat_15 ---
pusha .24                               ; [fn init: small_array_repeat_15]: push all used registers to stack
move $$locbase $sp                      ; [fn init: small_array_repeat_15]: set locals base register
cfei i0                                 ; [fn init: small_array_repeat_15]: allocate: locals 0 byte(s), call args 0 slot(s)
.52
sb $$arg0 $one i0                       ; store byte
addi $r64 $$arg0 i1                     ; add array element offset to array base
sb $r64 $one i0                         ; store byte
addi $r67 $$arg0 i2                     ; add array element offset to array base
sb $r67 $one i0                         ; store byte
addi $r70 $$arg0 i3                     ; add array element offset to array base
sb $r70 $one i0                         ; store byte
addi $r73 $$arg0 i4                     ; add array element offset to array base
sb $r73 $one i0                         ; store byte
.25
cfsi i0                                 ; [fn end: small_array_repeat_15] free: locals 0 byte(s), call args 0 slot(s)
popa .24                                ; [fn end: small_array_repeat_15] restore all used registers
jal $zero $$reta i0                     ; [fn end: small_array_repeat_15] return from call
DIFF------------------------------
.program:
.24                                     ; --- start of function: small_array_repeat_15 ---
pusha .24                               ; [fn init: small_array_repeat_15]: push all used registers to stack
move $$locbase $sp                      ; [fn init: small_array_repeat_15]: set locals base register
cfei i0                                 ; [fn init: small_array_repeat_15]: allocate: locals 0 byte(s), call args 0 slot(s)
.52
sb $$arg0 $one i0                       ; store byte
addi $r64 $$arg0 i1                     ; add array element offset to array base
sb $r64 $one i0                         ; store byte
addi $r67 $$arg0 i2                     ; add array element offset to array base
sb $r67 $one i0                         ; store byte
addi $r70 $$arg0 i3                     ; add array element offset to array base
sb $r70 $one i0                         ; store byte
addi $r73 $$arg0 i4                     ; add array element offset to array base
sb $r73 $one i0                         ; store byte
.25
cfsi i0                                 ; [fn end: small_array_repeat_15] free: locals 0 byte(s), call args 0 slot(s)
popa .24                                ; [fn end: small_array_repeat_15] restore all used registers
jal $zero $$reta i0                     ; [fn end: small_array_repeat_15] return from call
DIFF------------------------------
.program:
.26                                     ; --- start of function: big_array_repeat_16 ---
pusha .26                               ; [fn init: big_array_repeat_16]: push all used registers to stack
move $$locbase $sp                      ; [fn init: big_array_repeat_16]: set locals base register
cfei i0                                 ; [fn init: big_array_repeat_16]: allocate: locals 0 byte(s), call args 0 slot(s)
.53
 move $r75 $zero                         ; move parameter from branch to block argument
 movi $r75 i0                            ; move parameter from branch to block argument
ji  .54
.54
move $r77 $r75                          ; move parameter from branch to block argument
movi $r78 i1                            ; get array element size
 mul $r79 $r77 $r78                      ; get offset to array element
 muli $r79 $r75 i1                       ; get offset to array element
add $r79 $$arg0 $r79                    ; add array element offset to array base
sb $r79 $one i0                         ; store byte
 add $r80 $r77 $one
 addi $r80 $r77 i1
movi $r81 i25                           ; initialize constant into register
lt $r82 $r80 $r81
move $r75 $r80                          ; move parameter from branch to block argument
jnzi $r82 .54
ji  .55
.55
ji  .27
.27
cfsi i0                                 ; [fn end: big_array_repeat_16] free: locals 0 byte(s), call args 0 slot(s)
popa .26                                ; [fn end: big_array_repeat_16] restore all used registers
jal $zero $$reta i0                     ; [fn end: big_array_repeat_16] return from call
DIFF------------------------------
.program:
.26                                     ; --- start of function: big_array_repeat_16 ---
pusha .26                               ; [fn init: big_array_repeat_16]: push all used registers to stack
move $$locbase $sp                      ; [fn init: big_array_repeat_16]: set locals base register
cfei i0                                 ; [fn init: big_array_repeat_16]: allocate: locals 0 byte(s), call args 0 slot(s)
.53
movi $r75 i0                            ; move parameter from branch to block argument
.54
move $r77 $r75                          ; move parameter from branch to block argument
muli $r79 $r75 i1                       ; get offset to array element
add $r79 $$arg0 $r79                    ; add array element offset to array base
sb $r79 $one i0                         ; store byte
addi $r80 $r77 i1
movi $r81 i25                           ; initialize constant into register
lt $r82 $r80 $r81
move $r75 $r80                          ; move parameter from branch to block argument
jnzi $r82 .54
.55
.27
cfsi i0                                 ; [fn end: big_array_repeat_16] free: locals 0 byte(s), call args 0 slot(s)
popa .26                                ; [fn end: big_array_repeat_16] restore all used registers
jal $zero $$reta i0                     ; [fn end: big_array_repeat_16] return from call
DIFF------------------------------
.program:
.26                                     ; --- start of function: big_array_repeat_16 ---
pusha .26                               ; [fn init: big_array_repeat_16]: push all used registers to stack
move $$locbase $sp                      ; [fn init: big_array_repeat_16]: set locals base register
cfei i0                                 ; [fn init: big_array_repeat_16]: allocate: locals 0 byte(s), call args 0 slot(s)
.53
movi $r75 i0                            ; move parameter from branch to block argument
.54
move $r77 $r75                          ; move parameter from branch to block argument
muli $r79 $r75 i1                       ; get offset to array element
add $r79 $$arg0 $r79                    ; add array element offset to array base
sb $r79 $one i0                         ; store byte
addi $r80 $r77 i1
movi $r81 i25                           ; initialize constant into register
lt $r82 $r80 $r81
move $r75 $r80                          ; move parameter from branch to block argument
jnzi $r82 .54
.55
.27
cfsi i0                                 ; [fn end: big_array_repeat_16] free: locals 0 byte(s), call args 0 slot(s)
popa .26                                ; [fn end: big_array_repeat_16] restore all used registers
jal $zero $$reta i0                     ; [fn end: big_array_repeat_16] return from call
DIFF------------------------------
.program:
.26                                     ; --- start of function: big_array_repeat_16 ---
pusha .26                               ; [fn init: big_array_repeat_16]: push all used registers to stack
move $$locbase $sp                      ; [fn init: big_array_repeat_16]: set locals base register
cfei i0                                 ; [fn init: big_array_repeat_16]: allocate: locals 0 byte(s), call args 0 slot(s)
.53
movi $r75 i0                            ; move parameter from branch to block argument
.54
move $r77 $r75                          ; move parameter from branch to block argument
muli $r79 $r75 i1                       ; get offset to array element
add $r79 $$arg0 $r79                    ; add array element offset to array base
sb $r79 $one i0                         ; store byte
addi $r80 $r77 i1
movi $r81 i25                           ; initialize constant into register
lt $r82 $r80 $r81
move $r75 $r80                          ; move parameter from branch to block argument
jnzi $r82 .54
.55
.27
cfsi i0                                 ; [fn end: big_array_repeat_16] free: locals 0 byte(s), call args 0 slot(s)
popa .26                                ; [fn end: big_array_repeat_16] restore all used registers
jal $zero $$reta i0                     ; [fn end: big_array_repeat_16] return from call
DIFF------------------------------
.program:
.28                                     ; --- start of function: u8_array_bigger_than_18_bits_17 ---
pusha .28                               ; [fn init: u8_array_bigger_than_18_bits_17]: push all used registers to stack
move $$locbase $sp                      ; [fn init: u8_array_bigger_than_18_bits_17]: set locals base register
cfei i0                                 ; [fn init: u8_array_bigger_than_18_bits_17]: allocate: locals 0 byte(s), call args 0 slot(s)
.56
load $$tmp data_NonConfigurable_1       ; loading clear size in bytes
mcl $$arg0 $$tmp                        ; clear memory [u8; 262145]
ji  .29
.29
cfsi i0                                 ; [fn end: u8_array_bigger_than_18_bits_17] free: locals 0 byte(s), call args 0 slot(s)
popa .28                                ; [fn end: u8_array_bigger_than_18_bits_17] restore all used registers
jal $zero $$reta i0                     ; [fn end: u8_array_bigger_than_18_bits_17] return from call
DIFF------------------------------
.program:
.28                                     ; --- start of function: u8_array_bigger_than_18_bits_17 ---
pusha .28                               ; [fn init: u8_array_bigger_than_18_bits_17]: push all used registers to stack
move $$locbase $sp                      ; [fn init: u8_array_bigger_than_18_bits_17]: set locals base register
cfei i0                                 ; [fn init: u8_array_bigger_than_18_bits_17]: allocate: locals 0 byte(s), call args 0 slot(s)
.56
load $$tmp data_NonConfigurable_1       ; loading clear size in bytes
mcl $$arg0 $$tmp                        ; clear memory [u8; 262145]
.29
cfsi i0                                 ; [fn end: u8_array_bigger_than_18_bits_17] free: locals 0 byte(s), call args 0 slot(s)
popa .28                                ; [fn end: u8_array_bigger_than_18_bits_17] restore all used registers
jal $zero $$reta i0                     ; [fn end: u8_array_bigger_than_18_bits_17] return from call
DIFF------------------------------
.program:
.28                                     ; --- start of function: u8_array_bigger_than_18_bits_17 ---
pusha .28                               ; [fn init: u8_array_bigger_than_18_bits_17]: push all used registers to stack
move $$locbase $sp                      ; [fn init: u8_array_bigger_than_18_bits_17]: set locals base register
cfei i0                                 ; [fn init: u8_array_bigger_than_18_bits_17]: allocate: locals 0 byte(s), call args 0 slot(s)
.56
load $$tmp data_NonConfigurable_1       ; loading clear size in bytes
mcl $$arg0 $$tmp                        ; clear memory [u8; 262145]
.29
cfsi i0                                 ; [fn end: u8_array_bigger_than_18_bits_17] free: locals 0 byte(s), call args 0 slot(s)
popa .28                                ; [fn end: u8_array_bigger_than_18_bits_17] restore all used registers
jal $zero $$reta i0                     ; [fn end: u8_array_bigger_than_18_bits_17] return from call
DIFF------------------------------
.program:
.28                                     ; --- start of function: u8_array_bigger_than_18_bits_17 ---
pusha .28                               ; [fn init: u8_array_bigger_than_18_bits_17]: push all used registers to stack
move $$locbase $sp                      ; [fn init: u8_array_bigger_than_18_bits_17]: set locals base register
cfei i0                                 ; [fn init: u8_array_bigger_than_18_bits_17]: allocate: locals 0 byte(s), call args 0 slot(s)
.56
load $$tmp data_NonConfigurable_1       ; loading clear size in bytes
mcl $$arg0 $$tmp                        ; clear memory [u8; 262145]
.29
cfsi i0                                 ; [fn end: u8_array_bigger_than_18_bits_17] free: locals 0 byte(s), call args 0 slot(s)
popa .28                                ; [fn end: u8_array_bigger_than_18_bits_17] restore all used registers
jal $zero $$reta i0                     ; [fn end: u8_array_bigger_than_18_bits_17] return from call
DIFF------------------------------
.program:
.30                                     ; --- start of function: arrays_with_const_length_18 ---
pusha .30                               ; [fn init: arrays_with_const_length_18]: push all used registers to stack
move $$locbase $sp                      ; [fn init: arrays_with_const_length_18]: set locals base register
cfei i0                                 ; [fn init: arrays_with_const_length_18]: allocate: locals 0 byte(s), call args 0 slot(s)
.57
ji  .31
.31
cfsi i0                                 ; [fn end: arrays_with_const_length_18] free: locals 0 byte(s), call args 0 slot(s)
popa .30                                ; [fn end: arrays_with_const_length_18] restore all used registers
jal $zero $$reta i0                     ; [fn end: arrays_with_const_length_18] return from call
DIFF------------------------------
.program:
.30                                     ; --- start of function: arrays_with_const_length_18 ---
pusha .30                               ; [fn init: arrays_with_const_length_18]: push all used registers to stack
move $$locbase $sp                      ; [fn init: arrays_with_const_length_18]: set locals base register
cfei i0                                 ; [fn init: arrays_with_const_length_18]: allocate: locals 0 byte(s), call args 0 slot(s)
.57
.31
cfsi i0                                 ; [fn end: arrays_with_const_length_18] free: locals 0 byte(s), call args 0 slot(s)
popa .30                                ; [fn end: arrays_with_const_length_18] restore all used registers
jal $zero $$reta i0                     ; [fn end: arrays_with_const_length_18] return from call
DIFF------------------------------
.program:
.30                                     ; --- start of function: arrays_with_const_length_18 ---
pusha .30                               ; [fn init: arrays_with_const_length_18]: push all used registers to stack
move $$locbase $sp                      ; [fn init: arrays_with_const_length_18]: set locals base register
cfei i0                                 ; [fn init: arrays_with_const_length_18]: allocate: locals 0 byte(s), call args 0 slot(s)
.57
.31
cfsi i0                                 ; [fn end: arrays_with_const_length_18] free: locals 0 byte(s), call args 0 slot(s)
popa .30                                ; [fn end: arrays_with_const_length_18] restore all used registers
jal $zero $$reta i0                     ; [fn end: arrays_with_const_length_18] return from call
DIFF------------------------------
.program:
.30                                     ; --- start of function: arrays_with_const_length_18 ---
pusha .30                               ; [fn init: arrays_with_const_length_18]: push all used registers to stack
move $$locbase $sp                      ; [fn init: arrays_with_const_length_18]: set locals base register
cfei i0                                 ; [fn init: arrays_with_const_length_18]: allocate: locals 0 byte(s), call args 0 slot(s)
.57
.31
cfsi i0                                 ; [fn end: arrays_with_const_length_18] free: locals 0 byte(s), call args 0 slot(s)
popa .30                                ; [fn end: arrays_with_const_length_18] restore all used registers
jal $zero $$reta i0                     ; [fn end: arrays_with_const_length_18] return from call
DIFF------------------------------
.program:
.32                                     ; --- start of function: decode_array_19 ---
pusha .32                               ; [fn init: decode_array_19]: push all used registers to stack
move $$locbase $sp                      ; [fn init: decode_array_19]: set locals base register
cfei i72                                ; [fn init: decode_array_19]: allocate: locals 72 byte(s), call args 0 slot(s)
move $r86 $$arg0                        ; [fn init: decode_array_19]: copy argument 0 (__ret_value)
move $r87 $$reta                        ; [fn init: decode_array_19]: save return address
.58
addi $r88 $$locbase i16                 ; get offset to local __ptr [u8; 1]
movi $r89 i1                            ; get array element size
 mul $r90 $zero $r89                     ; get offset to array element
 add $r90 $r88 $r90                      ; add array element offset to array base
 movi $r90 i0                            ; get offset to array element
 move $r90 $r88                          ; add array element offset to array base
movi $r91 i255                          ; initialize constant into register
 sb $r90 $r91 i0                         ; store byte
 sb $r88 $r91 i0                         ; store byte
addi $r92 $$locbase i16                 ; get offset to local __ptr [u8; 1]
addi $r93 $$locbase i24                 ; get offset to local __ptr slice
move $$arg0 $r92                        ; [call: to_slice_20]: pass argument 0
move $$arg1 $r93                        ; [call: to_slice_20]: pass argument 1
fncall .34                              ; [call: to_slice_20]: call function
 move $r94 $zero                         ; [call: to_slice_20]: copy returned unit value
 movi $r94 i0                            ; [call: to_slice_20]: copy returned unit value
addi $r95 $$locbase i40                 ; get offset to local __ptr slice
mcpi $r95 $r93 i16                      ; copy memory
addi $r96 $$locbase i40                 ; get offset to local __ptr slice
addi $r97 $$locbase i56                 ; get offset to local __ptr slice
mcpi $r97 $r96 i16                      ; copy memory
addi $r98 $$locbase i56                 ; get offset to local __ptr slice
move $r99 $r98                          ; return value from ASM block with return register ptr
lw $r100 $r98 i0                        ; load word
 addi $r101 $r99 i8                      ; get offset to aggregate element
 addi $r101 $r98 i8                      ; get offset to aggregate element
lw $r102 $r98 i1                        ; load word
sw $$locbase $r100 i0                   ; store word
addi $r103 $$locbase i8                 ; get offset to aggregate element
sw $$locbase $r102 i1                   ; store word
lw $r104 $$locbase i0                   ; load word
 move $r105 $one                         ; copy ASM block argument's constant initial value to register
 aloc $r105                              ; aloc size
 movi $r105 i1                           ; copy ASM block argument's constant initial value to register
 aloc $one                               ; aloc size
mcp $hp $r104 $r105                     ; mcp hp src size
move $r106 $hp                          ; return value from ASM block with return register hp
movi $r107 i1                           ; get array element size
 mul $r108 $zero $r107                   ; get offset to array element
 add $r108 $r106 $r108                   ; add array element offset to array base
 lb $r109 $r108 i0                       ; load byte
 movi $r108 i0                           ; get offset to array element
 move $r108 $hp                          ; add array element offset to array base
 lb $r109 $hp i0                         ; load byte
movi $r110 i1                           ; get array element size
 mul $r111 $zero $r110                   ; get offset to array element
 add $r111 $r86 $r111                    ; add array element offset to array base
 sb $r111 $r109 i0                       ; store byte
 movi $r111 i0                           ; get offset to array element
 move $r111 $r86                         ; add array element offset to array base
 sb $r86 $r109 i0                        ; store byte
ji  .33
.33
cfsi i72                                ; [fn end: decode_array_19] free: locals 72 byte(s), call args 0 slot(s)
move $$reta $r87                        ; [fn end: decode_array_19] restore return address
popa .32                                ; [fn end: decode_array_19] restore all used registers
jal $zero $$reta i0                     ; [fn end: decode_array_19] return from call
DIFF------------------------------
.program:
.32                                     ; --- start of function: decode_array_19 ---
pusha .32                               ; [fn init: decode_array_19]: push all used registers to stack
move $$locbase $sp                      ; [fn init: decode_array_19]: set locals base register
cfei i72                                ; [fn init: decode_array_19]: allocate: locals 72 byte(s), call args 0 slot(s)
move $r86 $$arg0                        ; [fn init: decode_array_19]: copy argument 0 (__ret_value)
move $r87 $$reta                        ; [fn init: decode_array_19]: save return address
.58
addi $r88 $$locbase i16                 ; get offset to local __ptr [u8; 1]
movi $r91 i255                          ; initialize constant into register
sb $r88 $r91 i0                         ; store byte
addi $r92 $$locbase i16                 ; get offset to local __ptr [u8; 1]
addi $r93 $$locbase i24                 ; get offset to local __ptr slice
move $$arg0 $r92                        ; [call: to_slice_20]: pass argument 0
move $$arg1 $r93                        ; [call: to_slice_20]: pass argument 1
fncall .34                              ; [call: to_slice_20]: call function
addi $r95 $$locbase i40                 ; get offset to local __ptr slice
mcpi $r95 $r93 i16                      ; copy memory
addi $r96 $$locbase i40                 ; get offset to local __ptr slice
addi $r97 $$locbase i56                 ; get offset to local __ptr slice
mcpi $r97 $r96 i16                      ; copy memory
addi $r98 $$locbase i56                 ; get offset to local __ptr slice
lw $r100 $$locbase i7                   ; load word
lw $r102 $$locbase i8                   ; load word
sw $$locbase $r100 i0                   ; store word
sw $$locbase $r102 i1                   ; store word
lw $r104 $$locbase i0                   ; load word
movi $r105 i1                           ; copy ASM block argument's constant initial value to register
aloc $one                               ; aloc size
mcp $hp $r104 $r105                     ; mcp hp src size
lb $r109 $hp i0                         ; load byte
sb $r86 $r109 i0                        ; store byte
.33
cfsi i72                                ; [fn end: decode_array_19] free: locals 72 byte(s), call args 0 slot(s)
move $$reta $r87                        ; [fn end: decode_array_19] restore return address
popa .32                                ; [fn end: decode_array_19] restore all used registers
jal $zero $$reta i0                     ; [fn end: decode_array_19] return from call
DIFF------------------------------
.program:
.32                                     ; --- start of function: decode_array_19 ---
pusha .32                               ; [fn init: decode_array_19]: push all used registers to stack
move $$locbase $sp                      ; [fn init: decode_array_19]: set locals base register
cfei i72                                ; [fn init: decode_array_19]: allocate: locals 72 byte(s), call args 0 slot(s)
move $r86 $$arg0                        ; [fn init: decode_array_19]: copy argument 0 (__ret_value)
move $r87 $$reta                        ; [fn init: decode_array_19]: save return address
.58
addi $r88 $$locbase i16                 ; get offset to local __ptr [u8; 1]
movi $r91 i255                          ; initialize constant into register
sb $r88 $r91 i0                         ; store byte
addi $r92 $$locbase i16                 ; get offset to local __ptr [u8; 1]
addi $r93 $$locbase i24                 ; get offset to local __ptr slice
move $$arg0 $r92                        ; [call: to_slice_20]: pass argument 0
move $$arg1 $r93                        ; [call: to_slice_20]: pass argument 1
fncall .34                              ; [call: to_slice_20]: call function
addi $r95 $$locbase i40                 ; get offset to local __ptr slice
mcpi $r95 $r93 i16                      ; copy memory
addi $r96 $$locbase i40                 ; get offset to local __ptr slice
addi $r97 $$locbase i56                 ; get offset to local __ptr slice
mcpi $r97 $r96 i16                      ; copy memory
lw $r100 $$locbase i7                   ; load word
lw $r102 $$locbase i8                   ; load word
sw $$locbase $r100 i0                   ; store word
sw $$locbase $r102 i1                   ; store word
lw $r104 $$locbase i0                   ; load word
movi $r105 i1                           ; copy ASM block argument's constant initial value to register
aloc $one                               ; aloc size
mcp $hp $r104 $r105                     ; mcp hp src size
lb $r109 $hp i0                         ; load byte
sb $r86 $r109 i0                        ; store byte
.33
cfsi i72                                ; [fn end: decode_array_19] free: locals 72 byte(s), call args 0 slot(s)
move $$reta $r87                        ; [fn end: decode_array_19] restore return address
popa .32                                ; [fn end: decode_array_19] restore all used registers
jal $zero $$reta i0                     ; [fn end: decode_array_19] return from call
DIFF------------------------------
.program:
.32                                     ; --- start of function: decode_array_19 ---
pusha .32                               ; [fn init: decode_array_19]: push all used registers to stack
move $$locbase $sp                      ; [fn init: decode_array_19]: set locals base register
cfei i72                                ; [fn init: decode_array_19]: allocate: locals 72 byte(s), call args 0 slot(s)
move $r86 $$arg0                        ; [fn init: decode_array_19]: copy argument 0 (__ret_value)
move $r87 $$reta                        ; [fn init: decode_array_19]: save return address
.58
addi $r88 $$locbase i16                 ; get offset to local __ptr [u8; 1]
movi $r91 i255                          ; initialize constant into register
sb $r88 $r91 i0                         ; store byte
addi $r92 $$locbase i16                 ; get offset to local __ptr [u8; 1]
addi $r93 $$locbase i24                 ; get offset to local __ptr slice
move $$arg0 $r92                        ; [call: to_slice_20]: pass argument 0
move $$arg1 $r93                        ; [call: to_slice_20]: pass argument 1
fncall .34                              ; [call: to_slice_20]: call function
addi $r95 $$locbase i40                 ; get offset to local __ptr slice
mcpi $r95 $r93 i16                      ; copy memory
addi $r96 $$locbase i40                 ; get offset to local __ptr slice
addi $r97 $$locbase i56                 ; get offset to local __ptr slice
mcpi $r97 $r96 i16                      ; copy memory
lw $r100 $$locbase i7                   ; load word
lw $r102 $$locbase i8                   ; load word
sw $$locbase $r100 i0                   ; store word
sw $$locbase $r102 i1                   ; store word
lw $r104 $$locbase i0                   ; load word
movi $r105 i1                           ; copy ASM block argument's constant initial value to register
aloc $one                               ; aloc size
mcp $hp $r104 $r105                     ; mcp hp src size
lb $r109 $hp i0                         ; load byte
sb $r86 $r109 i0                        ; store byte
.33
cfsi i72                                ; [fn end: decode_array_19] free: locals 72 byte(s), call args 0 slot(s)
move $$reta $r87                        ; [fn end: decode_array_19] restore return address
popa .32                                ; [fn end: decode_array_19] restore all used registers
jal $zero $$reta i0                     ; [fn end: decode_array_19] return from call
DIFF------------------------------
.program:
.34                                     ; --- start of function: to_slice_20 ---
pusha .34                               ; [fn init: to_slice_20]: push all used registers to stack
move $$locbase $sp                      ; [fn init: to_slice_20]: set locals base register
cfei i40                                ; [fn init: to_slice_20]: allocate: locals 40 byte(s), call args 0 slot(s)
.59
addi $r113 $$locbase i16                ; get offset to local __ptr [u8; 1]
mcpi $r113 $$arg0 i1                    ; copy memory
addi $r114 $$locbase i16                ; get offset to local __ptr [u8; 1]
addi $r115 $$locbase i24                ; get offset to local __ptr { ptr, u64 }
sw $$locbase $r114 i3                   ; store word
addi $r116 $r115 i8                     ; get offset to aggregate element
sw $$locbase $one i4                    ; store word
addi $r117 $$locbase i24                ; get offset to local __ptr { ptr, u64 }
move $r118 $r117                        ; return value from ASM block with return register ptr
 mcpi $$locbase $r118 i16                ; copy memory
 mcpi $$locbase $r117 i16                ; copy memory
mcpi $$arg1 $$locbase i16               ; copy memory
ji  .35
.35
cfsi i40                                ; [fn end: to_slice_20] free: locals 40 byte(s), call args 0 slot(s)
popa .34                                ; [fn end: to_slice_20] restore all used registers
jal $zero $$reta i0                     ; [fn end: to_slice_20] return from call
DIFF------------------------------
.program:
.34                                     ; --- start of function: to_slice_20 ---
pusha .34                               ; [fn init: to_slice_20]: push all used registers to stack
move $$locbase $sp                      ; [fn init: to_slice_20]: set locals base register
cfei i40                                ; [fn init: to_slice_20]: allocate: locals 40 byte(s), call args 0 slot(s)
.59
addi $r113 $$locbase i16                ; get offset to local __ptr [u8; 1]
mcpi $r113 $$arg0 i1                    ; copy memory
addi $r114 $$locbase i16                ; get offset to local __ptr [u8; 1]
sw $$locbase $r114 i3                   ; store word
sw $$locbase $one i4                    ; store word
addi $r117 $$locbase i24                ; get offset to local __ptr { ptr, u64 }
mcpi $$locbase $r117 i16                ; copy memory
mcpi $$arg1 $$locbase i16               ; copy memory
.35
cfsi i40                                ; [fn end: to_slice_20] free: locals 40 byte(s), call args 0 slot(s)
popa .34                                ; [fn end: to_slice_20] restore all used registers
jal $zero $$reta i0                     ; [fn end: to_slice_20] return from call
DIFF------------------------------
.program:
.34                                     ; --- start of function: to_slice_20 ---
pusha .34                               ; [fn init: to_slice_20]: push all used registers to stack
move $$locbase $sp                      ; [fn init: to_slice_20]: set locals base register
cfei i40                                ; [fn init: to_slice_20]: allocate: locals 40 byte(s), call args 0 slot(s)
.59
addi $r113 $$locbase i16                ; get offset to local __ptr [u8; 1]
mcpi $r113 $$arg0 i1                    ; copy memory
addi $r114 $$locbase i16                ; get offset to local __ptr [u8; 1]
sw $$locbase $r114 i3                   ; store word
sw $$locbase $one i4                    ; store word
addi $r117 $$locbase i24                ; get offset to local __ptr { ptr, u64 }
mcpi $$locbase $r117 i16                ; copy memory
mcpi $$arg1 $$locbase i16               ; copy memory
.35
cfsi i40                                ; [fn end: to_slice_20] free: locals 40 byte(s), call args 0 slot(s)
popa .34                                ; [fn end: to_slice_20] restore all used registers
jal $zero $$reta i0                     ; [fn end: to_slice_20] return from call
DIFF------------------------------
.program:
.34                                     ; --- start of function: to_slice_20 ---
pusha .34                               ; [fn init: to_slice_20]: push all used registers to stack
move $$locbase $sp                      ; [fn init: to_slice_20]: set locals base register
cfei i40                                ; [fn init: to_slice_20]: allocate: locals 40 byte(s), call args 0 slot(s)
.59
addi $r113 $$locbase i16                ; get offset to local __ptr [u8; 1]
mcpi $r113 $$arg0 i1                    ; copy memory
addi $r114 $$locbase i16                ; get offset to local __ptr [u8; 1]
sw $$locbase $r114 i3                   ; store word
sw $$locbase $one i4                    ; store word
addi $r117 $$locbase i24                ; get offset to local __ptr { ptr, u64 }
mcpi $$locbase $r117 i16                ; copy memory
mcpi $$arg1 $$locbase i16               ; copy memory
.35
cfsi i40                                ; [fn end: to_slice_20] free: locals 40 byte(s), call args 0 slot(s)
popa .34                                ; [fn end: to_slice_20] restore all used registers
jal $zero $$reta i0                     ; [fn end: to_slice_20] return from call
DIFF------------------------------
.program:
.36                                     ; --- start of function: log_46 ---
pusha .36                               ; [fn init: log_46]: push all used registers to stack
move $$locbase $sp                      ; [fn init: log_46]: set locals base register
cfei i40                                ; [fn init: log_46]: allocate: locals 40 byte(s), call args 0 slot(s)
.60
addi $r120 $$locbase i32                ; get offset to local __ptr u8
sb $r120 $$arg0 i0                      ; store byte
addi $r121 $$locbase i32                ; get offset to local __ptr u8
sw $$locbase $r121 i0                   ; store word
addi $r122 $$locbase i8                 ; get offset to aggregate element
sw $$locbase $one i1                    ; store word
addi $r123 $$locbase i16                ; get offset to local __ptr slice
mcpi $r123 $$locbase i16                ; copy memory
load $r124 data_NonConfigurable_2       ; load constant from data section
lw $r125 $$locbase i2                   ; load slice pointer for logging data
lw $r126 $$locbase i3                   ; load slice size for logging data
logd $zero $r124 $r125 $r126            ; log slice
ji  .37
.37
cfsi i40                                ; [fn end: log_46] free: locals 40 byte(s), call args 0 slot(s)
popa .36                                ; [fn end: log_46] restore all used registers
jal $zero $$reta i0                     ; [fn end: log_46] return from call
DIFF------------------------------
.program:
.36                                     ; --- start of function: log_46 ---
pusha .36                               ; [fn init: log_46]: push all used registers to stack
move $$locbase $sp                      ; [fn init: log_46]: set locals base register
cfei i40                                ; [fn init: log_46]: allocate: locals 40 byte(s), call args 0 slot(s)
.60
addi $r120 $$locbase i32                ; get offset to local __ptr u8
sb $r120 $$arg0 i0                      ; store byte
addi $r121 $$locbase i32                ; get offset to local __ptr u8
sw $$locbase $r121 i0                   ; store word
sw $$locbase $one i1                    ; store word
addi $r123 $$locbase i16                ; get offset to local __ptr slice
mcpi $r123 $$locbase i16                ; copy memory
load $r124 data_NonConfigurable_2       ; load constant from data section
lw $r125 $$locbase i2                   ; load slice pointer for logging data
lw $r126 $$locbase i3                   ; load slice size for logging data
logd $zero $r124 $r125 $r126            ; log slice
.37
cfsi i40                                ; [fn end: log_46] free: locals 40 byte(s), call args 0 slot(s)
popa .36                                ; [fn end: log_46] restore all used registers
jal $zero $$reta i0                     ; [fn end: log_46] return from call
DIFF------------------------------
.program:
.36                                     ; --- start of function: log_46 ---
pusha .36                               ; [fn init: log_46]: push all used registers to stack
move $$locbase $sp                      ; [fn init: log_46]: set locals base register
cfei i40                                ; [fn init: log_46]: allocate: locals 40 byte(s), call args 0 slot(s)
.60
addi $r120 $$locbase i32                ; get offset to local __ptr u8
sb $r120 $$arg0 i0                      ; store byte
addi $r121 $$locbase i32                ; get offset to local __ptr u8
sw $$locbase $r121 i0                   ; store word
sw $$locbase $one i1                    ; store word
addi $r123 $$locbase i16                ; get offset to local __ptr slice
mcpi $r123 $$locbase i16                ; copy memory
load $r124 data_NonConfigurable_2       ; load constant from data section
lw $r125 $$locbase i2                   ; load slice pointer for logging data
lw $r126 $$locbase i3                   ; load slice size for logging data
logd $zero $r124 $r125 $r126            ; log slice
.37
cfsi i40                                ; [fn end: log_46] free: locals 40 byte(s), call args 0 slot(s)
popa .36                                ; [fn end: log_46] restore all used registers
jal $zero $$reta i0                     ; [fn end: log_46] return from call
DIFF------------------------------
.program:
.36                                     ; --- start of function: log_46 ---
pusha .36                               ; [fn init: log_46]: push all used registers to stack
move $$locbase $sp                      ; [fn init: log_46]: set locals base register
cfei i40                                ; [fn init: log_46]: allocate: locals 40 byte(s), call args 0 slot(s)
.60
addi $r120 $$locbase i32                ; get offset to local __ptr u8
sb $r120 $$arg0 i0                      ; store byte
addi $r121 $$locbase i32                ; get offset to local __ptr u8
sw $$locbase $r121 i0                   ; store word
sw $$locbase $one i1                    ; store word
addi $r123 $$locbase i16                ; get offset to local __ptr slice
mcpi $r123 $$locbase i16                ; copy memory
load $r124 data_NonConfigurable_2       ; load constant from data section
lw $r125 $$locbase i2                   ; load slice pointer for logging data
lw $r126 $$locbase i3                   ; load slice size for logging data
logd $zero $r124 $r125 $r126            ; log slice
.37
cfsi i40                                ; [fn end: log_46] free: locals 40 byte(s), call args 0 slot(s)
popa .36                                ; [fn end: log_46] restore all used registers
jal $zero $$reta i0                     ; [fn end: log_46] return from call
;; ASM: Final program
;; Program kind: Script
.program:
move $$tmp $pc
jmpf $zero i4
DATA_SECTION_OFFSET[0..32]
DATA_SECTION_OFFSET[32..64]
CONFIGURABLES_OFFSET[0..32]
CONFIGURABLES_OFFSET[32..64]
lw   $$ds $$tmp i1
add  $$ds $$ds $$tmp
cfei i0                       ; allocate stack space for globals
move $$locbase $sp            ; [entry init: __entry]: set locals base register
jal  $$reta $pc i2            ; [call: main_0]: call function
retd  $zero $zero             ; [entry end: __entry] return slice
pshl i7                       ; [fn init: main_0]: push used low registers 16..40
pshh i524288                  ; [fn init: main_0]: push used high registers 40..64
move $$locbase $sp            ; [fn init: main_0]: set locals base register
cfei i264920                  ; [fn init: main_0]: allocate: locals 264920 byte(s), call args 0 slot(s)
move $r1 $$reta               ; [fn init: main_0]: save return address
move $$arg0 $$locbase         ; [call: array_repeat_zero_small_u8_1]: pass argument 0
jal  $$reta $pc i91           ; [call: array_repeat_zero_small_u8_1]: call function
addi $r0 $$locbase i8         ; get offset to local __ptr [u64; 5]
move $$arg0 $r0               ; [call: array_repeat_zero_small_u16_2]: pass argument 0
jal  $$reta $pc i92           ; [call: array_repeat_zero_small_u16_2]: call function
addi $r0 $$locbase i48        ; get offset to local __ptr [u64; 5]
move $$arg0 $r0               ; [call: array_repeat_zero_small_u16_2]: pass argument 0
jal  $$reta $pc i89           ; [call: array_repeat_zero_small_u16_2]: call function
movi $r0 i32989               ; get word offset to local from base
muli $r0 $r0 i8               ; get byte offset to local from base
add  $r0 $$locbase $r0        ; get absolute byte offset to local
move $$arg0 $r0               ; [call: array_repeat_zero_small_u16_2]: pass argument 0
jal  $$reta $pc i84           ; [call: array_repeat_zero_small_u16_2]: call function
movi $r0 i32994               ; get word offset to local from base
muli $r0 $r0 i8               ; get byte offset to local from base
add  $r0 $$locbase $r0        ; get absolute byte offset to local
move $$arg0 $r0               ; [call: array_repeat_zero_small_u256_5]: pass argument 0
jal  $$reta $pc i83           ; [call: array_repeat_zero_small_u256_5]: call function
movi $r0 i33014               ; get word offset to local from base
muli $r0 $r0 i8               ; get byte offset to local from base
add  $r0 $$locbase $r0        ; get absolute byte offset to local
move $$arg0 $r0               ; [call: array_repeat_zero_small_b256_6]: pass argument 0
jal  $$reta $pc i82           ; [call: array_repeat_zero_small_b256_6]: call function
movi $r0 i33034               ; get word offset to local from base
muli $r0 $r0 i8               ; get byte offset to local from base
add  $r0 $$locbase $r0        ; get absolute byte offset to local
move $$arg0 $r0               ; [call: array_repeat_zero_small_bool_7]: pass argument 0
jal  $$reta $pc i81           ; [call: array_repeat_zero_small_bool_7]: call function
movi $r0 i33035               ; get word offset to local from base
muli $r0 $r0 i8               ; get byte offset to local from base
add  $r0 $$locbase $r0        ; get absolute byte offset to local
move $$arg0 $r0               ; [call: array_repeat_zero_big_u8_8]: pass argument 0
jal  $$reta $pc i80           ; [call: array_repeat_zero_big_u8_8]: call function
movi $r0 i33039               ; get word offset to local from base
muli $r0 $r0 i8               ; get byte offset to local from base
add  $r0 $$locbase $r0        ; get absolute byte offset to local
move $$arg0 $r0               ; [call: array_repeat_zero_big_u32_10]: pass argument 0
jal  $$reta $pc i79           ; [call: array_repeat_zero_big_u32_10]: call function
movi $r0 i33064               ; get word offset to local from base
muli $r0 $r0 i8               ; get byte offset to local from base
add  $r0 $$locbase $r0        ; get absolute byte offset to local
move $$arg0 $r0               ; [call: array_repeat_zero_big_u32_10]: pass argument 0
jal  $$reta $pc i74           ; [call: array_repeat_zero_big_u32_10]: call function
movi $r0 i33089               ; get word offset to local from base
muli $r0 $r0 i8               ; get byte offset to local from base
add  $r0 $$locbase $r0        ; get absolute byte offset to local
move $$arg0 $r0               ; [call: array_repeat_zero_big_u32_10]: pass argument 0
jal  $$reta $pc i69           ; [call: array_repeat_zero_big_u32_10]: call function
addi $r0 $$locbase i88        ; get offset to local __ptr [u256; 25]
move $$arg0 $r0               ; [call: array_repeat_zero_big_u256_12]: pass argument 0
jal  $$reta $pc i70           ; [call: array_repeat_zero_big_u256_12]: call function
addi $r0 $$locbase i888       ; get offset to local __ptr [b256; 25]
move $$arg0 $r0               ; [call: array_repeat_zero_big_b256_13]: pass argument 0
jal  $$reta $pc i71           ; [call: array_repeat_zero_big_b256_13]: call function
addi $r0 $$locbase i1688      ; get offset to local __ptr [bool; 25]
move $$arg0 $r0               ; [call: array_repeat_zero_big_bool_14]: pass argument 0
jal  $$reta $pc i72           ; [call: array_repeat_zero_big_bool_14]: call function
addi $r0 $$locbase i1720      ; get offset to local __ptr [bool; 5]
move $$arg0 $r0               ; [call: small_array_repeat_15]: pass argument 0
jal  $$reta $pc i73           ; [call: small_array_repeat_15]: call function
addi $r0 $$locbase i1728      ; get offset to local __ptr [bool; 25]
move $$arg0 $r0               ; [call: big_array_repeat_16]: pass argument 0
jal  $$reta $pc i84           ; [call: big_array_repeat_16]: call function
addi $r0 $$locbase i1760      ; get offset to local __ptr [u8; 262145]
move $$arg0 $r0               ; [call: u8_array_bigger_than_18_bits_17]: pass argument 0
jal  $$reta $pc i94           ; [call: u8_array_bigger_than_18_bits_17]: call function
jal  $$reta $pc i98           ; [call: arrays_with_const_length_18]: call function
movi $r0 i33114               ; get word offset to local from base
muli $r0 $r0 i8               ; get byte offset to local from base
add  $r0 $$locbase $r0        ; get absolute byte offset to local
move $$arg0 $r0               ; [call: decode_array_19]: pass argument 0
jal  $$reta $pc i96           ; [call: decode_array_19]: call function
movi $r0 i33114               ; get word offset to local from base
muli $r0 $r0 i8               ; get byte offset to local from base
add  $r0 $$locbase $r0        ; get absolute byte offset to local
lb   $r0 $r0 i0               ; load byte
movi $r2 i255                 ; initialize constant into register
eq   $r2 $r0 $r2
eq   $r2 $r2 $zero
jnzf $r2 $zero i1
jmpf $zero i6
move $$arg0 $r0               ; [call: log_46]: pass argument 0
jal  $$reta $pc i135          ; [call: log_46]: call function
movi $$arg0 i255              ; [call: log_46]: pass argument 0
jal  $$reta $pc i133          ; [call: log_46]: call function
load $r0 data_NonConfigurable_0; load constant from data section
rvrt $r0
cfsi i264920                  ; [fn end: main_0] free: locals 264920 byte(s), call args 0 slot(s)
move $$reta $r1               ; [fn end: main_0] restore return address
poph i524288                  ; [fn end: main_0]: restore used high registers 40..64
popl i7                       ; [fn end: main_0]: restore used low registers 16..40
jal  $zero $$reta i0          ; [fn end: main_0] return from call
pshh i524288                  ; [fn init: array_repeat_zero_small_u8_1]: push used high registers 40..64
mcli $$arg0 i5                ; clear memory [u8; 5], 5 bytes
poph i524288                  ; [fn end: array_repeat_zero_small_u8_1]: restore used high registers 40..64
jal  $zero $$reta i0          ; [fn end: array_repeat_zero_small_u8_1] return from call
pshh i524288                  ; [fn init: array_repeat_zero_small_u16_2]: push used high registers 40..64
mcli $$arg0 i40               ; clear memory [u64; 5], 40 bytes
poph i524288                  ; [fn end: array_repeat_zero_small_u16_2]: restore used high registers 40..64
jal  $zero $$reta i0          ; [fn end: array_repeat_zero_small_u16_2] return from call
pshh i524288                  ; [fn init: array_repeat_zero_small_u256_5]: push used high registers 40..64
mcli $$arg0 i160              ; clear memory [u256; 5], 160 bytes
poph i524288                  ; [fn end: array_repeat_zero_small_u256_5]: restore used high registers 40..64
jal  $zero $$reta i0          ; [fn end: array_repeat_zero_small_u256_5] return from call
pshh i524288                  ; [fn init: array_repeat_zero_small_b256_6]: push used high registers 40..64
mcli $$arg0 i160              ; clear memory [b256; 5], 160 bytes
poph i524288                  ; [fn end: array_repeat_zero_small_b256_6]: restore used high registers 40..64
jal  $zero $$reta i0          ; [fn end: array_repeat_zero_small_b256_6] return from call
pshh i524288                  ; [fn init: array_repeat_zero_small_bool_7]: push used high registers 40..64
mcli $$arg0 i5                ; clear memory [bool; 5], 5 bytes
poph i524288                  ; [fn end: array_repeat_zero_small_bool_7]: restore used high registers 40..64
jal  $zero $$reta i0          ; [fn end: array_repeat_zero_small_bool_7] return from call
pshh i524288                  ; [fn init: array_repeat_zero_big_u8_8]: push used high registers 40..64
mcli $$arg0 i25               ; clear memory [u8; 25], 25 bytes
poph i524288                  ; [fn end: array_repeat_zero_big_u8_8]: restore used high registers 40..64
jal  $zero $$reta i0          ; [fn end: array_repeat_zero_big_u8_8] return from call
pshh i524288                  ; [fn init: array_repeat_zero_big_u32_10]: push used high registers 40..64
mcli $$arg0 i200              ; clear memory [u64; 25], 200 bytes
poph i524288                  ; [fn end: array_repeat_zero_big_u32_10]: restore used high registers 40..64
jal  $zero $$reta i0          ; [fn end: array_repeat_zero_big_u32_10] return from call
pshh i524288                  ; [fn init: array_repeat_zero_big_u256_12]: push used high registers 40..64
mcli $$arg0 i800              ; clear memory [u256; 25], 800 bytes
poph i524288                  ; [fn end: array_repeat_zero_big_u256_12]: restore used high registers 40..64
jal  $zero $$reta i0          ; [fn end: array_repeat_zero_big_u256_12] return from call
pshh i524288                  ; [fn init: array_repeat_zero_big_b256_13]: push used high registers 40..64
mcli $$arg0 i800              ; clear memory [b256; 25], 800 bytes
poph i524288                  ; [fn end: array_repeat_zero_big_b256_13]: restore used high registers 40..64
jal  $zero $$reta i0          ; [fn end: array_repeat_zero_big_b256_13] return from call
pshh i524288                  ; [fn init: array_repeat_zero_big_bool_14]: push used high registers 40..64
mcli $$arg0 i25               ; clear memory [bool; 25], 25 bytes
poph i524288                  ; [fn end: array_repeat_zero_big_bool_14]: restore used high registers 40..64
jal  $zero $$reta i0          ; [fn end: array_repeat_zero_big_bool_14] return from call
pshl i1                       ; [fn init: small_array_repeat_15]: push used low registers 16..40
pshh i524288                  ; [fn init: small_array_repeat_15]: push used high registers 40..64
sb   $$arg0 $one i0           ; store byte
addi $r0 $$arg0 i1            ; add array element offset to array base
sb   $r0 $one i0              ; store byte
addi $r0 $$arg0 i2            ; add array element offset to array base
sb   $r0 $one i0              ; store byte
addi $r0 $$arg0 i3            ; add array element offset to array base
sb   $r0 $one i0              ; store byte
addi $r0 $$arg0 i4            ; add array element offset to array base
sb   $r0 $one i0              ; store byte
poph i524288                  ; [fn end: small_array_repeat_15]: restore used high registers 40..64
popl i1                       ; [fn end: small_array_repeat_15]: restore used low registers 16..40
jal  $zero $$reta i0          ; [fn end: small_array_repeat_15] return from call
pshl i3                       ; [fn init: big_array_repeat_16]: push used low registers 16..40
pshh i524288                  ; [fn init: big_array_repeat_16]: push used high registers 40..64
movi $r1 i0                   ; move parameter from branch to block argument
muli $r0 $r1 i1               ; get offset to array element
add  $r0 $$arg0 $r0           ; add array element offset to array base
sb   $r0 $one i0              ; store byte
addi $r1 $r1 i1
movi $r0 i25                  ; initialize constant into register
lt   $r0 $r1 $r0
jnzb $r0 $zero i5
poph i524288                  ; [fn end: big_array_repeat_16]: restore used high registers 40..64
popl i3                       ; [fn end: big_array_repeat_16]: restore used low registers 16..40
jal  $zero $$reta i0          ; [fn end: big_array_repeat_16] return from call
pshh i524288                  ; [fn init: u8_array_bigger_than_18_bits_17]: push used high registers 40..64
load $$tmp data_NonConfigurable_1; loading clear size in bytes
mcl  $$arg0 $$tmp             ; clear memory [u8; 262145]
poph i524288                  ; [fn end: u8_array_bigger_than_18_bits_17]: restore used high registers 40..64
jal  $zero $$reta i0          ; [fn end: u8_array_bigger_than_18_bits_17] return from call
pshh i524288                  ; [fn init: arrays_with_const_length_18]: push used high registers 40..64
poph i524288                  ; [fn end: arrays_with_const_length_18]: restore used high registers 40..64
jal  $zero $$reta i0          ; [fn end: arrays_with_const_length_18] return from call
pshl i15                      ; [fn init: decode_array_19]: push used low registers 16..40
pshh i524288                  ; [fn init: decode_array_19]: push used high registers 40..64
move $$locbase $sp            ; [fn init: decode_array_19]: set locals base register
cfei i72                      ; [fn init: decode_array_19]: allocate: locals 72 byte(s), call args 0 slot(s)
move $r2 $$arg0               ; [fn init: decode_array_19]: copy argument 0 (__ret_value)
move $r3 $$reta               ; [fn init: decode_array_19]: save return address
addi $r0 $$locbase i16        ; get offset to local __ptr [u8; 1]
movi $r1 i255                 ; initialize constant into register
sb   $r0 $r1 i0               ; store byte
addi $r0 $$locbase i16        ; get offset to local __ptr [u8; 1]
addi $r1 $$locbase i24        ; get offset to local __ptr slice
move $$arg0 $r0               ; [call: to_slice_20]: pass argument 0
move $$arg1 $r1               ; [call: to_slice_20]: pass argument 1
jal  $$reta $pc i21           ; [call: to_slice_20]: call function
addi $r0 $$locbase i40        ; get offset to local __ptr slice
mcpi $r0 $r1 i16              ; copy memory
addi $r0 $$locbase i40        ; get offset to local __ptr slice
addi $r1 $$locbase i56        ; get offset to local __ptr slice
mcpi $r1 $r0 i16              ; copy memory
lw   $r0 $$locbase i7         ; load word
lw   $r1 $$locbase i8         ; load word
sw   $$locbase $r0 i0         ; store word
sw   $$locbase $r1 i1         ; store word
lw   $r0 $$locbase i0         ; load word
movi $r1 i1                   ; copy ASM block argument's constant initial value to register
aloc $one                     ; aloc size
mcp  $hp $r0 $r1              ; mcp hp src size
lb   $r0 $hp i0               ; load byte
sb   $r2 $r0 i0               ; store byte
cfsi i72                      ; [fn end: decode_array_19] free: locals 72 byte(s), call args 0 slot(s)
move $$reta $r3               ; [fn end: decode_array_19] restore return address
poph i524288                  ; [fn end: decode_array_19]: restore used high registers 40..64
popl i15                      ; [fn end: decode_array_19]: restore used low registers 16..40
jal  $zero $$reta i0          ; [fn end: decode_array_19] return from call
pshl i1                       ; [fn init: to_slice_20]: push used low registers 16..40
pshh i524288                  ; [fn init: to_slice_20]: push used high registers 40..64
move $$locbase $sp            ; [fn init: to_slice_20]: set locals base register
cfei i40                      ; [fn init: to_slice_20]: allocate: locals 40 byte(s), call args 0 slot(s)
addi $r0 $$locbase i16        ; get offset to local __ptr [u8; 1]
mcpi $r0 $$arg0 i1            ; copy memory
addi $r0 $$locbase i16        ; get offset to local __ptr [u8; 1]
sw   $$locbase $r0 i3         ; store word
sw   $$locbase $one i4        ; store word
addi $r0 $$locbase i24        ; get offset to local __ptr { ptr, u64 }
mcpi $$locbase $r0 i16        ; copy memory
mcpi $$arg1 $$locbase i16     ; copy memory
cfsi i40                      ; [fn end: to_slice_20] free: locals 40 byte(s), call args 0 slot(s)
poph i524288                  ; [fn end: to_slice_20]: restore used high registers 40..64
popl i1                       ; [fn end: to_slice_20]: restore used low registers 16..40
jal  $zero $$reta i0          ; [fn end: to_slice_20] return from call
pshl i7                       ; [fn init: log_46]: push used low registers 16..40
pshh i524288                  ; [fn init: log_46]: push used high registers 40..64
move $$locbase $sp            ; [fn init: log_46]: set locals base register
cfei i40                      ; [fn init: log_46]: allocate: locals 40 byte(s), call args 0 slot(s)
addi $r0 $$locbase i32        ; get offset to local __ptr u8
sb   $r0 $$arg0 i0            ; store byte
addi $r0 $$locbase i32        ; get offset to local __ptr u8
sw   $$locbase $r0 i0         ; store word
sw   $$locbase $one i1        ; store word
addi $r0 $$locbase i16        ; get offset to local __ptr slice
mcpi $r0 $$locbase i16        ; copy memory
load $r0 data_NonConfigurable_2; load constant from data section
lw   $r1 $$locbase i2         ; load slice pointer for logging data
lw   $r2 $$locbase i3         ; load slice size for logging data
logd $zero $r0 $r1 $r2        ; log slice
cfsi i40                      ; [fn end: log_46] free: locals 40 byte(s), call args 0 slot(s)
poph i524288                  ; [fn end: log_46]: restore used high registers 40..64
popl i7                       ; [fn end: log_46]: restore used low registers 16..40
jal  $zero $$reta i0          ; [fn end: log_46] return from call
.data:
data_NonConfigurable_0 .word 18446744073709486083
data_NonConfigurable_1 .word 262145
data_NonConfigurable_2 .word 14454674236531057292


;; --- START OF TARGET BYTECODE ---

0x00000000 MOVE R60 $pc                                    ;; [26, 240, 48, 0]
0x00000004 JMPF $zero 0x4                                  ;; [116, 0, 0, 4]
0x00000008                                                 ;; [0, 0, 0, 0, 0, 0, 3, 240]
0x00000010                                                 ;; [0, 0, 0, 0, 0, 0, 0, 0]
0x00000018 LW R63 R60 0x1                                  ;; [93, 255, 192, 1]
0x0000001c ADD R63 R63 R60                                 ;; [16, 255, 255, 0]
0x00000020 MOVE R59 $sp                                    ;; [26, 236, 80, 0]
0x00000024 JAL R62 $pc 0x2                                 ;; [153, 248, 48, 2]
0x00000028 RETD $zero $zero                                ;; [37, 0, 0, 0]
0x0000002c PSHL 0x7                                        ;; [149, 0, 0, 7]
0x00000030 PSHH 0x80000                                    ;; [150, 8, 0, 0]
0x00000034 MOVE R59 $sp                                    ;; [26, 236, 80, 0]
0x00000038 CFEI 0x40ad8                                    ;; [145, 4, 10, 216]
0x0000003c MOVE R17 R62                                    ;; [26, 71, 224, 0]
0x00000040 MOVE R58 R59                                    ;; [26, 235, 176, 0]
0x00000044 JAL R62 $pc 0x5b                                ;; [153, 248, 48, 91]
0x00000048 ADDI $writable R59 0x8                          ;; [80, 67, 176, 8]
0x0000004c MOVE R58 $writable                              ;; [26, 233, 0, 0]
0x00000050 JAL R62 $pc 0x5c                                ;; [153, 248, 48, 92]
0x00000054 ADDI $writable R59 0x30                         ;; [80, 67, 176, 48]
0x00000058 MOVE R58 $writable                              ;; [26, 233, 0, 0]
0x0000005c JAL R62 $pc 0x59                                ;; [153, 248, 48, 89]
0x00000060 MOVI $writable 0x80dd                           ;; [114, 64, 128, 221]
0x00000064 MULI $writable $writable 0x8                    ;; [85, 65, 0, 8]
0x00000068 ADD $writable R59 $writable                     ;; [16, 67, 180, 0]
0x0000006c MOVE R58 $writable                              ;; [26, 233, 0, 0]
0x00000070 JAL R62 $pc 0x54                                ;; [153, 248, 48, 84]
0x00000074 MOVI $writable 0x80e2                           ;; [114, 64, 128, 226]
0x00000078 MULI $writable $writable 0x8                    ;; [85, 65, 0, 8]
0x0000007c ADD $writable R59 $writable                     ;; [16, 67, 180, 0]
0x00000080 MOVE R58 $writable                              ;; [26, 233, 0, 0]
0x00000084 JAL R62 $pc 0x53                                ;; [153, 248, 48, 83]
0x00000088 MOVI $writable 0x80f6                           ;; [114, 64, 128, 246]
0x0000008c MULI $writable $writable 0x8                    ;; [85, 65, 0, 8]
0x00000090 ADD $writable R59 $writable                     ;; [16, 67, 180, 0]
0x00000094 MOVE R58 $writable                              ;; [26, 233, 0, 0]
0x00000098 JAL R62 $pc 0x52                                ;; [153, 248, 48, 82]
0x0000009c MOVI $writable 0x810a                           ;; [114, 64, 129, 10]
0x000000a0 MULI $writable $writable 0x8                    ;; [85, 65, 0, 8]
0x000000a4 ADD $writable R59 $writable                     ;; [16, 67, 180, 0]
0x000000a8 MOVE R58 $writable                              ;; [26, 233, 0, 0]
0x000000ac JAL R62 $pc 0x51                                ;; [153, 248, 48, 81]
0x000000b0 MOVI $writable 0x810b                           ;; [114, 64, 129, 11]
0x000000b4 MULI $writable $writable 0x8                    ;; [85, 65, 0, 8]
0x000000b8 ADD $writable R59 $writable                     ;; [16, 67, 180, 0]
0x000000bc MOVE R58 $writable                              ;; [26, 233, 0, 0]
0x000000c0 JAL R62 $pc 0x50                                ;; [153, 248, 48, 80]
0x000000c4 MOVI $writable 0x810f                           ;; [114, 64, 129, 15]
0x000000c8 MULI $writable $writable 0x8                    ;; [85, 65, 0, 8]
0x000000cc ADD $writable R59 $writable                     ;; [16, 67, 180, 0]
0x000000d0 MOVE R58 $writable                              ;; [26, 233, 0, 0]
0x000000d4 JAL R62 $pc 0x4f                                ;; [153, 248, 48, 79]
0x000000d8 MOVI $writable 0x8128                           ;; [114, 64, 129, 40]
0x000000dc MULI $writable $writable 0x8                    ;; [85, 65, 0, 8]
0x000000e0 ADD $writable R59 $writable                     ;; [16, 67, 180, 0]
0x000000e4 MOVE R58 $writable                              ;; [26, 233, 0, 0]
0x000000e8 JAL R62 $pc 0x4a                                ;; [153, 248, 48, 74]
0x000000ec MOVI $writable 0x8141                           ;; [114, 64, 129, 65]
0x000000f0 MULI $writable $writable 0x8                    ;; [85, 65, 0, 8]
0x000000f4 ADD $writable R59 $writable                     ;; [16, 67, 180, 0]
0x000000f8 MOVE R58 $writable                              ;; [26, 233, 0, 0]
0x000000fc JAL R62 $pc 0x45                                ;; [153, 248, 48, 69]
0x00000100 ADDI $writable R59 0x58                         ;; [80, 67, 176, 88]
0x00000104 MOVE R58 $writable                              ;; [26, 233, 0, 0]
0x00000108 JAL R62 $pc 0x46                                ;; [153, 248, 48, 70]
0x0000010c ADDI $writable R59 0x378                        ;; [80, 67, 179, 120]
0x00000110 MOVE R58 $writable                              ;; [26, 233, 0, 0]
0x00000114 JAL R62 $pc 0x47                                ;; [153, 248, 48, 71]
0x00000118 ADDI $writable R59 0x698                        ;; [80, 67, 182, 152]
0x0000011c MOVE R58 $writable                              ;; [26, 233, 0, 0]
0x00000120 JAL R62 $pc 0x48                                ;; [153, 248, 48, 72]
0x00000124 ADDI $writable R59 0x6b8                        ;; [80, 67, 182, 184]
0x00000128 MOVE R58 $writable                              ;; [26, 233, 0, 0]
0x0000012c JAL R62 $pc 0x49                                ;; [153, 248, 48, 73]
0x00000130 ADDI $writable R59 0x6c0                        ;; [80, 67, 182, 192]
0x00000134 MOVE R58 $writable                              ;; [26, 233, 0, 0]
0x00000138 JAL R62 $pc 0x54                                ;; [153, 248, 48, 84]
0x0000013c ADDI $writable R59 0x6e0                        ;; [80, 67, 182, 224]
0x00000140 MOVE R58 $writable                              ;; [26, 233, 0, 0]
0x00000144 JAL R62 $pc 0x5e                                ;; [153, 248, 48, 94]
0x00000148 JAL R62 $pc 0x62                                ;; [153, 248, 48, 98]
0x0000014c MOVI $writable 0x815a                           ;; [114, 64, 129, 90]
0x00000150 MULI $writable $writable 0x8                    ;; [85, 65, 0, 8]
0x00000154 ADD $writable R59 $writable                     ;; [16, 67, 180, 0]
0x00000158 MOVE R58 $writable                              ;; [26, 233, 0, 0]
0x0000015c JAL R62 $pc 0x60                                ;; [153, 248, 48, 96]
0x00000160 MOVI $writable 0x815a                           ;; [114, 64, 129, 90]
0x00000164 MULI $writable $writable 0x8                    ;; [85, 65, 0, 8]
0x00000168 ADD $writable R59 $writable                     ;; [16, 67, 180, 0]
0x0000016c LB $writable $writable 0x0                      ;; [92, 65, 0, 0]
0x00000170 MOVI R18 0xff                                   ;; [114, 72, 0, 255]
0x00000174 EQ R18 $writable R18                            ;; [19, 73, 4, 128]
0x00000178 EQ R18 R18 $zero                                ;; [19, 73, 32, 0]
0x0000017c JNZF R18 $zero 0x1                              ;; [118, 72, 0, 1]
0x00000180 JMPF $zero 0x6                                  ;; [116, 0, 0, 6]
0x00000184 MOVE R58 $writable                              ;; [26, 233, 0, 0]
0x00000188 JAL R62 $pc 0x87                                ;; [153, 248, 48, 135]
0x0000018c MOVI R58 0xff                                   ;; [114, 232, 0, 255]
0x00000190 JAL R62 $pc 0x85                                ;; [153, 248, 48, 133]
0x00000194 LW $writable R63 0x0                            ;; [93, 67, 240, 0]
0x00000198 RVRT $writable                                  ;; [54, 64, 0, 0]
0x0000019c CFSI 0x40ad8                                    ;; [146, 4, 10, 216]
0x000001a0 MOVE R62 R17                                    ;; [26, 249, 16, 0]
0x000001a4 POPH 0x80000                                    ;; [152, 8, 0, 0]
0x000001a8 POPL 0x7                                        ;; [151, 0, 0, 7]
0x000001ac JAL $zero R62 0x0                               ;; [153, 3, 224, 0]
0x000001b0 PSHH 0x80000                                    ;; [150, 8, 0, 0]
0x000001b4 MCLI R58 0x5                                    ;; [112, 232, 0, 5]
0x000001b8 POPH 0x80000                                    ;; [152, 8, 0, 0]
0x000001bc JAL $zero R62 0x0                               ;; [153, 3, 224, 0]
0x000001c0 PSHH 0x80000                                    ;; [150, 8, 0, 0]
0x000001c4 MCLI R58 0x28                                   ;; [112, 232, 0, 40]
0x000001c8 POPH 0x80000                                    ;; [152, 8, 0, 0]
0x000001cc JAL $zero R62 0x0                               ;; [153, 3, 224, 0]
0x000001d0 PSHH 0x80000                                    ;; [150, 8, 0, 0]
0x000001d4 MCLI R58 0xa0                                   ;; [112, 232, 0, 160]
0x000001d8 POPH 0x80000                                    ;; [152, 8, 0, 0]
0x000001dc JAL $zero R62 0x0                               ;; [153, 3, 224, 0]
0x000001e0 PSHH 0x80000                                    ;; [150, 8, 0, 0]
0x000001e4 MCLI R58 0xa0                                   ;; [112, 232, 0, 160]
0x000001e8 POPH 0x80000                                    ;; [152, 8, 0, 0]
0x000001ec JAL $zero R62 0x0                               ;; [153, 3, 224, 0]
0x000001f0 PSHH 0x80000                                    ;; [150, 8, 0, 0]
0x000001f4 MCLI R58 0x5                                    ;; [112, 232, 0, 5]
0x000001f8 POPH 0x80000                                    ;; [152, 8, 0, 0]
0x000001fc JAL $zero R62 0x0                               ;; [153, 3, 224, 0]
0x00000200 PSHH 0x80000                                    ;; [150, 8, 0, 0]
0x00000204 MCLI R58 0x19                                   ;; [112, 232, 0, 25]
0x00000208 POPH 0x80000                                    ;; [152, 8, 0, 0]
0x0000020c JAL $zero R62 0x0                               ;; [153, 3, 224, 0]
0x00000210 PSHH 0x80000                                    ;; [150, 8, 0, 0]
0x00000214 MCLI R58 0xc8                                   ;; [112, 232, 0, 200]
0x00000218 POPH 0x80000                                    ;; [152, 8, 0, 0]
0x0000021c JAL $zero R62 0x0                               ;; [153, 3, 224, 0]
0x00000220 PSHH 0x80000                                    ;; [150, 8, 0, 0]
0x00000224 MCLI R58 0x320                                  ;; [112, 232, 3, 32]
0x00000228 POPH 0x80000                                    ;; [152, 8, 0, 0]
0x0000022c JAL $zero R62 0x0                               ;; [153, 3, 224, 0]
0x00000230 PSHH 0x80000                                    ;; [150, 8, 0, 0]
0x00000234 MCLI R58 0x320                                  ;; [112, 232, 3, 32]
0x00000238 POPH 0x80000                                    ;; [152, 8, 0, 0]
0x0000023c JAL $zero R62 0x0                               ;; [153, 3, 224, 0]
0x00000240 PSHH 0x80000                                    ;; [150, 8, 0, 0]
0x00000244 MCLI R58 0x19                                   ;; [112, 232, 0, 25]
0x00000248 POPH 0x80000                                    ;; [152, 8, 0, 0]
0x0000024c JAL $zero R62 0x0                               ;; [153, 3, 224, 0]
0x00000250 PSHL 0x1                                        ;; [149, 0, 0, 1]
0x00000254 PSHH 0x80000                                    ;; [150, 8, 0, 0]
0x00000258 SB R58 $one 0x0                                 ;; [94, 232, 16, 0]
0x0000025c ADDI $writable R58 0x1                          ;; [80, 67, 160, 1]
0x00000260 SB $writable $one 0x0                           ;; [94, 64, 16, 0]
0x00000264 ADDI $writable R58 0x2                          ;; [80, 67, 160, 2]
0x00000268 SB $writable $one 0x0                           ;; [94, 64, 16, 0]
0x0000026c ADDI $writable R58 0x3                          ;; [80, 67, 160, 3]
0x00000270 SB $writable $one 0x0                           ;; [94, 64, 16, 0]
0x00000274 ADDI $writable R58 0x4                          ;; [80, 67, 160, 4]
0x00000278 SB $writable $one 0x0                           ;; [94, 64, 16, 0]
0x0000027c POPH 0x80000                                    ;; [152, 8, 0, 0]
0x00000280 POPL 0x1                                        ;; [151, 0, 0, 1]
0x00000284 JAL $zero R62 0x0                               ;; [153, 3, 224, 0]
0x00000288 PSHL 0x3                                        ;; [149, 0, 0, 3]
0x0000028c PSHH 0x80000                                    ;; [150, 8, 0, 0]
0x00000290 MOVI R17 0x0                                    ;; [114, 68, 0, 0]
0x00000294 MULI $writable R17 0x1                          ;; [85, 65, 16, 1]
0x00000298 ADD $writable R58 $writable                     ;; [16, 67, 164, 0]
0x0000029c SB $writable $one 0x0                           ;; [94, 64, 16, 0]
0x000002a0 ADDI R17 R17 0x1                                ;; [80, 69, 16, 1]
0x000002a4 MOVI $writable 0x19                             ;; [114, 64, 0, 25]
0x000002a8 LT $writable R17 $writable                      ;; [22, 65, 20, 0]
0x000002ac JNZB $writable $zero 0x5                        ;; [119, 64, 0, 5]
0x000002b0 POPH 0x80000                                    ;; [152, 8, 0, 0]
0x000002b4 POPL 0x3                                        ;; [151, 0, 0, 3]
0x000002b8 JAL $zero R62 0x0                               ;; [153, 3, 224, 0]
0x000002bc PSHH 0x80000                                    ;; [150, 8, 0, 0]
0x000002c0 LW R60 R63 0x1                                  ;; [93, 243, 240, 1]
0x000002c4 MCL R58 R60                                     ;; [39, 235, 192, 0]
0x000002c8 POPH 0x80000                                    ;; [152, 8, 0, 0]
0x000002cc JAL $zero R62 0x0                               ;; [153, 3, 224, 0]
0x000002d0 PSHH 0x80000                                    ;; [150, 8, 0, 0]
0x000002d4 POPH 0x80000                                    ;; [152, 8, 0, 0]
0x000002d8 JAL $zero R62 0x0                               ;; [153, 3, 224, 0]
0x000002dc PSHL 0xf                                        ;; [149, 0, 0, 15]
0x000002e0 PSHH 0x80000                                    ;; [150, 8, 0, 0]
0x000002e4 MOVE R59 $sp                                    ;; [26, 236, 80, 0]
0x000002e8 CFEI 0x48                                       ;; [145, 0, 0, 72]
0x000002ec MOVE R18 R58                                    ;; [26, 75, 160, 0]
0x000002f0 MOVE R19 R62                                    ;; [26, 79, 224, 0]
0x000002f4 ADDI $writable R59 0x10                         ;; [80, 67, 176, 16]
0x000002f8 MOVI R17 0xff                                   ;; [114, 68, 0, 255]
0x000002fc SB $writable R17 0x0                            ;; [94, 65, 16, 0]
0x00000300 ADDI $writable R59 0x10                         ;; [80, 67, 176, 16]
0x00000304 ADDI R17 R59 0x18                               ;; [80, 71, 176, 24]
0x00000308 MOVE R58 $writable                              ;; [26, 233, 0, 0]
0x0000030c MOVE R57 R17                                    ;; [26, 229, 16, 0]
0x00000310 JAL R62 $pc 0x15                                ;; [153, 248, 48, 21]
0x00000314 ADDI $writable R59 0x28                         ;; [80, 67, 176, 40]
0x00000318 MCPI $writable R17 0x10                         ;; [96, 65, 16, 16]
0x0000031c ADDI $writable R59 0x28                         ;; [80, 67, 176, 40]
0x00000320 ADDI R17 R59 0x38                               ;; [80, 71, 176, 56]
0x00000324 MCPI R17 $writable 0x10                         ;; [96, 69, 0, 16]
0x00000328 LW $writable R59 0x7                            ;; [93, 67, 176, 7]
0x0000032c LW R17 R59 0x8                                  ;; [93, 71, 176, 8]
0x00000330 SW R59 $writable 0x0                            ;; [95, 237, 0, 0]
0x00000334 SW R59 R17 0x1                                  ;; [95, 237, 16, 1]
0x00000338 LW $writable R59 0x0                            ;; [93, 67, 176, 0]
0x0000033c MOVI R17 0x1                                    ;; [114, 68, 0, 1]
0x00000340 ALOC $one                                       ;; [38, 4, 0, 0]
0x00000344 MCP $hp $writable R17                           ;; [40, 29, 4, 64]
0x00000348 LB $writable $hp 0x0                            ;; [92, 64, 112, 0]
0x0000034c SB R18 $writable 0x0                            ;; [94, 73, 0, 0]
0x00000350 CFSI 0x48                                       ;; [146, 0, 0, 72]
0x00000354 MOVE R62 R19                                    ;; [26, 249, 48, 0]
0x00000358 POPH 0x80000                                    ;; [152, 8, 0, 0]
0x0000035c POPL 0xf                                        ;; [151, 0, 0, 15]
0x00000360 JAL $zero R62 0x0                               ;; [153, 3, 224, 0]
0x00000364 PSHL 0x1                                        ;; [149, 0, 0, 1]
0x00000368 PSHH 0x80000                                    ;; [150, 8, 0, 0]
0x0000036c MOVE R59 $sp                                    ;; [26, 236, 80, 0]
0x00000370 CFEI 0x28                                       ;; [145, 0, 0, 40]
0x00000374 ADDI $writable R59 0x10                         ;; [80, 67, 176, 16]
0x00000378 MCPI $writable R58 0x1                          ;; [96, 67, 160, 1]
0x0000037c ADDI $writable R59 0x10                         ;; [80, 67, 176, 16]
0x00000380 SW R59 $writable 0x3                            ;; [95, 237, 0, 3]
0x00000384 SW R59 $one 0x4                                 ;; [95, 236, 16, 4]
0x00000388 ADDI $writable R59 0x18                         ;; [80, 67, 176, 24]
0x0000038c MCPI R59 $writable 0x10                         ;; [96, 237, 0, 16]
0x00000390 MCPI R57 R59 0x10                               ;; [96, 231, 176, 16]
0x00000394 CFSI 0x28                                       ;; [146, 0, 0, 40]
0x00000398 POPH 0x80000                                    ;; [152, 8, 0, 0]
0x0000039c POPL 0x1                                        ;; [151, 0, 0, 1]
0x000003a0 JAL $zero R62 0x0                               ;; [153, 3, 224, 0]
0x000003a4 PSHL 0x7                                        ;; [149, 0, 0, 7]
0x000003a8 PSHH 0x80000                                    ;; [150, 8, 0, 0]
0x000003ac MOVE R59 $sp                                    ;; [26, 236, 80, 0]
0x000003b0 CFEI 0x28                                       ;; [145, 0, 0, 40]
0x000003b4 ADDI $writable R59 0x20                         ;; [80, 67, 176, 32]
0x000003b8 SB $writable R58 0x0                            ;; [94, 67, 160, 0]
0x000003bc ADDI $writable R59 0x20                         ;; [80, 67, 176, 32]
0x000003c0 SW R59 $writable 0x0                            ;; [95, 237, 0, 0]
0x000003c4 SW R59 $one 0x1                                 ;; [95, 236, 16, 1]
0x000003c8 ADDI $writable R59 0x10                         ;; [80, 67, 176, 16]
0x000003cc MCPI $writable R59 0x10                         ;; [96, 67, 176, 16]
0x000003d0 LW $writable R63 0x2                            ;; [93, 67, 240, 2]
0x000003d4 LW R17 R59 0x2                                  ;; [93, 71, 176, 2]
0x000003d8 LW R18 R59 0x3                                  ;; [93, 75, 176, 3]
0x000003dc LOGD $zero $writable R17 R18                    ;; [52, 1, 4, 82]
0x000003e0 CFSI 0x28                                       ;; [146, 0, 0, 40]
0x000003e4 POPH 0x80000                                    ;; [152, 8, 0, 0]
0x000003e8 POPL 0x7                                        ;; [151, 0, 0, 7]
0x000003ec JAL $zero R62 0x0                               ;; [153, 3, 224, 0]
.data_section:
0x000003f0 .word i18446744073709486083, as hex be bytes ([FF, FF, FF, FF, FF, FF, 00, 03])
0x000003f8 .word i262145, as hex be bytes ([00, 00, 00, 00, 00, 04, 00, 01])
0x00000400 .word i14454674236531057292, as hex be bytes ([C8, 99, 51, A2, 4C, 6C, A2, 8C])
;; --- END OF TARGET BYTECODE ---

warning
   --> test/src/e2e_vm_tests/test_programs/should_pass/language/array/array_repeat/src/main.sw:156:24
    |
154 | 
155 | // TODO-DCA: Fix DCA warning that `is_zero` methods are never called. See: https://github.com/FuelLabs/sway/issues/5921.
156 | impl IsZero for bool { fn is_zero(self) -> bool { self == false }}
    |                        ------------------------------------------ This method is never called.
157 | impl IsZero for u8 { fn is_zero(self) -> bool { self == 0 }}
158 | impl IsZero for u16 { fn is_zero(self) -> bool { self == 0 }}
    |
____

warning
   --> test/src/e2e_vm_tests/test_programs/should_pass/language/array/array_repeat/src/main.sw:157:22
    |
155 | // TODO-DCA: Fix DCA warning that `is_zero` methods are never called. See: https://github.com/FuelLabs/sway/issues/5921.
156 | impl IsZero for bool { fn is_zero(self) -> bool { self == false }}
157 | impl IsZero for u8 { fn is_zero(self) -> bool { self == 0 }}
    |                      -------------------------------------- This method is never called.
158 | impl IsZero for u16 { fn is_zero(self) -> bool { self == 0 }}
159 | impl IsZero for u32 { fn is_zero(self) -> bool { self == 0 }}
    |
____

warning
   --> test/src/e2e_vm_tests/test_programs/should_pass/language/array/array_repeat/src/main.sw:158:23
    |
156 | impl IsZero for bool { fn is_zero(self) -> bool { self == false }}
157 | impl IsZero for u8 { fn is_zero(self) -> bool { self == 0 }}
158 | impl IsZero for u16 { fn is_zero(self) -> bool { self == 0 }}
    |                       -------------------------------------- This method is never called.
159 | impl IsZero for u32 { fn is_zero(self) -> bool { self == 0 }}
160 | impl IsZero for u64 { fn is_zero(self) -> bool { self == 0 }}
    |
____

warning
   --> test/src/e2e_vm_tests/test_programs/should_pass/language/array/array_repeat/src/main.sw:159:23
    |
157 | impl IsZero for u8 { fn is_zero(self) -> bool { self == 0 }}
158 | impl IsZero for u16 { fn is_zero(self) -> bool { self == 0 }}
159 | impl IsZero for u32 { fn is_zero(self) -> bool { self == 0 }}
    |                       -------------------------------------- This method is never called.
160 | impl IsZero for u64 { fn is_zero(self) -> bool { self == 0 }}
161 | impl IsZero for u256 { fn is_zero(self) -> bool { self == 0x0000000000000000000000000000000000000000000000000000000000000000u256 }}
    |
____

warning
   --> test/src/e2e_vm_tests/test_programs/should_pass/language/array/array_repeat/src/main.sw:160:23
    |
158 | impl IsZero for u16 { fn is_zero(self) -> bool { self == 0 }}
159 | impl IsZero for u32 { fn is_zero(self) -> bool { self == 0 }}
160 | impl IsZero for u64 { fn is_zero(self) -> bool { self == 0 }}
    |                       -------------------------------------- This method is never called.
161 | impl IsZero for u256 { fn is_zero(self) -> bool { self == 0x0000000000000000000000000000000000000000000000000000000000000000u256 }}
162 | impl IsZero for b256 { fn is_zero(self) -> bool { self == 0x0000000000000000000000000000000000000000000000000000000000000000 }}
    |
____

warning
   --> test/src/e2e_vm_tests/test_programs/should_pass/language/array/array_repeat/src/main.sw:161:24
    |
159 | impl IsZero for u32 { fn is_zero(self) -> bool { self == 0 }}
160 | impl IsZero for u64 { fn is_zero(self) -> bool { self == 0 }}
161 | impl IsZero for u256 { fn is_zero(self) -> bool { self == 0x0000000000000000000000000000000000000000000000000000000000000000u256 }}
    |                        ----------------------------------------------------------------------------------------------------------- This method is never called.
162 | impl IsZero for b256 { fn is_zero(self) -> bool { self == 0x0000000000000000000000000000000000000000000000000000000000000000 }}
163 | 
    |
____

warning
   --> test/src/e2e_vm_tests/test_programs/should_pass/language/array/array_repeat/src/main.sw:162:24
    |
160 | impl IsZero for u64 { fn is_zero(self) -> bool { self == 0 }}
161 | impl IsZero for u256 { fn is_zero(self) -> bool { self == 0x0000000000000000000000000000000000000000000000000000000000000000u256 }}
162 | impl IsZero for b256 { fn is_zero(self) -> bool { self == 0x0000000000000000000000000000000000000000000000000000000000000000 }}
    |                        ------------------------------------------------------------------------------------------------------- This method is never called.
163 | 
164 | fn is_all_zero<T, const N: u64>(array: [T; N], n: u64) where T: IsZero {
    |
____

warning
   --> test/src/e2e_vm_tests/test_programs/should_pass/language/array/array_repeat/src/main.sw:164:4
    |
162 | impl IsZero for b256 { fn is_zero(self) -> bool { self == 0x0000000000000000000000000000000000000000000000000000000000000000 }}
163 | 
164 | fn is_all_zero<T, const N: u64>(array: [T; N], n: u64) where T: IsZero {
    |    ----------- This function is never called.
165 |     let mut i = 0;
166 |     while i < n {
    |
____

  Compiled script "array_repeat" with 8 warnings.
    Finished release [optimized + fuel] target(s) [1.032 KB] in ???

> forc test --path test/src/e2e_vm_tests/test_programs/should_pass/language/array/array_repeat --verbose --release
exit status: 0
output:
    Building test/src/e2e_vm_tests/test_programs/should_pass/language/array/array_repeat
   Compiling library std (test/src/e2e_vm_tests/reduced_std_libs/sway-lib-std-assert)
DIFF------------------------------
.program:
DIFF------------------------------
.program:
   Compiling script array_repeat (test/src/e2e_vm_tests/test_programs/should_pass/language/array/array_repeat)
DIFF------------------------------
.program:
DIFF------------------------------
.program:
DIFF------------------------------
.program:
.0                                      ; --- start of function: __entry ---
move $$locbase $sp                      ; [entry init: __entry]: set locals base register
cfei i0                                 ; [entry init: __entry]: allocate: locals 0 byte(s), call args 0 slot(s)
.48
fncall .2                               ; [call: main_0]: call function
 move $r1 $zero                          ; [call: main_0]: copy returned unit value
 movi $r1 i0                             ; [call: main_0]: copy returned unit value
retd $zero $zero                        ; [entry end: __entry] return slice
DIFF------------------------------
.program:
.0                                      ; --- start of function: __entry ---
move $$locbase $sp                      ; [entry init: __entry]: set locals base register
cfei i0                                 ; [entry init: __entry]: allocate: locals 0 byte(s), call args 0 slot(s)
.48
fncall .2                               ; [call: main_0]: call function
retd $zero $zero                        ; [entry end: __entry] return slice
DIFF------------------------------
.program:
.0                                      ; --- start of function: __entry ---
move $$locbase $sp                      ; [entry init: __entry]: set locals base register
cfei i0                                 ; [entry init: __entry]: allocate: locals 0 byte(s), call args 0 slot(s)
.48
fncall .2                               ; [call: main_0]: call function
retd $zero $zero                        ; [entry end: __entry] return slice
DIFF------------------------------
.program:
.0                                      ; --- start of function: __entry ---
move $$locbase $sp                      ; [entry init: __entry]: set locals base register
cfei i0                                 ; [entry init: __entry]: allocate: locals 0 byte(s), call args 0 slot(s)
.48
fncall .2                               ; [call: main_0]: call function
retd $zero $zero                        ; [entry end: __entry] return slice
DIFF------------------------------
.program:
.38                                     ; --- start of function: test_array_repeat_zero ---
move $$locbase $sp                      ; [entry init: test_array_repeat_zero]: set locals base register
cfei i264872                            ; [entry init: test_array_repeat_zero]: allocate: locals 264872 byte(s), call args 0 slot(s)
.71
addi $r128 $$locbase i720               ; get offset to local __ptr [u8; 5]
move $$arg0 $r128                       ; [call: array_repeat_zero_small_u8_1]: pass argument 0
fncall .4                               ; [call: array_repeat_zero_small_u8_1]: call function
 move $r129 $zero                        ; [call: array_repeat_zero_small_u8_1]: copy returned unit value
 move $r130 $zero                        ; move parameter from branch to block argument
 movi $r129 i0                           ; [call: array_repeat_zero_small_u8_1]: copy returned unit value
 movi $r130 i0                           ; move parameter from branch to block argument
ji  .72
.72
move $r132 $r130                        ; move parameter from branch to block argument
movi $r133 i5                           ; initialize constant into register
 lt $r134 $r132 $r133
 lt $r134 $r130 $r133
jnzi $r134 .73
ji  .74
.74
move $$arg0 $$locbase                   ; [call: array_repeat_zero_small_u16_2]: pass argument 0
fncall .6                               ; [call: array_repeat_zero_small_u16_2]: call function
 move $r135 $zero                        ; [call: array_repeat_zero_small_u16_2]: copy returned unit value
 movi $r135 i0                           ; [call: array_repeat_zero_small_u16_2]: copy returned unit value
move $$arg0 $$locbase                   ; [call: is_all_zero_57]: pass argument 0
movi $r136 i5                           ; initialize constant into register
 move $$arg1 $r136                       ; [call: is_all_zero_57]: pass argument 1
 movi $$arg1 i5                          ; [call: is_all_zero_57]: pass argument 1
fncall .40                              ; [call: is_all_zero_57]: call function
 move $r137 $zero                        ; [call: is_all_zero_57]: copy returned unit value
 movi $r137 i0                           ; [call: is_all_zero_57]: copy returned unit value
addi $r138 $$locbase i40                ; get offset to local __ptr [u64; 5]
move $$arg0 $r138                       ; [call: array_repeat_zero_small_u16_2]: pass argument 0
fncall .6                               ; [call: array_repeat_zero_small_u16_2]: call function
 move $r139 $zero                        ; [call: array_repeat_zero_small_u16_2]: copy returned unit value
 movi $r139 i0                           ; [call: array_repeat_zero_small_u16_2]: copy returned unit value
addi $r140 $$locbase i40                ; get offset to local __ptr [u64; 5]
move $$arg0 $r140                       ; [call: is_all_zero_57]: pass argument 0
movi $r141 i5                           ; initialize constant into register
 move $$arg1 $r141                       ; [call: is_all_zero_57]: pass argument 1
 movi $$arg1 i5                          ; [call: is_all_zero_57]: pass argument 1
fncall .40                              ; [call: is_all_zero_57]: call function
 move $r142 $zero                        ; [call: is_all_zero_57]: copy returned unit value
 movi $r142 i0                           ; [call: is_all_zero_57]: copy returned unit value
addi $r143 $$locbase i80                ; get offset to local __ptr [u64; 5]
move $$arg0 $r143                       ; [call: array_repeat_zero_small_u16_2]: pass argument 0
fncall .6                               ; [call: array_repeat_zero_small_u16_2]: call function
 move $r144 $zero                        ; [call: array_repeat_zero_small_u16_2]: copy returned unit value
 movi $r144 i0                           ; [call: array_repeat_zero_small_u16_2]: copy returned unit value
addi $r145 $$locbase i80                ; get offset to local __ptr [u64; 5]
move $$arg0 $r145                       ; [call: is_all_zero_57]: pass argument 0
movi $r146 i5                           ; initialize constant into register
 move $$arg1 $r146                       ; [call: is_all_zero_57]: pass argument 1
 movi $$arg1 i5                          ; [call: is_all_zero_57]: pass argument 1
fncall .40                              ; [call: is_all_zero_57]: call function
 move $r147 $zero                        ; [call: is_all_zero_57]: copy returned unit value
 movi $r147 i0                           ; [call: is_all_zero_57]: copy returned unit value
addi $r148 $$locbase i728               ; get offset to local __ptr [u256; 5]
move $$arg0 $r148                       ; [call: array_repeat_zero_small_u256_5]: pass argument 0
fncall .8                               ; [call: array_repeat_zero_small_u256_5]: call function
 move $r149 $zero                        ; [call: array_repeat_zero_small_u256_5]: copy returned unit value
 move $r150 $zero                        ; move parameter from branch to block argument
 movi $r149 i0                           ; [call: array_repeat_zero_small_u256_5]: copy returned unit value
 movi $r150 i0                           ; move parameter from branch to block argument
ji  .75
.75
move $r152 $r150                        ; move parameter from branch to block argument
movi $r153 i5                           ; initialize constant into register
 lt $r154 $r152 $r153
 lt $r154 $r150 $r153
jnzi $r154 .76
ji  .77
.77
addi $r155 $$locbase i888               ; get offset to local __ptr [b256; 5]
move $$arg0 $r155                       ; [call: array_repeat_zero_small_b256_6]: pass argument 0
fncall .10                              ; [call: array_repeat_zero_small_b256_6]: call function
 move $r156 $zero                        ; [call: array_repeat_zero_small_b256_6]: copy returned unit value
 move $r157 $zero                        ; move parameter from branch to block argument
 movi $r156 i0                           ; [call: array_repeat_zero_small_b256_6]: copy returned unit value
 movi $r157 i0                           ; move parameter from branch to block argument
ji  .78
.78
move $r159 $r157                        ; move parameter from branch to block argument
movi $r160 i5                           ; initialize constant into register
 lt $r161 $r159 $r160
 lt $r161 $r157 $r160
jnzi $r161 .79
ji  .80
.80
addi $r162 $$locbase i1048              ; get offset to local __ptr [bool; 5]
move $$arg0 $r162                       ; [call: array_repeat_zero_small_bool_7]: pass argument 0
fncall .12                              ; [call: array_repeat_zero_small_bool_7]: call function
 move $r163 $zero                        ; [call: array_repeat_zero_small_bool_7]: copy returned unit value
 move $r164 $zero                        ; move parameter from branch to block argument
 movi $r163 i0                           ; [call: array_repeat_zero_small_bool_7]: copy returned unit value
 movi $r164 i0                           ; move parameter from branch to block argument
ji  .81
.81
move $r166 $r164                        ; move parameter from branch to block argument
movi $r167 i5                           ; initialize constant into register
 lt $r168 $r166 $r167
 lt $r168 $r164 $r167
jnzi $r168 .82
ji  .83
.83
addi $r169 $$locbase i1056              ; get offset to local __ptr [u8; 25]
move $$arg0 $r169                       ; [call: array_repeat_zero_big_u8_8]: pass argument 0
fncall .14                              ; [call: array_repeat_zero_big_u8_8]: call function
 move $r170 $zero                        ; [call: array_repeat_zero_big_u8_8]: copy returned unit value
 move $r171 $zero                        ; move parameter from branch to block argument
 movi $r170 i0                           ; [call: array_repeat_zero_big_u8_8]: copy returned unit value
 movi $r171 i0                           ; move parameter from branch to block argument
ji  .84
.84
move $r173 $r171                        ; move parameter from branch to block argument
movi $r174 i25                          ; initialize constant into register
 lt $r175 $r173 $r174
 lt $r175 $r171 $r174
jnzi $r175 .85
ji  .86
.86
addi $r176 $$locbase i120               ; get offset to local __ptr [u64; 25]
move $$arg0 $r176                       ; [call: array_repeat_zero_big_u32_10]: pass argument 0
fncall .16                              ; [call: array_repeat_zero_big_u32_10]: call function
 move $r177 $zero                        ; [call: array_repeat_zero_big_u32_10]: copy returned unit value
 movi $r177 i0                           ; [call: array_repeat_zero_big_u32_10]: copy returned unit value
addi $r178 $$locbase i120               ; get offset to local __ptr [u64; 25]
move $$arg0 $r178                       ; [call: is_all_zero_77]: pass argument 0
movi $r179 i25                          ; initialize constant into register
 move $$arg1 $r179                       ; [call: is_all_zero_77]: pass argument 1
 movi $$arg1 i25                         ; [call: is_all_zero_77]: pass argument 1
fncall .46                              ; [call: is_all_zero_77]: call function
 move $r180 $zero                        ; [call: is_all_zero_77]: copy returned unit value
 movi $r180 i0                           ; [call: is_all_zero_77]: copy returned unit value
addi $r181 $$locbase i320               ; get offset to local __ptr [u64; 25]
move $$arg0 $r181                       ; [call: array_repeat_zero_big_u32_10]: pass argument 0
fncall .16                              ; [call: array_repeat_zero_big_u32_10]: call function
 move $r182 $zero                        ; [call: array_repeat_zero_big_u32_10]: copy returned unit value
 movi $r182 i0                           ; [call: array_repeat_zero_big_u32_10]: copy returned unit value
addi $r183 $$locbase i320               ; get offset to local __ptr [u64; 25]
move $$arg0 $r183                       ; [call: is_all_zero_77]: pass argument 0
movi $r184 i25                          ; initialize constant into register
 move $$arg1 $r184                       ; [call: is_all_zero_77]: pass argument 1
 movi $$arg1 i25                         ; [call: is_all_zero_77]: pass argument 1
fncall .46                              ; [call: is_all_zero_77]: call function
 move $r185 $zero                        ; [call: is_all_zero_77]: copy returned unit value
 movi $r185 i0                           ; [call: is_all_zero_77]: copy returned unit value
addi $r186 $$locbase i520               ; get offset to local __ptr [u64; 25]
move $$arg0 $r186                       ; [call: array_repeat_zero_big_u32_10]: pass argument 0
fncall .16                              ; [call: array_repeat_zero_big_u32_10]: call function
 move $r187 $zero                        ; [call: array_repeat_zero_big_u32_10]: copy returned unit value
 movi $r187 i0                           ; [call: array_repeat_zero_big_u32_10]: copy returned unit value
addi $r188 $$locbase i520               ; get offset to local __ptr [u64; 25]
move $$arg0 $r188                       ; [call: is_all_zero_77]: pass argument 0
movi $r189 i25                          ; initialize constant into register
 move $$arg1 $r189                       ; [call: is_all_zero_77]: pass argument 1
 movi $$arg1 i25                         ; [call: is_all_zero_77]: pass argument 1
fncall .46                              ; [call: is_all_zero_77]: call function
 move $r190 $zero                        ; [call: is_all_zero_77]: copy returned unit value
 movi $r190 i0                           ; [call: is_all_zero_77]: copy returned unit value
addi $r191 $$locbase i1088              ; get offset to local __ptr [u256; 25]
move $$arg0 $r191                       ; [call: array_repeat_zero_big_u256_12]: pass argument 0
fncall .18                              ; [call: array_repeat_zero_big_u256_12]: call function
 move $r192 $zero                        ; [call: array_repeat_zero_big_u256_12]: copy returned unit value
 move $r193 $zero                        ; move parameter from branch to block argument
 movi $r192 i0                           ; [call: array_repeat_zero_big_u256_12]: copy returned unit value
 movi $r193 i0                           ; move parameter from branch to block argument
ji  .87
.87
move $r195 $r193                        ; move parameter from branch to block argument
movi $r196 i25                          ; initialize constant into register
 lt $r197 $r195 $r196
 lt $r197 $r193 $r196
jnzi $r197 .88
ji  .89
.89
addi $r198 $$locbase i1888              ; get offset to local __ptr [b256; 25]
move $$arg0 $r198                       ; [call: array_repeat_zero_big_b256_13]: pass argument 0
fncall .20                              ; [call: array_repeat_zero_big_b256_13]: call function
 move $r199 $zero                        ; [call: array_repeat_zero_big_b256_13]: copy returned unit value
 move $r200 $zero                        ; move parameter from branch to block argument
 movi $r199 i0                           ; [call: array_repeat_zero_big_b256_13]: copy returned unit value
 movi $r200 i0                           ; move parameter from branch to block argument
ji  .90
.90
move $r202 $r200                        ; move parameter from branch to block argument
movi $r203 i25                          ; initialize constant into register
 lt $r204 $r202 $r203
 lt $r204 $r200 $r203
jnzi $r204 .91
ji  .92
.92
addi $r205 $$locbase i2688              ; get offset to local __ptr [bool; 25]
move $$arg0 $r205                       ; [call: array_repeat_zero_big_bool_14]: pass argument 0
fncall .22                              ; [call: array_repeat_zero_big_bool_14]: call function
 move $r206 $zero                        ; [call: array_repeat_zero_big_bool_14]: copy returned unit value
 move $r207 $zero                        ; move parameter from branch to block argument
 movi $r206 i0                           ; [call: array_repeat_zero_big_bool_14]: copy returned unit value
 movi $r207 i0                           ; move parameter from branch to block argument
ji  .93
.93
move $r209 $r207                        ; move parameter from branch to block argument
movi $r210 i25                          ; initialize constant into register
 lt $r211 $r209 $r210
 lt $r211 $r207 $r210
jnzi $r211 .94
ji  .95
.95
addi $r212 $$locbase i2720              ; get offset to local __ptr [u8; 262145]
move $$arg0 $r212                       ; [call: u8_array_bigger_than_18_bits_17]: pass argument 0
fncall .28                              ; [call: u8_array_bigger_than_18_bits_17]: call function
 move $r213 $zero                        ; [call: u8_array_bigger_than_18_bits_17]: copy returned unit value
 move $r214 $zero                        ; move parameter from branch to block argument
 movi $r213 i0                           ; [call: u8_array_bigger_than_18_bits_17]: copy returned unit value
 movi $r214 i0                           ; move parameter from branch to block argument
ji  .96
.96
move $r216 $r214                        ; move parameter from branch to block argument
load $r217 data_NonConfigurable_1       ; load constant from data section
 lt $r218 $r216 $r217
 lt $r218 $r214 $r217
jnzi $r218 .97
ji  .98
.98
ret $zero                               ; [entry end: test_array_repeat_zero] return unit as zero
.97
addi $r219 $$locbase i2720              ; get offset to local __ptr [u8; 262145]
movi $r220 i1                           ; get array element size
 mul $r221 $r216 $r220                   ; get offset to array element
 muli $r221 $r216 i1                     ; get offset to array element
add $r221 $r219 $r221                   ; add array element offset to array base
lb $r222 $r221 i0                       ; load byte
eq $r223 $r222 $zero
eq $r224 $r223 $zero
jnzi $r224 .99
ji  .100
.100
 add $r225 $r216 $one
 addi $r225 $r216 i1
move $r214 $r225                        ; move parameter from branch to block argument
ji  .96
.99
load $r227 data_NonConfigurable_3       ; load constant from data section
rvrt $r227
.94
addi $r228 $$locbase i2688              ; get offset to local __ptr [bool; 25]
movi $r229 i1                           ; get array element size
 mul $r230 $r209 $r229                   ; get offset to array element
 muli $r230 $r209 i1                     ; get offset to array element
add $r230 $r228 $r230                   ; add array element offset to array base
lb $r231 $r230 i0                       ; load byte
eq $r232 $r231 $zero
eq $r233 $r232 $zero
jnzi $r233 .101
ji  .102
.102
 add $r234 $r209 $one
 addi $r234 $r209 i1
move $r207 $r234                        ; move parameter from branch to block argument
ji  .93
.101
load $r236 data_NonConfigurable_3       ; load constant from data section
rvrt $r236
.91
addi $r237 $$locbase i1888              ; get offset to local __ptr [b256; 25]
movi $r238 i32                          ; get array element size
 mul $r239 $r202 $r238                   ; get offset to array element
 muli $r239 $r202 i32                    ; get offset to array element
add $r239 $r237 $r239                   ; add array element offset to array base
move $$arg0 $r239                       ; [call: is_zero_69]: pass argument 0
fncall .44                              ; [call: is_zero_69]: call function
move $r240 $$retv                       ; [call: is_zero_69]: copy returned value
 eq $r241 $r240 $zero
 eq $r241 $$retv $zero
jnzi $r241 .103
ji  .104
.104
 add $r242 $r202 $one
 addi $r242 $r202 i1
move $r200 $r242                        ; move parameter from branch to block argument
ji  .90
.103
load $r244 data_NonConfigurable_3       ; load constant from data section
rvrt $r244
.88
addi $r245 $$locbase i1088              ; get offset to local __ptr [u256; 25]
movi $r246 i32                          ; get array element size
 mul $r247 $r195 $r246                   ; get offset to array element
 muli $r247 $r195 i32                    ; get offset to array element
add $r247 $r245 $r247                   ; add array element offset to array base
move $$arg0 $r247                       ; [call: is_zero_66]: pass argument 0
fncall .42                              ; [call: is_zero_66]: call function
move $r248 $$retv                       ; [call: is_zero_66]: copy returned value
 eq $r249 $r248 $zero
 eq $r249 $$retv $zero
jnzi $r249 .105
ji  .106
.106
 add $r250 $r195 $one
 addi $r250 $r195 i1
move $r193 $r250                        ; move parameter from branch to block argument
ji  .87
.105
load $r252 data_NonConfigurable_3       ; load constant from data section
rvrt $r252
.85
addi $r253 $$locbase i1056              ; get offset to local __ptr [u8; 25]
movi $r254 i1                           ; get array element size
 mul $r255 $r173 $r254                   ; get offset to array element
 muli $r255 $r173 i1                     ; get offset to array element
add $r255 $r253 $r255                   ; add array element offset to array base
lb $r256 $r255 i0                       ; load byte
eq $r257 $r256 $zero
eq $r258 $r257 $zero
jnzi $r258 .107
ji  .108
.108
 add $r259 $r173 $one
 addi $r259 $r173 i1
move $r171 $r259                        ; move parameter from branch to block argument
ji  .84
.107
load $r261 data_NonConfigurable_3       ; load constant from data section
rvrt $r261
.82
addi $r262 $$locbase i1048              ; get offset to local __ptr [bool; 5]
movi $r263 i1                           ; get array element size
 mul $r264 $r166 $r263                   ; get offset to array element
 muli $r264 $r166 i1                     ; get offset to array element
add $r264 $r262 $r264                   ; add array element offset to array base
lb $r265 $r264 i0                       ; load byte
eq $r266 $r265 $zero
eq $r267 $r266 $zero
jnzi $r267 .109
ji  .110
.110
 add $r268 $r166 $one
 addi $r268 $r166 i1
move $r164 $r268                        ; move parameter from branch to block argument
ji  .81
.109
load $r270 data_NonConfigurable_3       ; load constant from data section
rvrt $r270
.79
addi $r271 $$locbase i888               ; get offset to local __ptr [b256; 5]
movi $r272 i32                          ; get array element size
 mul $r273 $r159 $r272                   ; get offset to array element
 muli $r273 $r159 i32                    ; get offset to array element
add $r273 $r271 $r273                   ; add array element offset to array base
move $$arg0 $r273                       ; [call: is_zero_69]: pass argument 0
fncall .44                              ; [call: is_zero_69]: call function
move $r274 $$retv                       ; [call: is_zero_69]: copy returned value
 eq $r275 $r274 $zero
 eq $r275 $$retv $zero
jnzi $r275 .111
ji  .112
.112
 add $r276 $r159 $one
 addi $r276 $r159 i1
move $r157 $r276                        ; move parameter from branch to block argument
ji  .78
.111
load $r278 data_NonConfigurable_3       ; load constant from data section
rvrt $r278
.76
addi $r279 $$locbase i728               ; get offset to local __ptr [u256; 5]
movi $r280 i32                          ; get array element size
 mul $r281 $r152 $r280                   ; get offset to array element
 muli $r281 $r152 i32                    ; get offset to array element
add $r281 $r279 $r281                   ; add array element offset to array base
move $$arg0 $r281                       ; [call: is_zero_66]: pass argument 0
fncall .42                              ; [call: is_zero_66]: call function
move $r282 $$retv                       ; [call: is_zero_66]: copy returned value
 eq $r283 $r282 $zero
 eq $r283 $$retv $zero
jnzi $r283 .113
ji  .114
.114
 add $r284 $r152 $one
 addi $r284 $r152 i1
move $r150 $r284                        ; move parameter from branch to block argument
ji  .75
.113
load $r286 data_NonConfigurable_3       ; load constant from data section
rvrt $r286
.73
addi $r287 $$locbase i720               ; get offset to local __ptr [u8; 5]
movi $r288 i1                           ; get array element size
 mul $r289 $r132 $r288                   ; get offset to array element
 muli $r289 $r132 i1                     ; get offset to array element
add $r289 $r287 $r289                   ; add array element offset to array base
lb $r290 $r289 i0                       ; load byte
eq $r291 $r290 $zero
eq $r292 $r291 $zero
jnzi $r292 .115
ji  .116
.116
 add $r293 $r132 $one
 addi $r293 $r132 i1
move $r130 $r293                        ; move parameter from branch to block argument
ji  .72
.115
load $r295 data_NonConfigurable_3       ; load constant from data section
rvrt $r295
DIFF------------------------------
.program:
.38                                     ; --- start of function: test_array_repeat_zero ---
move $$locbase $sp                      ; [entry init: test_array_repeat_zero]: set locals base register
cfei i264872                            ; [entry init: test_array_repeat_zero]: allocate: locals 264872 byte(s), call args 0 slot(s)
.71
addi $r128 $$locbase i720               ; get offset to local __ptr [u8; 5]
move $$arg0 $r128                       ; [call: array_repeat_zero_small_u8_1]: pass argument 0
fncall .4                               ; [call: array_repeat_zero_small_u8_1]: call function
movi $r130 i0                           ; move parameter from branch to block argument
.72
move $r132 $r130                        ; move parameter from branch to block argument
movi $r133 i5                           ; initialize constant into register
lt $r134 $r130 $r133
jnzi $r134 .73
.74
move $$arg0 $$locbase                   ; [call: array_repeat_zero_small_u16_2]: pass argument 0
fncall .6                               ; [call: array_repeat_zero_small_u16_2]: call function
move $$arg0 $$locbase                   ; [call: is_all_zero_57]: pass argument 0
movi $$arg1 i5                          ; [call: is_all_zero_57]: pass argument 1
fncall .40                              ; [call: is_all_zero_57]: call function
addi $r138 $$locbase i40                ; get offset to local __ptr [u64; 5]
move $$arg0 $r138                       ; [call: array_repeat_zero_small_u16_2]: pass argument 0
fncall .6                               ; [call: array_repeat_zero_small_u16_2]: call function
addi $r140 $$locbase i40                ; get offset to local __ptr [u64; 5]
move $$arg0 $r140                       ; [call: is_all_zero_57]: pass argument 0
movi $$arg1 i5                          ; [call: is_all_zero_57]: pass argument 1
fncall .40                              ; [call: is_all_zero_57]: call function
addi $r143 $$locbase i80                ; get offset to local __ptr [u64; 5]
move $$arg0 $r143                       ; [call: array_repeat_zero_small_u16_2]: pass argument 0
fncall .6                               ; [call: array_repeat_zero_small_u16_2]: call function
addi $r145 $$locbase i80                ; get offset to local __ptr [u64; 5]
move $$arg0 $r145                       ; [call: is_all_zero_57]: pass argument 0
movi $$arg1 i5                          ; [call: is_all_zero_57]: pass argument 1
fncall .40                              ; [call: is_all_zero_57]: call function
addi $r148 $$locbase i728               ; get offset to local __ptr [u256; 5]
move $$arg0 $r148                       ; [call: array_repeat_zero_small_u256_5]: pass argument 0
fncall .8                               ; [call: array_repeat_zero_small_u256_5]: call function
movi $r150 i0                           ; move parameter from branch to block argument
.75
move $r152 $r150                        ; move parameter from branch to block argument
movi $r153 i5                           ; initialize constant into register
lt $r154 $r150 $r153
jnzi $r154 .76
.77
addi $r155 $$locbase i888               ; get offset to local __ptr [b256; 5]
move $$arg0 $r155                       ; [call: array_repeat_zero_small_b256_6]: pass argument 0
fncall .10                              ; [call: array_repeat_zero_small_b256_6]: call function
movi $r157 i0                           ; move parameter from branch to block argument
.78
move $r159 $r157                        ; move parameter from branch to block argument
movi $r160 i5                           ; initialize constant into register
lt $r161 $r157 $r160
jnzi $r161 .79
.80
addi $r162 $$locbase i1048              ; get offset to local __ptr [bool; 5]
move $$arg0 $r162                       ; [call: array_repeat_zero_small_bool_7]: pass argument 0
fncall .12                              ; [call: array_repeat_zero_small_bool_7]: call function
movi $r164 i0                           ; move parameter from branch to block argument
.81
move $r166 $r164                        ; move parameter from branch to block argument
movi $r167 i5                           ; initialize constant into register
lt $r168 $r164 $r167
jnzi $r168 .82
.83
addi $r169 $$locbase i1056              ; get offset to local __ptr [u8; 25]
move $$arg0 $r169                       ; [call: array_repeat_zero_big_u8_8]: pass argument 0
fncall .14                              ; [call: array_repeat_zero_big_u8_8]: call function
movi $r171 i0                           ; move parameter from branch to block argument
.84
move $r173 $r171                        ; move parameter from branch to block argument
movi $r174 i25                          ; initialize constant into register
lt $r175 $r171 $r174
jnzi $r175 .85
.86
addi $r176 $$locbase i120               ; get offset to local __ptr [u64; 25]
move $$arg0 $r176                       ; [call: array_repeat_zero_big_u32_10]: pass argument 0
fncall .16                              ; [call: array_repeat_zero_big_u32_10]: call function
addi $r178 $$locbase i120               ; get offset to local __ptr [u64; 25]
move $$arg0 $r178                       ; [call: is_all_zero_77]: pass argument 0
movi $$arg1 i25                         ; [call: is_all_zero_77]: pass argument 1
fncall .46                              ; [call: is_all_zero_77]: call function
addi $r181 $$locbase i320               ; get offset to local __ptr [u64; 25]
move $$arg0 $r181                       ; [call: array_repeat_zero_big_u32_10]: pass argument 0
fncall .16                              ; [call: array_repeat_zero_big_u32_10]: call function
addi $r183 $$locbase i320               ; get offset to local __ptr [u64; 25]
move $$arg0 $r183                       ; [call: is_all_zero_77]: pass argument 0
movi $$arg1 i25                         ; [call: is_all_zero_77]: pass argument 1
fncall .46                              ; [call: is_all_zero_77]: call function
addi $r186 $$locbase i520               ; get offset to local __ptr [u64; 25]
move $$arg0 $r186                       ; [call: array_repeat_zero_big_u32_10]: pass argument 0
fncall .16                              ; [call: array_repeat_zero_big_u32_10]: call function
addi $r188 $$locbase i520               ; get offset to local __ptr [u64; 25]
move $$arg0 $r188                       ; [call: is_all_zero_77]: pass argument 0
movi $$arg1 i25                         ; [call: is_all_zero_77]: pass argument 1
fncall .46                              ; [call: is_all_zero_77]: call function
addi $r191 $$locbase i1088              ; get offset to local __ptr [u256; 25]
move $$arg0 $r191                       ; [call: array_repeat_zero_big_u256_12]: pass argument 0
fncall .18                              ; [call: array_repeat_zero_big_u256_12]: call function
movi $r193 i0                           ; move parameter from branch to block argument
.87
move $r195 $r193                        ; move parameter from branch to block argument
movi $r196 i25                          ; initialize constant into register
lt $r197 $r193 $r196
jnzi $r197 .88
.89
addi $r198 $$locbase i1888              ; get offset to local __ptr [b256; 25]
move $$arg0 $r198                       ; [call: array_repeat_zero_big_b256_13]: pass argument 0
fncall .20                              ; [call: array_repeat_zero_big_b256_13]: call function
movi $r200 i0                           ; move parameter from branch to block argument
.90
move $r202 $r200                        ; move parameter from branch to block argument
movi $r203 i25                          ; initialize constant into register
lt $r204 $r200 $r203
jnzi $r204 .91
.92
addi $r205 $$locbase i2688              ; get offset to local __ptr [bool; 25]
move $$arg0 $r205                       ; [call: array_repeat_zero_big_bool_14]: pass argument 0
fncall .22                              ; [call: array_repeat_zero_big_bool_14]: call function
movi $r207 i0                           ; move parameter from branch to block argument
.93
move $r209 $r207                        ; move parameter from branch to block argument
movi $r210 i25                          ; initialize constant into register
lt $r211 $r207 $r210
jnzi $r211 .94
.95
addi $r212 $$locbase i2720              ; get offset to local __ptr [u8; 262145]
move $$arg0 $r212                       ; [call: u8_array_bigger_than_18_bits_17]: pass argument 0
fncall .28                              ; [call: u8_array_bigger_than_18_bits_17]: call function
movi $r214 i0                           ; move parameter from branch to block argument
.96
move $r216 $r214                        ; move parameter from branch to block argument
load $r217 data_NonConfigurable_1       ; load constant from data section
lt $r218 $r214 $r217
jnzi $r218 .97
.98
ret $zero                               ; [entry end: test_array_repeat_zero] return unit as zero
.97
addi $r219 $$locbase i2720              ; get offset to local __ptr [u8; 262145]
muli $r221 $r216 i1                     ; get offset to array element
add $r221 $r219 $r221                   ; add array element offset to array base
lb $r222 $r221 i0                       ; load byte
eq $r223 $r222 $zero
eq $r224 $r223 $zero
jnzi $r224 .99
.100
addi $r225 $r216 i1
move $r214 $r225                        ; move parameter from branch to block argument
ji  .96
.99
load $r227 data_NonConfigurable_3       ; load constant from data section
rvrt $r227
.94
addi $r228 $$locbase i2688              ; get offset to local __ptr [bool; 25]
muli $r230 $r209 i1                     ; get offset to array element
add $r230 $r228 $r230                   ; add array element offset to array base
lb $r231 $r230 i0                       ; load byte
eq $r232 $r231 $zero
eq $r233 $r232 $zero
jnzi $r233 .101
.102
addi $r234 $r209 i1
move $r207 $r234                        ; move parameter from branch to block argument
ji  .93
.101
load $r236 data_NonConfigurable_3       ; load constant from data section
rvrt $r236
.91
addi $r237 $$locbase i1888              ; get offset to local __ptr [b256; 25]
muli $r239 $r202 i32                    ; get offset to array element
add $r239 $r237 $r239                   ; add array element offset to array base
move $$arg0 $r239                       ; [call: is_zero_69]: pass argument 0
fncall .44                              ; [call: is_zero_69]: call function
eq $r241 $$retv $zero
jnzi $r241 .103
.104
addi $r242 $r202 i1
move $r200 $r242                        ; move parameter from branch to block argument
ji  .90
.103
load $r244 data_NonConfigurable_3       ; load constant from data section
rvrt $r244
.88
addi $r245 $$locbase i1088              ; get offset to local __ptr [u256; 25]
muli $r247 $r195 i32                    ; get offset to array element
add $r247 $r245 $r247                   ; add array element offset to array base
move $$arg0 $r247                       ; [call: is_zero_66]: pass argument 0
fncall .42                              ; [call: is_zero_66]: call function
eq $r249 $$retv $zero
jnzi $r249 .105
.106
addi $r250 $r195 i1
move $r193 $r250                        ; move parameter from branch to block argument
ji  .87
.105
load $r252 data_NonConfigurable_3       ; load constant from data section
rvrt $r252
.85
addi $r253 $$locbase i1056              ; get offset to local __ptr [u8; 25]
muli $r255 $r173 i1                     ; get offset to array element
add $r255 $r253 $r255                   ; add array element offset to array base
lb $r256 $r255 i0                       ; load byte
eq $r257 $r256 $zero
eq $r258 $r257 $zero
jnzi $r258 .107
.108
addi $r259 $r173 i1
move $r171 $r259                        ; move parameter from branch to block argument
ji  .84
.107
load $r261 data_NonConfigurable_3       ; load constant from data section
rvrt $r261
.82
addi $r262 $$locbase i1048              ; get offset to local __ptr [bool; 5]
muli $r264 $r166 i1                     ; get offset to array element
add $r264 $r262 $r264                   ; add array element offset to array base
lb $r265 $r264 i0                       ; load byte
eq $r266 $r265 $zero
eq $r267 $r266 $zero
jnzi $r267 .109
.110
addi $r268 $r166 i1
move $r164 $r268                        ; move parameter from branch to block argument
ji  .81
.109
load $r270 data_NonConfigurable_3       ; load constant from data section
rvrt $r270
.79
addi $r271 $$locbase i888               ; get offset to local __ptr [b256; 5]
muli $r273 $r159 i32                    ; get offset to array element
add $r273 $r271 $r273                   ; add array element offset to array base
move $$arg0 $r273                       ; [call: is_zero_69]: pass argument 0
fncall .44                              ; [call: is_zero_69]: call function
eq $r275 $$retv $zero
jnzi $r275 .111
.112
addi $r276 $r159 i1
move $r157 $r276                        ; move parameter from branch to block argument
ji  .78
.111
load $r278 data_NonConfigurable_3       ; load constant from data section
rvrt $r278
.76
addi $r279 $$locbase i728               ; get offset to local __ptr [u256; 5]
muli $r281 $r152 i32                    ; get offset to array element
add $r281 $r279 $r281                   ; add array element offset to array base
move $$arg0 $r281                       ; [call: is_zero_66]: pass argument 0
fncall .42                              ; [call: is_zero_66]: call function
eq $r283 $$retv $zero
jnzi $r283 .113
.114
addi $r284 $r152 i1
move $r150 $r284                        ; move parameter from branch to block argument
ji  .75
.113
load $r286 data_NonConfigurable_3       ; load constant from data section
rvrt $r286
.73
addi $r287 $$locbase i720               ; get offset to local __ptr [u8; 5]
muli $r289 $r132 i1                     ; get offset to array element
add $r289 $r287 $r289                   ; add array element offset to array base
lb $r290 $r289 i0                       ; load byte
eq $r291 $r290 $zero
eq $r292 $r291 $zero
jnzi $r292 .115
.116
addi $r293 $r132 i1
move $r130 $r293                        ; move parameter from branch to block argument
ji  .72
.115
load $r295 data_NonConfigurable_3       ; load constant from data section
rvrt $r295
DIFF------------------------------
.program:
.38                                     ; --- start of function: test_array_repeat_zero ---
move $$locbase $sp                      ; [entry init: test_array_repeat_zero]: set locals base register
cfei i264872                            ; [entry init: test_array_repeat_zero]: allocate: locals 264872 byte(s), call args 0 slot(s)
.71
addi $r128 $$locbase i720               ; get offset to local __ptr [u8; 5]
move $$arg0 $r128                       ; [call: array_repeat_zero_small_u8_1]: pass argument 0
fncall .4                               ; [call: array_repeat_zero_small_u8_1]: call function
movi $r130 i0                           ; move parameter from branch to block argument
.72
move $r132 $r130                        ; move parameter from branch to block argument
movi $r133 i5                           ; initialize constant into register
lt $r134 $r130 $r133
jnzi $r134 .73
.74
move $$arg0 $$locbase                   ; [call: array_repeat_zero_small_u16_2]: pass argument 0
fncall .6                               ; [call: array_repeat_zero_small_u16_2]: call function
move $$arg0 $$locbase                   ; [call: is_all_zero_57]: pass argument 0
movi $$arg1 i5                          ; [call: is_all_zero_57]: pass argument 1
fncall .40                              ; [call: is_all_zero_57]: call function
addi $r138 $$locbase i40                ; get offset to local __ptr [u64; 5]
move $$arg0 $r138                       ; [call: array_repeat_zero_small_u16_2]: pass argument 0
fncall .6                               ; [call: array_repeat_zero_small_u16_2]: call function
addi $r140 $$locbase i40                ; get offset to local __ptr [u64; 5]
move $$arg0 $r140                       ; [call: is_all_zero_57]: pass argument 0
movi $$arg1 i5                          ; [call: is_all_zero_57]: pass argument 1
fncall .40                              ; [call: is_all_zero_57]: call function
addi $r143 $$locbase i80                ; get offset to local __ptr [u64; 5]
move $$arg0 $r143                       ; [call: array_repeat_zero_small_u16_2]: pass argument 0
fncall .6                               ; [call: array_repeat_zero_small_u16_2]: call function
addi $r145 $$locbase i80                ; get offset to local __ptr [u64; 5]
move $$arg0 $r145                       ; [call: is_all_zero_57]: pass argument 0
movi $$arg1 i5                          ; [call: is_all_zero_57]: pass argument 1
fncall .40                              ; [call: is_all_zero_57]: call function
addi $r148 $$locbase i728               ; get offset to local __ptr [u256; 5]
move $$arg0 $r148                       ; [call: array_repeat_zero_small_u256_5]: pass argument 0
fncall .8                               ; [call: array_repeat_zero_small_u256_5]: call function
movi $r150 i0                           ; move parameter from branch to block argument
.75
move $r152 $r150                        ; move parameter from branch to block argument
movi $r153 i5                           ; initialize constant into register
lt $r154 $r150 $r153
jnzi $r154 .76
.77
addi $r155 $$locbase i888               ; get offset to local __ptr [b256; 5]
move $$arg0 $r155                       ; [call: array_repeat_zero_small_b256_6]: pass argument 0
fncall .10                              ; [call: array_repeat_zero_small_b256_6]: call function
movi $r157 i0                           ; move parameter from branch to block argument
.78
move $r159 $r157                        ; move parameter from branch to block argument
movi $r160 i5                           ; initialize constant into register
lt $r161 $r157 $r160
jnzi $r161 .79
.80
addi $r162 $$locbase i1048              ; get offset to local __ptr [bool; 5]
move $$arg0 $r162                       ; [call: array_repeat_zero_small_bool_7]: pass argument 0
fncall .12                              ; [call: array_repeat_zero_small_bool_7]: call function
movi $r164 i0                           ; move parameter from branch to block argument
.81
move $r166 $r164                        ; move parameter from branch to block argument
movi $r167 i5                           ; initialize constant into register
lt $r168 $r164 $r167
jnzi $r168 .82
.83
addi $r169 $$locbase i1056              ; get offset to local __ptr [u8; 25]
move $$arg0 $r169                       ; [call: array_repeat_zero_big_u8_8]: pass argument 0
fncall .14                              ; [call: array_repeat_zero_big_u8_8]: call function
movi $r171 i0                           ; move parameter from branch to block argument
.84
move $r173 $r171                        ; move parameter from branch to block argument
movi $r174 i25                          ; initialize constant into register
lt $r175 $r171 $r174
jnzi $r175 .85
.86
addi $r176 $$locbase i120               ; get offset to local __ptr [u64; 25]
move $$arg0 $r176                       ; [call: array_repeat_zero_big_u32_10]: pass argument 0
fncall .16                              ; [call: array_repeat_zero_big_u32_10]: call function
addi $r178 $$locbase i120               ; get offset to local __ptr [u64; 25]
move $$arg0 $r178                       ; [call: is_all_zero_77]: pass argument 0
movi $$arg1 i25                         ; [call: is_all_zero_77]: pass argument 1
fncall .46                              ; [call: is_all_zero_77]: call function
addi $r181 $$locbase i320               ; get offset to local __ptr [u64; 25]
move $$arg0 $r181                       ; [call: array_repeat_zero_big_u32_10]: pass argument 0
fncall .16                              ; [call: array_repeat_zero_big_u32_10]: call function
addi $r183 $$locbase i320               ; get offset to local __ptr [u64; 25]
move $$arg0 $r183                       ; [call: is_all_zero_77]: pass argument 0
movi $$arg1 i25                         ; [call: is_all_zero_77]: pass argument 1
fncall .46                              ; [call: is_all_zero_77]: call function
addi $r186 $$locbase i520               ; get offset to local __ptr [u64; 25]
move $$arg0 $r186                       ; [call: array_repeat_zero_big_u32_10]: pass argument 0
fncall .16                              ; [call: array_repeat_zero_big_u32_10]: call function
addi $r188 $$locbase i520               ; get offset to local __ptr [u64; 25]
move $$arg0 $r188                       ; [call: is_all_zero_77]: pass argument 0
movi $$arg1 i25                         ; [call: is_all_zero_77]: pass argument 1
fncall .46                              ; [call: is_all_zero_77]: call function
addi $r191 $$locbase i1088              ; get offset to local __ptr [u256; 25]
move $$arg0 $r191                       ; [call: array_repeat_zero_big_u256_12]: pass argument 0
fncall .18                              ; [call: array_repeat_zero_big_u256_12]: call function
movi $r193 i0                           ; move parameter from branch to block argument
.87
move $r195 $r193                        ; move parameter from branch to block argument
movi $r196 i25                          ; initialize constant into register
lt $r197 $r193 $r196
jnzi $r197 .88
.89
addi $r198 $$locbase i1888              ; get offset to local __ptr [b256; 25]
move $$arg0 $r198                       ; [call: array_repeat_zero_big_b256_13]: pass argument 0
fncall .20                              ; [call: array_repeat_zero_big_b256_13]: call function
movi $r200 i0                           ; move parameter from branch to block argument
.90
move $r202 $r200                        ; move parameter from branch to block argument
movi $r203 i25                          ; initialize constant into register
lt $r204 $r200 $r203
jnzi $r204 .91
.92
addi $r205 $$locbase i2688              ; get offset to local __ptr [bool; 25]
move $$arg0 $r205                       ; [call: array_repeat_zero_big_bool_14]: pass argument 0
fncall .22                              ; [call: array_repeat_zero_big_bool_14]: call function
movi $r207 i0                           ; move parameter from branch to block argument
.93
move $r209 $r207                        ; move parameter from branch to block argument
movi $r210 i25                          ; initialize constant into register
lt $r211 $r207 $r210
jnzi $r211 .94
.95
addi $r212 $$locbase i2720              ; get offset to local __ptr [u8; 262145]
move $$arg0 $r212                       ; [call: u8_array_bigger_than_18_bits_17]: pass argument 0
fncall .28                              ; [call: u8_array_bigger_than_18_bits_17]: call function
movi $r214 i0                           ; move parameter from branch to block argument
.96
move $r216 $r214                        ; move parameter from branch to block argument
load $r217 data_NonConfigurable_1       ; load constant from data section
lt $r218 $r214 $r217
jnzi $r218 .97
.98
ret $zero                               ; [entry end: test_array_repeat_zero] return unit as zero
.97
addi $r219 $$locbase i2720              ; get offset to local __ptr [u8; 262145]
muli $r221 $r216 i1                     ; get offset to array element
add $r221 $r219 $r221                   ; add array element offset to array base
lb $r222 $r221 i0                       ; load byte
eq $r223 $r222 $zero
eq $r224 $r223 $zero
jnzi $r224 .99
.100
addi $r225 $r216 i1
move $r214 $r225                        ; move parameter from branch to block argument
ji  .96
.99
load $r227 data_NonConfigurable_3       ; load constant from data section
rvrt $r227
.94
addi $r228 $$locbase i2688              ; get offset to local __ptr [bool; 25]
muli $r230 $r209 i1                     ; get offset to array element
add $r230 $r228 $r230                   ; add array element offset to array base
lb $r231 $r230 i0                       ; load byte
eq $r232 $r231 $zero
eq $r233 $r232 $zero
jnzi $r233 .101
.102
addi $r234 $r209 i1
move $r207 $r234                        ; move parameter from branch to block argument
ji  .93
.101
load $r236 data_NonConfigurable_3       ; load constant from data section
rvrt $r236
.91
addi $r237 $$locbase i1888              ; get offset to local __ptr [b256; 25]
muli $r239 $r202 i32                    ; get offset to array element
add $r239 $r237 $r239                   ; add array element offset to array base
move $$arg0 $r239                       ; [call: is_zero_69]: pass argument 0
fncall .44                              ; [call: is_zero_69]: call function
eq $r241 $$retv $zero
jnzi $r241 .103
.104
addi $r242 $r202 i1
move $r200 $r242                        ; move parameter from branch to block argument
ji  .90
.103
load $r244 data_NonConfigurable_3       ; load constant from data section
rvrt $r244
.88
addi $r245 $$locbase i1088              ; get offset to local __ptr [u256; 25]
muli $r247 $r195 i32                    ; get offset to array element
add $r247 $r245 $r247                   ; add array element offset to array base
move $$arg0 $r247                       ; [call: is_zero_66]: pass argument 0
fncall .42                              ; [call: is_zero_66]: call function
eq $r249 $$retv $zero
jnzi $r249 .105
.106
addi $r250 $r195 i1
move $r193 $r250                        ; move parameter from branch to block argument
ji  .87
.105
load $r252 data_NonConfigurable_3       ; load constant from data section
rvrt $r252
.85
addi $r253 $$locbase i1056              ; get offset to local __ptr [u8; 25]
muli $r255 $r173 i1                     ; get offset to array element
add $r255 $r253 $r255                   ; add array element offset to array base
lb $r256 $r255 i0                       ; load byte
eq $r257 $r256 $zero
eq $r258 $r257 $zero
jnzi $r258 .107
.108
addi $r259 $r173 i1
move $r171 $r259                        ; move parameter from branch to block argument
ji  .84
.107
load $r261 data_NonConfigurable_3       ; load constant from data section
rvrt $r261
.82
addi $r262 $$locbase i1048              ; get offset to local __ptr [bool; 5]
muli $r264 $r166 i1                     ; get offset to array element
add $r264 $r262 $r264                   ; add array element offset to array base
lb $r265 $r264 i0                       ; load byte
eq $r266 $r265 $zero
eq $r267 $r266 $zero
jnzi $r267 .109
.110
addi $r268 $r166 i1
move $r164 $r268                        ; move parameter from branch to block argument
ji  .81
.109
load $r270 data_NonConfigurable_3       ; load constant from data section
rvrt $r270
.79
addi $r271 $$locbase i888               ; get offset to local __ptr [b256; 5]
muli $r273 $r159 i32                    ; get offset to array element
add $r273 $r271 $r273                   ; add array element offset to array base
move $$arg0 $r273                       ; [call: is_zero_69]: pass argument 0
fncall .44                              ; [call: is_zero_69]: call function
eq $r275 $$retv $zero
jnzi $r275 .111
.112
addi $r276 $r159 i1
move $r157 $r276                        ; move parameter from branch to block argument
ji  .78
.111
load $r278 data_NonConfigurable_3       ; load constant from data section
rvrt $r278
.76
addi $r279 $$locbase i728               ; get offset to local __ptr [u256; 5]
muli $r281 $r152 i32                    ; get offset to array element
add $r281 $r279 $r281                   ; add array element offset to array base
move $$arg0 $r281                       ; [call: is_zero_66]: pass argument 0
fncall .42                              ; [call: is_zero_66]: call function
eq $r283 $$retv $zero
jnzi $r283 .113
.114
addi $r284 $r152 i1
move $r150 $r284                        ; move parameter from branch to block argument
ji  .75
.113
load $r286 data_NonConfigurable_3       ; load constant from data section
rvrt $r286
.73
addi $r287 $$locbase i720               ; get offset to local __ptr [u8; 5]
muli $r289 $r132 i1                     ; get offset to array element
add $r289 $r287 $r289                   ; add array element offset to array base
lb $r290 $r289 i0                       ; load byte
eq $r291 $r290 $zero
eq $r292 $r291 $zero
jnzi $r292 .115
.116
addi $r293 $r132 i1
move $r130 $r293                        ; move parameter from branch to block argument
ji  .72
.115
load $r295 data_NonConfigurable_3       ; load constant from data section
rvrt $r295
DIFF------------------------------
.program:
.38                                     ; --- start of function: test_array_repeat_zero ---
move $$locbase $sp                      ; [entry init: test_array_repeat_zero]: set locals base register
cfei i264872                            ; [entry init: test_array_repeat_zero]: allocate: locals 264872 byte(s), call args 0 slot(s)
.71
addi $r128 $$locbase i720               ; get offset to local __ptr [u8; 5]
move $$arg0 $r128                       ; [call: array_repeat_zero_small_u8_1]: pass argument 0
fncall .4                               ; [call: array_repeat_zero_small_u8_1]: call function
movi $r130 i0                           ; move parameter from branch to block argument
.72
move $r132 $r130                        ; move parameter from branch to block argument
movi $r133 i5                           ; initialize constant into register
lt $r134 $r130 $r133
jnzi $r134 .73
.74
move $$arg0 $$locbase                   ; [call: array_repeat_zero_small_u16_2]: pass argument 0
fncall .6                               ; [call: array_repeat_zero_small_u16_2]: call function
move $$arg0 $$locbase                   ; [call: is_all_zero_57]: pass argument 0
movi $$arg1 i5                          ; [call: is_all_zero_57]: pass argument 1
fncall .40                              ; [call: is_all_zero_57]: call function
addi $r138 $$locbase i40                ; get offset to local __ptr [u64; 5]
move $$arg0 $r138                       ; [call: array_repeat_zero_small_u16_2]: pass argument 0
fncall .6                               ; [call: array_repeat_zero_small_u16_2]: call function
addi $r140 $$locbase i40                ; get offset to local __ptr [u64; 5]
move $$arg0 $r140                       ; [call: is_all_zero_57]: pass argument 0
movi $$arg1 i5                          ; [call: is_all_zero_57]: pass argument 1
fncall .40                              ; [call: is_all_zero_57]: call function
addi $r143 $$locbase i80                ; get offset to local __ptr [u64; 5]
move $$arg0 $r143                       ; [call: array_repeat_zero_small_u16_2]: pass argument 0
fncall .6                               ; [call: array_repeat_zero_small_u16_2]: call function
addi $r145 $$locbase i80                ; get offset to local __ptr [u64; 5]
move $$arg0 $r145                       ; [call: is_all_zero_57]: pass argument 0
movi $$arg1 i5                          ; [call: is_all_zero_57]: pass argument 1
fncall .40                              ; [call: is_all_zero_57]: call function
addi $r148 $$locbase i728               ; get offset to local __ptr [u256; 5]
move $$arg0 $r148                       ; [call: array_repeat_zero_small_u256_5]: pass argument 0
fncall .8                               ; [call: array_repeat_zero_small_u256_5]: call function
movi $r150 i0                           ; move parameter from branch to block argument
.75
move $r152 $r150                        ; move parameter from branch to block argument
movi $r153 i5                           ; initialize constant into register
lt $r154 $r150 $r153
jnzi $r154 .76
.77
addi $r155 $$locbase i888               ; get offset to local __ptr [b256; 5]
move $$arg0 $r155                       ; [call: array_repeat_zero_small_b256_6]: pass argument 0
fncall .10                              ; [call: array_repeat_zero_small_b256_6]: call function
movi $r157 i0                           ; move parameter from branch to block argument
.78
move $r159 $r157                        ; move parameter from branch to block argument
movi $r160 i5                           ; initialize constant into register
lt $r161 $r157 $r160
jnzi $r161 .79
.80
addi $r162 $$locbase i1048              ; get offset to local __ptr [bool; 5]
move $$arg0 $r162                       ; [call: array_repeat_zero_small_bool_7]: pass argument 0
fncall .12                              ; [call: array_repeat_zero_small_bool_7]: call function
movi $r164 i0                           ; move parameter from branch to block argument
.81
move $r166 $r164                        ; move parameter from branch to block argument
movi $r167 i5                           ; initialize constant into register
lt $r168 $r164 $r167
jnzi $r168 .82
.83
addi $r169 $$locbase i1056              ; get offset to local __ptr [u8; 25]
move $$arg0 $r169                       ; [call: array_repeat_zero_big_u8_8]: pass argument 0
fncall .14                              ; [call: array_repeat_zero_big_u8_8]: call function
movi $r171 i0                           ; move parameter from branch to block argument
.84
move $r173 $r171                        ; move parameter from branch to block argument
movi $r174 i25                          ; initialize constant into register
lt $r175 $r171 $r174
jnzi $r175 .85
.86
addi $r176 $$locbase i120               ; get offset to local __ptr [u64; 25]
move $$arg0 $r176                       ; [call: array_repeat_zero_big_u32_10]: pass argument 0
fncall .16                              ; [call: array_repeat_zero_big_u32_10]: call function
addi $r178 $$locbase i120               ; get offset to local __ptr [u64; 25]
move $$arg0 $r178                       ; [call: is_all_zero_77]: pass argument 0
movi $$arg1 i25                         ; [call: is_all_zero_77]: pass argument 1
fncall .46                              ; [call: is_all_zero_77]: call function
addi $r181 $$locbase i320               ; get offset to local __ptr [u64; 25]
move $$arg0 $r181                       ; [call: array_repeat_zero_big_u32_10]: pass argument 0
fncall .16                              ; [call: array_repeat_zero_big_u32_10]: call function
addi $r183 $$locbase i320               ; get offset to local __ptr [u64; 25]
move $$arg0 $r183                       ; [call: is_all_zero_77]: pass argument 0
movi $$arg1 i25                         ; [call: is_all_zero_77]: pass argument 1
fncall .46                              ; [call: is_all_zero_77]: call function
addi $r186 $$locbase i520               ; get offset to local __ptr [u64; 25]
move $$arg0 $r186                       ; [call: array_repeat_zero_big_u32_10]: pass argument 0
fncall .16                              ; [call: array_repeat_zero_big_u32_10]: call function
addi $r188 $$locbase i520               ; get offset to local __ptr [u64; 25]
move $$arg0 $r188                       ; [call: is_all_zero_77]: pass argument 0
movi $$arg1 i25                         ; [call: is_all_zero_77]: pass argument 1
fncall .46                              ; [call: is_all_zero_77]: call function
addi $r191 $$locbase i1088              ; get offset to local __ptr [u256; 25]
move $$arg0 $r191                       ; [call: array_repeat_zero_big_u256_12]: pass argument 0
fncall .18                              ; [call: array_repeat_zero_big_u256_12]: call function
movi $r193 i0                           ; move parameter from branch to block argument
.87
move $r195 $r193                        ; move parameter from branch to block argument
movi $r196 i25                          ; initialize constant into register
lt $r197 $r193 $r196
jnzi $r197 .88
.89
addi $r198 $$locbase i1888              ; get offset to local __ptr [b256; 25]
move $$arg0 $r198                       ; [call: array_repeat_zero_big_b256_13]: pass argument 0
fncall .20                              ; [call: array_repeat_zero_big_b256_13]: call function
movi $r200 i0                           ; move parameter from branch to block argument
.90
move $r202 $r200                        ; move parameter from branch to block argument
movi $r203 i25                          ; initialize constant into register
lt $r204 $r200 $r203
jnzi $r204 .91
.92
addi $r205 $$locbase i2688              ; get offset to local __ptr [bool; 25]
move $$arg0 $r205                       ; [call: array_repeat_zero_big_bool_14]: pass argument 0
fncall .22                              ; [call: array_repeat_zero_big_bool_14]: call function
movi $r207 i0                           ; move parameter from branch to block argument
.93
move $r209 $r207                        ; move parameter from branch to block argument
movi $r210 i25                          ; initialize constant into register
lt $r211 $r207 $r210
jnzi $r211 .94
.95
addi $r212 $$locbase i2720              ; get offset to local __ptr [u8; 262145]
move $$arg0 $r212                       ; [call: u8_array_bigger_than_18_bits_17]: pass argument 0
fncall .28                              ; [call: u8_array_bigger_than_18_bits_17]: call function
movi $r214 i0                           ; move parameter from branch to block argument
.96
move $r216 $r214                        ; move parameter from branch to block argument
load $r217 data_NonConfigurable_1       ; load constant from data section
lt $r218 $r214 $r217
jnzi $r218 .97
.98
ret $zero                               ; [entry end: test_array_repeat_zero] return unit as zero
.97
addi $r219 $$locbase i2720              ; get offset to local __ptr [u8; 262145]
muli $r221 $r216 i1                     ; get offset to array element
add $r221 $r219 $r221                   ; add array element offset to array base
lb $r222 $r221 i0                       ; load byte
eq $r223 $r222 $zero
eq $r224 $r223 $zero
jnzi $r224 .99
.100
addi $r225 $r216 i1
move $r214 $r225                        ; move parameter from branch to block argument
ji  .96
.99
load $r227 data_NonConfigurable_3       ; load constant from data section
rvrt $r227
.94
addi $r228 $$locbase i2688              ; get offset to local __ptr [bool; 25]
muli $r230 $r209 i1                     ; get offset to array element
add $r230 $r228 $r230                   ; add array element offset to array base
lb $r231 $r230 i0                       ; load byte
eq $r232 $r231 $zero
eq $r233 $r232 $zero
jnzi $r233 .101
.102
addi $r234 $r209 i1
move $r207 $r234                        ; move parameter from branch to block argument
ji  .93
.101
load $r236 data_NonConfigurable_3       ; load constant from data section
rvrt $r236
.91
addi $r237 $$locbase i1888              ; get offset to local __ptr [b256; 25]
muli $r239 $r202 i32                    ; get offset to array element
add $r239 $r237 $r239                   ; add array element offset to array base
move $$arg0 $r239                       ; [call: is_zero_69]: pass argument 0
fncall .44                              ; [call: is_zero_69]: call function
eq $r241 $$retv $zero
jnzi $r241 .103
.104
addi $r242 $r202 i1
move $r200 $r242                        ; move parameter from branch to block argument
ji  .90
.103
load $r244 data_NonConfigurable_3       ; load constant from data section
rvrt $r244
.88
addi $r245 $$locbase i1088              ; get offset to local __ptr [u256; 25]
muli $r247 $r195 i32                    ; get offset to array element
add $r247 $r245 $r247                   ; add array element offset to array base
move $$arg0 $r247                       ; [call: is_zero_66]: pass argument 0
fncall .42                              ; [call: is_zero_66]: call function
eq $r249 $$retv $zero
jnzi $r249 .105
.106
addi $r250 $r195 i1
move $r193 $r250                        ; move parameter from branch to block argument
ji  .87
.105
load $r252 data_NonConfigurable_3       ; load constant from data section
rvrt $r252
.85
addi $r253 $$locbase i1056              ; get offset to local __ptr [u8; 25]
muli $r255 $r173 i1                     ; get offset to array element
add $r255 $r253 $r255                   ; add array element offset to array base
lb $r256 $r255 i0                       ; load byte
eq $r257 $r256 $zero
eq $r258 $r257 $zero
jnzi $r258 .107
.108
addi $r259 $r173 i1
move $r171 $r259                        ; move parameter from branch to block argument
ji  .84
.107
load $r261 data_NonConfigurable_3       ; load constant from data section
rvrt $r261
.82
addi $r262 $$locbase i1048              ; get offset to local __ptr [bool; 5]
muli $r264 $r166 i1                     ; get offset to array element
add $r264 $r262 $r264                   ; add array element offset to array base
lb $r265 $r264 i0                       ; load byte
eq $r266 $r265 $zero
eq $r267 $r266 $zero
jnzi $r267 .109
.110
addi $r268 $r166 i1
move $r164 $r268                        ; move parameter from branch to block argument
ji  .81
.109
load $r270 data_NonConfigurable_3       ; load constant from data section
rvrt $r270
.79
addi $r271 $$locbase i888               ; get offset to local __ptr [b256; 5]
muli $r273 $r159 i32                    ; get offset to array element
add $r273 $r271 $r273                   ; add array element offset to array base
move $$arg0 $r273                       ; [call: is_zero_69]: pass argument 0
fncall .44                              ; [call: is_zero_69]: call function
eq $r275 $$retv $zero
jnzi $r275 .111
.112
addi $r276 $r159 i1
move $r157 $r276                        ; move parameter from branch to block argument
ji  .78
.111
load $r278 data_NonConfigurable_3       ; load constant from data section
rvrt $r278
.76
addi $r279 $$locbase i728               ; get offset to local __ptr [u256; 5]
muli $r281 $r152 i32                    ; get offset to array element
add $r281 $r279 $r281                   ; add array element offset to array base
move $$arg0 $r281                       ; [call: is_zero_66]: pass argument 0
fncall .42                              ; [call: is_zero_66]: call function
eq $r283 $$retv $zero
jnzi $r283 .113
.114
addi $r284 $r152 i1
move $r150 $r284                        ; move parameter from branch to block argument
ji  .75
.113
load $r286 data_NonConfigurable_3       ; load constant from data section
rvrt $r286
.73
addi $r287 $$locbase i720               ; get offset to local __ptr [u8; 5]
muli $r289 $r132 i1                     ; get offset to array element
add $r289 $r287 $r289                   ; add array element offset to array base
lb $r290 $r289 i0                       ; load byte
eq $r291 $r290 $zero
eq $r292 $r291 $zero
jnzi $r292 .115
.116
addi $r293 $r132 i1
move $r130 $r293                        ; move parameter from branch to block argument
ji  .72
.115
load $r295 data_NonConfigurable_3       ; load constant from data section
rvrt $r295
DIFF------------------------------
.program:
.2                                      ; --- start of function: main_0 ---
pusha .2                                ; [fn init: main_0]: push all used registers to stack
move $$locbase $sp                      ; [fn init: main_0]: set locals base register
cfei i264920                            ; [fn init: main_0]: allocate: locals 264920 byte(s), call args 0 slot(s)
move $r2 $$reta                         ; [fn init: main_0]: save return address
.49
move $$arg0 $$locbase                   ; [call: array_repeat_zero_small_u8_1]: pass argument 0
fncall .4                               ; [call: array_repeat_zero_small_u8_1]: call function
 move $r3 $zero                          ; [call: array_repeat_zero_small_u8_1]: copy returned unit value
 movi $r3 i0                             ; [call: array_repeat_zero_small_u8_1]: copy returned unit value
addi $r4 $$locbase i8                   ; get offset to local __ptr [u64; 5]
move $$arg0 $r4                         ; [call: array_repeat_zero_small_u16_2]: pass argument 0
fncall .6                               ; [call: array_repeat_zero_small_u16_2]: call function
 move $r5 $zero                          ; [call: array_repeat_zero_small_u16_2]: copy returned unit value
 movi $r5 i0                             ; [call: array_repeat_zero_small_u16_2]: copy returned unit value
addi $r6 $$locbase i48                  ; get offset to local __ptr [u64; 5]
move $$arg0 $r6                         ; [call: array_repeat_zero_small_u16_2]: pass argument 0
fncall .6                               ; [call: array_repeat_zero_small_u16_2]: call function
 move $r7 $zero                          ; [call: array_repeat_zero_small_u16_2]: copy returned unit value
 movi $r7 i0                             ; [call: array_repeat_zero_small_u16_2]: copy returned unit value
movi $r8 i32989                         ; get word offset to local from base
muli $r8 $r8 i8                         ; get byte offset to local from base
add $r8 $$locbase $r8                   ; get absolute byte offset to local
move $$arg0 $r8                         ; [call: array_repeat_zero_small_u16_2]: pass argument 0
fncall .6                               ; [call: array_repeat_zero_small_u16_2]: call function
 move $r9 $zero                          ; [call: array_repeat_zero_small_u16_2]: copy returned unit value
 movi $r9 i0                             ; [call: array_repeat_zero_small_u16_2]: copy returned unit value
movi $r10 i32994                        ; get word offset to local from base
muli $r10 $r10 i8                       ; get byte offset to local from base
add $r10 $$locbase $r10                 ; get absolute byte offset to local
move $$arg0 $r10                        ; [call: array_repeat_zero_small_u256_5]: pass argument 0
fncall .8                               ; [call: array_repeat_zero_small_u256_5]: call function
 move $r11 $zero                         ; [call: array_repeat_zero_small_u256_5]: copy returned unit value
 movi $r11 i0                            ; [call: array_repeat_zero_small_u256_5]: copy returned unit value
movi $r12 i33014                        ; get word offset to local from base
muli $r12 $r12 i8                       ; get byte offset to local from base
add $r12 $$locbase $r12                 ; get absolute byte offset to local
move $$arg0 $r12                        ; [call: array_repeat_zero_small_b256_6]: pass argument 0
fncall .10                              ; [call: array_repeat_zero_small_b256_6]: call function
 move $r13 $zero                         ; [call: array_repeat_zero_small_b256_6]: copy returned unit value
 movi $r13 i0                            ; [call: array_repeat_zero_small_b256_6]: copy returned unit value
movi $r14 i33034                        ; get word offset to local from base
muli $r14 $r14 i8                       ; get byte offset to local from base
add $r14 $$locbase $r14                 ; get absolute byte offset to local
move $$arg0 $r14                        ; [call: array_repeat_zero_small_bool_7]: pass argument 0
fncall .12                              ; [call: array_repeat_zero_small_bool_7]: call function
 move $r15 $zero                         ; [call: array_repeat_zero_small_bool_7]: copy returned unit value
 movi $r15 i0                            ; [call: array_repeat_zero_small_bool_7]: copy returned unit value
movi $r16 i33035                        ; get word offset to local from base
muli $r16 $r16 i8                       ; get byte offset to local from base
add $r16 $$locbase $r16                 ; get absolute byte offset to local
move $$arg0 $r16                        ; [call: array_repeat_zero_big_u8_8]: pass argument 0
fncall .14                              ; [call: array_repeat_zero_big_u8_8]: call function
 move $r17 $zero                         ; [call: array_repeat_zero_big_u8_8]: copy returned unit value
 movi $r17 i0                            ; [call: array_repeat_zero_big_u8_8]: copy returned unit value
movi $r18 i33039                        ; get word offset to local from base
muli $r18 $r18 i8                       ; get byte offset to local from base
add $r18 $$locbase $r18                 ; get absolute byte offset to local
move $$arg0 $r18                        ; [call: array_repeat_zero_big_u32_10]: pass argument 0
fncall .16                              ; [call: array_repeat_zero_big_u32_10]: call function
 move $r19 $zero                         ; [call: array_repeat_zero_big_u32_10]: copy returned unit value
 movi $r19 i0                            ; [call: array_repeat_zero_big_u32_10]: copy returned unit value
movi $r20 i33064                        ; get word offset to local from base
muli $r20 $r20 i8                       ; get byte offset to local from base
add $r20 $$locbase $r20                 ; get absolute byte offset to local
move $$arg0 $r20                        ; [call: array_repeat_zero_big_u32_10]: pass argument 0
fncall .16                              ; [call: array_repeat_zero_big_u32_10]: call function
 move $r21 $zero                         ; [call: array_repeat_zero_big_u32_10]: copy returned unit value
 movi $r21 i0                            ; [call: array_repeat_zero_big_u32_10]: copy returned unit value
movi $r22 i33089                        ; get word offset to local from base
muli $r22 $r22 i8                       ; get byte offset to local from base
add $r22 $$locbase $r22                 ; get absolute byte offset to local
move $$arg0 $r22                        ; [call: array_repeat_zero_big_u32_10]: pass argument 0
fncall .16                              ; [call: array_repeat_zero_big_u32_10]: call function
 move $r23 $zero                         ; [call: array_repeat_zero_big_u32_10]: copy returned unit value
 movi $r23 i0                            ; [call: array_repeat_zero_big_u32_10]: copy returned unit value
addi $r24 $$locbase i88                 ; get offset to local __ptr [u256; 25]
move $$arg0 $r24                        ; [call: array_repeat_zero_big_u256_12]: pass argument 0
fncall .18                              ; [call: array_repeat_zero_big_u256_12]: call function
 move $r25 $zero                         ; [call: array_repeat_zero_big_u256_12]: copy returned unit value
 movi $r25 i0                            ; [call: array_repeat_zero_big_u256_12]: copy returned unit value
addi $r26 $$locbase i888                ; get offset to local __ptr [b256; 25]
move $$arg0 $r26                        ; [call: array_repeat_zero_big_b256_13]: pass argument 0
fncall .20                              ; [call: array_repeat_zero_big_b256_13]: call function
 move $r27 $zero                         ; [call: array_repeat_zero_big_b256_13]: copy returned unit value
 movi $r27 i0                            ; [call: array_repeat_zero_big_b256_13]: copy returned unit value
addi $r28 $$locbase i1688               ; get offset to local __ptr [bool; 25]
move $$arg0 $r28                        ; [call: array_repeat_zero_big_bool_14]: pass argument 0
fncall .22                              ; [call: array_repeat_zero_big_bool_14]: call function
 move $r29 $zero                         ; [call: array_repeat_zero_big_bool_14]: copy returned unit value
 movi $r29 i0                            ; [call: array_repeat_zero_big_bool_14]: copy returned unit value
addi $r30 $$locbase i1720               ; get offset to local __ptr [bool; 5]
move $$arg0 $r30                        ; [call: small_array_repeat_15]: pass argument 0
fncall .24                              ; [call: small_array_repeat_15]: call function
 move $r31 $zero                         ; [call: small_array_repeat_15]: copy returned unit value
 movi $r31 i0                            ; [call: small_array_repeat_15]: copy returned unit value
addi $r32 $$locbase i1728               ; get offset to local __ptr [bool; 25]
move $$arg0 $r32                        ; [call: big_array_repeat_16]: pass argument 0
fncall .26                              ; [call: big_array_repeat_16]: call function
 move $r33 $zero                         ; [call: big_array_repeat_16]: copy returned unit value
 movi $r33 i0                            ; [call: big_array_repeat_16]: copy returned unit value
addi $r34 $$locbase i1760               ; get offset to local __ptr [u8; 262145]
move $$arg0 $r34                        ; [call: u8_array_bigger_than_18_bits_17]: pass argument 0
fncall .28                              ; [call: u8_array_bigger_than_18_bits_17]: call function
 move $r35 $zero                         ; [call: u8_array_bigger_than_18_bits_17]: copy returned unit value
 movi $r35 i0                            ; [call: u8_array_bigger_than_18_bits_17]: copy returned unit value
fncall .30                              ; [call: arrays_with_const_length_18]: call function
 move $r36 $zero                         ; [call: arrays_with_const_length_18]: copy returned unit value
 movi $r36 i0                            ; [call: arrays_with_const_length_18]: copy returned unit value
movi $r37 i33114                        ; get word offset to local from base
muli $r37 $r37 i8                       ; get byte offset to local from base
add $r37 $$locbase $r37                 ; get absolute byte offset to local
move $$arg0 $r37                        ; [call: decode_array_19]: pass argument 0
fncall .32                              ; [call: decode_array_19]: call function
 move $r38 $zero                         ; [call: decode_array_19]: copy returned unit value
 movi $r38 i0                            ; [call: decode_array_19]: copy returned unit value
movi $r39 i33114                        ; get word offset to local from base
muli $r39 $r39 i8                       ; get byte offset to local from base
add $r39 $$locbase $r39                 ; get absolute byte offset to local
movi $r40 i1                            ; get array element size
 mul $r41 $zero $r40                     ; get offset to array element
 add $r41 $r39 $r41                      ; add array element offset to array base
 lb $r42 $r41 i0                         ; load byte
 movi $r41 i0                            ; get offset to array element
 move $r41 $r39                          ; add array element offset to array base
 lb $r42 $r39 i0                         ; load byte
movi $r43 i255                          ; initialize constant into register
eq $r44 $r42 $r43
eq $r45 $r44 $zero
jnzi $r45 .50
ji  .51
.51
ji  .3
.50
move $$arg0 $r42                        ; [call: log_46]: pass argument 0
fncall .36                              ; [call: log_46]: call function
 move $r46 $zero                         ; [call: log_46]: copy returned unit value
 movi $r46 i0                            ; [call: log_46]: copy returned unit value
movi $r47 i255                          ; initialize constant into register
 move $$arg0 $r47                        ; [call: log_46]: pass argument 0
 movi $$arg0 i255                        ; [call: log_46]: pass argument 0
fncall .36                              ; [call: log_46]: call function
 move $r48 $zero                         ; [call: log_46]: copy returned unit value
 movi $r48 i0                            ; [call: log_46]: copy returned unit value
load $r49 data_NonConfigurable_0        ; load constant from data section
rvrt $r49
.3
cfsi i264920                            ; [fn end: main_0] free: locals 264920 byte(s), call args 0 slot(s)
move $$reta $r2                         ; [fn end: main_0] restore return address
popa .2                                 ; [fn end: main_0] restore all used registers
jal $zero $$reta i0                     ; [fn end: main_0] return from call
DIFF------------------------------
.program:
.2                                      ; --- start of function: main_0 ---
pusha .2                                ; [fn init: main_0]: push all used registers to stack
move $$locbase $sp                      ; [fn init: main_0]: set locals base register
cfei i264920                            ; [fn init: main_0]: allocate: locals 264920 byte(s), call args 0 slot(s)
move $r2 $$reta                         ; [fn init: main_0]: save return address
.49
move $$arg0 $$locbase                   ; [call: array_repeat_zero_small_u8_1]: pass argument 0
fncall .4                               ; [call: array_repeat_zero_small_u8_1]: call function
addi $r4 $$locbase i8                   ; get offset to local __ptr [u64; 5]
move $$arg0 $r4                         ; [call: array_repeat_zero_small_u16_2]: pass argument 0
fncall .6                               ; [call: array_repeat_zero_small_u16_2]: call function
addi $r6 $$locbase i48                  ; get offset to local __ptr [u64; 5]
move $$arg0 $r6                         ; [call: array_repeat_zero_small_u16_2]: pass argument 0
fncall .6                               ; [call: array_repeat_zero_small_u16_2]: call function
movi $r8 i32989                         ; get word offset to local from base
muli $r8 $r8 i8                         ; get byte offset to local from base
add $r8 $$locbase $r8                   ; get absolute byte offset to local
move $$arg0 $r8                         ; [call: array_repeat_zero_small_u16_2]: pass argument 0
fncall .6                               ; [call: array_repeat_zero_small_u16_2]: call function
movi $r10 i32994                        ; get word offset to local from base
muli $r10 $r10 i8                       ; get byte offset to local from base
add $r10 $$locbase $r10                 ; get absolute byte offset to local
move $$arg0 $r10                        ; [call: array_repeat_zero_small_u256_5]: pass argument 0
fncall .8                               ; [call: array_repeat_zero_small_u256_5]: call function
movi $r12 i33014                        ; get word offset to local from base
muli $r12 $r12 i8                       ; get byte offset to local from base
add $r12 $$locbase $r12                 ; get absolute byte offset to local
move $$arg0 $r12                        ; [call: array_repeat_zero_small_b256_6]: pass argument 0
fncall .10                              ; [call: array_repeat_zero_small_b256_6]: call function
movi $r14 i33034                        ; get word offset to local from base
muli $r14 $r14 i8                       ; get byte offset to local from base
add $r14 $$locbase $r14                 ; get absolute byte offset to local
move $$arg0 $r14                        ; [call: array_repeat_zero_small_bool_7]: pass argument 0
fncall .12                              ; [call: array_repeat_zero_small_bool_7]: call function
movi $r16 i33035                        ; get word offset to local from base
muli $r16 $r16 i8                       ; get byte offset to local from base
add $r16 $$locbase $r16                 ; get absolute byte offset to local
move $$arg0 $r16                        ; [call: array_repeat_zero_big_u8_8]: pass argument 0
fncall .14                              ; [call: array_repeat_zero_big_u8_8]: call function
movi $r18 i33039                        ; get word offset to local from base
muli $r18 $r18 i8                       ; get byte offset to local from base
add $r18 $$locbase $r18                 ; get absolute byte offset to local
move $$arg0 $r18                        ; [call: array_repeat_zero_big_u32_10]: pass argument 0
fncall .16                              ; [call: array_repeat_zero_big_u32_10]: call function
movi $r20 i33064                        ; get word offset to local from base
muli $r20 $r20 i8                       ; get byte offset to local from base
add $r20 $$locbase $r20                 ; get absolute byte offset to local
move $$arg0 $r20                        ; [call: array_repeat_zero_big_u32_10]: pass argument 0
fncall .16                              ; [call: array_repeat_zero_big_u32_10]: call function
movi $r22 i33089                        ; get word offset to local from base
muli $r22 $r22 i8                       ; get byte offset to local from base
add $r22 $$locbase $r22                 ; get absolute byte offset to local
move $$arg0 $r22                        ; [call: array_repeat_zero_big_u32_10]: pass argument 0
fncall .16                              ; [call: array_repeat_zero_big_u32_10]: call function
addi $r24 $$locbase i88                 ; get offset to local __ptr [u256; 25]
move $$arg0 $r24                        ; [call: array_repeat_zero_big_u256_12]: pass argument 0
fncall .18                              ; [call: array_repeat_zero_big_u256_12]: call function
addi $r26 $$locbase i888                ; get offset to local __ptr [b256; 25]
move $$arg0 $r26                        ; [call: array_repeat_zero_big_b256_13]: pass argument 0
fncall .20                              ; [call: array_repeat_zero_big_b256_13]: call function
addi $r28 $$locbase i1688               ; get offset to local __ptr [bool; 25]
move $$arg0 $r28                        ; [call: array_repeat_zero_big_bool_14]: pass argument 0
fncall .22                              ; [call: array_repeat_zero_big_bool_14]: call function
addi $r30 $$locbase i1720               ; get offset to local __ptr [bool; 5]
move $$arg0 $r30                        ; [call: small_array_repeat_15]: pass argument 0
fncall .24                              ; [call: small_array_repeat_15]: call function
addi $r32 $$locbase i1728               ; get offset to local __ptr [bool; 25]
move $$arg0 $r32                        ; [call: big_array_repeat_16]: pass argument 0
fncall .26                              ; [call: big_array_repeat_16]: call function
addi $r34 $$locbase i1760               ; get offset to local __ptr [u8; 262145]
move $$arg0 $r34                        ; [call: u8_array_bigger_than_18_bits_17]: pass argument 0
fncall .28                              ; [call: u8_array_bigger_than_18_bits_17]: call function
fncall .30                              ; [call: arrays_with_const_length_18]: call function
movi $r37 i33114                        ; get word offset to local from base
muli $r37 $r37 i8                       ; get byte offset to local from base
add $r37 $$locbase $r37                 ; get absolute byte offset to local
move $$arg0 $r37                        ; [call: decode_array_19]: pass argument 0
fncall .32                              ; [call: decode_array_19]: call function
movi $r39 i33114                        ; get word offset to local from base
muli $r39 $r39 i8                       ; get byte offset to local from base
add $r39 $$locbase $r39                 ; get absolute byte offset to local
lb $r42 $r39 i0                         ; load byte
movi $r43 i255                          ; initialize constant into register
eq $r44 $r42 $r43
eq $r45 $r44 $zero
jnzi $r45 .50
.51
ji  .3
.50
move $$arg0 $r42                        ; [call: log_46]: pass argument 0
fncall .36                              ; [call: log_46]: call function
movi $$arg0 i255                        ; [call: log_46]: pass argument 0
fncall .36                              ; [call: log_46]: call function
load $r49 data_NonConfigurable_0        ; load constant from data section
rvrt $r49
.3
cfsi i264920                            ; [fn end: main_0] free: locals 264920 byte(s), call args 0 slot(s)
move $$reta $r2                         ; [fn end: main_0] restore return address
popa .2                                 ; [fn end: main_0] restore all used registers
jal $zero $$reta i0                     ; [fn end: main_0] return from call
DIFF------------------------------
.program:
.2                                      ; --- start of function: main_0 ---
pusha .2                                ; [fn init: main_0]: push all used registers to stack
move $$locbase $sp                      ; [fn init: main_0]: set locals base register
cfei i264920                            ; [fn init: main_0]: allocate: locals 264920 byte(s), call args 0 slot(s)
move $r2 $$reta                         ; [fn init: main_0]: save return address
.49
move $$arg0 $$locbase                   ; [call: array_repeat_zero_small_u8_1]: pass argument 0
fncall .4                               ; [call: array_repeat_zero_small_u8_1]: call function
addi $r4 $$locbase i8                   ; get offset to local __ptr [u64; 5]
move $$arg0 $r4                         ; [call: array_repeat_zero_small_u16_2]: pass argument 0
fncall .6                               ; [call: array_repeat_zero_small_u16_2]: call function
addi $r6 $$locbase i48                  ; get offset to local __ptr [u64; 5]
move $$arg0 $r6                         ; [call: array_repeat_zero_small_u16_2]: pass argument 0
fncall .6                               ; [call: array_repeat_zero_small_u16_2]: call function
movi $r8 i32989                         ; get word offset to local from base
muli $r8 $r8 i8                         ; get byte offset to local from base
add $r8 $$locbase $r8                   ; get absolute byte offset to local
move $$arg0 $r8                         ; [call: array_repeat_zero_small_u16_2]: pass argument 0
fncall .6                               ; [call: array_repeat_zero_small_u16_2]: call function
movi $r10 i32994                        ; get word offset to local from base
muli $r10 $r10 i8                       ; get byte offset to local from base
add $r10 $$locbase $r10                 ; get absolute byte offset to local
move $$arg0 $r10                        ; [call: array_repeat_zero_small_u256_5]: pass argument 0
fncall .8                               ; [call: array_repeat_zero_small_u256_5]: call function
movi $r12 i33014                        ; get word offset to local from base
muli $r12 $r12 i8                       ; get byte offset to local from base
add $r12 $$locbase $r12                 ; get absolute byte offset to local
move $$arg0 $r12                        ; [call: array_repeat_zero_small_b256_6]: pass argument 0
fncall .10                              ; [call: array_repeat_zero_small_b256_6]: call function
movi $r14 i33034                        ; get word offset to local from base
muli $r14 $r14 i8                       ; get byte offset to local from base
add $r14 $$locbase $r14                 ; get absolute byte offset to local
move $$arg0 $r14                        ; [call: array_repeat_zero_small_bool_7]: pass argument 0
fncall .12                              ; [call: array_repeat_zero_small_bool_7]: call function
movi $r16 i33035                        ; get word offset to local from base
muli $r16 $r16 i8                       ; get byte offset to local from base
add $r16 $$locbase $r16                 ; get absolute byte offset to local
move $$arg0 $r16                        ; [call: array_repeat_zero_big_u8_8]: pass argument 0
fncall .14                              ; [call: array_repeat_zero_big_u8_8]: call function
movi $r18 i33039                        ; get word offset to local from base
muli $r18 $r18 i8                       ; get byte offset to local from base
add $r18 $$locbase $r18                 ; get absolute byte offset to local
move $$arg0 $r18                        ; [call: array_repeat_zero_big_u32_10]: pass argument 0
fncall .16                              ; [call: array_repeat_zero_big_u32_10]: call function
movi $r20 i33064                        ; get word offset to local from base
muli $r20 $r20 i8                       ; get byte offset to local from base
add $r20 $$locbase $r20                 ; get absolute byte offset to local
move $$arg0 $r20                        ; [call: array_repeat_zero_big_u32_10]: pass argument 0
fncall .16                              ; [call: array_repeat_zero_big_u32_10]: call function
movi $r22 i33089                        ; get word offset to local from base
muli $r22 $r22 i8                       ; get byte offset to local from base
add $r22 $$locbase $r22                 ; get absolute byte offset to local
move $$arg0 $r22                        ; [call: array_repeat_zero_big_u32_10]: pass argument 0
fncall .16                              ; [call: array_repeat_zero_big_u32_10]: call function
addi $r24 $$locbase i88                 ; get offset to local __ptr [u256; 25]
move $$arg0 $r24                        ; [call: array_repeat_zero_big_u256_12]: pass argument 0
fncall .18                              ; [call: array_repeat_zero_big_u256_12]: call function
addi $r26 $$locbase i888                ; get offset to local __ptr [b256; 25]
move $$arg0 $r26                        ; [call: array_repeat_zero_big_b256_13]: pass argument 0
fncall .20                              ; [call: array_repeat_zero_big_b256_13]: call function
addi $r28 $$locbase i1688               ; get offset to local __ptr [bool; 25]
move $$arg0 $r28                        ; [call: array_repeat_zero_big_bool_14]: pass argument 0
fncall .22                              ; [call: array_repeat_zero_big_bool_14]: call function
addi $r30 $$locbase i1720               ; get offset to local __ptr [bool; 5]
move $$arg0 $r30                        ; [call: small_array_repeat_15]: pass argument 0
fncall .24                              ; [call: small_array_repeat_15]: call function
addi $r32 $$locbase i1728               ; get offset to local __ptr [bool; 25]
move $$arg0 $r32                        ; [call: big_array_repeat_16]: pass argument 0
fncall .26                              ; [call: big_array_repeat_16]: call function
addi $r34 $$locbase i1760               ; get offset to local __ptr [u8; 262145]
move $$arg0 $r34                        ; [call: u8_array_bigger_than_18_bits_17]: pass argument 0
fncall .28                              ; [call: u8_array_bigger_than_18_bits_17]: call function
fncall .30                              ; [call: arrays_with_const_length_18]: call function
movi $r37 i33114                        ; get word offset to local from base
muli $r37 $r37 i8                       ; get byte offset to local from base
add $r37 $$locbase $r37                 ; get absolute byte offset to local
move $$arg0 $r37                        ; [call: decode_array_19]: pass argument 0
fncall .32                              ; [call: decode_array_19]: call function
movi $r39 i33114                        ; get word offset to local from base
muli $r39 $r39 i8                       ; get byte offset to local from base
add $r39 $$locbase $r39                 ; get absolute byte offset to local
lb $r42 $r39 i0                         ; load byte
movi $r43 i255                          ; initialize constant into register
eq $r44 $r42 $r43
eq $r45 $r44 $zero
jnzi $r45 .50
.51
ji  .3
.50
move $$arg0 $r42                        ; [call: log_46]: pass argument 0
fncall .36                              ; [call: log_46]: call function
movi $$arg0 i255                        ; [call: log_46]: pass argument 0
fncall .36                              ; [call: log_46]: call function
load $r49 data_NonConfigurable_0        ; load constant from data section
rvrt $r49
.3
cfsi i264920                            ; [fn end: main_0] free: locals 264920 byte(s), call args 0 slot(s)
move $$reta $r2                         ; [fn end: main_0] restore return address
popa .2                                 ; [fn end: main_0] restore all used registers
jal $zero $$reta i0                     ; [fn end: main_0] return from call
DIFF------------------------------
.program:
.2                                      ; --- start of function: main_0 ---
pusha .2                                ; [fn init: main_0]: push all used registers to stack
move $$locbase $sp                      ; [fn init: main_0]: set locals base register
cfei i264920                            ; [fn init: main_0]: allocate: locals 264920 byte(s), call args 0 slot(s)
move $r2 $$reta                         ; [fn init: main_0]: save return address
.49
move $$arg0 $$locbase                   ; [call: array_repeat_zero_small_u8_1]: pass argument 0
fncall .4                               ; [call: array_repeat_zero_small_u8_1]: call function
addi $r4 $$locbase i8                   ; get offset to local __ptr [u64; 5]
move $$arg0 $r4                         ; [call: array_repeat_zero_small_u16_2]: pass argument 0
fncall .6                               ; [call: array_repeat_zero_small_u16_2]: call function
addi $r6 $$locbase i48                  ; get offset to local __ptr [u64; 5]
move $$arg0 $r6                         ; [call: array_repeat_zero_small_u16_2]: pass argument 0
fncall .6                               ; [call: array_repeat_zero_small_u16_2]: call function
movi $r8 i32989                         ; get word offset to local from base
muli $r8 $r8 i8                         ; get byte offset to local from base
add $r8 $$locbase $r8                   ; get absolute byte offset to local
move $$arg0 $r8                         ; [call: array_repeat_zero_small_u16_2]: pass argument 0
fncall .6                               ; [call: array_repeat_zero_small_u16_2]: call function
movi $r10 i32994                        ; get word offset to local from base
muli $r10 $r10 i8                       ; get byte offset to local from base
add $r10 $$locbase $r10                 ; get absolute byte offset to local
move $$arg0 $r10                        ; [call: array_repeat_zero_small_u256_5]: pass argument 0
fncall .8                               ; [call: array_repeat_zero_small_u256_5]: call function
movi $r12 i33014                        ; get word offset to local from base
muli $r12 $r12 i8                       ; get byte offset to local from base
add $r12 $$locbase $r12                 ; get absolute byte offset to local
move $$arg0 $r12                        ; [call: array_repeat_zero_small_b256_6]: pass argument 0
fncall .10                              ; [call: array_repeat_zero_small_b256_6]: call function
movi $r14 i33034                        ; get word offset to local from base
muli $r14 $r14 i8                       ; get byte offset to local from base
add $r14 $$locbase $r14                 ; get absolute byte offset to local
move $$arg0 $r14                        ; [call: array_repeat_zero_small_bool_7]: pass argument 0
fncall .12                              ; [call: array_repeat_zero_small_bool_7]: call function
movi $r16 i33035                        ; get word offset to local from base
muli $r16 $r16 i8                       ; get byte offset to local from base
add $r16 $$locbase $r16                 ; get absolute byte offset to local
move $$arg0 $r16                        ; [call: array_repeat_zero_big_u8_8]: pass argument 0
fncall .14                              ; [call: array_repeat_zero_big_u8_8]: call function
movi $r18 i33039                        ; get word offset to local from base
muli $r18 $r18 i8                       ; get byte offset to local from base
add $r18 $$locbase $r18                 ; get absolute byte offset to local
move $$arg0 $r18                        ; [call: array_repeat_zero_big_u32_10]: pass argument 0
fncall .16                              ; [call: array_repeat_zero_big_u32_10]: call function
movi $r20 i33064                        ; get word offset to local from base
muli $r20 $r20 i8                       ; get byte offset to local from base
add $r20 $$locbase $r20                 ; get absolute byte offset to local
move $$arg0 $r20                        ; [call: array_repeat_zero_big_u32_10]: pass argument 0
fncall .16                              ; [call: array_repeat_zero_big_u32_10]: call function
movi $r22 i33089                        ; get word offset to local from base
muli $r22 $r22 i8                       ; get byte offset to local from base
add $r22 $$locbase $r22                 ; get absolute byte offset to local
move $$arg0 $r22                        ; [call: array_repeat_zero_big_u32_10]: pass argument 0
fncall .16                              ; [call: array_repeat_zero_big_u32_10]: call function
addi $r24 $$locbase i88                 ; get offset to local __ptr [u256; 25]
move $$arg0 $r24                        ; [call: array_repeat_zero_big_u256_12]: pass argument 0
fncall .18                              ; [call: array_repeat_zero_big_u256_12]: call function
addi $r26 $$locbase i888                ; get offset to local __ptr [b256; 25]
move $$arg0 $r26                        ; [call: array_repeat_zero_big_b256_13]: pass argument 0
fncall .20                              ; [call: array_repeat_zero_big_b256_13]: call function
addi $r28 $$locbase i1688               ; get offset to local __ptr [bool; 25]
move $$arg0 $r28                        ; [call: array_repeat_zero_big_bool_14]: pass argument 0
fncall .22                              ; [call: array_repeat_zero_big_bool_14]: call function
addi $r30 $$locbase i1720               ; get offset to local __ptr [bool; 5]
move $$arg0 $r30                        ; [call: small_array_repeat_15]: pass argument 0
fncall .24                              ; [call: small_array_repeat_15]: call function
addi $r32 $$locbase i1728               ; get offset to local __ptr [bool; 25]
move $$arg0 $r32                        ; [call: big_array_repeat_16]: pass argument 0
fncall .26                              ; [call: big_array_repeat_16]: call function
addi $r34 $$locbase i1760               ; get offset to local __ptr [u8; 262145]
move $$arg0 $r34                        ; [call: u8_array_bigger_than_18_bits_17]: pass argument 0
fncall .28                              ; [call: u8_array_bigger_than_18_bits_17]: call function
fncall .30                              ; [call: arrays_with_const_length_18]: call function
movi $r37 i33114                        ; get word offset to local from base
muli $r37 $r37 i8                       ; get byte offset to local from base
add $r37 $$locbase $r37                 ; get absolute byte offset to local
move $$arg0 $r37                        ; [call: decode_array_19]: pass argument 0
fncall .32                              ; [call: decode_array_19]: call function
movi $r39 i33114                        ; get word offset to local from base
muli $r39 $r39 i8                       ; get byte offset to local from base
add $r39 $$locbase $r39                 ; get absolute byte offset to local
lb $r42 $r39 i0                         ; load byte
movi $r43 i255                          ; initialize constant into register
eq $r44 $r42 $r43
eq $r45 $r44 $zero
jnzi $r45 .50
.51
ji  .3
.50
move $$arg0 $r42                        ; [call: log_46]: pass argument 0
fncall .36                              ; [call: log_46]: call function
movi $$arg0 i255                        ; [call: log_46]: pass argument 0
fncall .36                              ; [call: log_46]: call function
load $r49 data_NonConfigurable_0        ; load constant from data section
rvrt $r49
.3
cfsi i264920                            ; [fn end: main_0] free: locals 264920 byte(s), call args 0 slot(s)
move $$reta $r2                         ; [fn end: main_0] restore return address
popa .2                                 ; [fn end: main_0] restore all used registers
jal $zero $$reta i0                     ; [fn end: main_0] return from call
DIFF------------------------------
.program:
.4                                      ; --- start of function: array_repeat_zero_small_u8_1 ---
pusha .4                                ; [fn init: array_repeat_zero_small_u8_1]: push all used registers to stack
move $$locbase $sp                      ; [fn init: array_repeat_zero_small_u8_1]: set locals base register
cfei i0                                 ; [fn init: array_repeat_zero_small_u8_1]: allocate: locals 0 byte(s), call args 0 slot(s)
.52
mcli $$arg0 i5                          ; clear memory [u8; 5], 5 bytes
ji  .5
.5
cfsi i0                                 ; [fn end: array_repeat_zero_small_u8_1] free: locals 0 byte(s), call args 0 slot(s)
popa .4                                 ; [fn end: array_repeat_zero_small_u8_1] restore all used registers
jal $zero $$reta i0                     ; [fn end: array_repeat_zero_small_u8_1] return from call
DIFF------------------------------
.program:
.4                                      ; --- start of function: array_repeat_zero_small_u8_1 ---
pusha .4                                ; [fn init: array_repeat_zero_small_u8_1]: push all used registers to stack
move $$locbase $sp                      ; [fn init: array_repeat_zero_small_u8_1]: set locals base register
cfei i0                                 ; [fn init: array_repeat_zero_small_u8_1]: allocate: locals 0 byte(s), call args 0 slot(s)
.52
mcli $$arg0 i5                          ; clear memory [u8; 5], 5 bytes
.5
cfsi i0                                 ; [fn end: array_repeat_zero_small_u8_1] free: locals 0 byte(s), call args 0 slot(s)
popa .4                                 ; [fn end: array_repeat_zero_small_u8_1] restore all used registers
jal $zero $$reta i0                     ; [fn end: array_repeat_zero_small_u8_1] return from call
DIFF------------------------------
.program:
.4                                      ; --- start of function: array_repeat_zero_small_u8_1 ---
pusha .4                                ; [fn init: array_repeat_zero_small_u8_1]: push all used registers to stack
move $$locbase $sp                      ; [fn init: array_repeat_zero_small_u8_1]: set locals base register
cfei i0                                 ; [fn init: array_repeat_zero_small_u8_1]: allocate: locals 0 byte(s), call args 0 slot(s)
.52
mcli $$arg0 i5                          ; clear memory [u8; 5], 5 bytes
.5
cfsi i0                                 ; [fn end: array_repeat_zero_small_u8_1] free: locals 0 byte(s), call args 0 slot(s)
popa .4                                 ; [fn end: array_repeat_zero_small_u8_1] restore all used registers
jal $zero $$reta i0                     ; [fn end: array_repeat_zero_small_u8_1] return from call
DIFF------------------------------
.program:
.4                                      ; --- start of function: array_repeat_zero_small_u8_1 ---
pusha .4                                ; [fn init: array_repeat_zero_small_u8_1]: push all used registers to stack
move $$locbase $sp                      ; [fn init: array_repeat_zero_small_u8_1]: set locals base register
cfei i0                                 ; [fn init: array_repeat_zero_small_u8_1]: allocate: locals 0 byte(s), call args 0 slot(s)
.52
mcli $$arg0 i5                          ; clear memory [u8; 5], 5 bytes
.5
cfsi i0                                 ; [fn end: array_repeat_zero_small_u8_1] free: locals 0 byte(s), call args 0 slot(s)
popa .4                                 ; [fn end: array_repeat_zero_small_u8_1] restore all used registers
jal $zero $$reta i0                     ; [fn end: array_repeat_zero_small_u8_1] return from call
DIFF------------------------------
.program:
.6                                      ; --- start of function: array_repeat_zero_small_u16_2 ---
pusha .6                                ; [fn init: array_repeat_zero_small_u16_2]: push all used registers to stack
move $$locbase $sp                      ; [fn init: array_repeat_zero_small_u16_2]: set locals base register
cfei i0                                 ; [fn init: array_repeat_zero_small_u16_2]: allocate: locals 0 byte(s), call args 0 slot(s)
.53
mcli $$arg0 i40                         ; clear memory [u64; 5], 40 bytes
ji  .7
.7
cfsi i0                                 ; [fn end: array_repeat_zero_small_u16_2] free: locals 0 byte(s), call args 0 slot(s)
popa .6                                 ; [fn end: array_repeat_zero_small_u16_2] restore all used registers
jal $zero $$reta i0                     ; [fn end: array_repeat_zero_small_u16_2] return from call
DIFF------------------------------
.program:
.6                                      ; --- start of function: array_repeat_zero_small_u16_2 ---
pusha .6                                ; [fn init: array_repeat_zero_small_u16_2]: push all used registers to stack
move $$locbase $sp                      ; [fn init: array_repeat_zero_small_u16_2]: set locals base register
cfei i0                                 ; [fn init: array_repeat_zero_small_u16_2]: allocate: locals 0 byte(s), call args 0 slot(s)
.53
mcli $$arg0 i40                         ; clear memory [u64; 5], 40 bytes
.7
cfsi i0                                 ; [fn end: array_repeat_zero_small_u16_2] free: locals 0 byte(s), call args 0 slot(s)
popa .6                                 ; [fn end: array_repeat_zero_small_u16_2] restore all used registers
jal $zero $$reta i0                     ; [fn end: array_repeat_zero_small_u16_2] return from call
DIFF------------------------------
.program:
.6                                      ; --- start of function: array_repeat_zero_small_u16_2 ---
pusha .6                                ; [fn init: array_repeat_zero_small_u16_2]: push all used registers to stack
move $$locbase $sp                      ; [fn init: array_repeat_zero_small_u16_2]: set locals base register
cfei i0                                 ; [fn init: array_repeat_zero_small_u16_2]: allocate: locals 0 byte(s), call args 0 slot(s)
.53
mcli $$arg0 i40                         ; clear memory [u64; 5], 40 bytes
.7
cfsi i0                                 ; [fn end: array_repeat_zero_small_u16_2] free: locals 0 byte(s), call args 0 slot(s)
popa .6                                 ; [fn end: array_repeat_zero_small_u16_2] restore all used registers
jal $zero $$reta i0                     ; [fn end: array_repeat_zero_small_u16_2] return from call
DIFF------------------------------
.program:
.6                                      ; --- start of function: array_repeat_zero_small_u16_2 ---
pusha .6                                ; [fn init: array_repeat_zero_small_u16_2]: push all used registers to stack
move $$locbase $sp                      ; [fn init: array_repeat_zero_small_u16_2]: set locals base register
cfei i0                                 ; [fn init: array_repeat_zero_small_u16_2]: allocate: locals 0 byte(s), call args 0 slot(s)
.53
mcli $$arg0 i40                         ; clear memory [u64; 5], 40 bytes
.7
cfsi i0                                 ; [fn end: array_repeat_zero_small_u16_2] free: locals 0 byte(s), call args 0 slot(s)
popa .6                                 ; [fn end: array_repeat_zero_small_u16_2] restore all used registers
jal $zero $$reta i0                     ; [fn end: array_repeat_zero_small_u16_2] return from call
DIFF------------------------------
.program:
.8                                      ; --- start of function: array_repeat_zero_small_u256_5 ---
pusha .8                                ; [fn init: array_repeat_zero_small_u256_5]: push all used registers to stack
move $$locbase $sp                      ; [fn init: array_repeat_zero_small_u256_5]: set locals base register
cfei i0                                 ; [fn init: array_repeat_zero_small_u256_5]: allocate: locals 0 byte(s), call args 0 slot(s)
.54
mcli $$arg0 i160                        ; clear memory [u256; 5], 160 bytes
ji  .9
.9
cfsi i0                                 ; [fn end: array_repeat_zero_small_u256_5] free: locals 0 byte(s), call args 0 slot(s)
popa .8                                 ; [fn end: array_repeat_zero_small_u256_5] restore all used registers
jal $zero $$reta i0                     ; [fn end: array_repeat_zero_small_u256_5] return from call
DIFF------------------------------
.program:
.8                                      ; --- start of function: array_repeat_zero_small_u256_5 ---
pusha .8                                ; [fn init: array_repeat_zero_small_u256_5]: push all used registers to stack
move $$locbase $sp                      ; [fn init: array_repeat_zero_small_u256_5]: set locals base register
cfei i0                                 ; [fn init: array_repeat_zero_small_u256_5]: allocate: locals 0 byte(s), call args 0 slot(s)
.54
mcli $$arg0 i160                        ; clear memory [u256; 5], 160 bytes
.9
cfsi i0                                 ; [fn end: array_repeat_zero_small_u256_5] free: locals 0 byte(s), call args 0 slot(s)
popa .8                                 ; [fn end: array_repeat_zero_small_u256_5] restore all used registers
jal $zero $$reta i0                     ; [fn end: array_repeat_zero_small_u256_5] return from call
DIFF------------------------------
.program:
.8                                      ; --- start of function: array_repeat_zero_small_u256_5 ---
pusha .8                                ; [fn init: array_repeat_zero_small_u256_5]: push all used registers to stack
move $$locbase $sp                      ; [fn init: array_repeat_zero_small_u256_5]: set locals base register
cfei i0                                 ; [fn init: array_repeat_zero_small_u256_5]: allocate: locals 0 byte(s), call args 0 slot(s)
.54
mcli $$arg0 i160                        ; clear memory [u256; 5], 160 bytes
.9
cfsi i0                                 ; [fn end: array_repeat_zero_small_u256_5] free: locals 0 byte(s), call args 0 slot(s)
popa .8                                 ; [fn end: array_repeat_zero_small_u256_5] restore all used registers
jal $zero $$reta i0                     ; [fn end: array_repeat_zero_small_u256_5] return from call
DIFF------------------------------
.program:
.8                                      ; --- start of function: array_repeat_zero_small_u256_5 ---
pusha .8                                ; [fn init: array_repeat_zero_small_u256_5]: push all used registers to stack
move $$locbase $sp                      ; [fn init: array_repeat_zero_small_u256_5]: set locals base register
cfei i0                                 ; [fn init: array_repeat_zero_small_u256_5]: allocate: locals 0 byte(s), call args 0 slot(s)
.54
mcli $$arg0 i160                        ; clear memory [u256; 5], 160 bytes
.9
cfsi i0                                 ; [fn end: array_repeat_zero_small_u256_5] free: locals 0 byte(s), call args 0 slot(s)
popa .8                                 ; [fn end: array_repeat_zero_small_u256_5] restore all used registers
jal $zero $$reta i0                     ; [fn end: array_repeat_zero_small_u256_5] return from call
DIFF------------------------------
.program:
.10                                     ; --- start of function: array_repeat_zero_small_b256_6 ---
pusha .10                               ; [fn init: array_repeat_zero_small_b256_6]: push all used registers to stack
move $$locbase $sp                      ; [fn init: array_repeat_zero_small_b256_6]: set locals base register
cfei i0                                 ; [fn init: array_repeat_zero_small_b256_6]: allocate: locals 0 byte(s), call args 0 slot(s)
.55
mcli $$arg0 i160                        ; clear memory [b256; 5], 160 bytes
ji  .11
.11
cfsi i0                                 ; [fn end: array_repeat_zero_small_b256_6] free: locals 0 byte(s), call args 0 slot(s)
popa .10                                ; [fn end: array_repeat_zero_small_b256_6] restore all used registers
jal $zero $$reta i0                     ; [fn end: array_repeat_zero_small_b256_6] return from call
DIFF------------------------------
.program:
.10                                     ; --- start of function: array_repeat_zero_small_b256_6 ---
pusha .10                               ; [fn init: array_repeat_zero_small_b256_6]: push all used registers to stack
move $$locbase $sp                      ; [fn init: array_repeat_zero_small_b256_6]: set locals base register
cfei i0                                 ; [fn init: array_repeat_zero_small_b256_6]: allocate: locals 0 byte(s), call args 0 slot(s)
.55
mcli $$arg0 i160                        ; clear memory [b256; 5], 160 bytes
.11
cfsi i0                                 ; [fn end: array_repeat_zero_small_b256_6] free: locals 0 byte(s), call args 0 slot(s)
popa .10                                ; [fn end: array_repeat_zero_small_b256_6] restore all used registers
jal $zero $$reta i0                     ; [fn end: array_repeat_zero_small_b256_6] return from call
DIFF------------------------------
.program:
.10                                     ; --- start of function: array_repeat_zero_small_b256_6 ---
pusha .10                               ; [fn init: array_repeat_zero_small_b256_6]: push all used registers to stack
move $$locbase $sp                      ; [fn init: array_repeat_zero_small_b256_6]: set locals base register
cfei i0                                 ; [fn init: array_repeat_zero_small_b256_6]: allocate: locals 0 byte(s), call args 0 slot(s)
.55
mcli $$arg0 i160                        ; clear memory [b256; 5], 160 bytes
.11
cfsi i0                                 ; [fn end: array_repeat_zero_small_b256_6] free: locals 0 byte(s), call args 0 slot(s)
popa .10                                ; [fn end: array_repeat_zero_small_b256_6] restore all used registers
jal $zero $$reta i0                     ; [fn end: array_repeat_zero_small_b256_6] return from call
DIFF------------------------------
.program:
.10                                     ; --- start of function: array_repeat_zero_small_b256_6 ---
pusha .10                               ; [fn init: array_repeat_zero_small_b256_6]: push all used registers to stack
move $$locbase $sp                      ; [fn init: array_repeat_zero_small_b256_6]: set locals base register
cfei i0                                 ; [fn init: array_repeat_zero_small_b256_6]: allocate: locals 0 byte(s), call args 0 slot(s)
.55
mcli $$arg0 i160                        ; clear memory [b256; 5], 160 bytes
.11
cfsi i0                                 ; [fn end: array_repeat_zero_small_b256_6] free: locals 0 byte(s), call args 0 slot(s)
popa .10                                ; [fn end: array_repeat_zero_small_b256_6] restore all used registers
jal $zero $$reta i0                     ; [fn end: array_repeat_zero_small_b256_6] return from call
DIFF------------------------------
.program:
.12                                     ; --- start of function: array_repeat_zero_small_bool_7 ---
pusha .12                               ; [fn init: array_repeat_zero_small_bool_7]: push all used registers to stack
move $$locbase $sp                      ; [fn init: array_repeat_zero_small_bool_7]: set locals base register
cfei i0                                 ; [fn init: array_repeat_zero_small_bool_7]: allocate: locals 0 byte(s), call args 0 slot(s)
.56
mcli $$arg0 i5                          ; clear memory [bool; 5], 5 bytes
ji  .13
.13
cfsi i0                                 ; [fn end: array_repeat_zero_small_bool_7] free: locals 0 byte(s), call args 0 slot(s)
popa .12                                ; [fn end: array_repeat_zero_small_bool_7] restore all used registers
jal $zero $$reta i0                     ; [fn end: array_repeat_zero_small_bool_7] return from call
DIFF------------------------------
.program:
.12                                     ; --- start of function: array_repeat_zero_small_bool_7 ---
pusha .12                               ; [fn init: array_repeat_zero_small_bool_7]: push all used registers to stack
move $$locbase $sp                      ; [fn init: array_repeat_zero_small_bool_7]: set locals base register
cfei i0                                 ; [fn init: array_repeat_zero_small_bool_7]: allocate: locals 0 byte(s), call args 0 slot(s)
.56
mcli $$arg0 i5                          ; clear memory [bool; 5], 5 bytes
.13
cfsi i0                                 ; [fn end: array_repeat_zero_small_bool_7] free: locals 0 byte(s), call args 0 slot(s)
popa .12                                ; [fn end: array_repeat_zero_small_bool_7] restore all used registers
jal $zero $$reta i0                     ; [fn end: array_repeat_zero_small_bool_7] return from call
DIFF------------------------------
.program:
.12                                     ; --- start of function: array_repeat_zero_small_bool_7 ---
pusha .12                               ; [fn init: array_repeat_zero_small_bool_7]: push all used registers to stack
move $$locbase $sp                      ; [fn init: array_repeat_zero_small_bool_7]: set locals base register
cfei i0                                 ; [fn init: array_repeat_zero_small_bool_7]: allocate: locals 0 byte(s), call args 0 slot(s)
.56
mcli $$arg0 i5                          ; clear memory [bool; 5], 5 bytes
.13
cfsi i0                                 ; [fn end: array_repeat_zero_small_bool_7] free: locals 0 byte(s), call args 0 slot(s)
popa .12                                ; [fn end: array_repeat_zero_small_bool_7] restore all used registers
jal $zero $$reta i0                     ; [fn end: array_repeat_zero_small_bool_7] return from call
DIFF------------------------------
.program:
.12                                     ; --- start of function: array_repeat_zero_small_bool_7 ---
pusha .12                               ; [fn init: array_repeat_zero_small_bool_7]: push all used registers to stack
move $$locbase $sp                      ; [fn init: array_repeat_zero_small_bool_7]: set locals base register
cfei i0                                 ; [fn init: array_repeat_zero_small_bool_7]: allocate: locals 0 byte(s), call args 0 slot(s)
.56
mcli $$arg0 i5                          ; clear memory [bool; 5], 5 bytes
.13
cfsi i0                                 ; [fn end: array_repeat_zero_small_bool_7] free: locals 0 byte(s), call args 0 slot(s)
popa .12                                ; [fn end: array_repeat_zero_small_bool_7] restore all used registers
jal $zero $$reta i0                     ; [fn end: array_repeat_zero_small_bool_7] return from call
DIFF------------------------------
.program:
.14                                     ; --- start of function: array_repeat_zero_big_u8_8 ---
pusha .14                               ; [fn init: array_repeat_zero_big_u8_8]: push all used registers to stack
move $$locbase $sp                      ; [fn init: array_repeat_zero_big_u8_8]: set locals base register
cfei i0                                 ; [fn init: array_repeat_zero_big_u8_8]: allocate: locals 0 byte(s), call args 0 slot(s)
.57
mcli $$arg0 i25                         ; clear memory [u8; 25], 25 bytes
ji  .15
.15
cfsi i0                                 ; [fn end: array_repeat_zero_big_u8_8] free: locals 0 byte(s), call args 0 slot(s)
popa .14                                ; [fn end: array_repeat_zero_big_u8_8] restore all used registers
jal $zero $$reta i0                     ; [fn end: array_repeat_zero_big_u8_8] return from call
DIFF------------------------------
.program:
.14                                     ; --- start of function: array_repeat_zero_big_u8_8 ---
pusha .14                               ; [fn init: array_repeat_zero_big_u8_8]: push all used registers to stack
move $$locbase $sp                      ; [fn init: array_repeat_zero_big_u8_8]: set locals base register
cfei i0                                 ; [fn init: array_repeat_zero_big_u8_8]: allocate: locals 0 byte(s), call args 0 slot(s)
.57
mcli $$arg0 i25                         ; clear memory [u8; 25], 25 bytes
.15
cfsi i0                                 ; [fn end: array_repeat_zero_big_u8_8] free: locals 0 byte(s), call args 0 slot(s)
popa .14                                ; [fn end: array_repeat_zero_big_u8_8] restore all used registers
jal $zero $$reta i0                     ; [fn end: array_repeat_zero_big_u8_8] return from call
DIFF------------------------------
.program:
.14                                     ; --- start of function: array_repeat_zero_big_u8_8 ---
pusha .14                               ; [fn init: array_repeat_zero_big_u8_8]: push all used registers to stack
move $$locbase $sp                      ; [fn init: array_repeat_zero_big_u8_8]: set locals base register
cfei i0                                 ; [fn init: array_repeat_zero_big_u8_8]: allocate: locals 0 byte(s), call args 0 slot(s)
.57
mcli $$arg0 i25                         ; clear memory [u8; 25], 25 bytes
.15
cfsi i0                                 ; [fn end: array_repeat_zero_big_u8_8] free: locals 0 byte(s), call args 0 slot(s)
popa .14                                ; [fn end: array_repeat_zero_big_u8_8] restore all used registers
jal $zero $$reta i0                     ; [fn end: array_repeat_zero_big_u8_8] return from call
DIFF------------------------------
.program:
.14                                     ; --- start of function: array_repeat_zero_big_u8_8 ---
pusha .14                               ; [fn init: array_repeat_zero_big_u8_8]: push all used registers to stack
move $$locbase $sp                      ; [fn init: array_repeat_zero_big_u8_8]: set locals base register
cfei i0                                 ; [fn init: array_repeat_zero_big_u8_8]: allocate: locals 0 byte(s), call args 0 slot(s)
.57
mcli $$arg0 i25                         ; clear memory [u8; 25], 25 bytes
.15
cfsi i0                                 ; [fn end: array_repeat_zero_big_u8_8] free: locals 0 byte(s), call args 0 slot(s)
popa .14                                ; [fn end: array_repeat_zero_big_u8_8] restore all used registers
jal $zero $$reta i0                     ; [fn end: array_repeat_zero_big_u8_8] return from call
DIFF------------------------------
.program:
.16                                     ; --- start of function: array_repeat_zero_big_u32_10 ---
pusha .16                               ; [fn init: array_repeat_zero_big_u32_10]: push all used registers to stack
move $$locbase $sp                      ; [fn init: array_repeat_zero_big_u32_10]: set locals base register
cfei i0                                 ; [fn init: array_repeat_zero_big_u32_10]: allocate: locals 0 byte(s), call args 0 slot(s)
.58
mcli $$arg0 i200                        ; clear memory [u64; 25], 200 bytes
ji  .17
.17
cfsi i0                                 ; [fn end: array_repeat_zero_big_u32_10] free: locals 0 byte(s), call args 0 slot(s)
popa .16                                ; [fn end: array_repeat_zero_big_u32_10] restore all used registers
jal $zero $$reta i0                     ; [fn end: array_repeat_zero_big_u32_10] return from call
DIFF------------------------------
.program:
.16                                     ; --- start of function: array_repeat_zero_big_u32_10 ---
pusha .16                               ; [fn init: array_repeat_zero_big_u32_10]: push all used registers to stack
move $$locbase $sp                      ; [fn init: array_repeat_zero_big_u32_10]: set locals base register
cfei i0                                 ; [fn init: array_repeat_zero_big_u32_10]: allocate: locals 0 byte(s), call args 0 slot(s)
.58
mcli $$arg0 i200                        ; clear memory [u64; 25], 200 bytes
.17
cfsi i0                                 ; [fn end: array_repeat_zero_big_u32_10] free: locals 0 byte(s), call args 0 slot(s)
popa .16                                ; [fn end: array_repeat_zero_big_u32_10] restore all used registers
jal $zero $$reta i0                     ; [fn end: array_repeat_zero_big_u32_10] return from call
DIFF------------------------------
.program:
.16                                     ; --- start of function: array_repeat_zero_big_u32_10 ---
pusha .16                               ; [fn init: array_repeat_zero_big_u32_10]: push all used registers to stack
move $$locbase $sp                      ; [fn init: array_repeat_zero_big_u32_10]: set locals base register
cfei i0                                 ; [fn init: array_repeat_zero_big_u32_10]: allocate: locals 0 byte(s), call args 0 slot(s)
.58
mcli $$arg0 i200                        ; clear memory [u64; 25], 200 bytes
.17
cfsi i0                                 ; [fn end: array_repeat_zero_big_u32_10] free: locals 0 byte(s), call args 0 slot(s)
popa .16                                ; [fn end: array_repeat_zero_big_u32_10] restore all used registers
jal $zero $$reta i0                     ; [fn end: array_repeat_zero_big_u32_10] return from call
DIFF------------------------------
.program:
.16                                     ; --- start of function: array_repeat_zero_big_u32_10 ---
pusha .16                               ; [fn init: array_repeat_zero_big_u32_10]: push all used registers to stack
move $$locbase $sp                      ; [fn init: array_repeat_zero_big_u32_10]: set locals base register
cfei i0                                 ; [fn init: array_repeat_zero_big_u32_10]: allocate: locals 0 byte(s), call args 0 slot(s)
.58
mcli $$arg0 i200                        ; clear memory [u64; 25], 200 bytes
.17
cfsi i0                                 ; [fn end: array_repeat_zero_big_u32_10] free: locals 0 byte(s), call args 0 slot(s)
popa .16                                ; [fn end: array_repeat_zero_big_u32_10] restore all used registers
jal $zero $$reta i0                     ; [fn end: array_repeat_zero_big_u32_10] return from call
DIFF------------------------------
.program:
.18                                     ; --- start of function: array_repeat_zero_big_u256_12 ---
pusha .18                               ; [fn init: array_repeat_zero_big_u256_12]: push all used registers to stack
move $$locbase $sp                      ; [fn init: array_repeat_zero_big_u256_12]: set locals base register
cfei i0                                 ; [fn init: array_repeat_zero_big_u256_12]: allocate: locals 0 byte(s), call args 0 slot(s)
.59
mcli $$arg0 i800                        ; clear memory [u256; 25], 800 bytes
ji  .19
.19
cfsi i0                                 ; [fn end: array_repeat_zero_big_u256_12] free: locals 0 byte(s), call args 0 slot(s)
popa .18                                ; [fn end: array_repeat_zero_big_u256_12] restore all used registers
jal $zero $$reta i0                     ; [fn end: array_repeat_zero_big_u256_12] return from call
DIFF------------------------------
.program:
.18                                     ; --- start of function: array_repeat_zero_big_u256_12 ---
pusha .18                               ; [fn init: array_repeat_zero_big_u256_12]: push all used registers to stack
move $$locbase $sp                      ; [fn init: array_repeat_zero_big_u256_12]: set locals base register
cfei i0                                 ; [fn init: array_repeat_zero_big_u256_12]: allocate: locals 0 byte(s), call args 0 slot(s)
.59
mcli $$arg0 i800                        ; clear memory [u256; 25], 800 bytes
.19
cfsi i0                                 ; [fn end: array_repeat_zero_big_u256_12] free: locals 0 byte(s), call args 0 slot(s)
popa .18                                ; [fn end: array_repeat_zero_big_u256_12] restore all used registers
jal $zero $$reta i0                     ; [fn end: array_repeat_zero_big_u256_12] return from call
DIFF------------------------------
.program:
.18                                     ; --- start of function: array_repeat_zero_big_u256_12 ---
pusha .18                               ; [fn init: array_repeat_zero_big_u256_12]: push all used registers to stack
move $$locbase $sp                      ; [fn init: array_repeat_zero_big_u256_12]: set locals base register
cfei i0                                 ; [fn init: array_repeat_zero_big_u256_12]: allocate: locals 0 byte(s), call args 0 slot(s)
.59
mcli $$arg0 i800                        ; clear memory [u256; 25], 800 bytes
.19
cfsi i0                                 ; [fn end: array_repeat_zero_big_u256_12] free: locals 0 byte(s), call args 0 slot(s)
popa .18                                ; [fn end: array_repeat_zero_big_u256_12] restore all used registers
jal $zero $$reta i0                     ; [fn end: array_repeat_zero_big_u256_12] return from call
DIFF------------------------------
.program:
.18                                     ; --- start of function: array_repeat_zero_big_u256_12 ---
pusha .18                               ; [fn init: array_repeat_zero_big_u256_12]: push all used registers to stack
move $$locbase $sp                      ; [fn init: array_repeat_zero_big_u256_12]: set locals base register
cfei i0                                 ; [fn init: array_repeat_zero_big_u256_12]: allocate: locals 0 byte(s), call args 0 slot(s)
.59
mcli $$arg0 i800                        ; clear memory [u256; 25], 800 bytes
.19
cfsi i0                                 ; [fn end: array_repeat_zero_big_u256_12] free: locals 0 byte(s), call args 0 slot(s)
popa .18                                ; [fn end: array_repeat_zero_big_u256_12] restore all used registers
jal $zero $$reta i0                     ; [fn end: array_repeat_zero_big_u256_12] return from call
DIFF------------------------------
.program:
.20                                     ; --- start of function: array_repeat_zero_big_b256_13 ---
pusha .20                               ; [fn init: array_repeat_zero_big_b256_13]: push all used registers to stack
move $$locbase $sp                      ; [fn init: array_repeat_zero_big_b256_13]: set locals base register
cfei i0                                 ; [fn init: array_repeat_zero_big_b256_13]: allocate: locals 0 byte(s), call args 0 slot(s)
.60
mcli $$arg0 i800                        ; clear memory [b256; 25], 800 bytes
ji  .21
.21
cfsi i0                                 ; [fn end: array_repeat_zero_big_b256_13] free: locals 0 byte(s), call args 0 slot(s)
popa .20                                ; [fn end: array_repeat_zero_big_b256_13] restore all used registers
jal $zero $$reta i0                     ; [fn end: array_repeat_zero_big_b256_13] return from call
DIFF------------------------------
.program:
.20                                     ; --- start of function: array_repeat_zero_big_b256_13 ---
pusha .20                               ; [fn init: array_repeat_zero_big_b256_13]: push all used registers to stack
move $$locbase $sp                      ; [fn init: array_repeat_zero_big_b256_13]: set locals base register
cfei i0                                 ; [fn init: array_repeat_zero_big_b256_13]: allocate: locals 0 byte(s), call args 0 slot(s)
.60
mcli $$arg0 i800                        ; clear memory [b256; 25], 800 bytes
.21
cfsi i0                                 ; [fn end: array_repeat_zero_big_b256_13] free: locals 0 byte(s), call args 0 slot(s)
popa .20                                ; [fn end: array_repeat_zero_big_b256_13] restore all used registers
jal $zero $$reta i0                     ; [fn end: array_repeat_zero_big_b256_13] return from call
DIFF------------------------------
.program:
.20                                     ; --- start of function: array_repeat_zero_big_b256_13 ---
pusha .20                               ; [fn init: array_repeat_zero_big_b256_13]: push all used registers to stack
move $$locbase $sp                      ; [fn init: array_repeat_zero_big_b256_13]: set locals base register
cfei i0                                 ; [fn init: array_repeat_zero_big_b256_13]: allocate: locals 0 byte(s), call args 0 slot(s)
.60
mcli $$arg0 i800                        ; clear memory [b256; 25], 800 bytes
.21
cfsi i0                                 ; [fn end: array_repeat_zero_big_b256_13] free: locals 0 byte(s), call args 0 slot(s)
popa .20                                ; [fn end: array_repeat_zero_big_b256_13] restore all used registers
jal $zero $$reta i0                     ; [fn end: array_repeat_zero_big_b256_13] return from call
DIFF------------------------------
.program:
.20                                     ; --- start of function: array_repeat_zero_big_b256_13 ---
pusha .20                               ; [fn init: array_repeat_zero_big_b256_13]: push all used registers to stack
move $$locbase $sp                      ; [fn init: array_repeat_zero_big_b256_13]: set locals base register
cfei i0                                 ; [fn init: array_repeat_zero_big_b256_13]: allocate: locals 0 byte(s), call args 0 slot(s)
.60
mcli $$arg0 i800                        ; clear memory [b256; 25], 800 bytes
.21
cfsi i0                                 ; [fn end: array_repeat_zero_big_b256_13] free: locals 0 byte(s), call args 0 slot(s)
popa .20                                ; [fn end: array_repeat_zero_big_b256_13] restore all used registers
jal $zero $$reta i0                     ; [fn end: array_repeat_zero_big_b256_13] return from call
DIFF------------------------------
.program:
.22                                     ; --- start of function: array_repeat_zero_big_bool_14 ---
pusha .22                               ; [fn init: array_repeat_zero_big_bool_14]: push all used registers to stack
move $$locbase $sp                      ; [fn init: array_repeat_zero_big_bool_14]: set locals base register
cfei i0                                 ; [fn init: array_repeat_zero_big_bool_14]: allocate: locals 0 byte(s), call args 0 slot(s)
.61
mcli $$arg0 i25                         ; clear memory [bool; 25], 25 bytes
ji  .23
.23
cfsi i0                                 ; [fn end: array_repeat_zero_big_bool_14] free: locals 0 byte(s), call args 0 slot(s)
popa .22                                ; [fn end: array_repeat_zero_big_bool_14] restore all used registers
jal $zero $$reta i0                     ; [fn end: array_repeat_zero_big_bool_14] return from call
DIFF------------------------------
.program:
.22                                     ; --- start of function: array_repeat_zero_big_bool_14 ---
pusha .22                               ; [fn init: array_repeat_zero_big_bool_14]: push all used registers to stack
move $$locbase $sp                      ; [fn init: array_repeat_zero_big_bool_14]: set locals base register
cfei i0                                 ; [fn init: array_repeat_zero_big_bool_14]: allocate: locals 0 byte(s), call args 0 slot(s)
.61
mcli $$arg0 i25                         ; clear memory [bool; 25], 25 bytes
.23
cfsi i0                                 ; [fn end: array_repeat_zero_big_bool_14] free: locals 0 byte(s), call args 0 slot(s)
popa .22                                ; [fn end: array_repeat_zero_big_bool_14] restore all used registers
jal $zero $$reta i0                     ; [fn end: array_repeat_zero_big_bool_14] return from call
DIFF------------------------------
.program:
.22                                     ; --- start of function: array_repeat_zero_big_bool_14 ---
pusha .22                               ; [fn init: array_repeat_zero_big_bool_14]: push all used registers to stack
move $$locbase $sp                      ; [fn init: array_repeat_zero_big_bool_14]: set locals base register
cfei i0                                 ; [fn init: array_repeat_zero_big_bool_14]: allocate: locals 0 byte(s), call args 0 slot(s)
.61
mcli $$arg0 i25                         ; clear memory [bool; 25], 25 bytes
.23
cfsi i0                                 ; [fn end: array_repeat_zero_big_bool_14] free: locals 0 byte(s), call args 0 slot(s)
popa .22                                ; [fn end: array_repeat_zero_big_bool_14] restore all used registers
jal $zero $$reta i0                     ; [fn end: array_repeat_zero_big_bool_14] return from call
DIFF------------------------------
.program:
.22                                     ; --- start of function: array_repeat_zero_big_bool_14 ---
pusha .22                               ; [fn init: array_repeat_zero_big_bool_14]: push all used registers to stack
move $$locbase $sp                      ; [fn init: array_repeat_zero_big_bool_14]: set locals base register
cfei i0                                 ; [fn init: array_repeat_zero_big_bool_14]: allocate: locals 0 byte(s), call args 0 slot(s)
.61
mcli $$arg0 i25                         ; clear memory [bool; 25], 25 bytes
.23
cfsi i0                                 ; [fn end: array_repeat_zero_big_bool_14] free: locals 0 byte(s), call args 0 slot(s)
popa .22                                ; [fn end: array_repeat_zero_big_bool_14] restore all used registers
jal $zero $$reta i0                     ; [fn end: array_repeat_zero_big_bool_14] return from call
DIFF------------------------------
.program:
.24                                     ; --- start of function: small_array_repeat_15 ---
pusha .24                               ; [fn init: small_array_repeat_15]: push all used registers to stack
move $$locbase $sp                      ; [fn init: small_array_repeat_15]: set locals base register
cfei i0                                 ; [fn init: small_array_repeat_15]: allocate: locals 0 byte(s), call args 0 slot(s)
.62
movi $r61 i1                            ; get array element size
 mul $r62 $zero $r61                     ; get offset to array element
 add $r62 $$arg0 $r62                    ; add array element offset to array base
 sb $r62 $one i0                         ; store byte
 movi $r62 i0                            ; get offset to array element
 move $r62 $$arg0                        ; add array element offset to array base
 sb $$arg0 $one i0                       ; store byte
movi $r63 i1                            ; get array element size
 mul $r64 $one $r63                      ; get offset to array element
 add $r64 $$arg0 $r64                    ; add array element offset to array base
 movi $r64 i1                            ; get offset to array element
 addi $r64 $$arg0 i1                     ; add array element offset to array base
sb $r64 $one i0                         ; store byte
movi $r65 i1                            ; get array element size
movi $r66 i2                            ; initialize constant into register
 mul $r67 $r66 $r65                      ; get offset to array element
 add $r67 $$arg0 $r67                    ; add array element offset to array base
 movi $r67 i2                            ; get offset to array element
 addi $r67 $$arg0 i2                     ; add array element offset to array base
sb $r67 $one i0                         ; store byte
movi $r68 i1                            ; get array element size
movi $r69 i3                            ; initialize constant into register
 mul $r70 $r69 $r68                      ; get offset to array element
 add $r70 $$arg0 $r70                    ; add array element offset to array base
 movi $r70 i3                            ; get offset to array element
 addi $r70 $$arg0 i3                     ; add array element offset to array base
sb $r70 $one i0                         ; store byte
movi $r71 i1                            ; get array element size
movi $r72 i4                            ; initialize constant into register
 mul $r73 $r72 $r71                      ; get offset to array element
 add $r73 $$arg0 $r73                    ; add array element offset to array base
 movi $r73 i4                            ; get offset to array element
 addi $r73 $$arg0 i4                     ; add array element offset to array base
sb $r73 $one i0                         ; store byte
ji  .25
.25
cfsi i0                                 ; [fn end: small_array_repeat_15] free: locals 0 byte(s), call args 0 slot(s)
popa .24                                ; [fn end: small_array_repeat_15] restore all used registers
jal $zero $$reta i0                     ; [fn end: small_array_repeat_15] return from call
DIFF------------------------------
.program:
.24                                     ; --- start of function: small_array_repeat_15 ---
pusha .24                               ; [fn init: small_array_repeat_15]: push all used registers to stack
move $$locbase $sp                      ; [fn init: small_array_repeat_15]: set locals base register
cfei i0                                 ; [fn init: small_array_repeat_15]: allocate: locals 0 byte(s), call args 0 slot(s)
.62
sb $$arg0 $one i0                       ; store byte
addi $r64 $$arg0 i1                     ; add array element offset to array base
sb $r64 $one i0                         ; store byte
addi $r67 $$arg0 i2                     ; add array element offset to array base
sb $r67 $one i0                         ; store byte
addi $r70 $$arg0 i3                     ; add array element offset to array base
sb $r70 $one i0                         ; store byte
addi $r73 $$arg0 i4                     ; add array element offset to array base
sb $r73 $one i0                         ; store byte
.25
cfsi i0                                 ; [fn end: small_array_repeat_15] free: locals 0 byte(s), call args 0 slot(s)
popa .24                                ; [fn end: small_array_repeat_15] restore all used registers
jal $zero $$reta i0                     ; [fn end: small_array_repeat_15] return from call
DIFF------------------------------
.program:
.24                                     ; --- start of function: small_array_repeat_15 ---
pusha .24                               ; [fn init: small_array_repeat_15]: push all used registers to stack
move $$locbase $sp                      ; [fn init: small_array_repeat_15]: set locals base register
cfei i0                                 ; [fn init: small_array_repeat_15]: allocate: locals 0 byte(s), call args 0 slot(s)
.62
sb $$arg0 $one i0                       ; store byte
addi $r64 $$arg0 i1                     ; add array element offset to array base
sb $r64 $one i0                         ; store byte
addi $r67 $$arg0 i2                     ; add array element offset to array base
sb $r67 $one i0                         ; store byte
addi $r70 $$arg0 i3                     ; add array element offset to array base
sb $r70 $one i0                         ; store byte
addi $r73 $$arg0 i4                     ; add array element offset to array base
sb $r73 $one i0                         ; store byte
.25
cfsi i0                                 ; [fn end: small_array_repeat_15] free: locals 0 byte(s), call args 0 slot(s)
popa .24                                ; [fn end: small_array_repeat_15] restore all used registers
jal $zero $$reta i0                     ; [fn end: small_array_repeat_15] return from call
DIFF------------------------------
.program:
.24                                     ; --- start of function: small_array_repeat_15 ---
pusha .24                               ; [fn init: small_array_repeat_15]: push all used registers to stack
move $$locbase $sp                      ; [fn init: small_array_repeat_15]: set locals base register
cfei i0                                 ; [fn init: small_array_repeat_15]: allocate: locals 0 byte(s), call args 0 slot(s)
.62
sb $$arg0 $one i0                       ; store byte
addi $r64 $$arg0 i1                     ; add array element offset to array base
sb $r64 $one i0                         ; store byte
addi $r67 $$arg0 i2                     ; add array element offset to array base
sb $r67 $one i0                         ; store byte
addi $r70 $$arg0 i3                     ; add array element offset to array base
sb $r70 $one i0                         ; store byte
addi $r73 $$arg0 i4                     ; add array element offset to array base
sb $r73 $one i0                         ; store byte
.25
cfsi i0                                 ; [fn end: small_array_repeat_15] free: locals 0 byte(s), call args 0 slot(s)
popa .24                                ; [fn end: small_array_repeat_15] restore all used registers
jal $zero $$reta i0                     ; [fn end: small_array_repeat_15] return from call
DIFF------------------------------
.program:
.26                                     ; --- start of function: big_array_repeat_16 ---
pusha .26                               ; [fn init: big_array_repeat_16]: push all used registers to stack
move $$locbase $sp                      ; [fn init: big_array_repeat_16]: set locals base register
cfei i0                                 ; [fn init: big_array_repeat_16]: allocate: locals 0 byte(s), call args 0 slot(s)
.63
 move $r75 $zero                         ; move parameter from branch to block argument
 movi $r75 i0                            ; move parameter from branch to block argument
ji  .64
.64
move $r77 $r75                          ; move parameter from branch to block argument
movi $r78 i1                            ; get array element size
 mul $r79 $r77 $r78                      ; get offset to array element
 muli $r79 $r75 i1                       ; get offset to array element
add $r79 $$arg0 $r79                    ; add array element offset to array base
sb $r79 $one i0                         ; store byte
 add $r80 $r77 $one
 addi $r80 $r77 i1
movi $r81 i25                           ; initialize constant into register
lt $r82 $r80 $r81
move $r75 $r80                          ; move parameter from branch to block argument
jnzi $r82 .64
ji  .65
.65
ji  .27
.27
cfsi i0                                 ; [fn end: big_array_repeat_16] free: locals 0 byte(s), call args 0 slot(s)
popa .26                                ; [fn end: big_array_repeat_16] restore all used registers
jal $zero $$reta i0                     ; [fn end: big_array_repeat_16] return from call
DIFF------------------------------
.program:
.26                                     ; --- start of function: big_array_repeat_16 ---
pusha .26                               ; [fn init: big_array_repeat_16]: push all used registers to stack
move $$locbase $sp                      ; [fn init: big_array_repeat_16]: set locals base register
cfei i0                                 ; [fn init: big_array_repeat_16]: allocate: locals 0 byte(s), call args 0 slot(s)
.63
movi $r75 i0                            ; move parameter from branch to block argument
.64
move $r77 $r75                          ; move parameter from branch to block argument
muli $r79 $r75 i1                       ; get offset to array element
add $r79 $$arg0 $r79                    ; add array element offset to array base
sb $r79 $one i0                         ; store byte
addi $r80 $r77 i1
movi $r81 i25                           ; initialize constant into register
lt $r82 $r80 $r81
move $r75 $r80                          ; move parameter from branch to block argument
jnzi $r82 .64
.65
.27
cfsi i0                                 ; [fn end: big_array_repeat_16] free: locals 0 byte(s), call args 0 slot(s)
popa .26                                ; [fn end: big_array_repeat_16] restore all used registers
jal $zero $$reta i0                     ; [fn end: big_array_repeat_16] return from call
DIFF------------------------------
.program:
.26                                     ; --- start of function: big_array_repeat_16 ---
pusha .26                               ; [fn init: big_array_repeat_16]: push all used registers to stack
move $$locbase $sp                      ; [fn init: big_array_repeat_16]: set locals base register
cfei i0                                 ; [fn init: big_array_repeat_16]: allocate: locals 0 byte(s), call args 0 slot(s)
.63
movi $r75 i0                            ; move parameter from branch to block argument
.64
move $r77 $r75                          ; move parameter from branch to block argument
muli $r79 $r75 i1                       ; get offset to array element
add $r79 $$arg0 $r79                    ; add array element offset to array base
sb $r79 $one i0                         ; store byte
addi $r80 $r77 i1
movi $r81 i25                           ; initialize constant into register
lt $r82 $r80 $r81
move $r75 $r80                          ; move parameter from branch to block argument
jnzi $r82 .64
.65
.27
cfsi i0                                 ; [fn end: big_array_repeat_16] free: locals 0 byte(s), call args 0 slot(s)
popa .26                                ; [fn end: big_array_repeat_16] restore all used registers
jal $zero $$reta i0                     ; [fn end: big_array_repeat_16] return from call
DIFF------------------------------
.program:
.26                                     ; --- start of function: big_array_repeat_16 ---
pusha .26                               ; [fn init: big_array_repeat_16]: push all used registers to stack
move $$locbase $sp                      ; [fn init: big_array_repeat_16]: set locals base register
cfei i0                                 ; [fn init: big_array_repeat_16]: allocate: locals 0 byte(s), call args 0 slot(s)
.63
movi $r75 i0                            ; move parameter from branch to block argument
.64
move $r77 $r75                          ; move parameter from branch to block argument
muli $r79 $r75 i1                       ; get offset to array element
add $r79 $$arg0 $r79                    ; add array element offset to array base
sb $r79 $one i0                         ; store byte
addi $r80 $r77 i1
movi $r81 i25                           ; initialize constant into register
lt $r82 $r80 $r81
move $r75 $r80                          ; move parameter from branch to block argument
jnzi $r82 .64
.65
.27
cfsi i0                                 ; [fn end: big_array_repeat_16] free: locals 0 byte(s), call args 0 slot(s)
popa .26                                ; [fn end: big_array_repeat_16] restore all used registers
jal $zero $$reta i0                     ; [fn end: big_array_repeat_16] return from call
DIFF------------------------------
.program:
.28                                     ; --- start of function: u8_array_bigger_than_18_bits_17 ---
pusha .28                               ; [fn init: u8_array_bigger_than_18_bits_17]: push all used registers to stack
move $$locbase $sp                      ; [fn init: u8_array_bigger_than_18_bits_17]: set locals base register
cfei i0                                 ; [fn init: u8_array_bigger_than_18_bits_17]: allocate: locals 0 byte(s), call args 0 slot(s)
.66
load $$tmp data_NonConfigurable_1       ; loading clear size in bytes
mcl $$arg0 $$tmp                        ; clear memory [u8; 262145]
ji  .29
.29
cfsi i0                                 ; [fn end: u8_array_bigger_than_18_bits_17] free: locals 0 byte(s), call args 0 slot(s)
popa .28                                ; [fn end: u8_array_bigger_than_18_bits_17] restore all used registers
jal $zero $$reta i0                     ; [fn end: u8_array_bigger_than_18_bits_17] return from call
DIFF------------------------------
.program:
.28                                     ; --- start of function: u8_array_bigger_than_18_bits_17 ---
pusha .28                               ; [fn init: u8_array_bigger_than_18_bits_17]: push all used registers to stack
move $$locbase $sp                      ; [fn init: u8_array_bigger_than_18_bits_17]: set locals base register
cfei i0                                 ; [fn init: u8_array_bigger_than_18_bits_17]: allocate: locals 0 byte(s), call args 0 slot(s)
.66
load $$tmp data_NonConfigurable_1       ; loading clear size in bytes
mcl $$arg0 $$tmp                        ; clear memory [u8; 262145]
.29
cfsi i0                                 ; [fn end: u8_array_bigger_than_18_bits_17] free: locals 0 byte(s), call args 0 slot(s)
popa .28                                ; [fn end: u8_array_bigger_than_18_bits_17] restore all used registers
jal $zero $$reta i0                     ; [fn end: u8_array_bigger_than_18_bits_17] return from call
DIFF------------------------------
.program:
.28                                     ; --- start of function: u8_array_bigger_than_18_bits_17 ---
pusha .28                               ; [fn init: u8_array_bigger_than_18_bits_17]: push all used registers to stack
move $$locbase $sp                      ; [fn init: u8_array_bigger_than_18_bits_17]: set locals base register
cfei i0                                 ; [fn init: u8_array_bigger_than_18_bits_17]: allocate: locals 0 byte(s), call args 0 slot(s)
.66
load $$tmp data_NonConfigurable_1       ; loading clear size in bytes
mcl $$arg0 $$tmp                        ; clear memory [u8; 262145]
.29
cfsi i0                                 ; [fn end: u8_array_bigger_than_18_bits_17] free: locals 0 byte(s), call args 0 slot(s)
popa .28                                ; [fn end: u8_array_bigger_than_18_bits_17] restore all used registers
jal $zero $$reta i0                     ; [fn end: u8_array_bigger_than_18_bits_17] return from call
DIFF------------------------------
.program:
.28                                     ; --- start of function: u8_array_bigger_than_18_bits_17 ---
pusha .28                               ; [fn init: u8_array_bigger_than_18_bits_17]: push all used registers to stack
move $$locbase $sp                      ; [fn init: u8_array_bigger_than_18_bits_17]: set locals base register
cfei i0                                 ; [fn init: u8_array_bigger_than_18_bits_17]: allocate: locals 0 byte(s), call args 0 slot(s)
.66
load $$tmp data_NonConfigurable_1       ; loading clear size in bytes
mcl $$arg0 $$tmp                        ; clear memory [u8; 262145]
.29
cfsi i0                                 ; [fn end: u8_array_bigger_than_18_bits_17] free: locals 0 byte(s), call args 0 slot(s)
popa .28                                ; [fn end: u8_array_bigger_than_18_bits_17] restore all used registers
jal $zero $$reta i0                     ; [fn end: u8_array_bigger_than_18_bits_17] return from call
DIFF------------------------------
.program:
.30                                     ; --- start of function: arrays_with_const_length_18 ---
pusha .30                               ; [fn init: arrays_with_const_length_18]: push all used registers to stack
move $$locbase $sp                      ; [fn init: arrays_with_const_length_18]: set locals base register
cfei i0                                 ; [fn init: arrays_with_const_length_18]: allocate: locals 0 byte(s), call args 0 slot(s)
.67
ji  .31
.31
cfsi i0                                 ; [fn end: arrays_with_const_length_18] free: locals 0 byte(s), call args 0 slot(s)
popa .30                                ; [fn end: arrays_with_const_length_18] restore all used registers
jal $zero $$reta i0                     ; [fn end: arrays_with_const_length_18] return from call
DIFF------------------------------
.program:
.30                                     ; --- start of function: arrays_with_const_length_18 ---
pusha .30                               ; [fn init: arrays_with_const_length_18]: push all used registers to stack
move $$locbase $sp                      ; [fn init: arrays_with_const_length_18]: set locals base register
cfei i0                                 ; [fn init: arrays_with_const_length_18]: allocate: locals 0 byte(s), call args 0 slot(s)
.67
.31
cfsi i0                                 ; [fn end: arrays_with_const_length_18] free: locals 0 byte(s), call args 0 slot(s)
popa .30                                ; [fn end: arrays_with_const_length_18] restore all used registers
jal $zero $$reta i0                     ; [fn end: arrays_with_const_length_18] return from call
DIFF------------------------------
.program:
.30                                     ; --- start of function: arrays_with_const_length_18 ---
pusha .30                               ; [fn init: arrays_with_const_length_18]: push all used registers to stack
move $$locbase $sp                      ; [fn init: arrays_with_const_length_18]: set locals base register
cfei i0                                 ; [fn init: arrays_with_const_length_18]: allocate: locals 0 byte(s), call args 0 slot(s)
.67
.31
cfsi i0                                 ; [fn end: arrays_with_const_length_18] free: locals 0 byte(s), call args 0 slot(s)
popa .30                                ; [fn end: arrays_with_const_length_18] restore all used registers
jal $zero $$reta i0                     ; [fn end: arrays_with_const_length_18] return from call
DIFF------------------------------
.program:
.30                                     ; --- start of function: arrays_with_const_length_18 ---
pusha .30                               ; [fn init: arrays_with_const_length_18]: push all used registers to stack
move $$locbase $sp                      ; [fn init: arrays_with_const_length_18]: set locals base register
cfei i0                                 ; [fn init: arrays_with_const_length_18]: allocate: locals 0 byte(s), call args 0 slot(s)
.67
.31
cfsi i0                                 ; [fn end: arrays_with_const_length_18] free: locals 0 byte(s), call args 0 slot(s)
popa .30                                ; [fn end: arrays_with_const_length_18] restore all used registers
jal $zero $$reta i0                     ; [fn end: arrays_with_const_length_18] return from call
DIFF------------------------------
.program:
.32                                     ; --- start of function: decode_array_19 ---
pusha .32                               ; [fn init: decode_array_19]: push all used registers to stack
move $$locbase $sp                      ; [fn init: decode_array_19]: set locals base register
cfei i72                                ; [fn init: decode_array_19]: allocate: locals 72 byte(s), call args 0 slot(s)
move $r86 $$arg0                        ; [fn init: decode_array_19]: copy argument 0 (__ret_value)
move $r87 $$reta                        ; [fn init: decode_array_19]: save return address
.68
addi $r88 $$locbase i16                 ; get offset to local __ptr [u8; 1]
movi $r89 i1                            ; get array element size
 mul $r90 $zero $r89                     ; get offset to array element
 add $r90 $r88 $r90                      ; add array element offset to array base
 movi $r90 i0                            ; get offset to array element
 move $r90 $r88                          ; add array element offset to array base
movi $r91 i255                          ; initialize constant into register
 sb $r90 $r91 i0                         ; store byte
 sb $r88 $r91 i0                         ; store byte
addi $r92 $$locbase i16                 ; get offset to local __ptr [u8; 1]
addi $r93 $$locbase i24                 ; get offset to local __ptr slice
move $$arg0 $r92                        ; [call: to_slice_20]: pass argument 0
move $$arg1 $r93                        ; [call: to_slice_20]: pass argument 1
fncall .34                              ; [call: to_slice_20]: call function
 move $r94 $zero                         ; [call: to_slice_20]: copy returned unit value
 movi $r94 i0                            ; [call: to_slice_20]: copy returned unit value
addi $r95 $$locbase i40                 ; get offset to local __ptr slice
mcpi $r95 $r93 i16                      ; copy memory
addi $r96 $$locbase i40                 ; get offset to local __ptr slice
addi $r97 $$locbase i56                 ; get offset to local __ptr slice
mcpi $r97 $r96 i16                      ; copy memory
addi $r98 $$locbase i56                 ; get offset to local __ptr slice
move $r99 $r98                          ; return value from ASM block with return register ptr
lw $r100 $r98 i0                        ; load word
 addi $r101 $r99 i8                      ; get offset to aggregate element
 addi $r101 $r98 i8                      ; get offset to aggregate element
lw $r102 $r98 i1                        ; load word
sw $$locbase $r100 i0                   ; store word
addi $r103 $$locbase i8                 ; get offset to aggregate element
sw $$locbase $r102 i1                   ; store word
lw $r104 $$locbase i0                   ; load word
 move $r105 $one                         ; copy ASM block argument's constant initial value to register
 aloc $r105                              ; aloc size
 movi $r105 i1                           ; copy ASM block argument's constant initial value to register
 aloc $one                               ; aloc size
mcp $hp $r104 $r105                     ; mcp hp src size
move $r106 $hp                          ; return value from ASM block with return register hp
movi $r107 i1                           ; get array element size
 mul $r108 $zero $r107                   ; get offset to array element
 add $r108 $r106 $r108                   ; add array element offset to array base
 lb $r109 $r108 i0                       ; load byte
 movi $r108 i0                           ; get offset to array element
 move $r108 $hp                          ; add array element offset to array base
 lb $r109 $hp i0                         ; load byte
movi $r110 i1                           ; get array element size
 mul $r111 $zero $r110                   ; get offset to array element
 add $r111 $r86 $r111                    ; add array element offset to array base
 sb $r111 $r109 i0                       ; store byte
 movi $r111 i0                           ; get offset to array element
 move $r111 $r86                         ; add array element offset to array base
 sb $r86 $r109 i0                        ; store byte
ji  .33
.33
cfsi i72                                ; [fn end: decode_array_19] free: locals 72 byte(s), call args 0 slot(s)
move $$reta $r87                        ; [fn end: decode_array_19] restore return address
popa .32                                ; [fn end: decode_array_19] restore all used registers
jal $zero $$reta i0                     ; [fn end: decode_array_19] return from call
DIFF------------------------------
.program:
.32                                     ; --- start of function: decode_array_19 ---
pusha .32                               ; [fn init: decode_array_19]: push all used registers to stack
move $$locbase $sp                      ; [fn init: decode_array_19]: set locals base register
cfei i72                                ; [fn init: decode_array_19]: allocate: locals 72 byte(s), call args 0 slot(s)
move $r86 $$arg0                        ; [fn init: decode_array_19]: copy argument 0 (__ret_value)
move $r87 $$reta                        ; [fn init: decode_array_19]: save return address
.68
addi $r88 $$locbase i16                 ; get offset to local __ptr [u8; 1]
movi $r91 i255                          ; initialize constant into register
sb $r88 $r91 i0                         ; store byte
addi $r92 $$locbase i16                 ; get offset to local __ptr [u8; 1]
addi $r93 $$locbase i24                 ; get offset to local __ptr slice
move $$arg0 $r92                        ; [call: to_slice_20]: pass argument 0
move $$arg1 $r93                        ; [call: to_slice_20]: pass argument 1
fncall .34                              ; [call: to_slice_20]: call function
addi $r95 $$locbase i40                 ; get offset to local __ptr slice
mcpi $r95 $r93 i16                      ; copy memory
addi $r96 $$locbase i40                 ; get offset to local __ptr slice
addi $r97 $$locbase i56                 ; get offset to local __ptr slice
mcpi $r97 $r96 i16                      ; copy memory
addi $r98 $$locbase i56                 ; get offset to local __ptr slice
lw $r100 $$locbase i7                   ; load word
lw $r102 $$locbase i8                   ; load word
sw $$locbase $r100 i0                   ; store word
sw $$locbase $r102 i1                   ; store word
lw $r104 $$locbase i0                   ; load word
movi $r105 i1                           ; copy ASM block argument's constant initial value to register
aloc $one                               ; aloc size
mcp $hp $r104 $r105                     ; mcp hp src size
lb $r109 $hp i0                         ; load byte
sb $r86 $r109 i0                        ; store byte
.33
cfsi i72                                ; [fn end: decode_array_19] free: locals 72 byte(s), call args 0 slot(s)
move $$reta $r87                        ; [fn end: decode_array_19] restore return address
popa .32                                ; [fn end: decode_array_19] restore all used registers
jal $zero $$reta i0                     ; [fn end: decode_array_19] return from call
DIFF------------------------------
.program:
.32                                     ; --- start of function: decode_array_19 ---
pusha .32                               ; [fn init: decode_array_19]: push all used registers to stack
move $$locbase $sp                      ; [fn init: decode_array_19]: set locals base register
cfei i72                                ; [fn init: decode_array_19]: allocate: locals 72 byte(s), call args 0 slot(s)
move $r86 $$arg0                        ; [fn init: decode_array_19]: copy argument 0 (__ret_value)
move $r87 $$reta                        ; [fn init: decode_array_19]: save return address
.68
addi $r88 $$locbase i16                 ; get offset to local __ptr [u8; 1]
movi $r91 i255                          ; initialize constant into register
sb $r88 $r91 i0                         ; store byte
addi $r92 $$locbase i16                 ; get offset to local __ptr [u8; 1]
addi $r93 $$locbase i24                 ; get offset to local __ptr slice
move $$arg0 $r92                        ; [call: to_slice_20]: pass argument 0
move $$arg1 $r93                        ; [call: to_slice_20]: pass argument 1
fncall .34                              ; [call: to_slice_20]: call function
addi $r95 $$locbase i40                 ; get offset to local __ptr slice
mcpi $r95 $r93 i16                      ; copy memory
addi $r96 $$locbase i40                 ; get offset to local __ptr slice
addi $r97 $$locbase i56                 ; get offset to local __ptr slice
mcpi $r97 $r96 i16                      ; copy memory
lw $r100 $$locbase i7                   ; load word
lw $r102 $$locbase i8                   ; load word
sw $$locbase $r100 i0                   ; store word
sw $$locbase $r102 i1                   ; store word
lw $r104 $$locbase i0                   ; load word
movi $r105 i1                           ; copy ASM block argument's constant initial value to register
aloc $one                               ; aloc size
mcp $hp $r104 $r105                     ; mcp hp src size
lb $r109 $hp i0                         ; load byte
sb $r86 $r109 i0                        ; store byte
.33
cfsi i72                                ; [fn end: decode_array_19] free: locals 72 byte(s), call args 0 slot(s)
move $$reta $r87                        ; [fn end: decode_array_19] restore return address
popa .32                                ; [fn end: decode_array_19] restore all used registers
jal $zero $$reta i0                     ; [fn end: decode_array_19] return from call
DIFF------------------------------
.program:
.32                                     ; --- start of function: decode_array_19 ---
pusha .32                               ; [fn init: decode_array_19]: push all used registers to stack
move $$locbase $sp                      ; [fn init: decode_array_19]: set locals base register
cfei i72                                ; [fn init: decode_array_19]: allocate: locals 72 byte(s), call args 0 slot(s)
move $r86 $$arg0                        ; [fn init: decode_array_19]: copy argument 0 (__ret_value)
move $r87 $$reta                        ; [fn init: decode_array_19]: save return address
.68
addi $r88 $$locbase i16                 ; get offset to local __ptr [u8; 1]
movi $r91 i255                          ; initialize constant into register
sb $r88 $r91 i0                         ; store byte
addi $r92 $$locbase i16                 ; get offset to local __ptr [u8; 1]
addi $r93 $$locbase i24                 ; get offset to local __ptr slice
move $$arg0 $r92                        ; [call: to_slice_20]: pass argument 0
move $$arg1 $r93                        ; [call: to_slice_20]: pass argument 1
fncall .34                              ; [call: to_slice_20]: call function
addi $r95 $$locbase i40                 ; get offset to local __ptr slice
mcpi $r95 $r93 i16                      ; copy memory
addi $r96 $$locbase i40                 ; get offset to local __ptr slice
addi $r97 $$locbase i56                 ; get offset to local __ptr slice
mcpi $r97 $r96 i16                      ; copy memory
lw $r100 $$locbase i7                   ; load word
lw $r102 $$locbase i8                   ; load word
sw $$locbase $r100 i0                   ; store word
sw $$locbase $r102 i1                   ; store word
lw $r104 $$locbase i0                   ; load word
movi $r105 i1                           ; copy ASM block argument's constant initial value to register
aloc $one                               ; aloc size
mcp $hp $r104 $r105                     ; mcp hp src size
lb $r109 $hp i0                         ; load byte
sb $r86 $r109 i0                        ; store byte
.33
cfsi i72                                ; [fn end: decode_array_19] free: locals 72 byte(s), call args 0 slot(s)
move $$reta $r87                        ; [fn end: decode_array_19] restore return address
popa .32                                ; [fn end: decode_array_19] restore all used registers
jal $zero $$reta i0                     ; [fn end: decode_array_19] return from call
DIFF------------------------------
.program:
.34                                     ; --- start of function: to_slice_20 ---
pusha .34                               ; [fn init: to_slice_20]: push all used registers to stack
move $$locbase $sp                      ; [fn init: to_slice_20]: set locals base register
cfei i40                                ; [fn init: to_slice_20]: allocate: locals 40 byte(s), call args 0 slot(s)
.69
addi $r113 $$locbase i16                ; get offset to local __ptr [u8; 1]
mcpi $r113 $$arg0 i1                    ; copy memory
addi $r114 $$locbase i16                ; get offset to local __ptr [u8; 1]
addi $r115 $$locbase i24                ; get offset to local __ptr { ptr, u64 }
sw $$locbase $r114 i3                   ; store word
addi $r116 $r115 i8                     ; get offset to aggregate element
sw $$locbase $one i4                    ; store word
addi $r117 $$locbase i24                ; get offset to local __ptr { ptr, u64 }
move $r118 $r117                        ; return value from ASM block with return register ptr
 mcpi $$locbase $r118 i16                ; copy memory
 mcpi $$locbase $r117 i16                ; copy memory
mcpi $$arg1 $$locbase i16               ; copy memory
ji  .35
.35
cfsi i40                                ; [fn end: to_slice_20] free: locals 40 byte(s), call args 0 slot(s)
popa .34                                ; [fn end: to_slice_20] restore all used registers
jal $zero $$reta i0                     ; [fn end: to_slice_20] return from call
DIFF------------------------------
.program:
.34                                     ; --- start of function: to_slice_20 ---
pusha .34                               ; [fn init: to_slice_20]: push all used registers to stack
move $$locbase $sp                      ; [fn init: to_slice_20]: set locals base register
cfei i40                                ; [fn init: to_slice_20]: allocate: locals 40 byte(s), call args 0 slot(s)
.69
addi $r113 $$locbase i16                ; get offset to local __ptr [u8; 1]
mcpi $r113 $$arg0 i1                    ; copy memory
addi $r114 $$locbase i16                ; get offset to local __ptr [u8; 1]
sw $$locbase $r114 i3                   ; store word
sw $$locbase $one i4                    ; store word
addi $r117 $$locbase i24                ; get offset to local __ptr { ptr, u64 }
mcpi $$locbase $r117 i16                ; copy memory
mcpi $$arg1 $$locbase i16               ; copy memory
.35
cfsi i40                                ; [fn end: to_slice_20] free: locals 40 byte(s), call args 0 slot(s)
popa .34                                ; [fn end: to_slice_20] restore all used registers
jal $zero $$reta i0                     ; [fn end: to_slice_20] return from call
DIFF------------------------------
.program:
.34                                     ; --- start of function: to_slice_20 ---
pusha .34                               ; [fn init: to_slice_20]: push all used registers to stack
move $$locbase $sp                      ; [fn init: to_slice_20]: set locals base register
cfei i40                                ; [fn init: to_slice_20]: allocate: locals 40 byte(s), call args 0 slot(s)
.69
addi $r113 $$locbase i16                ; get offset to local __ptr [u8; 1]
mcpi $r113 $$arg0 i1                    ; copy memory
addi $r114 $$locbase i16                ; get offset to local __ptr [u8; 1]
sw $$locbase $r114 i3                   ; store word
sw $$locbase $one i4                    ; store word
addi $r117 $$locbase i24                ; get offset to local __ptr { ptr, u64 }
mcpi $$locbase $r117 i16                ; copy memory
mcpi $$arg1 $$locbase i16               ; copy memory
.35
cfsi i40                                ; [fn end: to_slice_20] free: locals 40 byte(s), call args 0 slot(s)
popa .34                                ; [fn end: to_slice_20] restore all used registers
jal $zero $$reta i0                     ; [fn end: to_slice_20] return from call
DIFF------------------------------
.program:
.34                                     ; --- start of function: to_slice_20 ---
pusha .34                               ; [fn init: to_slice_20]: push all used registers to stack
move $$locbase $sp                      ; [fn init: to_slice_20]: set locals base register
cfei i40                                ; [fn init: to_slice_20]: allocate: locals 40 byte(s), call args 0 slot(s)
.69
addi $r113 $$locbase i16                ; get offset to local __ptr [u8; 1]
mcpi $r113 $$arg0 i1                    ; copy memory
addi $r114 $$locbase i16                ; get offset to local __ptr [u8; 1]
sw $$locbase $r114 i3                   ; store word
sw $$locbase $one i4                    ; store word
addi $r117 $$locbase i24                ; get offset to local __ptr { ptr, u64 }
mcpi $$locbase $r117 i16                ; copy memory
mcpi $$arg1 $$locbase i16               ; copy memory
.35
cfsi i40                                ; [fn end: to_slice_20] free: locals 40 byte(s), call args 0 slot(s)
popa .34                                ; [fn end: to_slice_20] restore all used registers
jal $zero $$reta i0                     ; [fn end: to_slice_20] return from call
DIFF------------------------------
.program:
.36                                     ; --- start of function: log_46 ---
pusha .36                               ; [fn init: log_46]: push all used registers to stack
move $$locbase $sp                      ; [fn init: log_46]: set locals base register
cfei i40                                ; [fn init: log_46]: allocate: locals 40 byte(s), call args 0 slot(s)
.70
addi $r120 $$locbase i32                ; get offset to local __ptr u8
sb $r120 $$arg0 i0                      ; store byte
addi $r121 $$locbase i32                ; get offset to local __ptr u8
sw $$locbase $r121 i0                   ; store word
addi $r122 $$locbase i8                 ; get offset to aggregate element
sw $$locbase $one i1                    ; store word
addi $r123 $$locbase i16                ; get offset to local __ptr slice
mcpi $r123 $$locbase i16                ; copy memory
load $r124 data_NonConfigurable_2       ; load constant from data section
lw $r125 $$locbase i2                   ; load slice pointer for logging data
lw $r126 $$locbase i3                   ; load slice size for logging data
logd $zero $r124 $r125 $r126            ; log slice
ji  .37
.37
cfsi i40                                ; [fn end: log_46] free: locals 40 byte(s), call args 0 slot(s)
popa .36                                ; [fn end: log_46] restore all used registers
jal $zero $$reta i0                     ; [fn end: log_46] return from call
DIFF------------------------------
.program:
.36                                     ; --- start of function: log_46 ---
pusha .36                               ; [fn init: log_46]: push all used registers to stack
move $$locbase $sp                      ; [fn init: log_46]: set locals base register
cfei i40                                ; [fn init: log_46]: allocate: locals 40 byte(s), call args 0 slot(s)
.70
addi $r120 $$locbase i32                ; get offset to local __ptr u8
sb $r120 $$arg0 i0                      ; store byte
addi $r121 $$locbase i32                ; get offset to local __ptr u8
sw $$locbase $r121 i0                   ; store word
sw $$locbase $one i1                    ; store word
addi $r123 $$locbase i16                ; get offset to local __ptr slice
mcpi $r123 $$locbase i16                ; copy memory
load $r124 data_NonConfigurable_2       ; load constant from data section
lw $r125 $$locbase i2                   ; load slice pointer for logging data
lw $r126 $$locbase i3                   ; load slice size for logging data
logd $zero $r124 $r125 $r126            ; log slice
.37
cfsi i40                                ; [fn end: log_46] free: locals 40 byte(s), call args 0 slot(s)
popa .36                                ; [fn end: log_46] restore all used registers
jal $zero $$reta i0                     ; [fn end: log_46] return from call
DIFF------------------------------
.program:
.36                                     ; --- start of function: log_46 ---
pusha .36                               ; [fn init: log_46]: push all used registers to stack
move $$locbase $sp                      ; [fn init: log_46]: set locals base register
cfei i40                                ; [fn init: log_46]: allocate: locals 40 byte(s), call args 0 slot(s)
.70
addi $r120 $$locbase i32                ; get offset to local __ptr u8
sb $r120 $$arg0 i0                      ; store byte
addi $r121 $$locbase i32                ; get offset to local __ptr u8
sw $$locbase $r121 i0                   ; store word
sw $$locbase $one i1                    ; store word
addi $r123 $$locbase i16                ; get offset to local __ptr slice
mcpi $r123 $$locbase i16                ; copy memory
load $r124 data_NonConfigurable_2       ; load constant from data section
lw $r125 $$locbase i2                   ; load slice pointer for logging data
lw $r126 $$locbase i3                   ; load slice size for logging data
logd $zero $r124 $r125 $r126            ; log slice
.37
cfsi i40                                ; [fn end: log_46] free: locals 40 byte(s), call args 0 slot(s)
popa .36                                ; [fn end: log_46] restore all used registers
jal $zero $$reta i0                     ; [fn end: log_46] return from call
DIFF------------------------------
.program:
.36                                     ; --- start of function: log_46 ---
pusha .36                               ; [fn init: log_46]: push all used registers to stack
move $$locbase $sp                      ; [fn init: log_46]: set locals base register
cfei i40                                ; [fn init: log_46]: allocate: locals 40 byte(s), call args 0 slot(s)
.70
addi $r120 $$locbase i32                ; get offset to local __ptr u8
sb $r120 $$arg0 i0                      ; store byte
addi $r121 $$locbase i32                ; get offset to local __ptr u8
sw $$locbase $r121 i0                   ; store word
sw $$locbase $one i1                    ; store word
addi $r123 $$locbase i16                ; get offset to local __ptr slice
mcpi $r123 $$locbase i16                ; copy memory
load $r124 data_NonConfigurable_2       ; load constant from data section
lw $r125 $$locbase i2                   ; load slice pointer for logging data
lw $r126 $$locbase i3                   ; load slice size for logging data
logd $zero $r124 $r125 $r126            ; log slice
.37
cfsi i40                                ; [fn end: log_46] free: locals 40 byte(s), call args 0 slot(s)
popa .36                                ; [fn end: log_46] restore all used registers
jal $zero $$reta i0                     ; [fn end: log_46] return from call
DIFF------------------------------
.program:
.40                                     ; --- start of function: is_all_zero_57 ---
pusha .40                               ; [fn init: is_all_zero_57]: push all used registers to stack
move $$locbase $sp                      ; [fn init: is_all_zero_57]: set locals base register
cfei i40                                ; [fn init: is_all_zero_57]: allocate: locals 40 byte(s), call args 0 slot(s)
.117
mcpi $$locbase $$arg0 i40               ; copy memory
 move $r297 $zero                        ; move parameter from branch to block argument
 movi $r297 i0                           ; move parameter from branch to block argument
ji  .118
.118
move $r299 $r297                        ; move parameter from branch to block argument
 lt $r300 $r299 $$arg1
 lt $r300 $r297 $$arg1
jnzi $r300 .119
ji  .120
.120
ji  .41
.119
movi $r301 i8                           ; get array element size
 mul $r302 $r299 $r301                   ; get offset to array element
 muli $r302 $r299 i8                     ; get offset to array element
add $r302 $$locbase $r302               ; add array element offset to array base
lw $r303 $r302 i0                       ; load word
eq $r304 $r303 $zero
eq $r305 $r304 $zero
jnzi $r305 .121
ji  .122
.122
 add $r306 $r299 $one
 addi $r306 $r299 i1
move $r297 $r306                        ; move parameter from branch to block argument
ji  .118
.121
load $r308 data_NonConfigurable_3       ; load constant from data section
rvrt $r308
.41
cfsi i40                                ; [fn end: is_all_zero_57] free: locals 40 byte(s), call args 0 slot(s)
popa .40                                ; [fn end: is_all_zero_57] restore all used registers
jal $zero $$reta i0                     ; [fn end: is_all_zero_57] return from call
DIFF------------------------------
.program:
.40                                     ; --- start of function: is_all_zero_57 ---
pusha .40                               ; [fn init: is_all_zero_57]: push all used registers to stack
move $$locbase $sp                      ; [fn init: is_all_zero_57]: set locals base register
cfei i40                                ; [fn init: is_all_zero_57]: allocate: locals 40 byte(s), call args 0 slot(s)
.117
mcpi $$locbase $$arg0 i40               ; copy memory
movi $r297 i0                           ; move parameter from branch to block argument
.118
move $r299 $r297                        ; move parameter from branch to block argument
lt $r300 $r297 $$arg1
jnzi $r300 .119
.120
ji  .41
.119
muli $r302 $r299 i8                     ; get offset to array element
add $r302 $$locbase $r302               ; add array element offset to array base
lw $r303 $r302 i0                       ; load word
eq $r304 $r303 $zero
eq $r305 $r304 $zero
jnzi $r305 .121
.122
addi $r306 $r299 i1
move $r297 $r306                        ; move parameter from branch to block argument
ji  .118
.121
load $r308 data_NonConfigurable_3       ; load constant from data section
rvrt $r308
.41
cfsi i40                                ; [fn end: is_all_zero_57] free: locals 40 byte(s), call args 0 slot(s)
popa .40                                ; [fn end: is_all_zero_57] restore all used registers
jal $zero $$reta i0                     ; [fn end: is_all_zero_57] return from call
DIFF------------------------------
.program:
.40                                     ; --- start of function: is_all_zero_57 ---
pusha .40                               ; [fn init: is_all_zero_57]: push all used registers to stack
move $$locbase $sp                      ; [fn init: is_all_zero_57]: set locals base register
cfei i40                                ; [fn init: is_all_zero_57]: allocate: locals 40 byte(s), call args 0 slot(s)
.117
mcpi $$locbase $$arg0 i40               ; copy memory
movi $r297 i0                           ; move parameter from branch to block argument
.118
move $r299 $r297                        ; move parameter from branch to block argument
lt $r300 $r297 $$arg1
jnzi $r300 .119
.120
ji  .41
.119
muli $r302 $r299 i8                     ; get offset to array element
add $r302 $$locbase $r302               ; add array element offset to array base
lw $r303 $r302 i0                       ; load word
eq $r304 $r303 $zero
eq $r305 $r304 $zero
jnzi $r305 .121
.122
addi $r306 $r299 i1
move $r297 $r306                        ; move parameter from branch to block argument
ji  .118
.121
load $r308 data_NonConfigurable_3       ; load constant from data section
rvrt $r308
.41
cfsi i40                                ; [fn end: is_all_zero_57] free: locals 40 byte(s), call args 0 slot(s)
popa .40                                ; [fn end: is_all_zero_57] restore all used registers
jal $zero $$reta i0                     ; [fn end: is_all_zero_57] return from call
DIFF------------------------------
.program:
.40                                     ; --- start of function: is_all_zero_57 ---
pusha .40                               ; [fn init: is_all_zero_57]: push all used registers to stack
move $$locbase $sp                      ; [fn init: is_all_zero_57]: set locals base register
cfei i40                                ; [fn init: is_all_zero_57]: allocate: locals 40 byte(s), call args 0 slot(s)
.117
mcpi $$locbase $$arg0 i40               ; copy memory
movi $r297 i0                           ; move parameter from branch to block argument
.118
move $r299 $r297                        ; move parameter from branch to block argument
lt $r300 $r297 $$arg1
jnzi $r300 .119
.120
ji  .41
.119
muli $r302 $r299 i8                     ; get offset to array element
add $r302 $$locbase $r302               ; add array element offset to array base
lw $r303 $r302 i0                       ; load word
eq $r304 $r303 $zero
eq $r305 $r304 $zero
jnzi $r305 .121
.122
addi $r306 $r299 i1
move $r297 $r306                        ; move parameter from branch to block argument
ji  .118
.121
load $r308 data_NonConfigurable_3       ; load constant from data section
rvrt $r308
.41
cfsi i40                                ; [fn end: is_all_zero_57] free: locals 40 byte(s), call args 0 slot(s)
popa .40                                ; [fn end: is_all_zero_57] restore all used registers
jal $zero $$reta i0                     ; [fn end: is_all_zero_57] return from call
DIFF------------------------------
.program:
.42                                     ; --- start of function: is_zero_66 ---
pusha .42                               ; [fn init: is_zero_66]: push all used registers to stack
move $$locbase $sp                      ; [fn init: is_zero_66]: set locals base register
cfei i0                                 ; [fn init: is_zero_66]: allocate: locals 0 byte(s), call args 0 slot(s)
.123
load $r310 data_NonConfigurable_4       ; get local constant
wqcm $r311 $$arg0 $r310 i32
move $$retv $r311                       ; [fn end: is_zero_66] set return value
ji  .43
.43
cfsi i0                                 ; [fn end: is_zero_66] free: locals 0 byte(s), call args 0 slot(s)
popa .42                                ; [fn end: is_zero_66] restore all used registers
jal $zero $$reta i0                     ; [fn end: is_zero_66] return from call
DIFF------------------------------
.program:
.42                                     ; --- start of function: is_zero_66 ---
pusha .42                               ; [fn init: is_zero_66]: push all used registers to stack
move $$locbase $sp                      ; [fn init: is_zero_66]: set locals base register
cfei i0                                 ; [fn init: is_zero_66]: allocate: locals 0 byte(s), call args 0 slot(s)
.123
load $r310 data_NonConfigurable_4       ; get local constant
wqcm $r311 $$arg0 $r310 i32
move $$retv $r311                       ; [fn end: is_zero_66] set return value
.43
cfsi i0                                 ; [fn end: is_zero_66] free: locals 0 byte(s), call args 0 slot(s)
popa .42                                ; [fn end: is_zero_66] restore all used registers
jal $zero $$reta i0                     ; [fn end: is_zero_66] return from call
DIFF------------------------------
.program:
.42                                     ; --- start of function: is_zero_66 ---
pusha .42                               ; [fn init: is_zero_66]: push all used registers to stack
move $$locbase $sp                      ; [fn init: is_zero_66]: set locals base register
cfei i0                                 ; [fn init: is_zero_66]: allocate: locals 0 byte(s), call args 0 slot(s)
.123
load $r310 data_NonConfigurable_4       ; get local constant
wqcm $r311 $$arg0 $r310 i32
move $$retv $r311                       ; [fn end: is_zero_66] set return value
.43
cfsi i0                                 ; [fn end: is_zero_66] free: locals 0 byte(s), call args 0 slot(s)
popa .42                                ; [fn end: is_zero_66] restore all used registers
jal $zero $$reta i0                     ; [fn end: is_zero_66] return from call
DIFF------------------------------
.program:
.42                                     ; --- start of function: is_zero_66 ---
pusha .42                               ; [fn init: is_zero_66]: push all used registers to stack
move $$locbase $sp                      ; [fn init: is_zero_66]: set locals base register
cfei i0                                 ; [fn init: is_zero_66]: allocate: locals 0 byte(s), call args 0 slot(s)
.123
load $r310 data_NonConfigurable_4       ; get local constant
wqcm $r311 $$arg0 $r310 i32
move $$retv $r311                       ; [fn end: is_zero_66] set return value
.43
cfsi i0                                 ; [fn end: is_zero_66] free: locals 0 byte(s), call args 0 slot(s)
popa .42                                ; [fn end: is_zero_66] restore all used registers
jal $zero $$reta i0                     ; [fn end: is_zero_66] return from call
DIFF------------------------------
.program:
.44                                     ; --- start of function: is_zero_69 ---
pusha .44                               ; [fn init: is_zero_69]: push all used registers to stack
move $$locbase $sp                      ; [fn init: is_zero_69]: set locals base register
cfei i0                                 ; [fn init: is_zero_69]: allocate: locals 0 byte(s), call args 0 slot(s)
.124
load $r313 data_NonConfigurable_4       ; get local constant
wqcm $r314 $$arg0 $r313 i32
move $$retv $r314                       ; [fn end: is_zero_69] set return value
ji  .45
.45
cfsi i0                                 ; [fn end: is_zero_69] free: locals 0 byte(s), call args 0 slot(s)
popa .44                                ; [fn end: is_zero_69] restore all used registers
jal $zero $$reta i0                     ; [fn end: is_zero_69] return from call
DIFF------------------------------
.program:
.44                                     ; --- start of function: is_zero_69 ---
pusha .44                               ; [fn init: is_zero_69]: push all used registers to stack
move $$locbase $sp                      ; [fn init: is_zero_69]: set locals base register
cfei i0                                 ; [fn init: is_zero_69]: allocate: locals 0 byte(s), call args 0 slot(s)
.124
load $r313 data_NonConfigurable_4       ; get local constant
wqcm $r314 $$arg0 $r313 i32
move $$retv $r314                       ; [fn end: is_zero_69] set return value
.45
cfsi i0                                 ; [fn end: is_zero_69] free: locals 0 byte(s), call args 0 slot(s)
popa .44                                ; [fn end: is_zero_69] restore all used registers
jal $zero $$reta i0                     ; [fn end: is_zero_69] return from call
DIFF------------------------------
.program:
.44                                     ; --- start of function: is_zero_69 ---
pusha .44                               ; [fn init: is_zero_69]: push all used registers to stack
move $$locbase $sp                      ; [fn init: is_zero_69]: set locals base register
cfei i0                                 ; [fn init: is_zero_69]: allocate: locals 0 byte(s), call args 0 slot(s)
.124
load $r313 data_NonConfigurable_4       ; get local constant
wqcm $r314 $$arg0 $r313 i32
move $$retv $r314                       ; [fn end: is_zero_69] set return value
.45
cfsi i0                                 ; [fn end: is_zero_69] free: locals 0 byte(s), call args 0 slot(s)
popa .44                                ; [fn end: is_zero_69] restore all used registers
jal $zero $$reta i0                     ; [fn end: is_zero_69] return from call
DIFF------------------------------
.program:
.44                                     ; --- start of function: is_zero_69 ---
pusha .44                               ; [fn init: is_zero_69]: push all used registers to stack
move $$locbase $sp                      ; [fn init: is_zero_69]: set locals base register
cfei i0                                 ; [fn init: is_zero_69]: allocate: locals 0 byte(s), call args 0 slot(s)
.124
load $r313 data_NonConfigurable_4       ; get local constant
wqcm $r314 $$arg0 $r313 i32
move $$retv $r314                       ; [fn end: is_zero_69] set return value
.45
cfsi i0                                 ; [fn end: is_zero_69] free: locals 0 byte(s), call args 0 slot(s)
popa .44                                ; [fn end: is_zero_69] restore all used registers
jal $zero $$reta i0                     ; [fn end: is_zero_69] return from call
DIFF------------------------------
.program:
.46                                     ; --- start of function: is_all_zero_77 ---
pusha .46                               ; [fn init: is_all_zero_77]: push all used registers to stack
move $$locbase $sp                      ; [fn init: is_all_zero_77]: set locals base register
cfei i200                               ; [fn init: is_all_zero_77]: allocate: locals 200 byte(s), call args 0 slot(s)
.125
mcpi $$locbase $$arg0 i200              ; copy memory
 move $r316 $zero                        ; move parameter from branch to block argument
 movi $r316 i0                           ; move parameter from branch to block argument
ji  .126
.126
move $r318 $r316                        ; move parameter from branch to block argument
 lt $r319 $r318 $$arg1
 lt $r319 $r316 $$arg1
jnzi $r319 .127
ji  .128
.128
ji  .47
.127
movi $r320 i8                           ; get array element size
 mul $r321 $r318 $r320                   ; get offset to array element
 muli $r321 $r318 i8                     ; get offset to array element
add $r321 $$locbase $r321               ; add array element offset to array base
lw $r322 $r321 i0                       ; load word
eq $r323 $r322 $zero
eq $r324 $r323 $zero
jnzi $r324 .129
ji  .130
.130
 add $r325 $r318 $one
 addi $r325 $r318 i1
move $r316 $r325                        ; move parameter from branch to block argument
ji  .126
.129
load $r327 data_NonConfigurable_3       ; load constant from data section
rvrt $r327
.47
cfsi i200                               ; [fn end: is_all_zero_77] free: locals 200 byte(s), call args 0 slot(s)
popa .46                                ; [fn end: is_all_zero_77] restore all used registers
jal $zero $$reta i0                     ; [fn end: is_all_zero_77] return from call
DIFF------------------------------
.program:
.46                                     ; --- start of function: is_all_zero_77 ---
pusha .46                               ; [fn init: is_all_zero_77]: push all used registers to stack
move $$locbase $sp                      ; [fn init: is_all_zero_77]: set locals base register
cfei i200                               ; [fn init: is_all_zero_77]: allocate: locals 200 byte(s), call args 0 slot(s)
.125
mcpi $$locbase $$arg0 i200              ; copy memory
movi $r316 i0                           ; move parameter from branch to block argument
.126
move $r318 $r316                        ; move parameter from branch to block argument
lt $r319 $r316 $$arg1
jnzi $r319 .127
.128
ji  .47
.127
muli $r321 $r318 i8                     ; get offset to array element
add $r321 $$locbase $r321               ; add array element offset to array base
lw $r322 $r321 i0                       ; load word
eq $r323 $r322 $zero
eq $r324 $r323 $zero
jnzi $r324 .129
.130
addi $r325 $r318 i1
move $r316 $r325                        ; move parameter from branch to block argument
ji  .126
.129
load $r327 data_NonConfigurable_3       ; load constant from data section
rvrt $r327
.47
cfsi i200                               ; [fn end: is_all_zero_77] free: locals 200 byte(s), call args 0 slot(s)
popa .46                                ; [fn end: is_all_zero_77] restore all used registers
jal $zero $$reta i0                     ; [fn end: is_all_zero_77] return from call
DIFF------------------------------
.program:
.46                                     ; --- start of function: is_all_zero_77 ---
pusha .46                               ; [fn init: is_all_zero_77]: push all used registers to stack
move $$locbase $sp                      ; [fn init: is_all_zero_77]: set locals base register
cfei i200                               ; [fn init: is_all_zero_77]: allocate: locals 200 byte(s), call args 0 slot(s)
.125
mcpi $$locbase $$arg0 i200              ; copy memory
movi $r316 i0                           ; move parameter from branch to block argument
.126
move $r318 $r316                        ; move parameter from branch to block argument
lt $r319 $r316 $$arg1
jnzi $r319 .127
.128
ji  .47
.127
muli $r321 $r318 i8                     ; get offset to array element
add $r321 $$locbase $r321               ; add array element offset to array base
lw $r322 $r321 i0                       ; load word
eq $r323 $r322 $zero
eq $r324 $r323 $zero
jnzi $r324 .129
.130
addi $r325 $r318 i1
move $r316 $r325                        ; move parameter from branch to block argument
ji  .126
.129
load $r327 data_NonConfigurable_3       ; load constant from data section
rvrt $r327
.47
cfsi i200                               ; [fn end: is_all_zero_77] free: locals 200 byte(s), call args 0 slot(s)
popa .46                                ; [fn end: is_all_zero_77] restore all used registers
jal $zero $$reta i0                     ; [fn end: is_all_zero_77] return from call
DIFF------------------------------
.program:
.46                                     ; --- start of function: is_all_zero_77 ---
pusha .46                               ; [fn init: is_all_zero_77]: push all used registers to stack
move $$locbase $sp                      ; [fn init: is_all_zero_77]: set locals base register
cfei i200                               ; [fn init: is_all_zero_77]: allocate: locals 200 byte(s), call args 0 slot(s)
.125
mcpi $$locbase $$arg0 i200              ; copy memory
movi $r316 i0                           ; move parameter from branch to block argument
.126
move $r318 $r316                        ; move parameter from branch to block argument
lt $r319 $r316 $$arg1
jnzi $r319 .127
.128
ji  .47
.127
muli $r321 $r318 i8                     ; get offset to array element
add $r321 $$locbase $r321               ; add array element offset to array base
lw $r322 $r321 i0                       ; load word
eq $r323 $r322 $zero
eq $r324 $r323 $zero
jnzi $r324 .129
.130
addi $r325 $r318 i1
move $r316 $r325                        ; move parameter from branch to block argument
ji  .126
.129
load $r327 data_NonConfigurable_3       ; load constant from data section
rvrt $r327
.47
cfsi i200                               ; [fn end: is_all_zero_77] free: locals 200 byte(s), call args 0 slot(s)
popa .46                                ; [fn end: is_all_zero_77] restore all used registers
jal $zero $$reta i0                     ; [fn end: is_all_zero_77] return from call
    Finished release [optimized + fuel] target(s) [2.168 KB] in ???
    script array_repeat
      Bytecode size: 2168 bytes (2.168 KB)
      Bytecode hash: 0x10ba48e0c02a211fd1dd33b7d1a32373961b8f8e5afff176d162f784f9a60853
     Running 1 test, filtered 0 tests

tested -- array_repeat

      test test_array_repeat_zero ... ok (???, 6299007 gas)

test result: OK. 1 passed; 0 failed; finished in ???

    Finished in ???
