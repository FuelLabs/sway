---
source: test/src/snapshot/mod.rs
---
> forc build  --path test/src/e2e_vm_tests/test_programs/should_pass/language/array/array_repeat --experimental const_generics --ir final --asm final
exit status: 0
output:
    Building test/src/e2e_vm_tests/test_programs/should_pass/language/array/array_repeat
   Compiling library std (test/src/e2e_vm_tests/reduced_std_libs/sway-lib-std-assert)
// IR: Final
library {
}

   Compiling script array_repeat (test/src/e2e_vm_tests/test_programs/should_pass/language/array/array_repeat)
// IR: Final
script {
    pub entry fn __entry() -> __ptr slice, !3 {
        local mut slice __aggr_memcpy_0
        local { u64, u64 } __anon_0
        local slice __ret_value

        entry():
        v0 = get_local __ptr slice, __ret_value
        v1 = call main_0(), !6
        v2 = get_local __ptr { u64, u64 }, __anon_0, !7
        v3 = const u64 0
        v4 = get_elem_ptr v2, __ptr u64, v3, !7
        v5 = const u64 0, !8
        store v5 to v4, !7
        v6 = const u64 1
        v7 = get_elem_ptr v2, __ptr u64, v6, !7
        v8 = const u64 0, !9
        store v8 to v7, !7
        v9 = asm(s: v2) -> __ptr slice s {
        }
        v10 = get_local __ptr slice, __aggr_memcpy_0
        mem_copy_val v10, v9
        mem_copy_val v0, v10
        ret __ptr slice v0
    }

    entry_orig fn main_0() -> (), !13 {
        local [u8; 5] __ret_val
        local [u64; 5] __ret_val0
        local [u64; 5] __ret_val1
        local [u256; 25] __ret_val10
        local [b256; 25] __ret_val11
        local [bool; 25] __ret_val12
        local [bool; 5] __ret_val13
        local [bool; 25] __ret_val14
        local [u64; 5] __ret_val2
        local [u256; 5] __ret_val3
        local [b256; 5] __ret_val4
        local [bool; 5] __ret_val5
        local [u8; 25] __ret_val6
        local [u64; 25] __ret_val7
        local [u64; 25] __ret_val8
        local [u64; 25] __ret_val9

        entry():
        v0 = get_local __ptr [u8; 5], __ret_val
        v1 = call array_repeat_zero_small_u8_1(v0)
        v2 = get_local __ptr [u64; 5], __ret_val0
        v3 = call array_repeat_zero_small_u16_2(v2)
        v4 = get_local __ptr [u64; 5], __ret_val1
        v5 = call array_repeat_zero_small_u32_3(v4)
        v6 = get_local __ptr [u64; 5], __ret_val2
        v7 = call array_repeat_zero_small_u64_4(v6)
        v8 = get_local __ptr [u256; 5], __ret_val3
        v9 = call array_repeat_zero_small_u256_5(v8)
        v10 = get_local __ptr [b256; 5], __ret_val4
        v11 = call array_repeat_zero_small_b256_6(v10)
        v12 = get_local __ptr [bool; 5], __ret_val5
        v13 = call array_repeat_zero_small_bool_7(v12)
        v14 = get_local __ptr [u8; 25], __ret_val6
        v15 = call array_repeat_zero_big_u8_8(v14)
        v16 = get_local __ptr [u64; 25], __ret_val7
        v17 = call array_repeat_zero_big_u16_9(v16)
        v18 = get_local __ptr [u64; 25], __ret_val8
        v19 = call array_repeat_zero_big_u32_10(v18)
        v20 = get_local __ptr [u64; 25], __ret_val9
        v21 = call array_repeat_zero_big_u64_11(v20)
        v22 = get_local __ptr [u256; 25], __ret_val10
        v23 = call array_repeat_zero_big_u256_12(v22)
        v24 = get_local __ptr [b256; 25], __ret_val11
        v25 = call array_repeat_zero_big_b256_13(v24)
        v26 = get_local __ptr [bool; 25], __ret_val12
        v27 = call array_repeat_zero_big_bool_14(v26)
        v28 = get_local __ptr [bool; 5], __ret_val13
        v29 = call small_array_repeat_15(v28)
        v30 = get_local __ptr [bool; 25], __ret_val14
        v31 = call big_array_repeat_16(v30)
        v32 = const unit ()
        ret () v32
    }

    fn array_repeat_zero_small_u8_1(__ret_value: __ptr [u8; 5]) -> __ptr [u8; 5], !17 {
        local [u8; 5] __anon_0

        entry(__ret_value: __ptr [u8; 5]):
        v0 = get_local __ptr [u8; 5], __anon_0, !18
        mem_clear_val v0
        mem_copy_val __ret_value, v0
        ret __ptr [u8; 5] __ret_value
    }

    fn array_repeat_zero_small_u16_2(__ret_value: __ptr [u64; 5]) -> __ptr [u64; 5], !21 {
        local [u64; 5] __anon_0

        entry(__ret_value: __ptr [u64; 5]):
        v0 = get_local __ptr [u64; 5], __anon_0, !22
        mem_clear_val v0
        mem_copy_val __ret_value, v0
        ret __ptr [u64; 5] __ret_value
    }

    fn array_repeat_zero_small_u32_3(__ret_value: __ptr [u64; 5]) -> __ptr [u64; 5], !25 {
        local [u64; 5] __anon_0

        entry(__ret_value: __ptr [u64; 5]):
        v0 = get_local __ptr [u64; 5], __anon_0, !26
        mem_clear_val v0
        mem_copy_val __ret_value, v0
        ret __ptr [u64; 5] __ret_value
    }

    fn array_repeat_zero_small_u64_4(__ret_value: __ptr [u64; 5]) -> __ptr [u64; 5], !29 {
        local [u64; 5] __anon_0

        entry(__ret_value: __ptr [u64; 5]):
        v0 = get_local __ptr [u64; 5], __anon_0, !30
        mem_clear_val v0
        mem_copy_val __ret_value, v0
        ret __ptr [u64; 5] __ret_value
    }

    fn array_repeat_zero_small_u256_5(__ret_value: __ptr [u256; 5]) -> __ptr [u256; 5], !33 {
        local [u256; 5] __anon_0

        entry(__ret_value: __ptr [u256; 5]):
        v0 = get_local __ptr [u256; 5], __anon_0, !34
        mem_clear_val v0
        mem_copy_val __ret_value, v0
        ret __ptr [u256; 5] __ret_value
    }

    fn array_repeat_zero_small_b256_6(__ret_value: __ptr [b256; 5]) -> __ptr [b256; 5], !37 {
        local [b256; 5] __anon_0

        entry(__ret_value: __ptr [b256; 5]):
        v0 = get_local __ptr [b256; 5], __anon_0, !38
        mem_clear_val v0
        mem_copy_val __ret_value, v0
        ret __ptr [b256; 5] __ret_value
    }

    fn array_repeat_zero_small_bool_7(__ret_value: __ptr [bool; 5]) -> __ptr [bool; 5], !41 {
        local [bool; 5] __anon_0

        entry(__ret_value: __ptr [bool; 5]):
        v0 = get_local __ptr [bool; 5], __anon_0, !42
        mem_clear_val v0
        mem_copy_val __ret_value, v0
        ret __ptr [bool; 5] __ret_value
    }

    fn array_repeat_zero_big_u8_8(__ret_value: __ptr [u8; 25]) -> __ptr [u8; 25], !45 {
        local [u8; 25] __anon_0

        entry(__ret_value: __ptr [u8; 25]):
        v0 = get_local __ptr [u8; 25], __anon_0, !46
        mem_clear_val v0
        mem_copy_val __ret_value, v0
        ret __ptr [u8; 25] __ret_value
    }

    fn array_repeat_zero_big_u16_9(__ret_value: __ptr [u64; 25]) -> __ptr [u64; 25], !49 {
        local [u64; 25] __anon_0

        entry(__ret_value: __ptr [u64; 25]):
        v0 = get_local __ptr [u64; 25], __anon_0, !50
        mem_clear_val v0
        mem_copy_val __ret_value, v0
        ret __ptr [u64; 25] __ret_value
    }

    fn array_repeat_zero_big_u32_10(__ret_value: __ptr [u64; 25]) -> __ptr [u64; 25], !53 {
        local [u64; 25] __anon_0

        entry(__ret_value: __ptr [u64; 25]):
        v0 = get_local __ptr [u64; 25], __anon_0, !54
        mem_clear_val v0
        mem_copy_val __ret_value, v0
        ret __ptr [u64; 25] __ret_value
    }

    fn array_repeat_zero_big_u64_11(__ret_value: __ptr [u64; 25]) -> __ptr [u64; 25], !57 {
        local [u64; 25] __anon_0

        entry(__ret_value: __ptr [u64; 25]):
        v0 = get_local __ptr [u64; 25], __anon_0, !58
        mem_clear_val v0
        mem_copy_val __ret_value, v0
        ret __ptr [u64; 25] __ret_value
    }

    fn array_repeat_zero_big_u256_12(__ret_value: __ptr [u256; 25]) -> __ptr [u256; 25], !61 {
        local [u256; 25] __anon_0

        entry(__ret_value: __ptr [u256; 25]):
        v0 = get_local __ptr [u256; 25], __anon_0, !62
        mem_clear_val v0
        mem_copy_val __ret_value, v0
        ret __ptr [u256; 25] __ret_value
    }

    fn array_repeat_zero_big_b256_13(__ret_value: __ptr [b256; 25]) -> __ptr [b256; 25], !65 {
        local [b256; 25] __anon_0

        entry(__ret_value: __ptr [b256; 25]):
        v0 = get_local __ptr [b256; 25], __anon_0, !66
        mem_clear_val v0
        mem_copy_val __ret_value, v0
        ret __ptr [b256; 25] __ret_value
    }

    fn array_repeat_zero_big_bool_14(__ret_value: __ptr [bool; 25]) -> __ptr [bool; 25], !69 {
        local [bool; 25] __anon_0

        entry(__ret_value: __ptr [bool; 25]):
        v0 = get_local __ptr [bool; 25], __anon_0, !70
        mem_clear_val v0
        mem_copy_val __ret_value, v0
        ret __ptr [bool; 25] __ret_value
    }

    fn small_array_repeat_15(__ret_value: __ptr [bool; 5]) -> __ptr [bool; 5], !73 {
        local [bool; 5] __anon_0

        entry(__ret_value: __ptr [bool; 5]):
        v0 = get_local __ptr [bool; 5], __anon_0, !74
        v1 = const u64 0
        v2 = get_elem_ptr v0, __ptr bool, v1
        v3 = const bool true, !75
        store v3 to v2, !74
        v4 = const u64 1
        v5 = get_elem_ptr v0, __ptr bool, v4
        store v3 to v5, !74
        v6 = const u64 2
        v7 = get_elem_ptr v0, __ptr bool, v6
        store v3 to v7, !74
        v8 = const u64 3
        v9 = get_elem_ptr v0, __ptr bool, v8
        store v3 to v9, !74
        v10 = const u64 4
        v11 = get_elem_ptr v0, __ptr bool, v10
        store v3 to v11, !74
        mem_copy_val __ret_value, v0
        ret __ptr [bool; 5] __ret_value
    }

    fn big_array_repeat_16(__ret_value: __ptr [bool; 25]) -> __ptr [bool; 25], !78 {
        local [bool; 25] __anon_0

        entry(__ret_value: __ptr [bool; 25]):
        v0 = get_local __ptr [bool; 25], __anon_0, !79
        v1 = const u64 0
        br array_init_loop(v1)

        array_init_loop(v2: u64):
        v3 = get_elem_ptr v0, __ptr bool, v2
        v4 = const bool true, !80
        store v4 to v3, !79
        v5 = const u64 1
        v6 = add v2, v5
        v7 = const u64 25
        v8 = cmp lt v6 v7
        cbr v8, array_init_loop(v6), array_init_exit()

        array_init_exit():
        mem_copy_val __ret_value, v0
        ret __ptr [bool; 25] __ret_value
    }
}

!0 = "test/src/e2e_vm_tests/test_programs/should_pass/language/array/array_repeat/src/main.<autogenerated>.sw"
!1 = span !0 0 135
!2 = fn_name_span !0 7 14
!3 = (!1 !2)
!4 = span !0 66 72
!5 = fn_call_path_span !0 66 70
!6 = (!4 !5)
!7 = span !0 97 103
!8 = span !0 98 99
!9 = span !0 101 102
!10 = "test/src/e2e_vm_tests/test_programs/should_pass/language/array/array_repeat/src/main.sw"
!11 = span !10 1689 2362
!12 = fn_name_span !10 1692 1696
!13 = (!11 !12)
!14 = span !10 58 117
!15 = fn_name_span !10 61 87
!16 = inline "never"
!17 = (!14 !15 !16)
!18 = span !10 107 115
!19 = span !10 220 282
!20 = fn_name_span !10 223 250
!21 = (!19 !20 !16)
!22 = span !10 271 280
!23 = span !10 388 450
!24 = fn_name_span !10 391 418
!25 = (!23 !24 !16)
!26 = span !10 439 448
!27 = span !10 556 618
!28 = fn_name_span !10 559 586
!29 = (!27 !28 !16)
!30 = span !10 607 616
!31 = span !10 725 855
!32 = fn_name_span !10 728 756
!33 = (!31 !32 !16)
!34 = span !10 778 853
!35 = span !10 1030 1156
!36 = fn_name_span !10 1033 1061
!37 = (!35 !36 !16)
!38 = span !10 1083 1154
!39 = span !10 1327 1392
!40 = fn_name_span !10 1330 1358
!41 = (!39 !40 !16)
!42 = span !10 1380 1390
!43 = span !10 135 194
!44 = fn_name_span !10 138 162
!45 = (!43 !44 !16)
!46 = span !10 183 192
!47 = span !10 300 362
!48 = fn_name_span !10 303 328
!49 = (!47 !48 !16)
!50 = span !10 350 360
!51 = span !10 468 530
!52 = fn_name_span !10 471 496
!53 = (!51 !52 !16)
!54 = span !10 518 528
!55 = span !10 636 698
!56 = fn_name_span !10 639 664
!57 = (!55 !56 !16)
!58 = span !10 686 696
!59 = span !10 873 1003
!60 = fn_name_span !10 876 902
!61 = (!59 !60 !16)
!62 = span !10 925 1001
!63 = span !10 1174 1300
!64 = fn_name_span !10 1177 1203
!65 = (!63 !64 !16)
!66 = span !10 1226 1298
!67 = span !10 1410 1475
!68 = fn_name_span !10 1413 1439
!69 = (!67 !68 !16)
!70 = span !10 1462 1473
!71 = span !10 1536 1590
!72 = fn_name_span !10 1539 1557
!73 = (!71 !72 !16)
!74 = span !10 1579 1588
!75 = span !10 1580 1584
!76 = span !10 1633 1687
!77 = fn_name_span !10 1636 1652
!78 = (!76 !77 !16)
!79 = span !10 1675 1685
!80 = span !10 1676 1680

;; ASM: Final program
;; Program kind: Script
.program:
move $$tmp $pc
jmpf $zero i4
DATA_SECTION_OFFSET[0..32]
DATA_SECTION_OFFSET[32..64]
CONFIGURABLES_OFFSET[0..32]
CONFIGURABLES_OFFSET[32..64]
lw   $$ds $$tmp i1
add  $$ds $$ds $$tmp
cfei i0                       ; allocate stack space for globals
move $$locbase $sp            ; save locals base register for function __entry
cfei i48                      ; allocate 48 bytes for locals and 0 slots for call arguments
addi $r0 $$locbase i32        ; get offset to local
jal  $$reta $pc i9            ; [call]: call main_0
addi $r1 $$locbase i16        ; get offset to local
sw   $$locbase $zero i2       ; store word
sw   $$locbase $zero i3       ; store word
mcpi $$locbase $r1 i16        ; copy memory
mcpi $r0 $$locbase i16        ; copy memory
lw   $r1 $r0 i1               ; load size of returned slice
lw   $r0 $r0 i0               ; load pointer to returned slice
retd  $r0 $r1
pshl i3                       ; save registers 16..40
pshh i524288                  ; save registers 40..64
move $$locbase $sp            ; save locals base register for function main_0
cfei i2760                    ; allocate 2760 bytes for locals and 0 slots for call arguments
move $r1 $$reta               ; save return address
move $$arg0 $$locbase         ; [call]: pass argument 0
jal  $$reta $pc i52           ; [call]: call array_repeat_zero_small_u8_1
addi $r0 $$locbase i8         ; get offset to local
move $$arg0 $r0               ; [call]: pass argument 0
jal  $$reta $pc i63           ; [call]: call array_repeat_zero_small_u16_2
addi $r0 $$locbase i48        ; get offset to local
move $$arg0 $r0               ; [call]: pass argument 0
jal  $$reta $pc i74           ; [call]: call array_repeat_zero_small_u32_3
addi $r0 $$locbase i1760      ; get offset to local
move $$arg0 $r0               ; [call]: pass argument 0
jal  $$reta $pc i85           ; [call]: call array_repeat_zero_small_u64_4
addi $r0 $$locbase i1800      ; get offset to local
move $$arg0 $r0               ; [call]: pass argument 0
jal  $$reta $pc i96           ; [call]: call array_repeat_zero_small_u256_5
addi $r0 $$locbase i1960      ; get offset to local
move $$arg0 $r0               ; [call]: pass argument 0
jal  $$reta $pc i107          ; [call]: call array_repeat_zero_small_b256_6
addi $r0 $$locbase i2120      ; get offset to local
move $$arg0 $r0               ; [call]: pass argument 0
jal  $$reta $pc i118          ; [call]: call array_repeat_zero_small_bool_7
addi $r0 $$locbase i2128      ; get offset to local
move $$arg0 $r0               ; [call]: pass argument 0
jal  $$reta $pc i129          ; [call]: call array_repeat_zero_big_u8_8
addi $r0 $$locbase i2160      ; get offset to local
move $$arg0 $r0               ; [call]: pass argument 0
jal  $$reta $pc i140          ; [call]: call array_repeat_zero_big_u16_9
addi $r0 $$locbase i2360      ; get offset to local
move $$arg0 $r0               ; [call]: pass argument 0
jal  $$reta $pc i151          ; [call]: call array_repeat_zero_big_u32_10
addi $r0 $$locbase i2560      ; get offset to local
move $$arg0 $r0               ; [call]: pass argument 0
jal  $$reta $pc i162          ; [call]: call array_repeat_zero_big_u64_11
addi $r0 $$locbase i88        ; get offset to local
move $$arg0 $r0               ; [call]: pass argument 0
jal  $$reta $pc i173          ; [call]: call array_repeat_zero_big_u256_12
addi $r0 $$locbase i888       ; get offset to local
move $$arg0 $r0               ; [call]: pass argument 0
jal  $$reta $pc i184          ; [call]: call array_repeat_zero_big_b256_13
addi $r0 $$locbase i1688      ; get offset to local
move $$arg0 $r0               ; [call]: pass argument 0
jal  $$reta $pc i195          ; [call]: call array_repeat_zero_big_bool_14
addi $r0 $$locbase i1720      ; get offset to local
move $$arg0 $r0               ; [call]: pass argument 0
jal  $$reta $pc i206          ; [call]: call small_array_repeat_15
addi $r0 $$locbase i1728      ; get offset to local
move $$arg0 $r0               ; [call]: pass argument 0
jal  $$reta $pc i234          ; [call]: call big_array_repeat_16
move $$retv $zero             ; set return value
cfsi i2760                    ; free 2760 bytes for locals and 0 slots for extra call arguments
move $$reta $r1               ; restore return address
poph i524288                  ; restore registers 40..64
popl i3                       ; restore registers 16..40
jal  $zero $$reta i0          ; return from call
pshl i3                       ; save registers 16..40
pshh i524288                  ; save registers 40..64
move $$locbase $sp            ; save locals base register for function array_repeat_zero_small_u8_1
cfei i8                       ; allocate 8 bytes for locals and 0 slots for call arguments
move $r0 $$arg0               ; save argument 0 (__ret_value)
move $r1 $$reta               ; save return address
mcli $$locbase i5             ; clear memory [u8; 5], 5 bytes
mcpi $r0 $$locbase i5         ; copy memory
move $$retv $r0               ; set return value
cfsi i8                       ; free 8 bytes for locals and 0 slots for extra call arguments
move $$reta $r1               ; restore return address
poph i524288                  ; restore registers 40..64
popl i3                       ; restore registers 16..40
jal  $zero $$reta i0          ; return from call
pshl i3                       ; save registers 16..40
pshh i524288                  ; save registers 40..64
move $$locbase $sp            ; save locals base register for function array_repeat_zero_small_u16_2
cfei i40                      ; allocate 40 bytes for locals and 0 slots for call arguments
move $r0 $$arg0               ; save argument 0 (__ret_value)
move $r1 $$reta               ; save return address
mcli $$locbase i40            ; clear memory [u64; 5], 40 bytes
mcpi $r0 $$locbase i40        ; copy memory
move $$retv $r0               ; set return value
cfsi i40                      ; free 40 bytes for locals and 0 slots for extra call arguments
move $$reta $r1               ; restore return address
poph i524288                  ; restore registers 40..64
popl i3                       ; restore registers 16..40
jal  $zero $$reta i0          ; return from call
pshl i3                       ; save registers 16..40
pshh i524288                  ; save registers 40..64
move $$locbase $sp            ; save locals base register for function array_repeat_zero_small_u32_3
cfei i40                      ; allocate 40 bytes for locals and 0 slots for call arguments
move $r0 $$arg0               ; save argument 0 (__ret_value)
move $r1 $$reta               ; save return address
mcli $$locbase i40            ; clear memory [u64; 5], 40 bytes
mcpi $r0 $$locbase i40        ; copy memory
move $$retv $r0               ; set return value
cfsi i40                      ; free 40 bytes for locals and 0 slots for extra call arguments
move $$reta $r1               ; restore return address
poph i524288                  ; restore registers 40..64
popl i3                       ; restore registers 16..40
jal  $zero $$reta i0          ; return from call
pshl i3                       ; save registers 16..40
pshh i524288                  ; save registers 40..64
move $$locbase $sp            ; save locals base register for function array_repeat_zero_small_u64_4
cfei i40                      ; allocate 40 bytes for locals and 0 slots for call arguments
move $r0 $$arg0               ; save argument 0 (__ret_value)
move $r1 $$reta               ; save return address
mcli $$locbase i40            ; clear memory [u64; 5], 40 bytes
mcpi $r0 $$locbase i40        ; copy memory
move $$retv $r0               ; set return value
cfsi i40                      ; free 40 bytes for locals and 0 slots for extra call arguments
move $$reta $r1               ; restore return address
poph i524288                  ; restore registers 40..64
popl i3                       ; restore registers 16..40
jal  $zero $$reta i0          ; return from call
pshl i3                       ; save registers 16..40
pshh i524288                  ; save registers 40..64
move $$locbase $sp            ; save locals base register for function array_repeat_zero_small_u256_5
cfei i160                     ; allocate 160 bytes for locals and 0 slots for call arguments
move $r0 $$arg0               ; save argument 0 (__ret_value)
move $r1 $$reta               ; save return address
mcli $$locbase i160           ; clear memory [u256; 5], 160 bytes
mcpi $r0 $$locbase i160       ; copy memory
move $$retv $r0               ; set return value
cfsi i160                     ; free 160 bytes for locals and 0 slots for extra call arguments
move $$reta $r1               ; restore return address
poph i524288                  ; restore registers 40..64
popl i3                       ; restore registers 16..40
jal  $zero $$reta i0          ; return from call
pshl i3                       ; save registers 16..40
pshh i524288                  ; save registers 40..64
move $$locbase $sp            ; save locals base register for function array_repeat_zero_small_b256_6
cfei i160                     ; allocate 160 bytes for locals and 0 slots for call arguments
move $r0 $$arg0               ; save argument 0 (__ret_value)
move $r1 $$reta               ; save return address
mcli $$locbase i160           ; clear memory [b256; 5], 160 bytes
mcpi $r0 $$locbase i160       ; copy memory
move $$retv $r0               ; set return value
cfsi i160                     ; free 160 bytes for locals and 0 slots for extra call arguments
move $$reta $r1               ; restore return address
poph i524288                  ; restore registers 40..64
popl i3                       ; restore registers 16..40
jal  $zero $$reta i0          ; return from call
pshl i3                       ; save registers 16..40
pshh i524288                  ; save registers 40..64
move $$locbase $sp            ; save locals base register for function array_repeat_zero_small_bool_7
cfei i8                       ; allocate 8 bytes for locals and 0 slots for call arguments
move $r0 $$arg0               ; save argument 0 (__ret_value)
move $r1 $$reta               ; save return address
mcli $$locbase i5             ; clear memory [bool; 5], 5 bytes
mcpi $r0 $$locbase i5         ; copy memory
move $$retv $r0               ; set return value
cfsi i8                       ; free 8 bytes for locals and 0 slots for extra call arguments
move $$reta $r1               ; restore return address
poph i524288                  ; restore registers 40..64
popl i3                       ; restore registers 16..40
jal  $zero $$reta i0          ; return from call
pshl i3                       ; save registers 16..40
pshh i524288                  ; save registers 40..64
move $$locbase $sp            ; save locals base register for function array_repeat_zero_big_u8_8
cfei i32                      ; allocate 32 bytes for locals and 0 slots for call arguments
move $r0 $$arg0               ; save argument 0 (__ret_value)
move $r1 $$reta               ; save return address
mcli $$locbase i25            ; clear memory [u8; 25], 25 bytes
mcpi $r0 $$locbase i25        ; copy memory
move $$retv $r0               ; set return value
cfsi i32                      ; free 32 bytes for locals and 0 slots for extra call arguments
move $$reta $r1               ; restore return address
poph i524288                  ; restore registers 40..64
popl i3                       ; restore registers 16..40
jal  $zero $$reta i0          ; return from call
pshl i3                       ; save registers 16..40
pshh i524288                  ; save registers 40..64
move $$locbase $sp            ; save locals base register for function array_repeat_zero_big_u16_9
cfei i200                     ; allocate 200 bytes for locals and 0 slots for call arguments
move $r0 $$arg0               ; save argument 0 (__ret_value)
move $r1 $$reta               ; save return address
mcli $$locbase i200           ; clear memory [u64; 25], 200 bytes
mcpi $r0 $$locbase i200       ; copy memory
move $$retv $r0               ; set return value
cfsi i200                     ; free 200 bytes for locals and 0 slots for extra call arguments
move $$reta $r1               ; restore return address
poph i524288                  ; restore registers 40..64
popl i3                       ; restore registers 16..40
jal  $zero $$reta i0          ; return from call
pshl i3                       ; save registers 16..40
pshh i524288                  ; save registers 40..64
move $$locbase $sp            ; save locals base register for function array_repeat_zero_big_u32_10
cfei i200                     ; allocate 200 bytes for locals and 0 slots for call arguments
move $r0 $$arg0               ; save argument 0 (__ret_value)
move $r1 $$reta               ; save return address
mcli $$locbase i200           ; clear memory [u64; 25], 200 bytes
mcpi $r0 $$locbase i200       ; copy memory
move $$retv $r0               ; set return value
cfsi i200                     ; free 200 bytes for locals and 0 slots for extra call arguments
move $$reta $r1               ; restore return address
poph i524288                  ; restore registers 40..64
popl i3                       ; restore registers 16..40
jal  $zero $$reta i0          ; return from call
pshl i3                       ; save registers 16..40
pshh i524288                  ; save registers 40..64
move $$locbase $sp            ; save locals base register for function array_repeat_zero_big_u64_11
cfei i200                     ; allocate 200 bytes for locals and 0 slots for call arguments
move $r0 $$arg0               ; save argument 0 (__ret_value)
move $r1 $$reta               ; save return address
mcli $$locbase i200           ; clear memory [u64; 25], 200 bytes
mcpi $r0 $$locbase i200       ; copy memory
move $$retv $r0               ; set return value
cfsi i200                     ; free 200 bytes for locals and 0 slots for extra call arguments
move $$reta $r1               ; restore return address
poph i524288                  ; restore registers 40..64
popl i3                       ; restore registers 16..40
jal  $zero $$reta i0          ; return from call
pshl i3                       ; save registers 16..40
pshh i524288                  ; save registers 40..64
move $$locbase $sp            ; save locals base register for function array_repeat_zero_big_u256_12
cfei i800                     ; allocate 800 bytes for locals and 0 slots for call arguments
move $r0 $$arg0               ; save argument 0 (__ret_value)
move $r1 $$reta               ; save return address
mcli $$locbase i800           ; clear memory [u256; 25], 800 bytes
mcpi $r0 $$locbase i800       ; copy memory
move $$retv $r0               ; set return value
cfsi i800                     ; free 800 bytes for locals and 0 slots for extra call arguments
move $$reta $r1               ; restore return address
poph i524288                  ; restore registers 40..64
popl i3                       ; restore registers 16..40
jal  $zero $$reta i0          ; return from call
pshl i3                       ; save registers 16..40
pshh i524288                  ; save registers 40..64
move $$locbase $sp            ; save locals base register for function array_repeat_zero_big_b256_13
cfei i800                     ; allocate 800 bytes for locals and 0 slots for call arguments
move $r0 $$arg0               ; save argument 0 (__ret_value)
move $r1 $$reta               ; save return address
mcli $$locbase i800           ; clear memory [b256; 25], 800 bytes
mcpi $r0 $$locbase i800       ; copy memory
move $$retv $r0               ; set return value
cfsi i800                     ; free 800 bytes for locals and 0 slots for extra call arguments
move $$reta $r1               ; restore return address
poph i524288                  ; restore registers 40..64
popl i3                       ; restore registers 16..40
jal  $zero $$reta i0          ; return from call
pshl i3                       ; save registers 16..40
pshh i524288                  ; save registers 40..64
move $$locbase $sp            ; save locals base register for function array_repeat_zero_big_bool_14
cfei i32                      ; allocate 32 bytes for locals and 0 slots for call arguments
move $r0 $$arg0               ; save argument 0 (__ret_value)
move $r1 $$reta               ; save return address
mcli $$locbase i25            ; clear memory [bool; 25], 25 bytes
mcpi $r0 $$locbase i25        ; copy memory
move $$retv $r0               ; set return value
cfsi i32                      ; free 32 bytes for locals and 0 slots for extra call arguments
move $$reta $r1               ; restore return address
poph i524288                  ; restore registers 40..64
popl i3                       ; restore registers 16..40
jal  $zero $$reta i0          ; return from call
pshl i7                       ; save registers 16..40
pshh i524288                  ; save registers 40..64
move $$locbase $sp            ; save locals base register for function small_array_repeat_15
cfei i8                       ; allocate 8 bytes for locals and 0 slots for call arguments
move $r0 $$arg0               ; save argument 0 (__ret_value)
move $r1 $$reta               ; save return address
mul  $r2 $zero $one           ; get offset to array element
add  $r2 $$locbase $r2        ; add array element offset to array base
sb   $r2 $one i0              ; store byte
mul  $r2 $one $one            ; get offset to array element
add  $r2 $$locbase $r2        ; add array element offset to array base
sb   $r2 $one i0              ; store byte
movi $r2 i2                   ; initialize constant into register
mul  $r2 $r2 $one             ; get offset to array element
add  $r2 $$locbase $r2        ; add array element offset to array base
sb   $r2 $one i0              ; store byte
movi $r2 i3                   ; initialize constant into register
mul  $r2 $r2 $one             ; get offset to array element
add  $r2 $$locbase $r2        ; add array element offset to array base
sb   $r2 $one i0              ; store byte
movi $r2 i4                   ; initialize constant into register
mul  $r2 $r2 $one             ; get offset to array element
add  $r2 $$locbase $r2        ; add array element offset to array base
sb   $r2 $one i0              ; store byte
mcpi $r0 $$locbase i5         ; copy memory
move $$retv $r0               ; set return value
cfsi i8                       ; free 8 bytes for locals and 0 slots for extra call arguments
move $$reta $r1               ; restore return address
poph i524288                  ; restore registers 40..64
popl i7                       ; restore registers 16..40
jal  $zero $$reta i0          ; return from call
pshl i15                      ; save registers 16..40
pshh i524288                  ; save registers 40..64
move $$locbase $sp            ; save locals base register for function big_array_repeat_16
cfei i32                      ; allocate 32 bytes for locals and 0 slots for call arguments
move $r2 $$arg0               ; save argument 0 (__ret_value)
move $r3 $$reta               ; save return address
move $r1 $zero                ; move parameter from branch to block argument
mul  $r0 $r1 $one             ; get offset to array element
add  $r0 $$locbase $r0        ; add array element offset to array base
sb   $r0 $one i0              ; store byte
add  $r1 $r1 $one
movi $r0 i25                  ; initialize constant into register
lt   $r0 $r1 $r0
jnzb $r0 $zero i5
mcpi $r2 $$locbase i25        ; copy memory
move $$retv $r2               ; set return value
cfsi i32                      ; free 32 bytes for locals and 0 slots for extra call arguments
move $$reta $r3               ; restore return address
poph i524288                  ; restore registers 40..64
popl i15                      ; restore registers 16..40
jal  $zero $$reta i0          ; return from call
.data:


warning
   --> test/src/e2e_vm_tests/test_programs/should_pass/language/array/array_repeat/src/main.sw:110:24
    |
108 | trait IsZero { fn is_zero(self) -> bool; }
109 | 
110 | impl IsZero for bool { fn is_zero(self) -> bool { self == false }}
    |                        ------------------------------------------ This method is never called.
111 | impl IsZero for u8 { fn is_zero(self) -> bool { self == 0 }}
112 | impl IsZero for u16 { fn is_zero(self) -> bool { self == 0 }}
    |
____

warning
   --> test/src/e2e_vm_tests/test_programs/should_pass/language/array/array_repeat/src/main.sw:111:22
    |
109 | 
110 | impl IsZero for bool { fn is_zero(self) -> bool { self == false }}
111 | impl IsZero for u8 { fn is_zero(self) -> bool { self == 0 }}
    |                      -------------------------------------- This method is never called.
112 | impl IsZero for u16 { fn is_zero(self) -> bool { self == 0 }}
113 | impl IsZero for u32 { fn is_zero(self) -> bool { self == 0 }}
    |
____

warning
   --> test/src/e2e_vm_tests/test_programs/should_pass/language/array/array_repeat/src/main.sw:112:23
    |
110 | impl IsZero for bool { fn is_zero(self) -> bool { self == false }}
111 | impl IsZero for u8 { fn is_zero(self) -> bool { self == 0 }}
112 | impl IsZero for u16 { fn is_zero(self) -> bool { self == 0 }}
    |                       -------------------------------------- This method is never called.
113 | impl IsZero for u32 { fn is_zero(self) -> bool { self == 0 }}
114 | impl IsZero for u64 { fn is_zero(self) -> bool { self == 0 }}
    |
____

warning
   --> test/src/e2e_vm_tests/test_programs/should_pass/language/array/array_repeat/src/main.sw:113:23
    |
111 | impl IsZero for u8 { fn is_zero(self) -> bool { self == 0 }}
112 | impl IsZero for u16 { fn is_zero(self) -> bool { self == 0 }}
113 | impl IsZero for u32 { fn is_zero(self) -> bool { self == 0 }}
    |                       -------------------------------------- This method is never called.
114 | impl IsZero for u64 { fn is_zero(self) -> bool { self == 0 }}
115 | impl IsZero for u256 { fn is_zero(self) -> bool { self == 0x0000000000000000000000000000000000000000000000000000000000000000u256 }}
    |
____

warning
   --> test/src/e2e_vm_tests/test_programs/should_pass/language/array/array_repeat/src/main.sw:114:23
    |
112 | impl IsZero for u16 { fn is_zero(self) -> bool { self == 0 }}
113 | impl IsZero for u32 { fn is_zero(self) -> bool { self == 0 }}
114 | impl IsZero for u64 { fn is_zero(self) -> bool { self == 0 }}
    |                       -------------------------------------- This method is never called.
115 | impl IsZero for u256 { fn is_zero(self) -> bool { self == 0x0000000000000000000000000000000000000000000000000000000000000000u256 }}
116 | impl IsZero for b256 { fn is_zero(self) -> bool { self == 0x0000000000000000000000000000000000000000000000000000000000000000 }}
    |
____

warning
   --> test/src/e2e_vm_tests/test_programs/should_pass/language/array/array_repeat/src/main.sw:115:24
    |
113 | impl IsZero for u32 { fn is_zero(self) -> bool { self == 0 }}
114 | impl IsZero for u64 { fn is_zero(self) -> bool { self == 0 }}
115 | impl IsZero for u256 { fn is_zero(self) -> bool { self == 0x0000000000000000000000000000000000000000000000000000000000000000u256 }}
    |                        ----------------------------------------------------------------------------------------------------------- This method is never called.
116 | impl IsZero for b256 { fn is_zero(self) -> bool { self == 0x0000000000000000000000000000000000000000000000000000000000000000 }}
117 | 
    |
____

warning
   --> test/src/e2e_vm_tests/test_programs/should_pass/language/array/array_repeat/src/main.sw:116:24
    |
114 | impl IsZero for u64 { fn is_zero(self) -> bool { self == 0 }}
115 | impl IsZero for u256 { fn is_zero(self) -> bool { self == 0x0000000000000000000000000000000000000000000000000000000000000000u256 }}
116 | impl IsZero for b256 { fn is_zero(self) -> bool { self == 0x0000000000000000000000000000000000000000000000000000000000000000 }}
    |                        ------------------------------------------------------------------------------------------------------- This method is never called.
117 | 
118 | fn is_all_zero<T, const N: u64>(array: [T; N], n: u64) where T: IsZero {
    |
____

warning
   --> test/src/e2e_vm_tests/test_programs/should_pass/language/array/array_repeat/src/main.sw:118:4
    |
116 | impl IsZero for b256 { fn is_zero(self) -> bool { self == 0x0000000000000000000000000000000000000000000000000000000000000000 }}
117 | 
118 | fn is_all_zero<T, const N: u64>(array: [T; N], n: u64) where T: IsZero {
    |    ----------- This function is never called.
119 |     let mut i = 0;
120 |     while i < n {
    |
____

  Compiled script "array_repeat" with 8 warnings.
    Finished debug [unoptimized + fuel] target(s) [1.304 KB] in ???

> forc test --path test/src/e2e_vm_tests/test_programs/should_pass/language/array/array_repeat --experimental const_generics --verbose
exit status: 0
output:
    Building test/src/e2e_vm_tests/test_programs/should_pass/language/array/array_repeat
   Compiling library std (test/src/e2e_vm_tests/reduced_std_libs/sway-lib-std-assert)
   Compiling script array_repeat (test/src/e2e_vm_tests/test_programs/should_pass/language/array/array_repeat)
    Finished debug [unoptimized + fuel] target(s) [4.584 KB] in ???
    script array_repeat
      Bytecode size: 4584 bytes (4.584 KB)
      Bytecode hash: 0xca94e206724f138b65f71ddee439ab8e9d6d290913e703a5019fd11ee5833126
     Running 1 test, filtered 0 tests

tested -- array_repeat

      test test_array_repeat_zero ... ok (???, 18891 gas)

test result: OK. 1 passed; 0 failed; finished in ???

    Finished in ???
