---
source: test/src/snapshot/mod.rs
---
> forc test --path test/src/e2e_vm_tests/test_programs/should_pass/language/panic_expression/panicking_contract --test-threads 1 --logs --reverts
exit status: 0
output:
    Building test/src/e2e_vm_tests/test_programs/should_pass/language/panic_expression/panicking_contract
   Compiling library std (test/src/e2e_vm_tests/reduced_std_libs/sway-lib-std-core)
DIFF------------------------------
.program:
   Compiling library panicking_lib (test/src/e2e_vm_tests/test_programs/should_pass/language/panic_expression/panicking_lib)
DIFF------------------------------
.program:
   Compiling contract panicking_contract (test/src/e2e_vm_tests/test_programs/should_pass/language/panic_expression/panicking_contract)
DIFF------------------------------
.program:
DIFF------------------------------
.program:
.0                                      ; --- start of function: __entry ---
move $$locbase $sp                      ; save locals base register for function __entry
cfei i1264                              ; allocate 1264 bytes for locals and 0 slots for call arguments
.24
addr $r1 data_NonConfigurable_0         ; get __const_global's address in data section
addi $r2 $$locbase i40                  ; get offset to local __ptr { ptr, u64 }
sw $$locbase $r1 i5                     ; store word
addi $r3 $r2 i8                         ; get offset to aggregate element
movi $r4 i454                           ; initialize constant into register
sw $$locbase $r4 i6                     ; store word
addi $r5 $$locbase i256                 ; get offset to local __ptr slice
mcpi $r5 $r2 i16                        ; copy memory
addi $r6 $$locbase i640                 ; get offset to local __ptr slice
mcpi $r6 $r5 i16                        ; copy memory
addi $r7 $$locbase i640                 ; get offset to local __ptr slice
addi $r8 $$locbase i952                 ; get offset to local __ptr slice
mcpi $r8 $r7 i16                        ; copy memory
addi $r9 $$locbase i952                 ; get offset to local __ptr slice
move $r10 $r9                           ; return value from ASM block with return register s
addi $r11 $$locbase i24                 ; get offset to local __ptr { ptr, u64 }
 mcpi $r11 $r10 i16                      ; copy memory
 mcpi $r11 $r9 i16                       ; copy memory
addi $r12 $$locbase i568                ; get offset to local __ptr { ptr, u64 }
mcpi $r12 $r11 i16                      ; copy memory
addi $r13 $$locbase i568                ; get offset to local __ptr { ptr, u64 }
addi $r14 $$locbase i584                ; get offset to local __ptr { ptr, u64 }
mcpi $r14 $r13 i16                      ; copy memory
addi $r15 $$locbase i584                ; get offset to local __ptr { ptr, u64 }
addi $r16 $$locbase i896                ; get offset to local __ptr ptr
mcpi $r16 $r15 i8                       ; copy memory
addi $r17 $$locbase i584                ; get offset to local __ptr { ptr, u64 }
addi $r18 $r17 i8                       ; get offset to aggregate element
addi $r19 $$locbase i16                 ; get offset to local __ptr u64
mcpi $r19 $r18 i8                       ; copy memory
addi $r20 $$locbase i896                ; get offset to local __ptr ptr
lw $r21 $$locbase i112                  ; load word
addi $r22 $$locbase i656                ; get offset to local __ptr ptr
sw $$locbase $r21 i82                   ; store word
addi $r23 $$locbase i8                  ; get offset to local __ptr u64
movi $r24 i74                           ; initialize constant into register
sw $$locbase $r24 i1                    ; store word
move $r25 $fp                           ; return value from ASM block with return register fp
addi $r26 $$locbase i904                ; get offset to local __ptr ptr
 sw $$locbase $r25 i113                  ; store word
 sw $$locbase $fp i113                   ; store word
addi $r27 $$locbase i904                ; get offset to local __ptr ptr
addi $r28 $$locbase i8                  ; get offset to local __ptr u64
addi $r29 $$locbase i968                ; get offset to local __ptr ptr
mcpi $r29 $r27 i8                       ; copy memory
addi $r30 $$locbase i664                ; get offset to local __ptr u64
mcpi $r30 $r28 i8                       ; copy memory
addi $r31 $$locbase i968                ; get offset to local __ptr ptr
lw $r32 $$locbase i121                  ; load word
addi $r33 $$locbase i664                ; get offset to local __ptr u64
lw $r34 $$locbase i83                   ; load word
movi $r35 i8                            ; initialize constant into register
mul $r36 $r35 $r34
add $r37 $r32 $r36
addi $r38 $$locbase i920                ; get offset to local __ptr ptr
sw $$locbase $r37 i115                  ; store word
addi $r39 $$locbase i920                ; get offset to local __ptr ptr
lw $r40 $$locbase i115                  ; load word
move $$arg0 $r40                        ; [call]: pass argument 0
fncall .2                               ; [call]: call read_3
move $r41 $$retv                        ; [call]: copy the return value
addi $r42 $$locbase i936                ; get offset to local __ptr u64
 sw $$locbase $r41 i117                  ; store word
 sw $$locbase $$retv i117                ; store word
addi $r43 $$locbase i936                ; get offset to local __ptr u64
lw $r44 $$locbase i117                  ; load word
move $r45 $r44                          ; return value from ASM block with return register ptr
addi $r46 $$locbase i600                ; get offset to local __ptr ptr
 sw $$locbase $r45 i75                   ; store word
 sw $$locbase $r44 i75                   ; store word
movi $r47 i73                           ; initialize constant into register
sw $$locbase $r47 i0                    ; store word
move $r48 $fp                           ; return value from ASM block with return register fp
addi $r49 $$locbase i912                ; get offset to local __ptr ptr
 sw $$locbase $r48 i114                  ; store word
 sw $$locbase $fp i114                   ; store word
addi $r50 $$locbase i912                ; get offset to local __ptr ptr
addi $r51 $$locbase i984                ; get offset to local __ptr ptr
mcpi $r51 $r50 i8                       ; copy memory
addi $r52 $$locbase i672                ; get offset to local __ptr u64
mcpi $r52 $$locbase i8                  ; copy memory
addi $r53 $$locbase i984                ; get offset to local __ptr ptr
lw $r54 $$locbase i123                  ; load word
addi $r55 $$locbase i672                ; get offset to local __ptr u64
lw $r56 $$locbase i84                   ; load word
movi $r57 i8                            ; initialize constant into register
mul $r58 $r57 $r56
add $r59 $r54 $r58
addi $r60 $$locbase i928                ; get offset to local __ptr ptr
sw $$locbase $r59 i116                  ; store word
addi $r61 $$locbase i928                ; get offset to local __ptr ptr
lw $r62 $$locbase i116                  ; load word
move $$arg0 $r62                        ; [call]: pass argument 0
fncall .2                               ; [call]: call read_3
move $r63 $$retv                        ; [call]: copy the return value
addi $r64 $$locbase i944                ; get offset to local __ptr u64
 sw $$locbase $r63 i118                  ; store word
 sw $$locbase $$retv i118                ; store word
addi $r65 $$locbase i944                ; get offset to local __ptr u64
lw $r66 $$locbase i118                  ; load word
move $r67 $r66                          ; return value from ASM block with return register ptr
addi $r68 $$locbase i624                ; get offset to local __ptr ptr
 sw $$locbase $r67 i78                   ; store word
 sw $$locbase $r66 i78                   ; store word
addi $r69 $$locbase i528                ; get offset to local __ptr { ptr }
addi $r70 $$locbase i624                ; get offset to local __ptr ptr
mcpi $r69 $r70 i8                       ; copy memory
addi $r71 $$locbase i616                ; get offset to local __ptr { ptr }
mcpi $r71 $r69 i8                       ; copy memory
addi $r72 $$locbase i616                ; get offset to local __ptr { ptr }
addi $r73 $$locbase i1056               ; get offset to local __ptr __ptr { ptr }
sw $$locbase $r72 i132                  ; store word
addi $r74 $$locbase i1120               ; get offset to local __ptr u64
movi $r75 i8                            ; initialize constant into register
sw $$locbase $r75 i140                  ; store word
 jnzi $zero .25
 
ji  .26
.26
addi $r76 $$locbase i1120               ; get offset to local __ptr u64
addi $r77 $$locbase i976                ; get offset to local __ptr u64
mcpi $r77 $r76 i8                       ; copy memory
addi $r78 $$locbase i784                ; get offset to local __ptr u64
sw $$locbase $one i98                   ; store word
addi $r79 $$locbase i976                ; get offset to local __ptr u64
lw $r80 $$locbase i122                  ; load word
addi $r81 $$locbase i784                ; get offset to local __ptr u64
lw $r82 $$locbase i98                   ; load word
eq $r83 $r80 $r82
jnzi $r83 .27
ji  .28
.28
addi $r84 $$locbase i1056               ; get offset to local __ptr __ptr { ptr }
addi $r85 $$locbase i992                ; get offset to local __ptr __ptr { ptr }
mcpi $r85 $r84 i8                       ; copy memory
addi $r86 $$locbase i992                ; get offset to local __ptr __ptr { ptr }
lw $r87 $$locbase i124                  ; load word
lw $r88 $r87 i0                         ; load word
lw $r89 $r88 i0                         ; lw val ptr i0
move $r90 $r89                          ; return value from ASM block with return register val
addi $r91 $$locbase i1248               ; get offset to local __ptr u64
 sw $$locbase $r90 i156                  ; store word
 sw $$locbase $r89 i156                  ; store word
addi $r92 $$locbase i992                ; get offset to local __ptr __ptr { ptr }
lw $r93 $$locbase i124                  ; load word
lw $r94 $r93 i0                         ; load word
movi $r95 i8                            ; initialize constant into register
 mul $r96 $one $r95
 movi $r96 i8
add $r97 $r94 $r96
addi $r98 $$locbase i992                ; get offset to local __ptr __ptr { ptr }
lw $r99 $$locbase i124                  ; load word
sw $r99 $r97 i0                         ; store word
addi $r100 $$locbase i1248              ; get offset to local __ptr u64
lw $r101 $$locbase i156                 ; load word
move $r102 $r101                        ; move parameter from branch to block argument
ji  .29
.27
addi $r103 $$locbase i1056              ; get offset to local __ptr __ptr { ptr }
lw $r104 $$locbase i132                 ; load word
lw $r105 $r104 i0                       ; load word
lb $r106 $r105 i0                       ; lb val ptr i0
move $r107 $r106                        ; return value from ASM block with return register val
addi $r108 $$locbase i1256              ; get offset to local __ptr u64
 sw $$locbase $r107 i157                 ; store word
 sw $$locbase $r106 i157                 ; store word
addi $r109 $$locbase i1056              ; get offset to local __ptr __ptr { ptr }
lw $r110 $$locbase i132                 ; load word
lw $r111 $r110 i0                       ; load word
 mul $r112 $one $one
 add $r113 $r111 $r112
 movi $r112 i1
 add $r113 $r111 $one
addi $r114 $$locbase i1056              ; get offset to local __ptr __ptr { ptr }
lw $r115 $$locbase i132                 ; load word
sw $r115 $r113 i0                       ; store word
addi $r116 $$locbase i1256              ; get offset to local __ptr u64
lw $r117 $$locbase i157                 ; load word
move $r102 $r117                        ; move parameter from branch to block argument
ji  .29
.29
move $r120 $r102                        ; move parameter from branch to block argument
 move $r121 $r120                        ; move parameter from branch to block argument
 move $r121 $r102                        ; move parameter from branch to block argument
ji  .30
.25
addi $r122 $$locbase i1056              ; get offset to local __ptr __ptr { ptr }
lw $r123 $$locbase i132                 ; load word
lw $r124 $r123 i0                       ; load word
move $r125 $r124                        ; return value from ASM block with return register ptr
addi $r126 $$locbase i1240              ; get offset to local __ptr u64
 sw $$locbase $r125 i155                 ; store word
 sw $$locbase $r124 i155                 ; store word
addi $r127 $$locbase i1056              ; get offset to local __ptr __ptr { ptr }
lw $r128 $$locbase i132                 ; load word
lw $r129 $r128 i0                       ; load word
addi $r130 $$locbase i1120              ; get offset to local __ptr u64
lw $r131 $$locbase i140                 ; load word
mul $r132 $one $r131
add $r133 $r129 $r132
addi $r134 $$locbase i1056              ; get offset to local __ptr __ptr { ptr }
lw $r135 $$locbase i132                 ; load word
sw $r135 $r133 i0                       ; store word
addi $r136 $$locbase i1240              ; get offset to local __ptr u64
lw $r137 $$locbase i155                 ; load word
move $r121 $r137                        ; move parameter from branch to block argument
ji  .30
.30
move $r140 $r121                        ; move parameter from branch to block argument
addi $r141 $$locbase i608               ; get offset to local __ptr u64
 sw $$locbase $r140 i76                  ; store word
 sw $$locbase $r121 i76                  ; store word
addi $r142 $$locbase i616               ; get offset to local __ptr { ptr }
addi $r143 $$locbase i1064              ; get offset to local __ptr { ptr }
mcpi $r143 $r142 i8                     ; copy memory
addi $r144 $$locbase i1064              ; get offset to local __ptr { ptr }
lw $r145 $$locbase i133                 ; load word
addi $r146 $$locbase i632               ; get offset to local __ptr ptr
sw $$locbase $r145 i79                  ; store word
addi $r147 $$locbase i608               ; get offset to local __ptr u64
addi $r148 $$locbase i1072              ; get offset to local __ptr u64
mcpi $r148 $r147 i8                     ; copy memory
addi $r149 $$locbase i792               ; get offset to local __ptr u64
movi $r150 i20                          ; initialize constant into register
sw $$locbase $r150 i99                  ; store word
addi $r151 $$locbase i1072              ; get offset to local __ptr u64
lw $r152 $$locbase i134                 ; load word
addi $r153 $$locbase i792               ; get offset to local __ptr u64
lw $r154 $$locbase i99                  ; load word
eq $r155 $r152 $r154
jnzi $r155 .31
ji  .32
.31
addi $r156 $$locbase i632               ; get offset to local __ptr ptr
lw $r157 $$locbase i79                  ; load word
addi $r158 $$locbase i656               ; get offset to local __ptr ptr
lw $r159 $$locbase i82                  ; load word
movi $r161 i20                          ; initialize constant into register
addi $r160 $r159 i332
meq $r160 $r157 $r160 $r161
move $r162 $r160                        ; return value from ASM block with return register r
addi $r163 $$locbase i680               ; get offset to local __ptr bool
 sb $r163 $r162 i0                       ; store byte
 sb $r163 $r160 i0                       ; store byte
addi $r164 $$locbase i680               ; get offset to local __ptr bool
lb $r165 $r164 i0                       ; load byte
jnzi $r165 .33
ji  .32
.32
addi $r166 $$locbase i608               ; get offset to local __ptr u64
addi $r167 $$locbase i1080              ; get offset to local __ptr u64
mcpi $r167 $r166 i8                     ; copy memory
addi $r168 $$locbase i800               ; get offset to local __ptr u64
movi $r169 i22                          ; initialize constant into register
sw $$locbase $r169 i100                 ; store word
addi $r170 $$locbase i1080              ; get offset to local __ptr u64
lw $r171 $$locbase i135                 ; load word
addi $r172 $$locbase i800               ; get offset to local __ptr u64
lw $r173 $$locbase i100                 ; load word
eq $r174 $r171 $r173
jnzi $r174 .34
ji  .35
.34
addi $r175 $$locbase i632               ; get offset to local __ptr ptr
lw $r176 $$locbase i79                  ; load word
addi $r177 $$locbase i656               ; get offset to local __ptr ptr
lw $r178 $$locbase i82                  ; load word
movi $r180 i22                          ; initialize constant into register
addi $r179 $r178 i247
meq $r179 $r176 $r179 $r180
move $r181 $r179                        ; return value from ASM block with return register r
addi $r182 $$locbase i688               ; get offset to local __ptr bool
 sb $r182 $r181 i0                       ; store byte
 sb $r182 $r179 i0                       ; store byte
addi $r183 $$locbase i688               ; get offset to local __ptr bool
lb $r184 $r183 i0                       ; load byte
jnzi $r184 .36
ji  .35
.35
addi $r185 $$locbase i608               ; get offset to local __ptr u64
addi $r186 $$locbase i1088              ; get offset to local __ptr u64
mcpi $r186 $r185 i8                     ; copy memory
addi $r187 $$locbase i832               ; get offset to local __ptr u64
movi $r188 i23                          ; initialize constant into register
sw $$locbase $r188 i104                 ; store word
addi $r189 $$locbase i1088              ; get offset to local __ptr u64
lw $r190 $$locbase i136                 ; load word
addi $r191 $$locbase i832               ; get offset to local __ptr u64
lw $r192 $$locbase i104                 ; load word
eq $r193 $r190 $r192
jnzi $r193 .37
ji  .38
.37
addi $r194 $$locbase i632               ; get offset to local __ptr ptr
lw $r195 $$locbase i79                  ; load word
addi $r196 $$locbase i656               ; get offset to local __ptr ptr
lw $r197 $$locbase i82                  ; load word
movi $r199 i23                          ; initialize constant into register
addi $r198 $r197 i269
meq $r198 $r195 $r198 $r199
move $r200 $r198                        ; return value from ASM block with return register r
addi $r201 $$locbase i696               ; get offset to local __ptr bool
 sb $r201 $r200 i0                       ; store byte
 sb $r201 $r198 i0                       ; store byte
addi $r202 $$locbase i696               ; get offset to local __ptr bool
lb $r203 $r202 i0                       ; load byte
jnzi $r203 .39
ji  .38
.38
addi $r204 $$locbase i608               ; get offset to local __ptr u64
addi $r205 $$locbase i1096              ; get offset to local __ptr u64
mcpi $r205 $r204 i8                     ; copy memory
addi $r206 $$locbase i840               ; get offset to local __ptr u64
movi $r207 i24                          ; initialize constant into register
sw $$locbase $r207 i105                 ; store word
addi $r208 $$locbase i1096              ; get offset to local __ptr u64
lw $r209 $$locbase i137                 ; load word
addi $r210 $$locbase i840               ; get offset to local __ptr u64
lw $r211 $$locbase i105                 ; load word
eq $r212 $r209 $r211
jnzi $r212 .40
ji  .41
.40
addi $r213 $$locbase i632               ; get offset to local __ptr ptr
lw $r214 $$locbase i79                  ; load word
addi $r215 $$locbase i656               ; get offset to local __ptr ptr
lw $r216 $$locbase i82                  ; load word
movi $r218 i24                          ; initialize constant into register
addi $r217 $r216 i389
meq $r217 $r214 $r217 $r218
move $r219 $r217                        ; return value from ASM block with return register r
addi $r220 $$locbase i704               ; get offset to local __ptr bool
 sb $r220 $r219 i0                       ; store byte
 sb $r220 $r217 i0                       ; store byte
addi $r221 $$locbase i704               ; get offset to local __ptr bool
lb $r222 $r221 i0                       ; load byte
jnzi $r222 .42
ji  .41
.41
addi $r223 $$locbase i608               ; get offset to local __ptr u64
addi $r224 $$locbase i1104              ; get offset to local __ptr u64
mcpi $r224 $r223 i8                     ; copy memory
addi $r225 $$locbase i848               ; get offset to local __ptr u64
movi $r226 i25                          ; initialize constant into register
sw $$locbase $r226 i106                 ; store word
addi $r227 $$locbase i1104              ; get offset to local __ptr u64
lw $r228 $$locbase i138                 ; load word
addi $r229 $$locbase i848               ; get offset to local __ptr u64
lw $r230 $$locbase i106                 ; load word
eq $r231 $r228 $r230
jnzi $r231 .43
ji  .44
.43
addi $r232 $$locbase i632               ; get offset to local __ptr ptr
lw $r233 $$locbase i79                  ; load word
addi $r234 $$locbase i656               ; get offset to local __ptr ptr
lw $r235 $$locbase i82                  ; load word
movi $r237 i25                          ; initialize constant into register
addi $r236 $r235 i31
meq $r236 $r233 $r236 $r237
move $r238 $r236                        ; return value from ASM block with return register r
addi $r239 $$locbase i712               ; get offset to local __ptr bool
 sb $r239 $r238 i0                       ; store byte
 sb $r239 $r236 i0                       ; store byte
addi $r240 $$locbase i712               ; get offset to local __ptr bool
lb $r241 $r240 i0                       ; load byte
jnzi $r241 .45
ji  .44
.44
addi $r242 $$locbase i608               ; get offset to local __ptr u64
addi $r243 $$locbase i1112              ; get offset to local __ptr u64
mcpi $r243 $r242 i8                     ; copy memory
addi $r244 $$locbase i856               ; get offset to local __ptr u64
movi $r245 i31                          ; initialize constant into register
sw $$locbase $r245 i107                 ; store word
addi $r246 $$locbase i1112              ; get offset to local __ptr u64
lw $r247 $$locbase i139                 ; load word
addi $r248 $$locbase i856               ; get offset to local __ptr u64
lw $r249 $$locbase i107                 ; load word
eq $r250 $r247 $r249
jnzi $r250 .46
ji  .47
.46
addi $r251 $$locbase i632               ; get offset to local __ptr ptr
lw $r252 $$locbase i79                  ; load word
addi $r253 $$locbase i656               ; get offset to local __ptr ptr
lw $r254 $$locbase i82                  ; load word
movi $r256 i31                          ; initialize constant into register
addi $r255 $r254 i0
meq $r255 $r252 $r255 $r256
move $r257 $r255                        ; return value from ASM block with return register r
addi $r258 $$locbase i720               ; get offset to local __ptr bool
 sb $r258 $r257 i0                       ; store byte
 sb $r258 $r255 i0                       ; store byte
addi $r259 $$locbase i720               ; get offset to local __ptr bool
lb $r260 $r259 i0                       ; load byte
jnzi $r260 .48
ji  .47
.47
addi $r261 $$locbase i608               ; get offset to local __ptr u64
addi $r262 $$locbase i1000              ; get offset to local __ptr u64
mcpi $r262 $r261 i8                     ; copy memory
addi $r263 $$locbase i864               ; get offset to local __ptr u64
movi $r264 i34                          ; initialize constant into register
sw $$locbase $r264 i108                 ; store word
addi $r265 $$locbase i1000              ; get offset to local __ptr u64
lw $r266 $$locbase i125                 ; load word
addi $r267 $$locbase i864               ; get offset to local __ptr u64
lw $r268 $$locbase i108                 ; load word
eq $r269 $r266 $r268
jnzi $r269 .49
ji  .50
.49
addi $r270 $$locbase i632               ; get offset to local __ptr ptr
lw $r271 $$locbase i79                  ; load word
addi $r272 $$locbase i656               ; get offset to local __ptr ptr
lw $r273 $$locbase i82                  ; load word
movi $r275 i34                          ; initialize constant into register
addi $r274 $r273 i144
meq $r274 $r271 $r274 $r275
move $r276 $r274                        ; return value from ASM block with return register r
addi $r277 $$locbase i728               ; get offset to local __ptr bool
 sb $r277 $r276 i0                       ; store byte
 sb $r277 $r274 i0                       ; store byte
addi $r278 $$locbase i728               ; get offset to local __ptr bool
lb $r279 $r278 i0                       ; load byte
jnzi $r279 .51
ji  .50
.50
addi $r280 $$locbase i608               ; get offset to local __ptr u64
addi $r281 $$locbase i1008              ; get offset to local __ptr u64
mcpi $r281 $r280 i8                     ; copy memory
addi $r282 $$locbase i872               ; get offset to local __ptr u64
movi $r283 i37                          ; initialize constant into register
sw $$locbase $r283 i109                 ; store word
addi $r284 $$locbase i1008              ; get offset to local __ptr u64
lw $r285 $$locbase i126                 ; load word
addi $r286 $$locbase i872               ; get offset to local __ptr u64
lw $r287 $$locbase i109                 ; load word
eq $r288 $r285 $r287
jnzi $r288 .52
ji  .53
.52
addi $r289 $$locbase i632               ; get offset to local __ptr ptr
lw $r290 $$locbase i79                  ; load word
addi $r291 $$locbase i656               ; get offset to local __ptr ptr
lw $r292 $$locbase i82                  ; load word
movi $r294 i37                          ; initialize constant into register
addi $r293 $r292 i352
meq $r293 $r290 $r293 $r294
move $r295 $r293                        ; return value from ASM block with return register r
addi $r296 $$locbase i736               ; get offset to local __ptr bool
 sb $r296 $r295 i0                       ; store byte
 sb $r296 $r293 i0                       ; store byte
addi $r297 $$locbase i736               ; get offset to local __ptr bool
lb $r298 $r297 i0                       ; load byte
jnzi $r298 .54
ji  .53
.53
addi $r299 $$locbase i608               ; get offset to local __ptr u64
addi $r300 $$locbase i1016              ; get offset to local __ptr u64
mcpi $r300 $r299 i8                     ; copy memory
addi $r301 $$locbase i880               ; get offset to local __ptr u64
movi $r302 i39                          ; initialize constant into register
sw $$locbase $r302 i110                 ; store word
addi $r303 $$locbase i1016              ; get offset to local __ptr u64
lw $r304 $$locbase i127                 ; load word
addi $r305 $$locbase i880               ; get offset to local __ptr u64
lw $r306 $$locbase i110                 ; load word
eq $r307 $r304 $r306
jnzi $r307 .55
ji  .56
.55
addi $r308 $$locbase i632               ; get offset to local __ptr ptr
lw $r309 $$locbase i79                  ; load word
addi $r310 $$locbase i656               ; get offset to local __ptr ptr
lw $r311 $$locbase i82                  ; load word
movi $r313 i39                          ; initialize constant into register
addi $r312 $r311 i56
meq $r312 $r309 $r312 $r313
move $r314 $r312                        ; return value from ASM block with return register r
addi $r315 $$locbase i744               ; get offset to local __ptr bool
 sb $r315 $r314 i0                       ; store byte
 sb $r315 $r312 i0                       ; store byte
addi $r316 $$locbase i744               ; get offset to local __ptr bool
lb $r317 $r316 i0                       ; load byte
jnzi $r317 .57
ji  .56
.56
addi $r318 $$locbase i608               ; get offset to local __ptr u64
addi $r319 $$locbase i1024              ; get offset to local __ptr u64
mcpi $r319 $r318 i8                     ; copy memory
addi $r320 $$locbase i888               ; get offset to local __ptr u64
movi $r321 i40                          ; initialize constant into register
sw $$locbase $r321 i111                 ; store word
addi $r322 $$locbase i1024              ; get offset to local __ptr u64
lw $r323 $$locbase i128                 ; load word
addi $r324 $$locbase i888               ; get offset to local __ptr u64
lw $r325 $$locbase i111                 ; load word
eq $r326 $r323 $r325
jnzi $r326 .58
ji  .59
.58
addi $r327 $$locbase i632               ; get offset to local __ptr ptr
lw $r328 $$locbase i79                  ; load word
addi $r329 $$locbase i656               ; get offset to local __ptr ptr
lw $r330 $$locbase i82                  ; load word
movi $r332 i40                          ; initialize constant into register
addi $r331 $r330 i292
meq $r331 $r328 $r331 $r332
move $r333 $r331                        ; return value from ASM block with return register r
addi $r334 $$locbase i752               ; get offset to local __ptr bool
 sb $r334 $r333 i0                       ; store byte
 sb $r334 $r331 i0                       ; store byte
addi $r335 $$locbase i752               ; get offset to local __ptr bool
lb $r336 $r335 i0                       ; load byte
jnzi $r336 .60
ji  .59
.59
addi $r337 $$locbase i608               ; get offset to local __ptr u64
addi $r338 $$locbase i1032              ; get offset to local __ptr u64
mcpi $r338 $r337 i8                     ; copy memory
addi $r339 $$locbase i808               ; get offset to local __ptr u64
movi $r340 i41                          ; initialize constant into register
sw $$locbase $r340 i101                 ; store word
addi $r341 $$locbase i1032              ; get offset to local __ptr u64
lw $r342 $$locbase i129                 ; load word
addi $r343 $$locbase i808               ; get offset to local __ptr u64
lw $r344 $$locbase i101                 ; load word
eq $r345 $r342 $r344
jnzi $r345 .61
ji  .62
.61
addi $r346 $$locbase i632               ; get offset to local __ptr ptr
lw $r347 $$locbase i79                  ; load word
addi $r348 $$locbase i656               ; get offset to local __ptr ptr
lw $r349 $$locbase i82                  ; load word
movi $r351 i41                          ; initialize constant into register
addi $r350 $r349 i413
meq $r350 $r347 $r350 $r351
move $r352 $r350                        ; return value from ASM block with return register r
addi $r353 $$locbase i760               ; get offset to local __ptr bool
 sb $r353 $r352 i0                       ; store byte
 sb $r353 $r350 i0                       ; store byte
addi $r354 $$locbase i760               ; get offset to local __ptr bool
lb $r355 $r354 i0                       ; load byte
jnzi $r355 .63
ji  .62
.62
addi $r356 $$locbase i608               ; get offset to local __ptr u64
addi $r357 $$locbase i1040              ; get offset to local __ptr u64
mcpi $r357 $r356 i8                     ; copy memory
addi $r358 $$locbase i816               ; get offset to local __ptr u64
movi $r359 i49                          ; initialize constant into register
sw $$locbase $r359 i102                 ; store word
addi $r360 $$locbase i1040              ; get offset to local __ptr u64
lw $r361 $$locbase i130                 ; load word
addi $r362 $$locbase i816               ; get offset to local __ptr u64
lw $r363 $$locbase i102                 ; load word
eq $r364 $r361 $r363
jnzi $r364 .64
ji  .65
.64
addi $r365 $$locbase i632               ; get offset to local __ptr ptr
lw $r366 $$locbase i79                  ; load word
addi $r367 $$locbase i656               ; get offset to local __ptr ptr
lw $r368 $$locbase i82                  ; load word
movi $r370 i49                          ; initialize constant into register
addi $r369 $r368 i95
meq $r369 $r366 $r369 $r370
move $r371 $r369                        ; return value from ASM block with return register r
addi $r372 $$locbase i768               ; get offset to local __ptr bool
 sb $r372 $r371 i0                       ; store byte
 sb $r372 $r369 i0                       ; store byte
addi $r373 $$locbase i768               ; get offset to local __ptr bool
lb $r374 $r373 i0                       ; load byte
jnzi $r374 .66
ji  .65
.65
addi $r375 $$locbase i608               ; get offset to local __ptr u64
addi $r376 $$locbase i1048              ; get offset to local __ptr u64
mcpi $r376 $r375 i8                     ; copy memory
addi $r377 $$locbase i824               ; get offset to local __ptr u64
movi $r378 i69                          ; initialize constant into register
sw $$locbase $r378 i103                 ; store word
addi $r379 $$locbase i1048              ; get offset to local __ptr u64
lw $r380 $$locbase i131                 ; load word
addi $r381 $$locbase i824               ; get offset to local __ptr u64
lw $r382 $$locbase i103                 ; load word
eq $r383 $r380 $r382
jnzi $r383 .67
ji  .68
.67
addi $r384 $$locbase i632               ; get offset to local __ptr ptr
lw $r385 $$locbase i79                  ; load word
addi $r386 $$locbase i656               ; get offset to local __ptr ptr
lw $r387 $$locbase i82                  ; load word
movi $r389 i69                          ; initialize constant into register
addi $r388 $r387 i178
meq $r388 $r385 $r388 $r389
move $r390 $r388                        ; return value from ASM block with return register r
addi $r391 $$locbase i776               ; get offset to local __ptr bool
 sb $r391 $r390 i0                       ; store byte
 sb $r391 $r388 i0                       ; store byte
addi $r392 $$locbase i776               ; get offset to local __ptr bool
lb $r393 $r392 i0                       ; load byte
jnzi $r393 .69
ji  .68
.68
movi $r394 i123                         ; initialize constant into register
rvrt $r394
.69
addi $r395 $$locbase i360               ; get offset to local __ptr u64
movi $r396 i28                          ; initialize constant into register
sw $$locbase $r396 i45                  ; store word
addi $r397 $$locbase i200               ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
sw $$locbase $one i25                   ; store word
addi $r398 $r397 i55                    ; get offset to aggregate element
movi $r399 i42                          ; initialize constant into register
sb $r398 $r399 i0                       ; store byte
movi $r400 i28                          ; initialize constant into register
movi $r401 i11                          ; initialize constant into register
sll $r402 $r400 $r401
movi $r403 i27                          ; initialize constant into register
or $r404 $r402 $r403
addi $r405 $$locbase i1184              ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
mcpi $r405 $r397 i56                    ; copy memory
addi $r406 $$locbase i336               ; get offset to local __ptr u64
sw $$locbase $r404 i42                  ; store word
addi $r407 $$locbase i1184              ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
addi $r408 $$locbase i512               ; get offset to local __ptr slice
move $$arg0 $r407                       ; [call]: pass argument 0
move $$arg1 $r408                       ; [call]: pass argument 1
fncall .6                               ; [call]: call encode_allow_alias_12
 move $r409 $zero                        ; [call]: return unit value
 movi $r409 i0                           ; [call]: return unit value
addi $r410 $$locbase i464               ; get offset to local __ptr slice
mcpi $r410 $r408 i16                    ; copy memory
load $r411 data_NonConfigurable_1       ; load constant from data section
lw $r412 $$locbase i58                  ; load slice pointer for logging data
lw $r413 $$locbase i59                  ; load slice size for logging data
logd $zero $r411 $r412 $r413            ; log slice
load $r414 data_NonConfigurable_2       ; load constant from data section
and $r415 $r404 $r414
load $r416 data_NonConfigurable_3       ; load constant from data section
or $r417 $r416 $r415
rvrt $r417
.66
addi $r418 $$locbase i352               ; get offset to local __ptr u64
movi $r419 i26                          ; initialize constant into register
sw $$locbase $r419 i44                  ; store word
addr $r420 data_NonConfigurable_4       ; get __const_global7's address in data section
addi $r421 $$locbase i184               ; get offset to local __ptr { ptr, u64 }
sw $$locbase $r420 i23                  ; store word
addi $r422 $r421 i8                     ; get offset to aggregate element
movi $r423 i35                          ; initialize constant into register
sw $$locbase $r423 i24                  ; store word
addi $r424 $$locbase i288               ; get offset to local __ptr slice
mcpi $r424 $r421 i16                    ; copy memory
movi $r425 i26                          ; initialize constant into register
movi $r426 i11                          ; initialize constant into register
sll $r427 $r425 $r426
movi $r428 i25                          ; initialize constant into register
or $r429 $r427 $r428
addi $r430 $$locbase i552               ; get offset to local __ptr slice
mcpi $r430 $r424 i16                    ; copy memory
move $$arg0 $r430                       ; [call]: pass argument 0
move $$arg1 $r429                       ; [call]: pass argument 1
fncall .16                              ; [call]: call generic_panic_41
 move $r431 $zero                        ; [call]: return unit value
 movi $r431 i0                           ; [call]: return unit value
addi $r432 $$locbase i664               ; get offset to local __ptr ()
 move $r433 $zero                        ; return value from ASM block with return register zero
 retd $r433 $zero
 movi $r433 i0                           ; return value from ASM block with return register zero
 retd $zero $zero
.63
addi $r434 $$locbase i424               ; get offset to local __ptr u64
movi $r435 i24                          ; initialize constant into register
sw $$locbase $r435 i53                  ; store word
movi $r436 i24                          ; initialize constant into register
movi $r437 i11                          ; initialize constant into register
sll $r438 $r436 $r437
movi $r439 i23                          ; initialize constant into register
or $r440 $r438 $r439
move $$arg0 $r440                       ; [call]: pass argument 0
fncall .20                              ; [call]: call call_nested_panic_non_inlined_48
 move $r441 $zero                        ; [call]: return unit value
 movi $r441 i0                           ; [call]: return unit value
addi $r442 $$locbase i664               ; get offset to local __ptr ()
 move $r443 $zero                        ; return value from ASM block with return register zero
 retd $r443 $zero
 movi $r443 i0                           ; return value from ASM block with return register zero
 retd $zero $zero
.60
addi $r444 $$locbase i416               ; get offset to local __ptr u64
movi $r445 i22                          ; initialize constant into register
sw $$locbase $r445 i52                  ; store word
movi $r446 i22                          ; initialize constant into register
movi $r447 i11                          ; initialize constant into register
sll $r448 $r446 $r447
movi $r449 i21                          ; initialize constant into register
or $r450 $r448 $r449
 move $$arg0 $zero                       ; [call]: pass argument 0
 movi $$arg0 i0                          ; [call]: pass argument 0
move $$arg1 $r450                       ; [call]: pass argument 1
fncall .18                              ; [call]: call generic_panic_44
 move $r451 $zero                        ; [call]: return unit value
 movi $r451 i0                           ; [call]: return unit value
addi $r452 $$locbase i664               ; get offset to local __ptr ()
 move $r453 $zero                        ; return value from ASM block with return register zero
 retd $r453 $zero
 movi $r453 i0                           ; return value from ASM block with return register zero
 retd $zero $zero
.57
addi $r454 $$locbase i408               ; get offset to local __ptr u64
movi $r455 i20                          ; initialize constant into register
sw $$locbase $r455 i51                  ; store word
movi $r456 i20                          ; initialize constant into register
movi $r457 i11                          ; initialize constant into register
sll $r458 $r456 $r457
movi $r459 i17                          ; initialize constant into register
or $r460 $r458 $r459
addi $r461 $$locbase i328               ; get offset to local __ptr u64
sw $$locbase $r460 i41                  ; store word
load $r462 data_NonConfigurable_2       ; load constant from data section
and $r463 $r460 $r462
load $r464 data_NonConfigurable_5       ; load constant from data section
or $r465 $r464 $r463
rvrt $r465
.54
addi $r466 $$locbase i400               ; get offset to local __ptr u64
movi $r467 i16                          ; initialize constant into register
sw $$locbase $r467 i50                  ; store word
movi $r468 i16                          ; initialize constant into register
movi $r469 i11                          ; initialize constant into register
sll $r470 $r468 $r469
movi $r471 i15                          ; initialize constant into register
or $r472 $r470 $r471
move $$arg0 $r472                       ; [call]: pass argument 0
fncall .4                               ; [call]: call call_nested_panic_inlined_10
 move $r473 $zero                        ; [call]: return unit value
 movi $r473 i0                           ; [call]: return unit value
addi $r474 $$locbase i664               ; get offset to local __ptr ()
 move $r475 $zero                        ; return value from ASM block with return register zero
 retd $r475 $zero
 movi $r475 i0                           ; return value from ASM block with return register zero
 retd $zero $zero
.51
addi $r476 $$locbase i392               ; get offset to local __ptr u64
movi $r477 i14                          ; initialize constant into register
sw $$locbase $r477 i49                  ; store word
addi $r478 $$locbase i128               ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
sw $$locbase $zero i16                  ; store word
movi $r479 i14                          ; initialize constant into register
movi $r480 i11                          ; initialize constant into register
sll $r481 $r479 $r480
movi $r482 i13                          ; initialize constant into register
or $r483 $r481 $r482
addi $r484 $$locbase i1128              ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
mcpi $r484 $r478 i56                    ; copy memory
addi $r485 $$locbase i320               ; get offset to local __ptr u64
sw $$locbase $r483 i40                  ; store word
addi $r486 $$locbase i1128              ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
addi $r487 $$locbase i496               ; get offset to local __ptr slice
move $$arg0 $r486                       ; [call]: pass argument 0
move $$arg1 $r487                       ; [call]: pass argument 1
fncall .6                               ; [call]: call encode_allow_alias_12
 move $r488 $zero                        ; [call]: return unit value
 movi $r488 i0                           ; [call]: return unit value
addi $r489 $$locbase i448               ; get offset to local __ptr slice
mcpi $r489 $r487 i16                    ; copy memory
load $r490 data_NonConfigurable_1       ; load constant from data section
lw $r491 $$locbase i56                  ; load slice pointer for logging data
lw $r492 $$locbase i57                  ; load slice size for logging data
logd $zero $r490 $r491 $r492            ; log slice
load $r493 data_NonConfigurable_2       ; load constant from data section
and $r494 $r483 $r493
load $r495 data_NonConfigurable_3       ; load constant from data section
or $r496 $r495 $r494
rvrt $r496
.48
addi $r497 $$locbase i384               ; get offset to local __ptr u64
movi $r498 i12                          ; initialize constant into register
sw $$locbase $r498 i48                  ; store word
movi $r499 i12                          ; initialize constant into register
load $r500 data_NonConfigurable_2       ; load constant from data section
and $r501 $r499 $r500
load $r502 data_NonConfigurable_6       ; load constant from data section
or $r503 $r502 $r501
rvrt $r503
.45
addi $r504 $$locbase i376               ; get offset to local __ptr u64
movi $r505 i11                          ; initialize constant into register
sw $$locbase $r505 i47                  ; store word
addi $r506 $$locbase i72                ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
movi $r507 i2                           ; initialize constant into register
sw $$locbase $r507 i9                   ; store word
addi $r508 $r506 i55                    ; get offset to aggregate element
sb $r508 $one i0                        ; store byte
addi $r509 $$locbase i480               ; get offset to local __ptr slice
move $$arg0 $r506                       ; [call]: pass argument 0
move $$arg1 $r509                       ; [call]: pass argument 1
fncall .6                               ; [call]: call encode_allow_alias_12
 move $r510 $zero                        ; [call]: return unit value
 movi $r510 i0                           ; [call]: return unit value
addi $r511 $$locbase i432               ; get offset to local __ptr slice
mcpi $r511 $r509 i16                    ; copy memory
load $r512 data_NonConfigurable_1       ; load constant from data section
lw $r513 $$locbase i54                  ; load slice pointer for logging data
lw $r514 $$locbase i55                  ; load slice size for logging data
logd $zero $r512 $r513 $r514            ; log slice
movi $r515 i11                          ; initialize constant into register
load $r516 data_NonConfigurable_2       ; load constant from data section
and $r517 $r515 $r516
load $r518 data_NonConfigurable_7       ; load constant from data section
or $r519 $r518 $r517
rvrt $r519
.42
addi $r520 $$locbase i368               ; get offset to local __ptr u64
movi $r521 i10                          ; initialize constant into register
sw $$locbase $r521 i46                  ; store word
movi $r522 i10                          ; initialize constant into register
movi $r523 i11                          ; initialize constant into register
sll $r524 $r522 $r523
movi $r525 i9                           ; initialize constant into register
or $r526 $r524 $r525
move $$arg0 $r526                       ; [call]: pass argument 0
fncall .20                              ; [call]: call call_nested_panic_non_inlined_48
 move $r527 $zero                        ; [call]: return unit value
 movi $r527 i0                           ; [call]: return unit value
addi $r528 $$locbase i664               ; get offset to local __ptr ()
 move $r529 $zero                        ; return value from ASM block with return register zero
 retd $r529 $zero
 movi $r529 i0                           ; return value from ASM block with return register zero
 retd $zero $zero
.39
addi $r530 $$locbase i344               ; get offset to local __ptr u64
movi $r531 i7                           ; initialize constant into register
sw $$locbase $r531 i43                  ; store word
movi $r532 i7                           ; initialize constant into register
movi $r533 i11                          ; initialize constant into register
sll $r534 $r532 $r533
movi $r535 i6                           ; initialize constant into register
or $r536 $r534 $r535
 move $$arg0 $zero                       ; [call]: pass argument 0
 movi $$arg0 i0                          ; [call]: pass argument 0
move $$arg1 $r536                       ; [call]: pass argument 1
fncall .18                              ; [call]: call generic_panic_44
 move $r537 $zero                        ; [call]: return unit value
 movi $r537 i0                           ; [call]: return unit value
addi $r538 $$locbase i664               ; get offset to local __ptr ()
 move $r539 $zero                        ; return value from ASM block with return register zero
 retd $r539 $zero
 movi $r539 i0                           ; return value from ASM block with return register zero
 retd $zero $zero
.36
addi $r540 $$locbase i312               ; get offset to local __ptr u64
movi $r541 i5                           ; initialize constant into register
sw $$locbase $r541 i39                  ; store word
addr $r542 data_NonConfigurable_8       ; get __const_global3's address in data section
addi $r543 $$locbase i56                ; get offset to local __ptr { ptr, u64 }
sw $$locbase $r542 i7                   ; store word
addi $r544 $r543 i8                     ; get offset to aggregate element
movi $r545 i25                          ; initialize constant into register
sw $$locbase $r545 i8                   ; store word
addi $r546 $$locbase i272               ; get offset to local __ptr slice
mcpi $r546 $r543 i16                    ; copy memory
movi $r547 i5                           ; initialize constant into register
movi $r548 i11                          ; initialize constant into register
sll $r549 $r547 $r548
movi $r550 i4                           ; initialize constant into register
or $r551 $r549 $r550
addi $r552 $$locbase i536               ; get offset to local __ptr slice
mcpi $r552 $r546 i16                    ; copy memory
move $$arg0 $r552                       ; [call]: pass argument 0
move $$arg1 $r551                       ; [call]: pass argument 1
fncall .16                              ; [call]: call generic_panic_41
 move $r553 $zero                        ; [call]: return unit value
 movi $r553 i0                           ; [call]: return unit value
addi $r554 $$locbase i664               ; get offset to local __ptr ()
 move $r555 $zero                        ; return value from ASM block with return register zero
 retd $r555 $zero
 movi $r555 i0                           ; return value from ASM block with return register zero
 retd $zero $zero
.33
addi $r556 $$locbase i304               ; get offset to local __ptr u64
movi $r557 i3                           ; initialize constant into register
sw $$locbase $r557 i38                  ; store word
movi $r558 i3                           ; initialize constant into register
movi $r559 i11                          ; initialize constant into register
sll $r560 $r558 $r559
movi $r561 i2                           ; initialize constant into register
or $r562 $r560 $r561
move $$arg0 $r562                       ; [call]: pass argument 0
fncall .4                               ; [call]: call call_nested_panic_inlined_10
 move $r563 $zero                        ; [call]: return unit value
 movi $r563 i0                           ; [call]: return unit value
addi $r564 $$locbase i664               ; get offset to local __ptr ()
 move $r565 $zero                        ; return value from ASM block with return register zero
 retd $r565 $zero
 movi $r565 i0                           ; return value from ASM block with return register zero
 retd $zero $zero
DIFF------------------------------
.program:
.2                                      ; --- start of function: read_3 ---
pusha .2                                ; save all registers
move $$locbase $sp                      ; save locals base register for function read_3
cfei i24                                ; allocate 24 bytes for locals and 0 slots for call arguments
.70
addi $r567 $$locbase i8                 ; get offset to local __ptr ptr
sw $$locbase $$arg0 i1                  ; store word
 jnzi $zero .71
 
ji  .72
.72
addi $r568 $$locbase i16                ; get offset to local __ptr u64
movi $r569 i8                           ; initialize constant into register
sw $$locbase $r569 i2                   ; store word
sw $$locbase $one i0                    ; store word
addi $r570 $$locbase i16                ; get offset to local __ptr u64
lw $r571 $$locbase i2                   ; load word
lw $r572 $$locbase i0                   ; load word
eq $r573 $r571 $r572
jnzi $r573 .73
ji  .74
.74
addi $r574 $$locbase i8                 ; get offset to local __ptr ptr
lw $r575 $$locbase i1                   ; load word
lw $r576 $r575 i0                       ; lw val ptr i0
move $r577 $r576                        ; return value from ASM block with return register val
 move $r578 $r577                        ; move parameter from branch to block argument
 move $r578 $r576                        ; move parameter from branch to block argument
ji  .75
.73
addi $r579 $$locbase i8                 ; get offset to local __ptr ptr
lw $r580 $$locbase i1                   ; load word
lb $r581 $r580 i0                       ; lb val ptr i0
move $r582 $r581                        ; return value from ASM block with return register val
 move $r578 $r582                        ; move parameter from branch to block argument
 move $r578 $r581                        ; move parameter from branch to block argument
ji  .75
.75
move $r585 $r578                        ; move parameter from branch to block argument
 move $r586 $r585                        ; move parameter from branch to block argument
 move $r586 $r578                        ; move parameter from branch to block argument
ji  .76
.71
addi $r587 $$locbase i8                 ; get offset to local __ptr ptr
lw $r588 $$locbase i1                   ; load word
move $r589 $r588                        ; return value from ASM block with return register ptr
 move $r586 $r589                        ; move parameter from branch to block argument
 move $r586 $r588                        ; move parameter from branch to block argument
ji  .76
.76
move $r592 $r586                        ; move parameter from branch to block argument
 move $$retv $r592                       ; set return value
 move $$retv $r586                       ; set return value
ji  .3
.3
cfsi i24                                ; free 24 bytes for locals and 0 slots for extra call arguments
popa .2                                 ; restore all registers
jal $zero $$reta i0                     ; return from call
DIFF------------------------------
.program:
.4                                      ; --- start of function: call_nested_panic_inlined_10 ---
pusha .4                                ; save all registers
move $$locbase $sp                      ; save locals base register for function call_nested_panic_inlined_10
cfei i288                               ; allocate 288 bytes for locals and 0 slots for call arguments
move $r593 $$arg0                       ; save argument 0 (__backtrace)
move $r594 $$reta                       ; save return address
.77
movi $r595 i4                           ; initialize constant into register
sw $$locbase $r595 i0                   ; store word
addi $r596 $$locbase i152               ; get offset to local __ptr [slice; 3]
addr $r597 data_NonConfigurable_9       ; get __const_global0's address in data section
addi $r598 $$locbase i56                ; get offset to local __ptr { ptr, u64 }
sw $$locbase $r597 i7                   ; store word
addi $r599 $r598 i8                     ; get offset to aggregate element
movi $r600 i7                           ; initialize constant into register
sw $$locbase $r600 i8                   ; store word
addi $r601 $$locbase i72                ; get offset to local __ptr slice
mcpi $r601 $r598 i16                    ; copy memory
addr $r602 data_NonConfigurable_10      ; get __const_global1's address in data section
addi $r603 $$locbase i88                ; get offset to local __ptr { ptr, u64 }
sw $$locbase $r602 i11                  ; store word
addi $r604 $r603 i8                     ; get offset to aggregate element
movi $r605 i7                           ; initialize constant into register
sw $$locbase $r605 i12                  ; store word
addi $r606 $$locbase i104               ; get offset to local __ptr slice
mcpi $r606 $r603 i16                    ; copy memory
addr $r607 data_NonConfigurable_11      ; get __const_global2's address in data section
addi $r608 $$locbase i120               ; get offset to local __ptr { ptr, u64 }
sw $$locbase $r607 i15                  ; store word
addi $r609 $r608 i8                     ; get offset to aggregate element
movi $r610 i22                          ; initialize constant into register
sw $$locbase $r610 i16                  ; store word
addi $r611 $$locbase i136               ; get offset to local __ptr slice
mcpi $r611 $r608 i16                    ; copy memory
movi $r612 i16                          ; get array element size
 mul $r613 $zero $r612                   ; get offset to array element
 add $r613 $r596 $r613                   ; add array element offset to array base
 movi $r613 i0                           ; get offset to array element
 add $r613 $r596 $zero                   ; add array element offset to array base
mcpi $r613 $r601 i16                    ; copy memory
movi $r614 i16                          ; get array element size
 mul $r615 $one $r614                    ; get offset to array element
 movi $r615 i16                          ; get offset to array element
add $r615 $r596 $r615                   ; add array element offset to array base
mcpi $r615 $r606 i16                    ; copy memory
movi $r616 i16                          ; get array element size
movi $r617 i2                           ; initialize constant into register
 mul $r618 $r617 $r616                   ; get offset to array element
 movi $r618 i32                          ; get offset to array element
add $r618 $r596 $r618                   ; add array element offset to array base
mcpi $r618 $r611 i16                    ; copy memory
addi $r619 $$locbase i8                 ; get offset to aggregate element
mcpi $r619 $r596 i48                    ; copy memory
movi $r620 i11                          ; initialize constant into register
sll $r621 $r593 $r620
or $r622 $r621 $one
addi $r623 $$locbase i232               ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
mcpi $r623 $$locbase i56                ; copy memory
addi $r624 $$locbase i232               ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
addi $r625 $$locbase i216               ; get offset to local __ptr slice
move $$arg0 $r624                       ; [call]: pass argument 0
move $$arg1 $r625                       ; [call]: pass argument 1
fncall .6                               ; [call]: call encode_allow_alias_12
 move $r626 $zero                        ; [call]: return unit value
 movi $r626 i0                           ; [call]: return unit value
addi $r627 $$locbase i200               ; get offset to local __ptr slice
mcpi $r627 $r625 i16                    ; copy memory
load $r628 data_NonConfigurable_1       ; load constant from data section
lw $r629 $$locbase i25                  ; load slice pointer for logging data
lw $r630 $$locbase i26                  ; load slice size for logging data
logd $zero $r628 $r629 $r630            ; log slice
load $r631 data_NonConfigurable_2       ; load constant from data section
and $r632 $r622 $r631
load $r633 data_NonConfigurable_12      ; load constant from data section
or $r634 $r633 $r632
rvrt $r634
.5
cfsi i288                               ; free 288 bytes for locals and 0 slots for extra call arguments
move $$reta $r594                       ; restore return address
popa .4                                 ; restore all registers
jal $zero $$reta i0                     ; return from call
DIFF------------------------------
.program:
.6                                      ; --- start of function: encode_allow_alias_12 ---
pusha .6                                ; save all registers
move $$locbase $sp                      ; save locals base register for function encode_allow_alias_12
cfei i1864                              ; allocate 1864 bytes for locals and 0 slots for call arguments
move $r635 $$arg0                       ; save argument 0 (item)
move $r636 $$arg1                       ; save argument 1 (__ret_value)
move $r637 $$reta                       ; save return address
.78
addi $r638 $$locbase i1488              ; get offset to local __ptr __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
 sw $$locbase $r635 i186                 ; store word
 sw $$locbase $$arg0 i186                ; store word
addi $r639 $$locbase i1568              ; get offset to local __ptr u64
load $r640 data_NonConfigurable_13      ; load constant from data section
sw $$locbase $r640 i196                 ; store word
addi $r641 $$locbase i1496              ; get offset to local __ptr u64
sw $$locbase $zero i187                 ; store word
addi $r642 $$locbase i1568              ; get offset to local __ptr u64
lw $r643 $$locbase i196                 ; load word
addi $r644 $$locbase i1496              ; get offset to local __ptr u64
lw $r645 $$locbase i187                 ; load word
eq $r646 $r643 $r645
move $r647 $r646                        ; move parameter from branch to block argument
jnzi $r646 .79
ji  .80
.79
 move $r647 $one                         ; move parameter from branch to block argument
 movi $r647 i1                           ; move parameter from branch to block argument
ji  .80
.80
move $r650 $r647                        ; move parameter from branch to block argument
 move $r651 $r650                        ; move parameter from branch to block argument
 jnzi $r650 .81
 move $r651 $r647                        ; move parameter from branch to block argument
 jnzi $r647 .81
ji  .82
.81
 move $r651 $one                         ; move parameter from branch to block argument
 movi $r651 i1                           ; move parameter from branch to block argument
ji  .82
.82
move $r654 $r651                        ; move parameter from branch to block argument
 move $r655 $r654                        ; move parameter from branch to block argument
 jnzi $r654 .83
 move $r655 $r651                        ; move parameter from branch to block argument
 jnzi $r651 .83
ji  .84
.83
 move $r655 $one                         ; move parameter from branch to block argument
 movi $r655 i1                           ; move parameter from branch to block argument
ji  .84
.84
move $r658 $r655                        ; move parameter from branch to block argument
 move $r659 $r658                        ; move parameter from branch to block argument
 jnzi $r658 .85
 move $r659 $r655                        ; move parameter from branch to block argument
 jnzi $r655 .85
ji  .86
.85
addi $r660 $$locbase i1576              ; get offset to local __ptr u64
load $r661 data_NonConfigurable_14      ; load constant from data section
sw $$locbase $r661 i197                 ; store word
addi $r662 $$locbase i1504              ; get offset to local __ptr u64
load $r663 data_NonConfigurable_14      ; load constant from data section
sw $$locbase $r663 i188                 ; store word
addi $r664 $$locbase i1576              ; get offset to local __ptr u64
lw $r665 $$locbase i197                 ; load word
addi $r666 $$locbase i1504              ; get offset to local __ptr u64
lw $r667 $$locbase i188                 ; load word
eq $r668 $r665 $r667
move $r669 $r668                        ; move parameter from branch to block argument
jnzi $r668 .87
ji  .88
.87
 move $r669 $one                         ; move parameter from branch to block argument
 movi $r669 i1                           ; move parameter from branch to block argument
ji  .88
.88
move $r672 $r669                        ; move parameter from branch to block argument
 move $r673 $r672                        ; move parameter from branch to block argument
 jnzi $r672 .89
 move $r673 $r669                        ; move parameter from branch to block argument
 jnzi $r669 .89
ji  .90
.89
 move $r673 $one                         ; move parameter from branch to block argument
 movi $r673 i1                           ; move parameter from branch to block argument
ji  .90
.90
move $r676 $r673                        ; move parameter from branch to block argument
 move $r659 $r676                        ; move parameter from branch to block argument
 move $r659 $r673                        ; move parameter from branch to block argument
ji  .86
.86
move $r679 $r659                        ; move parameter from branch to block argument
 move $r680 $r679                        ; move parameter from branch to block argument
 jnzi $r679 .91
 move $r680 $r659                        ; move parameter from branch to block argument
 jnzi $r659 .91
ji  .92
.91
 move $r680 $zero                        ; move parameter from branch to block argument
 movi $r680 i0                           ; move parameter from branch to block argument
ji  .92
.92
move $r683 $r680                        ; move parameter from branch to block argument
 jnzi $r683 .93
 jnzi $r680 .93
ji  .94
.94
addi $r684 $$locbase i1488              ; get offset to local __ptr __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
lw $r685 $$locbase i186                 ; load word
addi $r686 $$locbase i456               ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r686                       ; [call]: pass argument 0
fncall .12                              ; [call]: call new_38
 move $r687 $zero                        ; [call]: return unit value
 movi $r687 i0                           ; [call]: return unit value
addi $r688 $$locbase i1600              ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
mcpi $r688 $r685 i56                    ; copy memory
addi $r689 $$locbase i1072              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r689 $r686 i24                    ; copy memory
addi $r690 $$locbase i1600              ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
addi $r691 $$locbase i208               ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
mcpi $r691 $r690 i56                    ; copy memory
addi $r692 $$locbase i208               ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
addi $r693 $$locbase i1584              ; get offset to local __ptr u64
mcpi $r693 $r692 i8                     ; copy memory
addi $r694 $$locbase i1528              ; get offset to local __ptr u64
sw $$locbase $zero i191                 ; store word
addi $r695 $$locbase i1584              ; get offset to local __ptr u64
lw $r696 $$locbase i198                 ; load word
addi $r697 $$locbase i1528              ; get offset to local __ptr u64
lw $r698 $$locbase i191                 ; load word
eq $r699 $r696 $r698
jnzi $r699 .95
ji  .96
.96
addi $r700 $$locbase i208               ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
addi $r701 $$locbase i1656              ; get offset to local __ptr u64
mcpi $r701 $r700 i8                     ; copy memory
addi $r702 $$locbase i1512              ; get offset to local __ptr u64
sw $$locbase $one i189                  ; store word
addi $r703 $$locbase i1656              ; get offset to local __ptr u64
lw $r704 $$locbase i207                 ; load word
addi $r705 $$locbase i1512              ; get offset to local __ptr u64
lw $r706 $$locbase i189                 ; load word
eq $r707 $r704 $r706
jnzi $r707 .97
ji  .98
.98
addi $r708 $$locbase i208               ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
addi $r709 $$locbase i1680              ; get offset to local __ptr u64
mcpi $r709 $r708 i8                     ; copy memory
addi $r710 $$locbase i1536              ; get offset to local __ptr u64
movi $r711 i2                           ; initialize constant into register
sw $$locbase $r711 i192                 ; store word
addi $r712 $$locbase i1680              ; get offset to local __ptr u64
lw $r713 $$locbase i210                 ; load word
addi $r714 $$locbase i1536              ; get offset to local __ptr u64
lw $r715 $$locbase i192                 ; load word
eq $r716 $r713 $r715
jnzi $r716 .99
ji  .100
.100
addi $r717 $$locbase i208               ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
addi $r718 $$locbase i1696              ; get offset to local __ptr u64
mcpi $r718 $r717 i8                     ; copy memory
addi $r719 $$locbase i1544              ; get offset to local __ptr u64
movi $r720 i3                           ; initialize constant into register
sw $$locbase $r720 i193                 ; store word
addi $r721 $$locbase i1696              ; get offset to local __ptr u64
lw $r722 $$locbase i212                 ; load word
addi $r723 $$locbase i1544              ; get offset to local __ptr u64
lw $r724 $$locbase i193                 ; load word
eq $r725 $r722 $r724
jnzi $r725 .101
ji  .102
.102
addi $r726 $$locbase i208               ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
addi $r727 $$locbase i1720              ; get offset to local __ptr u64
mcpi $r727 $r726 i8                     ; copy memory
addi $r728 $$locbase i1552              ; get offset to local __ptr u64
movi $r729 i4                           ; initialize constant into register
sw $$locbase $r729 i194                 ; store word
addi $r730 $$locbase i1720              ; get offset to local __ptr u64
lw $r731 $$locbase i215                 ; load word
addi $r732 $$locbase i1552              ; get offset to local __ptr u64
lw $r733 $$locbase i194                 ; load word
eq $r734 $r731 $r733
jnzi $r734 .103
ji  .104
.104
load $r735 data_NonConfigurable_15      ; load constant from data section
rvrt $r735
.103
addi $r736 $$locbase i208               ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
addi $r737 $r736 i8                     ; get offset to aggregate element
addi $r738 $$locbase i1816              ; get offset to local __ptr [slice; 3]
mcpi $r738 $r737 i48                    ; copy memory
addi $r739 $$locbase i1072              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r740 $$locbase i688               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r740 $r739 i24                    ; copy memory
addi $r741 $$locbase i408               ; get offset to local __ptr { { ptr, u64, u64 } }
movi $r742 i4                           ; initialize constant into register
 move $$arg0 $r742                       ; [call]: pass argument 0
 movi $$arg0 i4                          ; [call]: pass argument 0
move $$arg1 $r740                       ; [call]: pass argument 1
move $$arg2 $r741                       ; [call]: pass argument 2
fncall .8                               ; [call]: call abi_encode_30
 move $r743 $zero                        ; [call]: return unit value
 movi $r743 i0                           ; [call]: return unit value
addi $r744 $$locbase i1408              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r744 $r741 i24                    ; copy memory
addi $r745 $$locbase i1816              ; get offset to local __ptr [slice; 3]
addi $r746 $$locbase i1408              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r747 $$locbase i1728              ; get offset to local __ptr [slice; 3]
mcpi $r747 $r745 i48                    ; copy memory
addi $r748 $$locbase i1168              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r748 $r746 i24                    ; copy memory
addi $r749 $$locbase i1168              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r750 $$locbase i1240              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r750 $r749 i24                    ; copy memory
addi $r751 $$locbase i1480              ; get offset to local __ptr u64
sw $$locbase $zero i185                 ; store word
ji  .105
.105
addi $r752 $$locbase i1480              ; get offset to local __ptr u64
addi $r753 $$locbase i1592              ; get offset to local __ptr u64
mcpi $r753 $r752 i8                     ; copy memory
addi $r754 $$locbase i1560              ; get offset to local __ptr u64
movi $r755 i3                           ; initialize constant into register
sw $$locbase $r755 i195                 ; store word
addi $r756 $$locbase i1592              ; get offset to local __ptr u64
lw $r757 $$locbase i199                 ; load word
addi $r758 $$locbase i1560              ; get offset to local __ptr u64
lw $r759 $$locbase i195                 ; load word
lt $r760 $r757 $r759
jnzi $r760 .106
ji  .107
.107
addi $r761 $$locbase i1240              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r762 $$locbase i848               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r762 $r761 i24                    ; copy memory
addi $r763 $$locbase i1432              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r763 $r762 i24                    ; copy memory
addi $r764 $$locbase i1432              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r765 $$locbase i872               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r765 $r764 i24                    ; copy memory
addi $r766 $$locbase i896               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r766 $r765 i24                    ; copy memory
move $r767 $r766                        ; move parameter from branch to block argument
ji  .108
.106
addi $r768 $$locbase i1728              ; get offset to local __ptr [slice; 3]
addi $r769 $$locbase i1480              ; get offset to local __ptr u64
lw $r770 $$locbase i185                 ; load word
movi $r771 i16                          ; get array element size
mul $r772 $r770 $r771                   ; get offset to array element
add $r772 $r768 $r772                   ; add array element offset to array base
addi $r773 $$locbase i1240              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r774 $$locbase i712               ; get offset to local __ptr slice
mcpi $r774 $r772 i16                    ; copy memory
addi $r775 $$locbase i728               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r775 $r773 i24                    ; copy memory
addi $r776 $$locbase i432               ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r774                       ; [call]: pass argument 0
move $$arg1 $r775                       ; [call]: pass argument 1
move $$arg2 $r776                       ; [call]: pass argument 2
fncall .10                              ; [call]: call abi_encode_36
 move $r777 $zero                        ; [call]: return unit value
 movi $r777 i0                           ; [call]: return unit value
addi $r778 $$locbase i1240              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r778 $r776 i24                    ; copy memory
addi $r779 $$locbase i1480              ; get offset to local __ptr u64
addi $r780 $$locbase i1664              ; get offset to local __ptr u64
mcpi $r780 $r779 i8                     ; copy memory
addi $r781 $$locbase i1520              ; get offset to local __ptr u64
sw $$locbase $one i190                  ; store word
addi $r782 $$locbase i1664              ; get offset to local __ptr u64
lw $r783 $$locbase i208                 ; load word
addi $r784 $$locbase i1520              ; get offset to local __ptr u64
lw $r785 $$locbase i190                 ; load word
add $r786 $r783 $r785
addi $r787 $$locbase i1480              ; get offset to local __ptr u64
sw $$locbase $r786 i185                 ; store word
ji  .105
.101
addi $r788 $$locbase i208               ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
addi $r789 $r788 i40                    ; get offset to aggregate element
addi $r790 $$locbase i1800              ; get offset to local __ptr { u64, u64 }
mcpi $r790 $r789 i16                    ; copy memory
addi $r791 $$locbase i1072              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r792 $$locbase i616               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r792 $r791 i24                    ; copy memory
addi $r793 $$locbase i336               ; get offset to local __ptr { { ptr, u64, u64 } }
movi $r794 i3                           ; initialize constant into register
 move $$arg0 $r794                       ; [call]: pass argument 0
 movi $$arg0 i3                          ; [call]: pass argument 0
move $$arg1 $r792                       ; [call]: pass argument 1
move $$arg2 $r793                       ; [call]: pass argument 2
fncall .8                               ; [call]: call abi_encode_30
 move $r795 $zero                        ; [call]: return unit value
 movi $r795 i0                           ; [call]: return unit value
addi $r796 $$locbase i1360              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r796 $r793 i24                    ; copy memory
addi $r797 $$locbase i1800              ; get offset to local __ptr { u64, u64 }
addi $r798 $$locbase i1360              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r799 $$locbase i1704              ; get offset to local __ptr { u64, u64 }
mcpi $r799 $r797 i16                    ; copy memory
addi $r800 $$locbase i1144              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r800 $r798 i24                    ; copy memory
addi $r801 $$locbase i1704              ; get offset to local __ptr { u64, u64 }
lw $r802 $$locbase i213                 ; load word
addi $r803 $$locbase i1144              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r804 $$locbase i640               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r804 $r803 i24                    ; copy memory
addi $r805 $$locbase i360               ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r802                       ; [call]: pass argument 0
move $$arg1 $r804                       ; [call]: pass argument 1
move $$arg2 $r805                       ; [call]: pass argument 2
fncall .8                               ; [call]: call abi_encode_30
 move $r806 $zero                        ; [call]: return unit value
 movi $r806 i0                           ; [call]: return unit value
addi $r807 $$locbase i1216              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r807 $r805 i24                    ; copy memory
addi $r808 $$locbase i1704              ; get offset to local __ptr { u64, u64 }
addi $r809 $r808 i8                     ; get offset to aggregate element
lw $r810 $$locbase i214                 ; load word
addi $r811 $$locbase i1216              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r812 $$locbase i664               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r812 $r811 i24                    ; copy memory
addi $r813 $$locbase i384               ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r810                       ; [call]: pass argument 0
move $$arg1 $r812                       ; [call]: pass argument 1
move $$arg2 $r813                       ; [call]: pass argument 2
fncall .8                               ; [call]: call abi_encode_30
 move $r814 $zero                        ; [call]: return unit value
 movi $r814 i0                           ; [call]: return unit value
addi $r815 $$locbase i1288              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r815 $r813 i24                    ; copy memory
addi $r816 $$locbase i1288              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r817 $$locbase i824               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r817 $r816 i24                    ; copy memory
addi $r818 $$locbase i1384              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r818 $r817 i24                    ; copy memory
addi $r819 $$locbase i1384              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r820 $$locbase i896               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r820 $r819 i24                    ; copy memory
move $r767 $r820                        ; move parameter from branch to block argument
ji  .108
.108
move $r823 $r767                        ; move parameter from branch to block argument
addi $r824 $$locbase i920               ; get offset to local __ptr { { ptr, u64, u64 } }
 mcpi $r824 $r823 i24                    ; copy memory
 mcpi $r824 $r767 i24                    ; copy memory
move $r825 $r824                        ; move parameter from branch to block argument
ji  .109
.99
addi $r826 $$locbase i208               ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
addi $r827 $r826 i55                    ; get offset to aggregate element
addi $r828 $$locbase i1792              ; get offset to local __ptr bool
mcpi $r828 $r827 i1                     ; copy memory
addi $r829 $$locbase i1072              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r830 $$locbase i592               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r830 $r829 i24                    ; copy memory
addi $r831 $$locbase i312               ; get offset to local __ptr { { ptr, u64, u64 } }
movi $r832 i2                           ; initialize constant into register
 move $$arg0 $r832                       ; [call]: pass argument 0
 movi $$arg0 i2                          ; [call]: pass argument 0
move $$arg1 $r830                       ; [call]: pass argument 1
move $$arg2 $r831                       ; [call]: pass argument 2
fncall .8                               ; [call]: call abi_encode_30
 move $r833 $zero                        ; [call]: return unit value
 movi $r833 i0                           ; [call]: return unit value
addi $r834 $$locbase i1312              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r834 $r831 i24                    ; copy memory
addi $r835 $$locbase i1792              ; get offset to local __ptr bool
addi $r836 $$locbase i1312              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r837 $$locbase i1688              ; get offset to local __ptr bool
mcpi $r837 $r835 i1                     ; copy memory
addi $r838 $$locbase i1120              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r838 $r836 i24                    ; copy memory
addi $r839 $$locbase i520               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r840 $$locbase i1120              ; get offset to local __ptr { { ptr, u64, u64 } }
move $r841 $r840                        ; return value from ASM block with return register buffer
addi $r842 $$locbase i48                ; get offset to local __ptr { ptr, u64, u64 }
 mcpi $r842 $r841 i24                    ; copy memory
 mcpi $r842 $r840 i24                    ; copy memory
addi $r843 $$locbase i136               ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r843 $r842 i24                    ; copy memory
lw $r844 $$locbase i17                  ; load word
addi $r845 $r843 i8                     ; get offset to aggregate element
lw $r846 $$locbase i18                  ; load word
addi $r847 $r843 i16                    ; get offset to aggregate element
lw $r848 $$locbase i19                  ; load word
addi $r849 $$locbase i1688              ; get offset to local __ptr bool
lb $r850 $r849 i0                       ; load byte
add $r851 $r848 $one
gt $r852 $r851 $r846
move $r853 $r844                        ; move parameter from branch to block argument
move $r854 $r846                        ; move parameter from branch to block argument
jnzi $r852 .110
ji  .111
.110
movi $r855 i2                           ; initialize constant into register
mul $r856 $r846 $r855
add $r857 $r856 $one
aloc $r857
mcp $hp $r844 $r848
move $r858 $hp                          ; return value from ASM block with return register hp
 move $r853 $r858                        ; move parameter from branch to block argument
 move $r853 $hp                          ; move parameter from branch to block argument
move $r854 $r857                        ; move parameter from branch to block argument
ji  .111
.111
move $r862 $r853                        ; move parameter from branch to block argument
move $r864 $r854                        ; move parameter from branch to block argument
 add $r865 $r862 $r848
 add $r865 $r853 $r848
sb $r865 $r850 i0                       ; store byte
add $r866 $r848 $one
addi $r867 $$locbase i184               ; get offset to local __ptr { ptr, u64, u64 }
sw $$locbase $r862 i23                  ; store word
addi $r868 $r867 i8                     ; get offset to aggregate element
sw $$locbase $r864 i24                  ; store word
addi $r869 $r867 i16                    ; get offset to aggregate element
sw $$locbase $r866 i25                  ; store word
move $r870 $r867                        ; return value from ASM block with return register buffer
addi $r871 $$locbase i72                ; get offset to local __ptr { ptr, u64, u64 }
 mcpi $r871 $r870 i24                    ; copy memory
 mcpi $r871 $r867 i24                    ; copy memory
mcpi $r839 $r871 i24                    ; copy memory
addi $r872 $$locbase i800               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r872 $r839 i24                    ; copy memory
addi $r873 $$locbase i1336              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r873 $r872 i24                    ; copy memory
addi $r874 $$locbase i1336              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r875 $$locbase i920               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r875 $r874 i24                    ; copy memory
move $r825 $r875                        ; move parameter from branch to block argument
ji  .109
.109
move $r878 $r825                        ; move parameter from branch to block argument
addi $r879 $$locbase i944               ; get offset to local __ptr { { ptr, u64, u64 } }
 mcpi $r879 $r878 i24                    ; copy memory
 mcpi $r879 $r825 i24                    ; copy memory
move $r880 $r879                        ; move parameter from branch to block argument
ji  .112
.97
addi $r881 $$locbase i208               ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
addi $r882 $r881 i55                    ; get offset to aggregate element
addi $r883 $$locbase i1784              ; get offset to local __ptr u8
mcpi $r883 $r882 i1                     ; copy memory
addi $r884 $$locbase i1072              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r885 $$locbase i568               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r885 $r884 i24                    ; copy memory
addi $r886 $$locbase i288               ; get offset to local __ptr { { ptr, u64, u64 } }
 move $$arg0 $one                        ; [call]: pass argument 0
 movi $$arg0 i1                          ; [call]: pass argument 0
move $$arg1 $r885                       ; [call]: pass argument 1
move $$arg2 $r886                       ; [call]: pass argument 2
fncall .8                               ; [call]: call abi_encode_30
 move $r887 $zero                        ; [call]: return unit value
 movi $r887 i0                           ; [call]: return unit value
addi $r888 $$locbase i1192              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r888 $r886 i24                    ; copy memory
addi $r889 $$locbase i1784              ; get offset to local __ptr u8
addi $r890 $$locbase i1192              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r891 $$locbase i1672              ; get offset to local __ptr u8
mcpi $r891 $r889 i1                     ; copy memory
addi $r892 $$locbase i1096              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r892 $r890 i24                    ; copy memory
addi $r893 $$locbase i496               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r894 $$locbase i1096              ; get offset to local __ptr { { ptr, u64, u64 } }
move $r895 $r894                        ; return value from ASM block with return register buffer
 mcpi $$locbase $r895 i24                ; copy memory
 mcpi $$locbase $r894 i24                ; copy memory
addi $r896 $$locbase i112               ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r896 $$locbase i24                ; copy memory
lw $r897 $$locbase i14                  ; load word
addi $r898 $r896 i8                     ; get offset to aggregate element
lw $r899 $$locbase i15                  ; load word
addi $r900 $r896 i16                    ; get offset to aggregate element
lw $r901 $$locbase i16                  ; load word
addi $r902 $$locbase i1672              ; get offset to local __ptr u8
lb $r903 $r902 i0                       ; load byte
add $r904 $r901 $one
gt $r905 $r904 $r899
move $r906 $r897                        ; move parameter from branch to block argument
move $r907 $r899                        ; move parameter from branch to block argument
jnzi $r905 .113
ji  .114
.113
movi $r908 i2                           ; initialize constant into register
mul $r909 $r899 $r908
add $r910 $r909 $one
aloc $r910
mcp $hp $r897 $r901
move $r911 $hp                          ; return value from ASM block with return register hp
 move $r906 $r911                        ; move parameter from branch to block argument
 move $r906 $hp                          ; move parameter from branch to block argument
move $r907 $r910                        ; move parameter from branch to block argument
ji  .114
.114
move $r915 $r906                        ; move parameter from branch to block argument
move $r917 $r907                        ; move parameter from branch to block argument
 add $r918 $r915 $r901
 add $r918 $r906 $r901
sb $r918 $r903 i0                       ; store byte
add $r919 $r901 $one
addi $r920 $$locbase i160               ; get offset to local __ptr { ptr, u64, u64 }
sw $$locbase $r915 i20                  ; store word
addi $r921 $r920 i8                     ; get offset to aggregate element
sw $$locbase $r917 i21                  ; store word
addi $r922 $r920 i16                    ; get offset to aggregate element
sw $$locbase $r919 i22                  ; store word
move $r923 $r920                        ; return value from ASM block with return register buffer
addi $r924 $$locbase i24                ; get offset to local __ptr { ptr, u64, u64 }
 mcpi $r924 $r923 i24                    ; copy memory
 mcpi $r924 $r920 i24                    ; copy memory
mcpi $r893 $r924 i24                    ; copy memory
addi $r925 $$locbase i776               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r925 $r893 i24                    ; copy memory
addi $r926 $$locbase i1264              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r926 $r925 i24                    ; copy memory
addi $r927 $$locbase i1264              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r928 $$locbase i944               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r928 $r927 i24                    ; copy memory
move $r880 $r928                        ; move parameter from branch to block argument
ji  .112
.112
move $r931 $r880                        ; move parameter from branch to block argument
addi $r932 $$locbase i968               ; get offset to local __ptr { { ptr, u64, u64 } }
 mcpi $r932 $r931 i24                    ; copy memory
 mcpi $r932 $r880 i24                    ; copy memory
move $r933 $r932                        ; move parameter from branch to block argument
ji  .115
.95
addi $r934 $$locbase i1072              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r935 $$locbase i544               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r935 $r934 i24                    ; copy memory
addi $r936 $$locbase i264               ; get offset to local __ptr { { ptr, u64, u64 } }
 move $$arg0 $zero                       ; [call]: pass argument 0
 movi $$arg0 i0                          ; [call]: pass argument 0
move $$arg1 $r935                       ; [call]: pass argument 1
move $$arg2 $r936                       ; [call]: pass argument 2
fncall .8                               ; [call]: call abi_encode_30
 move $r937 $zero                        ; [call]: return unit value
 movi $r937 i0                           ; [call]: return unit value
addi $r938 $$locbase i968               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r938 $r936 i24                    ; copy memory
move $r933 $r938                        ; move parameter from branch to block argument
ji  .115
.115
move $r941 $r933                        ; move parameter from branch to block argument
addi $r942 $$locbase i1456              ; get offset to local __ptr { { ptr, u64, u64 } }
 mcpi $r942 $r941 i24                    ; copy memory
 mcpi $r942 $r933 i24                    ; copy memory
addi $r943 $$locbase i1456              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r944 $$locbase i992               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r944 $r943 i24                    ; copy memory
addi $r945 $$locbase i1048              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r945 $r944 i24                    ; copy memory
addi $r946 $$locbase i1048              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r947 $$locbase i752               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r947 $r946 i24                    ; copy memory
addi $r948 $$locbase i480               ; get offset to local __ptr slice
move $$arg0 $r947                       ; [call]: pass argument 0
move $$arg1 $r948                       ; [call]: pass argument 1
fncall .14                              ; [call]: call as_raw_slice_39
 move $r949 $zero                        ; [call]: return unit value
 movi $r949 i0                           ; [call]: return unit value
addi $r950 $$locbase i1016              ; get offset to local __ptr slice
mcpi $r950 $r948 i16                    ; copy memory
move $r951 $r950                        ; move parameter from branch to block argument
ji  .116
.93
addi $r952 $$locbase i1776              ; get offset to local __ptr u64
movi $r953 i56                          ; initialize constant into register
sw $$locbase $r953 i222                 ; store word
addi $r954 $$locbase i1032              ; get offset to local __ptr { __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }, u64 }
addi $r955 $$locbase i1488              ; get offset to local __ptr __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
addi $r956 $$locbase i1776              ; get offset to local __ptr u64
mcpi $r954 $r955 i8                     ; copy memory
addi $r957 $r954 i8                     ; get offset to aggregate element
mcpi $r957 $r956 i8                     ; copy memory
addi $r958 $$locbase i96                ; get offset to local __ptr { __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }, u64 }
mcpi $r958 $r954 i16                    ; copy memory
addi $r959 $$locbase i1016              ; get offset to local __ptr slice
mcpi $r959 $r958 i16                    ; copy memory
move $r951 $r959                        ; move parameter from branch to block argument
ji  .116
.116
move $r962 $r951                        ; move parameter from branch to block argument
 mcpi $r636 $r962 i16                    ; copy memory
 mcpi $r636 $r951 i16                    ; copy memory
ji  .7
.7
cfsi i1864                              ; free 1864 bytes for locals and 0 slots for extra call arguments
move $$reta $r637                       ; restore return address
popa .6                                 ; restore all registers
jal $zero $$reta i0                     ; return from call
DIFF------------------------------
.program:
.8                                      ; --- start of function: abi_encode_30 ---
pusha .8                                ; save all registers
move $$locbase $sp                      ; save locals base register for function abi_encode_30
cfei i152                               ; allocate 152 bytes for locals and 0 slots for call arguments
.117
addi $r964 $$locbase i144               ; get offset to local __ptr u64
sw $$locbase $$arg0 i18                 ; store word
addi $r965 $$locbase i120               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r965 $$arg1 i24                   ; copy memory
addi $r966 $$locbase i96                ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r967 $$locbase i120               ; get offset to local __ptr { { ptr, u64, u64 } }
move $r968 $r967                        ; return value from ASM block with return register buffer
 mcpi $$locbase $r968 i24                ; copy memory
 mcpi $$locbase $r967 i24                ; copy memory
addi $r969 $$locbase i48                ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r969 $$locbase i24                ; copy memory
lw $r970 $$locbase i6                   ; load word
addi $r971 $r969 i8                     ; get offset to aggregate element
lw $r972 $$locbase i7                   ; load word
addi $r973 $r969 i16                    ; get offset to aggregate element
lw $r974 $$locbase i8                   ; load word
addi $r975 $$locbase i144               ; get offset to local __ptr u64
lw $r976 $$locbase i18                  ; load word
movi $r977 i8                           ; initialize constant into register
add $r978 $r974 $r977
gt $r979 $r978 $r972
move $r980 $r970                        ; move parameter from branch to block argument
move $r981 $r972                        ; move parameter from branch to block argument
jnzi $r979 .118
ji  .119
.118
movi $r982 i2                           ; initialize constant into register
mul $r983 $r972 $r982
movi $r984 i8                           ; initialize constant into register
add $r985 $r983 $r984
aloc $r985
mcp $hp $r970 $r974
move $r986 $hp                          ; return value from ASM block with return register hp
 move $r980 $r986                        ; move parameter from branch to block argument
 move $r980 $hp                          ; move parameter from branch to block argument
move $r981 $r985                        ; move parameter from branch to block argument
ji  .119
.119
move $r990 $r980                        ; move parameter from branch to block argument
move $r992 $r981                        ; move parameter from branch to block argument
 add $r993 $r990 $r974
 add $r993 $r980 $r974
sw $r993 $r976 i0                       ; store word
movi $r994 i8                           ; initialize constant into register
add $r995 $r974 $r994
addi $r996 $$locbase i72                ; get offset to local __ptr { ptr, u64, u64 }
sw $$locbase $r990 i9                   ; store word
addi $r997 $r996 i8                     ; get offset to aggregate element
sw $$locbase $r992 i10                  ; store word
addi $r998 $r996 i16                    ; get offset to aggregate element
sw $$locbase $r995 i11                  ; store word
move $r999 $r996                        ; return value from ASM block with return register buffer
addi $r1000 $$locbase i24               ; get offset to local __ptr { ptr, u64, u64 }
 mcpi $r1000 $r999 i24                   ; copy memory
 mcpi $r1000 $r996 i24                   ; copy memory
mcpi $r966 $r1000 i24                   ; copy memory
mcpi $$arg2 $r966 i24                   ; copy memory
ji  .9
.9
cfsi i152                               ; free 152 bytes for locals and 0 slots for extra call arguments
popa .8                                 ; restore all registers
jal $zero $$reta i0                     ; return from call
DIFF------------------------------
.program:
.10                                     ; --- start of function: abi_encode_36 ---
pusha .10                               ; save all registers
move $$locbase $sp                      ; save locals base register for function abi_encode_36
cfei i224                               ; allocate 224 bytes for locals and 0 slots for call arguments
.120
addi $r1002 $$locbase i208              ; get offset to local __ptr slice
mcpi $r1002 $$arg0 i16                  ; copy memory
addi $r1003 $$locbase i184              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r1003 $$arg1 i24                  ; copy memory
addi $r1004 $$locbase i160              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r1005 $$locbase i184              ; get offset to local __ptr { { ptr, u64, u64 } }
move $r1006 $r1005                      ; return value from ASM block with return register buffer
 mcpi $$locbase $r1006 i24               ; copy memory
 mcpi $$locbase $r1005 i24               ; copy memory
addi $r1007 $$locbase i80               ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r1007 $$locbase i24               ; copy memory
lw $r1008 $$locbase i10                 ; load word
addi $r1009 $r1007 i8                   ; get offset to aggregate element
lw $r1010 $$locbase i11                 ; load word
addi $r1011 $r1007 i16                  ; get offset to aggregate element
lw $r1012 $$locbase i12                 ; load word
addi $r1013 $$locbase i208              ; get offset to local __ptr slice
addi $r1014 $$locbase i40               ; get offset to local __ptr slice
mcpi $r1014 $r1013 i16                  ; copy memory
move $r1015 $r1013                      ; return value from ASM block with return register item
addi $r1016 $$locbase i24               ; get offset to local __ptr { u64, u64 }
 mcpi $r1016 $r1015 i16                  ; copy memory
 mcpi $r1016 $r1013 i16                  ; copy memory
addi $r1017 $$locbase i104              ; get offset to local __ptr { u64, u64 }
mcpi $r1017 $r1016 i16                  ; copy memory
addi $r1018 $r1017 i8                   ; get offset to aggregate element
lw $r1019 $$locbase i14                 ; load word
movi $r1020 i8                          ; initialize constant into register
add $r1021 $r1019 $r1020
add $r1022 $r1012 $r1021
gt $r1023 $r1022 $r1010
move $r1024 $r1008                      ; move parameter from branch to block argument
move $r1025 $r1010                      ; move parameter from branch to block argument
jnzi $r1023 .121
ji  .122
.121
movi $r1026 i2                          ; initialize constant into register
mul $r1027 $r1010 $r1026
add $r1028 $r1027 $r1021
aloc $r1028
mcp $hp $r1008 $r1012
move $r1029 $hp                         ; return value from ASM block with return register hp
 move $r1024 $r1029                      ; move parameter from branch to block argument
 move $r1024 $hp                         ; move parameter from branch to block argument
move $r1025 $r1028                      ; move parameter from branch to block argument
ji  .122
.122
move $r1033 $r1024                      ; move parameter from branch to block argument
move $r1035 $r1025                      ; move parameter from branch to block argument
addi $r1036 $$locbase i120              ; get offset to local __ptr slice
mcpi $r1036 $r1014 i16                  ; copy memory
add $r1037 $r1033 $r1012
lw $r1039 $$locbase i16
sw $r1037 $r1039 i0
addi $r1037 $r1037 i8
lw $r1038 $$locbase i15
mcp $r1037 $r1038 $r1039
addi $r1040 $r1012 i8
add $r1040 $r1040 $r1039
move $r1041 $r1040                      ; return value from ASM block with return register new_len
addi $r1042 $$locbase i136              ; get offset to local __ptr { ptr, u64, u64 }
sw $$locbase $r1033 i17                 ; store word
addi $r1043 $r1042 i8                   ; get offset to aggregate element
sw $$locbase $r1035 i18                 ; store word
addi $r1044 $r1042 i16                  ; get offset to aggregate element
sw $$locbase $r1041 i19                 ; store word
move $r1045 $r1042                      ; return value from ASM block with return register buffer
addi $r1046 $$locbase i56               ; get offset to local __ptr { ptr, u64, u64 }
 mcpi $r1046 $r1045 i24                  ; copy memory
 mcpi $r1046 $r1042 i24                  ; copy memory
mcpi $r1004 $r1046 i24                  ; copy memory
mcpi $$arg2 $r1004 i24                  ; copy memory
ji  .11
.11
cfsi i224                               ; free 224 bytes for locals and 0 slots for extra call arguments
popa .10                                ; restore all registers
jal $zero $$reta i0                     ; return from call
DIFF------------------------------
.program:
.12                                     ; --- start of function: new_38 ---
pusha .12                               ; save all registers
move $$locbase $sp                      ; save locals base register for function new_38
cfei i72                                ; allocate 72 bytes for locals and 0 slots for call arguments
.123
addi $r1048 $$locbase i48               ; get offset to local __ptr { { ptr, u64, u64 } }
movi $r1049 i1024                       ; initialize constant into register
aloc $r1049
move $r1050 $hp                         ; return value from ASM block with return register hp
addi $r1051 $$locbase i24               ; get offset to local __ptr { ptr, u64, u64 }
 sw $$locbase $r1050 i3                  ; store word
 sw $$locbase $hp i3                     ; store word
addi $r1052 $r1051 i8                   ; get offset to aggregate element
movi $r1053 i1024                       ; initialize constant into register
sw $$locbase $r1053 i4                  ; store word
addi $r1054 $r1051 i16                  ; get offset to aggregate element
sw $$locbase $zero i5                   ; store word
move $r1055 $r1051                      ; return value from ASM block with return register buffer
 mcpi $$locbase $r1055 i24               ; copy memory
 mcpi $$locbase $r1051 i24               ; copy memory
mcpi $r1048 $$locbase i24               ; copy memory
mcpi $$arg0 $r1048 i24                  ; copy memory
ji  .13
.13
cfsi i72                                ; free 72 bytes for locals and 0 slots for extra call arguments
popa .12                                ; restore all registers
jal $zero $$reta i0                     ; return from call
DIFF------------------------------
.program:
.14                                     ; --- start of function: as_raw_slice_39 ---
pusha .14                               ; save all registers
move $$locbase $sp                      ; save locals base register for function as_raw_slice_39
cfei i104                               ; allocate 104 bytes for locals and 0 slots for call arguments
.124
addi $r1057 $$locbase i80               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r1057 $$arg0 i24                  ; copy memory
addi $r1058 $$locbase i80               ; get offset to local __ptr { { ptr, u64, u64 } }
move $r1059 $r1058                      ; return value from ASM block with return register buffer
 mcpi $$locbase $r1059 i24               ; copy memory
 mcpi $$locbase $r1058 i24               ; copy memory
addi $r1060 $$locbase i40               ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r1060 $$locbase i24               ; copy memory
addi $r1061 $r1060 i16                  ; get offset to aggregate element
addi $r1062 $$locbase i64               ; get offset to local __ptr { ptr, u64 }
mcpi $r1062 $r1060 i8                   ; copy memory
addi $r1063 $r1062 i8                   ; get offset to aggregate element
mcpi $r1063 $r1061 i8                   ; copy memory
move $r1064 $r1062                      ; return value from ASM block with return register s
addi $r1065 $$locbase i24               ; get offset to local __ptr slice
 mcpi $r1065 $r1064 i16                  ; copy memory
 mcpi $r1065 $r1062 i16                  ; copy memory
mcpi $$arg1 $r1065 i16                  ; copy memory
ji  .15
.15
cfsi i104                               ; free 104 bytes for locals and 0 slots for extra call arguments
popa .14                                ; restore all registers
jal $zero $$reta i0                     ; return from call
DIFF------------------------------
.program:
.16                                     ; --- start of function: generic_panic_41 ---
pusha .16                               ; save all registers
move $$locbase $sp                      ; save locals base register for function generic_panic_41
cfei i240                               ; allocate 240 bytes for locals and 0 slots for call arguments
move $r1066 $$arg0                      ; save argument 0 (t)
move $r1067 $$arg1                      ; save argument 1 (__backtrace)
move $r1068 $$reta                      ; save return address
.125
addi $r1069 $$locbase i224              ; get offset to local __ptr slice
 mcpi $r1069 $r1066 i16                  ; copy memory
 mcpi $r1069 $$arg0 i16                  ; copy memory
addi $r1070 $$locbase i224              ; get offset to local __ptr slice
addi $r1071 $$locbase i208              ; get offset to local __ptr __ptr slice
sw $$locbase $r1070 i26                 ; store word
 jnzi $zero .126
 
ji  .127
.127
addi $r1072 $$locbase i208              ; get offset to local __ptr __ptr slice
lw $r1073 $$locbase i26                 ; load word
addi $r1074 $$locbase i56               ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r1074                      ; [call]: pass argument 0
fncall .12                              ; [call]: call new_38
 move $r1075 $zero                       ; [call]: return unit value
 movi $r1075 i0                          ; [call]: return unit value
addi $r1076 $$locbase i96               ; get offset to local __ptr slice
mcpi $r1076 $r1073 i16                  ; copy memory
addi $r1077 $$locbase i112              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r1077 $r1074 i24                  ; copy memory
addi $r1078 $$locbase i32               ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r1076                      ; [call]: pass argument 0
move $$arg1 $r1077                      ; [call]: pass argument 1
move $$arg2 $r1078                      ; [call]: pass argument 2
fncall .10                              ; [call]: call abi_encode_36
 move $r1079 $zero                       ; [call]: return unit value
 movi $r1079 i0                          ; [call]: return unit value
addi $r1080 $$locbase i184              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r1080 $r1078 i24                  ; copy memory
addi $r1081 $$locbase i184              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r1082 $$locbase i80               ; get offset to local __ptr slice
move $$arg0 $r1081                      ; [call]: pass argument 0
move $$arg1 $r1082                      ; [call]: pass argument 1
fncall .14                              ; [call]: call as_raw_slice_39
 move $r1083 $zero                       ; [call]: return unit value
 movi $r1083 i0                          ; [call]: return unit value
addi $r1084 $$locbase i136              ; get offset to local __ptr slice
mcpi $r1084 $r1082 i16                  ; copy memory
move $r1085 $r1084                      ; move parameter from branch to block argument
ji  .128
.126
addi $r1086 $$locbase i216              ; get offset to local __ptr u64
movi $r1087 i16                         ; initialize constant into register
sw $$locbase $r1087 i27                 ; store word
addi $r1088 $$locbase i168              ; get offset to local __ptr { __ptr slice, u64 }
addi $r1089 $$locbase i208              ; get offset to local __ptr __ptr slice
addi $r1090 $$locbase i216              ; get offset to local __ptr u64
mcpi $r1088 $r1089 i8                   ; copy memory
addi $r1091 $r1088 i8                   ; get offset to aggregate element
mcpi $r1091 $r1090 i8                   ; copy memory
mcpi $$locbase $r1088 i16               ; copy memory
addi $r1092 $$locbase i136              ; get offset to local __ptr slice
mcpi $r1092 $$locbase i16               ; copy memory
move $r1085 $r1092                      ; move parameter from branch to block argument
ji  .128
.128
move $r1095 $r1085                      ; move parameter from branch to block argument
addi $r1096 $$locbase i152              ; get offset to local __ptr slice
 mcpi $r1096 $r1095 i16                  ; copy memory
 mcpi $r1096 $r1085 i16                  ; copy memory
addi $r1097 $$locbase i16               ; get offset to local __ptr slice
mcpi $r1097 $r1096 i16                  ; copy memory
load $r1098 data_NonConfigurable_16     ; load constant from data section
lw $r1099 $$locbase i2                  ; load slice pointer for logging data
lw $r1100 $$locbase i3                  ; load slice size for logging data
logd $zero $r1098 $r1099 $r1100         ; log slice
load $r1101 data_NonConfigurable_2      ; load constant from data section
and $r1102 $r1067 $r1101
load $r1103 data_NonConfigurable_17     ; load constant from data section
or $r1104 $r1103 $r1102
rvrt $r1104
.17
cfsi i240                               ; free 240 bytes for locals and 0 slots for extra call arguments
move $$reta $r1068                      ; restore return address
popa .16                                ; restore all registers
jal $zero $$reta i0                     ; return from call
DIFF------------------------------
.program:
.18                                     ; --- start of function: generic_panic_44 ---
pusha .18                               ; save all registers
move $$locbase $sp                      ; save locals base register for function generic_panic_44
cfei i184                               ; allocate 184 bytes for locals and 0 slots for call arguments
move $r1105 $$arg0                      ; save argument 0 (t)
move $r1106 $$arg1                      ; save argument 1 (__backtrace)
move $r1107 $$reta                      ; save return address
.129
addi $r1108 $$locbase i184              ; get offset to local __ptr ()
addi $r1109 $$locbase i184              ; get offset to local __ptr ()
addi $r1110 $$locbase i168              ; get offset to local __ptr __ptr ()
sw $$locbase $r1109 i21                 ; store word
 jnzi $one .130
 ji  .130
ji  .131
.131
addi $r1111 $$locbase i32               ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r1111                      ; [call]: pass argument 0
fncall .12                              ; [call]: call new_38
 move $r1112 $zero                       ; [call]: return unit value
 movi $r1112 i0                          ; [call]: return unit value
addi $r1113 $$locbase i144              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r1113 $r1111 i24                  ; copy memory
addi $r1114 $$locbase i144              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r1115 $$locbase i72               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r1115 $r1114 i24                  ; copy memory
addi $r1116 $$locbase i56               ; get offset to local __ptr slice
move $$arg0 $r1115                      ; [call]: pass argument 0
move $$arg1 $r1116                      ; [call]: pass argument 1
fncall .14                              ; [call]: call as_raw_slice_39
 move $r1117 $zero                       ; [call]: return unit value
 movi $r1117 i0                          ; [call]: return unit value
addi $r1118 $$locbase i96               ; get offset to local __ptr slice
mcpi $r1118 $r1116 i16                  ; copy memory
move $r1119 $r1118                      ; move parameter from branch to block argument
ji  .132
.130
addi $r1120 $$locbase i176              ; get offset to local __ptr u64
sw $$locbase $zero i22                  ; store word
addi $r1121 $$locbase i128              ; get offset to local __ptr { __ptr (), u64 }
addi $r1122 $$locbase i168              ; get offset to local __ptr __ptr ()
addi $r1123 $$locbase i176              ; get offset to local __ptr u64
mcpi $r1121 $r1122 i8                   ; copy memory
addi $r1124 $r1121 i8                   ; get offset to aggregate element
mcpi $r1124 $r1123 i8                   ; copy memory
mcpi $$locbase $r1121 i16               ; copy memory
addi $r1125 $$locbase i96               ; get offset to local __ptr slice
mcpi $r1125 $$locbase i16               ; copy memory
move $r1119 $r1125                      ; move parameter from branch to block argument
ji  .132
.132
move $r1128 $r1119                      ; move parameter from branch to block argument
addi $r1129 $$locbase i112              ; get offset to local __ptr slice
 mcpi $r1129 $r1128 i16                  ; copy memory
 mcpi $r1129 $r1119 i16                  ; copy memory
addi $r1130 $$locbase i16               ; get offset to local __ptr slice
mcpi $r1130 $r1129 i16                  ; copy memory
load $r1131 data_NonConfigurable_18     ; load constant from data section
lw $r1132 $$locbase i2                  ; load slice pointer for logging data
lw $r1133 $$locbase i3                  ; load slice size for logging data
logd $zero $r1131 $r1132 $r1133         ; log slice
load $r1134 data_NonConfigurable_2      ; load constant from data section
and $r1135 $r1106 $r1134
load $r1136 data_NonConfigurable_19     ; load constant from data section
or $r1137 $r1136 $r1135
rvrt $r1137
.19
cfsi i184                               ; free 184 bytes for locals and 0 slots for extra call arguments
move $$reta $r1107                      ; restore return address
popa .18                                ; restore all registers
jal $zero $$reta i0                     ; return from call
DIFF------------------------------
.program:
.20                                     ; --- start of function: call_nested_panic_non_inlined_48 ---
pusha .20                               ; save all registers
move $$locbase $sp                      ; save locals base register for function call_nested_panic_non_inlined_48
cfei i200                               ; allocate 200 bytes for locals and 0 slots for call arguments
move $r1138 $$arg0                      ; save argument 0 (__backtrace)
move $r1139 $$reta                      ; save return address
.133
movi $r1140 i4                          ; initialize constant into register
sw $$locbase $r1140 i0                  ; store word
addi $r1141 $$locbase i152              ; get offset to local __ptr [slice; 3]
addr $r1142 data_NonConfigurable_20     ; get __const_global4's address in data section
addi $r1143 $$locbase i56               ; get offset to local __ptr { ptr, u64 }
sw $$locbase $r1142 i7                  ; store word
addi $r1144 $r1143 i8                   ; get offset to aggregate element
movi $r1145 i4                          ; initialize constant into register
sw $$locbase $r1145 i8                  ; store word
addi $r1146 $$locbase i72               ; get offset to local __ptr slice
mcpi $r1146 $r1143 i16                  ; copy memory
addr $r1147 data_NonConfigurable_21     ; get __const_global5's address in data section
addi $r1148 $$locbase i88               ; get offset to local __ptr { ptr, u64 }
sw $$locbase $r1147 i11                 ; store word
addi $r1149 $r1148 i8                   ; get offset to aggregate element
movi $r1150 i6                          ; initialize constant into register
sw $$locbase $r1150 i12                 ; store word
addi $r1151 $$locbase i104              ; get offset to local __ptr slice
mcpi $r1151 $r1148 i16                  ; copy memory
addr $r1152 data_NonConfigurable_22     ; get __const_global6's address in data section
addi $r1153 $$locbase i120              ; get offset to local __ptr { ptr, u64 }
sw $$locbase $r1152 i15                 ; store word
addi $r1154 $r1153 i8                   ; get offset to aggregate element
movi $r1155 i17                         ; initialize constant into register
sw $$locbase $r1155 i16                 ; store word
addi $r1156 $$locbase i136              ; get offset to local __ptr slice
mcpi $r1156 $r1153 i16                  ; copy memory
movi $r1157 i16                         ; get array element size
 mul $r1158 $zero $r1157                 ; get offset to array element
 add $r1158 $r1141 $r1158                ; add array element offset to array base
 movi $r1158 i0                          ; get offset to array element
 add $r1158 $r1141 $zero                 ; add array element offset to array base
mcpi $r1158 $r1146 i16                  ; copy memory
movi $r1159 i16                         ; get array element size
 mul $r1160 $one $r1159                  ; get offset to array element
 movi $r1160 i16                         ; get offset to array element
add $r1160 $r1141 $r1160                ; add array element offset to array base
mcpi $r1160 $r1151 i16                  ; copy memory
movi $r1161 i16                         ; get array element size
movi $r1162 i2                          ; initialize constant into register
 mul $r1163 $r1162 $r1161                ; get offset to array element
 movi $r1163 i32                         ; get offset to array element
add $r1163 $r1141 $r1163                ; add array element offset to array base
mcpi $r1163 $r1156 i16                  ; copy memory
addi $r1164 $$locbase i8                ; get offset to aggregate element
mcpi $r1164 $r1141 i48                  ; copy memory
movi $r1165 i11                         ; initialize constant into register
sll $r1166 $r1138 $r1165
movi $r1167 i8                          ; initialize constant into register
or $r1168 $r1166 $r1167
 move $$arg0 $one                        ; [call]: pass argument 0
 movi $$arg0 i1                          ; [call]: pass argument 0
move $$arg1 $$locbase                   ; [call]: pass argument 1
move $$arg2 $r1168                      ; [call]: pass argument 2
fncall .22                              ; [call]: call nested_panic_non_inlined_49
 move $r1169 $zero                       ; [call]: return unit value
 movi $r1169 i0                          ; [call]: return unit value
ji  .21
.21
cfsi i200                               ; free 200 bytes for locals and 0 slots for extra call arguments
move $$reta $r1139                      ; restore return address
popa .20                                ; restore all registers
jal $zero $$reta i0                     ; return from call
DIFF------------------------------
.program:
.22                                     ; --- start of function: nested_panic_non_inlined_49 ---
pusha .22                               ; save all registers
move $$locbase $sp                      ; save locals base register for function nested_panic_non_inlined_49
cfei i96                                ; allocate 96 bytes for locals and 0 slots for call arguments
move $r1170 $$arg0                      ; save argument 0 (to_panic)
move $r1171 $$arg1                      ; save argument 1 (err)
move $r1172 $$arg2                      ; save argument 2 (__backtrace)
move $r1173 $$reta                      ; save return address
.134
addi $r1174 $$locbase i88               ; get offset to local __ptr bool
 sb $r1174 $r1170 i0                     ; store byte
 sb $r1174 $$arg0 i0                     ; store byte
addi $r1175 $$locbase i32               ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
mcpi $r1175 $r1171 i56                  ; copy memory
addi $r1176 $$locbase i88               ; get offset to local __ptr bool
lb $r1177 $r1176 i0                     ; load byte
jnzi $r1177 .135
ji  .136
.136
ji  .23
.135
addi $r1178 $$locbase i32               ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
addi $r1179 $$locbase i16               ; get offset to local __ptr slice
move $$arg0 $r1178                      ; [call]: pass argument 0
move $$arg1 $r1179                      ; [call]: pass argument 1
fncall .6                               ; [call]: call encode_allow_alias_12
 move $r1180 $zero                       ; [call]: return unit value
 movi $r1180 i0                          ; [call]: return unit value
mcpi $$locbase $r1179 i16               ; copy memory
load $r1181 data_NonConfigurable_1      ; load constant from data section
lw $r1182 $$locbase i0                  ; load slice pointer for logging data
lw $r1183 $$locbase i1                  ; load slice size for logging data
logd $zero $r1181 $r1182 $r1183         ; log slice
load $r1184 data_NonConfigurable_2      ; load constant from data section
and $r1185 $r1172 $r1184
load $r1186 data_NonConfigurable_23     ; load constant from data section
or $r1187 $r1186 $r1185
rvrt $r1187
.23
cfsi i96                                ; free 96 bytes for locals and 0 slots for extra call arguments
move $$reta $r1173                      ; restore return address
popa .22                                ; restore all registers
jal $zero $$reta i0                     ; return from call
DIFF------------------------------
.program:
DIFF------------------------------
.program:
.0                                      ; --- start of function: __entry ---
move $$locbase $sp                      ; save locals base register for function __entry
cfei i1264                              ; allocate 1264 bytes for locals and 0 slots for call arguments
.52
addr $r1 data_NonConfigurable_0         ; get __const_global's address in data section
addi $r2 $$locbase i40                  ; get offset to local __ptr { ptr, u64 }
sw $$locbase $r1 i5                     ; store word
addi $r3 $r2 i8                         ; get offset to aggregate element
movi $r4 i454                           ; initialize constant into register
sw $$locbase $r4 i6                     ; store word
addi $r5 $$locbase i256                 ; get offset to local __ptr slice
mcpi $r5 $r2 i16                        ; copy memory
addi $r6 $$locbase i640                 ; get offset to local __ptr slice
mcpi $r6 $r5 i16                        ; copy memory
addi $r7 $$locbase i640                 ; get offset to local __ptr slice
addi $r8 $$locbase i952                 ; get offset to local __ptr slice
mcpi $r8 $r7 i16                        ; copy memory
addi $r9 $$locbase i952                 ; get offset to local __ptr slice
move $r10 $r9                           ; return value from ASM block with return register s
addi $r11 $$locbase i24                 ; get offset to local __ptr { ptr, u64 }
 mcpi $r11 $r10 i16                      ; copy memory
 mcpi $r11 $r9 i16                       ; copy memory
addi $r12 $$locbase i568                ; get offset to local __ptr { ptr, u64 }
mcpi $r12 $r11 i16                      ; copy memory
addi $r13 $$locbase i568                ; get offset to local __ptr { ptr, u64 }
addi $r14 $$locbase i584                ; get offset to local __ptr { ptr, u64 }
mcpi $r14 $r13 i16                      ; copy memory
addi $r15 $$locbase i584                ; get offset to local __ptr { ptr, u64 }
addi $r16 $$locbase i896                ; get offset to local __ptr ptr
mcpi $r16 $r15 i8                       ; copy memory
addi $r17 $$locbase i584                ; get offset to local __ptr { ptr, u64 }
addi $r18 $r17 i8                       ; get offset to aggregate element
addi $r19 $$locbase i16                 ; get offset to local __ptr u64
mcpi $r19 $r18 i8                       ; copy memory
addi $r20 $$locbase i896                ; get offset to local __ptr ptr
lw $r21 $$locbase i112                  ; load word
addi $r22 $$locbase i656                ; get offset to local __ptr ptr
sw $$locbase $r21 i82                   ; store word
addi $r23 $$locbase i8                  ; get offset to local __ptr u64
movi $r24 i74                           ; initialize constant into register
sw $$locbase $r24 i1                    ; store word
move $r25 $fp                           ; return value from ASM block with return register fp
addi $r26 $$locbase i904                ; get offset to local __ptr ptr
 sw $$locbase $r25 i113                  ; store word
 sw $$locbase $fp i113                   ; store word
addi $r27 $$locbase i904                ; get offset to local __ptr ptr
addi $r28 $$locbase i8                  ; get offset to local __ptr u64
addi $r29 $$locbase i968                ; get offset to local __ptr ptr
mcpi $r29 $r27 i8                       ; copy memory
addi $r30 $$locbase i664                ; get offset to local __ptr u64
mcpi $r30 $r28 i8                       ; copy memory
addi $r31 $$locbase i968                ; get offset to local __ptr ptr
lw $r32 $$locbase i121                  ; load word
addi $r33 $$locbase i664                ; get offset to local __ptr u64
lw $r34 $$locbase i83                   ; load word
movi $r35 i8                            ; initialize constant into register
mul $r36 $r35 $r34
add $r37 $r32 $r36
addi $r38 $$locbase i920                ; get offset to local __ptr ptr
sw $$locbase $r37 i115                  ; store word
addi $r39 $$locbase i920                ; get offset to local __ptr ptr
lw $r40 $$locbase i115                  ; load word
move $$arg0 $r40                        ; [call]: pass argument 0
fncall .2                               ; [call]: call read_3
move $r41 $$retv                        ; [call]: copy the return value
addi $r42 $$locbase i936                ; get offset to local __ptr u64
 sw $$locbase $r41 i117                  ; store word
 sw $$locbase $$retv i117                ; store word
addi $r43 $$locbase i936                ; get offset to local __ptr u64
lw $r44 $$locbase i117                  ; load word
move $r45 $r44                          ; return value from ASM block with return register ptr
addi $r46 $$locbase i600                ; get offset to local __ptr ptr
 sw $$locbase $r45 i75                   ; store word
 sw $$locbase $r44 i75                   ; store word
movi $r47 i73                           ; initialize constant into register
sw $$locbase $r47 i0                    ; store word
move $r48 $fp                           ; return value from ASM block with return register fp
addi $r49 $$locbase i912                ; get offset to local __ptr ptr
 sw $$locbase $r48 i114                  ; store word
 sw $$locbase $fp i114                   ; store word
addi $r50 $$locbase i912                ; get offset to local __ptr ptr
addi $r51 $$locbase i984                ; get offset to local __ptr ptr
mcpi $r51 $r50 i8                       ; copy memory
addi $r52 $$locbase i672                ; get offset to local __ptr u64
mcpi $r52 $$locbase i8                  ; copy memory
addi $r53 $$locbase i984                ; get offset to local __ptr ptr
lw $r54 $$locbase i123                  ; load word
addi $r55 $$locbase i672                ; get offset to local __ptr u64
lw $r56 $$locbase i84                   ; load word
movi $r57 i8                            ; initialize constant into register
mul $r58 $r57 $r56
add $r59 $r54 $r58
addi $r60 $$locbase i928                ; get offset to local __ptr ptr
sw $$locbase $r59 i116                  ; store word
addi $r61 $$locbase i928                ; get offset to local __ptr ptr
lw $r62 $$locbase i116                  ; load word
move $$arg0 $r62                        ; [call]: pass argument 0
fncall .2                               ; [call]: call read_3
move $r63 $$retv                        ; [call]: copy the return value
addi $r64 $$locbase i944                ; get offset to local __ptr u64
 sw $$locbase $r63 i118                  ; store word
 sw $$locbase $$retv i118                ; store word
addi $r65 $$locbase i944                ; get offset to local __ptr u64
lw $r66 $$locbase i118                  ; load word
move $r67 $r66                          ; return value from ASM block with return register ptr
addi $r68 $$locbase i624                ; get offset to local __ptr ptr
 sw $$locbase $r67 i78                   ; store word
 sw $$locbase $r66 i78                   ; store word
addi $r69 $$locbase i528                ; get offset to local __ptr { ptr }
addi $r70 $$locbase i624                ; get offset to local __ptr ptr
mcpi $r69 $r70 i8                       ; copy memory
addi $r71 $$locbase i616                ; get offset to local __ptr { ptr }
mcpi $r71 $r69 i8                       ; copy memory
addi $r72 $$locbase i616                ; get offset to local __ptr { ptr }
addi $r73 $$locbase i1056               ; get offset to local __ptr __ptr { ptr }
sw $$locbase $r72 i132                  ; store word
addi $r74 $$locbase i1120               ; get offset to local __ptr u64
movi $r75 i8                            ; initialize constant into register
sw $$locbase $r75 i140                  ; store word
 jnzi $zero .53
 
ji  .54
.54
addi $r76 $$locbase i1120               ; get offset to local __ptr u64
addi $r77 $$locbase i976                ; get offset to local __ptr u64
mcpi $r77 $r76 i8                       ; copy memory
addi $r78 $$locbase i784                ; get offset to local __ptr u64
sw $$locbase $one i98                   ; store word
addi $r79 $$locbase i976                ; get offset to local __ptr u64
lw $r80 $$locbase i122                  ; load word
addi $r81 $$locbase i784                ; get offset to local __ptr u64
lw $r82 $$locbase i98                   ; load word
eq $r83 $r80 $r82
jnzi $r83 .55
ji  .56
.56
addi $r84 $$locbase i1056               ; get offset to local __ptr __ptr { ptr }
addi $r85 $$locbase i992                ; get offset to local __ptr __ptr { ptr }
mcpi $r85 $r84 i8                       ; copy memory
addi $r86 $$locbase i992                ; get offset to local __ptr __ptr { ptr }
lw $r87 $$locbase i124                  ; load word
lw $r88 $r87 i0                         ; load word
lw $r89 $r88 i0                         ; lw val ptr i0
move $r90 $r89                          ; return value from ASM block with return register val
addi $r91 $$locbase i1248               ; get offset to local __ptr u64
 sw $$locbase $r90 i156                  ; store word
 sw $$locbase $r89 i156                  ; store word
addi $r92 $$locbase i992                ; get offset to local __ptr __ptr { ptr }
lw $r93 $$locbase i124                  ; load word
lw $r94 $r93 i0                         ; load word
movi $r95 i8                            ; initialize constant into register
 mul $r96 $one $r95
 movi $r96 i8
add $r97 $r94 $r96
addi $r98 $$locbase i992                ; get offset to local __ptr __ptr { ptr }
lw $r99 $$locbase i124                  ; load word
sw $r99 $r97 i0                         ; store word
addi $r100 $$locbase i1248              ; get offset to local __ptr u64
lw $r101 $$locbase i156                 ; load word
move $r102 $r101                        ; move parameter from branch to block argument
ji  .57
.55
addi $r103 $$locbase i1056              ; get offset to local __ptr __ptr { ptr }
lw $r104 $$locbase i132                 ; load word
lw $r105 $r104 i0                       ; load word
lb $r106 $r105 i0                       ; lb val ptr i0
move $r107 $r106                        ; return value from ASM block with return register val
addi $r108 $$locbase i1256              ; get offset to local __ptr u64
 sw $$locbase $r107 i157                 ; store word
 sw $$locbase $r106 i157                 ; store word
addi $r109 $$locbase i1056              ; get offset to local __ptr __ptr { ptr }
lw $r110 $$locbase i132                 ; load word
lw $r111 $r110 i0                       ; load word
 mul $r112 $one $one
 add $r113 $r111 $r112
 movi $r112 i1
 add $r113 $r111 $one
addi $r114 $$locbase i1056              ; get offset to local __ptr __ptr { ptr }
lw $r115 $$locbase i132                 ; load word
sw $r115 $r113 i0                       ; store word
addi $r116 $$locbase i1256              ; get offset to local __ptr u64
lw $r117 $$locbase i157                 ; load word
move $r102 $r117                        ; move parameter from branch to block argument
ji  .57
.57
move $r120 $r102                        ; move parameter from branch to block argument
 move $r121 $r120                        ; move parameter from branch to block argument
 move $r121 $r102                        ; move parameter from branch to block argument
ji  .58
.53
addi $r122 $$locbase i1056              ; get offset to local __ptr __ptr { ptr }
lw $r123 $$locbase i132                 ; load word
lw $r124 $r123 i0                       ; load word
move $r125 $r124                        ; return value from ASM block with return register ptr
addi $r126 $$locbase i1240              ; get offset to local __ptr u64
 sw $$locbase $r125 i155                 ; store word
 sw $$locbase $r124 i155                 ; store word
addi $r127 $$locbase i1056              ; get offset to local __ptr __ptr { ptr }
lw $r128 $$locbase i132                 ; load word
lw $r129 $r128 i0                       ; load word
addi $r130 $$locbase i1120              ; get offset to local __ptr u64
lw $r131 $$locbase i140                 ; load word
mul $r132 $one $r131
add $r133 $r129 $r132
addi $r134 $$locbase i1056              ; get offset to local __ptr __ptr { ptr }
lw $r135 $$locbase i132                 ; load word
sw $r135 $r133 i0                       ; store word
addi $r136 $$locbase i1240              ; get offset to local __ptr u64
lw $r137 $$locbase i155                 ; load word
move $r121 $r137                        ; move parameter from branch to block argument
ji  .58
.58
move $r140 $r121                        ; move parameter from branch to block argument
addi $r141 $$locbase i608               ; get offset to local __ptr u64
 sw $$locbase $r140 i76                  ; store word
 sw $$locbase $r121 i76                  ; store word
addi $r142 $$locbase i616               ; get offset to local __ptr { ptr }
addi $r143 $$locbase i1064              ; get offset to local __ptr { ptr }
mcpi $r143 $r142 i8                     ; copy memory
addi $r144 $$locbase i1064              ; get offset to local __ptr { ptr }
lw $r145 $$locbase i133                 ; load word
addi $r146 $$locbase i632               ; get offset to local __ptr ptr
sw $$locbase $r145 i79                  ; store word
addi $r147 $$locbase i608               ; get offset to local __ptr u64
addi $r148 $$locbase i1072              ; get offset to local __ptr u64
mcpi $r148 $r147 i8                     ; copy memory
addi $r149 $$locbase i792               ; get offset to local __ptr u64
movi $r150 i20                          ; initialize constant into register
sw $$locbase $r150 i99                  ; store word
addi $r151 $$locbase i1072              ; get offset to local __ptr u64
lw $r152 $$locbase i134                 ; load word
addi $r153 $$locbase i792               ; get offset to local __ptr u64
lw $r154 $$locbase i99                  ; load word
eq $r155 $r152 $r154
jnzi $r155 .59
ji  .60
.59
addi $r156 $$locbase i632               ; get offset to local __ptr ptr
lw $r157 $$locbase i79                  ; load word
addi $r158 $$locbase i656               ; get offset to local __ptr ptr
lw $r159 $$locbase i82                  ; load word
movi $r161 i20                          ; initialize constant into register
addi $r160 $r159 i332
meq $r160 $r157 $r160 $r161
move $r162 $r160                        ; return value from ASM block with return register r
addi $r163 $$locbase i680               ; get offset to local __ptr bool
 sb $r163 $r162 i0                       ; store byte
 sb $r163 $r160 i0                       ; store byte
addi $r164 $$locbase i680               ; get offset to local __ptr bool
lb $r165 $r164 i0                       ; load byte
jnzi $r165 .61
ji  .60
.60
addi $r166 $$locbase i608               ; get offset to local __ptr u64
addi $r167 $$locbase i1080              ; get offset to local __ptr u64
mcpi $r167 $r166 i8                     ; copy memory
addi $r168 $$locbase i800               ; get offset to local __ptr u64
movi $r169 i22                          ; initialize constant into register
sw $$locbase $r169 i100                 ; store word
addi $r170 $$locbase i1080              ; get offset to local __ptr u64
lw $r171 $$locbase i135                 ; load word
addi $r172 $$locbase i800               ; get offset to local __ptr u64
lw $r173 $$locbase i100                 ; load word
eq $r174 $r171 $r173
jnzi $r174 .62
ji  .63
.62
addi $r175 $$locbase i632               ; get offset to local __ptr ptr
lw $r176 $$locbase i79                  ; load word
addi $r177 $$locbase i656               ; get offset to local __ptr ptr
lw $r178 $$locbase i82                  ; load word
movi $r180 i22                          ; initialize constant into register
addi $r179 $r178 i247
meq $r179 $r176 $r179 $r180
move $r181 $r179                        ; return value from ASM block with return register r
addi $r182 $$locbase i688               ; get offset to local __ptr bool
 sb $r182 $r181 i0                       ; store byte
 sb $r182 $r179 i0                       ; store byte
addi $r183 $$locbase i688               ; get offset to local __ptr bool
lb $r184 $r183 i0                       ; load byte
jnzi $r184 .64
ji  .63
.63
addi $r185 $$locbase i608               ; get offset to local __ptr u64
addi $r186 $$locbase i1088              ; get offset to local __ptr u64
mcpi $r186 $r185 i8                     ; copy memory
addi $r187 $$locbase i832               ; get offset to local __ptr u64
movi $r188 i23                          ; initialize constant into register
sw $$locbase $r188 i104                 ; store word
addi $r189 $$locbase i1088              ; get offset to local __ptr u64
lw $r190 $$locbase i136                 ; load word
addi $r191 $$locbase i832               ; get offset to local __ptr u64
lw $r192 $$locbase i104                 ; load word
eq $r193 $r190 $r192
jnzi $r193 .65
ji  .66
.65
addi $r194 $$locbase i632               ; get offset to local __ptr ptr
lw $r195 $$locbase i79                  ; load word
addi $r196 $$locbase i656               ; get offset to local __ptr ptr
lw $r197 $$locbase i82                  ; load word
movi $r199 i23                          ; initialize constant into register
addi $r198 $r197 i269
meq $r198 $r195 $r198 $r199
move $r200 $r198                        ; return value from ASM block with return register r
addi $r201 $$locbase i696               ; get offset to local __ptr bool
 sb $r201 $r200 i0                       ; store byte
 sb $r201 $r198 i0                       ; store byte
addi $r202 $$locbase i696               ; get offset to local __ptr bool
lb $r203 $r202 i0                       ; load byte
jnzi $r203 .67
ji  .66
.66
addi $r204 $$locbase i608               ; get offset to local __ptr u64
addi $r205 $$locbase i1096              ; get offset to local __ptr u64
mcpi $r205 $r204 i8                     ; copy memory
addi $r206 $$locbase i840               ; get offset to local __ptr u64
movi $r207 i24                          ; initialize constant into register
sw $$locbase $r207 i105                 ; store word
addi $r208 $$locbase i1096              ; get offset to local __ptr u64
lw $r209 $$locbase i137                 ; load word
addi $r210 $$locbase i840               ; get offset to local __ptr u64
lw $r211 $$locbase i105                 ; load word
eq $r212 $r209 $r211
jnzi $r212 .68
ji  .69
.68
addi $r213 $$locbase i632               ; get offset to local __ptr ptr
lw $r214 $$locbase i79                  ; load word
addi $r215 $$locbase i656               ; get offset to local __ptr ptr
lw $r216 $$locbase i82                  ; load word
movi $r218 i24                          ; initialize constant into register
addi $r217 $r216 i389
meq $r217 $r214 $r217 $r218
move $r219 $r217                        ; return value from ASM block with return register r
addi $r220 $$locbase i704               ; get offset to local __ptr bool
 sb $r220 $r219 i0                       ; store byte
 sb $r220 $r217 i0                       ; store byte
addi $r221 $$locbase i704               ; get offset to local __ptr bool
lb $r222 $r221 i0                       ; load byte
jnzi $r222 .70
ji  .69
.69
addi $r223 $$locbase i608               ; get offset to local __ptr u64
addi $r224 $$locbase i1104              ; get offset to local __ptr u64
mcpi $r224 $r223 i8                     ; copy memory
addi $r225 $$locbase i848               ; get offset to local __ptr u64
movi $r226 i25                          ; initialize constant into register
sw $$locbase $r226 i106                 ; store word
addi $r227 $$locbase i1104              ; get offset to local __ptr u64
lw $r228 $$locbase i138                 ; load word
addi $r229 $$locbase i848               ; get offset to local __ptr u64
lw $r230 $$locbase i106                 ; load word
eq $r231 $r228 $r230
jnzi $r231 .71
ji  .72
.71
addi $r232 $$locbase i632               ; get offset to local __ptr ptr
lw $r233 $$locbase i79                  ; load word
addi $r234 $$locbase i656               ; get offset to local __ptr ptr
lw $r235 $$locbase i82                  ; load word
movi $r237 i25                          ; initialize constant into register
addi $r236 $r235 i31
meq $r236 $r233 $r236 $r237
move $r238 $r236                        ; return value from ASM block with return register r
addi $r239 $$locbase i712               ; get offset to local __ptr bool
 sb $r239 $r238 i0                       ; store byte
 sb $r239 $r236 i0                       ; store byte
addi $r240 $$locbase i712               ; get offset to local __ptr bool
lb $r241 $r240 i0                       ; load byte
jnzi $r241 .73
ji  .72
.72
addi $r242 $$locbase i608               ; get offset to local __ptr u64
addi $r243 $$locbase i1112              ; get offset to local __ptr u64
mcpi $r243 $r242 i8                     ; copy memory
addi $r244 $$locbase i856               ; get offset to local __ptr u64
movi $r245 i31                          ; initialize constant into register
sw $$locbase $r245 i107                 ; store word
addi $r246 $$locbase i1112              ; get offset to local __ptr u64
lw $r247 $$locbase i139                 ; load word
addi $r248 $$locbase i856               ; get offset to local __ptr u64
lw $r249 $$locbase i107                 ; load word
eq $r250 $r247 $r249
jnzi $r250 .74
ji  .75
.74
addi $r251 $$locbase i632               ; get offset to local __ptr ptr
lw $r252 $$locbase i79                  ; load word
addi $r253 $$locbase i656               ; get offset to local __ptr ptr
lw $r254 $$locbase i82                  ; load word
movi $r256 i31                          ; initialize constant into register
addi $r255 $r254 i0
meq $r255 $r252 $r255 $r256
move $r257 $r255                        ; return value from ASM block with return register r
addi $r258 $$locbase i720               ; get offset to local __ptr bool
 sb $r258 $r257 i0                       ; store byte
 sb $r258 $r255 i0                       ; store byte
addi $r259 $$locbase i720               ; get offset to local __ptr bool
lb $r260 $r259 i0                       ; load byte
jnzi $r260 .76
ji  .75
.75
addi $r261 $$locbase i608               ; get offset to local __ptr u64
addi $r262 $$locbase i1000              ; get offset to local __ptr u64
mcpi $r262 $r261 i8                     ; copy memory
addi $r263 $$locbase i864               ; get offset to local __ptr u64
movi $r264 i34                          ; initialize constant into register
sw $$locbase $r264 i108                 ; store word
addi $r265 $$locbase i1000              ; get offset to local __ptr u64
lw $r266 $$locbase i125                 ; load word
addi $r267 $$locbase i864               ; get offset to local __ptr u64
lw $r268 $$locbase i108                 ; load word
eq $r269 $r266 $r268
jnzi $r269 .77
ji  .78
.77
addi $r270 $$locbase i632               ; get offset to local __ptr ptr
lw $r271 $$locbase i79                  ; load word
addi $r272 $$locbase i656               ; get offset to local __ptr ptr
lw $r273 $$locbase i82                  ; load word
movi $r275 i34                          ; initialize constant into register
addi $r274 $r273 i144
meq $r274 $r271 $r274 $r275
move $r276 $r274                        ; return value from ASM block with return register r
addi $r277 $$locbase i728               ; get offset to local __ptr bool
 sb $r277 $r276 i0                       ; store byte
 sb $r277 $r274 i0                       ; store byte
addi $r278 $$locbase i728               ; get offset to local __ptr bool
lb $r279 $r278 i0                       ; load byte
jnzi $r279 .79
ji  .78
.78
addi $r280 $$locbase i608               ; get offset to local __ptr u64
addi $r281 $$locbase i1008              ; get offset to local __ptr u64
mcpi $r281 $r280 i8                     ; copy memory
addi $r282 $$locbase i872               ; get offset to local __ptr u64
movi $r283 i37                          ; initialize constant into register
sw $$locbase $r283 i109                 ; store word
addi $r284 $$locbase i1008              ; get offset to local __ptr u64
lw $r285 $$locbase i126                 ; load word
addi $r286 $$locbase i872               ; get offset to local __ptr u64
lw $r287 $$locbase i109                 ; load word
eq $r288 $r285 $r287
jnzi $r288 .80
ji  .81
.80
addi $r289 $$locbase i632               ; get offset to local __ptr ptr
lw $r290 $$locbase i79                  ; load word
addi $r291 $$locbase i656               ; get offset to local __ptr ptr
lw $r292 $$locbase i82                  ; load word
movi $r294 i37                          ; initialize constant into register
addi $r293 $r292 i352
meq $r293 $r290 $r293 $r294
move $r295 $r293                        ; return value from ASM block with return register r
addi $r296 $$locbase i736               ; get offset to local __ptr bool
 sb $r296 $r295 i0                       ; store byte
 sb $r296 $r293 i0                       ; store byte
addi $r297 $$locbase i736               ; get offset to local __ptr bool
lb $r298 $r297 i0                       ; load byte
jnzi $r298 .82
ji  .81
.81
addi $r299 $$locbase i608               ; get offset to local __ptr u64
addi $r300 $$locbase i1016              ; get offset to local __ptr u64
mcpi $r300 $r299 i8                     ; copy memory
addi $r301 $$locbase i880               ; get offset to local __ptr u64
movi $r302 i39                          ; initialize constant into register
sw $$locbase $r302 i110                 ; store word
addi $r303 $$locbase i1016              ; get offset to local __ptr u64
lw $r304 $$locbase i127                 ; load word
addi $r305 $$locbase i880               ; get offset to local __ptr u64
lw $r306 $$locbase i110                 ; load word
eq $r307 $r304 $r306
jnzi $r307 .83
ji  .84
.83
addi $r308 $$locbase i632               ; get offset to local __ptr ptr
lw $r309 $$locbase i79                  ; load word
addi $r310 $$locbase i656               ; get offset to local __ptr ptr
lw $r311 $$locbase i82                  ; load word
movi $r313 i39                          ; initialize constant into register
addi $r312 $r311 i56
meq $r312 $r309 $r312 $r313
move $r314 $r312                        ; return value from ASM block with return register r
addi $r315 $$locbase i744               ; get offset to local __ptr bool
 sb $r315 $r314 i0                       ; store byte
 sb $r315 $r312 i0                       ; store byte
addi $r316 $$locbase i744               ; get offset to local __ptr bool
lb $r317 $r316 i0                       ; load byte
jnzi $r317 .85
ji  .84
.84
addi $r318 $$locbase i608               ; get offset to local __ptr u64
addi $r319 $$locbase i1024              ; get offset to local __ptr u64
mcpi $r319 $r318 i8                     ; copy memory
addi $r320 $$locbase i888               ; get offset to local __ptr u64
movi $r321 i40                          ; initialize constant into register
sw $$locbase $r321 i111                 ; store word
addi $r322 $$locbase i1024              ; get offset to local __ptr u64
lw $r323 $$locbase i128                 ; load word
addi $r324 $$locbase i888               ; get offset to local __ptr u64
lw $r325 $$locbase i111                 ; load word
eq $r326 $r323 $r325
jnzi $r326 .86
ji  .87
.86
addi $r327 $$locbase i632               ; get offset to local __ptr ptr
lw $r328 $$locbase i79                  ; load word
addi $r329 $$locbase i656               ; get offset to local __ptr ptr
lw $r330 $$locbase i82                  ; load word
movi $r332 i40                          ; initialize constant into register
addi $r331 $r330 i292
meq $r331 $r328 $r331 $r332
move $r333 $r331                        ; return value from ASM block with return register r
addi $r334 $$locbase i752               ; get offset to local __ptr bool
 sb $r334 $r333 i0                       ; store byte
 sb $r334 $r331 i0                       ; store byte
addi $r335 $$locbase i752               ; get offset to local __ptr bool
lb $r336 $r335 i0                       ; load byte
jnzi $r336 .88
ji  .87
.87
addi $r337 $$locbase i608               ; get offset to local __ptr u64
addi $r338 $$locbase i1032              ; get offset to local __ptr u64
mcpi $r338 $r337 i8                     ; copy memory
addi $r339 $$locbase i808               ; get offset to local __ptr u64
movi $r340 i41                          ; initialize constant into register
sw $$locbase $r340 i101                 ; store word
addi $r341 $$locbase i1032              ; get offset to local __ptr u64
lw $r342 $$locbase i129                 ; load word
addi $r343 $$locbase i808               ; get offset to local __ptr u64
lw $r344 $$locbase i101                 ; load word
eq $r345 $r342 $r344
jnzi $r345 .89
ji  .90
.89
addi $r346 $$locbase i632               ; get offset to local __ptr ptr
lw $r347 $$locbase i79                  ; load word
addi $r348 $$locbase i656               ; get offset to local __ptr ptr
lw $r349 $$locbase i82                  ; load word
movi $r351 i41                          ; initialize constant into register
addi $r350 $r349 i413
meq $r350 $r347 $r350 $r351
move $r352 $r350                        ; return value from ASM block with return register r
addi $r353 $$locbase i760               ; get offset to local __ptr bool
 sb $r353 $r352 i0                       ; store byte
 sb $r353 $r350 i0                       ; store byte
addi $r354 $$locbase i760               ; get offset to local __ptr bool
lb $r355 $r354 i0                       ; load byte
jnzi $r355 .91
ji  .90
.90
addi $r356 $$locbase i608               ; get offset to local __ptr u64
addi $r357 $$locbase i1040              ; get offset to local __ptr u64
mcpi $r357 $r356 i8                     ; copy memory
addi $r358 $$locbase i816               ; get offset to local __ptr u64
movi $r359 i49                          ; initialize constant into register
sw $$locbase $r359 i102                 ; store word
addi $r360 $$locbase i1040              ; get offset to local __ptr u64
lw $r361 $$locbase i130                 ; load word
addi $r362 $$locbase i816               ; get offset to local __ptr u64
lw $r363 $$locbase i102                 ; load word
eq $r364 $r361 $r363
jnzi $r364 .92
ji  .93
.92
addi $r365 $$locbase i632               ; get offset to local __ptr ptr
lw $r366 $$locbase i79                  ; load word
addi $r367 $$locbase i656               ; get offset to local __ptr ptr
lw $r368 $$locbase i82                  ; load word
movi $r370 i49                          ; initialize constant into register
addi $r369 $r368 i95
meq $r369 $r366 $r369 $r370
move $r371 $r369                        ; return value from ASM block with return register r
addi $r372 $$locbase i768               ; get offset to local __ptr bool
 sb $r372 $r371 i0                       ; store byte
 sb $r372 $r369 i0                       ; store byte
addi $r373 $$locbase i768               ; get offset to local __ptr bool
lb $r374 $r373 i0                       ; load byte
jnzi $r374 .94
ji  .93
.93
addi $r375 $$locbase i608               ; get offset to local __ptr u64
addi $r376 $$locbase i1048              ; get offset to local __ptr u64
mcpi $r376 $r375 i8                     ; copy memory
addi $r377 $$locbase i824               ; get offset to local __ptr u64
movi $r378 i69                          ; initialize constant into register
sw $$locbase $r378 i103                 ; store word
addi $r379 $$locbase i1048              ; get offset to local __ptr u64
lw $r380 $$locbase i131                 ; load word
addi $r381 $$locbase i824               ; get offset to local __ptr u64
lw $r382 $$locbase i103                 ; load word
eq $r383 $r380 $r382
jnzi $r383 .95
ji  .96
.95
addi $r384 $$locbase i632               ; get offset to local __ptr ptr
lw $r385 $$locbase i79                  ; load word
addi $r386 $$locbase i656               ; get offset to local __ptr ptr
lw $r387 $$locbase i82                  ; load word
movi $r389 i69                          ; initialize constant into register
addi $r388 $r387 i178
meq $r388 $r385 $r388 $r389
move $r390 $r388                        ; return value from ASM block with return register r
addi $r391 $$locbase i776               ; get offset to local __ptr bool
 sb $r391 $r390 i0                       ; store byte
 sb $r391 $r388 i0                       ; store byte
addi $r392 $$locbase i776               ; get offset to local __ptr bool
lb $r393 $r392 i0                       ; load byte
jnzi $r393 .97
ji  .96
.96
movi $r394 i123                         ; initialize constant into register
rvrt $r394
.97
addi $r395 $$locbase i360               ; get offset to local __ptr u64
movi $r396 i28                          ; initialize constant into register
sw $$locbase $r396 i45                  ; store word
addi $r397 $$locbase i200               ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
sw $$locbase $one i25                   ; store word
addi $r398 $r397 i55                    ; get offset to aggregate element
movi $r399 i42                          ; initialize constant into register
sb $r398 $r399 i0                       ; store byte
movi $r400 i28                          ; initialize constant into register
movi $r401 i11                          ; initialize constant into register
sll $r402 $r400 $r401
movi $r403 i27                          ; initialize constant into register
or $r404 $r402 $r403
addi $r405 $$locbase i1184              ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
mcpi $r405 $r397 i56                    ; copy memory
addi $r406 $$locbase i336               ; get offset to local __ptr u64
sw $$locbase $r404 i42                  ; store word
addi $r407 $$locbase i1184              ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
addi $r408 $$locbase i512               ; get offset to local __ptr slice
move $$arg0 $r407                       ; [call]: pass argument 0
move $$arg1 $r408                       ; [call]: pass argument 1
fncall .6                               ; [call]: call encode_allow_alias_12
 move $r409 $zero                        ; [call]: return unit value
 movi $r409 i0                           ; [call]: return unit value
addi $r410 $$locbase i464               ; get offset to local __ptr slice
mcpi $r410 $r408 i16                    ; copy memory
load $r411 data_NonConfigurable_1       ; load constant from data section
lw $r412 $$locbase i58                  ; load slice pointer for logging data
lw $r413 $$locbase i59                  ; load slice size for logging data
logd $zero $r411 $r412 $r413            ; log slice
load $r414 data_NonConfigurable_2       ; load constant from data section
and $r415 $r404 $r414
load $r416 data_NonConfigurable_3       ; load constant from data section
or $r417 $r416 $r415
rvrt $r417
.94
addi $r418 $$locbase i352               ; get offset to local __ptr u64
movi $r419 i26                          ; initialize constant into register
sw $$locbase $r419 i44                  ; store word
addr $r420 data_NonConfigurable_4       ; get __const_global7's address in data section
addi $r421 $$locbase i184               ; get offset to local __ptr { ptr, u64 }
sw $$locbase $r420 i23                  ; store word
addi $r422 $r421 i8                     ; get offset to aggregate element
movi $r423 i35                          ; initialize constant into register
sw $$locbase $r423 i24                  ; store word
addi $r424 $$locbase i288               ; get offset to local __ptr slice
mcpi $r424 $r421 i16                    ; copy memory
movi $r425 i26                          ; initialize constant into register
movi $r426 i11                          ; initialize constant into register
sll $r427 $r425 $r426
movi $r428 i25                          ; initialize constant into register
or $r429 $r427 $r428
addi $r430 $$locbase i552               ; get offset to local __ptr slice
mcpi $r430 $r424 i16                    ; copy memory
move $$arg0 $r430                       ; [call]: pass argument 0
move $$arg1 $r429                       ; [call]: pass argument 1
fncall .16                              ; [call]: call generic_panic_41
 move $r431 $zero                        ; [call]: return unit value
 movi $r431 i0                           ; [call]: return unit value
addi $r432 $$locbase i664               ; get offset to local __ptr ()
 move $r433 $zero                        ; return value from ASM block with return register zero
 retd $r433 $zero
 movi $r433 i0                           ; return value from ASM block with return register zero
 retd $zero $zero
.91
addi $r434 $$locbase i424               ; get offset to local __ptr u64
movi $r435 i24                          ; initialize constant into register
sw $$locbase $r435 i53                  ; store word
movi $r436 i24                          ; initialize constant into register
movi $r437 i11                          ; initialize constant into register
sll $r438 $r436 $r437
movi $r439 i23                          ; initialize constant into register
or $r440 $r438 $r439
move $$arg0 $r440                       ; [call]: pass argument 0
fncall .20                              ; [call]: call call_nested_panic_non_inlined_48
 move $r441 $zero                        ; [call]: return unit value
 movi $r441 i0                           ; [call]: return unit value
addi $r442 $$locbase i664               ; get offset to local __ptr ()
 move $r443 $zero                        ; return value from ASM block with return register zero
 retd $r443 $zero
 movi $r443 i0                           ; return value from ASM block with return register zero
 retd $zero $zero
.88
addi $r444 $$locbase i416               ; get offset to local __ptr u64
movi $r445 i22                          ; initialize constant into register
sw $$locbase $r445 i52                  ; store word
movi $r446 i22                          ; initialize constant into register
movi $r447 i11                          ; initialize constant into register
sll $r448 $r446 $r447
movi $r449 i21                          ; initialize constant into register
or $r450 $r448 $r449
 move $$arg0 $zero                       ; [call]: pass argument 0
 movi $$arg0 i0                          ; [call]: pass argument 0
move $$arg1 $r450                       ; [call]: pass argument 1
fncall .18                              ; [call]: call generic_panic_44
 move $r451 $zero                        ; [call]: return unit value
 movi $r451 i0                           ; [call]: return unit value
addi $r452 $$locbase i664               ; get offset to local __ptr ()
 move $r453 $zero                        ; return value from ASM block with return register zero
 retd $r453 $zero
 movi $r453 i0                           ; return value from ASM block with return register zero
 retd $zero $zero
.85
addi $r454 $$locbase i408               ; get offset to local __ptr u64
movi $r455 i20                          ; initialize constant into register
sw $$locbase $r455 i51                  ; store word
movi $r456 i20                          ; initialize constant into register
movi $r457 i11                          ; initialize constant into register
sll $r458 $r456 $r457
movi $r459 i17                          ; initialize constant into register
or $r460 $r458 $r459
addi $r461 $$locbase i328               ; get offset to local __ptr u64
sw $$locbase $r460 i41                  ; store word
load $r462 data_NonConfigurable_2       ; load constant from data section
and $r463 $r460 $r462
load $r464 data_NonConfigurable_5       ; load constant from data section
or $r465 $r464 $r463
rvrt $r465
.82
addi $r466 $$locbase i400               ; get offset to local __ptr u64
movi $r467 i16                          ; initialize constant into register
sw $$locbase $r467 i50                  ; store word
movi $r468 i16                          ; initialize constant into register
movi $r469 i11                          ; initialize constant into register
sll $r470 $r468 $r469
movi $r471 i15                          ; initialize constant into register
or $r472 $r470 $r471
move $$arg0 $r472                       ; [call]: pass argument 0
fncall .4                               ; [call]: call call_nested_panic_inlined_10
 move $r473 $zero                        ; [call]: return unit value
 movi $r473 i0                           ; [call]: return unit value
addi $r474 $$locbase i664               ; get offset to local __ptr ()
 move $r475 $zero                        ; return value from ASM block with return register zero
 retd $r475 $zero
 movi $r475 i0                           ; return value from ASM block with return register zero
 retd $zero $zero
.79
addi $r476 $$locbase i392               ; get offset to local __ptr u64
movi $r477 i14                          ; initialize constant into register
sw $$locbase $r477 i49                  ; store word
addi $r478 $$locbase i128               ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
sw $$locbase $zero i16                  ; store word
movi $r479 i14                          ; initialize constant into register
movi $r480 i11                          ; initialize constant into register
sll $r481 $r479 $r480
movi $r482 i13                          ; initialize constant into register
or $r483 $r481 $r482
addi $r484 $$locbase i1128              ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
mcpi $r484 $r478 i56                    ; copy memory
addi $r485 $$locbase i320               ; get offset to local __ptr u64
sw $$locbase $r483 i40                  ; store word
addi $r486 $$locbase i1128              ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
addi $r487 $$locbase i496               ; get offset to local __ptr slice
move $$arg0 $r486                       ; [call]: pass argument 0
move $$arg1 $r487                       ; [call]: pass argument 1
fncall .6                               ; [call]: call encode_allow_alias_12
 move $r488 $zero                        ; [call]: return unit value
 movi $r488 i0                           ; [call]: return unit value
addi $r489 $$locbase i448               ; get offset to local __ptr slice
mcpi $r489 $r487 i16                    ; copy memory
load $r490 data_NonConfigurable_1       ; load constant from data section
lw $r491 $$locbase i56                  ; load slice pointer for logging data
lw $r492 $$locbase i57                  ; load slice size for logging data
logd $zero $r490 $r491 $r492            ; log slice
load $r493 data_NonConfigurable_2       ; load constant from data section
and $r494 $r483 $r493
load $r495 data_NonConfigurable_3       ; load constant from data section
or $r496 $r495 $r494
rvrt $r496
.76
addi $r497 $$locbase i384               ; get offset to local __ptr u64
movi $r498 i12                          ; initialize constant into register
sw $$locbase $r498 i48                  ; store word
movi $r499 i12                          ; initialize constant into register
load $r500 data_NonConfigurable_2       ; load constant from data section
and $r501 $r499 $r500
load $r502 data_NonConfigurable_6       ; load constant from data section
or $r503 $r502 $r501
rvrt $r503
.73
addi $r504 $$locbase i376               ; get offset to local __ptr u64
movi $r505 i11                          ; initialize constant into register
sw $$locbase $r505 i47                  ; store word
addi $r506 $$locbase i72                ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
movi $r507 i2                           ; initialize constant into register
sw $$locbase $r507 i9                   ; store word
addi $r508 $r506 i55                    ; get offset to aggregate element
sb $r508 $one i0                        ; store byte
addi $r509 $$locbase i480               ; get offset to local __ptr slice
move $$arg0 $r506                       ; [call]: pass argument 0
move $$arg1 $r509                       ; [call]: pass argument 1
fncall .6                               ; [call]: call encode_allow_alias_12
 move $r510 $zero                        ; [call]: return unit value
 movi $r510 i0                           ; [call]: return unit value
addi $r511 $$locbase i432               ; get offset to local __ptr slice
mcpi $r511 $r509 i16                    ; copy memory
load $r512 data_NonConfigurable_1       ; load constant from data section
lw $r513 $$locbase i54                  ; load slice pointer for logging data
lw $r514 $$locbase i55                  ; load slice size for logging data
logd $zero $r512 $r513 $r514            ; log slice
movi $r515 i11                          ; initialize constant into register
load $r516 data_NonConfigurable_2       ; load constant from data section
and $r517 $r515 $r516
load $r518 data_NonConfigurable_7       ; load constant from data section
or $r519 $r518 $r517
rvrt $r519
.70
addi $r520 $$locbase i368               ; get offset to local __ptr u64
movi $r521 i10                          ; initialize constant into register
sw $$locbase $r521 i46                  ; store word
movi $r522 i10                          ; initialize constant into register
movi $r523 i11                          ; initialize constant into register
sll $r524 $r522 $r523
movi $r525 i9                           ; initialize constant into register
or $r526 $r524 $r525
move $$arg0 $r526                       ; [call]: pass argument 0
fncall .20                              ; [call]: call call_nested_panic_non_inlined_48
 move $r527 $zero                        ; [call]: return unit value
 movi $r527 i0                           ; [call]: return unit value
addi $r528 $$locbase i664               ; get offset to local __ptr ()
 move $r529 $zero                        ; return value from ASM block with return register zero
 retd $r529 $zero
 movi $r529 i0                           ; return value from ASM block with return register zero
 retd $zero $zero
.67
addi $r530 $$locbase i344               ; get offset to local __ptr u64
movi $r531 i7                           ; initialize constant into register
sw $$locbase $r531 i43                  ; store word
movi $r532 i7                           ; initialize constant into register
movi $r533 i11                          ; initialize constant into register
sll $r534 $r532 $r533
movi $r535 i6                           ; initialize constant into register
or $r536 $r534 $r535
 move $$arg0 $zero                       ; [call]: pass argument 0
 movi $$arg0 i0                          ; [call]: pass argument 0
move $$arg1 $r536                       ; [call]: pass argument 1
fncall .18                              ; [call]: call generic_panic_44
 move $r537 $zero                        ; [call]: return unit value
 movi $r537 i0                           ; [call]: return unit value
addi $r538 $$locbase i664               ; get offset to local __ptr ()
 move $r539 $zero                        ; return value from ASM block with return register zero
 retd $r539 $zero
 movi $r539 i0                           ; return value from ASM block with return register zero
 retd $zero $zero
.64
addi $r540 $$locbase i312               ; get offset to local __ptr u64
movi $r541 i5                           ; initialize constant into register
sw $$locbase $r541 i39                  ; store word
addr $r542 data_NonConfigurable_8       ; get __const_global3's address in data section
addi $r543 $$locbase i56                ; get offset to local __ptr { ptr, u64 }
sw $$locbase $r542 i7                   ; store word
addi $r544 $r543 i8                     ; get offset to aggregate element
movi $r545 i25                          ; initialize constant into register
sw $$locbase $r545 i8                   ; store word
addi $r546 $$locbase i272               ; get offset to local __ptr slice
mcpi $r546 $r543 i16                    ; copy memory
movi $r547 i5                           ; initialize constant into register
movi $r548 i11                          ; initialize constant into register
sll $r549 $r547 $r548
movi $r550 i4                           ; initialize constant into register
or $r551 $r549 $r550
addi $r552 $$locbase i536               ; get offset to local __ptr slice
mcpi $r552 $r546 i16                    ; copy memory
move $$arg0 $r552                       ; [call]: pass argument 0
move $$arg1 $r551                       ; [call]: pass argument 1
fncall .16                              ; [call]: call generic_panic_41
 move $r553 $zero                        ; [call]: return unit value
 movi $r553 i0                           ; [call]: return unit value
addi $r554 $$locbase i664               ; get offset to local __ptr ()
 move $r555 $zero                        ; return value from ASM block with return register zero
 retd $r555 $zero
 movi $r555 i0                           ; return value from ASM block with return register zero
 retd $zero $zero
.61
addi $r556 $$locbase i304               ; get offset to local __ptr u64
movi $r557 i3                           ; initialize constant into register
sw $$locbase $r557 i38                  ; store word
movi $r558 i3                           ; initialize constant into register
movi $r559 i11                          ; initialize constant into register
sll $r560 $r558 $r559
movi $r561 i2                           ; initialize constant into register
or $r562 $r560 $r561
move $$arg0 $r562                       ; [call]: pass argument 0
fncall .4                               ; [call]: call call_nested_panic_inlined_10
 move $r563 $zero                        ; [call]: return unit value
 movi $r563 i0                           ; [call]: return unit value
addi $r564 $$locbase i664               ; get offset to local __ptr ()
 move $r565 $zero                        ; return value from ASM block with return register zero
 retd $r565 $zero
 movi $r565 i0                           ; return value from ASM block with return register zero
 retd $zero $zero
DIFF------------------------------
.program:
.24                                     ; --- start of function: test_panicking_in_contract_self_impl ---
move $$locbase $sp                      ; save locals base register for function test_panicking_in_contract_self_impl
cfei i64                                ; allocate 64 bytes for locals and 0 slots for call arguments
.165
addr $r1189 data_NonConfigurable_25     ; get panicking_contract::CONTRACT_ID's address in data section
addr $r1190 data_NonConfigurable_26     ; get __const_global8's address in data section
sw $$locbase $r1190 i0                  ; store word
addi $r1191 $$locbase i8                ; get offset to aggregate element
movi $r1192 i39                         ; initialize constant into register
sw $$locbase $r1192 i1                  ; store word
addi $r1193 $$locbase i16               ; get offset to local __ptr slice
mcpi $r1193 $$locbase i16               ; copy memory
addi $r1194 $$locbase i32               ; get offset to local __ptr b256
mcpi $r1194 $r1189 i32                  ; copy memory
addi $r1195 $$locbase i16               ; get offset to local __ptr slice
load $r1196 data_NonConfigurable_24     ; get local constant
move $$arg0 $r1194                      ; [call]: pass argument 0
move $$arg1 $r1195                      ; [call]: pass argument 1
 move $$arg2 $zero                       ; [call]: pass argument 2
 move $$arg3 $zero                       ; [call]: pass argument 3
 movi $$arg2 i0                          ; [call]: pass argument 2
 movi $$arg3 i0                          ; [call]: pass argument 3
move $$arg4 $r1196                      ; [call]: pass argument 4
load $r1197 data_NonConfigurable_27     ; load constant from data section
move $$arg5 $r1197                      ; [call]: pass argument 5
fncall .26                              ; [call]: call contract_call_63
 move $r1198 $zero                       ; [call]: return unit value
 movi $r1198 i0                          ; [call]: return unit value
ret $zero                               ; return unit as zero
DIFF------------------------------
.program:
.30                                     ; --- start of function: test_directly_panicking_method ---
move $$locbase $sp                      ; save locals base register for function test_directly_panicking_method
cfei i64                                ; allocate 64 bytes for locals and 0 slots for call arguments
.174
addr $r1289 data_NonConfigurable_25     ; get panicking_contract::CONTRACT_ID's address in data section
addr $r1290 data_NonConfigurable_28     ; get __const_global9's address in data section
sw $$locbase $r1290 i0                  ; store word
addi $r1291 $$locbase i8                ; get offset to aggregate element
movi $r1292 i33                         ; initialize constant into register
sw $$locbase $r1292 i1                  ; store word
addi $r1293 $$locbase i16               ; get offset to local __ptr slice
mcpi $r1293 $$locbase i16               ; copy memory
addi $r1294 $$locbase i32               ; get offset to local __ptr b256
mcpi $r1294 $r1289 i32                  ; copy memory
addi $r1295 $$locbase i16               ; get offset to local __ptr slice
load $r1296 data_NonConfigurable_24     ; get local constant
move $$arg0 $r1294                      ; [call]: pass argument 0
move $$arg1 $r1295                      ; [call]: pass argument 1
 move $$arg2 $zero                       ; [call]: pass argument 2
 move $$arg3 $zero                       ; [call]: pass argument 3
 movi $$arg2 i0                          ; [call]: pass argument 2
 movi $$arg3 i0                          ; [call]: pass argument 3
move $$arg4 $r1296                      ; [call]: pass argument 4
load $r1297 data_NonConfigurable_27     ; load constant from data section
move $$arg5 $r1297                      ; [call]: pass argument 5
fncall .26                              ; [call]: call contract_call_63
 move $r1298 $zero                       ; [call]: return unit value
 movi $r1298 i0                          ; [call]: return unit value
ret $zero                               ; return unit as zero
DIFF------------------------------
.program:
.32                                     ; --- start of function: test_nested_panic_inlined ---
move $$locbase $sp                      ; save locals base register for function test_nested_panic_inlined
cfei i64                                ; allocate 64 bytes for locals and 0 slots for call arguments
.175
addr $r1300 data_NonConfigurable_25     ; get panicking_contract::CONTRACT_ID's address in data section
addr $r1301 data_NonConfigurable_29     ; get __const_global10's address in data section
sw $$locbase $r1301 i0                  ; store word
addi $r1302 $$locbase i8                ; get offset to aggregate element
movi $r1303 i28                         ; initialize constant into register
sw $$locbase $r1303 i1                  ; store word
addi $r1304 $$locbase i16               ; get offset to local __ptr slice
mcpi $r1304 $$locbase i16               ; copy memory
addi $r1305 $$locbase i32               ; get offset to local __ptr b256
mcpi $r1305 $r1300 i32                  ; copy memory
addi $r1306 $$locbase i16               ; get offset to local __ptr slice
load $r1307 data_NonConfigurable_24     ; get local constant
move $$arg0 $r1305                      ; [call]: pass argument 0
move $$arg1 $r1306                      ; [call]: pass argument 1
 move $$arg2 $zero                       ; [call]: pass argument 2
 move $$arg3 $zero                       ; [call]: pass argument 3
 movi $$arg2 i0                          ; [call]: pass argument 2
 movi $$arg3 i0                          ; [call]: pass argument 3
move $$arg4 $r1307                      ; [call]: pass argument 4
load $r1308 data_NonConfigurable_27     ; load constant from data section
move $$arg5 $r1308                      ; [call]: pass argument 5
fncall .26                              ; [call]: call contract_call_63
 move $r1309 $zero                       ; [call]: return unit value
 movi $r1309 i0                          ; [call]: return unit value
ret $zero                               ; return unit as zero
DIFF------------------------------
.program:
.34                                     ; --- start of function: test_nested_panic_inlined_same_revert_code ---
move $$locbase $sp                      ; save locals base register for function test_nested_panic_inlined_same_revert_code
cfei i64                                ; allocate 64 bytes for locals and 0 slots for call arguments
.176
addr $r1311 data_NonConfigurable_25     ; get panicking_contract::CONTRACT_ID's address in data section
addr $r1312 data_NonConfigurable_30     ; get __const_global11's address in data section
sw $$locbase $r1312 i0                  ; store word
addi $r1313 $$locbase i8                ; get offset to aggregate element
movi $r1314 i28                         ; initialize constant into register
sw $$locbase $r1314 i1                  ; store word
addi $r1315 $$locbase i16               ; get offset to local __ptr slice
mcpi $r1315 $$locbase i16               ; copy memory
addi $r1316 $$locbase i32               ; get offset to local __ptr b256
mcpi $r1316 $r1311 i32                  ; copy memory
addi $r1317 $$locbase i16               ; get offset to local __ptr slice
load $r1318 data_NonConfigurable_24     ; get local constant
move $$arg0 $r1316                      ; [call]: pass argument 0
move $$arg1 $r1317                      ; [call]: pass argument 1
 move $$arg2 $zero                       ; [call]: pass argument 2
 move $$arg3 $zero                       ; [call]: pass argument 3
 movi $$arg2 i0                          ; [call]: pass argument 2
 movi $$arg3 i0                          ; [call]: pass argument 3
move $$arg4 $r1318                      ; [call]: pass argument 4
load $r1319 data_NonConfigurable_27     ; load constant from data section
move $$arg5 $r1319                      ; [call]: pass argument 5
fncall .26                              ; [call]: call contract_call_63
 move $r1320 $zero                       ; [call]: return unit value
 movi $r1320 i0                          ; [call]: return unit value
ret $zero                               ; return unit as zero
DIFF------------------------------
.program:
.36                                     ; --- start of function: test_nested_panic_non_inlined ---
move $$locbase $sp                      ; save locals base register for function test_nested_panic_non_inlined
cfei i64                                ; allocate 64 bytes for locals and 0 slots for call arguments
.177
addr $r1322 data_NonConfigurable_25     ; get panicking_contract::CONTRACT_ID's address in data section
addr $r1323 data_NonConfigurable_31     ; get __const_global12's address in data section
sw $$locbase $r1323 i0                  ; store word
addi $r1324 $$locbase i8                ; get offset to aggregate element
movi $r1325 i32                         ; initialize constant into register
sw $$locbase $r1325 i1                  ; store word
addi $r1326 $$locbase i16               ; get offset to local __ptr slice
mcpi $r1326 $$locbase i16               ; copy memory
addi $r1327 $$locbase i32               ; get offset to local __ptr b256
mcpi $r1327 $r1322 i32                  ; copy memory
addi $r1328 $$locbase i16               ; get offset to local __ptr slice
load $r1329 data_NonConfigurable_24     ; get local constant
move $$arg0 $r1327                      ; [call]: pass argument 0
move $$arg1 $r1328                      ; [call]: pass argument 1
 move $$arg2 $zero                       ; [call]: pass argument 2
 move $$arg3 $zero                       ; [call]: pass argument 3
 movi $$arg2 i0                          ; [call]: pass argument 2
 movi $$arg3 i0                          ; [call]: pass argument 3
move $$arg4 $r1329                      ; [call]: pass argument 4
load $r1330 data_NonConfigurable_27     ; load constant from data section
move $$arg5 $r1330                      ; [call]: pass argument 5
fncall .26                              ; [call]: call contract_call_63
 move $r1331 $zero                       ; [call]: return unit value
 movi $r1331 i0                          ; [call]: return unit value
ret $zero                               ; return unit as zero
DIFF------------------------------
.program:
.38                                     ; --- start of function: test_nested_panic_non_inlined_same_revert_code ---
move $$locbase $sp                      ; save locals base register for function test_nested_panic_non_inlined_same_revert_code
cfei i64                                ; allocate 64 bytes for locals and 0 slots for call arguments
.178
addr $r1333 data_NonConfigurable_25     ; get panicking_contract::CONTRACT_ID's address in data section
addr $r1334 data_NonConfigurable_32     ; get __const_global13's address in data section
sw $$locbase $r1334 i0                  ; store word
addi $r1335 $$locbase i8                ; get offset to aggregate element
movi $r1336 i32                         ; initialize constant into register
sw $$locbase $r1336 i1                  ; store word
addi $r1337 $$locbase i16               ; get offset to local __ptr slice
mcpi $r1337 $$locbase i16               ; copy memory
addi $r1338 $$locbase i32               ; get offset to local __ptr b256
mcpi $r1338 $r1333 i32                  ; copy memory
addi $r1339 $$locbase i16               ; get offset to local __ptr slice
load $r1340 data_NonConfigurable_24     ; get local constant
move $$arg0 $r1338                      ; [call]: pass argument 0
move $$arg1 $r1339                      ; [call]: pass argument 1
 move $$arg2 $zero                       ; [call]: pass argument 2
 move $$arg3 $zero                       ; [call]: pass argument 3
 movi $$arg2 i0                          ; [call]: pass argument 2
 movi $$arg3 i0                          ; [call]: pass argument 3
move $$arg4 $r1340                      ; [call]: pass argument 4
load $r1341 data_NonConfigurable_27     ; load constant from data section
move $$arg5 $r1341                      ; [call]: pass argument 5
fncall .26                              ; [call]: call contract_call_63
 move $r1342 $zero                       ; [call]: return unit value
 movi $r1342 i0                          ; [call]: return unit value
ret $zero                               ; return unit as zero
DIFF------------------------------
.program:
.40                                     ; --- start of function: test_generic_panic_with_unit ---
move $$locbase $sp                      ; save locals base register for function test_generic_panic_with_unit
cfei i64                                ; allocate 64 bytes for locals and 0 slots for call arguments
.179
addr $r1344 data_NonConfigurable_25     ; get panicking_contract::CONTRACT_ID's address in data section
addr $r1345 data_NonConfigurable_33     ; get __const_global14's address in data section
sw $$locbase $r1345 i0                  ; store word
addi $r1346 $$locbase i8                ; get offset to aggregate element
movi $r1347 i31                         ; initialize constant into register
sw $$locbase $r1347 i1                  ; store word
addi $r1348 $$locbase i16               ; get offset to local __ptr slice
mcpi $r1348 $$locbase i16               ; copy memory
addi $r1349 $$locbase i32               ; get offset to local __ptr b256
mcpi $r1349 $r1344 i32                  ; copy memory
addi $r1350 $$locbase i16               ; get offset to local __ptr slice
load $r1351 data_NonConfigurable_24     ; get local constant
move $$arg0 $r1349                      ; [call]: pass argument 0
move $$arg1 $r1350                      ; [call]: pass argument 1
 move $$arg2 $zero                       ; [call]: pass argument 2
 move $$arg3 $zero                       ; [call]: pass argument 3
 movi $$arg2 i0                          ; [call]: pass argument 2
 movi $$arg3 i0                          ; [call]: pass argument 3
move $$arg4 $r1351                      ; [call]: pass argument 4
load $r1352 data_NonConfigurable_27     ; load constant from data section
move $$arg5 $r1352                      ; [call]: pass argument 5
fncall .26                              ; [call]: call contract_call_63
 move $r1353 $zero                       ; [call]: return unit value
 movi $r1353 i0                          ; [call]: return unit value
ret $zero                               ; return unit as zero
DIFF------------------------------
.program:
.42                                     ; --- start of function: test_generic_panic_with_unit_same_revert_code ---
move $$locbase $sp                      ; save locals base register for function test_generic_panic_with_unit_same_revert_code
cfei i64                                ; allocate 64 bytes for locals and 0 slots for call arguments
.180
addr $r1355 data_NonConfigurable_25     ; get panicking_contract::CONTRACT_ID's address in data section
addr $r1356 data_NonConfigurable_34     ; get __const_global15's address in data section
sw $$locbase $r1356 i0                  ; store word
addi $r1357 $$locbase i8                ; get offset to aggregate element
movi $r1358 i31                         ; initialize constant into register
sw $$locbase $r1358 i1                  ; store word
addi $r1359 $$locbase i16               ; get offset to local __ptr slice
mcpi $r1359 $$locbase i16               ; copy memory
addi $r1360 $$locbase i32               ; get offset to local __ptr b256
mcpi $r1360 $r1355 i32                  ; copy memory
addi $r1361 $$locbase i16               ; get offset to local __ptr slice
load $r1362 data_NonConfigurable_24     ; get local constant
move $$arg0 $r1360                      ; [call]: pass argument 0
move $$arg1 $r1361                      ; [call]: pass argument 1
 move $$arg2 $zero                       ; [call]: pass argument 2
 move $$arg3 $zero                       ; [call]: pass argument 3
 movi $$arg2 i0                          ; [call]: pass argument 2
 movi $$arg3 i0                          ; [call]: pass argument 3
move $$arg4 $r1362                      ; [call]: pass argument 4
load $r1363 data_NonConfigurable_27     ; load constant from data section
move $$arg5 $r1363                      ; [call]: pass argument 5
fncall .26                              ; [call]: call contract_call_63
 move $r1364 $zero                       ; [call]: return unit value
 movi $r1364 i0                          ; [call]: return unit value
ret $zero                               ; return unit as zero
DIFF------------------------------
.program:
.44                                     ; --- start of function: test_generic_panic_with_str ---
move $$locbase $sp                      ; save locals base register for function test_generic_panic_with_str
cfei i64                                ; allocate 64 bytes for locals and 0 slots for call arguments
.181
addr $r1366 data_NonConfigurable_25     ; get panicking_contract::CONTRACT_ID's address in data section
addr $r1367 data_NonConfigurable_35     ; get __const_global16's address in data section
sw $$locbase $r1367 i0                  ; store word
addi $r1368 $$locbase i8                ; get offset to aggregate element
movi $r1369 i30                         ; initialize constant into register
sw $$locbase $r1369 i1                  ; store word
addi $r1370 $$locbase i16               ; get offset to local __ptr slice
mcpi $r1370 $$locbase i16               ; copy memory
addi $r1371 $$locbase i32               ; get offset to local __ptr b256
mcpi $r1371 $r1366 i32                  ; copy memory
addi $r1372 $$locbase i16               ; get offset to local __ptr slice
load $r1373 data_NonConfigurable_24     ; get local constant
move $$arg0 $r1371                      ; [call]: pass argument 0
move $$arg1 $r1372                      ; [call]: pass argument 1
 move $$arg2 $zero                       ; [call]: pass argument 2
 move $$arg3 $zero                       ; [call]: pass argument 3
 movi $$arg2 i0                          ; [call]: pass argument 2
 movi $$arg3 i0                          ; [call]: pass argument 3
move $$arg4 $r1373                      ; [call]: pass argument 4
load $r1374 data_NonConfigurable_27     ; load constant from data section
move $$arg5 $r1374                      ; [call]: pass argument 5
fncall .26                              ; [call]: call contract_call_63
 move $r1375 $zero                       ; [call]: return unit value
 movi $r1375 i0                          ; [call]: return unit value
ret $zero                               ; return unit as zero
DIFF------------------------------
.program:
.46                                     ; --- start of function: test_generic_panic_with_different_str_same_revert_code ---
move $$locbase $sp                      ; save locals base register for function test_generic_panic_with_different_str_same_revert_code
cfei i64                                ; allocate 64 bytes for locals and 0 slots for call arguments
.182
addr $r1377 data_NonConfigurable_25     ; get panicking_contract::CONTRACT_ID's address in data section
addr $r1378 data_NonConfigurable_36     ; get __const_global17's address in data section
sw $$locbase $r1378 i0                  ; store word
addi $r1379 $$locbase i8                ; get offset to aggregate element
movi $r1380 i57                         ; initialize constant into register
sw $$locbase $r1380 i1                  ; store word
addi $r1381 $$locbase i16               ; get offset to local __ptr slice
mcpi $r1381 $$locbase i16               ; copy memory
addi $r1382 $$locbase i32               ; get offset to local __ptr b256
mcpi $r1382 $r1377 i32                  ; copy memory
addi $r1383 $$locbase i16               ; get offset to local __ptr slice
load $r1384 data_NonConfigurable_24     ; get local constant
move $$arg0 $r1382                      ; [call]: pass argument 0
move $$arg1 $r1383                      ; [call]: pass argument 1
 move $$arg2 $zero                       ; [call]: pass argument 2
 move $$arg3 $zero                       ; [call]: pass argument 3
 movi $$arg2 i0                          ; [call]: pass argument 2
 movi $$arg3 i0                          ; [call]: pass argument 3
move $$arg4 $r1384                      ; [call]: pass argument 4
load $r1385 data_NonConfigurable_27     ; load constant from data section
move $$arg5 $r1385                      ; [call]: pass argument 5
fncall .26                              ; [call]: call contract_call_63
 move $r1386 $zero                       ; [call]: return unit value
 movi $r1386 i0                          ; [call]: return unit value
ret $zero                               ; return unit as zero
DIFF------------------------------
.program:
.48                                     ; --- start of function: test_generic_panic_with_error_type_enum ---
move $$locbase $sp                      ; save locals base register for function test_generic_panic_with_error_type_enum
cfei i64                                ; allocate 64 bytes for locals and 0 slots for call arguments
.183
addr $r1388 data_NonConfigurable_25     ; get panicking_contract::CONTRACT_ID's address in data section
addr $r1389 data_NonConfigurable_37     ; get __const_global18's address in data section
sw $$locbase $r1389 i0                  ; store word
addi $r1390 $$locbase i8                ; get offset to aggregate element
movi $r1391 i42                         ; initialize constant into register
sw $$locbase $r1391 i1                  ; store word
addi $r1392 $$locbase i16               ; get offset to local __ptr slice
mcpi $r1392 $$locbase i16               ; copy memory
addi $r1393 $$locbase i32               ; get offset to local __ptr b256
mcpi $r1393 $r1388 i32                  ; copy memory
addi $r1394 $$locbase i16               ; get offset to local __ptr slice
load $r1395 data_NonConfigurable_24     ; get local constant
move $$arg0 $r1393                      ; [call]: pass argument 0
move $$arg1 $r1394                      ; [call]: pass argument 1
 move $$arg2 $zero                       ; [call]: pass argument 2
 move $$arg3 $zero                       ; [call]: pass argument 3
 movi $$arg2 i0                          ; [call]: pass argument 2
 movi $$arg3 i0                          ; [call]: pass argument 3
move $$arg4 $r1395                      ; [call]: pass argument 4
load $r1396 data_NonConfigurable_27     ; load constant from data section
move $$arg5 $r1396                      ; [call]: pass argument 5
fncall .26                              ; [call]: call contract_call_63
 move $r1397 $zero                       ; [call]: return unit value
 movi $r1397 i0                          ; [call]: return unit value
ret $zero                               ; return unit as zero
DIFF------------------------------
.program:
.50                                     ; --- start of function: test_generic_panic_with_error_type_enum_different_variant_same_revert_code ---
move $$locbase $sp                      ; save locals base register for function test_generic_panic_with_error_type_enum_different_variant_same_revert_code
cfei i64                                ; allocate 64 bytes for locals and 0 slots for call arguments
.184
addr $r1399 data_NonConfigurable_25     ; get panicking_contract::CONTRACT_ID's address in data section
addr $r1400 data_NonConfigurable_38     ; get __const_global19's address in data section
sw $$locbase $r1400 i0                  ; store word
addi $r1401 $$locbase i8                ; get offset to aggregate element
movi $r1402 i77                         ; initialize constant into register
sw $$locbase $r1402 i1                  ; store word
addi $r1403 $$locbase i16               ; get offset to local __ptr slice
mcpi $r1403 $$locbase i16               ; copy memory
addi $r1404 $$locbase i32               ; get offset to local __ptr b256
mcpi $r1404 $r1399 i32                  ; copy memory
addi $r1405 $$locbase i16               ; get offset to local __ptr slice
load $r1406 data_NonConfigurable_24     ; get local constant
move $$arg0 $r1404                      ; [call]: pass argument 0
move $$arg1 $r1405                      ; [call]: pass argument 1
 move $$arg2 $zero                       ; [call]: pass argument 2
 move $$arg3 $zero                       ; [call]: pass argument 3
 movi $$arg2 i0                          ; [call]: pass argument 2
 movi $$arg3 i0                          ; [call]: pass argument 3
move $$arg4 $r1406                      ; [call]: pass argument 4
load $r1407 data_NonConfigurable_27     ; load constant from data section
move $$arg5 $r1407                      ; [call]: pass argument 5
fncall .26                              ; [call]: call contract_call_63
 move $r1408 $zero                       ; [call]: return unit value
 movi $r1408 i0                          ; [call]: return unit value
ret $zero                               ; return unit as zero
DIFF------------------------------
.program:
.2                                      ; --- start of function: read_3 ---
pusha .2                                ; save all registers
move $$locbase $sp                      ; save locals base register for function read_3
cfei i24                                ; allocate 24 bytes for locals and 0 slots for call arguments
.98
addi $r567 $$locbase i8                 ; get offset to local __ptr ptr
sw $$locbase $$arg0 i1                  ; store word
 jnzi $zero .99
 
ji  .100
.100
addi $r568 $$locbase i16                ; get offset to local __ptr u64
movi $r569 i8                           ; initialize constant into register
sw $$locbase $r569 i2                   ; store word
sw $$locbase $one i0                    ; store word
addi $r570 $$locbase i16                ; get offset to local __ptr u64
lw $r571 $$locbase i2                   ; load word
lw $r572 $$locbase i0                   ; load word
eq $r573 $r571 $r572
jnzi $r573 .101
ji  .102
.102
addi $r574 $$locbase i8                 ; get offset to local __ptr ptr
lw $r575 $$locbase i1                   ; load word
lw $r576 $r575 i0                       ; lw val ptr i0
move $r577 $r576                        ; return value from ASM block with return register val
 move $r578 $r577                        ; move parameter from branch to block argument
 move $r578 $r576                        ; move parameter from branch to block argument
ji  .103
.101
addi $r579 $$locbase i8                 ; get offset to local __ptr ptr
lw $r580 $$locbase i1                   ; load word
lb $r581 $r580 i0                       ; lb val ptr i0
move $r582 $r581                        ; return value from ASM block with return register val
 move $r578 $r582                        ; move parameter from branch to block argument
 move $r578 $r581                        ; move parameter from branch to block argument
ji  .103
.103
move $r585 $r578                        ; move parameter from branch to block argument
 move $r586 $r585                        ; move parameter from branch to block argument
 move $r586 $r578                        ; move parameter from branch to block argument
ji  .104
.99
addi $r587 $$locbase i8                 ; get offset to local __ptr ptr
lw $r588 $$locbase i1                   ; load word
move $r589 $r588                        ; return value from ASM block with return register ptr
 move $r586 $r589                        ; move parameter from branch to block argument
 move $r586 $r588                        ; move parameter from branch to block argument
ji  .104
.104
move $r592 $r586                        ; move parameter from branch to block argument
 move $$retv $r592                       ; set return value
 move $$retv $r586                       ; set return value
ji  .3
.3
cfsi i24                                ; free 24 bytes for locals and 0 slots for extra call arguments
popa .2                                 ; restore all registers
jal $zero $$reta i0                     ; return from call
DIFF------------------------------
.program:
.4                                      ; --- start of function: call_nested_panic_inlined_10 ---
pusha .4                                ; save all registers
move $$locbase $sp                      ; save locals base register for function call_nested_panic_inlined_10
cfei i288                               ; allocate 288 bytes for locals and 0 slots for call arguments
move $r593 $$arg0                       ; save argument 0 (__backtrace)
move $r594 $$reta                       ; save return address
.105
movi $r595 i4                           ; initialize constant into register
sw $$locbase $r595 i0                   ; store word
addi $r596 $$locbase i152               ; get offset to local __ptr [slice; 3]
addr $r597 data_NonConfigurable_9       ; get __const_global0's address in data section
addi $r598 $$locbase i56                ; get offset to local __ptr { ptr, u64 }
sw $$locbase $r597 i7                   ; store word
addi $r599 $r598 i8                     ; get offset to aggregate element
movi $r600 i7                           ; initialize constant into register
sw $$locbase $r600 i8                   ; store word
addi $r601 $$locbase i72                ; get offset to local __ptr slice
mcpi $r601 $r598 i16                    ; copy memory
addr $r602 data_NonConfigurable_10      ; get __const_global1's address in data section
addi $r603 $$locbase i88                ; get offset to local __ptr { ptr, u64 }
sw $$locbase $r602 i11                  ; store word
addi $r604 $r603 i8                     ; get offset to aggregate element
movi $r605 i7                           ; initialize constant into register
sw $$locbase $r605 i12                  ; store word
addi $r606 $$locbase i104               ; get offset to local __ptr slice
mcpi $r606 $r603 i16                    ; copy memory
addr $r607 data_NonConfigurable_11      ; get __const_global2's address in data section
addi $r608 $$locbase i120               ; get offset to local __ptr { ptr, u64 }
sw $$locbase $r607 i15                  ; store word
addi $r609 $r608 i8                     ; get offset to aggregate element
movi $r610 i22                          ; initialize constant into register
sw $$locbase $r610 i16                  ; store word
addi $r611 $$locbase i136               ; get offset to local __ptr slice
mcpi $r611 $r608 i16                    ; copy memory
movi $r612 i16                          ; get array element size
 mul $r613 $zero $r612                   ; get offset to array element
 add $r613 $r596 $r613                   ; add array element offset to array base
 movi $r613 i0                           ; get offset to array element
 add $r613 $r596 $zero                   ; add array element offset to array base
mcpi $r613 $r601 i16                    ; copy memory
movi $r614 i16                          ; get array element size
 mul $r615 $one $r614                    ; get offset to array element
 movi $r615 i16                          ; get offset to array element
add $r615 $r596 $r615                   ; add array element offset to array base
mcpi $r615 $r606 i16                    ; copy memory
movi $r616 i16                          ; get array element size
movi $r617 i2                           ; initialize constant into register
 mul $r618 $r617 $r616                   ; get offset to array element
 movi $r618 i32                          ; get offset to array element
add $r618 $r596 $r618                   ; add array element offset to array base
mcpi $r618 $r611 i16                    ; copy memory
addi $r619 $$locbase i8                 ; get offset to aggregate element
mcpi $r619 $r596 i48                    ; copy memory
movi $r620 i11                          ; initialize constant into register
sll $r621 $r593 $r620
or $r622 $r621 $one
addi $r623 $$locbase i232               ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
mcpi $r623 $$locbase i56                ; copy memory
addi $r624 $$locbase i232               ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
addi $r625 $$locbase i216               ; get offset to local __ptr slice
move $$arg0 $r624                       ; [call]: pass argument 0
move $$arg1 $r625                       ; [call]: pass argument 1
fncall .6                               ; [call]: call encode_allow_alias_12
 move $r626 $zero                        ; [call]: return unit value
 movi $r626 i0                           ; [call]: return unit value
addi $r627 $$locbase i200               ; get offset to local __ptr slice
mcpi $r627 $r625 i16                    ; copy memory
load $r628 data_NonConfigurable_1       ; load constant from data section
lw $r629 $$locbase i25                  ; load slice pointer for logging data
lw $r630 $$locbase i26                  ; load slice size for logging data
logd $zero $r628 $r629 $r630            ; log slice
load $r631 data_NonConfigurable_2       ; load constant from data section
and $r632 $r622 $r631
load $r633 data_NonConfigurable_12      ; load constant from data section
or $r634 $r633 $r632
rvrt $r634
.5
cfsi i288                               ; free 288 bytes for locals and 0 slots for extra call arguments
move $$reta $r594                       ; restore return address
popa .4                                 ; restore all registers
jal $zero $$reta i0                     ; return from call
DIFF------------------------------
.program:
.6                                      ; --- start of function: encode_allow_alias_12 ---
pusha .6                                ; save all registers
move $$locbase $sp                      ; save locals base register for function encode_allow_alias_12
cfei i1864                              ; allocate 1864 bytes for locals and 0 slots for call arguments
move $r635 $$arg0                       ; save argument 0 (item)
move $r636 $$arg1                       ; save argument 1 (__ret_value)
move $r637 $$reta                       ; save return address
.106
addi $r638 $$locbase i1488              ; get offset to local __ptr __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
 sw $$locbase $r635 i186                 ; store word
 sw $$locbase $$arg0 i186                ; store word
addi $r639 $$locbase i1568              ; get offset to local __ptr u64
load $r640 data_NonConfigurable_13      ; load constant from data section
sw $$locbase $r640 i196                 ; store word
addi $r641 $$locbase i1496              ; get offset to local __ptr u64
sw $$locbase $zero i187                 ; store word
addi $r642 $$locbase i1568              ; get offset to local __ptr u64
lw $r643 $$locbase i196                 ; load word
addi $r644 $$locbase i1496              ; get offset to local __ptr u64
lw $r645 $$locbase i187                 ; load word
eq $r646 $r643 $r645
move $r647 $r646                        ; move parameter from branch to block argument
jnzi $r646 .107
ji  .108
.107
 move $r647 $one                         ; move parameter from branch to block argument
 movi $r647 i1                           ; move parameter from branch to block argument
ji  .108
.108
move $r650 $r647                        ; move parameter from branch to block argument
 move $r651 $r650                        ; move parameter from branch to block argument
 jnzi $r650 .109
 move $r651 $r647                        ; move parameter from branch to block argument
 jnzi $r647 .109
ji  .110
.109
 move $r651 $one                         ; move parameter from branch to block argument
 movi $r651 i1                           ; move parameter from branch to block argument
ji  .110
.110
move $r654 $r651                        ; move parameter from branch to block argument
 move $r655 $r654                        ; move parameter from branch to block argument
 jnzi $r654 .111
 move $r655 $r651                        ; move parameter from branch to block argument
 jnzi $r651 .111
ji  .112
.111
 move $r655 $one                         ; move parameter from branch to block argument
 movi $r655 i1                           ; move parameter from branch to block argument
ji  .112
.112
move $r658 $r655                        ; move parameter from branch to block argument
 move $r659 $r658                        ; move parameter from branch to block argument
 jnzi $r658 .113
 move $r659 $r655                        ; move parameter from branch to block argument
 jnzi $r655 .113
ji  .114
.113
addi $r660 $$locbase i1576              ; get offset to local __ptr u64
load $r661 data_NonConfigurable_14      ; load constant from data section
sw $$locbase $r661 i197                 ; store word
addi $r662 $$locbase i1504              ; get offset to local __ptr u64
load $r663 data_NonConfigurable_14      ; load constant from data section
sw $$locbase $r663 i188                 ; store word
addi $r664 $$locbase i1576              ; get offset to local __ptr u64
lw $r665 $$locbase i197                 ; load word
addi $r666 $$locbase i1504              ; get offset to local __ptr u64
lw $r667 $$locbase i188                 ; load word
eq $r668 $r665 $r667
move $r669 $r668                        ; move parameter from branch to block argument
jnzi $r668 .115
ji  .116
.115
 move $r669 $one                         ; move parameter from branch to block argument
 movi $r669 i1                           ; move parameter from branch to block argument
ji  .116
.116
move $r672 $r669                        ; move parameter from branch to block argument
 move $r673 $r672                        ; move parameter from branch to block argument
 jnzi $r672 .117
 move $r673 $r669                        ; move parameter from branch to block argument
 jnzi $r669 .117
ji  .118
.117
 move $r673 $one                         ; move parameter from branch to block argument
 movi $r673 i1                           ; move parameter from branch to block argument
ji  .118
.118
move $r676 $r673                        ; move parameter from branch to block argument
 move $r659 $r676                        ; move parameter from branch to block argument
 move $r659 $r673                        ; move parameter from branch to block argument
ji  .114
.114
move $r679 $r659                        ; move parameter from branch to block argument
 move $r680 $r679                        ; move parameter from branch to block argument
 jnzi $r679 .119
 move $r680 $r659                        ; move parameter from branch to block argument
 jnzi $r659 .119
ji  .120
.119
 move $r680 $zero                        ; move parameter from branch to block argument
 movi $r680 i0                           ; move parameter from branch to block argument
ji  .120
.120
move $r683 $r680                        ; move parameter from branch to block argument
 jnzi $r683 .121
 jnzi $r680 .121
ji  .122
.122
addi $r684 $$locbase i1488              ; get offset to local __ptr __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
lw $r685 $$locbase i186                 ; load word
addi $r686 $$locbase i456               ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r686                       ; [call]: pass argument 0
fncall .12                              ; [call]: call new_38
 move $r687 $zero                        ; [call]: return unit value
 movi $r687 i0                           ; [call]: return unit value
addi $r688 $$locbase i1600              ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
mcpi $r688 $r685 i56                    ; copy memory
addi $r689 $$locbase i1072              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r689 $r686 i24                    ; copy memory
addi $r690 $$locbase i1600              ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
addi $r691 $$locbase i208               ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
mcpi $r691 $r690 i56                    ; copy memory
addi $r692 $$locbase i208               ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
addi $r693 $$locbase i1584              ; get offset to local __ptr u64
mcpi $r693 $r692 i8                     ; copy memory
addi $r694 $$locbase i1528              ; get offset to local __ptr u64
sw $$locbase $zero i191                 ; store word
addi $r695 $$locbase i1584              ; get offset to local __ptr u64
lw $r696 $$locbase i198                 ; load word
addi $r697 $$locbase i1528              ; get offset to local __ptr u64
lw $r698 $$locbase i191                 ; load word
eq $r699 $r696 $r698
jnzi $r699 .123
ji  .124
.124
addi $r700 $$locbase i208               ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
addi $r701 $$locbase i1656              ; get offset to local __ptr u64
mcpi $r701 $r700 i8                     ; copy memory
addi $r702 $$locbase i1512              ; get offset to local __ptr u64
sw $$locbase $one i189                  ; store word
addi $r703 $$locbase i1656              ; get offset to local __ptr u64
lw $r704 $$locbase i207                 ; load word
addi $r705 $$locbase i1512              ; get offset to local __ptr u64
lw $r706 $$locbase i189                 ; load word
eq $r707 $r704 $r706
jnzi $r707 .125
ji  .126
.126
addi $r708 $$locbase i208               ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
addi $r709 $$locbase i1680              ; get offset to local __ptr u64
mcpi $r709 $r708 i8                     ; copy memory
addi $r710 $$locbase i1536              ; get offset to local __ptr u64
movi $r711 i2                           ; initialize constant into register
sw $$locbase $r711 i192                 ; store word
addi $r712 $$locbase i1680              ; get offset to local __ptr u64
lw $r713 $$locbase i210                 ; load word
addi $r714 $$locbase i1536              ; get offset to local __ptr u64
lw $r715 $$locbase i192                 ; load word
eq $r716 $r713 $r715
jnzi $r716 .127
ji  .128
.128
addi $r717 $$locbase i208               ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
addi $r718 $$locbase i1696              ; get offset to local __ptr u64
mcpi $r718 $r717 i8                     ; copy memory
addi $r719 $$locbase i1544              ; get offset to local __ptr u64
movi $r720 i3                           ; initialize constant into register
sw $$locbase $r720 i193                 ; store word
addi $r721 $$locbase i1696              ; get offset to local __ptr u64
lw $r722 $$locbase i212                 ; load word
addi $r723 $$locbase i1544              ; get offset to local __ptr u64
lw $r724 $$locbase i193                 ; load word
eq $r725 $r722 $r724
jnzi $r725 .129
ji  .130
.130
addi $r726 $$locbase i208               ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
addi $r727 $$locbase i1720              ; get offset to local __ptr u64
mcpi $r727 $r726 i8                     ; copy memory
addi $r728 $$locbase i1552              ; get offset to local __ptr u64
movi $r729 i4                           ; initialize constant into register
sw $$locbase $r729 i194                 ; store word
addi $r730 $$locbase i1720              ; get offset to local __ptr u64
lw $r731 $$locbase i215                 ; load word
addi $r732 $$locbase i1552              ; get offset to local __ptr u64
lw $r733 $$locbase i194                 ; load word
eq $r734 $r731 $r733
jnzi $r734 .131
ji  .132
.132
load $r735 data_NonConfigurable_15      ; load constant from data section
rvrt $r735
.131
addi $r736 $$locbase i208               ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
addi $r737 $r736 i8                     ; get offset to aggregate element
addi $r738 $$locbase i1816              ; get offset to local __ptr [slice; 3]
mcpi $r738 $r737 i48                    ; copy memory
addi $r739 $$locbase i1072              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r740 $$locbase i688               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r740 $r739 i24                    ; copy memory
addi $r741 $$locbase i408               ; get offset to local __ptr { { ptr, u64, u64 } }
movi $r742 i4                           ; initialize constant into register
 move $$arg0 $r742                       ; [call]: pass argument 0
 movi $$arg0 i4                          ; [call]: pass argument 0
move $$arg1 $r740                       ; [call]: pass argument 1
move $$arg2 $r741                       ; [call]: pass argument 2
fncall .8                               ; [call]: call abi_encode_30
 move $r743 $zero                        ; [call]: return unit value
 movi $r743 i0                           ; [call]: return unit value
addi $r744 $$locbase i1408              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r744 $r741 i24                    ; copy memory
addi $r745 $$locbase i1816              ; get offset to local __ptr [slice; 3]
addi $r746 $$locbase i1408              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r747 $$locbase i1728              ; get offset to local __ptr [slice; 3]
mcpi $r747 $r745 i48                    ; copy memory
addi $r748 $$locbase i1168              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r748 $r746 i24                    ; copy memory
addi $r749 $$locbase i1168              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r750 $$locbase i1240              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r750 $r749 i24                    ; copy memory
addi $r751 $$locbase i1480              ; get offset to local __ptr u64
sw $$locbase $zero i185                 ; store word
ji  .133
.133
addi $r752 $$locbase i1480              ; get offset to local __ptr u64
addi $r753 $$locbase i1592              ; get offset to local __ptr u64
mcpi $r753 $r752 i8                     ; copy memory
addi $r754 $$locbase i1560              ; get offset to local __ptr u64
movi $r755 i3                           ; initialize constant into register
sw $$locbase $r755 i195                 ; store word
addi $r756 $$locbase i1592              ; get offset to local __ptr u64
lw $r757 $$locbase i199                 ; load word
addi $r758 $$locbase i1560              ; get offset to local __ptr u64
lw $r759 $$locbase i195                 ; load word
lt $r760 $r757 $r759
jnzi $r760 .134
ji  .135
.135
addi $r761 $$locbase i1240              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r762 $$locbase i848               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r762 $r761 i24                    ; copy memory
addi $r763 $$locbase i1432              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r763 $r762 i24                    ; copy memory
addi $r764 $$locbase i1432              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r765 $$locbase i872               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r765 $r764 i24                    ; copy memory
addi $r766 $$locbase i896               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r766 $r765 i24                    ; copy memory
move $r767 $r766                        ; move parameter from branch to block argument
ji  .136
.134
addi $r768 $$locbase i1728              ; get offset to local __ptr [slice; 3]
addi $r769 $$locbase i1480              ; get offset to local __ptr u64
lw $r770 $$locbase i185                 ; load word
movi $r771 i16                          ; get array element size
mul $r772 $r770 $r771                   ; get offset to array element
add $r772 $r768 $r772                   ; add array element offset to array base
addi $r773 $$locbase i1240              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r774 $$locbase i712               ; get offset to local __ptr slice
mcpi $r774 $r772 i16                    ; copy memory
addi $r775 $$locbase i728               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r775 $r773 i24                    ; copy memory
addi $r776 $$locbase i432               ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r774                       ; [call]: pass argument 0
move $$arg1 $r775                       ; [call]: pass argument 1
move $$arg2 $r776                       ; [call]: pass argument 2
fncall .10                              ; [call]: call abi_encode_36
 move $r777 $zero                        ; [call]: return unit value
 movi $r777 i0                           ; [call]: return unit value
addi $r778 $$locbase i1240              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r778 $r776 i24                    ; copy memory
addi $r779 $$locbase i1480              ; get offset to local __ptr u64
addi $r780 $$locbase i1664              ; get offset to local __ptr u64
mcpi $r780 $r779 i8                     ; copy memory
addi $r781 $$locbase i1520              ; get offset to local __ptr u64
sw $$locbase $one i190                  ; store word
addi $r782 $$locbase i1664              ; get offset to local __ptr u64
lw $r783 $$locbase i208                 ; load word
addi $r784 $$locbase i1520              ; get offset to local __ptr u64
lw $r785 $$locbase i190                 ; load word
add $r786 $r783 $r785
addi $r787 $$locbase i1480              ; get offset to local __ptr u64
sw $$locbase $r786 i185                 ; store word
ji  .133
.129
addi $r788 $$locbase i208               ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
addi $r789 $r788 i40                    ; get offset to aggregate element
addi $r790 $$locbase i1800              ; get offset to local __ptr { u64, u64 }
mcpi $r790 $r789 i16                    ; copy memory
addi $r791 $$locbase i1072              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r792 $$locbase i616               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r792 $r791 i24                    ; copy memory
addi $r793 $$locbase i336               ; get offset to local __ptr { { ptr, u64, u64 } }
movi $r794 i3                           ; initialize constant into register
 move $$arg0 $r794                       ; [call]: pass argument 0
 movi $$arg0 i3                          ; [call]: pass argument 0
move $$arg1 $r792                       ; [call]: pass argument 1
move $$arg2 $r793                       ; [call]: pass argument 2
fncall .8                               ; [call]: call abi_encode_30
 move $r795 $zero                        ; [call]: return unit value
 movi $r795 i0                           ; [call]: return unit value
addi $r796 $$locbase i1360              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r796 $r793 i24                    ; copy memory
addi $r797 $$locbase i1800              ; get offset to local __ptr { u64, u64 }
addi $r798 $$locbase i1360              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r799 $$locbase i1704              ; get offset to local __ptr { u64, u64 }
mcpi $r799 $r797 i16                    ; copy memory
addi $r800 $$locbase i1144              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r800 $r798 i24                    ; copy memory
addi $r801 $$locbase i1704              ; get offset to local __ptr { u64, u64 }
lw $r802 $$locbase i213                 ; load word
addi $r803 $$locbase i1144              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r804 $$locbase i640               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r804 $r803 i24                    ; copy memory
addi $r805 $$locbase i360               ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r802                       ; [call]: pass argument 0
move $$arg1 $r804                       ; [call]: pass argument 1
move $$arg2 $r805                       ; [call]: pass argument 2
fncall .8                               ; [call]: call abi_encode_30
 move $r806 $zero                        ; [call]: return unit value
 movi $r806 i0                           ; [call]: return unit value
addi $r807 $$locbase i1216              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r807 $r805 i24                    ; copy memory
addi $r808 $$locbase i1704              ; get offset to local __ptr { u64, u64 }
addi $r809 $r808 i8                     ; get offset to aggregate element
lw $r810 $$locbase i214                 ; load word
addi $r811 $$locbase i1216              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r812 $$locbase i664               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r812 $r811 i24                    ; copy memory
addi $r813 $$locbase i384               ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r810                       ; [call]: pass argument 0
move $$arg1 $r812                       ; [call]: pass argument 1
move $$arg2 $r813                       ; [call]: pass argument 2
fncall .8                               ; [call]: call abi_encode_30
 move $r814 $zero                        ; [call]: return unit value
 movi $r814 i0                           ; [call]: return unit value
addi $r815 $$locbase i1288              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r815 $r813 i24                    ; copy memory
addi $r816 $$locbase i1288              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r817 $$locbase i824               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r817 $r816 i24                    ; copy memory
addi $r818 $$locbase i1384              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r818 $r817 i24                    ; copy memory
addi $r819 $$locbase i1384              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r820 $$locbase i896               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r820 $r819 i24                    ; copy memory
move $r767 $r820                        ; move parameter from branch to block argument
ji  .136
.136
move $r823 $r767                        ; move parameter from branch to block argument
addi $r824 $$locbase i920               ; get offset to local __ptr { { ptr, u64, u64 } }
 mcpi $r824 $r823 i24                    ; copy memory
 mcpi $r824 $r767 i24                    ; copy memory
move $r825 $r824                        ; move parameter from branch to block argument
ji  .137
.127
addi $r826 $$locbase i208               ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
addi $r827 $r826 i55                    ; get offset to aggregate element
addi $r828 $$locbase i1792              ; get offset to local __ptr bool
mcpi $r828 $r827 i1                     ; copy memory
addi $r829 $$locbase i1072              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r830 $$locbase i592               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r830 $r829 i24                    ; copy memory
addi $r831 $$locbase i312               ; get offset to local __ptr { { ptr, u64, u64 } }
movi $r832 i2                           ; initialize constant into register
 move $$arg0 $r832                       ; [call]: pass argument 0
 movi $$arg0 i2                          ; [call]: pass argument 0
move $$arg1 $r830                       ; [call]: pass argument 1
move $$arg2 $r831                       ; [call]: pass argument 2
fncall .8                               ; [call]: call abi_encode_30
 move $r833 $zero                        ; [call]: return unit value
 movi $r833 i0                           ; [call]: return unit value
addi $r834 $$locbase i1312              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r834 $r831 i24                    ; copy memory
addi $r835 $$locbase i1792              ; get offset to local __ptr bool
addi $r836 $$locbase i1312              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r837 $$locbase i1688              ; get offset to local __ptr bool
mcpi $r837 $r835 i1                     ; copy memory
addi $r838 $$locbase i1120              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r838 $r836 i24                    ; copy memory
addi $r839 $$locbase i520               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r840 $$locbase i1120              ; get offset to local __ptr { { ptr, u64, u64 } }
move $r841 $r840                        ; return value from ASM block with return register buffer
addi $r842 $$locbase i48                ; get offset to local __ptr { ptr, u64, u64 }
 mcpi $r842 $r841 i24                    ; copy memory
 mcpi $r842 $r840 i24                    ; copy memory
addi $r843 $$locbase i136               ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r843 $r842 i24                    ; copy memory
lw $r844 $$locbase i17                  ; load word
addi $r845 $r843 i8                     ; get offset to aggregate element
lw $r846 $$locbase i18                  ; load word
addi $r847 $r843 i16                    ; get offset to aggregate element
lw $r848 $$locbase i19                  ; load word
addi $r849 $$locbase i1688              ; get offset to local __ptr bool
lb $r850 $r849 i0                       ; load byte
add $r851 $r848 $one
gt $r852 $r851 $r846
move $r853 $r844                        ; move parameter from branch to block argument
move $r854 $r846                        ; move parameter from branch to block argument
jnzi $r852 .138
ji  .139
.138
movi $r855 i2                           ; initialize constant into register
mul $r856 $r846 $r855
add $r857 $r856 $one
aloc $r857
mcp $hp $r844 $r848
move $r858 $hp                          ; return value from ASM block with return register hp
 move $r853 $r858                        ; move parameter from branch to block argument
 move $r853 $hp                          ; move parameter from branch to block argument
move $r854 $r857                        ; move parameter from branch to block argument
ji  .139
.139
move $r862 $r853                        ; move parameter from branch to block argument
move $r864 $r854                        ; move parameter from branch to block argument
 add $r865 $r862 $r848
 add $r865 $r853 $r848
sb $r865 $r850 i0                       ; store byte
add $r866 $r848 $one
addi $r867 $$locbase i184               ; get offset to local __ptr { ptr, u64, u64 }
sw $$locbase $r862 i23                  ; store word
addi $r868 $r867 i8                     ; get offset to aggregate element
sw $$locbase $r864 i24                  ; store word
addi $r869 $r867 i16                    ; get offset to aggregate element
sw $$locbase $r866 i25                  ; store word
move $r870 $r867                        ; return value from ASM block with return register buffer
addi $r871 $$locbase i72                ; get offset to local __ptr { ptr, u64, u64 }
 mcpi $r871 $r870 i24                    ; copy memory
 mcpi $r871 $r867 i24                    ; copy memory
mcpi $r839 $r871 i24                    ; copy memory
addi $r872 $$locbase i800               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r872 $r839 i24                    ; copy memory
addi $r873 $$locbase i1336              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r873 $r872 i24                    ; copy memory
addi $r874 $$locbase i1336              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r875 $$locbase i920               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r875 $r874 i24                    ; copy memory
move $r825 $r875                        ; move parameter from branch to block argument
ji  .137
.137
move $r878 $r825                        ; move parameter from branch to block argument
addi $r879 $$locbase i944               ; get offset to local __ptr { { ptr, u64, u64 } }
 mcpi $r879 $r878 i24                    ; copy memory
 mcpi $r879 $r825 i24                    ; copy memory
move $r880 $r879                        ; move parameter from branch to block argument
ji  .140
.125
addi $r881 $$locbase i208               ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
addi $r882 $r881 i55                    ; get offset to aggregate element
addi $r883 $$locbase i1784              ; get offset to local __ptr u8
mcpi $r883 $r882 i1                     ; copy memory
addi $r884 $$locbase i1072              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r885 $$locbase i568               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r885 $r884 i24                    ; copy memory
addi $r886 $$locbase i288               ; get offset to local __ptr { { ptr, u64, u64 } }
 move $$arg0 $one                        ; [call]: pass argument 0
 movi $$arg0 i1                          ; [call]: pass argument 0
move $$arg1 $r885                       ; [call]: pass argument 1
move $$arg2 $r886                       ; [call]: pass argument 2
fncall .8                               ; [call]: call abi_encode_30
 move $r887 $zero                        ; [call]: return unit value
 movi $r887 i0                           ; [call]: return unit value
addi $r888 $$locbase i1192              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r888 $r886 i24                    ; copy memory
addi $r889 $$locbase i1784              ; get offset to local __ptr u8
addi $r890 $$locbase i1192              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r891 $$locbase i1672              ; get offset to local __ptr u8
mcpi $r891 $r889 i1                     ; copy memory
addi $r892 $$locbase i1096              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r892 $r890 i24                    ; copy memory
addi $r893 $$locbase i496               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r894 $$locbase i1096              ; get offset to local __ptr { { ptr, u64, u64 } }
move $r895 $r894                        ; return value from ASM block with return register buffer
 mcpi $$locbase $r895 i24                ; copy memory
 mcpi $$locbase $r894 i24                ; copy memory
addi $r896 $$locbase i112               ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r896 $$locbase i24                ; copy memory
lw $r897 $$locbase i14                  ; load word
addi $r898 $r896 i8                     ; get offset to aggregate element
lw $r899 $$locbase i15                  ; load word
addi $r900 $r896 i16                    ; get offset to aggregate element
lw $r901 $$locbase i16                  ; load word
addi $r902 $$locbase i1672              ; get offset to local __ptr u8
lb $r903 $r902 i0                       ; load byte
add $r904 $r901 $one
gt $r905 $r904 $r899
move $r906 $r897                        ; move parameter from branch to block argument
move $r907 $r899                        ; move parameter from branch to block argument
jnzi $r905 .141
ji  .142
.141
movi $r908 i2                           ; initialize constant into register
mul $r909 $r899 $r908
add $r910 $r909 $one
aloc $r910
mcp $hp $r897 $r901
move $r911 $hp                          ; return value from ASM block with return register hp
 move $r906 $r911                        ; move parameter from branch to block argument
 move $r906 $hp                          ; move parameter from branch to block argument
move $r907 $r910                        ; move parameter from branch to block argument
ji  .142
.142
move $r915 $r906                        ; move parameter from branch to block argument
move $r917 $r907                        ; move parameter from branch to block argument
 add $r918 $r915 $r901
 add $r918 $r906 $r901
sb $r918 $r903 i0                       ; store byte
add $r919 $r901 $one
addi $r920 $$locbase i160               ; get offset to local __ptr { ptr, u64, u64 }
sw $$locbase $r915 i20                  ; store word
addi $r921 $r920 i8                     ; get offset to aggregate element
sw $$locbase $r917 i21                  ; store word
addi $r922 $r920 i16                    ; get offset to aggregate element
sw $$locbase $r919 i22                  ; store word
move $r923 $r920                        ; return value from ASM block with return register buffer
addi $r924 $$locbase i24                ; get offset to local __ptr { ptr, u64, u64 }
 mcpi $r924 $r923 i24                    ; copy memory
 mcpi $r924 $r920 i24                    ; copy memory
mcpi $r893 $r924 i24                    ; copy memory
addi $r925 $$locbase i776               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r925 $r893 i24                    ; copy memory
addi $r926 $$locbase i1264              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r926 $r925 i24                    ; copy memory
addi $r927 $$locbase i1264              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r928 $$locbase i944               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r928 $r927 i24                    ; copy memory
move $r880 $r928                        ; move parameter from branch to block argument
ji  .140
.140
move $r931 $r880                        ; move parameter from branch to block argument
addi $r932 $$locbase i968               ; get offset to local __ptr { { ptr, u64, u64 } }
 mcpi $r932 $r931 i24                    ; copy memory
 mcpi $r932 $r880 i24                    ; copy memory
move $r933 $r932                        ; move parameter from branch to block argument
ji  .143
.123
addi $r934 $$locbase i1072              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r935 $$locbase i544               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r935 $r934 i24                    ; copy memory
addi $r936 $$locbase i264               ; get offset to local __ptr { { ptr, u64, u64 } }
 move $$arg0 $zero                       ; [call]: pass argument 0
 movi $$arg0 i0                          ; [call]: pass argument 0
move $$arg1 $r935                       ; [call]: pass argument 1
move $$arg2 $r936                       ; [call]: pass argument 2
fncall .8                               ; [call]: call abi_encode_30
 move $r937 $zero                        ; [call]: return unit value
 movi $r937 i0                           ; [call]: return unit value
addi $r938 $$locbase i968               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r938 $r936 i24                    ; copy memory
move $r933 $r938                        ; move parameter from branch to block argument
ji  .143
.143
move $r941 $r933                        ; move parameter from branch to block argument
addi $r942 $$locbase i1456              ; get offset to local __ptr { { ptr, u64, u64 } }
 mcpi $r942 $r941 i24                    ; copy memory
 mcpi $r942 $r933 i24                    ; copy memory
addi $r943 $$locbase i1456              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r944 $$locbase i992               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r944 $r943 i24                    ; copy memory
addi $r945 $$locbase i1048              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r945 $r944 i24                    ; copy memory
addi $r946 $$locbase i1048              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r947 $$locbase i752               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r947 $r946 i24                    ; copy memory
addi $r948 $$locbase i480               ; get offset to local __ptr slice
move $$arg0 $r947                       ; [call]: pass argument 0
move $$arg1 $r948                       ; [call]: pass argument 1
fncall .14                              ; [call]: call as_raw_slice_39
 move $r949 $zero                        ; [call]: return unit value
 movi $r949 i0                           ; [call]: return unit value
addi $r950 $$locbase i1016              ; get offset to local __ptr slice
mcpi $r950 $r948 i16                    ; copy memory
move $r951 $r950                        ; move parameter from branch to block argument
ji  .144
.121
addi $r952 $$locbase i1776              ; get offset to local __ptr u64
movi $r953 i56                          ; initialize constant into register
sw $$locbase $r953 i222                 ; store word
addi $r954 $$locbase i1032              ; get offset to local __ptr { __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }, u64 }
addi $r955 $$locbase i1488              ; get offset to local __ptr __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
addi $r956 $$locbase i1776              ; get offset to local __ptr u64
mcpi $r954 $r955 i8                     ; copy memory
addi $r957 $r954 i8                     ; get offset to aggregate element
mcpi $r957 $r956 i8                     ; copy memory
addi $r958 $$locbase i96                ; get offset to local __ptr { __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }, u64 }
mcpi $r958 $r954 i16                    ; copy memory
addi $r959 $$locbase i1016              ; get offset to local __ptr slice
mcpi $r959 $r958 i16                    ; copy memory
move $r951 $r959                        ; move parameter from branch to block argument
ji  .144
.144
move $r962 $r951                        ; move parameter from branch to block argument
 mcpi $r636 $r962 i16                    ; copy memory
 mcpi $r636 $r951 i16                    ; copy memory
ji  .7
.7
cfsi i1864                              ; free 1864 bytes for locals and 0 slots for extra call arguments
move $$reta $r637                       ; restore return address
popa .6                                 ; restore all registers
jal $zero $$reta i0                     ; return from call
DIFF------------------------------
.program:
.8                                      ; --- start of function: abi_encode_30 ---
pusha .8                                ; save all registers
move $$locbase $sp                      ; save locals base register for function abi_encode_30
cfei i152                               ; allocate 152 bytes for locals and 0 slots for call arguments
.145
addi $r964 $$locbase i144               ; get offset to local __ptr u64
sw $$locbase $$arg0 i18                 ; store word
addi $r965 $$locbase i120               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r965 $$arg1 i24                   ; copy memory
addi $r966 $$locbase i96                ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r967 $$locbase i120               ; get offset to local __ptr { { ptr, u64, u64 } }
move $r968 $r967                        ; return value from ASM block with return register buffer
 mcpi $$locbase $r968 i24                ; copy memory
 mcpi $$locbase $r967 i24                ; copy memory
addi $r969 $$locbase i48                ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r969 $$locbase i24                ; copy memory
lw $r970 $$locbase i6                   ; load word
addi $r971 $r969 i8                     ; get offset to aggregate element
lw $r972 $$locbase i7                   ; load word
addi $r973 $r969 i16                    ; get offset to aggregate element
lw $r974 $$locbase i8                   ; load word
addi $r975 $$locbase i144               ; get offset to local __ptr u64
lw $r976 $$locbase i18                  ; load word
movi $r977 i8                           ; initialize constant into register
add $r978 $r974 $r977
gt $r979 $r978 $r972
move $r980 $r970                        ; move parameter from branch to block argument
move $r981 $r972                        ; move parameter from branch to block argument
jnzi $r979 .146
ji  .147
.146
movi $r982 i2                           ; initialize constant into register
mul $r983 $r972 $r982
movi $r984 i8                           ; initialize constant into register
add $r985 $r983 $r984
aloc $r985
mcp $hp $r970 $r974
move $r986 $hp                          ; return value from ASM block with return register hp
 move $r980 $r986                        ; move parameter from branch to block argument
 move $r980 $hp                          ; move parameter from branch to block argument
move $r981 $r985                        ; move parameter from branch to block argument
ji  .147
.147
move $r990 $r980                        ; move parameter from branch to block argument
move $r992 $r981                        ; move parameter from branch to block argument
 add $r993 $r990 $r974
 add $r993 $r980 $r974
sw $r993 $r976 i0                       ; store word
movi $r994 i8                           ; initialize constant into register
add $r995 $r974 $r994
addi $r996 $$locbase i72                ; get offset to local __ptr { ptr, u64, u64 }
sw $$locbase $r990 i9                   ; store word
addi $r997 $r996 i8                     ; get offset to aggregate element
sw $$locbase $r992 i10                  ; store word
addi $r998 $r996 i16                    ; get offset to aggregate element
sw $$locbase $r995 i11                  ; store word
move $r999 $r996                        ; return value from ASM block with return register buffer
addi $r1000 $$locbase i24               ; get offset to local __ptr { ptr, u64, u64 }
 mcpi $r1000 $r999 i24                   ; copy memory
 mcpi $r1000 $r996 i24                   ; copy memory
mcpi $r966 $r1000 i24                   ; copy memory
mcpi $$arg2 $r966 i24                   ; copy memory
ji  .9
.9
cfsi i152                               ; free 152 bytes for locals and 0 slots for extra call arguments
popa .8                                 ; restore all registers
jal $zero $$reta i0                     ; return from call
DIFF------------------------------
.program:
.10                                     ; --- start of function: abi_encode_36 ---
pusha .10                               ; save all registers
move $$locbase $sp                      ; save locals base register for function abi_encode_36
cfei i224                               ; allocate 224 bytes for locals and 0 slots for call arguments
.148
addi $r1002 $$locbase i208              ; get offset to local __ptr slice
mcpi $r1002 $$arg0 i16                  ; copy memory
addi $r1003 $$locbase i184              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r1003 $$arg1 i24                  ; copy memory
addi $r1004 $$locbase i160              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r1005 $$locbase i184              ; get offset to local __ptr { { ptr, u64, u64 } }
move $r1006 $r1005                      ; return value from ASM block with return register buffer
 mcpi $$locbase $r1006 i24               ; copy memory
 mcpi $$locbase $r1005 i24               ; copy memory
addi $r1007 $$locbase i80               ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r1007 $$locbase i24               ; copy memory
lw $r1008 $$locbase i10                 ; load word
addi $r1009 $r1007 i8                   ; get offset to aggregate element
lw $r1010 $$locbase i11                 ; load word
addi $r1011 $r1007 i16                  ; get offset to aggregate element
lw $r1012 $$locbase i12                 ; load word
addi $r1013 $$locbase i208              ; get offset to local __ptr slice
addi $r1014 $$locbase i40               ; get offset to local __ptr slice
mcpi $r1014 $r1013 i16                  ; copy memory
move $r1015 $r1013                      ; return value from ASM block with return register item
addi $r1016 $$locbase i24               ; get offset to local __ptr { u64, u64 }
 mcpi $r1016 $r1015 i16                  ; copy memory
 mcpi $r1016 $r1013 i16                  ; copy memory
addi $r1017 $$locbase i104              ; get offset to local __ptr { u64, u64 }
mcpi $r1017 $r1016 i16                  ; copy memory
addi $r1018 $r1017 i8                   ; get offset to aggregate element
lw $r1019 $$locbase i14                 ; load word
movi $r1020 i8                          ; initialize constant into register
add $r1021 $r1019 $r1020
add $r1022 $r1012 $r1021
gt $r1023 $r1022 $r1010
move $r1024 $r1008                      ; move parameter from branch to block argument
move $r1025 $r1010                      ; move parameter from branch to block argument
jnzi $r1023 .149
ji  .150
.149
movi $r1026 i2                          ; initialize constant into register
mul $r1027 $r1010 $r1026
add $r1028 $r1027 $r1021
aloc $r1028
mcp $hp $r1008 $r1012
move $r1029 $hp                         ; return value from ASM block with return register hp
 move $r1024 $r1029                      ; move parameter from branch to block argument
 move $r1024 $hp                         ; move parameter from branch to block argument
move $r1025 $r1028                      ; move parameter from branch to block argument
ji  .150
.150
move $r1033 $r1024                      ; move parameter from branch to block argument
move $r1035 $r1025                      ; move parameter from branch to block argument
addi $r1036 $$locbase i120              ; get offset to local __ptr slice
mcpi $r1036 $r1014 i16                  ; copy memory
add $r1037 $r1033 $r1012
lw $r1039 $$locbase i16
sw $r1037 $r1039 i0
addi $r1037 $r1037 i8
lw $r1038 $$locbase i15
mcp $r1037 $r1038 $r1039
addi $r1040 $r1012 i8
add $r1040 $r1040 $r1039
move $r1041 $r1040                      ; return value from ASM block with return register new_len
addi $r1042 $$locbase i136              ; get offset to local __ptr { ptr, u64, u64 }
sw $$locbase $r1033 i17                 ; store word
addi $r1043 $r1042 i8                   ; get offset to aggregate element
sw $$locbase $r1035 i18                 ; store word
addi $r1044 $r1042 i16                  ; get offset to aggregate element
sw $$locbase $r1041 i19                 ; store word
move $r1045 $r1042                      ; return value from ASM block with return register buffer
addi $r1046 $$locbase i56               ; get offset to local __ptr { ptr, u64, u64 }
 mcpi $r1046 $r1045 i24                  ; copy memory
 mcpi $r1046 $r1042 i24                  ; copy memory
mcpi $r1004 $r1046 i24                  ; copy memory
mcpi $$arg2 $r1004 i24                  ; copy memory
ji  .11
.11
cfsi i224                               ; free 224 bytes for locals and 0 slots for extra call arguments
popa .10                                ; restore all registers
jal $zero $$reta i0                     ; return from call
DIFF------------------------------
.program:
.12                                     ; --- start of function: new_38 ---
pusha .12                               ; save all registers
move $$locbase $sp                      ; save locals base register for function new_38
cfei i72                                ; allocate 72 bytes for locals and 0 slots for call arguments
.151
addi $r1048 $$locbase i48               ; get offset to local __ptr { { ptr, u64, u64 } }
movi $r1049 i1024                       ; initialize constant into register
aloc $r1049
move $r1050 $hp                         ; return value from ASM block with return register hp
addi $r1051 $$locbase i24               ; get offset to local __ptr { ptr, u64, u64 }
 sw $$locbase $r1050 i3                  ; store word
 sw $$locbase $hp i3                     ; store word
addi $r1052 $r1051 i8                   ; get offset to aggregate element
movi $r1053 i1024                       ; initialize constant into register
sw $$locbase $r1053 i4                  ; store word
addi $r1054 $r1051 i16                  ; get offset to aggregate element
sw $$locbase $zero i5                   ; store word
move $r1055 $r1051                      ; return value from ASM block with return register buffer
 mcpi $$locbase $r1055 i24               ; copy memory
 mcpi $$locbase $r1051 i24               ; copy memory
mcpi $r1048 $$locbase i24               ; copy memory
mcpi $$arg0 $r1048 i24                  ; copy memory
ji  .13
.13
cfsi i72                                ; free 72 bytes for locals and 0 slots for extra call arguments
popa .12                                ; restore all registers
jal $zero $$reta i0                     ; return from call
DIFF------------------------------
.program:
.14                                     ; --- start of function: as_raw_slice_39 ---
pusha .14                               ; save all registers
move $$locbase $sp                      ; save locals base register for function as_raw_slice_39
cfei i104                               ; allocate 104 bytes for locals and 0 slots for call arguments
.152
addi $r1057 $$locbase i80               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r1057 $$arg0 i24                  ; copy memory
addi $r1058 $$locbase i80               ; get offset to local __ptr { { ptr, u64, u64 } }
move $r1059 $r1058                      ; return value from ASM block with return register buffer
 mcpi $$locbase $r1059 i24               ; copy memory
 mcpi $$locbase $r1058 i24               ; copy memory
addi $r1060 $$locbase i40               ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r1060 $$locbase i24               ; copy memory
addi $r1061 $r1060 i16                  ; get offset to aggregate element
addi $r1062 $$locbase i64               ; get offset to local __ptr { ptr, u64 }
mcpi $r1062 $r1060 i8                   ; copy memory
addi $r1063 $r1062 i8                   ; get offset to aggregate element
mcpi $r1063 $r1061 i8                   ; copy memory
move $r1064 $r1062                      ; return value from ASM block with return register s
addi $r1065 $$locbase i24               ; get offset to local __ptr slice
 mcpi $r1065 $r1064 i16                  ; copy memory
 mcpi $r1065 $r1062 i16                  ; copy memory
mcpi $$arg1 $r1065 i16                  ; copy memory
ji  .15
.15
cfsi i104                               ; free 104 bytes for locals and 0 slots for extra call arguments
popa .14                                ; restore all registers
jal $zero $$reta i0                     ; return from call
DIFF------------------------------
.program:
.16                                     ; --- start of function: generic_panic_41 ---
pusha .16                               ; save all registers
move $$locbase $sp                      ; save locals base register for function generic_panic_41
cfei i240                               ; allocate 240 bytes for locals and 0 slots for call arguments
move $r1066 $$arg0                      ; save argument 0 (t)
move $r1067 $$arg1                      ; save argument 1 (__backtrace)
move $r1068 $$reta                      ; save return address
.153
addi $r1069 $$locbase i224              ; get offset to local __ptr slice
 mcpi $r1069 $r1066 i16                  ; copy memory
 mcpi $r1069 $$arg0 i16                  ; copy memory
addi $r1070 $$locbase i224              ; get offset to local __ptr slice
addi $r1071 $$locbase i208              ; get offset to local __ptr __ptr slice
sw $$locbase $r1070 i26                 ; store word
 jnzi $zero .154
 
ji  .155
.155
addi $r1072 $$locbase i208              ; get offset to local __ptr __ptr slice
lw $r1073 $$locbase i26                 ; load word
addi $r1074 $$locbase i56               ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r1074                      ; [call]: pass argument 0
fncall .12                              ; [call]: call new_38
 move $r1075 $zero                       ; [call]: return unit value
 movi $r1075 i0                          ; [call]: return unit value
addi $r1076 $$locbase i96               ; get offset to local __ptr slice
mcpi $r1076 $r1073 i16                  ; copy memory
addi $r1077 $$locbase i112              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r1077 $r1074 i24                  ; copy memory
addi $r1078 $$locbase i32               ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r1076                      ; [call]: pass argument 0
move $$arg1 $r1077                      ; [call]: pass argument 1
move $$arg2 $r1078                      ; [call]: pass argument 2
fncall .10                              ; [call]: call abi_encode_36
 move $r1079 $zero                       ; [call]: return unit value
 movi $r1079 i0                          ; [call]: return unit value
addi $r1080 $$locbase i184              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r1080 $r1078 i24                  ; copy memory
addi $r1081 $$locbase i184              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r1082 $$locbase i80               ; get offset to local __ptr slice
move $$arg0 $r1081                      ; [call]: pass argument 0
move $$arg1 $r1082                      ; [call]: pass argument 1
fncall .14                              ; [call]: call as_raw_slice_39
 move $r1083 $zero                       ; [call]: return unit value
 movi $r1083 i0                          ; [call]: return unit value
addi $r1084 $$locbase i136              ; get offset to local __ptr slice
mcpi $r1084 $r1082 i16                  ; copy memory
move $r1085 $r1084                      ; move parameter from branch to block argument
ji  .156
.154
addi $r1086 $$locbase i216              ; get offset to local __ptr u64
movi $r1087 i16                         ; initialize constant into register
sw $$locbase $r1087 i27                 ; store word
addi $r1088 $$locbase i168              ; get offset to local __ptr { __ptr slice, u64 }
addi $r1089 $$locbase i208              ; get offset to local __ptr __ptr slice
addi $r1090 $$locbase i216              ; get offset to local __ptr u64
mcpi $r1088 $r1089 i8                   ; copy memory
addi $r1091 $r1088 i8                   ; get offset to aggregate element
mcpi $r1091 $r1090 i8                   ; copy memory
mcpi $$locbase $r1088 i16               ; copy memory
addi $r1092 $$locbase i136              ; get offset to local __ptr slice
mcpi $r1092 $$locbase i16               ; copy memory
move $r1085 $r1092                      ; move parameter from branch to block argument
ji  .156
.156
move $r1095 $r1085                      ; move parameter from branch to block argument
addi $r1096 $$locbase i152              ; get offset to local __ptr slice
 mcpi $r1096 $r1095 i16                  ; copy memory
 mcpi $r1096 $r1085 i16                  ; copy memory
addi $r1097 $$locbase i16               ; get offset to local __ptr slice
mcpi $r1097 $r1096 i16                  ; copy memory
load $r1098 data_NonConfigurable_16     ; load constant from data section
lw $r1099 $$locbase i2                  ; load slice pointer for logging data
lw $r1100 $$locbase i3                  ; load slice size for logging data
logd $zero $r1098 $r1099 $r1100         ; log slice
load $r1101 data_NonConfigurable_2      ; load constant from data section
and $r1102 $r1067 $r1101
load $r1103 data_NonConfigurable_17     ; load constant from data section
or $r1104 $r1103 $r1102
rvrt $r1104
.17
cfsi i240                               ; free 240 bytes for locals and 0 slots for extra call arguments
move $$reta $r1068                      ; restore return address
popa .16                                ; restore all registers
jal $zero $$reta i0                     ; return from call
DIFF------------------------------
.program:
.18                                     ; --- start of function: generic_panic_44 ---
pusha .18                               ; save all registers
move $$locbase $sp                      ; save locals base register for function generic_panic_44
cfei i184                               ; allocate 184 bytes for locals and 0 slots for call arguments
move $r1105 $$arg0                      ; save argument 0 (t)
move $r1106 $$arg1                      ; save argument 1 (__backtrace)
move $r1107 $$reta                      ; save return address
.157
addi $r1108 $$locbase i184              ; get offset to local __ptr ()
addi $r1109 $$locbase i184              ; get offset to local __ptr ()
addi $r1110 $$locbase i168              ; get offset to local __ptr __ptr ()
sw $$locbase $r1109 i21                 ; store word
 jnzi $one .158
 ji  .158
ji  .159
.159
addi $r1111 $$locbase i32               ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r1111                      ; [call]: pass argument 0
fncall .12                              ; [call]: call new_38
 move $r1112 $zero                       ; [call]: return unit value
 movi $r1112 i0                          ; [call]: return unit value
addi $r1113 $$locbase i144              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r1113 $r1111 i24                  ; copy memory
addi $r1114 $$locbase i144              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r1115 $$locbase i72               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r1115 $r1114 i24                  ; copy memory
addi $r1116 $$locbase i56               ; get offset to local __ptr slice
move $$arg0 $r1115                      ; [call]: pass argument 0
move $$arg1 $r1116                      ; [call]: pass argument 1
fncall .14                              ; [call]: call as_raw_slice_39
 move $r1117 $zero                       ; [call]: return unit value
 movi $r1117 i0                          ; [call]: return unit value
addi $r1118 $$locbase i96               ; get offset to local __ptr slice
mcpi $r1118 $r1116 i16                  ; copy memory
move $r1119 $r1118                      ; move parameter from branch to block argument
ji  .160
.158
addi $r1120 $$locbase i176              ; get offset to local __ptr u64
sw $$locbase $zero i22                  ; store word
addi $r1121 $$locbase i128              ; get offset to local __ptr { __ptr (), u64 }
addi $r1122 $$locbase i168              ; get offset to local __ptr __ptr ()
addi $r1123 $$locbase i176              ; get offset to local __ptr u64
mcpi $r1121 $r1122 i8                   ; copy memory
addi $r1124 $r1121 i8                   ; get offset to aggregate element
mcpi $r1124 $r1123 i8                   ; copy memory
mcpi $$locbase $r1121 i16               ; copy memory
addi $r1125 $$locbase i96               ; get offset to local __ptr slice
mcpi $r1125 $$locbase i16               ; copy memory
move $r1119 $r1125                      ; move parameter from branch to block argument
ji  .160
.160
move $r1128 $r1119                      ; move parameter from branch to block argument
addi $r1129 $$locbase i112              ; get offset to local __ptr slice
 mcpi $r1129 $r1128 i16                  ; copy memory
 mcpi $r1129 $r1119 i16                  ; copy memory
addi $r1130 $$locbase i16               ; get offset to local __ptr slice
mcpi $r1130 $r1129 i16                  ; copy memory
load $r1131 data_NonConfigurable_18     ; load constant from data section
lw $r1132 $$locbase i2                  ; load slice pointer for logging data
lw $r1133 $$locbase i3                  ; load slice size for logging data
logd $zero $r1131 $r1132 $r1133         ; log slice
load $r1134 data_NonConfigurable_2      ; load constant from data section
and $r1135 $r1106 $r1134
load $r1136 data_NonConfigurable_19     ; load constant from data section
or $r1137 $r1136 $r1135
rvrt $r1137
.19
cfsi i184                               ; free 184 bytes for locals and 0 slots for extra call arguments
move $$reta $r1107                      ; restore return address
popa .18                                ; restore all registers
jal $zero $$reta i0                     ; return from call
DIFF------------------------------
.program:
.20                                     ; --- start of function: call_nested_panic_non_inlined_48 ---
pusha .20                               ; save all registers
move $$locbase $sp                      ; save locals base register for function call_nested_panic_non_inlined_48
cfei i200                               ; allocate 200 bytes for locals and 0 slots for call arguments
move $r1138 $$arg0                      ; save argument 0 (__backtrace)
move $r1139 $$reta                      ; save return address
.161
movi $r1140 i4                          ; initialize constant into register
sw $$locbase $r1140 i0                  ; store word
addi $r1141 $$locbase i152              ; get offset to local __ptr [slice; 3]
addr $r1142 data_NonConfigurable_20     ; get __const_global4's address in data section
addi $r1143 $$locbase i56               ; get offset to local __ptr { ptr, u64 }
sw $$locbase $r1142 i7                  ; store word
addi $r1144 $r1143 i8                   ; get offset to aggregate element
movi $r1145 i4                          ; initialize constant into register
sw $$locbase $r1145 i8                  ; store word
addi $r1146 $$locbase i72               ; get offset to local __ptr slice
mcpi $r1146 $r1143 i16                  ; copy memory
addr $r1147 data_NonConfigurable_21     ; get __const_global5's address in data section
addi $r1148 $$locbase i88               ; get offset to local __ptr { ptr, u64 }
sw $$locbase $r1147 i11                 ; store word
addi $r1149 $r1148 i8                   ; get offset to aggregate element
movi $r1150 i6                          ; initialize constant into register
sw $$locbase $r1150 i12                 ; store word
addi $r1151 $$locbase i104              ; get offset to local __ptr slice
mcpi $r1151 $r1148 i16                  ; copy memory
addr $r1152 data_NonConfigurable_22     ; get __const_global6's address in data section
addi $r1153 $$locbase i120              ; get offset to local __ptr { ptr, u64 }
sw $$locbase $r1152 i15                 ; store word
addi $r1154 $r1153 i8                   ; get offset to aggregate element
movi $r1155 i17                         ; initialize constant into register
sw $$locbase $r1155 i16                 ; store word
addi $r1156 $$locbase i136              ; get offset to local __ptr slice
mcpi $r1156 $r1153 i16                  ; copy memory
movi $r1157 i16                         ; get array element size
 mul $r1158 $zero $r1157                 ; get offset to array element
 add $r1158 $r1141 $r1158                ; add array element offset to array base
 movi $r1158 i0                          ; get offset to array element
 add $r1158 $r1141 $zero                 ; add array element offset to array base
mcpi $r1158 $r1146 i16                  ; copy memory
movi $r1159 i16                         ; get array element size
 mul $r1160 $one $r1159                  ; get offset to array element
 movi $r1160 i16                         ; get offset to array element
add $r1160 $r1141 $r1160                ; add array element offset to array base
mcpi $r1160 $r1151 i16                  ; copy memory
movi $r1161 i16                         ; get array element size
movi $r1162 i2                          ; initialize constant into register
 mul $r1163 $r1162 $r1161                ; get offset to array element
 movi $r1163 i32                         ; get offset to array element
add $r1163 $r1141 $r1163                ; add array element offset to array base
mcpi $r1163 $r1156 i16                  ; copy memory
addi $r1164 $$locbase i8                ; get offset to aggregate element
mcpi $r1164 $r1141 i48                  ; copy memory
movi $r1165 i11                         ; initialize constant into register
sll $r1166 $r1138 $r1165
movi $r1167 i8                          ; initialize constant into register
or $r1168 $r1166 $r1167
 move $$arg0 $one                        ; [call]: pass argument 0
 movi $$arg0 i1                          ; [call]: pass argument 0
move $$arg1 $$locbase                   ; [call]: pass argument 1
move $$arg2 $r1168                      ; [call]: pass argument 2
fncall .22                              ; [call]: call nested_panic_non_inlined_49
 move $r1169 $zero                       ; [call]: return unit value
 movi $r1169 i0                          ; [call]: return unit value
ji  .21
.21
cfsi i200                               ; free 200 bytes for locals and 0 slots for extra call arguments
move $$reta $r1139                      ; restore return address
popa .20                                ; restore all registers
jal $zero $$reta i0                     ; return from call
DIFF------------------------------
.program:
.22                                     ; --- start of function: nested_panic_non_inlined_49 ---
pusha .22                               ; save all registers
move $$locbase $sp                      ; save locals base register for function nested_panic_non_inlined_49
cfei i96                                ; allocate 96 bytes for locals and 0 slots for call arguments
move $r1170 $$arg0                      ; save argument 0 (to_panic)
move $r1171 $$arg1                      ; save argument 1 (err)
move $r1172 $$arg2                      ; save argument 2 (__backtrace)
move $r1173 $$reta                      ; save return address
.162
addi $r1174 $$locbase i88               ; get offset to local __ptr bool
 sb $r1174 $r1170 i0                     ; store byte
 sb $r1174 $$arg0 i0                     ; store byte
addi $r1175 $$locbase i32               ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
mcpi $r1175 $r1171 i56                  ; copy memory
addi $r1176 $$locbase i88               ; get offset to local __ptr bool
lb $r1177 $r1176 i0                     ; load byte
jnzi $r1177 .163
ji  .164
.164
ji  .23
.163
addi $r1178 $$locbase i32               ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
addi $r1179 $$locbase i16               ; get offset to local __ptr slice
move $$arg0 $r1178                      ; [call]: pass argument 0
move $$arg1 $r1179                      ; [call]: pass argument 1
fncall .6                               ; [call]: call encode_allow_alias_12
 move $r1180 $zero                       ; [call]: return unit value
 movi $r1180 i0                          ; [call]: return unit value
mcpi $$locbase $r1179 i16               ; copy memory
load $r1181 data_NonConfigurable_1      ; load constant from data section
lw $r1182 $$locbase i0                  ; load slice pointer for logging data
lw $r1183 $$locbase i1                  ; load slice size for logging data
logd $zero $r1181 $r1182 $r1183         ; log slice
load $r1184 data_NonConfigurable_2      ; load constant from data section
and $r1185 $r1172 $r1184
load $r1186 data_NonConfigurable_23     ; load constant from data section
or $r1187 $r1186 $r1185
rvrt $r1187
.23
cfsi i96                                ; free 96 bytes for locals and 0 slots for extra call arguments
move $$reta $r1173                      ; restore return address
popa .22                                ; restore all registers
jal $zero $$reta i0                     ; return from call
DIFF------------------------------
.program:
.26                                     ; --- start of function: contract_call_63 ---
pusha .26                               ; save all registers
move $$locbase $sp                      ; save locals base register for function contract_call_63
cfei i568                               ; allocate 568 bytes for locals and 0 slots for call arguments
move $r1199 $$arg0                      ; save argument 0 (contract_id)
move $r1200 $$arg1                      ; save argument 1 (method_name)
move $r1201 $$arg2                      ; save argument 2 (args)
move $r1202 $$arg3                      ; save argument 3 (coins)
move $r1203 $$arg4                      ; save argument 4 (asset_id)
move $r1204 $$arg5                      ; save argument 5 (gas)
move $r1205 $$reta                      ; save return address
.166
addi $r1206 $$locbase i408              ; get offset to local __ptr b256
 mcpi $r1206 $r1199 i32                  ; copy memory
 mcpi $r1206 $$arg0 i32                  ; copy memory
addi $r1207 $$locbase i448              ; get offset to local __ptr slice
mcpi $r1207 $r1200 i16                  ; copy memory
addi $r1208 $$locbase i312              ; get offset to local __ptr ()
addi $r1209 $$locbase i400              ; get offset to local __ptr u64
sw $$locbase $r1202 i50                 ; store word
addi $r1210 $$locbase i312              ; get offset to local __ptr b256
mcpi $r1210 $r1203 i32                  ; copy memory
addi $r1211 $$locbase i440              ; get offset to local __ptr u64
sw $$locbase $r1204 i55                 ; store word
addi $r1212 $$locbase i312              ; get offset to local __ptr ()
addi $r1213 $$locbase i448              ; get offset to local __ptr ()
 jnzi $one .167
 ji  .167
ji  .168
.168
addi $r1214 $$locbase i448              ; get offset to local __ptr ()
addi $r1215 $$locbase i80               ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r1215                      ; [call]: pass argument 0
fncall .12                              ; [call]: call new_38
 move $r1216 $zero                       ; [call]: return unit value
 movi $r1216 i0                          ; [call]: return unit value
addi $r1217 $$locbase i560              ; get offset to local __ptr ()
addi $r1218 $$locbase i376              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r1218 $r1215 i24                  ; copy memory
addi $r1219 $$locbase i376              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r1220 $$locbase i184              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r1220 $r1219 i24                  ; copy memory
addi $r1221 $$locbase i344              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r1221 $r1220 i24                  ; copy memory
addi $r1222 $$locbase i344              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r1223 $$locbase i128              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r1223 $r1222 i24                  ; copy memory
addi $r1224 $$locbase i104              ; get offset to local __ptr slice
move $$arg0 $r1223                      ; [call]: pass argument 0
move $$arg1 $r1224                      ; [call]: pass argument 1
fncall .14                              ; [call]: call as_raw_slice_39
 move $r1225 $zero                       ; [call]: return unit value
 movi $r1225 i0                          ; [call]: return unit value
addi $r1226 $$locbase i208              ; get offset to local __ptr slice
mcpi $r1226 $r1224 i16                  ; copy memory
move $r1227 $r1226                      ; move parameter from branch to block argument
ji  .169
.167
addi $r1228 $$locbase i560              ; get offset to local __ptr u64
sw $$locbase $zero i70                  ; store word
addi $r1229 $$locbase i560              ; get offset to local __ptr u64
lw $r1230 $$locbase i70                 ; load word
addi $r1231 $$locbase i448              ; get offset to local __ptr ()
aloc $r1230                             ; aloc size
mcp $hp $r1231 $r1230                   ; mcp hp src size
move $r1232 $hp                         ; return value from ASM block with return register hp
addi $r1233 $$locbase i520              ; get offset to local __ptr ptr
 sw $$locbase $r1232 i65                 ; store word
 sw $$locbase $hp i65                    ; store word
addi $r1234 $$locbase i288              ; get offset to local __ptr { ptr, u64 }
addi $r1235 $$locbase i520              ; get offset to local __ptr ptr
addi $r1236 $$locbase i560              ; get offset to local __ptr u64
mcpi $r1234 $r1235 i8                   ; copy memory
addi $r1237 $r1234 i8                   ; get offset to aggregate element
mcpi $r1237 $r1236 i8                   ; copy memory
move $r1238 $r1234                      ; return value from ASM block with return register s
 mcpi $$locbase $r1238 i16               ; copy memory
 mcpi $$locbase $r1234 i16               ; copy memory
addi $r1239 $$locbase i208              ; get offset to local __ptr slice
mcpi $r1239 $$locbase i16               ; copy memory
move $r1227 $r1239                      ; move parameter from branch to block argument
ji  .169
.169
move $r1242 $r1227                      ; move parameter from branch to block argument
addi $r1243 $$locbase i224              ; get offset to local __ptr slice
 mcpi $r1243 $r1242 i16                  ; copy memory
 mcpi $r1243 $r1227 i16                  ; copy memory
addi $r1244 $$locbase i544              ; get offset to local __ptr slice
mcpi $r1244 $r1243 i16                  ; copy memory
addi $r1245 $$locbase i240              ; get offset to local __ptr { b256, u64, u64 }
addi $r1246 $$locbase i408              ; get offset to local __ptr b256
addi $r1247 $$locbase i16               ; get offset to local __ptr b256
mcpi $r1247 $r1246 i32                  ; copy memory
addi $r1248 $$locbase i448              ; get offset to local __ptr slice
addi $r1249 $$locbase i152              ; get offset to local __ptr slice
mcpi $r1249 $r1248 i16                  ; copy memory
move $$arg0 $r1249                      ; [call]: pass argument 0
fncall .28                              ; [call]: call ptr_65
move $r1250 $$retv                      ; [call]: copy the return value
 move $r1251 $r1250                      ; return value from ASM block with return register a
 move $r1251 $$retv                      ; return value from ASM block with return register a
addi $r1252 $$locbase i544              ; get offset to local __ptr slice
addi $r1253 $$locbase i168              ; get offset to local __ptr slice
mcpi $r1253 $r1252 i16                  ; copy memory
move $$arg0 $r1253                      ; [call]: pass argument 0
fncall .28                              ; [call]: call ptr_65
move $r1254 $$retv                      ; [call]: copy the return value
 move $r1255 $r1254                      ; return value from ASM block with return register a
 move $r1255 $$retv                      ; return value from ASM block with return register a
mcpi $r1245 $r1247 i32                  ; copy memory
addi $r1256 $r1245 i32                  ; get offset to aggregate element
sw $r1245 $r1251 i4                     ; store word
addi $r1257 $r1245 i40                  ; get offset to aggregate element
sw $r1245 $r1255 i5                     ; store word
addi $r1258 $$locbase i464              ; get offset to local __ptr { b256, u64, u64 }
mcpi $r1258 $r1245 i48                  ; copy memory
addi $r1259 $$locbase i464              ; get offset to local __ptr { b256, u64, u64 }
addi $r1260 $$locbase i400              ; get offset to local __ptr u64
lw $r1261 $$locbase i50                 ; load word
addi $r1262 $$locbase i312              ; get offset to local __ptr b256
addi $r1263 $$locbase i48               ; get offset to local __ptr b256
mcpi $r1263 $r1262 i32                  ; copy memory
addi $r1264 $$locbase i48               ; get offset to local __ptr b256
addi $r1265 $$locbase i440              ; get offset to local __ptr u64
lw $r1266 $$locbase i55                 ; load word
call $r1259 $r1261 $r1264 $r1266        ; call external contract
move $r1267 $ret                        ; save external contract call result
move $r1268 $ret                        ; return value from ASM block with return register ret
addi $r1269 $$locbase i512              ; get offset to local __ptr ptr
 sw $$locbase $r1268 i64                 ; store word
 sw $$locbase $ret i64                   ; store word
addi $r1270 $$locbase i512              ; get offset to local __ptr ptr
addi $r1271 $$locbase i528              ; get offset to local __ptr ptr
mcpi $r1271 $r1270 i8                   ; copy memory
 jnzi $one .170
 ji  .170
ji  .171
.171
addi $r1272 $$locbase i120              ; get offset to local __ptr { ptr }
addi $r1273 $$locbase i528              ; get offset to local __ptr ptr
mcpi $r1272 $r1273 i8                   ; copy memory
addi $r1274 $$locbase i368              ; get offset to local __ptr { ptr }
mcpi $r1274 $r1272 i8                   ; copy memory
addi $r1275 $$locbase i368              ; get offset to local __ptr { ptr }
addi $r1276 $$locbase i304              ; get offset to local __ptr __ptr { ptr }
sw $$locbase $r1275 i38                 ; store word
ji  .172
.170
addi $r1277 $$locbase i528              ; get offset to local __ptr ptr
lw $r1278 $$locbase i66                 ; load word
addi $r1279 $$locbase i536              ; get offset to local __ptr __ptr ()
sw $$locbase $r1278 i67                 ; store word
ji  .172
.172
ji  .27
.27
cfsi i568                               ; free 568 bytes for locals and 0 slots for extra call arguments
move $$reta $r1205                      ; restore return address
popa .26                                ; restore all registers
jal $zero $$reta i0                     ; return from call
DIFF------------------------------
.program:
.28                                     ; --- start of function: ptr_65 ---
pusha .28                               ; save all registers
move $$locbase $sp                      ; save locals base register for function ptr_65
cfei i64                                ; allocate 64 bytes for locals and 0 slots for call arguments
.173
addi $r1281 $$locbase i48               ; get offset to local __ptr slice
mcpi $r1281 $$arg0 i16                  ; copy memory
addi $r1282 $$locbase i48               ; get offset to local __ptr slice
move $r1283 $r1282                      ; return value from ASM block with return register ptr
 mcpi $$locbase $r1283 i16               ; copy memory
 mcpi $$locbase $r1282 i16               ; copy memory
addi $r1284 $$locbase i32               ; get offset to local __ptr { ptr, u64 }
mcpi $r1284 $$locbase i16               ; copy memory
addi $r1285 $$locbase i16               ; get offset to local __ptr { ptr, u64 }
mcpi $r1285 $r1284 i16                  ; copy memory
addi $r1286 $$locbase i32               ; get offset to local __ptr { ptr, u64 }
lw $r1287 $$locbase i4                  ; load word
move $$retv $r1287                      ; set return value
ji  .29
.29
cfsi i64                                ; free 64 bytes for locals and 0 slots for extra call arguments
popa .28                                ; restore all registers
jal $zero $$reta i0                     ; return from call
    Finished debug [unoptimized + fuel] target(s) [8.496 KB] in ???
     Running 12 tests, filtered 0 tests

tested -- panicking_contract

<<<<<<< HEAD
<<<<<<< HEAD
      test test_panicking_in_contract_self_impl ... ok (???, 10987 gas)
=======
      test test_panicking_in_contract_self_impl ... ok (???, 10988 gas)
>>>>>>> 0f3fd4cde (replave move by movi when possible on asm optimisation)
=======
      test test_panicking_in_contract_self_impl ... ok (???, 10981 gas)
>>>>>>> ef4a6e047 (more operators for const_propagate)
           revert code: 828000000000000c
             panic message: panicking in contract self impl
             panicked:      in <Contract as PanickingContractAbi>::panicking_in_contract_self_impl
                               at panicking_contract@1.2.3, src/main.sw:22:9
<<<<<<< HEAD
<<<<<<< HEAD
      test test_directly_panicking_method ... ok (???, 11998 gas)
=======
      test test_directly_panicking_method ... ok (???, 11997 gas)
>>>>>>> 0f3fd4cde (replave move by movi when possible on asm optimisation)
=======
      test test_directly_panicking_method ... ok (???, 11990 gas)
>>>>>>> ef4a6e047 (more operators for const_propagate)
           revert code: 820000000000000b
             panic message: Error C.
             panic value:   C(true)
             panicked:      in <Contract as Abi>::directly_panicking_method
                               at panicking_contract@1.2.3, src/main.sw:28:9
           decoded log values:
C(true), log rb: 5503570629422409978
<<<<<<< HEAD
<<<<<<< HEAD
      test test_nested_panic_inlined ... ok (???, 12722 gas)
=======
      test test_nested_panic_inlined ... ok (???, 12721 gas)
>>>>>>> 0f3fd4cde (replave move by movi when possible on asm optimisation)
=======
      test test_nested_panic_inlined ... ok (???, 12704 gas)
>>>>>>> ef4a6e047 (more operators for const_propagate)
           revert code: 8000000000c01001
             panic message: Error E.
             panic value:   E([AsciiString { data: "to have" }, AsciiString { data: "strings" }, AsciiString { data: "in error enum variants" }])
             panicked:      in panicking_lib::nested_panic_inlined
                               at panicking_lib, src/lib.sw:35:5
             backtrace:     called in panicking_lib::call_nested_panic_inlined
                                at panicking_lib, src/lib.sw:46:5
                              called in <Contract as Abi>::nested_panic_inlined
                                at panicking_contract@1.2.3, src/main.sw:32:9
           decoded log values:
E([AsciiString { data: "to have" }, AsciiString { data: "strings" }, AsciiString { data: "in error enum variants" }]), log rb: 5503570629422409978
<<<<<<< HEAD
<<<<<<< HEAD
      test test_nested_panic_inlined_same_revert_code ... ok (???, 12722 gas)
=======
      test test_nested_panic_inlined_same_revert_code ... ok (???, 12721 gas)
>>>>>>> 0f3fd4cde (replave move by movi when possible on asm optimisation)
=======
      test test_nested_panic_inlined_same_revert_code ... ok (???, 12704 gas)
>>>>>>> ef4a6e047 (more operators for const_propagate)
           revert code: 8000000000c01001
             panic message: Error E.
             panic value:   E([AsciiString { data: "to have" }, AsciiString { data: "strings" }, AsciiString { data: "in error enum variants" }])
             panicked:      in panicking_lib::nested_panic_inlined
                               at panicking_lib, src/lib.sw:35:5
             backtrace:     called in panicking_lib::call_nested_panic_inlined
                                at panicking_lib, src/lib.sw:46:5
                              called in <Contract as Abi>::nested_panic_inlined
                                at panicking_contract@1.2.3, src/main.sw:32:9
           decoded log values:
E([AsciiString { data: "to have" }, AsciiString { data: "strings" }, AsciiString { data: "in error enum variants" }]), log rb: 5503570629422409978
<<<<<<< HEAD
<<<<<<< HEAD
      test test_nested_panic_non_inlined ... ok (???, 12824 gas)
=======
      test test_nested_panic_non_inlined ... ok (???, 12823 gas)
>>>>>>> 0f3fd4cde (replave move by movi when possible on asm optimisation)
=======
      test test_nested_panic_non_inlined ... ok (???, 12806 gas)
>>>>>>> ef4a6e047 (more operators for const_propagate)
           revert code: 8180000002804808
             panic message: Error E.
             panic value:   E([AsciiString { data: "this" }, AsciiString { data: "is not" }, AsciiString { data: "the best practice" }])
             panicked:      in panicking_lib::nested_panic_non_inlined
                               at panicking_lib, src/lib.sw:41:9
             backtrace:     called in panicking_lib::call_nested_panic_non_inlined
                                at panicking_lib, src/lib.sw:50:5
                              called in <Contract as Abi>::nested_panic_non_inlined
                                at panicking_contract@1.2.3, src/main.sw:40:9
           decoded log values:
E([AsciiString { data: "this" }, AsciiString { data: "is not" }, AsciiString { data: "the best practice" }]), log rb: 5503570629422409978
<<<<<<< HEAD
<<<<<<< HEAD
      test test_nested_panic_non_inlined_same_revert_code ... ok (???, 12824 gas)
=======
      test test_nested_panic_non_inlined_same_revert_code ... ok (???, 12823 gas)
>>>>>>> 0f3fd4cde (replave move by movi when possible on asm optimisation)
=======
      test test_nested_panic_non_inlined_same_revert_code ... ok (???, 12806 gas)
>>>>>>> ef4a6e047 (more operators for const_propagate)
           revert code: 8180000002804808
             panic message: Error E.
             panic value:   E([AsciiString { data: "this" }, AsciiString { data: "is not" }, AsciiString { data: "the best practice" }])
             panicked:      in panicking_lib::nested_panic_non_inlined
                               at panicking_lib, src/lib.sw:41:9
             backtrace:     called in panicking_lib::call_nested_panic_non_inlined
                                at panicking_lib, src/lib.sw:50:5
                              called in <Contract as Abi>::nested_panic_non_inlined
                                at panicking_contract@1.2.3, src/main.sw:40:9
           decoded log values:
E([AsciiString { data: "this" }, AsciiString { data: "is not" }, AsciiString { data: "the best practice" }]), log rb: 5503570629422409978
<<<<<<< HEAD
<<<<<<< HEAD
      test test_generic_panic_with_unit ... ok (???, 11449 gas)
=======
      test test_generic_panic_with_unit ... ok (???, 11450 gas)
>>>>>>> 0f3fd4cde (replave move by movi when possible on asm optimisation)
=======
      test test_generic_panic_with_unit ... ok (???, 11443 gas)
>>>>>>> ef4a6e047 (more operators for const_propagate)
           revert code: 8100000000003806
             panic value:   ()
             panicked:      in panicking_lib::generic_panic
                               at panicking_lib, src/lib.sw:74:5
             backtrace:     called in <Contract as Abi>::generic_panic_with_unit
                                at panicking_contract@1.2.3, src/main.sw:48:9
           decoded log values:
(), log rb: 3330666440490685604
<<<<<<< HEAD
<<<<<<< HEAD
      test test_generic_panic_with_unit_same_revert_code ... ok (???, 11449 gas)
=======
      test test_generic_panic_with_unit_same_revert_code ... ok (???, 11450 gas)
>>>>>>> 0f3fd4cde (replave move by movi when possible on asm optimisation)
=======
      test test_generic_panic_with_unit_same_revert_code ... ok (???, 11443 gas)
>>>>>>> ef4a6e047 (more operators for const_propagate)
           revert code: 8100000000003806
             panic value:   ()
             panicked:      in panicking_lib::generic_panic
                               at panicking_lib, src/lib.sw:74:5
             backtrace:     called in <Contract as Abi>::generic_panic_with_unit
                                at panicking_contract@1.2.3, src/main.sw:48:9
           decoded log values:
(), log rb: 3330666440490685604
<<<<<<< HEAD
<<<<<<< HEAD
      test test_generic_panic_with_str ... ok (???, 11744 gas)
=======
      test test_generic_panic_with_str ... ok (???, 11745 gas)
>>>>>>> 0f3fd4cde (replave move by movi when possible on asm optimisation)
=======
      test test_generic_panic_with_str ... ok (???, 11738 gas)
>>>>>>> ef4a6e047 (more operators for const_propagate)
           revert code: 8080000000002804
             panic message: generic panic with string
             panicked:      in panicking_lib::generic_panic
                               at panicking_lib, src/lib.sw:74:5
             backtrace:     called in <Contract as Abi>::generic_panic_with_str
                                at panicking_contract@1.2.3, src/main.sw:56:9
           decoded log values:
AsciiString { data: "generic panic with string" }, log rb: 10098701174489624218
<<<<<<< HEAD
<<<<<<< HEAD
      test test_generic_panic_with_different_str_same_revert_code ... ok (???, 11967 gas)
=======
      test test_generic_panic_with_different_str_same_revert_code ... ok (???, 11968 gas)
>>>>>>> 0f3fd4cde (replave move by movi when possible on asm optimisation)
=======
      test test_generic_panic_with_different_str_same_revert_code ... ok (???, 11961 gas)
>>>>>>> ef4a6e047 (more operators for const_propagate)
           revert code: 808000000000d019
             panic message: generic panic with different string
             panicked:      in panicking_lib::generic_panic
                               at panicking_lib, src/lib.sw:74:5
             backtrace:     called in <Contract as Abi>::generic_panic_with_different_str_same_revert_code
                                at panicking_contract@1.2.3, src/main.sw:60:9
           decoded log values:
AsciiString { data: "generic panic with different string" }, log rb: 10098701174489624218
<<<<<<< HEAD
<<<<<<< HEAD
      test test_generic_panic_with_error_type_enum ... ok (???, 11893 gas)
=======
      test test_generic_panic_with_error_type_enum ... ok (???, 11894 gas)
>>>>>>> 0f3fd4cde (replave move by movi when possible on asm optimisation)
=======
      test test_generic_panic_with_error_type_enum ... ok (???, 11887 gas)
>>>>>>> ef4a6e047 (more operators for const_propagate)
           revert code: 830000000000700d
             panic message: Error A.
             panic value:   A
             panicked:      in panicking_lib::generic_panic
                               at panicking_lib, src/lib.sw:74:5
             backtrace:     called in <Contract as Abi>::generic_panic_with_error_type_enum
                                at panicking_contract@1.2.3, src/main.sw:64:9
           decoded log values:
A, log rb: 5503570629422409978
<<<<<<< HEAD
<<<<<<< HEAD
      test test_generic_panic_with_error_type_enum_different_variant_same_revert_code ... ok (???, 12160 gas)
=======
      test test_generic_panic_with_error_type_enum_different_variant_same_revert_code ... ok (???, 12161 gas)
>>>>>>> 0f3fd4cde (replave move by movi when possible on asm optimisation)
=======
      test test_generic_panic_with_error_type_enum_different_variant_same_revert_code ... ok (???, 12154 gas)
>>>>>>> ef4a6e047 (more operators for const_propagate)
           revert code: 830000000000e01b
             panic message: Error B.
             panic value:   B(42)
             panicked:      in panicking_lib::generic_panic
                               at panicking_lib, src/lib.sw:74:5
             backtrace:     called in <Contract as Abi>::generic_panic_with_error_type_enum_different_variant_same_revert_code
                                at panicking_contract@1.2.3, src/main.sw:68:9
           decoded log values:
B(42), log rb: 5503570629422409978

test result: OK. 12 passed; 0 failed; finished in ???

    Finished in ???

> forc test --path test/src/e2e_vm_tests/test_programs/should_pass/language/panic_expression/panicking_contract --release --test-threads 1 --logs --reverts
exit status: 0
output:
    Building test/src/e2e_vm_tests/test_programs/should_pass/language/panic_expression/panicking_contract
   Compiling library std (test/src/e2e_vm_tests/reduced_std_libs/sway-lib-std-core)
DIFF------------------------------
.program:
DIFF------------------------------
.program:
   Compiling library panicking_lib (test/src/e2e_vm_tests/test_programs/should_pass/language/panic_expression/panicking_lib)
DIFF------------------------------
.program:
DIFF------------------------------
.program:
   Compiling contract panicking_contract (test/src/e2e_vm_tests/test_programs/should_pass/language/panic_expression/panicking_contract)
DIFF------------------------------
.program:
DIFF------------------------------
.program:
DIFF------------------------------
.program:
.0                                      ; --- start of function: __entry ---
move $$locbase $sp                      ; save locals base register for function __entry
cfei i608                               ; allocate 608 bytes for locals and 0 slots for call arguments
.22
addr $r1 data_NonConfigurable_0         ; get __const_global's address in data section
addi $r2 $$locbase i16                  ; get offset to local __ptr { ptr, u64 }
sw $$locbase $r1 i2                     ; store word
addi $r3 $r2 i8                         ; get offset to aggregate element
movi $r4 i454                           ; initialize constant into register
sw $$locbase $r4 i3                     ; store word
addi $r5 $$locbase i232                 ; get offset to local __ptr slice
mcpi $r5 $r2 i16                        ; copy memory
addi $r6 $$locbase i456                 ; get offset to local __ptr slice
mcpi $r6 $r5 i16                        ; copy memory
addi $r7 $$locbase i456                 ; get offset to local __ptr slice
addi $r8 $$locbase i472                 ; get offset to local __ptr slice
mcpi $r8 $r7 i16                        ; copy memory
addi $r9 $$locbase i472                 ; get offset to local __ptr slice
move $r10 $r9                           ; return value from ASM block with return register s
 mcpi $$locbase $r10 i16                 ; copy memory
 mcpi $$locbase $r9 i16                  ; copy memory
addi $r11 $$locbase i416                ; get offset to local __ptr { ptr, u64 }
mcpi $r11 $$locbase i16                 ; copy memory
addi $r12 $$locbase i416                ; get offset to local __ptr { ptr, u64 }
addi $r13 $$locbase i432                ; get offset to local __ptr { ptr, u64 }
mcpi $r13 $r12 i16                      ; copy memory
addi $r14 $$locbase i432                ; get offset to local __ptr { ptr, u64 }
lw $r15 $$locbase i54                   ; load word
move $r16 $fp                           ; return value from ASM block with return register fp
movi $r17 i592                          ; initialize constant into register
 add $r18 $r16 $r17
 add $r18 $fp $r17
lw $r19 $fp i74                         ; lw val ptr i0
move $r20 $r19                          ; return value from ASM block with return register val
move $r21 $fp                           ; return value from ASM block with return register fp
movi $r22 i584                          ; initialize constant into register
 add $r23 $r21 $r22
 add $r23 $fp $r22
lw $r24 $fp i73                         ; lw val ptr i0
move $r25 $r24                          ; return value from ASM block with return register val
 move $r26 $r25                          ; return value from ASM block with return register ptr
 move $r26 $r24                          ; return value from ASM block with return register ptr
addi $r27 $$locbase i376                ; get offset to local __ptr { ptr }
 sw $$locbase $r26 i47                   ; store word
 sw $$locbase $r24 i47                   ; store word
addi $r28 $$locbase i448                ; get offset to local __ptr { ptr }
mcpi $r28 $r27 i8                       ; copy memory
addi $r29 $$locbase i448                ; get offset to local __ptr { ptr }
lw $r30 $$locbase i56                   ; load word
lw $r31 $r30 i0                         ; lw val ptr i0
move $r32 $r31                          ; return value from ASM block with return register val
lw $r33 $$locbase i56                   ; load word
movi $r34 i8                            ; initialize constant into register
add $r35 $r33 $r34
sw $$locbase $r35 i56                   ; store word
addi $r36 $$locbase i448                ; get offset to local __ptr { ptr }
addi $r37 $$locbase i488                ; get offset to local __ptr { ptr }
mcpi $r37 $r36 i8                       ; copy memory
addi $r38 $$locbase i488                ; get offset to local __ptr { ptr }
lw $r39 $$locbase i61                   ; load word
movi $r40 i20                           ; initialize constant into register
eq $r41 $r32 $r40
jnzi $r41 .23
ji  .24
.23
movi $r43 i20                           ; initialize constant into register
addi $r42 $r15 i332
meq $r42 $r39 $r42 $r43
move $r44 $r42                          ; return value from ASM block with return register r
 jnzi $r44 .25
 jnzi $r42 .25
ji  .24
.24
movi $r45 i22                           ; initialize constant into register
eq $r46 $r32 $r45
jnzi $r46 .26
ji  .27
.26
movi $r48 i22                           ; initialize constant into register
addi $r47 $r15 i247
meq $r47 $r39 $r47 $r48
move $r49 $r47                          ; return value from ASM block with return register r
 jnzi $r49 .28
 jnzi $r47 .28
ji  .27
.27
movi $r50 i23                           ; initialize constant into register
eq $r51 $r32 $r50
jnzi $r51 .29
ji  .30
.29
movi $r53 i23                           ; initialize constant into register
addi $r52 $r15 i269
meq $r52 $r39 $r52 $r53
move $r54 $r52                          ; return value from ASM block with return register r
 jnzi $r54 .31
 jnzi $r52 .31
ji  .30
.30
movi $r55 i24                           ; initialize constant into register
eq $r56 $r32 $r55
jnzi $r56 .32
ji  .33
.32
movi $r58 i24                           ; initialize constant into register
addi $r57 $r15 i389
meq $r57 $r39 $r57 $r58
move $r59 $r57                          ; return value from ASM block with return register r
 jnzi $r59 .34
 jnzi $r57 .34
ji  .33
.33
movi $r60 i25                           ; initialize constant into register
eq $r61 $r32 $r60
jnzi $r61 .35
ji  .36
.35
movi $r63 i25                           ; initialize constant into register
addi $r62 $r15 i31
meq $r62 $r39 $r62 $r63
move $r64 $r62                          ; return value from ASM block with return register r
 jnzi $r64 .37
 jnzi $r62 .37
ji  .36
.36
movi $r65 i31                           ; initialize constant into register
eq $r66 $r32 $r65
jnzi $r66 .38
ji  .39
.38
movi $r68 i31                           ; initialize constant into register
addi $r67 $r15 i0
meq $r67 $r39 $r67 $r68
move $r69 $r67                          ; return value from ASM block with return register r
 jnzi $r69 .40
 jnzi $r67 .40
ji  .39
.39
movi $r70 i34                           ; initialize constant into register
eq $r71 $r32 $r70
jnzi $r71 .41
ji  .42
.41
movi $r73 i34                           ; initialize constant into register
addi $r72 $r15 i144
meq $r72 $r39 $r72 $r73
move $r74 $r72                          ; return value from ASM block with return register r
 jnzi $r74 .43
 jnzi $r72 .43
ji  .42
.42
movi $r75 i37                           ; initialize constant into register
eq $r76 $r32 $r75
jnzi $r76 .44
ji  .45
.44
movi $r78 i37                           ; initialize constant into register
addi $r77 $r15 i352
meq $r77 $r39 $r77 $r78
move $r79 $r77                          ; return value from ASM block with return register r
 jnzi $r79 .46
 jnzi $r77 .46
ji  .45
.45
movi $r80 i39                           ; initialize constant into register
eq $r81 $r32 $r80
jnzi $r81 .47
ji  .48
.47
movi $r83 i39                           ; initialize constant into register
addi $r82 $r15 i56
meq $r82 $r39 $r82 $r83
move $r84 $r82                          ; return value from ASM block with return register r
 jnzi $r84 .49
 jnzi $r82 .49
ji  .48
.48
movi $r85 i40                           ; initialize constant into register
eq $r86 $r32 $r85
jnzi $r86 .50
ji  .51
.50
movi $r88 i40                           ; initialize constant into register
addi $r87 $r15 i292
meq $r87 $r39 $r87 $r88
move $r89 $r87                          ; return value from ASM block with return register r
 jnzi $r89 .52
 jnzi $r87 .52
ji  .51
.51
movi $r90 i41                           ; initialize constant into register
eq $r91 $r32 $r90
jnzi $r91 .53
ji  .54
.53
movi $r93 i41                           ; initialize constant into register
addi $r92 $r15 i413
meq $r92 $r39 $r92 $r93
move $r94 $r92                          ; return value from ASM block with return register r
 jnzi $r94 .55
 jnzi $r92 .55
ji  .54
.54
movi $r95 i49                           ; initialize constant into register
eq $r96 $r32 $r95
jnzi $r96 .56
ji  .57
.56
movi $r98 i49                           ; initialize constant into register
addi $r97 $r15 i95
meq $r97 $r39 $r97 $r98
move $r99 $r97                          ; return value from ASM block with return register r
 jnzi $r99 .58
 jnzi $r97 .58
ji  .57
.57
movi $r100 i69                          ; initialize constant into register
eq $r101 $r32 $r100
jnzi $r101 .59
ji  .60
.59
movi $r103 i69                          ; initialize constant into register
addi $r102 $r15 i178
meq $r102 $r39 $r102 $r103
move $r104 $r102                        ; return value from ASM block with return register r
 jnzi $r104 .61
 jnzi $r102 .61
ji  .60
.60
movi $r105 i123                         ; initialize constant into register
rvrt $r105
.61
addi $r106 $$locbase i176               ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
sw $$locbase $one i22                   ; store word
addi $r107 $r106 i55                    ; get offset to aggregate element
movi $r108 i42                          ; initialize constant into register
sb $r107 $r108 i0                       ; store byte
addi $r109 $$locbase i552               ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
mcpi $r109 $r106 i56                    ; copy memory
addi $r110 $$locbase i552               ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
addi $r111 $$locbase i360               ; get offset to local __ptr slice
move $$arg0 $r110                       ; [call]: pass argument 0
move $$arg1 $r111                       ; [call]: pass argument 1
fncall .2                               ; [call]: call encode_allow_alias_12
 move $r112 $zero                        ; [call]: return unit value
 movi $r112 i0                           ; [call]: return unit value
addi $r113 $$locbase i312               ; get offset to local __ptr slice
mcpi $r113 $r111 i16                    ; copy memory
load $r114 data_NonConfigurable_1       ; load constant from data section
lw $r115 $$locbase i39                  ; load slice pointer for logging data
lw $r116 $$locbase i40                  ; load slice size for logging data
logd $zero $r114 $r115 $r116            ; log slice
load $r117 data_NonConfigurable_2       ; load constant from data section
rvrt $r117
.58
addr $r118 data_NonConfigurable_3       ; get __const_global7's address in data section
addi $r119 $$locbase i160               ; get offset to local __ptr { ptr, u64 }
sw $$locbase $r118 i20                  ; store word
addi $r120 $r119 i8                     ; get offset to aggregate element
movi $r121 i35                          ; initialize constant into register
sw $$locbase $r121 i21                  ; store word
addi $r122 $$locbase i264               ; get offset to local __ptr slice
mcpi $r122 $r119 i16                    ; copy memory
addi $r123 $$locbase i400               ; get offset to local __ptr slice
mcpi $r123 $r122 i16                    ; copy memory
move $$arg0 $r123                       ; [call]: pass argument 0
 move $$arg1 $zero                       ; [call]: pass argument 1
 movi $$arg1 i0                          ; [call]: pass argument 1
fncall .12                              ; [call]: call generic_panic_41
 move $r124 $zero                        ; [call]: return unit value
 move $r125 $zero                        ; return value from ASM block with return register zero
 retd $r125 $zero
 movi $r124 i0                           ; [call]: return unit value
 movi $r125 i0                           ; return value from ASM block with return register zero
 retd $zero $zero
.55
 move $$arg0 $zero                       ; [call]: pass argument 0
 movi $$arg0 i0                          ; [call]: pass argument 0
fncall .16                              ; [call]: call nested_panic_non_inlined_47
 move $r126 $zero                        ; [call]: return unit value
 move $r127 $zero                        ; return value from ASM block with return register zero
 retd $r127 $zero
 movi $r126 i0                           ; [call]: return unit value
 movi $r127 i0                           ; return value from ASM block with return register zero
 retd $zero $zero
.52
 move $$arg0 $zero                       ; [call]: pass argument 0
 movi $$arg0 i0                          ; [call]: pass argument 0
fncall .14                              ; [call]: call generic_panic_with_unit_43
 move $r128 $zero                        ; [call]: return unit value
 move $r129 $zero                        ; return value from ASM block with return register zero
 retd $r129 $zero
 movi $r128 i0                           ; [call]: return unit value
 movi $r129 i0                           ; return value from ASM block with return register zero
 retd $zero $zero
.49
load $r130 data_NonConfigurable_4       ; load constant from data section
rvrt $r130
.46
 move $$arg0 $zero                       ; [call]: pass argument 0
 movi $$arg0 i0                          ; [call]: pass argument 0
fncall .20                              ; [call]: call nested_panic_inlined_same_revert_code_54
 move $r131 $zero                        ; [call]: return unit value
 move $r132 $zero                        ; return value from ASM block with return register zero
 retd $r132 $zero
 movi $r131 i0                           ; [call]: return unit value
 movi $r132 i0                           ; return value from ASM block with return register zero
 retd $zero $zero
.43
addi $r133 $$locbase i104               ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
sw $$locbase $zero i13                  ; store word
addi $r134 $$locbase i496               ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
mcpi $r134 $r133 i56                    ; copy memory
addi $r135 $$locbase i496               ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
addi $r136 $$locbase i344               ; get offset to local __ptr slice
move $$arg0 $r135                       ; [call]: pass argument 0
move $$arg1 $r136                       ; [call]: pass argument 1
fncall .2                               ; [call]: call encode_allow_alias_12
 move $r137 $zero                        ; [call]: return unit value
 movi $r137 i0                           ; [call]: return unit value
addi $r138 $$locbase i296               ; get offset to local __ptr slice
mcpi $r138 $r136 i16                    ; copy memory
load $r139 data_NonConfigurable_1       ; load constant from data section
lw $r140 $$locbase i37                  ; load slice pointer for logging data
lw $r141 $$locbase i38                  ; load slice size for logging data
logd $zero $r139 $r140 $r141            ; log slice
load $r142 data_NonConfigurable_2       ; load constant from data section
rvrt $r142
.40
load $r143 data_NonConfigurable_5       ; load constant from data section
rvrt $r143
.37
addi $r144 $$locbase i48                ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
movi $r145 i2                           ; initialize constant into register
sw $$locbase $r145 i6                   ; store word
addi $r146 $r144 i55                    ; get offset to aggregate element
sb $r146 $one i0                        ; store byte
addi $r147 $$locbase i328               ; get offset to local __ptr slice
move $$arg0 $r144                       ; [call]: pass argument 0
move $$arg1 $r147                       ; [call]: pass argument 1
fncall .2                               ; [call]: call encode_allow_alias_12
 move $r148 $zero                        ; [call]: return unit value
 movi $r148 i0                           ; [call]: return unit value
addi $r149 $$locbase i280               ; get offset to local __ptr slice
mcpi $r149 $r147 i16                    ; copy memory
load $r150 data_NonConfigurable_1       ; load constant from data section
lw $r151 $$locbase i35                  ; load slice pointer for logging data
lw $r152 $$locbase i36                  ; load slice size for logging data
logd $zero $r150 $r151 $r152            ; log slice
load $r153 data_NonConfigurable_6       ; load constant from data section
rvrt $r153
.34
 move $$arg0 $zero                       ; [call]: pass argument 0
 movi $$arg0 i0                          ; [call]: pass argument 0
fncall .16                              ; [call]: call nested_panic_non_inlined_47
 move $r154 $zero                        ; [call]: return unit value
 move $r155 $zero                        ; return value from ASM block with return register zero
 retd $r155 $zero
 movi $r154 i0                           ; [call]: return unit value
 movi $r155 i0                           ; return value from ASM block with return register zero
 retd $zero $zero
.31
 move $$arg0 $zero                       ; [call]: pass argument 0
 movi $$arg0 i0                          ; [call]: pass argument 0
fncall .14                              ; [call]: call generic_panic_with_unit_43
 move $r156 $zero                        ; [call]: return unit value
 move $r157 $zero                        ; return value from ASM block with return register zero
 retd $r157 $zero
 movi $r156 i0                           ; [call]: return unit value
 movi $r157 i0                           ; return value from ASM block with return register zero
 retd $zero $zero
.28
addr $r158 data_NonConfigurable_7       ; get __const_global3's address in data section
addi $r159 $$locbase i32                ; get offset to local __ptr { ptr, u64 }
sw $$locbase $r158 i4                   ; store word
addi $r160 $r159 i8                     ; get offset to aggregate element
movi $r161 i25                          ; initialize constant into register
sw $$locbase $r161 i5                   ; store word
addi $r162 $$locbase i248               ; get offset to local __ptr slice
mcpi $r162 $r159 i16                    ; copy memory
addi $r163 $$locbase i384               ; get offset to local __ptr slice
mcpi $r163 $r162 i16                    ; copy memory
move $$arg0 $r163                       ; [call]: pass argument 0
 move $$arg1 $zero                       ; [call]: pass argument 1
 movi $$arg1 i0                          ; [call]: pass argument 1
fncall .12                              ; [call]: call generic_panic_41
 move $r164 $zero                        ; [call]: return unit value
 move $r165 $zero                        ; return value from ASM block with return register zero
 retd $r165 $zero
 movi $r164 i0                           ; [call]: return unit value
 movi $r165 i0                           ; return value from ASM block with return register zero
 retd $zero $zero
.25
 move $$arg0 $zero                       ; [call]: pass argument 0
 movi $$arg0 i0                          ; [call]: pass argument 0
fncall .20                              ; [call]: call nested_panic_inlined_same_revert_code_54
 move $r166 $zero                        ; [call]: return unit value
 move $r167 $zero                        ; return value from ASM block with return register zero
 retd $r167 $zero
 movi $r166 i0                           ; [call]: return unit value
 movi $r167 i0                           ; return value from ASM block with return register zero
 retd $zero $zero
DIFF------------------------------
.program:
.0                                      ; --- start of function: __entry ---
move $$locbase $sp                      ; save locals base register for function __entry
cfei i608                               ; allocate 608 bytes for locals and 0 slots for call arguments
.22
addr $r1 data_NonConfigurable_0         ; get __const_global's address in data section
addi $r2 $$locbase i16                  ; get offset to local __ptr { ptr, u64 }
sw $$locbase $r1 i2                     ; store word
movi $r4 i454                           ; initialize constant into register
sw $$locbase $r4 i3                     ; store word
addi $r5 $$locbase i232                 ; get offset to local __ptr slice
mcpi $r5 $r2 i16                        ; copy memory
addi $r6 $$locbase i456                 ; get offset to local __ptr slice
mcpi $r6 $r5 i16                        ; copy memory
addi $r7 $$locbase i456                 ; get offset to local __ptr slice
addi $r8 $$locbase i472                 ; get offset to local __ptr slice
mcpi $r8 $r7 i16                        ; copy memory
addi $r9 $$locbase i472                 ; get offset to local __ptr slice
mcpi $$locbase $r9 i16                  ; copy memory
addi $r11 $$locbase i416                ; get offset to local __ptr { ptr, u64 }
mcpi $r11 $$locbase i16                 ; copy memory
addi $r12 $$locbase i416                ; get offset to local __ptr { ptr, u64 }
addi $r13 $$locbase i432                ; get offset to local __ptr { ptr, u64 }
mcpi $r13 $r12 i16                      ; copy memory
lw $r15 $$locbase i54                   ; load word
lw $r24 $fp i73                         ; lw val ptr i0
addi $r27 $$locbase i376                ; get offset to local __ptr { ptr }
sw $$locbase $r24 i47                   ; store word
addi $r28 $$locbase i448                ; get offset to local __ptr { ptr }
mcpi $r28 $r27 i8                       ; copy memory
lw $r30 $$locbase i56                   ; load word
lw $r31 $r30 i0                         ; lw val ptr i0
move $r32 $r31                          ; return value from ASM block with return register val
lw $r33 $$locbase i56                   ; load word
movi $r34 i8                            ; initialize constant into register
add $r35 $r33 $r34
sw $$locbase $r35 i56                   ; store word
addi $r36 $$locbase i448                ; get offset to local __ptr { ptr }
addi $r37 $$locbase i488                ; get offset to local __ptr { ptr }
mcpi $r37 $r36 i8                       ; copy memory
lw $r39 $$locbase i61                   ; load word
movi $r40 i20                           ; initialize constant into register
eq $r41 $r32 $r40
jnzi $r41 .23
ji  .24
.23
movi $r43 i20                           ; initialize constant into register
addi $r42 $r15 i332
meq $r42 $r39 $r42 $r43
jnzi $r42 .25
.24
movi $r45 i22                           ; initialize constant into register
eq $r46 $r32 $r45
jnzi $r46 .26
ji  .27
.26
movi $r48 i22                           ; initialize constant into register
addi $r47 $r15 i247
meq $r47 $r39 $r47 $r48
jnzi $r47 .28
.27
movi $r50 i23                           ; initialize constant into register
eq $r51 $r32 $r50
jnzi $r51 .29
ji  .30
.29
movi $r53 i23                           ; initialize constant into register
addi $r52 $r15 i269
meq $r52 $r39 $r52 $r53
jnzi $r52 .31
.30
movi $r55 i24                           ; initialize constant into register
eq $r56 $r32 $r55
jnzi $r56 .32
ji  .33
.32
movi $r58 i24                           ; initialize constant into register
addi $r57 $r15 i389
meq $r57 $r39 $r57 $r58
jnzi $r57 .34
.33
movi $r60 i25                           ; initialize constant into register
eq $r61 $r32 $r60
jnzi $r61 .35
ji  .36
.35
movi $r63 i25                           ; initialize constant into register
addi $r62 $r15 i31
meq $r62 $r39 $r62 $r63
jnzi $r62 .37
.36
movi $r65 i31                           ; initialize constant into register
eq $r66 $r32 $r65
jnzi $r66 .38
ji  .39
.38
movi $r68 i31                           ; initialize constant into register
addi $r67 $r15 i0
meq $r67 $r39 $r67 $r68
jnzi $r67 .40
.39
movi $r70 i34                           ; initialize constant into register
eq $r71 $r32 $r70
jnzi $r71 .41
ji  .42
.41
movi $r73 i34                           ; initialize constant into register
addi $r72 $r15 i144
meq $r72 $r39 $r72 $r73
jnzi $r72 .43
.42
movi $r75 i37                           ; initialize constant into register
eq $r76 $r32 $r75
jnzi $r76 .44
ji  .45
.44
movi $r78 i37                           ; initialize constant into register
addi $r77 $r15 i352
meq $r77 $r39 $r77 $r78
jnzi $r77 .46
.45
movi $r80 i39                           ; initialize constant into register
eq $r81 $r32 $r80
jnzi $r81 .47
ji  .48
.47
movi $r83 i39                           ; initialize constant into register
addi $r82 $r15 i56
meq $r82 $r39 $r82 $r83
jnzi $r82 .49
.48
movi $r85 i40                           ; initialize constant into register
eq $r86 $r32 $r85
jnzi $r86 .50
ji  .51
.50
movi $r88 i40                           ; initialize constant into register
addi $r87 $r15 i292
meq $r87 $r39 $r87 $r88
jnzi $r87 .52
.51
movi $r90 i41                           ; initialize constant into register
eq $r91 $r32 $r90
jnzi $r91 .53
ji  .54
.53
movi $r93 i41                           ; initialize constant into register
addi $r92 $r15 i413
meq $r92 $r39 $r92 $r93
jnzi $r92 .55
.54
movi $r95 i49                           ; initialize constant into register
eq $r96 $r32 $r95
jnzi $r96 .56
ji  .57
.56
movi $r98 i49                           ; initialize constant into register
addi $r97 $r15 i95
meq $r97 $r39 $r97 $r98
jnzi $r97 .58
.57
movi $r100 i69                          ; initialize constant into register
eq $r101 $r32 $r100
jnzi $r101 .59
ji  .60
.59
movi $r103 i69                          ; initialize constant into register
addi $r102 $r15 i178
meq $r102 $r39 $r102 $r103
jnzi $r102 .61
.60
movi $r105 i123                         ; initialize constant into register
rvrt $r105
.61
addi $r106 $$locbase i176               ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
sw $$locbase $one i22                   ; store word
addi $r107 $r106 i55                    ; get offset to aggregate element
movi $r108 i42                          ; initialize constant into register
sb $r107 $r108 i0                       ; store byte
addi $r109 $$locbase i552               ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
mcpi $r109 $r106 i56                    ; copy memory
addi $r110 $$locbase i552               ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
addi $r111 $$locbase i360               ; get offset to local __ptr slice
move $$arg0 $r110                       ; [call]: pass argument 0
move $$arg1 $r111                       ; [call]: pass argument 1
fncall .2                               ; [call]: call encode_allow_alias_12
addi $r113 $$locbase i312               ; get offset to local __ptr slice
mcpi $r113 $r111 i16                    ; copy memory
load $r114 data_NonConfigurable_1       ; load constant from data section
lw $r115 $$locbase i39                  ; load slice pointer for logging data
lw $r116 $$locbase i40                  ; load slice size for logging data
logd $zero $r114 $r115 $r116            ; log slice
load $r117 data_NonConfigurable_2       ; load constant from data section
rvrt $r117
.58
addr $r118 data_NonConfigurable_3       ; get __const_global7's address in data section
addi $r119 $$locbase i160               ; get offset to local __ptr { ptr, u64 }
sw $$locbase $r118 i20                  ; store word
movi $r121 i35                          ; initialize constant into register
sw $$locbase $r121 i21                  ; store word
addi $r122 $$locbase i264               ; get offset to local __ptr slice
mcpi $r122 $r119 i16                    ; copy memory
addi $r123 $$locbase i400               ; get offset to local __ptr slice
mcpi $r123 $r122 i16                    ; copy memory
move $$arg0 $r123                       ; [call]: pass argument 0
movi $$arg1 i0                          ; [call]: pass argument 1
fncall .12                              ; [call]: call generic_panic_41
retd $zero $zero
.55
movi $$arg0 i0                          ; [call]: pass argument 0
fncall .16                              ; [call]: call nested_panic_non_inlined_47
retd $zero $zero
.52
movi $$arg0 i0                          ; [call]: pass argument 0
fncall .14                              ; [call]: call generic_panic_with_unit_43
retd $zero $zero
.49
load $r130 data_NonConfigurable_4       ; load constant from data section
rvrt $r130
.46
movi $$arg0 i0                          ; [call]: pass argument 0
fncall .20                              ; [call]: call nested_panic_inlined_same_revert_code_54
retd $zero $zero
.43
addi $r133 $$locbase i104               ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
sw $$locbase $zero i13                  ; store word
addi $r134 $$locbase i496               ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
mcpi $r134 $r133 i56                    ; copy memory
addi $r135 $$locbase i496               ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
addi $r136 $$locbase i344               ; get offset to local __ptr slice
move $$arg0 $r135                       ; [call]: pass argument 0
move $$arg1 $r136                       ; [call]: pass argument 1
fncall .2                               ; [call]: call encode_allow_alias_12
addi $r138 $$locbase i296               ; get offset to local __ptr slice
mcpi $r138 $r136 i16                    ; copy memory
load $r139 data_NonConfigurable_1       ; load constant from data section
lw $r140 $$locbase i37                  ; load slice pointer for logging data
lw $r141 $$locbase i38                  ; load slice size for logging data
logd $zero $r139 $r140 $r141            ; log slice
load $r142 data_NonConfigurable_2       ; load constant from data section
rvrt $r142
.40
load $r143 data_NonConfigurable_5       ; load constant from data section
rvrt $r143
.37
addi $r144 $$locbase i48                ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
movi $r145 i2                           ; initialize constant into register
sw $$locbase $r145 i6                   ; store word
addi $r146 $r144 i55                    ; get offset to aggregate element
sb $r146 $one i0                        ; store byte
addi $r147 $$locbase i328               ; get offset to local __ptr slice
move $$arg0 $r144                       ; [call]: pass argument 0
move $$arg1 $r147                       ; [call]: pass argument 1
fncall .2                               ; [call]: call encode_allow_alias_12
addi $r149 $$locbase i280               ; get offset to local __ptr slice
mcpi $r149 $r147 i16                    ; copy memory
load $r150 data_NonConfigurable_1       ; load constant from data section
lw $r151 $$locbase i35                  ; load slice pointer for logging data
lw $r152 $$locbase i36                  ; load slice size for logging data
logd $zero $r150 $r151 $r152            ; log slice
load $r153 data_NonConfigurable_6       ; load constant from data section
rvrt $r153
.34
movi $$arg0 i0                          ; [call]: pass argument 0
fncall .16                              ; [call]: call nested_panic_non_inlined_47
retd $zero $zero
.31
movi $$arg0 i0                          ; [call]: pass argument 0
fncall .14                              ; [call]: call generic_panic_with_unit_43
retd $zero $zero
.28
addr $r158 data_NonConfigurable_7       ; get __const_global3's address in data section
addi $r159 $$locbase i32                ; get offset to local __ptr { ptr, u64 }
sw $$locbase $r158 i4                   ; store word
movi $r161 i25                          ; initialize constant into register
sw $$locbase $r161 i5                   ; store word
addi $r162 $$locbase i248               ; get offset to local __ptr slice
mcpi $r162 $r159 i16                    ; copy memory
addi $r163 $$locbase i384               ; get offset to local __ptr slice
mcpi $r163 $r162 i16                    ; copy memory
move $$arg0 $r163                       ; [call]: pass argument 0
movi $$arg1 i0                          ; [call]: pass argument 1
fncall .12                              ; [call]: call generic_panic_41
retd $zero $zero
.25
movi $$arg0 i0                          ; [call]: pass argument 0
fncall .20                              ; [call]: call nested_panic_inlined_same_revert_code_54
retd $zero $zero
DIFF------------------------------
.program:
.0                                      ; --- start of function: __entry ---
move $$locbase $sp                      ; save locals base register for function __entry
cfei i608                               ; allocate 608 bytes for locals and 0 slots for call arguments
.22
addr $r1 data_NonConfigurable_0         ; get __const_global's address in data section
addi $r2 $$locbase i16                  ; get offset to local __ptr { ptr, u64 }
sw $$locbase $r1 i2                     ; store word
movi $r4 i454                           ; initialize constant into register
sw $$locbase $r4 i3                     ; store word
addi $r5 $$locbase i232                 ; get offset to local __ptr slice
mcpi $r5 $r2 i16                        ; copy memory
addi $r6 $$locbase i456                 ; get offset to local __ptr slice
mcpi $r6 $r5 i16                        ; copy memory
addi $r7 $$locbase i456                 ; get offset to local __ptr slice
addi $r8 $$locbase i472                 ; get offset to local __ptr slice
mcpi $r8 $r7 i16                        ; copy memory
addi $r9 $$locbase i472                 ; get offset to local __ptr slice
mcpi $$locbase $r9 i16                  ; copy memory
addi $r11 $$locbase i416                ; get offset to local __ptr { ptr, u64 }
mcpi $r11 $$locbase i16                 ; copy memory
addi $r12 $$locbase i416                ; get offset to local __ptr { ptr, u64 }
addi $r13 $$locbase i432                ; get offset to local __ptr { ptr, u64 }
mcpi $r13 $r12 i16                      ; copy memory
lw $r15 $$locbase i54                   ; load word
lw $r24 $fp i73                         ; lw val ptr i0
addi $r27 $$locbase i376                ; get offset to local __ptr { ptr }
sw $$locbase $r24 i47                   ; store word
addi $r28 $$locbase i448                ; get offset to local __ptr { ptr }
mcpi $r28 $r27 i8                       ; copy memory
lw $r30 $$locbase i56                   ; load word
lw $r31 $r30 i0                         ; lw val ptr i0
move $r32 $r31                          ; return value from ASM block with return register val
lw $r33 $$locbase i56                   ; load word
movi $r34 i8                            ; initialize constant into register
add $r35 $r33 $r34
sw $$locbase $r35 i56                   ; store word
addi $r36 $$locbase i448                ; get offset to local __ptr { ptr }
addi $r37 $$locbase i488                ; get offset to local __ptr { ptr }
mcpi $r37 $r36 i8                       ; copy memory
lw $r39 $$locbase i61                   ; load word
movi $r40 i20                           ; initialize constant into register
eq $r41 $r32 $r40
jnzi $r41 .23
ji  .24
.23
movi $r43 i20                           ; initialize constant into register
addi $r42 $r15 i332
meq $r42 $r39 $r42 $r43
jnzi $r42 .25
.24
movi $r45 i22                           ; initialize constant into register
eq $r46 $r32 $r45
jnzi $r46 .26
ji  .27
.26
movi $r48 i22                           ; initialize constant into register
addi $r47 $r15 i247
meq $r47 $r39 $r47 $r48
jnzi $r47 .28
.27
movi $r50 i23                           ; initialize constant into register
eq $r51 $r32 $r50
jnzi $r51 .29
ji  .30
.29
movi $r53 i23                           ; initialize constant into register
addi $r52 $r15 i269
meq $r52 $r39 $r52 $r53
jnzi $r52 .31
.30
movi $r55 i24                           ; initialize constant into register
eq $r56 $r32 $r55
jnzi $r56 .32
ji  .33
.32
movi $r58 i24                           ; initialize constant into register
addi $r57 $r15 i389
meq $r57 $r39 $r57 $r58
jnzi $r57 .34
.33
movi $r60 i25                           ; initialize constant into register
eq $r61 $r32 $r60
jnzi $r61 .35
ji  .36
.35
movi $r63 i25                           ; initialize constant into register
addi $r62 $r15 i31
meq $r62 $r39 $r62 $r63
jnzi $r62 .37
.36
movi $r65 i31                           ; initialize constant into register
eq $r66 $r32 $r65
jnzi $r66 .38
ji  .39
.38
movi $r68 i31                           ; initialize constant into register
addi $r67 $r15 i0
meq $r67 $r39 $r67 $r68
jnzi $r67 .40
.39
movi $r70 i34                           ; initialize constant into register
eq $r71 $r32 $r70
jnzi $r71 .41
ji  .42
.41
movi $r73 i34                           ; initialize constant into register
addi $r72 $r15 i144
meq $r72 $r39 $r72 $r73
jnzi $r72 .43
.42
movi $r75 i37                           ; initialize constant into register
eq $r76 $r32 $r75
jnzi $r76 .44
ji  .45
.44
movi $r78 i37                           ; initialize constant into register
addi $r77 $r15 i352
meq $r77 $r39 $r77 $r78
jnzi $r77 .46
.45
movi $r80 i39                           ; initialize constant into register
eq $r81 $r32 $r80
jnzi $r81 .47
ji  .48
.47
movi $r83 i39                           ; initialize constant into register
addi $r82 $r15 i56
meq $r82 $r39 $r82 $r83
jnzi $r82 .49
.48
movi $r85 i40                           ; initialize constant into register
eq $r86 $r32 $r85
jnzi $r86 .50
ji  .51
.50
movi $r88 i40                           ; initialize constant into register
addi $r87 $r15 i292
meq $r87 $r39 $r87 $r88
jnzi $r87 .52
.51
movi $r90 i41                           ; initialize constant into register
eq $r91 $r32 $r90
jnzi $r91 .53
ji  .54
.53
movi $r93 i41                           ; initialize constant into register
addi $r92 $r15 i413
meq $r92 $r39 $r92 $r93
jnzi $r92 .55
.54
movi $r95 i49                           ; initialize constant into register
eq $r96 $r32 $r95
jnzi $r96 .56
ji  .57
.56
movi $r98 i49                           ; initialize constant into register
addi $r97 $r15 i95
meq $r97 $r39 $r97 $r98
jnzi $r97 .58
.57
movi $r100 i69                          ; initialize constant into register
eq $r101 $r32 $r100
jnzi $r101 .59
ji  .60
.59
movi $r103 i69                          ; initialize constant into register
addi $r102 $r15 i178
meq $r102 $r39 $r102 $r103
jnzi $r102 .61
.60
movi $r105 i123                         ; initialize constant into register
rvrt $r105
.61
addi $r106 $$locbase i176               ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
sw $$locbase $one i22                   ; store word
addi $r107 $r106 i55                    ; get offset to aggregate element
movi $r108 i42                          ; initialize constant into register
sb $r107 $r108 i0                       ; store byte
addi $r109 $$locbase i552               ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
mcpi $r109 $r106 i56                    ; copy memory
addi $r110 $$locbase i552               ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
addi $r111 $$locbase i360               ; get offset to local __ptr slice
move $$arg0 $r110                       ; [call]: pass argument 0
move $$arg1 $r111                       ; [call]: pass argument 1
fncall .2                               ; [call]: call encode_allow_alias_12
addi $r113 $$locbase i312               ; get offset to local __ptr slice
mcpi $r113 $r111 i16                    ; copy memory
load $r114 data_NonConfigurable_1       ; load constant from data section
lw $r115 $$locbase i39                  ; load slice pointer for logging data
lw $r116 $$locbase i40                  ; load slice size for logging data
logd $zero $r114 $r115 $r116            ; log slice
load $r117 data_NonConfigurable_2       ; load constant from data section
rvrt $r117
.58
addr $r118 data_NonConfigurable_3       ; get __const_global7's address in data section
addi $r119 $$locbase i160               ; get offset to local __ptr { ptr, u64 }
sw $$locbase $r118 i20                  ; store word
movi $r121 i35                          ; initialize constant into register
sw $$locbase $r121 i21                  ; store word
addi $r122 $$locbase i264               ; get offset to local __ptr slice
mcpi $r122 $r119 i16                    ; copy memory
addi $r123 $$locbase i400               ; get offset to local __ptr slice
mcpi $r123 $r122 i16                    ; copy memory
move $$arg0 $r123                       ; [call]: pass argument 0
movi $$arg1 i0                          ; [call]: pass argument 1
fncall .12                              ; [call]: call generic_panic_41
retd $zero $zero
.55
movi $$arg0 i0                          ; [call]: pass argument 0
fncall .16                              ; [call]: call nested_panic_non_inlined_47
retd $zero $zero
.52
movi $$arg0 i0                          ; [call]: pass argument 0
fncall .14                              ; [call]: call generic_panic_with_unit_43
retd $zero $zero
.49
load $r130 data_NonConfigurable_4       ; load constant from data section
rvrt $r130
.46
movi $$arg0 i0                          ; [call]: pass argument 0
fncall .20                              ; [call]: call nested_panic_inlined_same_revert_code_54
retd $zero $zero
.43
addi $r133 $$locbase i104               ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
sw $$locbase $zero i13                  ; store word
addi $r134 $$locbase i496               ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
mcpi $r134 $r133 i56                    ; copy memory
addi $r135 $$locbase i496               ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
addi $r136 $$locbase i344               ; get offset to local __ptr slice
move $$arg0 $r135                       ; [call]: pass argument 0
move $$arg1 $r136                       ; [call]: pass argument 1
fncall .2                               ; [call]: call encode_allow_alias_12
addi $r138 $$locbase i296               ; get offset to local __ptr slice
mcpi $r138 $r136 i16                    ; copy memory
load $r139 data_NonConfigurable_1       ; load constant from data section
lw $r140 $$locbase i37                  ; load slice pointer for logging data
lw $r141 $$locbase i38                  ; load slice size for logging data
logd $zero $r139 $r140 $r141            ; log slice
load $r142 data_NonConfigurable_2       ; load constant from data section
rvrt $r142
.40
load $r143 data_NonConfigurable_5       ; load constant from data section
rvrt $r143
.37
addi $r144 $$locbase i48                ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
movi $r145 i2                           ; initialize constant into register
sw $$locbase $r145 i6                   ; store word
addi $r146 $r144 i55                    ; get offset to aggregate element
sb $r146 $one i0                        ; store byte
addi $r147 $$locbase i328               ; get offset to local __ptr slice
move $$arg0 $r144                       ; [call]: pass argument 0
move $$arg1 $r147                       ; [call]: pass argument 1
fncall .2                               ; [call]: call encode_allow_alias_12
addi $r149 $$locbase i280               ; get offset to local __ptr slice
mcpi $r149 $r147 i16                    ; copy memory
load $r150 data_NonConfigurable_1       ; load constant from data section
lw $r151 $$locbase i35                  ; load slice pointer for logging data
lw $r152 $$locbase i36                  ; load slice size for logging data
logd $zero $r150 $r151 $r152            ; log slice
load $r153 data_NonConfigurable_6       ; load constant from data section
rvrt $r153
.34
movi $$arg0 i0                          ; [call]: pass argument 0
fncall .16                              ; [call]: call nested_panic_non_inlined_47
retd $zero $zero
.31
movi $$arg0 i0                          ; [call]: pass argument 0
fncall .14                              ; [call]: call generic_panic_with_unit_43
retd $zero $zero
.28
addr $r158 data_NonConfigurable_7       ; get __const_global3's address in data section
addi $r159 $$locbase i32                ; get offset to local __ptr { ptr, u64 }
sw $$locbase $r158 i4                   ; store word
movi $r161 i25                          ; initialize constant into register
sw $$locbase $r161 i5                   ; store word
addi $r162 $$locbase i248               ; get offset to local __ptr slice
mcpi $r162 $r159 i16                    ; copy memory
addi $r163 $$locbase i384               ; get offset to local __ptr slice
mcpi $r163 $r162 i16                    ; copy memory
move $$arg0 $r163                       ; [call]: pass argument 0
movi $$arg1 i0                          ; [call]: pass argument 1
fncall .12                              ; [call]: call generic_panic_41
retd $zero $zero
.25
movi $$arg0 i0                          ; [call]: pass argument 0
fncall .20                              ; [call]: call nested_panic_inlined_same_revert_code_54
retd $zero $zero
DIFF------------------------------
.program:
.0                                      ; --- start of function: __entry ---
move $$locbase $sp                      ; save locals base register for function __entry
cfei i608                               ; allocate 608 bytes for locals and 0 slots for call arguments
.22
addr $r1 data_NonConfigurable_0         ; get __const_global's address in data section
addi $r2 $$locbase i16                  ; get offset to local __ptr { ptr, u64 }
sw $$locbase $r1 i2                     ; store word
movi $r4 i454                           ; initialize constant into register
sw $$locbase $r4 i3                     ; store word
addi $r5 $$locbase i232                 ; get offset to local __ptr slice
mcpi $r5 $r2 i16                        ; copy memory
addi $r6 $$locbase i456                 ; get offset to local __ptr slice
mcpi $r6 $r5 i16                        ; copy memory
addi $r7 $$locbase i456                 ; get offset to local __ptr slice
addi $r8 $$locbase i472                 ; get offset to local __ptr slice
mcpi $r8 $r7 i16                        ; copy memory
addi $r9 $$locbase i472                 ; get offset to local __ptr slice
mcpi $$locbase $r9 i16                  ; copy memory
addi $r11 $$locbase i416                ; get offset to local __ptr { ptr, u64 }
mcpi $r11 $$locbase i16                 ; copy memory
addi $r12 $$locbase i416                ; get offset to local __ptr { ptr, u64 }
addi $r13 $$locbase i432                ; get offset to local __ptr { ptr, u64 }
mcpi $r13 $r12 i16                      ; copy memory
lw $r15 $$locbase i54                   ; load word
lw $r24 $fp i73                         ; lw val ptr i0
addi $r27 $$locbase i376                ; get offset to local __ptr { ptr }
sw $$locbase $r24 i47                   ; store word
addi $r28 $$locbase i448                ; get offset to local __ptr { ptr }
mcpi $r28 $r27 i8                       ; copy memory
lw $r30 $$locbase i56                   ; load word
lw $r31 $r30 i0                         ; lw val ptr i0
move $r32 $r31                          ; return value from ASM block with return register val
lw $r33 $$locbase i56                   ; load word
movi $r34 i8                            ; initialize constant into register
add $r35 $r33 $r34
sw $$locbase $r35 i56                   ; store word
addi $r36 $$locbase i448                ; get offset to local __ptr { ptr }
addi $r37 $$locbase i488                ; get offset to local __ptr { ptr }
mcpi $r37 $r36 i8                       ; copy memory
lw $r39 $$locbase i61                   ; load word
movi $r40 i20                           ; initialize constant into register
eq $r41 $r32 $r40
jnzi $r41 .23
ji  .24
.23
movi $r43 i20                           ; initialize constant into register
addi $r42 $r15 i332
meq $r42 $r39 $r42 $r43
jnzi $r42 .25
.24
movi $r45 i22                           ; initialize constant into register
eq $r46 $r32 $r45
jnzi $r46 .26
ji  .27
.26
movi $r48 i22                           ; initialize constant into register
addi $r47 $r15 i247
meq $r47 $r39 $r47 $r48
jnzi $r47 .28
.27
movi $r50 i23                           ; initialize constant into register
eq $r51 $r32 $r50
jnzi $r51 .29
ji  .30
.29
movi $r53 i23                           ; initialize constant into register
addi $r52 $r15 i269
meq $r52 $r39 $r52 $r53
jnzi $r52 .31
.30
movi $r55 i24                           ; initialize constant into register
eq $r56 $r32 $r55
jnzi $r56 .32
ji  .33
.32
movi $r58 i24                           ; initialize constant into register
addi $r57 $r15 i389
meq $r57 $r39 $r57 $r58
jnzi $r57 .34
.33
movi $r60 i25                           ; initialize constant into register
eq $r61 $r32 $r60
jnzi $r61 .35
ji  .36
.35
movi $r63 i25                           ; initialize constant into register
addi $r62 $r15 i31
meq $r62 $r39 $r62 $r63
jnzi $r62 .37
.36
movi $r65 i31                           ; initialize constant into register
eq $r66 $r32 $r65
jnzi $r66 .38
ji  .39
.38
movi $r68 i31                           ; initialize constant into register
addi $r67 $r15 i0
meq $r67 $r39 $r67 $r68
jnzi $r67 .40
.39
movi $r70 i34                           ; initialize constant into register
eq $r71 $r32 $r70
jnzi $r71 .41
ji  .42
.41
movi $r73 i34                           ; initialize constant into register
addi $r72 $r15 i144
meq $r72 $r39 $r72 $r73
jnzi $r72 .43
.42
movi $r75 i37                           ; initialize constant into register
eq $r76 $r32 $r75
jnzi $r76 .44
ji  .45
.44
movi $r78 i37                           ; initialize constant into register
addi $r77 $r15 i352
meq $r77 $r39 $r77 $r78
jnzi $r77 .46
.45
movi $r80 i39                           ; initialize constant into register
eq $r81 $r32 $r80
jnzi $r81 .47
ji  .48
.47
movi $r83 i39                           ; initialize constant into register
addi $r82 $r15 i56
meq $r82 $r39 $r82 $r83
jnzi $r82 .49
.48
movi $r85 i40                           ; initialize constant into register
eq $r86 $r32 $r85
jnzi $r86 .50
ji  .51
.50
movi $r88 i40                           ; initialize constant into register
addi $r87 $r15 i292
meq $r87 $r39 $r87 $r88
jnzi $r87 .52
.51
movi $r90 i41                           ; initialize constant into register
eq $r91 $r32 $r90
jnzi $r91 .53
ji  .54
.53
movi $r93 i41                           ; initialize constant into register
addi $r92 $r15 i413
meq $r92 $r39 $r92 $r93
jnzi $r92 .55
.54
movi $r95 i49                           ; initialize constant into register
eq $r96 $r32 $r95
jnzi $r96 .56
ji  .57
.56
movi $r98 i49                           ; initialize constant into register
addi $r97 $r15 i95
meq $r97 $r39 $r97 $r98
jnzi $r97 .58
.57
movi $r100 i69                          ; initialize constant into register
eq $r101 $r32 $r100
jnzi $r101 .59
ji  .60
.59
movi $r103 i69                          ; initialize constant into register
addi $r102 $r15 i178
meq $r102 $r39 $r102 $r103
jnzi $r102 .61
.60
movi $r105 i123                         ; initialize constant into register
rvrt $r105
.61
addi $r106 $$locbase i176               ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
sw $$locbase $one i22                   ; store word
addi $r107 $r106 i55                    ; get offset to aggregate element
movi $r108 i42                          ; initialize constant into register
sb $r107 $r108 i0                       ; store byte
addi $r109 $$locbase i552               ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
mcpi $r109 $r106 i56                    ; copy memory
addi $r110 $$locbase i552               ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
addi $r111 $$locbase i360               ; get offset to local __ptr slice
move $$arg0 $r110                       ; [call]: pass argument 0
move $$arg1 $r111                       ; [call]: pass argument 1
fncall .2                               ; [call]: call encode_allow_alias_12
addi $r113 $$locbase i312               ; get offset to local __ptr slice
mcpi $r113 $r111 i16                    ; copy memory
load $r114 data_NonConfigurable_1       ; load constant from data section
lw $r115 $$locbase i39                  ; load slice pointer for logging data
lw $r116 $$locbase i40                  ; load slice size for logging data
logd $zero $r114 $r115 $r116            ; log slice
load $r117 data_NonConfigurable_2       ; load constant from data section
rvrt $r117
.58
addr $r118 data_NonConfigurable_3       ; get __const_global7's address in data section
addi $r119 $$locbase i160               ; get offset to local __ptr { ptr, u64 }
sw $$locbase $r118 i20                  ; store word
movi $r121 i35                          ; initialize constant into register
sw $$locbase $r121 i21                  ; store word
addi $r122 $$locbase i264               ; get offset to local __ptr slice
mcpi $r122 $r119 i16                    ; copy memory
addi $r123 $$locbase i400               ; get offset to local __ptr slice
mcpi $r123 $r122 i16                    ; copy memory
move $$arg0 $r123                       ; [call]: pass argument 0
movi $$arg1 i0                          ; [call]: pass argument 1
fncall .12                              ; [call]: call generic_panic_41
retd $zero $zero
.55
movi $$arg0 i0                          ; [call]: pass argument 0
fncall .16                              ; [call]: call nested_panic_non_inlined_47
retd $zero $zero
.52
movi $$arg0 i0                          ; [call]: pass argument 0
fncall .14                              ; [call]: call generic_panic_with_unit_43
retd $zero $zero
.49
load $r130 data_NonConfigurable_4       ; load constant from data section
rvrt $r130
.46
movi $$arg0 i0                          ; [call]: pass argument 0
fncall .20                              ; [call]: call nested_panic_inlined_same_revert_code_54
retd $zero $zero
.43
addi $r133 $$locbase i104               ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
sw $$locbase $zero i13                  ; store word
addi $r134 $$locbase i496               ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
mcpi $r134 $r133 i56                    ; copy memory
addi $r135 $$locbase i496               ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
addi $r136 $$locbase i344               ; get offset to local __ptr slice
move $$arg0 $r135                       ; [call]: pass argument 0
move $$arg1 $r136                       ; [call]: pass argument 1
fncall .2                               ; [call]: call encode_allow_alias_12
addi $r138 $$locbase i296               ; get offset to local __ptr slice
mcpi $r138 $r136 i16                    ; copy memory
load $r139 data_NonConfigurable_1       ; load constant from data section
lw $r140 $$locbase i37                  ; load slice pointer for logging data
lw $r141 $$locbase i38                  ; load slice size for logging data
logd $zero $r139 $r140 $r141            ; log slice
load $r142 data_NonConfigurable_2       ; load constant from data section
rvrt $r142
.40
load $r143 data_NonConfigurable_5       ; load constant from data section
rvrt $r143
.37
addi $r144 $$locbase i48                ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
movi $r145 i2                           ; initialize constant into register
sw $$locbase $r145 i6                   ; store word
addi $r146 $r144 i55                    ; get offset to aggregate element
sb $r146 $one i0                        ; store byte
addi $r147 $$locbase i328               ; get offset to local __ptr slice
move $$arg0 $r144                       ; [call]: pass argument 0
move $$arg1 $r147                       ; [call]: pass argument 1
fncall .2                               ; [call]: call encode_allow_alias_12
addi $r149 $$locbase i280               ; get offset to local __ptr slice
mcpi $r149 $r147 i16                    ; copy memory
load $r150 data_NonConfigurable_1       ; load constant from data section
lw $r151 $$locbase i35                  ; load slice pointer for logging data
lw $r152 $$locbase i36                  ; load slice size for logging data
logd $zero $r150 $r151 $r152            ; log slice
load $r153 data_NonConfigurable_6       ; load constant from data section
rvrt $r153
.34
movi $$arg0 i0                          ; [call]: pass argument 0
fncall .16                              ; [call]: call nested_panic_non_inlined_47
retd $zero $zero
.31
movi $$arg0 i0                          ; [call]: pass argument 0
fncall .14                              ; [call]: call generic_panic_with_unit_43
retd $zero $zero
.28
addr $r158 data_NonConfigurable_7       ; get __const_global3's address in data section
addi $r159 $$locbase i32                ; get offset to local __ptr { ptr, u64 }
sw $$locbase $r158 i4                   ; store word
movi $r161 i25                          ; initialize constant into register
sw $$locbase $r161 i5                   ; store word
addi $r162 $$locbase i248               ; get offset to local __ptr slice
mcpi $r162 $r159 i16                    ; copy memory
addi $r163 $$locbase i384               ; get offset to local __ptr slice
mcpi $r163 $r162 i16                    ; copy memory
move $$arg0 $r163                       ; [call]: pass argument 0
movi $$arg1 i0                          ; [call]: pass argument 1
fncall .12                              ; [call]: call generic_panic_41
retd $zero $zero
.25
movi $$arg0 i0                          ; [call]: pass argument 0
fncall .20                              ; [call]: call nested_panic_inlined_same_revert_code_54
retd $zero $zero
DIFF------------------------------
.program:
.2                                      ; --- start of function: encode_allow_alias_12 ---
pusha .2                                ; save all registers
move $$locbase $sp                      ; save locals base register for function encode_allow_alias_12
cfei i1520                              ; allocate 1520 bytes for locals and 0 slots for call arguments
move $r168 $$arg0                       ; save argument 0 (item)
move $r169 $$arg1                       ; save argument 1 (__ret_value)
move $r170 $$reta                       ; save return address
.62
 move $r171 $zero                        ; move parameter from branch to block argument
 jnzi $zero .63
 movi $r171 i0                           ; move parameter from branch to block argument
 
ji  .64
.63
 move $r171 $one                         ; move parameter from branch to block argument
 movi $r171 i1                           ; move parameter from branch to block argument
ji  .64
.64
move $r174 $r171                        ; move parameter from branch to block argument
 move $r175 $r174                        ; move parameter from branch to block argument
 jnzi $r174 .65
 move $r175 $r171                        ; move parameter from branch to block argument
 jnzi $r171 .65
ji  .66
.65
 move $r175 $one                         ; move parameter from branch to block argument
 movi $r175 i1                           ; move parameter from branch to block argument
ji  .66
.66
move $r178 $r175                        ; move parameter from branch to block argument
 move $r179 $r178                        ; move parameter from branch to block argument
 jnzi $r178 .67
 move $r179 $r175                        ; move parameter from branch to block argument
 jnzi $r175 .67
ji  .68
.67
 move $r179 $zero                        ; move parameter from branch to block argument
 movi $r179 i0                           ; move parameter from branch to block argument
ji  .68
.68
move $r182 $r179                        ; move parameter from branch to block argument
 jnzi $r182 .69
 jnzi $r179 .69
ji  .70
.70
addi $r183 $$locbase i456               ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r183                       ; [call]: pass argument 0
fncall .8                               ; [call]: call new_38
 move $r184 $zero                        ; [call]: return unit value
 movi $r184 i0                           ; [call]: return unit value
addi $r185 $$locbase i1336              ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
mcpi $r185 $r168 i56                    ; copy memory
addi $r186 $$locbase i928               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r186 $r183 i24                    ; copy memory
addi $r187 $$locbase i1336              ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
addi $r188 $$locbase i208               ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
mcpi $r188 $r187 i56                    ; copy memory
addi $r189 $$locbase i208               ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
lw $r190 $$locbase i26                  ; load word
eq $r191 $r190 $zero
jnzi $r191 .71
ji  .72
.72
addi $r192 $$locbase i208               ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
lw $r193 $$locbase i26                  ; load word
eq $r194 $r193 $one
jnzi $r194 .73
ji  .74
.74
addi $r195 $$locbase i208               ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
lw $r196 $$locbase i26                  ; load word
movi $r197 i2                           ; initialize constant into register
eq $r198 $r196 $r197
jnzi $r198 .75
ji  .76
.76
addi $r199 $$locbase i208               ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
lw $r200 $$locbase i26                  ; load word
movi $r201 i3                           ; initialize constant into register
eq $r202 $r200 $r201
jnzi $r202 .77
ji  .78
.78
addi $r203 $$locbase i208               ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
lw $r204 $$locbase i26                  ; load word
movi $r205 i4                           ; initialize constant into register
eq $r206 $r204 $r205
jnzi $r206 .79
ji  .80
.80
load $r207 data_NonConfigurable_8       ; load constant from data section
rvrt $r207
.79
addi $r208 $$locbase i208               ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
addi $r209 $r208 i8                     ; get offset to aggregate element
addi $r210 $$locbase i1472              ; get offset to local __ptr [slice; 3]
mcpi $r210 $r209 i48                    ; copy memory
addi $r211 $$locbase i928               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r212 $$locbase i688               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r212 $r211 i24                    ; copy memory
addi $r213 $$locbase i408               ; get offset to local __ptr { { ptr, u64, u64 } }
movi $r214 i4                           ; initialize constant into register
 move $$arg0 $r214                       ; [call]: pass argument 0
 movi $$arg0 i4                          ; [call]: pass argument 0
move $$arg1 $r212                       ; [call]: pass argument 1
move $$arg2 $r213                       ; [call]: pass argument 2
fncall .4                               ; [call]: call abi_encode_30
 move $r215 $zero                        ; [call]: return unit value
 movi $r215 i0                           ; [call]: return unit value
addi $r216 $$locbase i1264              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r216 $r213 i24                    ; copy memory
addi $r217 $$locbase i1472              ; get offset to local __ptr [slice; 3]
addi $r218 $$locbase i1264              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r219 $$locbase i1408              ; get offset to local __ptr [slice; 3]
mcpi $r219 $r217 i48                    ; copy memory
addi $r220 $$locbase i1024              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r220 $r218 i24                    ; copy memory
addi $r221 $$locbase i1024              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r222 $$locbase i1096              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r222 $r221 i24                    ; copy memory
 move $r223 $zero                        ; move parameter from branch to block argument
 movi $r223 i0                           ; move parameter from branch to block argument
ji  .81
.81
move $r225 $r223                        ; move parameter from branch to block argument
movi $r226 i3                           ; initialize constant into register
 lt $r227 $r225 $r226
 lt $r227 $r223 $r226
jnzi $r227 .82
ji  .83
.83
addi $r228 $$locbase i1096              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r229 $$locbase i1288              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r229 $r228 i24                    ; copy memory
addi $r230 $$locbase i1288              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r231 $$locbase i776               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r231 $r230 i24                    ; copy memory
move $r232 $r231                        ; move parameter from branch to block argument
ji  .84
.82
addi $r233 $$locbase i1408              ; get offset to local __ptr [slice; 3]
movi $r234 i16                          ; get array element size
mul $r235 $r225 $r234                   ; get offset to array element
add $r235 $r233 $r235                   ; add array element offset to array base
addi $r236 $$locbase i1096              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r237 $$locbase i712               ; get offset to local __ptr slice
mcpi $r237 $r235 i16                    ; copy memory
addi $r238 $$locbase i728               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r238 $r236 i24                    ; copy memory
addi $r239 $$locbase i432               ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r237                       ; [call]: pass argument 0
move $$arg1 $r238                       ; [call]: pass argument 1
move $$arg2 $r239                       ; [call]: pass argument 2
fncall .6                               ; [call]: call abi_encode_36
 move $r240 $zero                        ; [call]: return unit value
 movi $r240 i0                           ; [call]: return unit value
addi $r241 $$locbase i1096              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r241 $r239 i24                    ; copy memory
add $r242 $r225 $one
move $r223 $r242                        ; move parameter from branch to block argument
ji  .81
.77
addi $r244 $$locbase i208               ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
addi $r245 $r244 i40                    ; get offset to aggregate element
addi $r246 $$locbase i1456              ; get offset to local __ptr { u64, u64 }
mcpi $r246 $r245 i16                    ; copy memory
addi $r247 $$locbase i928               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r248 $$locbase i616               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r248 $r247 i24                    ; copy memory
addi $r249 $$locbase i336               ; get offset to local __ptr { { ptr, u64, u64 } }
movi $r250 i3                           ; initialize constant into register
 move $$arg0 $r250                       ; [call]: pass argument 0
 movi $$arg0 i3                          ; [call]: pass argument 0
move $$arg1 $r248                       ; [call]: pass argument 1
move $$arg2 $r249                       ; [call]: pass argument 2
fncall .4                               ; [call]: call abi_encode_30
 move $r251 $zero                        ; [call]: return unit value
 movi $r251 i0                           ; [call]: return unit value
addi $r252 $$locbase i1216              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r252 $r249 i24                    ; copy memory
addi $r253 $$locbase i1456              ; get offset to local __ptr { u64, u64 }
addi $r254 $$locbase i1216              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r255 $$locbase i1392              ; get offset to local __ptr { u64, u64 }
mcpi $r255 $r253 i16                    ; copy memory
addi $r256 $$locbase i1000              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r256 $r254 i24                    ; copy memory
addi $r257 $$locbase i1392              ; get offset to local __ptr { u64, u64 }
lw $r258 $$locbase i174                 ; load word
addi $r259 $$locbase i1000              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r260 $$locbase i640               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r260 $r259 i24                    ; copy memory
addi $r261 $$locbase i360               ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r258                       ; [call]: pass argument 0
move $$arg1 $r260                       ; [call]: pass argument 1
move $$arg2 $r261                       ; [call]: pass argument 2
fncall .4                               ; [call]: call abi_encode_30
 move $r262 $zero                        ; [call]: return unit value
 movi $r262 i0                           ; [call]: return unit value
addi $r263 $$locbase i1072              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r263 $r261 i24                    ; copy memory
addi $r264 $$locbase i1392              ; get offset to local __ptr { u64, u64 }
addi $r265 $r264 i8                     ; get offset to aggregate element
lw $r266 $$locbase i175                 ; load word
addi $r267 $$locbase i1072              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r268 $$locbase i664               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r268 $r267 i24                    ; copy memory
addi $r269 $$locbase i384               ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r266                       ; [call]: pass argument 0
move $$arg1 $r268                       ; [call]: pass argument 1
move $$arg2 $r269                       ; [call]: pass argument 2
fncall .4                               ; [call]: call abi_encode_30
 move $r270 $zero                        ; [call]: return unit value
 movi $r270 i0                           ; [call]: return unit value
addi $r271 $$locbase i1144              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r271 $r269 i24                    ; copy memory
addi $r272 $$locbase i1144              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r273 $$locbase i1240              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r273 $r272 i24                    ; copy memory
addi $r274 $$locbase i1240              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r275 $$locbase i776               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r275 $r274 i24                    ; copy memory
move $r232 $r275                        ; move parameter from branch to block argument
ji  .84
.84
move $r278 $r232                        ; move parameter from branch to block argument
addi $r279 $$locbase i800               ; get offset to local __ptr { { ptr, u64, u64 } }
 mcpi $r279 $r278 i24                    ; copy memory
 mcpi $r279 $r232 i24                    ; copy memory
move $r280 $r279                        ; move parameter from branch to block argument
ji  .85
.75
addi $r281 $$locbase i208               ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
addi $r282 $r281 i55                    ; get offset to aggregate element
lb $r283 $r282 i0                       ; load byte
addi $r284 $$locbase i928               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r285 $$locbase i592               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r285 $r284 i24                    ; copy memory
addi $r286 $$locbase i312               ; get offset to local __ptr { { ptr, u64, u64 } }
movi $r287 i2                           ; initialize constant into register
 move $$arg0 $r287                       ; [call]: pass argument 0
 movi $$arg0 i2                          ; [call]: pass argument 0
move $$arg1 $r285                       ; [call]: pass argument 1
move $$arg2 $r286                       ; [call]: pass argument 2
fncall .4                               ; [call]: call abi_encode_30
 move $r288 $zero                        ; [call]: return unit value
 movi $r288 i0                           ; [call]: return unit value
addi $r289 $$locbase i1168              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r289 $r286 i24                    ; copy memory
addi $r290 $$locbase i1168              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r291 $$locbase i976               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r291 $r290 i24                    ; copy memory
addi $r292 $$locbase i520               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r293 $$locbase i976               ; get offset to local __ptr { { ptr, u64, u64 } }
move $r294 $r293                        ; return value from ASM block with return register buffer
addi $r295 $$locbase i48                ; get offset to local __ptr { ptr, u64, u64 }
 mcpi $r295 $r294 i24                    ; copy memory
 mcpi $r295 $r293 i24                    ; copy memory
addi $r296 $$locbase i136               ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r296 $r295 i24                    ; copy memory
lw $r297 $$locbase i17                  ; load word
addi $r298 $r296 i8                     ; get offset to aggregate element
lw $r299 $$locbase i18                  ; load word
addi $r300 $r296 i16                    ; get offset to aggregate element
lw $r301 $$locbase i19                  ; load word
add $r302 $r301 $one
gt $r303 $r302 $r299
move $r304 $r297                        ; move parameter from branch to block argument
move $r305 $r299                        ; move parameter from branch to block argument
jnzi $r303 .86
ji  .87
.86
movi $r306 i2                           ; initialize constant into register
mul $r307 $r299 $r306
add $r308 $r307 $one
aloc $r308
mcp $hp $r297 $r301
move $r309 $hp                          ; return value from ASM block with return register hp
 move $r304 $r309                        ; move parameter from branch to block argument
 move $r304 $hp                          ; move parameter from branch to block argument
move $r305 $r308                        ; move parameter from branch to block argument
ji  .87
.87
move $r313 $r304                        ; move parameter from branch to block argument
move $r315 $r305                        ; move parameter from branch to block argument
 add $r316 $r313 $r301
 add $r316 $r304 $r301
sb $r316 $r283 i0                       ; store byte
addi $r317 $$locbase i184               ; get offset to local __ptr { ptr, u64, u64 }
sw $$locbase $r313 i23                  ; store word
addi $r318 $r317 i8                     ; get offset to aggregate element
sw $$locbase $r315 i24                  ; store word
addi $r319 $r317 i16                    ; get offset to aggregate element
sw $$locbase $r302 i25                  ; store word
move $r320 $r317                        ; return value from ASM block with return register buffer
addi $r321 $$locbase i72                ; get offset to local __ptr { ptr, u64, u64 }
 mcpi $r321 $r320 i24                    ; copy memory
 mcpi $r321 $r317 i24                    ; copy memory
mcpi $r292 $r321 i24                    ; copy memory
addi $r322 $$locbase i1192              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r322 $r292 i24                    ; copy memory
addi $r323 $$locbase i1192              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r324 $$locbase i800               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r324 $r323 i24                    ; copy memory
move $r280 $r324                        ; move parameter from branch to block argument
ji  .85
.85
move $r327 $r280                        ; move parameter from branch to block argument
addi $r328 $$locbase i824               ; get offset to local __ptr { { ptr, u64, u64 } }
 mcpi $r328 $r327 i24                    ; copy memory
 mcpi $r328 $r280 i24                    ; copy memory
move $r329 $r328                        ; move parameter from branch to block argument
ji  .88
.73
addi $r330 $$locbase i208               ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
addi $r331 $r330 i55                    ; get offset to aggregate element
lb $r332 $r331 i0                       ; load byte
addi $r333 $$locbase i928               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r334 $$locbase i568               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r334 $r333 i24                    ; copy memory
addi $r335 $$locbase i288               ; get offset to local __ptr { { ptr, u64, u64 } }
 move $$arg0 $one                        ; [call]: pass argument 0
 movi $$arg0 i1                          ; [call]: pass argument 0
move $$arg1 $r334                       ; [call]: pass argument 1
move $$arg2 $r335                       ; [call]: pass argument 2
fncall .4                               ; [call]: call abi_encode_30
 move $r336 $zero                        ; [call]: return unit value
 movi $r336 i0                           ; [call]: return unit value
addi $r337 $$locbase i1048              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r337 $r335 i24                    ; copy memory
addi $r338 $$locbase i1048              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r339 $$locbase i952               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r339 $r338 i24                    ; copy memory
addi $r340 $$locbase i496               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r341 $$locbase i952               ; get offset to local __ptr { { ptr, u64, u64 } }
move $r342 $r341                        ; return value from ASM block with return register buffer
 mcpi $$locbase $r342 i24                ; copy memory
 mcpi $$locbase $r341 i24                ; copy memory
addi $r343 $$locbase i112               ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r343 $$locbase i24                ; copy memory
lw $r344 $$locbase i14                  ; load word
addi $r345 $r343 i8                     ; get offset to aggregate element
lw $r346 $$locbase i15                  ; load word
addi $r347 $r343 i16                    ; get offset to aggregate element
lw $r348 $$locbase i16                  ; load word
add $r349 $r348 $one
gt $r350 $r349 $r346
move $r351 $r344                        ; move parameter from branch to block argument
move $r352 $r346                        ; move parameter from branch to block argument
jnzi $r350 .89
ji  .90
.89
movi $r353 i2                           ; initialize constant into register
mul $r354 $r346 $r353
add $r355 $r354 $one
aloc $r355
mcp $hp $r344 $r348
move $r356 $hp                          ; return value from ASM block with return register hp
 move $r351 $r356                        ; move parameter from branch to block argument
 move $r351 $hp                          ; move parameter from branch to block argument
move $r352 $r355                        ; move parameter from branch to block argument
ji  .90
.90
move $r360 $r351                        ; move parameter from branch to block argument
move $r362 $r352                        ; move parameter from branch to block argument
 add $r363 $r360 $r348
 add $r363 $r351 $r348
sb $r363 $r332 i0                       ; store byte
addi $r364 $$locbase i160               ; get offset to local __ptr { ptr, u64, u64 }
sw $$locbase $r360 i20                  ; store word
addi $r365 $r364 i8                     ; get offset to aggregate element
sw $$locbase $r362 i21                  ; store word
addi $r366 $r364 i16                    ; get offset to aggregate element
sw $$locbase $r349 i22                  ; store word
move $r367 $r364                        ; return value from ASM block with return register buffer
addi $r368 $$locbase i24                ; get offset to local __ptr { ptr, u64, u64 }
 mcpi $r368 $r367 i24                    ; copy memory
 mcpi $r368 $r364 i24                    ; copy memory
mcpi $r340 $r368 i24                    ; copy memory
addi $r369 $$locbase i1120              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r369 $r340 i24                    ; copy memory
addi $r370 $$locbase i1120              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r371 $$locbase i824               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r371 $r370 i24                    ; copy memory
move $r329 $r371                        ; move parameter from branch to block argument
ji  .88
.88
move $r374 $r329                        ; move parameter from branch to block argument
addi $r375 $$locbase i848               ; get offset to local __ptr { { ptr, u64, u64 } }
 mcpi $r375 $r374 i24                    ; copy memory
 mcpi $r375 $r329 i24                    ; copy memory
move $r376 $r375                        ; move parameter from branch to block argument
ji  .91
.71
addi $r377 $$locbase i928               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r378 $$locbase i544               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r378 $r377 i24                    ; copy memory
addi $r379 $$locbase i264               ; get offset to local __ptr { { ptr, u64, u64 } }
 move $$arg0 $zero                       ; [call]: pass argument 0
 movi $$arg0 i0                          ; [call]: pass argument 0
move $$arg1 $r378                       ; [call]: pass argument 1
move $$arg2 $r379                       ; [call]: pass argument 2
fncall .4                               ; [call]: call abi_encode_30
 move $r380 $zero                        ; [call]: return unit value
 movi $r380 i0                           ; [call]: return unit value
addi $r381 $$locbase i848               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r381 $r379 i24                    ; copy memory
move $r376 $r381                        ; move parameter from branch to block argument
ji  .91
.91
move $r384 $r376                        ; move parameter from branch to block argument
addi $r385 $$locbase i1312              ; get offset to local __ptr { { ptr, u64, u64 } }
 mcpi $r385 $r384 i24                    ; copy memory
 mcpi $r385 $r376 i24                    ; copy memory
addi $r386 $$locbase i1312              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r387 $$locbase i904               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r387 $r386 i24                    ; copy memory
addi $r388 $$locbase i904               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r389 $$locbase i752               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r389 $r388 i24                    ; copy memory
addi $r390 $$locbase i480               ; get offset to local __ptr slice
move $$arg0 $r389                       ; [call]: pass argument 0
move $$arg1 $r390                       ; [call]: pass argument 1
fncall .10                              ; [call]: call as_raw_slice_39
 move $r391 $zero                        ; [call]: return unit value
 movi $r391 i0                           ; [call]: return unit value
addi $r392 $$locbase i872               ; get offset to local __ptr slice
mcpi $r392 $r390 i16                    ; copy memory
move $r393 $r392                        ; move parameter from branch to block argument
ji  .92
.69
addi $r394 $$locbase i888               ; get offset to local __ptr { __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }, u64 }
sw $$locbase $r168 i111                 ; store word
addi $r395 $r394 i8                     ; get offset to aggregate element
movi $r396 i56                          ; initialize constant into register
sw $$locbase $r396 i112                 ; store word
addi $r397 $$locbase i96                ; get offset to local __ptr { __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }, u64 }
mcpi $r397 $r394 i16                    ; copy memory
addi $r398 $$locbase i872               ; get offset to local __ptr slice
mcpi $r398 $r397 i16                    ; copy memory
move $r393 $r398                        ; move parameter from branch to block argument
ji  .92
.92
move $r401 $r393                        ; move parameter from branch to block argument
 mcpi $r169 $r401 i16                    ; copy memory
 mcpi $r169 $r393 i16                    ; copy memory
ji  .3
.3
cfsi i1520                              ; free 1520 bytes for locals and 0 slots for extra call arguments
move $$reta $r170                       ; restore return address
popa .2                                 ; restore all registers
jal $zero $$reta i0                     ; return from call
DIFF------------------------------
.program:
.2                                      ; --- start of function: encode_allow_alias_12 ---
pusha .2                                ; save all registers
move $$locbase $sp                      ; save locals base register for function encode_allow_alias_12
cfei i1520                              ; allocate 1520 bytes for locals and 0 slots for call arguments
move $r168 $$arg0                       ; save argument 0 (item)
move $r169 $$arg1                       ; save argument 1 (__ret_value)
move $r170 $$reta                       ; save return address
.62
movi $r171 i0                           ; move parameter from branch to block argument
.64
 move $r175 $r171                        ; move parameter from branch to block argument
 jnzi $r171 .65
 movi $r175 i0                           ; move parameter from branch to block argument
 
ji  .66
.65
movi $r175 i1                           ; move parameter from branch to block argument
.66
move $r179 $r175                        ; move parameter from branch to block argument
jnzi $r175 .67
ji  .68
.67
movi $r179 i0                           ; move parameter from branch to block argument
.68
jnzi $r179 .69
.70
addi $r183 $$locbase i456               ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r183                       ; [call]: pass argument 0
fncall .8                               ; [call]: call new_38
addi $r185 $$locbase i1336              ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
mcpi $r185 $r168 i56                    ; copy memory
addi $r186 $$locbase i928               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r186 $r183 i24                    ; copy memory
addi $r187 $$locbase i1336              ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
addi $r188 $$locbase i208               ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
mcpi $r188 $r187 i56                    ; copy memory
lw $r190 $$locbase i26                  ; load word
eq $r191 $r190 $zero
jnzi $r191 .71
.72
lw $r193 $$locbase i26                  ; load word
eq $r194 $r193 $one
jnzi $r194 .73
.74
lw $r196 $$locbase i26                  ; load word
movi $r197 i2                           ; initialize constant into register
eq $r198 $r196 $r197
jnzi $r198 .75
.76
lw $r200 $$locbase i26                  ; load word
movi $r201 i3                           ; initialize constant into register
eq $r202 $r200 $r201
jnzi $r202 .77
.78
lw $r204 $$locbase i26                  ; load word
movi $r205 i4                           ; initialize constant into register
eq $r206 $r204 $r205
jnzi $r206 .79
.80
load $r207 data_NonConfigurable_8       ; load constant from data section
rvrt $r207
.79
addi $r208 $$locbase i208               ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
addi $r209 $r208 i8                     ; get offset to aggregate element
addi $r210 $$locbase i1472              ; get offset to local __ptr [slice; 3]
mcpi $r210 $r209 i48                    ; copy memory
addi $r211 $$locbase i928               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r212 $$locbase i688               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r212 $r211 i24                    ; copy memory
addi $r213 $$locbase i408               ; get offset to local __ptr { { ptr, u64, u64 } }
movi $$arg0 i4                          ; [call]: pass argument 0
move $$arg1 $r212                       ; [call]: pass argument 1
move $$arg2 $r213                       ; [call]: pass argument 2
fncall .4                               ; [call]: call abi_encode_30
addi $r216 $$locbase i1264              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r216 $r213 i24                    ; copy memory
addi $r217 $$locbase i1472              ; get offset to local __ptr [slice; 3]
addi $r218 $$locbase i1264              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r219 $$locbase i1408              ; get offset to local __ptr [slice; 3]
mcpi $r219 $r217 i48                    ; copy memory
addi $r220 $$locbase i1024              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r220 $r218 i24                    ; copy memory
addi $r221 $$locbase i1024              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r222 $$locbase i1096              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r222 $r221 i24                    ; copy memory
movi $r223 i0                           ; move parameter from branch to block argument
.81
move $r225 $r223                        ; move parameter from branch to block argument
movi $r226 i3                           ; initialize constant into register
lt $r227 $r223 $r226
jnzi $r227 .82
.83
addi $r228 $$locbase i1096              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r229 $$locbase i1288              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r229 $r228 i24                    ; copy memory
addi $r230 $$locbase i1288              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r231 $$locbase i776               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r231 $r230 i24                    ; copy memory
move $r232 $r231                        ; move parameter from branch to block argument
ji  .84
.82
addi $r233 $$locbase i1408              ; get offset to local __ptr [slice; 3]
movi $r234 i16                          ; get array element size
mul $r235 $r225 $r234                   ; get offset to array element
add $r235 $r233 $r235                   ; add array element offset to array base
addi $r236 $$locbase i1096              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r237 $$locbase i712               ; get offset to local __ptr slice
mcpi $r237 $r235 i16                    ; copy memory
addi $r238 $$locbase i728               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r238 $r236 i24                    ; copy memory
addi $r239 $$locbase i432               ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r237                       ; [call]: pass argument 0
move $$arg1 $r238                       ; [call]: pass argument 1
move $$arg2 $r239                       ; [call]: pass argument 2
fncall .6                               ; [call]: call abi_encode_36
addi $r241 $$locbase i1096              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r241 $r239 i24                    ; copy memory
add $r242 $r225 $one
move $r223 $r242                        ; move parameter from branch to block argument
ji  .81
.77
addi $r244 $$locbase i208               ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
addi $r245 $r244 i40                    ; get offset to aggregate element
addi $r246 $$locbase i1456              ; get offset to local __ptr { u64, u64 }
mcpi $r246 $r245 i16                    ; copy memory
addi $r247 $$locbase i928               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r248 $$locbase i616               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r248 $r247 i24                    ; copy memory
addi $r249 $$locbase i336               ; get offset to local __ptr { { ptr, u64, u64 } }
movi $$arg0 i3                          ; [call]: pass argument 0
move $$arg1 $r248                       ; [call]: pass argument 1
move $$arg2 $r249                       ; [call]: pass argument 2
fncall .4                               ; [call]: call abi_encode_30
addi $r252 $$locbase i1216              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r252 $r249 i24                    ; copy memory
addi $r253 $$locbase i1456              ; get offset to local __ptr { u64, u64 }
addi $r254 $$locbase i1216              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r255 $$locbase i1392              ; get offset to local __ptr { u64, u64 }
mcpi $r255 $r253 i16                    ; copy memory
addi $r256 $$locbase i1000              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r256 $r254 i24                    ; copy memory
lw $r258 $$locbase i174                 ; load word
addi $r259 $$locbase i1000              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r260 $$locbase i640               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r260 $r259 i24                    ; copy memory
addi $r261 $$locbase i360               ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r258                       ; [call]: pass argument 0
move $$arg1 $r260                       ; [call]: pass argument 1
move $$arg2 $r261                       ; [call]: pass argument 2
fncall .4                               ; [call]: call abi_encode_30
addi $r263 $$locbase i1072              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r263 $r261 i24                    ; copy memory
lw $r266 $$locbase i175                 ; load word
addi $r267 $$locbase i1072              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r268 $$locbase i664               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r268 $r267 i24                    ; copy memory
addi $r269 $$locbase i384               ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r266                       ; [call]: pass argument 0
move $$arg1 $r268                       ; [call]: pass argument 1
move $$arg2 $r269                       ; [call]: pass argument 2
fncall .4                               ; [call]: call abi_encode_30
addi $r271 $$locbase i1144              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r271 $r269 i24                    ; copy memory
addi $r272 $$locbase i1144              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r273 $$locbase i1240              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r273 $r272 i24                    ; copy memory
addi $r274 $$locbase i1240              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r275 $$locbase i776               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r275 $r274 i24                    ; copy memory
move $r232 $r275                        ; move parameter from branch to block argument
.84
addi $r279 $$locbase i800               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r279 $r232 i24                    ; copy memory
move $r280 $r279                        ; move parameter from branch to block argument
ji  .85
.75
addi $r281 $$locbase i208               ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
addi $r282 $r281 i55                    ; get offset to aggregate element
lb $r283 $r282 i0                       ; load byte
addi $r284 $$locbase i928               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r285 $$locbase i592               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r285 $r284 i24                    ; copy memory
addi $r286 $$locbase i312               ; get offset to local __ptr { { ptr, u64, u64 } }
movi $$arg0 i2                          ; [call]: pass argument 0
move $$arg1 $r285                       ; [call]: pass argument 1
move $$arg2 $r286                       ; [call]: pass argument 2
fncall .4                               ; [call]: call abi_encode_30
addi $r289 $$locbase i1168              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r289 $r286 i24                    ; copy memory
addi $r290 $$locbase i1168              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r291 $$locbase i976               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r291 $r290 i24                    ; copy memory
addi $r292 $$locbase i520               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r293 $$locbase i976               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r295 $$locbase i48                ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r295 $r293 i24                    ; copy memory
addi $r296 $$locbase i136               ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r296 $r295 i24                    ; copy memory
lw $r297 $$locbase i17                  ; load word
lw $r299 $$locbase i18                  ; load word
lw $r301 $$locbase i19                  ; load word
add $r302 $r301 $one
gt $r303 $r302 $r299
move $r304 $r297                        ; move parameter from branch to block argument
move $r305 $r299                        ; move parameter from branch to block argument
jnzi $r303 .86
ji  .87
.86
movi $r306 i2                           ; initialize constant into register
mul $r307 $r299 $r306
add $r308 $r307 $one
aloc $r308
mcp $hp $r297 $r301
move $r304 $hp                          ; move parameter from branch to block argument
move $r305 $r308                        ; move parameter from branch to block argument
.87
move $r313 $r304                        ; move parameter from branch to block argument
move $r315 $r305                        ; move parameter from branch to block argument
add $r316 $r304 $r301
sb $r316 $r283 i0                       ; store byte
addi $r317 $$locbase i184               ; get offset to local __ptr { ptr, u64, u64 }
sw $$locbase $r313 i23                  ; store word
sw $$locbase $r315 i24                  ; store word
sw $$locbase $r302 i25                  ; store word
addi $r321 $$locbase i72                ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r321 $r317 i24                    ; copy memory
mcpi $r292 $r321 i24                    ; copy memory
addi $r322 $$locbase i1192              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r322 $r292 i24                    ; copy memory
addi $r323 $$locbase i1192              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r324 $$locbase i800               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r324 $r323 i24                    ; copy memory
move $r280 $r324                        ; move parameter from branch to block argument
.85
addi $r328 $$locbase i824               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r328 $r280 i24                    ; copy memory
move $r329 $r328                        ; move parameter from branch to block argument
ji  .88
.73
addi $r330 $$locbase i208               ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
addi $r331 $r330 i55                    ; get offset to aggregate element
lb $r332 $r331 i0                       ; load byte
addi $r333 $$locbase i928               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r334 $$locbase i568               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r334 $r333 i24                    ; copy memory
addi $r335 $$locbase i288               ; get offset to local __ptr { { ptr, u64, u64 } }
movi $$arg0 i1                          ; [call]: pass argument 0
move $$arg1 $r334                       ; [call]: pass argument 1
move $$arg2 $r335                       ; [call]: pass argument 2
fncall .4                               ; [call]: call abi_encode_30
addi $r337 $$locbase i1048              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r337 $r335 i24                    ; copy memory
addi $r338 $$locbase i1048              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r339 $$locbase i952               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r339 $r338 i24                    ; copy memory
addi $r340 $$locbase i496               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r341 $$locbase i952               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $$locbase $r341 i24                ; copy memory
addi $r343 $$locbase i112               ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r343 $$locbase i24                ; copy memory
lw $r344 $$locbase i14                  ; load word
lw $r346 $$locbase i15                  ; load word
lw $r348 $$locbase i16                  ; load word
add $r349 $r348 $one
gt $r350 $r349 $r346
move $r351 $r344                        ; move parameter from branch to block argument
move $r352 $r346                        ; move parameter from branch to block argument
jnzi $r350 .89
ji  .90
.89
movi $r353 i2                           ; initialize constant into register
mul $r354 $r346 $r353
add $r355 $r354 $one
aloc $r355
mcp $hp $r344 $r348
move $r351 $hp                          ; move parameter from branch to block argument
move $r352 $r355                        ; move parameter from branch to block argument
.90
move $r360 $r351                        ; move parameter from branch to block argument
move $r362 $r352                        ; move parameter from branch to block argument
add $r363 $r351 $r348
sb $r363 $r332 i0                       ; store byte
addi $r364 $$locbase i160               ; get offset to local __ptr { ptr, u64, u64 }
sw $$locbase $r360 i20                  ; store word
sw $$locbase $r362 i21                  ; store word
sw $$locbase $r349 i22                  ; store word
addi $r368 $$locbase i24                ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r368 $r364 i24                    ; copy memory
mcpi $r340 $r368 i24                    ; copy memory
addi $r369 $$locbase i1120              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r369 $r340 i24                    ; copy memory
addi $r370 $$locbase i1120              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r371 $$locbase i824               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r371 $r370 i24                    ; copy memory
move $r329 $r371                        ; move parameter from branch to block argument
.88
addi $r375 $$locbase i848               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r375 $r329 i24                    ; copy memory
move $r376 $r375                        ; move parameter from branch to block argument
ji  .91
.71
addi $r377 $$locbase i928               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r378 $$locbase i544               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r378 $r377 i24                    ; copy memory
addi $r379 $$locbase i264               ; get offset to local __ptr { { ptr, u64, u64 } }
movi $$arg0 i0                          ; [call]: pass argument 0
move $$arg1 $r378                       ; [call]: pass argument 1
move $$arg2 $r379                       ; [call]: pass argument 2
fncall .4                               ; [call]: call abi_encode_30
addi $r381 $$locbase i848               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r381 $r379 i24                    ; copy memory
move $r376 $r381                        ; move parameter from branch to block argument
.91
addi $r385 $$locbase i1312              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r385 $r376 i24                    ; copy memory
addi $r386 $$locbase i1312              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r387 $$locbase i904               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r387 $r386 i24                    ; copy memory
addi $r388 $$locbase i904               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r389 $$locbase i752               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r389 $r388 i24                    ; copy memory
addi $r390 $$locbase i480               ; get offset to local __ptr slice
move $$arg0 $r389                       ; [call]: pass argument 0
move $$arg1 $r390                       ; [call]: pass argument 1
fncall .10                              ; [call]: call as_raw_slice_39
addi $r392 $$locbase i872               ; get offset to local __ptr slice
mcpi $r392 $r390 i16                    ; copy memory
move $r393 $r392                        ; move parameter from branch to block argument
ji  .92
.69
addi $r394 $$locbase i888               ; get offset to local __ptr { __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }, u64 }
sw $$locbase $r168 i111                 ; store word
movi $r396 i56                          ; initialize constant into register
sw $$locbase $r396 i112                 ; store word
addi $r397 $$locbase i96                ; get offset to local __ptr { __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }, u64 }
mcpi $r397 $r394 i16                    ; copy memory
addi $r398 $$locbase i872               ; get offset to local __ptr slice
mcpi $r398 $r397 i16                    ; copy memory
move $r393 $r398                        ; move parameter from branch to block argument
.92
mcpi $r169 $r393 i16                    ; copy memory
.3
cfsi i1520                              ; free 1520 bytes for locals and 0 slots for extra call arguments
move $$reta $r170                       ; restore return address
popa .2                                 ; restore all registers
jal $zero $$reta i0                     ; return from call
DIFF------------------------------
.program:
.2                                      ; --- start of function: encode_allow_alias_12 ---
pusha .2                                ; save all registers
move $$locbase $sp                      ; save locals base register for function encode_allow_alias_12
cfei i1520                              ; allocate 1520 bytes for locals and 0 slots for call arguments
move $r168 $$arg0                       ; save argument 0 (item)
move $r169 $$arg1                       ; save argument 1 (__ret_value)
move $r170 $$reta                       ; save return address
.62
.64
movi $r175 i0                           ; move parameter from branch to block argument
.66
 move $r179 $r175                        ; move parameter from branch to block argument
 jnzi $r175 .67
 movi $r179 i0                           ; move parameter from branch to block argument
 
ji  .68
.67
 movi $r179 i0                           ; move parameter from branch to block argument
                                         ; move parameter from branch to block argument
.68
jnzi $r179 .69
.70
addi $r183 $$locbase i456               ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r183                       ; [call]: pass argument 0
fncall .8                               ; [call]: call new_38
addi $r185 $$locbase i1336              ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
mcpi $r185 $r168 i56                    ; copy memory
addi $r186 $$locbase i928               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r186 $r183 i24                    ; copy memory
addi $r187 $$locbase i1336              ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
addi $r188 $$locbase i208               ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
mcpi $r188 $r187 i56                    ; copy memory
lw $r190 $$locbase i26                  ; load word
eq $r191 $r190 $zero
jnzi $r191 .71
.72
lw $r193 $$locbase i26                  ; load word
eq $r194 $r193 $one
jnzi $r194 .73
.74
lw $r196 $$locbase i26                  ; load word
movi $r197 i2                           ; initialize constant into register
eq $r198 $r196 $r197
jnzi $r198 .75
.76
lw $r200 $$locbase i26                  ; load word
movi $r201 i3                           ; initialize constant into register
eq $r202 $r200 $r201
jnzi $r202 .77
.78
lw $r204 $$locbase i26                  ; load word
movi $r205 i4                           ; initialize constant into register
eq $r206 $r204 $r205
jnzi $r206 .79
.80
load $r207 data_NonConfigurable_8       ; load constant from data section
rvrt $r207
.79
addi $r208 $$locbase i208               ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
addi $r209 $r208 i8                     ; get offset to aggregate element
addi $r210 $$locbase i1472              ; get offset to local __ptr [slice; 3]
mcpi $r210 $r209 i48                    ; copy memory
addi $r211 $$locbase i928               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r212 $$locbase i688               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r212 $r211 i24                    ; copy memory
addi $r213 $$locbase i408               ; get offset to local __ptr { { ptr, u64, u64 } }
movi $$arg0 i4                          ; [call]: pass argument 0
move $$arg1 $r212                       ; [call]: pass argument 1
move $$arg2 $r213                       ; [call]: pass argument 2
fncall .4                               ; [call]: call abi_encode_30
addi $r216 $$locbase i1264              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r216 $r213 i24                    ; copy memory
addi $r217 $$locbase i1472              ; get offset to local __ptr [slice; 3]
addi $r218 $$locbase i1264              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r219 $$locbase i1408              ; get offset to local __ptr [slice; 3]
mcpi $r219 $r217 i48                    ; copy memory
addi $r220 $$locbase i1024              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r220 $r218 i24                    ; copy memory
addi $r221 $$locbase i1024              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r222 $$locbase i1096              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r222 $r221 i24                    ; copy memory
movi $r223 i0                           ; move parameter from branch to block argument
.81
move $r225 $r223                        ; move parameter from branch to block argument
movi $r226 i3                           ; initialize constant into register
lt $r227 $r223 $r226
jnzi $r227 .82
.83
addi $r228 $$locbase i1096              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r229 $$locbase i1288              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r229 $r228 i24                    ; copy memory
addi $r230 $$locbase i1288              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r231 $$locbase i776               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r231 $r230 i24                    ; copy memory
move $r232 $r231                        ; move parameter from branch to block argument
ji  .84
.82
addi $r233 $$locbase i1408              ; get offset to local __ptr [slice; 3]
movi $r234 i16                          ; get array element size
mul $r235 $r225 $r234                   ; get offset to array element
add $r235 $r233 $r235                   ; add array element offset to array base
addi $r236 $$locbase i1096              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r237 $$locbase i712               ; get offset to local __ptr slice
mcpi $r237 $r235 i16                    ; copy memory
addi $r238 $$locbase i728               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r238 $r236 i24                    ; copy memory
addi $r239 $$locbase i432               ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r237                       ; [call]: pass argument 0
move $$arg1 $r238                       ; [call]: pass argument 1
move $$arg2 $r239                       ; [call]: pass argument 2
fncall .6                               ; [call]: call abi_encode_36
addi $r241 $$locbase i1096              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r241 $r239 i24                    ; copy memory
add $r242 $r225 $one
move $r223 $r242                        ; move parameter from branch to block argument
ji  .81
.77
addi $r244 $$locbase i208               ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
addi $r245 $r244 i40                    ; get offset to aggregate element
addi $r246 $$locbase i1456              ; get offset to local __ptr { u64, u64 }
mcpi $r246 $r245 i16                    ; copy memory
addi $r247 $$locbase i928               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r248 $$locbase i616               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r248 $r247 i24                    ; copy memory
addi $r249 $$locbase i336               ; get offset to local __ptr { { ptr, u64, u64 } }
movi $$arg0 i3                          ; [call]: pass argument 0
move $$arg1 $r248                       ; [call]: pass argument 1
move $$arg2 $r249                       ; [call]: pass argument 2
fncall .4                               ; [call]: call abi_encode_30
addi $r252 $$locbase i1216              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r252 $r249 i24                    ; copy memory
addi $r253 $$locbase i1456              ; get offset to local __ptr { u64, u64 }
addi $r254 $$locbase i1216              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r255 $$locbase i1392              ; get offset to local __ptr { u64, u64 }
mcpi $r255 $r253 i16                    ; copy memory
addi $r256 $$locbase i1000              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r256 $r254 i24                    ; copy memory
lw $r258 $$locbase i174                 ; load word
addi $r259 $$locbase i1000              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r260 $$locbase i640               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r260 $r259 i24                    ; copy memory
addi $r261 $$locbase i360               ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r258                       ; [call]: pass argument 0
move $$arg1 $r260                       ; [call]: pass argument 1
move $$arg2 $r261                       ; [call]: pass argument 2
fncall .4                               ; [call]: call abi_encode_30
addi $r263 $$locbase i1072              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r263 $r261 i24                    ; copy memory
lw $r266 $$locbase i175                 ; load word
addi $r267 $$locbase i1072              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r268 $$locbase i664               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r268 $r267 i24                    ; copy memory
addi $r269 $$locbase i384               ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r266                       ; [call]: pass argument 0
move $$arg1 $r268                       ; [call]: pass argument 1
move $$arg2 $r269                       ; [call]: pass argument 2
fncall .4                               ; [call]: call abi_encode_30
addi $r271 $$locbase i1144              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r271 $r269 i24                    ; copy memory
addi $r272 $$locbase i1144              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r273 $$locbase i1240              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r273 $r272 i24                    ; copy memory
addi $r274 $$locbase i1240              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r275 $$locbase i776               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r275 $r274 i24                    ; copy memory
move $r232 $r275                        ; move parameter from branch to block argument
.84
addi $r279 $$locbase i800               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r279 $r232 i24                    ; copy memory
move $r280 $r279                        ; move parameter from branch to block argument
ji  .85
.75
addi $r281 $$locbase i208               ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
addi $r282 $r281 i55                    ; get offset to aggregate element
lb $r283 $r282 i0                       ; load byte
addi $r284 $$locbase i928               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r285 $$locbase i592               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r285 $r284 i24                    ; copy memory
addi $r286 $$locbase i312               ; get offset to local __ptr { { ptr, u64, u64 } }
movi $$arg0 i2                          ; [call]: pass argument 0
move $$arg1 $r285                       ; [call]: pass argument 1
move $$arg2 $r286                       ; [call]: pass argument 2
fncall .4                               ; [call]: call abi_encode_30
addi $r289 $$locbase i1168              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r289 $r286 i24                    ; copy memory
addi $r290 $$locbase i1168              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r291 $$locbase i976               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r291 $r290 i24                    ; copy memory
addi $r292 $$locbase i520               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r293 $$locbase i976               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r295 $$locbase i48                ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r295 $r293 i24                    ; copy memory
addi $r296 $$locbase i136               ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r296 $r295 i24                    ; copy memory
lw $r297 $$locbase i17                  ; load word
lw $r299 $$locbase i18                  ; load word
lw $r301 $$locbase i19                  ; load word
add $r302 $r301 $one
gt $r303 $r302 $r299
move $r304 $r297                        ; move parameter from branch to block argument
move $r305 $r299                        ; move parameter from branch to block argument
jnzi $r303 .86
ji  .87
.86
movi $r306 i2                           ; initialize constant into register
mul $r307 $r299 $r306
add $r308 $r307 $one
aloc $r308
mcp $hp $r297 $r301
move $r304 $hp                          ; move parameter from branch to block argument
move $r305 $r308                        ; move parameter from branch to block argument
.87
move $r313 $r304                        ; move parameter from branch to block argument
move $r315 $r305                        ; move parameter from branch to block argument
add $r316 $r304 $r301
sb $r316 $r283 i0                       ; store byte
addi $r317 $$locbase i184               ; get offset to local __ptr { ptr, u64, u64 }
sw $$locbase $r313 i23                  ; store word
sw $$locbase $r315 i24                  ; store word
sw $$locbase $r302 i25                  ; store word
addi $r321 $$locbase i72                ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r321 $r317 i24                    ; copy memory
mcpi $r292 $r321 i24                    ; copy memory
addi $r322 $$locbase i1192              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r322 $r292 i24                    ; copy memory
addi $r323 $$locbase i1192              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r324 $$locbase i800               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r324 $r323 i24                    ; copy memory
move $r280 $r324                        ; move parameter from branch to block argument
.85
addi $r328 $$locbase i824               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r328 $r280 i24                    ; copy memory
move $r329 $r328                        ; move parameter from branch to block argument
ji  .88
.73
addi $r330 $$locbase i208               ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
addi $r331 $r330 i55                    ; get offset to aggregate element
lb $r332 $r331 i0                       ; load byte
addi $r333 $$locbase i928               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r334 $$locbase i568               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r334 $r333 i24                    ; copy memory
addi $r335 $$locbase i288               ; get offset to local __ptr { { ptr, u64, u64 } }
movi $$arg0 i1                          ; [call]: pass argument 0
move $$arg1 $r334                       ; [call]: pass argument 1
move $$arg2 $r335                       ; [call]: pass argument 2
fncall .4                               ; [call]: call abi_encode_30
addi $r337 $$locbase i1048              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r337 $r335 i24                    ; copy memory
addi $r338 $$locbase i1048              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r339 $$locbase i952               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r339 $r338 i24                    ; copy memory
addi $r340 $$locbase i496               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r341 $$locbase i952               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $$locbase $r341 i24                ; copy memory
addi $r343 $$locbase i112               ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r343 $$locbase i24                ; copy memory
lw $r344 $$locbase i14                  ; load word
lw $r346 $$locbase i15                  ; load word
lw $r348 $$locbase i16                  ; load word
add $r349 $r348 $one
gt $r350 $r349 $r346
move $r351 $r344                        ; move parameter from branch to block argument
move $r352 $r346                        ; move parameter from branch to block argument
jnzi $r350 .89
ji  .90
.89
movi $r353 i2                           ; initialize constant into register
mul $r354 $r346 $r353
add $r355 $r354 $one
aloc $r355
mcp $hp $r344 $r348
move $r351 $hp                          ; move parameter from branch to block argument
move $r352 $r355                        ; move parameter from branch to block argument
.90
move $r360 $r351                        ; move parameter from branch to block argument
move $r362 $r352                        ; move parameter from branch to block argument
add $r363 $r351 $r348
sb $r363 $r332 i0                       ; store byte
addi $r364 $$locbase i160               ; get offset to local __ptr { ptr, u64, u64 }
sw $$locbase $r360 i20                  ; store word
sw $$locbase $r362 i21                  ; store word
sw $$locbase $r349 i22                  ; store word
addi $r368 $$locbase i24                ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r368 $r364 i24                    ; copy memory
mcpi $r340 $r368 i24                    ; copy memory
addi $r369 $$locbase i1120              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r369 $r340 i24                    ; copy memory
addi $r370 $$locbase i1120              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r371 $$locbase i824               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r371 $r370 i24                    ; copy memory
move $r329 $r371                        ; move parameter from branch to block argument
.88
addi $r375 $$locbase i848               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r375 $r329 i24                    ; copy memory
move $r376 $r375                        ; move parameter from branch to block argument
ji  .91
.71
addi $r377 $$locbase i928               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r378 $$locbase i544               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r378 $r377 i24                    ; copy memory
addi $r379 $$locbase i264               ; get offset to local __ptr { { ptr, u64, u64 } }
movi $$arg0 i0                          ; [call]: pass argument 0
move $$arg1 $r378                       ; [call]: pass argument 1
move $$arg2 $r379                       ; [call]: pass argument 2
fncall .4                               ; [call]: call abi_encode_30
addi $r381 $$locbase i848               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r381 $r379 i24                    ; copy memory
move $r376 $r381                        ; move parameter from branch to block argument
.91
addi $r385 $$locbase i1312              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r385 $r376 i24                    ; copy memory
addi $r386 $$locbase i1312              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r387 $$locbase i904               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r387 $r386 i24                    ; copy memory
addi $r388 $$locbase i904               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r389 $$locbase i752               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r389 $r388 i24                    ; copy memory
addi $r390 $$locbase i480               ; get offset to local __ptr slice
move $$arg0 $r389                       ; [call]: pass argument 0
move $$arg1 $r390                       ; [call]: pass argument 1
fncall .10                              ; [call]: call as_raw_slice_39
addi $r392 $$locbase i872               ; get offset to local __ptr slice
mcpi $r392 $r390 i16                    ; copy memory
move $r393 $r392                        ; move parameter from branch to block argument
ji  .92
.69
addi $r394 $$locbase i888               ; get offset to local __ptr { __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }, u64 }
sw $$locbase $r168 i111                 ; store word
movi $r396 i56                          ; initialize constant into register
sw $$locbase $r396 i112                 ; store word
addi $r397 $$locbase i96                ; get offset to local __ptr { __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }, u64 }
mcpi $r397 $r394 i16                    ; copy memory
addi $r398 $$locbase i872               ; get offset to local __ptr slice
mcpi $r398 $r397 i16                    ; copy memory
move $r393 $r398                        ; move parameter from branch to block argument
.92
mcpi $r169 $r393 i16                    ; copy memory
.3
cfsi i1520                              ; free 1520 bytes for locals and 0 slots for extra call arguments
move $$reta $r170                       ; restore return address
popa .2                                 ; restore all registers
jal $zero $$reta i0                     ; return from call
DIFF------------------------------
.program:
.2                                      ; --- start of function: encode_allow_alias_12 ---
pusha .2                                ; save all registers
move $$locbase $sp                      ; save locals base register for function encode_allow_alias_12
cfei i1520                              ; allocate 1520 bytes for locals and 0 slots for call arguments
move $r168 $$arg0                       ; save argument 0 (item)
move $r169 $$arg1                       ; save argument 1 (__ret_value)
move $r170 $$reta                       ; save return address
.62
.64
.66
movi $r179 i0                           ; move parameter from branch to block argument
.68
 jnzi $r179 .69
 
.70
addi $r183 $$locbase i456               ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r183                       ; [call]: pass argument 0
fncall .8                               ; [call]: call new_38
addi $r185 $$locbase i1336              ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
mcpi $r185 $r168 i56                    ; copy memory
addi $r186 $$locbase i928               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r186 $r183 i24                    ; copy memory
addi $r187 $$locbase i1336              ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
addi $r188 $$locbase i208               ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
mcpi $r188 $r187 i56                    ; copy memory
lw $r190 $$locbase i26                  ; load word
eq $r191 $r190 $zero
jnzi $r191 .71
.72
lw $r193 $$locbase i26                  ; load word
eq $r194 $r193 $one
jnzi $r194 .73
.74
lw $r196 $$locbase i26                  ; load word
movi $r197 i2                           ; initialize constant into register
eq $r198 $r196 $r197
jnzi $r198 .75
.76
lw $r200 $$locbase i26                  ; load word
movi $r201 i3                           ; initialize constant into register
eq $r202 $r200 $r201
jnzi $r202 .77
.78
lw $r204 $$locbase i26                  ; load word
movi $r205 i4                           ; initialize constant into register
eq $r206 $r204 $r205
jnzi $r206 .79
.80
load $r207 data_NonConfigurable_8       ; load constant from data section
rvrt $r207
.79
addi $r208 $$locbase i208               ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
addi $r209 $r208 i8                     ; get offset to aggregate element
addi $r210 $$locbase i1472              ; get offset to local __ptr [slice; 3]
mcpi $r210 $r209 i48                    ; copy memory
addi $r211 $$locbase i928               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r212 $$locbase i688               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r212 $r211 i24                    ; copy memory
addi $r213 $$locbase i408               ; get offset to local __ptr { { ptr, u64, u64 } }
movi $$arg0 i4                          ; [call]: pass argument 0
move $$arg1 $r212                       ; [call]: pass argument 1
move $$arg2 $r213                       ; [call]: pass argument 2
fncall .4                               ; [call]: call abi_encode_30
addi $r216 $$locbase i1264              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r216 $r213 i24                    ; copy memory
addi $r217 $$locbase i1472              ; get offset to local __ptr [slice; 3]
addi $r218 $$locbase i1264              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r219 $$locbase i1408              ; get offset to local __ptr [slice; 3]
mcpi $r219 $r217 i48                    ; copy memory
addi $r220 $$locbase i1024              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r220 $r218 i24                    ; copy memory
addi $r221 $$locbase i1024              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r222 $$locbase i1096              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r222 $r221 i24                    ; copy memory
movi $r223 i0                           ; move parameter from branch to block argument
.81
move $r225 $r223                        ; move parameter from branch to block argument
movi $r226 i3                           ; initialize constant into register
lt $r227 $r223 $r226
jnzi $r227 .82
.83
addi $r228 $$locbase i1096              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r229 $$locbase i1288              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r229 $r228 i24                    ; copy memory
addi $r230 $$locbase i1288              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r231 $$locbase i776               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r231 $r230 i24                    ; copy memory
move $r232 $r231                        ; move parameter from branch to block argument
ji  .84
.82
addi $r233 $$locbase i1408              ; get offset to local __ptr [slice; 3]
movi $r234 i16                          ; get array element size
mul $r235 $r225 $r234                   ; get offset to array element
add $r235 $r233 $r235                   ; add array element offset to array base
addi $r236 $$locbase i1096              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r237 $$locbase i712               ; get offset to local __ptr slice
mcpi $r237 $r235 i16                    ; copy memory
addi $r238 $$locbase i728               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r238 $r236 i24                    ; copy memory
addi $r239 $$locbase i432               ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r237                       ; [call]: pass argument 0
move $$arg1 $r238                       ; [call]: pass argument 1
move $$arg2 $r239                       ; [call]: pass argument 2
fncall .6                               ; [call]: call abi_encode_36
addi $r241 $$locbase i1096              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r241 $r239 i24                    ; copy memory
add $r242 $r225 $one
move $r223 $r242                        ; move parameter from branch to block argument
ji  .81
.77
addi $r244 $$locbase i208               ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
addi $r245 $r244 i40                    ; get offset to aggregate element
addi $r246 $$locbase i1456              ; get offset to local __ptr { u64, u64 }
mcpi $r246 $r245 i16                    ; copy memory
addi $r247 $$locbase i928               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r248 $$locbase i616               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r248 $r247 i24                    ; copy memory
addi $r249 $$locbase i336               ; get offset to local __ptr { { ptr, u64, u64 } }
movi $$arg0 i3                          ; [call]: pass argument 0
move $$arg1 $r248                       ; [call]: pass argument 1
move $$arg2 $r249                       ; [call]: pass argument 2
fncall .4                               ; [call]: call abi_encode_30
addi $r252 $$locbase i1216              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r252 $r249 i24                    ; copy memory
addi $r253 $$locbase i1456              ; get offset to local __ptr { u64, u64 }
addi $r254 $$locbase i1216              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r255 $$locbase i1392              ; get offset to local __ptr { u64, u64 }
mcpi $r255 $r253 i16                    ; copy memory
addi $r256 $$locbase i1000              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r256 $r254 i24                    ; copy memory
lw $r258 $$locbase i174                 ; load word
addi $r259 $$locbase i1000              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r260 $$locbase i640               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r260 $r259 i24                    ; copy memory
addi $r261 $$locbase i360               ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r258                       ; [call]: pass argument 0
move $$arg1 $r260                       ; [call]: pass argument 1
move $$arg2 $r261                       ; [call]: pass argument 2
fncall .4                               ; [call]: call abi_encode_30
addi $r263 $$locbase i1072              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r263 $r261 i24                    ; copy memory
lw $r266 $$locbase i175                 ; load word
addi $r267 $$locbase i1072              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r268 $$locbase i664               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r268 $r267 i24                    ; copy memory
addi $r269 $$locbase i384               ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r266                       ; [call]: pass argument 0
move $$arg1 $r268                       ; [call]: pass argument 1
move $$arg2 $r269                       ; [call]: pass argument 2
fncall .4                               ; [call]: call abi_encode_30
addi $r271 $$locbase i1144              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r271 $r269 i24                    ; copy memory
addi $r272 $$locbase i1144              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r273 $$locbase i1240              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r273 $r272 i24                    ; copy memory
addi $r274 $$locbase i1240              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r275 $$locbase i776               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r275 $r274 i24                    ; copy memory
move $r232 $r275                        ; move parameter from branch to block argument
.84
addi $r279 $$locbase i800               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r279 $r232 i24                    ; copy memory
move $r280 $r279                        ; move parameter from branch to block argument
ji  .85
.75
addi $r281 $$locbase i208               ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
addi $r282 $r281 i55                    ; get offset to aggregate element
lb $r283 $r282 i0                       ; load byte
addi $r284 $$locbase i928               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r285 $$locbase i592               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r285 $r284 i24                    ; copy memory
addi $r286 $$locbase i312               ; get offset to local __ptr { { ptr, u64, u64 } }
movi $$arg0 i2                          ; [call]: pass argument 0
move $$arg1 $r285                       ; [call]: pass argument 1
move $$arg2 $r286                       ; [call]: pass argument 2
fncall .4                               ; [call]: call abi_encode_30
addi $r289 $$locbase i1168              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r289 $r286 i24                    ; copy memory
addi $r290 $$locbase i1168              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r291 $$locbase i976               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r291 $r290 i24                    ; copy memory
addi $r292 $$locbase i520               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r293 $$locbase i976               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r295 $$locbase i48                ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r295 $r293 i24                    ; copy memory
addi $r296 $$locbase i136               ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r296 $r295 i24                    ; copy memory
lw $r297 $$locbase i17                  ; load word
lw $r299 $$locbase i18                  ; load word
lw $r301 $$locbase i19                  ; load word
add $r302 $r301 $one
gt $r303 $r302 $r299
move $r304 $r297                        ; move parameter from branch to block argument
move $r305 $r299                        ; move parameter from branch to block argument
jnzi $r303 .86
ji  .87
.86
movi $r306 i2                           ; initialize constant into register
mul $r307 $r299 $r306
add $r308 $r307 $one
aloc $r308
mcp $hp $r297 $r301
move $r304 $hp                          ; move parameter from branch to block argument
move $r305 $r308                        ; move parameter from branch to block argument
.87
move $r313 $r304                        ; move parameter from branch to block argument
move $r315 $r305                        ; move parameter from branch to block argument
add $r316 $r304 $r301
sb $r316 $r283 i0                       ; store byte
addi $r317 $$locbase i184               ; get offset to local __ptr { ptr, u64, u64 }
sw $$locbase $r313 i23                  ; store word
sw $$locbase $r315 i24                  ; store word
sw $$locbase $r302 i25                  ; store word
addi $r321 $$locbase i72                ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r321 $r317 i24                    ; copy memory
mcpi $r292 $r321 i24                    ; copy memory
addi $r322 $$locbase i1192              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r322 $r292 i24                    ; copy memory
addi $r323 $$locbase i1192              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r324 $$locbase i800               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r324 $r323 i24                    ; copy memory
move $r280 $r324                        ; move parameter from branch to block argument
.85
addi $r328 $$locbase i824               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r328 $r280 i24                    ; copy memory
move $r329 $r328                        ; move parameter from branch to block argument
ji  .88
.73
addi $r330 $$locbase i208               ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
addi $r331 $r330 i55                    ; get offset to aggregate element
lb $r332 $r331 i0                       ; load byte
addi $r333 $$locbase i928               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r334 $$locbase i568               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r334 $r333 i24                    ; copy memory
addi $r335 $$locbase i288               ; get offset to local __ptr { { ptr, u64, u64 } }
movi $$arg0 i1                          ; [call]: pass argument 0
move $$arg1 $r334                       ; [call]: pass argument 1
move $$arg2 $r335                       ; [call]: pass argument 2
fncall .4                               ; [call]: call abi_encode_30
addi $r337 $$locbase i1048              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r337 $r335 i24                    ; copy memory
addi $r338 $$locbase i1048              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r339 $$locbase i952               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r339 $r338 i24                    ; copy memory
addi $r340 $$locbase i496               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r341 $$locbase i952               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $$locbase $r341 i24                ; copy memory
addi $r343 $$locbase i112               ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r343 $$locbase i24                ; copy memory
lw $r344 $$locbase i14                  ; load word
lw $r346 $$locbase i15                  ; load word
lw $r348 $$locbase i16                  ; load word
add $r349 $r348 $one
gt $r350 $r349 $r346
move $r351 $r344                        ; move parameter from branch to block argument
move $r352 $r346                        ; move parameter from branch to block argument
jnzi $r350 .89
ji  .90
.89
movi $r353 i2                           ; initialize constant into register
mul $r354 $r346 $r353
add $r355 $r354 $one
aloc $r355
mcp $hp $r344 $r348
move $r351 $hp                          ; move parameter from branch to block argument
move $r352 $r355                        ; move parameter from branch to block argument
.90
move $r360 $r351                        ; move parameter from branch to block argument
move $r362 $r352                        ; move parameter from branch to block argument
add $r363 $r351 $r348
sb $r363 $r332 i0                       ; store byte
addi $r364 $$locbase i160               ; get offset to local __ptr { ptr, u64, u64 }
sw $$locbase $r360 i20                  ; store word
sw $$locbase $r362 i21                  ; store word
sw $$locbase $r349 i22                  ; store word
addi $r368 $$locbase i24                ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r368 $r364 i24                    ; copy memory
mcpi $r340 $r368 i24                    ; copy memory
addi $r369 $$locbase i1120              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r369 $r340 i24                    ; copy memory
addi $r370 $$locbase i1120              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r371 $$locbase i824               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r371 $r370 i24                    ; copy memory
move $r329 $r371                        ; move parameter from branch to block argument
.88
addi $r375 $$locbase i848               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r375 $r329 i24                    ; copy memory
move $r376 $r375                        ; move parameter from branch to block argument
ji  .91
.71
addi $r377 $$locbase i928               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r378 $$locbase i544               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r378 $r377 i24                    ; copy memory
addi $r379 $$locbase i264               ; get offset to local __ptr { { ptr, u64, u64 } }
movi $$arg0 i0                          ; [call]: pass argument 0
move $$arg1 $r378                       ; [call]: pass argument 1
move $$arg2 $r379                       ; [call]: pass argument 2
fncall .4                               ; [call]: call abi_encode_30
addi $r381 $$locbase i848               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r381 $r379 i24                    ; copy memory
move $r376 $r381                        ; move parameter from branch to block argument
.91
addi $r385 $$locbase i1312              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r385 $r376 i24                    ; copy memory
addi $r386 $$locbase i1312              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r387 $$locbase i904               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r387 $r386 i24                    ; copy memory
addi $r388 $$locbase i904               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r389 $$locbase i752               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r389 $r388 i24                    ; copy memory
addi $r390 $$locbase i480               ; get offset to local __ptr slice
move $$arg0 $r389                       ; [call]: pass argument 0
move $$arg1 $r390                       ; [call]: pass argument 1
fncall .10                              ; [call]: call as_raw_slice_39
addi $r392 $$locbase i872               ; get offset to local __ptr slice
mcpi $r392 $r390 i16                    ; copy memory
move $r393 $r392                        ; move parameter from branch to block argument
ji  .92
.69
addi $r394 $$locbase i888               ; get offset to local __ptr { __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }, u64 }
sw $$locbase $r168 i111                 ; store word
movi $r396 i56                          ; initialize constant into register
sw $$locbase $r396 i112                 ; store word
addi $r397 $$locbase i96                ; get offset to local __ptr { __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }, u64 }
mcpi $r397 $r394 i16                    ; copy memory
addi $r398 $$locbase i872               ; get offset to local __ptr slice
mcpi $r398 $r397 i16                    ; copy memory
move $r393 $r398                        ; move parameter from branch to block argument
.92
mcpi $r169 $r393 i16                    ; copy memory
.3
cfsi i1520                              ; free 1520 bytes for locals and 0 slots for extra call arguments
move $$reta $r170                       ; restore return address
popa .2                                 ; restore all registers
jal $zero $$reta i0                     ; return from call
DIFF------------------------------
.program:
.2                                      ; --- start of function: encode_allow_alias_12 ---
pusha .2                                ; save all registers
move $$locbase $sp                      ; save locals base register for function encode_allow_alias_12
cfei i1520                              ; allocate 1520 bytes for locals and 0 slots for call arguments
move $r168 $$arg0                       ; save argument 0 (item)
move $r169 $$arg1                       ; save argument 1 (__ret_value)
move $r170 $$reta                       ; save return address
.62
.64
.66
.68
.70
addi $r183 $$locbase i456               ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r183                       ; [call]: pass argument 0
fncall .8                               ; [call]: call new_38
addi $r185 $$locbase i1336              ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
mcpi $r185 $r168 i56                    ; copy memory
addi $r186 $$locbase i928               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r186 $r183 i24                    ; copy memory
addi $r187 $$locbase i1336              ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
addi $r188 $$locbase i208               ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
mcpi $r188 $r187 i56                    ; copy memory
lw $r190 $$locbase i26                  ; load word
eq $r191 $r190 $zero
jnzi $r191 .71
.72
lw $r193 $$locbase i26                  ; load word
eq $r194 $r193 $one
jnzi $r194 .73
.74
lw $r196 $$locbase i26                  ; load word
movi $r197 i2                           ; initialize constant into register
eq $r198 $r196 $r197
jnzi $r198 .75
.76
lw $r200 $$locbase i26                  ; load word
movi $r201 i3                           ; initialize constant into register
eq $r202 $r200 $r201
jnzi $r202 .77
.78
lw $r204 $$locbase i26                  ; load word
movi $r205 i4                           ; initialize constant into register
eq $r206 $r204 $r205
jnzi $r206 .79
.80
load $r207 data_NonConfigurable_8       ; load constant from data section
rvrt $r207
.79
addi $r208 $$locbase i208               ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
addi $r209 $r208 i8                     ; get offset to aggregate element
addi $r210 $$locbase i1472              ; get offset to local __ptr [slice; 3]
mcpi $r210 $r209 i48                    ; copy memory
addi $r211 $$locbase i928               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r212 $$locbase i688               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r212 $r211 i24                    ; copy memory
addi $r213 $$locbase i408               ; get offset to local __ptr { { ptr, u64, u64 } }
movi $$arg0 i4                          ; [call]: pass argument 0
move $$arg1 $r212                       ; [call]: pass argument 1
move $$arg2 $r213                       ; [call]: pass argument 2
fncall .4                               ; [call]: call abi_encode_30
addi $r216 $$locbase i1264              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r216 $r213 i24                    ; copy memory
addi $r217 $$locbase i1472              ; get offset to local __ptr [slice; 3]
addi $r218 $$locbase i1264              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r219 $$locbase i1408              ; get offset to local __ptr [slice; 3]
mcpi $r219 $r217 i48                    ; copy memory
addi $r220 $$locbase i1024              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r220 $r218 i24                    ; copy memory
addi $r221 $$locbase i1024              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r222 $$locbase i1096              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r222 $r221 i24                    ; copy memory
movi $r223 i0                           ; move parameter from branch to block argument
.81
move $r225 $r223                        ; move parameter from branch to block argument
movi $r226 i3                           ; initialize constant into register
lt $r227 $r223 $r226
jnzi $r227 .82
.83
addi $r228 $$locbase i1096              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r229 $$locbase i1288              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r229 $r228 i24                    ; copy memory
addi $r230 $$locbase i1288              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r231 $$locbase i776               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r231 $r230 i24                    ; copy memory
move $r232 $r231                        ; move parameter from branch to block argument
ji  .84
.82
addi $r233 $$locbase i1408              ; get offset to local __ptr [slice; 3]
movi $r234 i16                          ; get array element size
mul $r235 $r225 $r234                   ; get offset to array element
add $r235 $r233 $r235                   ; add array element offset to array base
addi $r236 $$locbase i1096              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r237 $$locbase i712               ; get offset to local __ptr slice
mcpi $r237 $r235 i16                    ; copy memory
addi $r238 $$locbase i728               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r238 $r236 i24                    ; copy memory
addi $r239 $$locbase i432               ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r237                       ; [call]: pass argument 0
move $$arg1 $r238                       ; [call]: pass argument 1
move $$arg2 $r239                       ; [call]: pass argument 2
fncall .6                               ; [call]: call abi_encode_36
addi $r241 $$locbase i1096              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r241 $r239 i24                    ; copy memory
add $r242 $r225 $one
move $r223 $r242                        ; move parameter from branch to block argument
ji  .81
.77
addi $r244 $$locbase i208               ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
addi $r245 $r244 i40                    ; get offset to aggregate element
addi $r246 $$locbase i1456              ; get offset to local __ptr { u64, u64 }
mcpi $r246 $r245 i16                    ; copy memory
addi $r247 $$locbase i928               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r248 $$locbase i616               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r248 $r247 i24                    ; copy memory
addi $r249 $$locbase i336               ; get offset to local __ptr { { ptr, u64, u64 } }
movi $$arg0 i3                          ; [call]: pass argument 0
move $$arg1 $r248                       ; [call]: pass argument 1
move $$arg2 $r249                       ; [call]: pass argument 2
fncall .4                               ; [call]: call abi_encode_30
addi $r252 $$locbase i1216              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r252 $r249 i24                    ; copy memory
addi $r253 $$locbase i1456              ; get offset to local __ptr { u64, u64 }
addi $r254 $$locbase i1216              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r255 $$locbase i1392              ; get offset to local __ptr { u64, u64 }
mcpi $r255 $r253 i16                    ; copy memory
addi $r256 $$locbase i1000              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r256 $r254 i24                    ; copy memory
lw $r258 $$locbase i174                 ; load word
addi $r259 $$locbase i1000              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r260 $$locbase i640               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r260 $r259 i24                    ; copy memory
addi $r261 $$locbase i360               ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r258                       ; [call]: pass argument 0
move $$arg1 $r260                       ; [call]: pass argument 1
move $$arg2 $r261                       ; [call]: pass argument 2
fncall .4                               ; [call]: call abi_encode_30
addi $r263 $$locbase i1072              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r263 $r261 i24                    ; copy memory
lw $r266 $$locbase i175                 ; load word
addi $r267 $$locbase i1072              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r268 $$locbase i664               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r268 $r267 i24                    ; copy memory
addi $r269 $$locbase i384               ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r266                       ; [call]: pass argument 0
move $$arg1 $r268                       ; [call]: pass argument 1
move $$arg2 $r269                       ; [call]: pass argument 2
fncall .4                               ; [call]: call abi_encode_30
addi $r271 $$locbase i1144              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r271 $r269 i24                    ; copy memory
addi $r272 $$locbase i1144              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r273 $$locbase i1240              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r273 $r272 i24                    ; copy memory
addi $r274 $$locbase i1240              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r275 $$locbase i776               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r275 $r274 i24                    ; copy memory
move $r232 $r275                        ; move parameter from branch to block argument
.84
addi $r279 $$locbase i800               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r279 $r232 i24                    ; copy memory
move $r280 $r279                        ; move parameter from branch to block argument
ji  .85
.75
addi $r281 $$locbase i208               ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
addi $r282 $r281 i55                    ; get offset to aggregate element
lb $r283 $r282 i0                       ; load byte
addi $r284 $$locbase i928               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r285 $$locbase i592               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r285 $r284 i24                    ; copy memory
addi $r286 $$locbase i312               ; get offset to local __ptr { { ptr, u64, u64 } }
movi $$arg0 i2                          ; [call]: pass argument 0
move $$arg1 $r285                       ; [call]: pass argument 1
move $$arg2 $r286                       ; [call]: pass argument 2
fncall .4                               ; [call]: call abi_encode_30
addi $r289 $$locbase i1168              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r289 $r286 i24                    ; copy memory
addi $r290 $$locbase i1168              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r291 $$locbase i976               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r291 $r290 i24                    ; copy memory
addi $r292 $$locbase i520               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r293 $$locbase i976               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r295 $$locbase i48                ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r295 $r293 i24                    ; copy memory
addi $r296 $$locbase i136               ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r296 $r295 i24                    ; copy memory
lw $r297 $$locbase i17                  ; load word
lw $r299 $$locbase i18                  ; load word
lw $r301 $$locbase i19                  ; load word
add $r302 $r301 $one
gt $r303 $r302 $r299
move $r304 $r297                        ; move parameter from branch to block argument
move $r305 $r299                        ; move parameter from branch to block argument
jnzi $r303 .86
ji  .87
.86
movi $r306 i2                           ; initialize constant into register
mul $r307 $r299 $r306
add $r308 $r307 $one
aloc $r308
mcp $hp $r297 $r301
move $r304 $hp                          ; move parameter from branch to block argument
move $r305 $r308                        ; move parameter from branch to block argument
.87
move $r313 $r304                        ; move parameter from branch to block argument
move $r315 $r305                        ; move parameter from branch to block argument
add $r316 $r304 $r301
sb $r316 $r283 i0                       ; store byte
addi $r317 $$locbase i184               ; get offset to local __ptr { ptr, u64, u64 }
sw $$locbase $r313 i23                  ; store word
sw $$locbase $r315 i24                  ; store word
sw $$locbase $r302 i25                  ; store word
addi $r321 $$locbase i72                ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r321 $r317 i24                    ; copy memory
mcpi $r292 $r321 i24                    ; copy memory
addi $r322 $$locbase i1192              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r322 $r292 i24                    ; copy memory
addi $r323 $$locbase i1192              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r324 $$locbase i800               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r324 $r323 i24                    ; copy memory
move $r280 $r324                        ; move parameter from branch to block argument
.85
addi $r328 $$locbase i824               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r328 $r280 i24                    ; copy memory
move $r329 $r328                        ; move parameter from branch to block argument
ji  .88
.73
addi $r330 $$locbase i208               ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
addi $r331 $r330 i55                    ; get offset to aggregate element
lb $r332 $r331 i0                       ; load byte
addi $r333 $$locbase i928               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r334 $$locbase i568               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r334 $r333 i24                    ; copy memory
addi $r335 $$locbase i288               ; get offset to local __ptr { { ptr, u64, u64 } }
movi $$arg0 i1                          ; [call]: pass argument 0
move $$arg1 $r334                       ; [call]: pass argument 1
move $$arg2 $r335                       ; [call]: pass argument 2
fncall .4                               ; [call]: call abi_encode_30
addi $r337 $$locbase i1048              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r337 $r335 i24                    ; copy memory
addi $r338 $$locbase i1048              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r339 $$locbase i952               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r339 $r338 i24                    ; copy memory
addi $r340 $$locbase i496               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r341 $$locbase i952               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $$locbase $r341 i24                ; copy memory
addi $r343 $$locbase i112               ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r343 $$locbase i24                ; copy memory
lw $r344 $$locbase i14                  ; load word
lw $r346 $$locbase i15                  ; load word
lw $r348 $$locbase i16                  ; load word
add $r349 $r348 $one
gt $r350 $r349 $r346
move $r351 $r344                        ; move parameter from branch to block argument
move $r352 $r346                        ; move parameter from branch to block argument
jnzi $r350 .89
ji  .90
.89
movi $r353 i2                           ; initialize constant into register
mul $r354 $r346 $r353
add $r355 $r354 $one
aloc $r355
mcp $hp $r344 $r348
move $r351 $hp                          ; move parameter from branch to block argument
move $r352 $r355                        ; move parameter from branch to block argument
.90
move $r360 $r351                        ; move parameter from branch to block argument
move $r362 $r352                        ; move parameter from branch to block argument
add $r363 $r351 $r348
sb $r363 $r332 i0                       ; store byte
addi $r364 $$locbase i160               ; get offset to local __ptr { ptr, u64, u64 }
sw $$locbase $r360 i20                  ; store word
sw $$locbase $r362 i21                  ; store word
sw $$locbase $r349 i22                  ; store word
addi $r368 $$locbase i24                ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r368 $r364 i24                    ; copy memory
mcpi $r340 $r368 i24                    ; copy memory
addi $r369 $$locbase i1120              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r369 $r340 i24                    ; copy memory
addi $r370 $$locbase i1120              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r371 $$locbase i824               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r371 $r370 i24                    ; copy memory
move $r329 $r371                        ; move parameter from branch to block argument
.88
addi $r375 $$locbase i848               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r375 $r329 i24                    ; copy memory
move $r376 $r375                        ; move parameter from branch to block argument
ji  .91
.71
addi $r377 $$locbase i928               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r378 $$locbase i544               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r378 $r377 i24                    ; copy memory
addi $r379 $$locbase i264               ; get offset to local __ptr { { ptr, u64, u64 } }
movi $$arg0 i0                          ; [call]: pass argument 0
move $$arg1 $r378                       ; [call]: pass argument 1
move $$arg2 $r379                       ; [call]: pass argument 2
fncall .4                               ; [call]: call abi_encode_30
addi $r381 $$locbase i848               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r381 $r379 i24                    ; copy memory
move $r376 $r381                        ; move parameter from branch to block argument
.91
addi $r385 $$locbase i1312              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r385 $r376 i24                    ; copy memory
addi $r386 $$locbase i1312              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r387 $$locbase i904               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r387 $r386 i24                    ; copy memory
addi $r388 $$locbase i904               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r389 $$locbase i752               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r389 $r388 i24                    ; copy memory
addi $r390 $$locbase i480               ; get offset to local __ptr slice
move $$arg0 $r389                       ; [call]: pass argument 0
move $$arg1 $r390                       ; [call]: pass argument 1
fncall .10                              ; [call]: call as_raw_slice_39
addi $r392 $$locbase i872               ; get offset to local __ptr slice
mcpi $r392 $r390 i16                    ; copy memory
move $r393 $r392                        ; move parameter from branch to block argument
.92
 mcpi $r169 $r393 i16                    ; copy memory
 mcpi $r169 $r392 i16                    ; copy memory
.3
cfsi i1520                              ; free 1520 bytes for locals and 0 slots for extra call arguments
move $$reta $r170                       ; restore return address
popa .2                                 ; restore all registers
jal $zero $$reta i0                     ; return from call
DIFF------------------------------
.program:
.2                                      ; --- start of function: encode_allow_alias_12 ---
pusha .2                                ; save all registers
move $$locbase $sp                      ; save locals base register for function encode_allow_alias_12
cfei i1520                              ; allocate 1520 bytes for locals and 0 slots for call arguments
move $r168 $$arg0                       ; save argument 0 (item)
move $r169 $$arg1                       ; save argument 1 (__ret_value)
move $r170 $$reta                       ; save return address
.62
.64
.66
.68
.70
addi $r183 $$locbase i456               ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r183                       ; [call]: pass argument 0
fncall .8                               ; [call]: call new_38
addi $r185 $$locbase i1336              ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
mcpi $r185 $r168 i56                    ; copy memory
addi $r186 $$locbase i928               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r186 $r183 i24                    ; copy memory
addi $r187 $$locbase i1336              ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
addi $r188 $$locbase i208               ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
mcpi $r188 $r187 i56                    ; copy memory
lw $r190 $$locbase i26                  ; load word
eq $r191 $r190 $zero
jnzi $r191 .71
.72
lw $r193 $$locbase i26                  ; load word
eq $r194 $r193 $one
jnzi $r194 .73
.74
lw $r196 $$locbase i26                  ; load word
movi $r197 i2                           ; initialize constant into register
eq $r198 $r196 $r197
jnzi $r198 .75
.76
lw $r200 $$locbase i26                  ; load word
movi $r201 i3                           ; initialize constant into register
eq $r202 $r200 $r201
jnzi $r202 .77
.78
lw $r204 $$locbase i26                  ; load word
movi $r205 i4                           ; initialize constant into register
eq $r206 $r204 $r205
jnzi $r206 .79
.80
load $r207 data_NonConfigurable_8       ; load constant from data section
rvrt $r207
.79
addi $r208 $$locbase i208               ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
addi $r209 $r208 i8                     ; get offset to aggregate element
addi $r210 $$locbase i1472              ; get offset to local __ptr [slice; 3]
mcpi $r210 $r209 i48                    ; copy memory
addi $r211 $$locbase i928               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r212 $$locbase i688               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r212 $r211 i24                    ; copy memory
addi $r213 $$locbase i408               ; get offset to local __ptr { { ptr, u64, u64 } }
movi $$arg0 i4                          ; [call]: pass argument 0
move $$arg1 $r212                       ; [call]: pass argument 1
move $$arg2 $r213                       ; [call]: pass argument 2
fncall .4                               ; [call]: call abi_encode_30
addi $r216 $$locbase i1264              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r216 $r213 i24                    ; copy memory
addi $r217 $$locbase i1472              ; get offset to local __ptr [slice; 3]
addi $r218 $$locbase i1264              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r219 $$locbase i1408              ; get offset to local __ptr [slice; 3]
mcpi $r219 $r217 i48                    ; copy memory
addi $r220 $$locbase i1024              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r220 $r218 i24                    ; copy memory
addi $r221 $$locbase i1024              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r222 $$locbase i1096              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r222 $r221 i24                    ; copy memory
movi $r223 i0                           ; move parameter from branch to block argument
.81
move $r225 $r223                        ; move parameter from branch to block argument
movi $r226 i3                           ; initialize constant into register
lt $r227 $r223 $r226
jnzi $r227 .82
.83
addi $r228 $$locbase i1096              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r229 $$locbase i1288              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r229 $r228 i24                    ; copy memory
addi $r230 $$locbase i1288              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r231 $$locbase i776               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r231 $r230 i24                    ; copy memory
move $r232 $r231                        ; move parameter from branch to block argument
ji  .84
.82
addi $r233 $$locbase i1408              ; get offset to local __ptr [slice; 3]
movi $r234 i16                          ; get array element size
mul $r235 $r225 $r234                   ; get offset to array element
add $r235 $r233 $r235                   ; add array element offset to array base
addi $r236 $$locbase i1096              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r237 $$locbase i712               ; get offset to local __ptr slice
mcpi $r237 $r235 i16                    ; copy memory
addi $r238 $$locbase i728               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r238 $r236 i24                    ; copy memory
addi $r239 $$locbase i432               ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r237                       ; [call]: pass argument 0
move $$arg1 $r238                       ; [call]: pass argument 1
move $$arg2 $r239                       ; [call]: pass argument 2
fncall .6                               ; [call]: call abi_encode_36
addi $r241 $$locbase i1096              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r241 $r239 i24                    ; copy memory
add $r242 $r225 $one
move $r223 $r242                        ; move parameter from branch to block argument
ji  .81
.77
addi $r244 $$locbase i208               ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
addi $r245 $r244 i40                    ; get offset to aggregate element
addi $r246 $$locbase i1456              ; get offset to local __ptr { u64, u64 }
mcpi $r246 $r245 i16                    ; copy memory
addi $r247 $$locbase i928               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r248 $$locbase i616               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r248 $r247 i24                    ; copy memory
addi $r249 $$locbase i336               ; get offset to local __ptr { { ptr, u64, u64 } }
movi $$arg0 i3                          ; [call]: pass argument 0
move $$arg1 $r248                       ; [call]: pass argument 1
move $$arg2 $r249                       ; [call]: pass argument 2
fncall .4                               ; [call]: call abi_encode_30
addi $r252 $$locbase i1216              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r252 $r249 i24                    ; copy memory
addi $r253 $$locbase i1456              ; get offset to local __ptr { u64, u64 }
addi $r254 $$locbase i1216              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r255 $$locbase i1392              ; get offset to local __ptr { u64, u64 }
mcpi $r255 $r253 i16                    ; copy memory
addi $r256 $$locbase i1000              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r256 $r254 i24                    ; copy memory
lw $r258 $$locbase i174                 ; load word
addi $r259 $$locbase i1000              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r260 $$locbase i640               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r260 $r259 i24                    ; copy memory
addi $r261 $$locbase i360               ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r258                       ; [call]: pass argument 0
move $$arg1 $r260                       ; [call]: pass argument 1
move $$arg2 $r261                       ; [call]: pass argument 2
fncall .4                               ; [call]: call abi_encode_30
addi $r263 $$locbase i1072              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r263 $r261 i24                    ; copy memory
lw $r266 $$locbase i175                 ; load word
addi $r267 $$locbase i1072              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r268 $$locbase i664               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r268 $r267 i24                    ; copy memory
addi $r269 $$locbase i384               ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r266                       ; [call]: pass argument 0
move $$arg1 $r268                       ; [call]: pass argument 1
move $$arg2 $r269                       ; [call]: pass argument 2
fncall .4                               ; [call]: call abi_encode_30
addi $r271 $$locbase i1144              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r271 $r269 i24                    ; copy memory
addi $r272 $$locbase i1144              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r273 $$locbase i1240              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r273 $r272 i24                    ; copy memory
addi $r274 $$locbase i1240              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r275 $$locbase i776               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r275 $r274 i24                    ; copy memory
move $r232 $r275                        ; move parameter from branch to block argument
.84
addi $r279 $$locbase i800               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r279 $r232 i24                    ; copy memory
move $r280 $r279                        ; move parameter from branch to block argument
ji  .85
.75
addi $r281 $$locbase i208               ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
addi $r282 $r281 i55                    ; get offset to aggregate element
lb $r283 $r282 i0                       ; load byte
addi $r284 $$locbase i928               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r285 $$locbase i592               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r285 $r284 i24                    ; copy memory
addi $r286 $$locbase i312               ; get offset to local __ptr { { ptr, u64, u64 } }
movi $$arg0 i2                          ; [call]: pass argument 0
move $$arg1 $r285                       ; [call]: pass argument 1
move $$arg2 $r286                       ; [call]: pass argument 2
fncall .4                               ; [call]: call abi_encode_30
addi $r289 $$locbase i1168              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r289 $r286 i24                    ; copy memory
addi $r290 $$locbase i1168              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r291 $$locbase i976               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r291 $r290 i24                    ; copy memory
addi $r292 $$locbase i520               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r293 $$locbase i976               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r295 $$locbase i48                ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r295 $r293 i24                    ; copy memory
addi $r296 $$locbase i136               ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r296 $r295 i24                    ; copy memory
lw $r297 $$locbase i17                  ; load word
lw $r299 $$locbase i18                  ; load word
lw $r301 $$locbase i19                  ; load word
add $r302 $r301 $one
gt $r303 $r302 $r299
move $r304 $r297                        ; move parameter from branch to block argument
move $r305 $r299                        ; move parameter from branch to block argument
jnzi $r303 .86
ji  .87
.86
movi $r306 i2                           ; initialize constant into register
mul $r307 $r299 $r306
add $r308 $r307 $one
aloc $r308
mcp $hp $r297 $r301
move $r304 $hp                          ; move parameter from branch to block argument
move $r305 $r308                        ; move parameter from branch to block argument
.87
move $r313 $r304                        ; move parameter from branch to block argument
move $r315 $r305                        ; move parameter from branch to block argument
add $r316 $r304 $r301
sb $r316 $r283 i0                       ; store byte
addi $r317 $$locbase i184               ; get offset to local __ptr { ptr, u64, u64 }
sw $$locbase $r313 i23                  ; store word
sw $$locbase $r315 i24                  ; store word
sw $$locbase $r302 i25                  ; store word
addi $r321 $$locbase i72                ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r321 $r317 i24                    ; copy memory
mcpi $r292 $r321 i24                    ; copy memory
addi $r322 $$locbase i1192              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r322 $r292 i24                    ; copy memory
addi $r323 $$locbase i1192              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r324 $$locbase i800               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r324 $r323 i24                    ; copy memory
move $r280 $r324                        ; move parameter from branch to block argument
.85
addi $r328 $$locbase i824               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r328 $r280 i24                    ; copy memory
move $r329 $r328                        ; move parameter from branch to block argument
ji  .88
.73
addi $r330 $$locbase i208               ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
addi $r331 $r330 i55                    ; get offset to aggregate element
lb $r332 $r331 i0                       ; load byte
addi $r333 $$locbase i928               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r334 $$locbase i568               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r334 $r333 i24                    ; copy memory
addi $r335 $$locbase i288               ; get offset to local __ptr { { ptr, u64, u64 } }
movi $$arg0 i1                          ; [call]: pass argument 0
move $$arg1 $r334                       ; [call]: pass argument 1
move $$arg2 $r335                       ; [call]: pass argument 2
fncall .4                               ; [call]: call abi_encode_30
addi $r337 $$locbase i1048              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r337 $r335 i24                    ; copy memory
addi $r338 $$locbase i1048              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r339 $$locbase i952               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r339 $r338 i24                    ; copy memory
addi $r340 $$locbase i496               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r341 $$locbase i952               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $$locbase $r341 i24                ; copy memory
addi $r343 $$locbase i112               ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r343 $$locbase i24                ; copy memory
lw $r344 $$locbase i14                  ; load word
lw $r346 $$locbase i15                  ; load word
lw $r348 $$locbase i16                  ; load word
add $r349 $r348 $one
gt $r350 $r349 $r346
move $r351 $r344                        ; move parameter from branch to block argument
move $r352 $r346                        ; move parameter from branch to block argument
jnzi $r350 .89
ji  .90
.89
movi $r353 i2                           ; initialize constant into register
mul $r354 $r346 $r353
add $r355 $r354 $one
aloc $r355
mcp $hp $r344 $r348
move $r351 $hp                          ; move parameter from branch to block argument
move $r352 $r355                        ; move parameter from branch to block argument
.90
move $r360 $r351                        ; move parameter from branch to block argument
move $r362 $r352                        ; move parameter from branch to block argument
add $r363 $r351 $r348
sb $r363 $r332 i0                       ; store byte
addi $r364 $$locbase i160               ; get offset to local __ptr { ptr, u64, u64 }
sw $$locbase $r360 i20                  ; store word
sw $$locbase $r362 i21                  ; store word
sw $$locbase $r349 i22                  ; store word
addi $r368 $$locbase i24                ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r368 $r364 i24                    ; copy memory
mcpi $r340 $r368 i24                    ; copy memory
addi $r369 $$locbase i1120              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r369 $r340 i24                    ; copy memory
addi $r370 $$locbase i1120              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r371 $$locbase i824               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r371 $r370 i24                    ; copy memory
move $r329 $r371                        ; move parameter from branch to block argument
.88
addi $r375 $$locbase i848               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r375 $r329 i24                    ; copy memory
move $r376 $r375                        ; move parameter from branch to block argument
ji  .91
.71
addi $r377 $$locbase i928               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r378 $$locbase i544               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r378 $r377 i24                    ; copy memory
addi $r379 $$locbase i264               ; get offset to local __ptr { { ptr, u64, u64 } }
movi $$arg0 i0                          ; [call]: pass argument 0
move $$arg1 $r378                       ; [call]: pass argument 1
move $$arg2 $r379                       ; [call]: pass argument 2
fncall .4                               ; [call]: call abi_encode_30
addi $r381 $$locbase i848               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r381 $r379 i24                    ; copy memory
move $r376 $r381                        ; move parameter from branch to block argument
.91
addi $r385 $$locbase i1312              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r385 $r376 i24                    ; copy memory
addi $r386 $$locbase i1312              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r387 $$locbase i904               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r387 $r386 i24                    ; copy memory
addi $r388 $$locbase i904               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r389 $$locbase i752               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r389 $r388 i24                    ; copy memory
addi $r390 $$locbase i480               ; get offset to local __ptr slice
move $$arg0 $r389                       ; [call]: pass argument 0
move $$arg1 $r390                       ; [call]: pass argument 1
fncall .10                              ; [call]: call as_raw_slice_39
addi $r392 $$locbase i872               ; get offset to local __ptr slice
mcpi $r392 $r390 i16                    ; copy memory
.92
mcpi $r169 $r392 i16                    ; copy memory
.3
cfsi i1520                              ; free 1520 bytes for locals and 0 slots for extra call arguments
move $$reta $r170                       ; restore return address
popa .2                                 ; restore all registers
jal $zero $$reta i0                     ; return from call
DIFF------------------------------
.program:
.2                                      ; --- start of function: encode_allow_alias_12 ---
pusha .2                                ; save all registers
move $$locbase $sp                      ; save locals base register for function encode_allow_alias_12
cfei i1520                              ; allocate 1520 bytes for locals and 0 slots for call arguments
move $r168 $$arg0                       ; save argument 0 (item)
move $r169 $$arg1                       ; save argument 1 (__ret_value)
move $r170 $$reta                       ; save return address
.62
.64
.66
.68
.70
addi $r183 $$locbase i456               ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r183                       ; [call]: pass argument 0
fncall .8                               ; [call]: call new_38
addi $r185 $$locbase i1336              ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
mcpi $r185 $r168 i56                    ; copy memory
addi $r186 $$locbase i928               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r186 $r183 i24                    ; copy memory
addi $r187 $$locbase i1336              ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
addi $r188 $$locbase i208               ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
mcpi $r188 $r187 i56                    ; copy memory
lw $r190 $$locbase i26                  ; load word
eq $r191 $r190 $zero
jnzi $r191 .71
.72
lw $r193 $$locbase i26                  ; load word
eq $r194 $r193 $one
jnzi $r194 .73
.74
lw $r196 $$locbase i26                  ; load word
movi $r197 i2                           ; initialize constant into register
eq $r198 $r196 $r197
jnzi $r198 .75
.76
lw $r200 $$locbase i26                  ; load word
movi $r201 i3                           ; initialize constant into register
eq $r202 $r200 $r201
jnzi $r202 .77
.78
lw $r204 $$locbase i26                  ; load word
movi $r205 i4                           ; initialize constant into register
eq $r206 $r204 $r205
jnzi $r206 .79
.80
load $r207 data_NonConfigurable_8       ; load constant from data section
rvrt $r207
.79
addi $r208 $$locbase i208               ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
addi $r209 $r208 i8                     ; get offset to aggregate element
addi $r210 $$locbase i1472              ; get offset to local __ptr [slice; 3]
mcpi $r210 $r209 i48                    ; copy memory
addi $r211 $$locbase i928               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r212 $$locbase i688               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r212 $r211 i24                    ; copy memory
addi $r213 $$locbase i408               ; get offset to local __ptr { { ptr, u64, u64 } }
movi $$arg0 i4                          ; [call]: pass argument 0
move $$arg1 $r212                       ; [call]: pass argument 1
move $$arg2 $r213                       ; [call]: pass argument 2
fncall .4                               ; [call]: call abi_encode_30
addi $r216 $$locbase i1264              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r216 $r213 i24                    ; copy memory
addi $r217 $$locbase i1472              ; get offset to local __ptr [slice; 3]
addi $r218 $$locbase i1264              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r219 $$locbase i1408              ; get offset to local __ptr [slice; 3]
mcpi $r219 $r217 i48                    ; copy memory
addi $r220 $$locbase i1024              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r220 $r218 i24                    ; copy memory
addi $r221 $$locbase i1024              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r222 $$locbase i1096              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r222 $r221 i24                    ; copy memory
movi $r223 i0                           ; move parameter from branch to block argument
.81
move $r225 $r223                        ; move parameter from branch to block argument
movi $r226 i3                           ; initialize constant into register
lt $r227 $r223 $r226
jnzi $r227 .82
.83
addi $r228 $$locbase i1096              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r229 $$locbase i1288              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r229 $r228 i24                    ; copy memory
addi $r230 $$locbase i1288              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r231 $$locbase i776               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r231 $r230 i24                    ; copy memory
move $r232 $r231                        ; move parameter from branch to block argument
ji  .84
.82
addi $r233 $$locbase i1408              ; get offset to local __ptr [slice; 3]
movi $r234 i16                          ; get array element size
mul $r235 $r225 $r234                   ; get offset to array element
add $r235 $r233 $r235                   ; add array element offset to array base
addi $r236 $$locbase i1096              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r237 $$locbase i712               ; get offset to local __ptr slice
mcpi $r237 $r235 i16                    ; copy memory
addi $r238 $$locbase i728               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r238 $r236 i24                    ; copy memory
addi $r239 $$locbase i432               ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r237                       ; [call]: pass argument 0
move $$arg1 $r238                       ; [call]: pass argument 1
move $$arg2 $r239                       ; [call]: pass argument 2
fncall .6                               ; [call]: call abi_encode_36
addi $r241 $$locbase i1096              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r241 $r239 i24                    ; copy memory
add $r242 $r225 $one
move $r223 $r242                        ; move parameter from branch to block argument
ji  .81
.77
addi $r244 $$locbase i208               ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
addi $r245 $r244 i40                    ; get offset to aggregate element
addi $r246 $$locbase i1456              ; get offset to local __ptr { u64, u64 }
mcpi $r246 $r245 i16                    ; copy memory
addi $r247 $$locbase i928               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r248 $$locbase i616               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r248 $r247 i24                    ; copy memory
addi $r249 $$locbase i336               ; get offset to local __ptr { { ptr, u64, u64 } }
movi $$arg0 i3                          ; [call]: pass argument 0
move $$arg1 $r248                       ; [call]: pass argument 1
move $$arg2 $r249                       ; [call]: pass argument 2
fncall .4                               ; [call]: call abi_encode_30
addi $r252 $$locbase i1216              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r252 $r249 i24                    ; copy memory
addi $r253 $$locbase i1456              ; get offset to local __ptr { u64, u64 }
addi $r254 $$locbase i1216              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r255 $$locbase i1392              ; get offset to local __ptr { u64, u64 }
mcpi $r255 $r253 i16                    ; copy memory
addi $r256 $$locbase i1000              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r256 $r254 i24                    ; copy memory
lw $r258 $$locbase i174                 ; load word
addi $r259 $$locbase i1000              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r260 $$locbase i640               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r260 $r259 i24                    ; copy memory
addi $r261 $$locbase i360               ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r258                       ; [call]: pass argument 0
move $$arg1 $r260                       ; [call]: pass argument 1
move $$arg2 $r261                       ; [call]: pass argument 2
fncall .4                               ; [call]: call abi_encode_30
addi $r263 $$locbase i1072              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r263 $r261 i24                    ; copy memory
lw $r266 $$locbase i175                 ; load word
addi $r267 $$locbase i1072              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r268 $$locbase i664               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r268 $r267 i24                    ; copy memory
addi $r269 $$locbase i384               ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r266                       ; [call]: pass argument 0
move $$arg1 $r268                       ; [call]: pass argument 1
move $$arg2 $r269                       ; [call]: pass argument 2
fncall .4                               ; [call]: call abi_encode_30
addi $r271 $$locbase i1144              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r271 $r269 i24                    ; copy memory
addi $r272 $$locbase i1144              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r273 $$locbase i1240              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r273 $r272 i24                    ; copy memory
addi $r274 $$locbase i1240              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r275 $$locbase i776               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r275 $r274 i24                    ; copy memory
move $r232 $r275                        ; move parameter from branch to block argument
.84
addi $r279 $$locbase i800               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r279 $r232 i24                    ; copy memory
move $r280 $r279                        ; move parameter from branch to block argument
ji  .85
.75
addi $r281 $$locbase i208               ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
addi $r282 $r281 i55                    ; get offset to aggregate element
lb $r283 $r282 i0                       ; load byte
addi $r284 $$locbase i928               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r285 $$locbase i592               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r285 $r284 i24                    ; copy memory
addi $r286 $$locbase i312               ; get offset to local __ptr { { ptr, u64, u64 } }
movi $$arg0 i2                          ; [call]: pass argument 0
move $$arg1 $r285                       ; [call]: pass argument 1
move $$arg2 $r286                       ; [call]: pass argument 2
fncall .4                               ; [call]: call abi_encode_30
addi $r289 $$locbase i1168              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r289 $r286 i24                    ; copy memory
addi $r290 $$locbase i1168              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r291 $$locbase i976               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r291 $r290 i24                    ; copy memory
addi $r292 $$locbase i520               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r293 $$locbase i976               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r295 $$locbase i48                ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r295 $r293 i24                    ; copy memory
addi $r296 $$locbase i136               ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r296 $r295 i24                    ; copy memory
lw $r297 $$locbase i17                  ; load word
lw $r299 $$locbase i18                  ; load word
lw $r301 $$locbase i19                  ; load word
add $r302 $r301 $one
gt $r303 $r302 $r299
move $r304 $r297                        ; move parameter from branch to block argument
move $r305 $r299                        ; move parameter from branch to block argument
jnzi $r303 .86
ji  .87
.86
movi $r306 i2                           ; initialize constant into register
mul $r307 $r299 $r306
add $r308 $r307 $one
aloc $r308
mcp $hp $r297 $r301
move $r304 $hp                          ; move parameter from branch to block argument
move $r305 $r308                        ; move parameter from branch to block argument
.87
move $r313 $r304                        ; move parameter from branch to block argument
move $r315 $r305                        ; move parameter from branch to block argument
add $r316 $r304 $r301
sb $r316 $r283 i0                       ; store byte
addi $r317 $$locbase i184               ; get offset to local __ptr { ptr, u64, u64 }
sw $$locbase $r313 i23                  ; store word
sw $$locbase $r315 i24                  ; store word
sw $$locbase $r302 i25                  ; store word
addi $r321 $$locbase i72                ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r321 $r317 i24                    ; copy memory
mcpi $r292 $r321 i24                    ; copy memory
addi $r322 $$locbase i1192              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r322 $r292 i24                    ; copy memory
addi $r323 $$locbase i1192              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r324 $$locbase i800               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r324 $r323 i24                    ; copy memory
move $r280 $r324                        ; move parameter from branch to block argument
.85
addi $r328 $$locbase i824               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r328 $r280 i24                    ; copy memory
move $r329 $r328                        ; move parameter from branch to block argument
ji  .88
.73
addi $r330 $$locbase i208               ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
addi $r331 $r330 i55                    ; get offset to aggregate element
lb $r332 $r331 i0                       ; load byte
addi $r333 $$locbase i928               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r334 $$locbase i568               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r334 $r333 i24                    ; copy memory
addi $r335 $$locbase i288               ; get offset to local __ptr { { ptr, u64, u64 } }
movi $$arg0 i1                          ; [call]: pass argument 0
move $$arg1 $r334                       ; [call]: pass argument 1
move $$arg2 $r335                       ; [call]: pass argument 2
fncall .4                               ; [call]: call abi_encode_30
addi $r337 $$locbase i1048              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r337 $r335 i24                    ; copy memory
addi $r338 $$locbase i1048              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r339 $$locbase i952               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r339 $r338 i24                    ; copy memory
addi $r340 $$locbase i496               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r341 $$locbase i952               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $$locbase $r341 i24                ; copy memory
addi $r343 $$locbase i112               ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r343 $$locbase i24                ; copy memory
lw $r344 $$locbase i14                  ; load word
lw $r346 $$locbase i15                  ; load word
lw $r348 $$locbase i16                  ; load word
add $r349 $r348 $one
gt $r350 $r349 $r346
move $r351 $r344                        ; move parameter from branch to block argument
move $r352 $r346                        ; move parameter from branch to block argument
jnzi $r350 .89
ji  .90
.89
movi $r353 i2                           ; initialize constant into register
mul $r354 $r346 $r353
add $r355 $r354 $one
aloc $r355
mcp $hp $r344 $r348
move $r351 $hp                          ; move parameter from branch to block argument
move $r352 $r355                        ; move parameter from branch to block argument
.90
move $r360 $r351                        ; move parameter from branch to block argument
move $r362 $r352                        ; move parameter from branch to block argument
add $r363 $r351 $r348
sb $r363 $r332 i0                       ; store byte
addi $r364 $$locbase i160               ; get offset to local __ptr { ptr, u64, u64 }
sw $$locbase $r360 i20                  ; store word
sw $$locbase $r362 i21                  ; store word
sw $$locbase $r349 i22                  ; store word
addi $r368 $$locbase i24                ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r368 $r364 i24                    ; copy memory
mcpi $r340 $r368 i24                    ; copy memory
addi $r369 $$locbase i1120              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r369 $r340 i24                    ; copy memory
addi $r370 $$locbase i1120              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r371 $$locbase i824               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r371 $r370 i24                    ; copy memory
move $r329 $r371                        ; move parameter from branch to block argument
.88
addi $r375 $$locbase i848               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r375 $r329 i24                    ; copy memory
move $r376 $r375                        ; move parameter from branch to block argument
ji  .91
.71
addi $r377 $$locbase i928               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r378 $$locbase i544               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r378 $r377 i24                    ; copy memory
addi $r379 $$locbase i264               ; get offset to local __ptr { { ptr, u64, u64 } }
movi $$arg0 i0                          ; [call]: pass argument 0
move $$arg1 $r378                       ; [call]: pass argument 1
move $$arg2 $r379                       ; [call]: pass argument 2
fncall .4                               ; [call]: call abi_encode_30
addi $r381 $$locbase i848               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r381 $r379 i24                    ; copy memory
move $r376 $r381                        ; move parameter from branch to block argument
.91
addi $r385 $$locbase i1312              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r385 $r376 i24                    ; copy memory
addi $r386 $$locbase i1312              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r387 $$locbase i904               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r387 $r386 i24                    ; copy memory
addi $r388 $$locbase i904               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r389 $$locbase i752               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r389 $r388 i24                    ; copy memory
addi $r390 $$locbase i480               ; get offset to local __ptr slice
move $$arg0 $r389                       ; [call]: pass argument 0
move $$arg1 $r390                       ; [call]: pass argument 1
fncall .10                              ; [call]: call as_raw_slice_39
addi $r392 $$locbase i872               ; get offset to local __ptr slice
mcpi $r392 $r390 i16                    ; copy memory
.92
mcpi $r169 $r392 i16                    ; copy memory
.3
cfsi i1520                              ; free 1520 bytes for locals and 0 slots for extra call arguments
move $$reta $r170                       ; restore return address
popa .2                                 ; restore all registers
jal $zero $$reta i0                     ; return from call
DIFF------------------------------
.program:
.2                                      ; --- start of function: encode_allow_alias_12 ---
pusha .2                                ; save all registers
move $$locbase $sp                      ; save locals base register for function encode_allow_alias_12
cfei i1520                              ; allocate 1520 bytes for locals and 0 slots for call arguments
move $r168 $$arg0                       ; save argument 0 (item)
move $r169 $$arg1                       ; save argument 1 (__ret_value)
move $r170 $$reta                       ; save return address
.62
.64
.66
.68
.70
addi $r183 $$locbase i456               ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r183                       ; [call]: pass argument 0
fncall .8                               ; [call]: call new_38
addi $r185 $$locbase i1336              ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
mcpi $r185 $r168 i56                    ; copy memory
addi $r186 $$locbase i928               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r186 $r183 i24                    ; copy memory
addi $r187 $$locbase i1336              ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
addi $r188 $$locbase i208               ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
mcpi $r188 $r187 i56                    ; copy memory
lw $r190 $$locbase i26                  ; load word
eq $r191 $r190 $zero
jnzi $r191 .71
.72
lw $r193 $$locbase i26                  ; load word
eq $r194 $r193 $one
jnzi $r194 .73
.74
lw $r196 $$locbase i26                  ; load word
movi $r197 i2                           ; initialize constant into register
eq $r198 $r196 $r197
jnzi $r198 .75
.76
lw $r200 $$locbase i26                  ; load word
movi $r201 i3                           ; initialize constant into register
eq $r202 $r200 $r201
jnzi $r202 .77
.78
lw $r204 $$locbase i26                  ; load word
movi $r205 i4                           ; initialize constant into register
eq $r206 $r204 $r205
jnzi $r206 .79
.80
load $r207 data_NonConfigurable_8       ; load constant from data section
rvrt $r207
.79
addi $r208 $$locbase i208               ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
addi $r209 $r208 i8                     ; get offset to aggregate element
addi $r210 $$locbase i1472              ; get offset to local __ptr [slice; 3]
mcpi $r210 $r209 i48                    ; copy memory
addi $r211 $$locbase i928               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r212 $$locbase i688               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r212 $r211 i24                    ; copy memory
addi $r213 $$locbase i408               ; get offset to local __ptr { { ptr, u64, u64 } }
movi $$arg0 i4                          ; [call]: pass argument 0
move $$arg1 $r212                       ; [call]: pass argument 1
move $$arg2 $r213                       ; [call]: pass argument 2
fncall .4                               ; [call]: call abi_encode_30
addi $r216 $$locbase i1264              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r216 $r213 i24                    ; copy memory
addi $r217 $$locbase i1472              ; get offset to local __ptr [slice; 3]
addi $r218 $$locbase i1264              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r219 $$locbase i1408              ; get offset to local __ptr [slice; 3]
mcpi $r219 $r217 i48                    ; copy memory
addi $r220 $$locbase i1024              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r220 $r218 i24                    ; copy memory
addi $r221 $$locbase i1024              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r222 $$locbase i1096              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r222 $r221 i24                    ; copy memory
movi $r223 i0                           ; move parameter from branch to block argument
.81
move $r225 $r223                        ; move parameter from branch to block argument
movi $r226 i3                           ; initialize constant into register
lt $r227 $r223 $r226
jnzi $r227 .82
.83
addi $r228 $$locbase i1096              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r229 $$locbase i1288              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r229 $r228 i24                    ; copy memory
addi $r230 $$locbase i1288              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r231 $$locbase i776               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r231 $r230 i24                    ; copy memory
move $r232 $r231                        ; move parameter from branch to block argument
ji  .84
.82
addi $r233 $$locbase i1408              ; get offset to local __ptr [slice; 3]
movi $r234 i16                          ; get array element size
mul $r235 $r225 $r234                   ; get offset to array element
add $r235 $r233 $r235                   ; add array element offset to array base
addi $r236 $$locbase i1096              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r237 $$locbase i712               ; get offset to local __ptr slice
mcpi $r237 $r235 i16                    ; copy memory
addi $r238 $$locbase i728               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r238 $r236 i24                    ; copy memory
addi $r239 $$locbase i432               ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r237                       ; [call]: pass argument 0
move $$arg1 $r238                       ; [call]: pass argument 1
move $$arg2 $r239                       ; [call]: pass argument 2
fncall .6                               ; [call]: call abi_encode_36
addi $r241 $$locbase i1096              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r241 $r239 i24                    ; copy memory
add $r242 $r225 $one
move $r223 $r242                        ; move parameter from branch to block argument
ji  .81
.77
addi $r244 $$locbase i208               ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
addi $r245 $r244 i40                    ; get offset to aggregate element
addi $r246 $$locbase i1456              ; get offset to local __ptr { u64, u64 }
mcpi $r246 $r245 i16                    ; copy memory
addi $r247 $$locbase i928               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r248 $$locbase i616               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r248 $r247 i24                    ; copy memory
addi $r249 $$locbase i336               ; get offset to local __ptr { { ptr, u64, u64 } }
movi $$arg0 i3                          ; [call]: pass argument 0
move $$arg1 $r248                       ; [call]: pass argument 1
move $$arg2 $r249                       ; [call]: pass argument 2
fncall .4                               ; [call]: call abi_encode_30
addi $r252 $$locbase i1216              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r252 $r249 i24                    ; copy memory
addi $r253 $$locbase i1456              ; get offset to local __ptr { u64, u64 }
addi $r254 $$locbase i1216              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r255 $$locbase i1392              ; get offset to local __ptr { u64, u64 }
mcpi $r255 $r253 i16                    ; copy memory
addi $r256 $$locbase i1000              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r256 $r254 i24                    ; copy memory
lw $r258 $$locbase i174                 ; load word
addi $r259 $$locbase i1000              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r260 $$locbase i640               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r260 $r259 i24                    ; copy memory
addi $r261 $$locbase i360               ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r258                       ; [call]: pass argument 0
move $$arg1 $r260                       ; [call]: pass argument 1
move $$arg2 $r261                       ; [call]: pass argument 2
fncall .4                               ; [call]: call abi_encode_30
addi $r263 $$locbase i1072              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r263 $r261 i24                    ; copy memory
lw $r266 $$locbase i175                 ; load word
addi $r267 $$locbase i1072              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r268 $$locbase i664               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r268 $r267 i24                    ; copy memory
addi $r269 $$locbase i384               ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r266                       ; [call]: pass argument 0
move $$arg1 $r268                       ; [call]: pass argument 1
move $$arg2 $r269                       ; [call]: pass argument 2
fncall .4                               ; [call]: call abi_encode_30
addi $r271 $$locbase i1144              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r271 $r269 i24                    ; copy memory
addi $r272 $$locbase i1144              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r273 $$locbase i1240              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r273 $r272 i24                    ; copy memory
addi $r274 $$locbase i1240              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r275 $$locbase i776               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r275 $r274 i24                    ; copy memory
move $r232 $r275                        ; move parameter from branch to block argument
.84
addi $r279 $$locbase i800               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r279 $r232 i24                    ; copy memory
move $r280 $r279                        ; move parameter from branch to block argument
ji  .85
.75
addi $r281 $$locbase i208               ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
addi $r282 $r281 i55                    ; get offset to aggregate element
lb $r283 $r282 i0                       ; load byte
addi $r284 $$locbase i928               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r285 $$locbase i592               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r285 $r284 i24                    ; copy memory
addi $r286 $$locbase i312               ; get offset to local __ptr { { ptr, u64, u64 } }
movi $$arg0 i2                          ; [call]: pass argument 0
move $$arg1 $r285                       ; [call]: pass argument 1
move $$arg2 $r286                       ; [call]: pass argument 2
fncall .4                               ; [call]: call abi_encode_30
addi $r289 $$locbase i1168              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r289 $r286 i24                    ; copy memory
addi $r290 $$locbase i1168              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r291 $$locbase i976               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r291 $r290 i24                    ; copy memory
addi $r292 $$locbase i520               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r293 $$locbase i976               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r295 $$locbase i48                ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r295 $r293 i24                    ; copy memory
addi $r296 $$locbase i136               ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r296 $r295 i24                    ; copy memory
lw $r297 $$locbase i17                  ; load word
lw $r299 $$locbase i18                  ; load word
lw $r301 $$locbase i19                  ; load word
add $r302 $r301 $one
gt $r303 $r302 $r299
move $r304 $r297                        ; move parameter from branch to block argument
move $r305 $r299                        ; move parameter from branch to block argument
jnzi $r303 .86
ji  .87
.86
movi $r306 i2                           ; initialize constant into register
mul $r307 $r299 $r306
add $r308 $r307 $one
aloc $r308
mcp $hp $r297 $r301
move $r304 $hp                          ; move parameter from branch to block argument
move $r305 $r308                        ; move parameter from branch to block argument
.87
move $r313 $r304                        ; move parameter from branch to block argument
move $r315 $r305                        ; move parameter from branch to block argument
add $r316 $r304 $r301
sb $r316 $r283 i0                       ; store byte
addi $r317 $$locbase i184               ; get offset to local __ptr { ptr, u64, u64 }
sw $$locbase $r313 i23                  ; store word
sw $$locbase $r315 i24                  ; store word
sw $$locbase $r302 i25                  ; store word
addi $r321 $$locbase i72                ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r321 $r317 i24                    ; copy memory
mcpi $r292 $r321 i24                    ; copy memory
addi $r322 $$locbase i1192              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r322 $r292 i24                    ; copy memory
addi $r323 $$locbase i1192              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r324 $$locbase i800               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r324 $r323 i24                    ; copy memory
move $r280 $r324                        ; move parameter from branch to block argument
.85
addi $r328 $$locbase i824               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r328 $r280 i24                    ; copy memory
move $r329 $r328                        ; move parameter from branch to block argument
ji  .88
.73
addi $r330 $$locbase i208               ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
addi $r331 $r330 i55                    ; get offset to aggregate element
lb $r332 $r331 i0                       ; load byte
addi $r333 $$locbase i928               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r334 $$locbase i568               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r334 $r333 i24                    ; copy memory
addi $r335 $$locbase i288               ; get offset to local __ptr { { ptr, u64, u64 } }
movi $$arg0 i1                          ; [call]: pass argument 0
move $$arg1 $r334                       ; [call]: pass argument 1
move $$arg2 $r335                       ; [call]: pass argument 2
fncall .4                               ; [call]: call abi_encode_30
addi $r337 $$locbase i1048              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r337 $r335 i24                    ; copy memory
addi $r338 $$locbase i1048              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r339 $$locbase i952               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r339 $r338 i24                    ; copy memory
addi $r340 $$locbase i496               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r341 $$locbase i952               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $$locbase $r341 i24                ; copy memory
addi $r343 $$locbase i112               ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r343 $$locbase i24                ; copy memory
lw $r344 $$locbase i14                  ; load word
lw $r346 $$locbase i15                  ; load word
lw $r348 $$locbase i16                  ; load word
add $r349 $r348 $one
gt $r350 $r349 $r346
move $r351 $r344                        ; move parameter from branch to block argument
move $r352 $r346                        ; move parameter from branch to block argument
jnzi $r350 .89
ji  .90
.89
movi $r353 i2                           ; initialize constant into register
mul $r354 $r346 $r353
add $r355 $r354 $one
aloc $r355
mcp $hp $r344 $r348
move $r351 $hp                          ; move parameter from branch to block argument
move $r352 $r355                        ; move parameter from branch to block argument
.90
move $r360 $r351                        ; move parameter from branch to block argument
move $r362 $r352                        ; move parameter from branch to block argument
add $r363 $r351 $r348
sb $r363 $r332 i0                       ; store byte
addi $r364 $$locbase i160               ; get offset to local __ptr { ptr, u64, u64 }
sw $$locbase $r360 i20                  ; store word
sw $$locbase $r362 i21                  ; store word
sw $$locbase $r349 i22                  ; store word
addi $r368 $$locbase i24                ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r368 $r364 i24                    ; copy memory
mcpi $r340 $r368 i24                    ; copy memory
addi $r369 $$locbase i1120              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r369 $r340 i24                    ; copy memory
addi $r370 $$locbase i1120              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r371 $$locbase i824               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r371 $r370 i24                    ; copy memory
move $r329 $r371                        ; move parameter from branch to block argument
.88
addi $r375 $$locbase i848               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r375 $r329 i24                    ; copy memory
move $r376 $r375                        ; move parameter from branch to block argument
ji  .91
.71
addi $r377 $$locbase i928               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r378 $$locbase i544               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r378 $r377 i24                    ; copy memory
addi $r379 $$locbase i264               ; get offset to local __ptr { { ptr, u64, u64 } }
movi $$arg0 i0                          ; [call]: pass argument 0
move $$arg1 $r378                       ; [call]: pass argument 1
move $$arg2 $r379                       ; [call]: pass argument 2
fncall .4                               ; [call]: call abi_encode_30
addi $r381 $$locbase i848               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r381 $r379 i24                    ; copy memory
move $r376 $r381                        ; move parameter from branch to block argument
.91
addi $r385 $$locbase i1312              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r385 $r376 i24                    ; copy memory
addi $r386 $$locbase i1312              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r387 $$locbase i904               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r387 $r386 i24                    ; copy memory
addi $r388 $$locbase i904               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r389 $$locbase i752               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r389 $r388 i24                    ; copy memory
addi $r390 $$locbase i480               ; get offset to local __ptr slice
move $$arg0 $r389                       ; [call]: pass argument 0
move $$arg1 $r390                       ; [call]: pass argument 1
fncall .10                              ; [call]: call as_raw_slice_39
addi $r392 $$locbase i872               ; get offset to local __ptr slice
mcpi $r392 $r390 i16                    ; copy memory
.92
mcpi $r169 $r392 i16                    ; copy memory
.3
cfsi i1520                              ; free 1520 bytes for locals and 0 slots for extra call arguments
move $$reta $r170                       ; restore return address
popa .2                                 ; restore all registers
jal $zero $$reta i0                     ; return from call
DIFF------------------------------
.program:
.4                                      ; --- start of function: abi_encode_30 ---
pusha .4                                ; save all registers
move $$locbase $sp                      ; save locals base register for function abi_encode_30
cfei i144                               ; allocate 144 bytes for locals and 0 slots for call arguments
.93
addi $r403 $$locbase i120               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r403 $$arg1 i24                   ; copy memory
addi $r404 $$locbase i96                ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r405 $$locbase i120               ; get offset to local __ptr { { ptr, u64, u64 } }
move $r406 $r405                        ; return value from ASM block with return register buffer
 mcpi $$locbase $r406 i24                ; copy memory
 mcpi $$locbase $r405 i24                ; copy memory
addi $r407 $$locbase i48                ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r407 $$locbase i24                ; copy memory
lw $r408 $$locbase i6                   ; load word
addi $r409 $r407 i8                     ; get offset to aggregate element
lw $r410 $$locbase i7                   ; load word
addi $r411 $r407 i16                    ; get offset to aggregate element
lw $r412 $$locbase i8                   ; load word
movi $r413 i8                           ; initialize constant into register
add $r414 $r412 $r413
gt $r415 $r414 $r410
move $r416 $r408                        ; move parameter from branch to block argument
move $r417 $r410                        ; move parameter from branch to block argument
jnzi $r415 .94
ji  .95
.94
movi $r418 i2                           ; initialize constant into register
mul $r419 $r410 $r418
movi $r420 i8                           ; initialize constant into register
add $r421 $r419 $r420
aloc $r421
mcp $hp $r408 $r412
move $r422 $hp                          ; return value from ASM block with return register hp
 move $r416 $r422                        ; move parameter from branch to block argument
 move $r416 $hp                          ; move parameter from branch to block argument
move $r417 $r421                        ; move parameter from branch to block argument
ji  .95
.95
move $r426 $r416                        ; move parameter from branch to block argument
move $r428 $r417                        ; move parameter from branch to block argument
 add $r429 $r426 $r412
 add $r429 $r416 $r412
sw $r429 $$arg0 i0                      ; store word
addi $r430 $$locbase i72                ; get offset to local __ptr { ptr, u64, u64 }
sw $$locbase $r426 i9                   ; store word
addi $r431 $r430 i8                     ; get offset to aggregate element
sw $$locbase $r428 i10                  ; store word
addi $r432 $r430 i16                    ; get offset to aggregate element
sw $$locbase $r414 i11                  ; store word
move $r433 $r430                        ; return value from ASM block with return register buffer
addi $r434 $$locbase i24                ; get offset to local __ptr { ptr, u64, u64 }
 mcpi $r434 $r433 i24                    ; copy memory
 mcpi $r434 $r430 i24                    ; copy memory
mcpi $r404 $r434 i24                    ; copy memory
mcpi $$arg2 $r404 i24                   ; copy memory
ji  .5
.5
cfsi i144                               ; free 144 bytes for locals and 0 slots for extra call arguments
popa .4                                 ; restore all registers
jal $zero $$reta i0                     ; return from call
DIFF------------------------------
.program:
.4                                      ; --- start of function: abi_encode_30 ---
pusha .4                                ; save all registers
move $$locbase $sp                      ; save locals base register for function abi_encode_30
cfei i144                               ; allocate 144 bytes for locals and 0 slots for call arguments
.93
addi $r403 $$locbase i120               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r403 $$arg1 i24                   ; copy memory
addi $r404 $$locbase i96                ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r405 $$locbase i120               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $$locbase $r405 i24                ; copy memory
addi $r407 $$locbase i48                ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r407 $$locbase i24                ; copy memory
lw $r408 $$locbase i6                   ; load word
lw $r410 $$locbase i7                   ; load word
lw $r412 $$locbase i8                   ; load word
movi $r413 i8                           ; initialize constant into register
add $r414 $r412 $r413
gt $r415 $r414 $r410
move $r416 $r408                        ; move parameter from branch to block argument
move $r417 $r410                        ; move parameter from branch to block argument
jnzi $r415 .94
ji  .95
.94
movi $r418 i2                           ; initialize constant into register
mul $r419 $r410 $r418
movi $r420 i8                           ; initialize constant into register
add $r421 $r419 $r420
aloc $r421
mcp $hp $r408 $r412
move $r416 $hp                          ; move parameter from branch to block argument
move $r417 $r421                        ; move parameter from branch to block argument
.95
move $r426 $r416                        ; move parameter from branch to block argument
move $r428 $r417                        ; move parameter from branch to block argument
add $r429 $r416 $r412
sw $r429 $$arg0 i0                      ; store word
addi $r430 $$locbase i72                ; get offset to local __ptr { ptr, u64, u64 }
sw $$locbase $r426 i9                   ; store word
sw $$locbase $r428 i10                  ; store word
sw $$locbase $r414 i11                  ; store word
addi $r434 $$locbase i24                ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r434 $r430 i24                    ; copy memory
mcpi $r404 $r434 i24                    ; copy memory
mcpi $$arg2 $r404 i24                   ; copy memory
.5
cfsi i144                               ; free 144 bytes for locals and 0 slots for extra call arguments
popa .4                                 ; restore all registers
jal $zero $$reta i0                     ; return from call
DIFF------------------------------
.program:
.4                                      ; --- start of function: abi_encode_30 ---
pusha .4                                ; save all registers
move $$locbase $sp                      ; save locals base register for function abi_encode_30
cfei i144                               ; allocate 144 bytes for locals and 0 slots for call arguments
.93
addi $r403 $$locbase i120               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r403 $$arg1 i24                   ; copy memory
addi $r404 $$locbase i96                ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r405 $$locbase i120               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $$locbase $r405 i24                ; copy memory
addi $r407 $$locbase i48                ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r407 $$locbase i24                ; copy memory
lw $r408 $$locbase i6                   ; load word
lw $r410 $$locbase i7                   ; load word
lw $r412 $$locbase i8                   ; load word
movi $r413 i8                           ; initialize constant into register
add $r414 $r412 $r413
gt $r415 $r414 $r410
move $r416 $r408                        ; move parameter from branch to block argument
move $r417 $r410                        ; move parameter from branch to block argument
jnzi $r415 .94
ji  .95
.94
movi $r418 i2                           ; initialize constant into register
mul $r419 $r410 $r418
movi $r420 i8                           ; initialize constant into register
add $r421 $r419 $r420
aloc $r421
mcp $hp $r408 $r412
move $r416 $hp                          ; move parameter from branch to block argument
move $r417 $r421                        ; move parameter from branch to block argument
.95
move $r426 $r416                        ; move parameter from branch to block argument
move $r428 $r417                        ; move parameter from branch to block argument
add $r429 $r416 $r412
sw $r429 $$arg0 i0                      ; store word
addi $r430 $$locbase i72                ; get offset to local __ptr { ptr, u64, u64 }
sw $$locbase $r426 i9                   ; store word
sw $$locbase $r428 i10                  ; store word
sw $$locbase $r414 i11                  ; store word
addi $r434 $$locbase i24                ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r434 $r430 i24                    ; copy memory
mcpi $r404 $r434 i24                    ; copy memory
mcpi $$arg2 $r404 i24                   ; copy memory
.5
cfsi i144                               ; free 144 bytes for locals and 0 slots for extra call arguments
popa .4                                 ; restore all registers
jal $zero $$reta i0                     ; return from call
DIFF------------------------------
.program:
.4                                      ; --- start of function: abi_encode_30 ---
pusha .4                                ; save all registers
move $$locbase $sp                      ; save locals base register for function abi_encode_30
cfei i144                               ; allocate 144 bytes for locals and 0 slots for call arguments
.93
addi $r403 $$locbase i120               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r403 $$arg1 i24                   ; copy memory
addi $r404 $$locbase i96                ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r405 $$locbase i120               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $$locbase $r405 i24                ; copy memory
addi $r407 $$locbase i48                ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r407 $$locbase i24                ; copy memory
lw $r408 $$locbase i6                   ; load word
lw $r410 $$locbase i7                   ; load word
lw $r412 $$locbase i8                   ; load word
movi $r413 i8                           ; initialize constant into register
add $r414 $r412 $r413
gt $r415 $r414 $r410
move $r416 $r408                        ; move parameter from branch to block argument
move $r417 $r410                        ; move parameter from branch to block argument
jnzi $r415 .94
ji  .95
.94
movi $r418 i2                           ; initialize constant into register
mul $r419 $r410 $r418
movi $r420 i8                           ; initialize constant into register
add $r421 $r419 $r420
aloc $r421
mcp $hp $r408 $r412
move $r416 $hp                          ; move parameter from branch to block argument
move $r417 $r421                        ; move parameter from branch to block argument
.95
move $r426 $r416                        ; move parameter from branch to block argument
move $r428 $r417                        ; move parameter from branch to block argument
add $r429 $r416 $r412
sw $r429 $$arg0 i0                      ; store word
addi $r430 $$locbase i72                ; get offset to local __ptr { ptr, u64, u64 }
sw $$locbase $r426 i9                   ; store word
sw $$locbase $r428 i10                  ; store word
sw $$locbase $r414 i11                  ; store word
addi $r434 $$locbase i24                ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r434 $r430 i24                    ; copy memory
mcpi $r404 $r434 i24                    ; copy memory
mcpi $$arg2 $r404 i24                   ; copy memory
.5
cfsi i144                               ; free 144 bytes for locals and 0 slots for extra call arguments
popa .4                                 ; restore all registers
jal $zero $$reta i0                     ; return from call
DIFF------------------------------
.program:
.6                                      ; --- start of function: abi_encode_36 ---
pusha .6                                ; save all registers
move $$locbase $sp                      ; save locals base register for function abi_encode_36
cfei i224                               ; allocate 224 bytes for locals and 0 slots for call arguments
.96
addi $r436 $$locbase i208               ; get offset to local __ptr slice
mcpi $r436 $$arg0 i16                   ; copy memory
addi $r437 $$locbase i184               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r437 $$arg1 i24                   ; copy memory
addi $r438 $$locbase i160               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r439 $$locbase i184               ; get offset to local __ptr { { ptr, u64, u64 } }
move $r440 $r439                        ; return value from ASM block with return register buffer
 mcpi $$locbase $r440 i24                ; copy memory
 mcpi $$locbase $r439 i24                ; copy memory
addi $r441 $$locbase i80                ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r441 $$locbase i24                ; copy memory
lw $r442 $$locbase i10                  ; load word
addi $r443 $r441 i8                     ; get offset to aggregate element
lw $r444 $$locbase i11                  ; load word
addi $r445 $r441 i16                    ; get offset to aggregate element
lw $r446 $$locbase i12                  ; load word
addi $r447 $$locbase i208               ; get offset to local __ptr slice
addi $r448 $$locbase i40                ; get offset to local __ptr slice
mcpi $r448 $r447 i16                    ; copy memory
move $r449 $r447                        ; return value from ASM block with return register item
addi $r450 $$locbase i24                ; get offset to local __ptr { u64, u64 }
 mcpi $r450 $r449 i16                    ; copy memory
 mcpi $r450 $r447 i16                    ; copy memory
addi $r451 $$locbase i104               ; get offset to local __ptr { u64, u64 }
mcpi $r451 $r450 i16                    ; copy memory
addi $r452 $r451 i8                     ; get offset to aggregate element
lw $r453 $$locbase i14                  ; load word
movi $r454 i8                           ; initialize constant into register
add $r455 $r453 $r454
add $r456 $r446 $r455
gt $r457 $r456 $r444
move $r458 $r442                        ; move parameter from branch to block argument
move $r459 $r444                        ; move parameter from branch to block argument
jnzi $r457 .97
ji  .98
.97
movi $r460 i2                           ; initialize constant into register
mul $r461 $r444 $r460
add $r462 $r461 $r455
aloc $r462
mcp $hp $r442 $r446
move $r463 $hp                          ; return value from ASM block with return register hp
 move $r458 $r463                        ; move parameter from branch to block argument
 move $r458 $hp                          ; move parameter from branch to block argument
move $r459 $r462                        ; move parameter from branch to block argument
ji  .98
.98
move $r467 $r458                        ; move parameter from branch to block argument
move $r469 $r459                        ; move parameter from branch to block argument
addi $r470 $$locbase i120               ; get offset to local __ptr slice
mcpi $r470 $r448 i16                    ; copy memory
add $r471 $r467 $r446
lw $r473 $$locbase i16
sw $r471 $r473 i0
addi $r471 $r471 i8
lw $r472 $$locbase i15
mcp $r471 $r472 $r473
addi $r474 $r446 i8
add $r474 $r474 $r473
move $r475 $r474                        ; return value from ASM block with return register new_len
addi $r476 $$locbase i136               ; get offset to local __ptr { ptr, u64, u64 }
sw $$locbase $r467 i17                  ; store word
addi $r477 $r476 i8                     ; get offset to aggregate element
sw $$locbase $r469 i18                  ; store word
addi $r478 $r476 i16                    ; get offset to aggregate element
sw $$locbase $r475 i19                  ; store word
move $r479 $r476                        ; return value from ASM block with return register buffer
addi $r480 $$locbase i56                ; get offset to local __ptr { ptr, u64, u64 }
 mcpi $r480 $r479 i24                    ; copy memory
 mcpi $r480 $r476 i24                    ; copy memory
mcpi $r438 $r480 i24                    ; copy memory
mcpi $$arg2 $r438 i24                   ; copy memory
ji  .7
.7
cfsi i224                               ; free 224 bytes for locals and 0 slots for extra call arguments
popa .6                                 ; restore all registers
jal $zero $$reta i0                     ; return from call
DIFF------------------------------
.program:
.6                                      ; --- start of function: abi_encode_36 ---
pusha .6                                ; save all registers
move $$locbase $sp                      ; save locals base register for function abi_encode_36
cfei i224                               ; allocate 224 bytes for locals and 0 slots for call arguments
.96
addi $r436 $$locbase i208               ; get offset to local __ptr slice
mcpi $r436 $$arg0 i16                   ; copy memory
addi $r437 $$locbase i184               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r437 $$arg1 i24                   ; copy memory
addi $r438 $$locbase i160               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r439 $$locbase i184               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $$locbase $r439 i24                ; copy memory
addi $r441 $$locbase i80                ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r441 $$locbase i24                ; copy memory
lw $r442 $$locbase i10                  ; load word
lw $r444 $$locbase i11                  ; load word
lw $r446 $$locbase i12                  ; load word
addi $r447 $$locbase i208               ; get offset to local __ptr slice
addi $r448 $$locbase i40                ; get offset to local __ptr slice
mcpi $r448 $r447 i16                    ; copy memory
addi $r450 $$locbase i24                ; get offset to local __ptr { u64, u64 }
mcpi $r450 $r447 i16                    ; copy memory
addi $r451 $$locbase i104               ; get offset to local __ptr { u64, u64 }
mcpi $r451 $r450 i16                    ; copy memory
lw $r453 $$locbase i14                  ; load word
movi $r454 i8                           ; initialize constant into register
add $r455 $r453 $r454
add $r456 $r446 $r455
gt $r457 $r456 $r444
move $r458 $r442                        ; move parameter from branch to block argument
move $r459 $r444                        ; move parameter from branch to block argument
jnzi $r457 .97
ji  .98
.97
movi $r460 i2                           ; initialize constant into register
mul $r461 $r444 $r460
add $r462 $r461 $r455
aloc $r462
mcp $hp $r442 $r446
move $r458 $hp                          ; move parameter from branch to block argument
move $r459 $r462                        ; move parameter from branch to block argument
.98
move $r467 $r458                        ; move parameter from branch to block argument
move $r469 $r459                        ; move parameter from branch to block argument
addi $r470 $$locbase i120               ; get offset to local __ptr slice
mcpi $r470 $r448 i16                    ; copy memory
add $r471 $r467 $r446
lw $r473 $$locbase i16
sw $r471 $r473 i0
addi $r471 $r471 i8
lw $r472 $$locbase i15
mcp $r471 $r472 $r473
addi $r474 $r446 i8
add $r474 $r474 $r473
move $r475 $r474                        ; return value from ASM block with return register new_len
addi $r476 $$locbase i136               ; get offset to local __ptr { ptr, u64, u64 }
sw $$locbase $r467 i17                  ; store word
sw $$locbase $r469 i18                  ; store word
sw $$locbase $r475 i19                  ; store word
addi $r480 $$locbase i56                ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r480 $r476 i24                    ; copy memory
mcpi $r438 $r480 i24                    ; copy memory
mcpi $$arg2 $r438 i24                   ; copy memory
.7
cfsi i224                               ; free 224 bytes for locals and 0 slots for extra call arguments
popa .6                                 ; restore all registers
jal $zero $$reta i0                     ; return from call
DIFF------------------------------
.program:
.6                                      ; --- start of function: abi_encode_36 ---
pusha .6                                ; save all registers
move $$locbase $sp                      ; save locals base register for function abi_encode_36
cfei i224                               ; allocate 224 bytes for locals and 0 slots for call arguments
.96
addi $r436 $$locbase i208               ; get offset to local __ptr slice
mcpi $r436 $$arg0 i16                   ; copy memory
addi $r437 $$locbase i184               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r437 $$arg1 i24                   ; copy memory
addi $r438 $$locbase i160               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r439 $$locbase i184               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $$locbase $r439 i24                ; copy memory
addi $r441 $$locbase i80                ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r441 $$locbase i24                ; copy memory
lw $r442 $$locbase i10                  ; load word
lw $r444 $$locbase i11                  ; load word
lw $r446 $$locbase i12                  ; load word
addi $r447 $$locbase i208               ; get offset to local __ptr slice
addi $r448 $$locbase i40                ; get offset to local __ptr slice
mcpi $r448 $r447 i16                    ; copy memory
addi $r450 $$locbase i24                ; get offset to local __ptr { u64, u64 }
mcpi $r450 $r447 i16                    ; copy memory
addi $r451 $$locbase i104               ; get offset to local __ptr { u64, u64 }
mcpi $r451 $r450 i16                    ; copy memory
lw $r453 $$locbase i14                  ; load word
movi $r454 i8                           ; initialize constant into register
add $r455 $r453 $r454
add $r456 $r446 $r455
gt $r457 $r456 $r444
move $r458 $r442                        ; move parameter from branch to block argument
move $r459 $r444                        ; move parameter from branch to block argument
jnzi $r457 .97
ji  .98
.97
movi $r460 i2                           ; initialize constant into register
mul $r461 $r444 $r460
add $r462 $r461 $r455
aloc $r462
mcp $hp $r442 $r446
move $r458 $hp                          ; move parameter from branch to block argument
move $r459 $r462                        ; move parameter from branch to block argument
.98
move $r467 $r458                        ; move parameter from branch to block argument
move $r469 $r459                        ; move parameter from branch to block argument
addi $r470 $$locbase i120               ; get offset to local __ptr slice
mcpi $r470 $r448 i16                    ; copy memory
add $r471 $r467 $r446
lw $r473 $$locbase i16
sw $r471 $r473 i0
addi $r471 $r471 i8
lw $r472 $$locbase i15
mcp $r471 $r472 $r473
addi $r474 $r446 i8
add $r474 $r474 $r473
move $r475 $r474                        ; return value from ASM block with return register new_len
addi $r476 $$locbase i136               ; get offset to local __ptr { ptr, u64, u64 }
sw $$locbase $r467 i17                  ; store word
sw $$locbase $r469 i18                  ; store word
sw $$locbase $r475 i19                  ; store word
addi $r480 $$locbase i56                ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r480 $r476 i24                    ; copy memory
mcpi $r438 $r480 i24                    ; copy memory
mcpi $$arg2 $r438 i24                   ; copy memory
.7
cfsi i224                               ; free 224 bytes for locals and 0 slots for extra call arguments
popa .6                                 ; restore all registers
jal $zero $$reta i0                     ; return from call
DIFF------------------------------
.program:
.6                                      ; --- start of function: abi_encode_36 ---
pusha .6                                ; save all registers
move $$locbase $sp                      ; save locals base register for function abi_encode_36
cfei i224                               ; allocate 224 bytes for locals and 0 slots for call arguments
.96
addi $r436 $$locbase i208               ; get offset to local __ptr slice
mcpi $r436 $$arg0 i16                   ; copy memory
addi $r437 $$locbase i184               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r437 $$arg1 i24                   ; copy memory
addi $r438 $$locbase i160               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r439 $$locbase i184               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $$locbase $r439 i24                ; copy memory
addi $r441 $$locbase i80                ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r441 $$locbase i24                ; copy memory
lw $r442 $$locbase i10                  ; load word
lw $r444 $$locbase i11                  ; load word
lw $r446 $$locbase i12                  ; load word
addi $r447 $$locbase i208               ; get offset to local __ptr slice
addi $r448 $$locbase i40                ; get offset to local __ptr slice
mcpi $r448 $r447 i16                    ; copy memory
addi $r450 $$locbase i24                ; get offset to local __ptr { u64, u64 }
mcpi $r450 $r447 i16                    ; copy memory
addi $r451 $$locbase i104               ; get offset to local __ptr { u64, u64 }
mcpi $r451 $r450 i16                    ; copy memory
lw $r453 $$locbase i14                  ; load word
movi $r454 i8                           ; initialize constant into register
add $r455 $r453 $r454
add $r456 $r446 $r455
gt $r457 $r456 $r444
move $r458 $r442                        ; move parameter from branch to block argument
move $r459 $r444                        ; move parameter from branch to block argument
jnzi $r457 .97
ji  .98
.97
movi $r460 i2                           ; initialize constant into register
mul $r461 $r444 $r460
add $r462 $r461 $r455
aloc $r462
mcp $hp $r442 $r446
move $r458 $hp                          ; move parameter from branch to block argument
move $r459 $r462                        ; move parameter from branch to block argument
.98
move $r467 $r458                        ; move parameter from branch to block argument
move $r469 $r459                        ; move parameter from branch to block argument
addi $r470 $$locbase i120               ; get offset to local __ptr slice
mcpi $r470 $r448 i16                    ; copy memory
add $r471 $r467 $r446
lw $r473 $$locbase i16
sw $r471 $r473 i0
addi $r471 $r471 i8
lw $r472 $$locbase i15
mcp $r471 $r472 $r473
addi $r474 $r446 i8
add $r474 $r474 $r473
move $r475 $r474                        ; return value from ASM block with return register new_len
addi $r476 $$locbase i136               ; get offset to local __ptr { ptr, u64, u64 }
sw $$locbase $r467 i17                  ; store word
sw $$locbase $r469 i18                  ; store word
sw $$locbase $r475 i19                  ; store word
addi $r480 $$locbase i56                ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r480 $r476 i24                    ; copy memory
mcpi $r438 $r480 i24                    ; copy memory
mcpi $$arg2 $r438 i24                   ; copy memory
.7
cfsi i224                               ; free 224 bytes for locals and 0 slots for extra call arguments
popa .6                                 ; restore all registers
jal $zero $$reta i0                     ; return from call
DIFF------------------------------
.program:
.8                                      ; --- start of function: new_38 ---
pusha .8                                ; save all registers
move $$locbase $sp                      ; save locals base register for function new_38
cfei i72                                ; allocate 72 bytes for locals and 0 slots for call arguments
.99
addi $r482 $$locbase i48                ; get offset to local __ptr { { ptr, u64, u64 } }
movi $r483 i1024                        ; initialize constant into register
aloc $r483
move $r484 $hp                          ; return value from ASM block with return register hp
addi $r485 $$locbase i24                ; get offset to local __ptr { ptr, u64, u64 }
 sw $$locbase $r484 i3                   ; store word
 sw $$locbase $hp i3                     ; store word
addi $r486 $r485 i8                     ; get offset to aggregate element
movi $r487 i1024                        ; initialize constant into register
sw $$locbase $r487 i4                   ; store word
addi $r488 $r485 i16                    ; get offset to aggregate element
sw $$locbase $zero i5                   ; store word
move $r489 $r485                        ; return value from ASM block with return register buffer
 mcpi $$locbase $r489 i24                ; copy memory
 mcpi $$locbase $r485 i24                ; copy memory
mcpi $r482 $$locbase i24                ; copy memory
mcpi $$arg0 $r482 i24                   ; copy memory
ji  .9
.9
cfsi i72                                ; free 72 bytes for locals and 0 slots for extra call arguments
popa .8                                 ; restore all registers
jal $zero $$reta i0                     ; return from call
DIFF------------------------------
.program:
.8                                      ; --- start of function: new_38 ---
pusha .8                                ; save all registers
move $$locbase $sp                      ; save locals base register for function new_38
cfei i72                                ; allocate 72 bytes for locals and 0 slots for call arguments
.99
addi $r482 $$locbase i48                ; get offset to local __ptr { { ptr, u64, u64 } }
movi $r483 i1024                        ; initialize constant into register
aloc $r483
addi $r485 $$locbase i24                ; get offset to local __ptr { ptr, u64, u64 }
sw $$locbase $hp i3                     ; store word
movi $r487 i1024                        ; initialize constant into register
sw $$locbase $r487 i4                   ; store word
sw $$locbase $zero i5                   ; store word
mcpi $$locbase $r485 i24                ; copy memory
mcpi $r482 $$locbase i24                ; copy memory
mcpi $$arg0 $r482 i24                   ; copy memory
.9
cfsi i72                                ; free 72 bytes for locals and 0 slots for extra call arguments
popa .8                                 ; restore all registers
jal $zero $$reta i0                     ; return from call
DIFF------------------------------
.program:
.8                                      ; --- start of function: new_38 ---
pusha .8                                ; save all registers
move $$locbase $sp                      ; save locals base register for function new_38
cfei i72                                ; allocate 72 bytes for locals and 0 slots for call arguments
.99
addi $r482 $$locbase i48                ; get offset to local __ptr { { ptr, u64, u64 } }
movi $r483 i1024                        ; initialize constant into register
aloc $r483
addi $r485 $$locbase i24                ; get offset to local __ptr { ptr, u64, u64 }
sw $$locbase $hp i3                     ; store word
movi $r487 i1024                        ; initialize constant into register
sw $$locbase $r487 i4                   ; store word
sw $$locbase $zero i5                   ; store word
mcpi $$locbase $r485 i24                ; copy memory
mcpi $r482 $$locbase i24                ; copy memory
mcpi $$arg0 $r482 i24                   ; copy memory
.9
cfsi i72                                ; free 72 bytes for locals and 0 slots for extra call arguments
popa .8                                 ; restore all registers
jal $zero $$reta i0                     ; return from call
DIFF------------------------------
.program:
.8                                      ; --- start of function: new_38 ---
pusha .8                                ; save all registers
move $$locbase $sp                      ; save locals base register for function new_38
cfei i72                                ; allocate 72 bytes for locals and 0 slots for call arguments
.99
addi $r482 $$locbase i48                ; get offset to local __ptr { { ptr, u64, u64 } }
movi $r483 i1024                        ; initialize constant into register
aloc $r483
addi $r485 $$locbase i24                ; get offset to local __ptr { ptr, u64, u64 }
sw $$locbase $hp i3                     ; store word
movi $r487 i1024                        ; initialize constant into register
sw $$locbase $r487 i4                   ; store word
sw $$locbase $zero i5                   ; store word
mcpi $$locbase $r485 i24                ; copy memory
mcpi $r482 $$locbase i24                ; copy memory
mcpi $$arg0 $r482 i24                   ; copy memory
.9
cfsi i72                                ; free 72 bytes for locals and 0 slots for extra call arguments
popa .8                                 ; restore all registers
jal $zero $$reta i0                     ; return from call
DIFF------------------------------
.program:
.10                                     ; --- start of function: as_raw_slice_39 ---
pusha .10                               ; save all registers
move $$locbase $sp                      ; save locals base register for function as_raw_slice_39
cfei i56                                ; allocate 56 bytes for locals and 0 slots for call arguments
.100
addi $r491 $$locbase i32                ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r491 $$arg0 i24                   ; copy memory
addi $r492 $$locbase i32                ; get offset to local __ptr { { ptr, u64, u64 } }
move $r493 $r492                        ; return value from ASM block with return register buffer
lw $r494 $r492 i0                       ; load word
 addi $r495 $r493 i16                    ; get offset to aggregate element
 addi $r495 $r492 i16                    ; get offset to aggregate element
lw $r496 $r492 i2                       ; load word
addi $r497 $$locbase i16                ; get offset to local __ptr { ptr, u64 }
sw $$locbase $r494 i2                   ; store word
addi $r498 $r497 i8                     ; get offset to aggregate element
sw $$locbase $r496 i3                   ; store word
move $r499 $r497                        ; return value from ASM block with return register s
 mcpi $$locbase $r499 i16                ; copy memory
 mcpi $$locbase $r497 i16                ; copy memory
mcpi $$arg1 $$locbase i16               ; copy memory
ji  .11
.11
cfsi i56                                ; free 56 bytes for locals and 0 slots for extra call arguments
popa .10                                ; restore all registers
jal $zero $$reta i0                     ; return from call
DIFF------------------------------
.program:
.10                                     ; --- start of function: as_raw_slice_39 ---
pusha .10                               ; save all registers
move $$locbase $sp                      ; save locals base register for function as_raw_slice_39
cfei i56                                ; allocate 56 bytes for locals and 0 slots for call arguments
.100
addi $r491 $$locbase i32                ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r491 $$arg0 i24                   ; copy memory
addi $r492 $$locbase i32                ; get offset to local __ptr { { ptr, u64, u64 } }
lw $r494 $$locbase i4                   ; load word
lw $r496 $$locbase i6                   ; load word
addi $r497 $$locbase i16                ; get offset to local __ptr { ptr, u64 }
sw $$locbase $r494 i2                   ; store word
sw $$locbase $r496 i3                   ; store word
mcpi $$locbase $r497 i16                ; copy memory
mcpi $$arg1 $$locbase i16               ; copy memory
.11
cfsi i56                                ; free 56 bytes for locals and 0 slots for extra call arguments
popa .10                                ; restore all registers
jal $zero $$reta i0                     ; return from call
DIFF------------------------------
.program:
.10                                     ; --- start of function: as_raw_slice_39 ---
pusha .10                               ; save all registers
move $$locbase $sp                      ; save locals base register for function as_raw_slice_39
cfei i56                                ; allocate 56 bytes for locals and 0 slots for call arguments
.100
addi $r491 $$locbase i32                ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r491 $$arg0 i24                   ; copy memory
lw $r494 $$locbase i4                   ; load word
lw $r496 $$locbase i6                   ; load word
addi $r497 $$locbase i16                ; get offset to local __ptr { ptr, u64 }
sw $$locbase $r494 i2                   ; store word
sw $$locbase $r496 i3                   ; store word
mcpi $$locbase $r497 i16                ; copy memory
mcpi $$arg1 $$locbase i16               ; copy memory
.11
cfsi i56                                ; free 56 bytes for locals and 0 slots for extra call arguments
popa .10                                ; restore all registers
jal $zero $$reta i0                     ; return from call
DIFF------------------------------
.program:
.10                                     ; --- start of function: as_raw_slice_39 ---
pusha .10                               ; save all registers
move $$locbase $sp                      ; save locals base register for function as_raw_slice_39
cfei i56                                ; allocate 56 bytes for locals and 0 slots for call arguments
.100
addi $r491 $$locbase i32                ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r491 $$arg0 i24                   ; copy memory
lw $r494 $$locbase i4                   ; load word
lw $r496 $$locbase i6                   ; load word
addi $r497 $$locbase i16                ; get offset to local __ptr { ptr, u64 }
sw $$locbase $r494 i2                   ; store word
sw $$locbase $r496 i3                   ; store word
mcpi $$locbase $r497 i16                ; copy memory
mcpi $$arg1 $$locbase i16               ; copy memory
.11
cfsi i56                                ; free 56 bytes for locals and 0 slots for extra call arguments
popa .10                                ; restore all registers
jal $zero $$reta i0                     ; return from call
DIFF------------------------------
.program:
.12                                     ; --- start of function: generic_panic_41 ---
pusha .12                               ; save all registers
move $$locbase $sp                      ; save locals base register for function generic_panic_41
cfei i64                                ; allocate 64 bytes for locals and 0 slots for call arguments
move $r500 $$arg0                       ; save argument 0 (t)
move $r501 $$arg1                       ; save argument 1 (__backtrace)
move $r502 $$reta                       ; save return address
.101
addi $r503 $$locbase i16                ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r503                       ; [call]: pass argument 0
fncall .8                               ; [call]: call new_38
 move $r504 $zero                        ; [call]: return unit value
 movi $r504 i0                           ; [call]: return unit value
addi $r505 $$locbase i16                ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r506 $$locbase i40                ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r500                       ; [call]: pass argument 0
move $$arg1 $r505                       ; [call]: pass argument 1
move $$arg2 $r506                       ; [call]: pass argument 2
fncall .6                               ; [call]: call abi_encode_36
 move $r507 $zero                        ; [call]: return unit value
 movi $r507 i0                           ; [call]: return unit value
addi $r508 $$locbase i40                ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r508                       ; [call]: pass argument 0
move $$arg1 $$locbase                   ; [call]: pass argument 1
fncall .10                              ; [call]: call as_raw_slice_39
 move $r509 $zero                        ; [call]: return unit value
 movi $r509 i0                           ; [call]: return unit value
load $r510 data_NonConfigurable_9       ; load constant from data section
lw $r511 $$locbase i0                   ; load slice pointer for logging data
lw $r512 $$locbase i1                   ; load slice size for logging data
logd $zero $r510 $r511 $r512            ; log slice
load $r513 data_NonConfigurable_10      ; load constant from data section
and $r514 $r501 $r513
load $r515 data_NonConfigurable_11      ; load constant from data section
or $r516 $r515 $r514
rvrt $r516
.13
cfsi i64                                ; free 64 bytes for locals and 0 slots for extra call arguments
move $$reta $r502                       ; restore return address
popa .12                                ; restore all registers
jal $zero $$reta i0                     ; return from call
DIFF------------------------------
.program:
.12                                     ; --- start of function: generic_panic_41 ---
pusha .12                               ; save all registers
move $$locbase $sp                      ; save locals base register for function generic_panic_41
cfei i64                                ; allocate 64 bytes for locals and 0 slots for call arguments
move $r500 $$arg0                       ; save argument 0 (t)
move $r501 $$arg1                       ; save argument 1 (__backtrace)
.101
addi $r503 $$locbase i16                ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r503                       ; [call]: pass argument 0
fncall .8                               ; [call]: call new_38
addi $r505 $$locbase i16                ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r506 $$locbase i40                ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r500                       ; [call]: pass argument 0
move $$arg1 $r505                       ; [call]: pass argument 1
move $$arg2 $r506                       ; [call]: pass argument 2
fncall .6                               ; [call]: call abi_encode_36
addi $r508 $$locbase i40                ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r508                       ; [call]: pass argument 0
move $$arg1 $$locbase                   ; [call]: pass argument 1
fncall .10                              ; [call]: call as_raw_slice_39
load $r510 data_NonConfigurable_9       ; load constant from data section
lw $r511 $$locbase i0                   ; load slice pointer for logging data
lw $r512 $$locbase i1                   ; load slice size for logging data
logd $zero $r510 $r511 $r512            ; log slice
load $r513 data_NonConfigurable_10      ; load constant from data section
and $r514 $r501 $r513
load $r515 data_NonConfigurable_11      ; load constant from data section
or $r516 $r515 $r514
rvrt $r516
DIFF------------------------------
.program:
.12                                     ; --- start of function: generic_panic_41 ---
pusha .12                               ; save all registers
move $$locbase $sp                      ; save locals base register for function generic_panic_41
cfei i64                                ; allocate 64 bytes for locals and 0 slots for call arguments
move $r500 $$arg0                       ; save argument 0 (t)
move $r501 $$arg1                       ; save argument 1 (__backtrace)
.101
addi $r503 $$locbase i16                ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r503                       ; [call]: pass argument 0
fncall .8                               ; [call]: call new_38
addi $r505 $$locbase i16                ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r506 $$locbase i40                ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r500                       ; [call]: pass argument 0
move $$arg1 $r505                       ; [call]: pass argument 1
move $$arg2 $r506                       ; [call]: pass argument 2
fncall .6                               ; [call]: call abi_encode_36
addi $r508 $$locbase i40                ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r508                       ; [call]: pass argument 0
move $$arg1 $$locbase                   ; [call]: pass argument 1
fncall .10                              ; [call]: call as_raw_slice_39
load $r510 data_NonConfigurable_9       ; load constant from data section
lw $r511 $$locbase i0                   ; load slice pointer for logging data
lw $r512 $$locbase i1                   ; load slice size for logging data
logd $zero $r510 $r511 $r512            ; log slice
load $r513 data_NonConfigurable_10      ; load constant from data section
and $r514 $r501 $r513
load $r515 data_NonConfigurable_11      ; load constant from data section
or $r516 $r515 $r514
rvrt $r516
DIFF------------------------------
.program:
.12                                     ; --- start of function: generic_panic_41 ---
pusha .12                               ; save all registers
move $$locbase $sp                      ; save locals base register for function generic_panic_41
cfei i64                                ; allocate 64 bytes for locals and 0 slots for call arguments
move $r500 $$arg0                       ; save argument 0 (t)
move $r501 $$arg1                       ; save argument 1 (__backtrace)
.101
addi $r503 $$locbase i16                ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r503                       ; [call]: pass argument 0
fncall .8                               ; [call]: call new_38
addi $r505 $$locbase i16                ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r506 $$locbase i40                ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r500                       ; [call]: pass argument 0
move $$arg1 $r505                       ; [call]: pass argument 1
move $$arg2 $r506                       ; [call]: pass argument 2
fncall .6                               ; [call]: call abi_encode_36
addi $r508 $$locbase i40                ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r508                       ; [call]: pass argument 0
move $$arg1 $$locbase                   ; [call]: pass argument 1
fncall .10                              ; [call]: call as_raw_slice_39
load $r510 data_NonConfigurable_9       ; load constant from data section
lw $r511 $$locbase i0                   ; load slice pointer for logging data
lw $r512 $$locbase i1                   ; load slice size for logging data
logd $zero $r510 $r511 $r512            ; log slice
load $r513 data_NonConfigurable_10      ; load constant from data section
and $r514 $r501 $r513
load $r515 data_NonConfigurable_11      ; load constant from data section
or $r516 $r515 $r514
rvrt $r516
DIFF------------------------------
.program:
.14                                     ; --- start of function: generic_panic_with_unit_43 ---
pusha .14                               ; save all registers
move $$locbase $sp                      ; save locals base register for function generic_panic_with_unit_43
cfei i32                                ; allocate 32 bytes for locals and 0 slots for call arguments
.102
addi $r518 $$locbase i32                ; get offset to local __ptr ()
addi $r519 $$locbase i32                ; get offset to local __ptr ()
sw $$locbase $r519 i0                   ; store word
addi $r520 $$locbase i8                 ; get offset to aggregate element
sw $$locbase $zero i1                   ; store word
addi $r521 $$locbase i16                ; get offset to local __ptr slice
mcpi $r521 $$locbase i16                ; copy memory
load $r522 data_NonConfigurable_12      ; load constant from data section
lw $r523 $$locbase i2                   ; load slice pointer for logging data
lw $r524 $$locbase i3                   ; load slice size for logging data
logd $zero $r522 $r523 $r524            ; log slice
load $r525 data_NonConfigurable_10      ; load constant from data section
and $r526 $$arg0 $r525
load $r527 data_NonConfigurable_13      ; load constant from data section
or $r528 $r527 $r526
rvrt $r528
.15
cfsi i32                                ; free 32 bytes for locals and 0 slots for extra call arguments
popa .14                                ; restore all registers
jal $zero $$reta i0                     ; return from call
DIFF------------------------------
.program:
.14                                     ; --- start of function: generic_panic_with_unit_43 ---
pusha .14                               ; save all registers
move $$locbase $sp                      ; save locals base register for function generic_panic_with_unit_43
cfei i32                                ; allocate 32 bytes for locals and 0 slots for call arguments
.102
addi $r519 $$locbase i32                ; get offset to local __ptr ()
sw $$locbase $r519 i0                   ; store word
sw $$locbase $zero i1                   ; store word
addi $r521 $$locbase i16                ; get offset to local __ptr slice
mcpi $r521 $$locbase i16                ; copy memory
load $r522 data_NonConfigurable_12      ; load constant from data section
lw $r523 $$locbase i2                   ; load slice pointer for logging data
lw $r524 $$locbase i3                   ; load slice size for logging data
logd $zero $r522 $r523 $r524            ; log slice
load $r525 data_NonConfigurable_10      ; load constant from data section
and $r526 $$arg0 $r525
load $r527 data_NonConfigurable_13      ; load constant from data section
or $r528 $r527 $r526
rvrt $r528
DIFF------------------------------
.program:
.14                                     ; --- start of function: generic_panic_with_unit_43 ---
pusha .14                               ; save all registers
move $$locbase $sp                      ; save locals base register for function generic_panic_with_unit_43
cfei i32                                ; allocate 32 bytes for locals and 0 slots for call arguments
.102
addi $r519 $$locbase i32                ; get offset to local __ptr ()
sw $$locbase $r519 i0                   ; store word
sw $$locbase $zero i1                   ; store word
addi $r521 $$locbase i16                ; get offset to local __ptr slice
mcpi $r521 $$locbase i16                ; copy memory
load $r522 data_NonConfigurable_12      ; load constant from data section
lw $r523 $$locbase i2                   ; load slice pointer for logging data
lw $r524 $$locbase i3                   ; load slice size for logging data
logd $zero $r522 $r523 $r524            ; log slice
load $r525 data_NonConfigurable_10      ; load constant from data section
and $r526 $$arg0 $r525
load $r527 data_NonConfigurable_13      ; load constant from data section
or $r528 $r527 $r526
rvrt $r528
DIFF------------------------------
.program:
.14                                     ; --- start of function: generic_panic_with_unit_43 ---
pusha .14                               ; save all registers
move $$locbase $sp                      ; save locals base register for function generic_panic_with_unit_43
cfei i32                                ; allocate 32 bytes for locals and 0 slots for call arguments
.102
addi $r519 $$locbase i32                ; get offset to local __ptr ()
sw $$locbase $r519 i0                   ; store word
sw $$locbase $zero i1                   ; store word
addi $r521 $$locbase i16                ; get offset to local __ptr slice
mcpi $r521 $$locbase i16                ; copy memory
load $r522 data_NonConfigurable_12      ; load constant from data section
lw $r523 $$locbase i2                   ; load slice pointer for logging data
lw $r524 $$locbase i3                   ; load slice size for logging data
logd $zero $r522 $r523 $r524            ; log slice
load $r525 data_NonConfigurable_10      ; load constant from data section
and $r526 $$arg0 $r525
load $r527 data_NonConfigurable_13      ; load constant from data section
or $r528 $r527 $r526
rvrt $r528
DIFF------------------------------
.program:
.16                                     ; --- start of function: nested_panic_non_inlined_47 ---
pusha .16                               ; save all registers
move $$locbase $sp                      ; save locals base register for function nested_panic_non_inlined_47
cfei i200                               ; allocate 200 bytes for locals and 0 slots for call arguments
move $r529 $$arg0                       ; save argument 0 (__backtrace)
move $r530 $$reta                       ; save return address
.103
movi $r531 i4                           ; initialize constant into register
sw $$locbase $r531 i0                   ; store word
addi $r532 $$locbase i152               ; get offset to local __ptr [slice; 3]
addr $r533 data_NonConfigurable_14      ; get __const_global4's address in data section
addi $r534 $$locbase i56                ; get offset to local __ptr { ptr, u64 }
sw $$locbase $r533 i7                   ; store word
addi $r535 $r534 i8                     ; get offset to aggregate element
movi $r536 i4                           ; initialize constant into register
sw $$locbase $r536 i8                   ; store word
addi $r537 $$locbase i72                ; get offset to local __ptr slice
mcpi $r537 $r534 i16                    ; copy memory
addr $r538 data_NonConfigurable_15      ; get __const_global5's address in data section
addi $r539 $$locbase i88                ; get offset to local __ptr { ptr, u64 }
sw $$locbase $r538 i11                  ; store word
addi $r540 $r539 i8                     ; get offset to aggregate element
movi $r541 i6                           ; initialize constant into register
sw $$locbase $r541 i12                  ; store word
addi $r542 $$locbase i104               ; get offset to local __ptr slice
mcpi $r542 $r539 i16                    ; copy memory
addr $r543 data_NonConfigurable_16      ; get __const_global6's address in data section
addi $r544 $$locbase i120               ; get offset to local __ptr { ptr, u64 }
sw $$locbase $r543 i15                  ; store word
addi $r545 $r544 i8                     ; get offset to aggregate element
movi $r546 i17                          ; initialize constant into register
sw $$locbase $r546 i16                  ; store word
addi $r547 $$locbase i136               ; get offset to local __ptr slice
mcpi $r547 $r544 i16                    ; copy memory
movi $r548 i16                          ; get array element size
 mul $r549 $zero $r548                   ; get offset to array element
 add $r549 $r532 $r549                   ; add array element offset to array base
 movi $r549 i0                           ; get offset to array element
 add $r549 $r532 $zero                   ; add array element offset to array base
mcpi $r549 $r537 i16                    ; copy memory
movi $r550 i16                          ; get array element size
 mul $r551 $one $r550                    ; get offset to array element
 movi $r551 i16                          ; get offset to array element
add $r551 $r532 $r551                   ; add array element offset to array base
mcpi $r551 $r542 i16                    ; copy memory
movi $r552 i16                          ; get array element size
movi $r553 i2                           ; initialize constant into register
 mul $r554 $r553 $r552                   ; get offset to array element
 movi $r554 i32                          ; get offset to array element
add $r554 $r532 $r554                   ; add array element offset to array base
mcpi $r554 $r547 i16                    ; copy memory
addi $r555 $$locbase i8                 ; get offset to aggregate element
mcpi $r555 $r532 i48                    ; copy memory
 move $$arg0 $one                        ; [call]: pass argument 0
 movi $$arg0 i1                          ; [call]: pass argument 0
move $$arg1 $$locbase                   ; [call]: pass argument 1
move $$arg2 $r529                       ; [call]: pass argument 2
fncall .18                              ; [call]: call nested_panic_non_inlined_49
 move $r556 $zero                        ; [call]: return unit value
 movi $r556 i0                           ; [call]: return unit value
ji  .17
.17
cfsi i200                               ; free 200 bytes for locals and 0 slots for extra call arguments
move $$reta $r530                       ; restore return address
popa .16                                ; restore all registers
jal $zero $$reta i0                     ; return from call
DIFF------------------------------
.program:
.16                                     ; --- start of function: nested_panic_non_inlined_47 ---
pusha .16                               ; save all registers
move $$locbase $sp                      ; save locals base register for function nested_panic_non_inlined_47
cfei i200                               ; allocate 200 bytes for locals and 0 slots for call arguments
move $r529 $$arg0                       ; save argument 0 (__backtrace)
move $r530 $$reta                       ; save return address
.103
movi $r531 i4                           ; initialize constant into register
sw $$locbase $r531 i0                   ; store word
addi $r532 $$locbase i152               ; get offset to local __ptr [slice; 3]
addr $r533 data_NonConfigurable_14      ; get __const_global4's address in data section
addi $r534 $$locbase i56                ; get offset to local __ptr { ptr, u64 }
sw $$locbase $r533 i7                   ; store word
movi $r536 i4                           ; initialize constant into register
sw $$locbase $r536 i8                   ; store word
addi $r537 $$locbase i72                ; get offset to local __ptr slice
mcpi $r537 $r534 i16                    ; copy memory
addr $r538 data_NonConfigurable_15      ; get __const_global5's address in data section
addi $r539 $$locbase i88                ; get offset to local __ptr { ptr, u64 }
sw $$locbase $r538 i11                  ; store word
movi $r541 i6                           ; initialize constant into register
sw $$locbase $r541 i12                  ; store word
addi $r542 $$locbase i104               ; get offset to local __ptr slice
mcpi $r542 $r539 i16                    ; copy memory
addr $r543 data_NonConfigurable_16      ; get __const_global6's address in data section
addi $r544 $$locbase i120               ; get offset to local __ptr { ptr, u64 }
sw $$locbase $r543 i15                  ; store word
movi $r546 i17                          ; initialize constant into register
sw $$locbase $r546 i16                  ; store word
addi $r547 $$locbase i136               ; get offset to local __ptr slice
mcpi $r547 $r544 i16                    ; copy memory
add $r549 $r532 $zero                   ; add array element offset to array base
mcpi $r549 $r537 i16                    ; copy memory
movi $r551 i16                          ; get offset to array element
add $r551 $r532 $r551                   ; add array element offset to array base
mcpi $r551 $r542 i16                    ; copy memory
movi $r554 i32                          ; get offset to array element
add $r554 $r532 $r554                   ; add array element offset to array base
mcpi $r554 $r547 i16                    ; copy memory
addi $r555 $$locbase i8                 ; get offset to aggregate element
mcpi $r555 $r532 i48                    ; copy memory
movi $$arg0 i1                          ; [call]: pass argument 0
move $$arg1 $$locbase                   ; [call]: pass argument 1
move $$arg2 $r529                       ; [call]: pass argument 2
fncall .18                              ; [call]: call nested_panic_non_inlined_49
.17
cfsi i200                               ; free 200 bytes for locals and 0 slots for extra call arguments
move $$reta $r530                       ; restore return address
popa .16                                ; restore all registers
jal $zero $$reta i0                     ; return from call
DIFF------------------------------
.program:
.16                                     ; --- start of function: nested_panic_non_inlined_47 ---
pusha .16                               ; save all registers
move $$locbase $sp                      ; save locals base register for function nested_panic_non_inlined_47
cfei i200                               ; allocate 200 bytes for locals and 0 slots for call arguments
move $r529 $$arg0                       ; save argument 0 (__backtrace)
move $r530 $$reta                       ; save return address
.103
movi $r531 i4                           ; initialize constant into register
sw $$locbase $r531 i0                   ; store word
addi $r532 $$locbase i152               ; get offset to local __ptr [slice; 3]
addr $r533 data_NonConfigurable_14      ; get __const_global4's address in data section
addi $r534 $$locbase i56                ; get offset to local __ptr { ptr, u64 }
sw $$locbase $r533 i7                   ; store word
movi $r536 i4                           ; initialize constant into register
sw $$locbase $r536 i8                   ; store word
addi $r537 $$locbase i72                ; get offset to local __ptr slice
mcpi $r537 $r534 i16                    ; copy memory
addr $r538 data_NonConfigurable_15      ; get __const_global5's address in data section
addi $r539 $$locbase i88                ; get offset to local __ptr { ptr, u64 }
sw $$locbase $r538 i11                  ; store word
movi $r541 i6                           ; initialize constant into register
sw $$locbase $r541 i12                  ; store word
addi $r542 $$locbase i104               ; get offset to local __ptr slice
mcpi $r542 $r539 i16                    ; copy memory
addr $r543 data_NonConfigurable_16      ; get __const_global6's address in data section
addi $r544 $$locbase i120               ; get offset to local __ptr { ptr, u64 }
sw $$locbase $r543 i15                  ; store word
movi $r546 i17                          ; initialize constant into register
sw $$locbase $r546 i16                  ; store word
addi $r547 $$locbase i136               ; get offset to local __ptr slice
mcpi $r547 $r544 i16                    ; copy memory
add $r549 $r532 $zero                   ; add array element offset to array base
mcpi $r549 $r537 i16                    ; copy memory
movi $r551 i16                          ; get offset to array element
add $r551 $r532 $r551                   ; add array element offset to array base
mcpi $r551 $r542 i16                    ; copy memory
movi $r554 i32                          ; get offset to array element
add $r554 $r532 $r554                   ; add array element offset to array base
mcpi $r554 $r547 i16                    ; copy memory
addi $r555 $$locbase i8                 ; get offset to aggregate element
mcpi $r555 $r532 i48                    ; copy memory
movi $$arg0 i1                          ; [call]: pass argument 0
move $$arg1 $$locbase                   ; [call]: pass argument 1
move $$arg2 $r529                       ; [call]: pass argument 2
fncall .18                              ; [call]: call nested_panic_non_inlined_49
.17
cfsi i200                               ; free 200 bytes for locals and 0 slots for extra call arguments
move $$reta $r530                       ; restore return address
popa .16                                ; restore all registers
jal $zero $$reta i0                     ; return from call
DIFF------------------------------
.program:
.16                                     ; --- start of function: nested_panic_non_inlined_47 ---
pusha .16                               ; save all registers
move $$locbase $sp                      ; save locals base register for function nested_panic_non_inlined_47
cfei i200                               ; allocate 200 bytes for locals and 0 slots for call arguments
move $r529 $$arg0                       ; save argument 0 (__backtrace)
move $r530 $$reta                       ; save return address
.103
movi $r531 i4                           ; initialize constant into register
sw $$locbase $r531 i0                   ; store word
addi $r532 $$locbase i152               ; get offset to local __ptr [slice; 3]
addr $r533 data_NonConfigurable_14      ; get __const_global4's address in data section
addi $r534 $$locbase i56                ; get offset to local __ptr { ptr, u64 }
sw $$locbase $r533 i7                   ; store word
movi $r536 i4                           ; initialize constant into register
sw $$locbase $r536 i8                   ; store word
addi $r537 $$locbase i72                ; get offset to local __ptr slice
mcpi $r537 $r534 i16                    ; copy memory
addr $r538 data_NonConfigurable_15      ; get __const_global5's address in data section
addi $r539 $$locbase i88                ; get offset to local __ptr { ptr, u64 }
sw $$locbase $r538 i11                  ; store word
movi $r541 i6                           ; initialize constant into register
sw $$locbase $r541 i12                  ; store word
addi $r542 $$locbase i104               ; get offset to local __ptr slice
mcpi $r542 $r539 i16                    ; copy memory
addr $r543 data_NonConfigurable_16      ; get __const_global6's address in data section
addi $r544 $$locbase i120               ; get offset to local __ptr { ptr, u64 }
sw $$locbase $r543 i15                  ; store word
movi $r546 i17                          ; initialize constant into register
sw $$locbase $r546 i16                  ; store word
addi $r547 $$locbase i136               ; get offset to local __ptr slice
mcpi $r547 $r544 i16                    ; copy memory
add $r549 $r532 $zero                   ; add array element offset to array base
mcpi $r549 $r537 i16                    ; copy memory
movi $r551 i16                          ; get offset to array element
add $r551 $r532 $r551                   ; add array element offset to array base
mcpi $r551 $r542 i16                    ; copy memory
movi $r554 i32                          ; get offset to array element
add $r554 $r532 $r554                   ; add array element offset to array base
mcpi $r554 $r547 i16                    ; copy memory
addi $r555 $$locbase i8                 ; get offset to aggregate element
mcpi $r555 $r532 i48                    ; copy memory
movi $$arg0 i1                          ; [call]: pass argument 0
move $$arg1 $$locbase                   ; [call]: pass argument 1
move $$arg2 $r529                       ; [call]: pass argument 2
fncall .18                              ; [call]: call nested_panic_non_inlined_49
.17
cfsi i200                               ; free 200 bytes for locals and 0 slots for extra call arguments
move $$reta $r530                       ; restore return address
popa .16                                ; restore all registers
jal $zero $$reta i0                     ; return from call
DIFF------------------------------
.program:
.18                                     ; --- start of function: nested_panic_non_inlined_49 ---
pusha .18                               ; save all registers
move $$locbase $sp                      ; save locals base register for function nested_panic_non_inlined_49
cfei i72                                ; allocate 72 bytes for locals and 0 slots for call arguments
move $r557 $$arg0                       ; save argument 0 (to_panic)
move $r558 $$arg1                       ; save argument 1 (err)
move $r559 $$arg2                       ; save argument 2 (__backtrace)
move $r560 $$reta                       ; save return address
.104
addi $r561 $$locbase i16                ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
 mcpi $r561 $r558 i56                    ; copy memory
 mcpi $r561 $$arg1 i56                   ; copy memory
jnzi $r557 .105
ji  .106
.106
ji  .19
.105
addi $r562 $$locbase i16                ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
move $$arg0 $r562                       ; [call]: pass argument 0
move $$arg1 $$locbase                   ; [call]: pass argument 1
fncall .2                               ; [call]: call encode_allow_alias_12
 move $r563 $zero                        ; [call]: return unit value
 movi $r563 i0                           ; [call]: return unit value
load $r564 data_NonConfigurable_1       ; load constant from data section
lw $r565 $$locbase i0                   ; load slice pointer for logging data
lw $r566 $$locbase i1                   ; load slice size for logging data
logd $zero $r564 $r565 $r566            ; log slice
load $r567 data_NonConfigurable_10      ; load constant from data section
and $r568 $r559 $r567
load $r569 data_NonConfigurable_17      ; load constant from data section
or $r570 $r569 $r568
rvrt $r570
.19
cfsi i72                                ; free 72 bytes for locals and 0 slots for extra call arguments
move $$reta $r560                       ; restore return address
popa .18                                ; restore all registers
jal $zero $$reta i0                     ; return from call
DIFF------------------------------
.program:
.18                                     ; --- start of function: nested_panic_non_inlined_49 ---
pusha .18                               ; save all registers
move $$locbase $sp                      ; save locals base register for function nested_panic_non_inlined_49
cfei i72                                ; allocate 72 bytes for locals and 0 slots for call arguments
move $r557 $$arg0                       ; save argument 0 (to_panic)
move $r559 $$arg2                       ; save argument 2 (__backtrace)
move $r560 $$reta                       ; save return address
.104
addi $r561 $$locbase i16                ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
mcpi $r561 $$arg1 i56                   ; copy memory
jnzi $r557 .105
.106
ji  .19
.105
addi $r562 $$locbase i16                ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
move $$arg0 $r562                       ; [call]: pass argument 0
move $$arg1 $$locbase                   ; [call]: pass argument 1
fncall .2                               ; [call]: call encode_allow_alias_12
load $r564 data_NonConfigurable_1       ; load constant from data section
lw $r565 $$locbase i0                   ; load slice pointer for logging data
lw $r566 $$locbase i1                   ; load slice size for logging data
logd $zero $r564 $r565 $r566            ; log slice
load $r567 data_NonConfigurable_10      ; load constant from data section
and $r568 $r559 $r567
load $r569 data_NonConfigurable_17      ; load constant from data section
or $r570 $r569 $r568
rvrt $r570
.19
cfsi i72                                ; free 72 bytes for locals and 0 slots for extra call arguments
move $$reta $r560                       ; restore return address
popa .18                                ; restore all registers
jal $zero $$reta i0                     ; return from call
DIFF------------------------------
.program:
.18                                     ; --- start of function: nested_panic_non_inlined_49 ---
pusha .18                               ; save all registers
move $$locbase $sp                      ; save locals base register for function nested_panic_non_inlined_49
cfei i72                                ; allocate 72 bytes for locals and 0 slots for call arguments
move $r557 $$arg0                       ; save argument 0 (to_panic)
move $r559 $$arg2                       ; save argument 2 (__backtrace)
move $r560 $$reta                       ; save return address
.104
addi $r561 $$locbase i16                ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
mcpi $r561 $$arg1 i56                   ; copy memory
jnzi $r557 .105
.106
ji  .19
.105
addi $r562 $$locbase i16                ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
move $$arg0 $r562                       ; [call]: pass argument 0
move $$arg1 $$locbase                   ; [call]: pass argument 1
fncall .2                               ; [call]: call encode_allow_alias_12
load $r564 data_NonConfigurable_1       ; load constant from data section
lw $r565 $$locbase i0                   ; load slice pointer for logging data
lw $r566 $$locbase i1                   ; load slice size for logging data
logd $zero $r564 $r565 $r566            ; log slice
load $r567 data_NonConfigurable_10      ; load constant from data section
and $r568 $r559 $r567
load $r569 data_NonConfigurable_17      ; load constant from data section
or $r570 $r569 $r568
rvrt $r570
.19
cfsi i72                                ; free 72 bytes for locals and 0 slots for extra call arguments
move $$reta $r560                       ; restore return address
popa .18                                ; restore all registers
jal $zero $$reta i0                     ; return from call
DIFF------------------------------
.program:
.18                                     ; --- start of function: nested_panic_non_inlined_49 ---
pusha .18                               ; save all registers
move $$locbase $sp                      ; save locals base register for function nested_panic_non_inlined_49
cfei i72                                ; allocate 72 bytes for locals and 0 slots for call arguments
move $r557 $$arg0                       ; save argument 0 (to_panic)
move $r559 $$arg2                       ; save argument 2 (__backtrace)
move $r560 $$reta                       ; save return address
.104
addi $r561 $$locbase i16                ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
mcpi $r561 $$arg1 i56                   ; copy memory
jnzi $r557 .105
.106
ji  .19
.105
addi $r562 $$locbase i16                ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
move $$arg0 $r562                       ; [call]: pass argument 0
move $$arg1 $$locbase                   ; [call]: pass argument 1
fncall .2                               ; [call]: call encode_allow_alias_12
load $r564 data_NonConfigurable_1       ; load constant from data section
lw $r565 $$locbase i0                   ; load slice pointer for logging data
lw $r566 $$locbase i1                   ; load slice size for logging data
logd $zero $r564 $r565 $r566            ; log slice
load $r567 data_NonConfigurable_10      ; load constant from data section
and $r568 $r559 $r567
load $r569 data_NonConfigurable_17      ; load constant from data section
or $r570 $r569 $r568
rvrt $r570
.19
cfsi i72                                ; free 72 bytes for locals and 0 slots for extra call arguments
move $$reta $r560                       ; restore return address
popa .18                                ; restore all registers
jal $zero $$reta i0                     ; return from call
DIFF------------------------------
.program:
.20                                     ; --- start of function: nested_panic_inlined_same_revert_code_54 ---
pusha .20                               ; save all registers
move $$locbase $sp                      ; save locals base register for function nested_panic_inlined_same_revert_code_54
cfei i216                               ; allocate 216 bytes for locals and 0 slots for call arguments
move $r571 $$arg0                       ; save argument 0 (__backtrace)
move $r572 $$reta                       ; save return address
.107
addi $r573 $$locbase i160               ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
movi $r574 i4                           ; initialize constant into register
sw $$locbase $r574 i20                  ; store word
addi $r575 $$locbase i96                ; get offset to local __ptr [slice; 3]
addr $r576 data_NonConfigurable_18      ; get __const_global0's address in data section
sw $$locbase $r576 i0                   ; store word
addi $r577 $$locbase i8                 ; get offset to aggregate element
movi $r578 i7                           ; initialize constant into register
sw $$locbase $r578 i1                   ; store word
addi $r579 $$locbase i16                ; get offset to local __ptr slice
mcpi $r579 $$locbase i16                ; copy memory
addr $r580 data_NonConfigurable_19      ; get __const_global1's address in data section
addi $r581 $$locbase i32                ; get offset to local __ptr { ptr, u64 }
sw $$locbase $r580 i4                   ; store word
addi $r582 $r581 i8                     ; get offset to aggregate element
movi $r583 i7                           ; initialize constant into register
sw $$locbase $r583 i5                   ; store word
addi $r584 $$locbase i48                ; get offset to local __ptr slice
mcpi $r584 $r581 i16                    ; copy memory
addr $r585 data_NonConfigurable_20      ; get __const_global2's address in data section
addi $r586 $$locbase i64                ; get offset to local __ptr { ptr, u64 }
sw $$locbase $r585 i8                   ; store word
addi $r587 $r586 i8                     ; get offset to aggregate element
movi $r588 i22                          ; initialize constant into register
sw $$locbase $r588 i9                   ; store word
addi $r589 $$locbase i80                ; get offset to local __ptr slice
mcpi $r589 $r586 i16                    ; copy memory
movi $r590 i16                          ; get array element size
 mul $r591 $zero $r590                   ; get offset to array element
 add $r591 $r575 $r591                   ; add array element offset to array base
 movi $r591 i0                           ; get offset to array element
 add $r591 $r575 $zero                   ; add array element offset to array base
mcpi $r591 $r579 i16                    ; copy memory
movi $r592 i16                          ; get array element size
 mul $r593 $one $r592                    ; get offset to array element
 movi $r593 i16                          ; get offset to array element
add $r593 $r575 $r593                   ; add array element offset to array base
mcpi $r593 $r584 i16                    ; copy memory
movi $r594 i16                          ; get array element size
movi $r595 i2                           ; initialize constant into register
 mul $r596 $r595 $r594                   ; get offset to array element
 movi $r596 i32                          ; get offset to array element
add $r596 $r575 $r596                   ; add array element offset to array base
mcpi $r596 $r589 i16                    ; copy memory
addi $r597 $r573 i8                     ; get offset to aggregate element
mcpi $r597 $r575 i48                    ; copy memory
addi $r598 $$locbase i160               ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
addi $r599 $$locbase i144               ; get offset to local __ptr slice
move $$arg0 $r598                       ; [call]: pass argument 0
move $$arg1 $r599                       ; [call]: pass argument 1
fncall .2                               ; [call]: call encode_allow_alias_12
 move $r600 $zero                        ; [call]: return unit value
 movi $r600 i0                           ; [call]: return unit value
addi $r601 $$locbase i144               ; get offset to local __ptr slice
load $r602 data_NonConfigurable_1       ; load constant from data section
lw $r603 $$locbase i18                  ; load slice pointer for logging data
lw $r604 $$locbase i19                  ; load slice size for logging data
logd $zero $r602 $r603 $r604            ; log slice
load $r605 data_NonConfigurable_10      ; load constant from data section
and $r606 $r571 $r605
load $r607 data_NonConfigurable_21      ; load constant from data section
or $r608 $r607 $r606
rvrt $r608
.21
cfsi i216                               ; free 216 bytes for locals and 0 slots for extra call arguments
move $$reta $r572                       ; restore return address
popa .20                                ; restore all registers
jal $zero $$reta i0                     ; return from call
DIFF------------------------------
.program:
.20                                     ; --- start of function: nested_panic_inlined_same_revert_code_54 ---
pusha .20                               ; save all registers
move $$locbase $sp                      ; save locals base register for function nested_panic_inlined_same_revert_code_54
cfei i216                               ; allocate 216 bytes for locals and 0 slots for call arguments
move $r571 $$arg0                       ; save argument 0 (__backtrace)
.107
addi $r573 $$locbase i160               ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
movi $r574 i4                           ; initialize constant into register
sw $$locbase $r574 i20                  ; store word
addi $r575 $$locbase i96                ; get offset to local __ptr [slice; 3]
addr $r576 data_NonConfigurable_18      ; get __const_global0's address in data section
sw $$locbase $r576 i0                   ; store word
movi $r578 i7                           ; initialize constant into register
sw $$locbase $r578 i1                   ; store word
addi $r579 $$locbase i16                ; get offset to local __ptr slice
mcpi $r579 $$locbase i16                ; copy memory
addr $r580 data_NonConfigurable_19      ; get __const_global1's address in data section
addi $r581 $$locbase i32                ; get offset to local __ptr { ptr, u64 }
sw $$locbase $r580 i4                   ; store word
movi $r583 i7                           ; initialize constant into register
sw $$locbase $r583 i5                   ; store word
addi $r584 $$locbase i48                ; get offset to local __ptr slice
mcpi $r584 $r581 i16                    ; copy memory
addr $r585 data_NonConfigurable_20      ; get __const_global2's address in data section
addi $r586 $$locbase i64                ; get offset to local __ptr { ptr, u64 }
sw $$locbase $r585 i8                   ; store word
movi $r588 i22                          ; initialize constant into register
sw $$locbase $r588 i9                   ; store word
addi $r589 $$locbase i80                ; get offset to local __ptr slice
mcpi $r589 $r586 i16                    ; copy memory
add $r591 $r575 $zero                   ; add array element offset to array base
mcpi $r591 $r579 i16                    ; copy memory
movi $r593 i16                          ; get offset to array element
add $r593 $r575 $r593                   ; add array element offset to array base
mcpi $r593 $r584 i16                    ; copy memory
movi $r596 i32                          ; get offset to array element
add $r596 $r575 $r596                   ; add array element offset to array base
mcpi $r596 $r589 i16                    ; copy memory
addi $r597 $r573 i8                     ; get offset to aggregate element
mcpi $r597 $r575 i48                    ; copy memory
addi $r598 $$locbase i160               ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
addi $r599 $$locbase i144               ; get offset to local __ptr slice
move $$arg0 $r598                       ; [call]: pass argument 0
move $$arg1 $r599                       ; [call]: pass argument 1
fncall .2                               ; [call]: call encode_allow_alias_12
load $r602 data_NonConfigurable_1       ; load constant from data section
lw $r603 $$locbase i18                  ; load slice pointer for logging data
lw $r604 $$locbase i19                  ; load slice size for logging data
logd $zero $r602 $r603 $r604            ; log slice
load $r605 data_NonConfigurable_10      ; load constant from data section
and $r606 $r571 $r605
load $r607 data_NonConfigurable_21      ; load constant from data section
or $r608 $r607 $r606
rvrt $r608
DIFF------------------------------
.program:
.20                                     ; --- start of function: nested_panic_inlined_same_revert_code_54 ---
pusha .20                               ; save all registers
move $$locbase $sp                      ; save locals base register for function nested_panic_inlined_same_revert_code_54
cfei i216                               ; allocate 216 bytes for locals and 0 slots for call arguments
move $r571 $$arg0                       ; save argument 0 (__backtrace)
.107
addi $r573 $$locbase i160               ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
movi $r574 i4                           ; initialize constant into register
sw $$locbase $r574 i20                  ; store word
addi $r575 $$locbase i96                ; get offset to local __ptr [slice; 3]
addr $r576 data_NonConfigurable_18      ; get __const_global0's address in data section
sw $$locbase $r576 i0                   ; store word
movi $r578 i7                           ; initialize constant into register
sw $$locbase $r578 i1                   ; store word
addi $r579 $$locbase i16                ; get offset to local __ptr slice
mcpi $r579 $$locbase i16                ; copy memory
addr $r580 data_NonConfigurable_19      ; get __const_global1's address in data section
addi $r581 $$locbase i32                ; get offset to local __ptr { ptr, u64 }
sw $$locbase $r580 i4                   ; store word
movi $r583 i7                           ; initialize constant into register
sw $$locbase $r583 i5                   ; store word
addi $r584 $$locbase i48                ; get offset to local __ptr slice
mcpi $r584 $r581 i16                    ; copy memory
addr $r585 data_NonConfigurable_20      ; get __const_global2's address in data section
addi $r586 $$locbase i64                ; get offset to local __ptr { ptr, u64 }
sw $$locbase $r585 i8                   ; store word
movi $r588 i22                          ; initialize constant into register
sw $$locbase $r588 i9                   ; store word
addi $r589 $$locbase i80                ; get offset to local __ptr slice
mcpi $r589 $r586 i16                    ; copy memory
add $r591 $r575 $zero                   ; add array element offset to array base
mcpi $r591 $r579 i16                    ; copy memory
movi $r593 i16                          ; get offset to array element
add $r593 $r575 $r593                   ; add array element offset to array base
mcpi $r593 $r584 i16                    ; copy memory
movi $r596 i32                          ; get offset to array element
add $r596 $r575 $r596                   ; add array element offset to array base
mcpi $r596 $r589 i16                    ; copy memory
addi $r597 $r573 i8                     ; get offset to aggregate element
mcpi $r597 $r575 i48                    ; copy memory
addi $r598 $$locbase i160               ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
addi $r599 $$locbase i144               ; get offset to local __ptr slice
move $$arg0 $r598                       ; [call]: pass argument 0
move $$arg1 $r599                       ; [call]: pass argument 1
fncall .2                               ; [call]: call encode_allow_alias_12
load $r602 data_NonConfigurable_1       ; load constant from data section
lw $r603 $$locbase i18                  ; load slice pointer for logging data
lw $r604 $$locbase i19                  ; load slice size for logging data
logd $zero $r602 $r603 $r604            ; log slice
load $r605 data_NonConfigurable_10      ; load constant from data section
and $r606 $r571 $r605
load $r607 data_NonConfigurable_21      ; load constant from data section
or $r608 $r607 $r606
rvrt $r608
DIFF------------------------------
.program:
.20                                     ; --- start of function: nested_panic_inlined_same_revert_code_54 ---
pusha .20                               ; save all registers
move $$locbase $sp                      ; save locals base register for function nested_panic_inlined_same_revert_code_54
cfei i216                               ; allocate 216 bytes for locals and 0 slots for call arguments
move $r571 $$arg0                       ; save argument 0 (__backtrace)
.107
addi $r573 $$locbase i160               ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
movi $r574 i4                           ; initialize constant into register
sw $$locbase $r574 i20                  ; store word
addi $r575 $$locbase i96                ; get offset to local __ptr [slice; 3]
addr $r576 data_NonConfigurable_18      ; get __const_global0's address in data section
sw $$locbase $r576 i0                   ; store word
movi $r578 i7                           ; initialize constant into register
sw $$locbase $r578 i1                   ; store word
addi $r579 $$locbase i16                ; get offset to local __ptr slice
mcpi $r579 $$locbase i16                ; copy memory
addr $r580 data_NonConfigurable_19      ; get __const_global1's address in data section
addi $r581 $$locbase i32                ; get offset to local __ptr { ptr, u64 }
sw $$locbase $r580 i4                   ; store word
movi $r583 i7                           ; initialize constant into register
sw $$locbase $r583 i5                   ; store word
addi $r584 $$locbase i48                ; get offset to local __ptr slice
mcpi $r584 $r581 i16                    ; copy memory
addr $r585 data_NonConfigurable_20      ; get __const_global2's address in data section
addi $r586 $$locbase i64                ; get offset to local __ptr { ptr, u64 }
sw $$locbase $r585 i8                   ; store word
movi $r588 i22                          ; initialize constant into register
sw $$locbase $r588 i9                   ; store word
addi $r589 $$locbase i80                ; get offset to local __ptr slice
mcpi $r589 $r586 i16                    ; copy memory
add $r591 $r575 $zero                   ; add array element offset to array base
mcpi $r591 $r579 i16                    ; copy memory
movi $r593 i16                          ; get offset to array element
add $r593 $r575 $r593                   ; add array element offset to array base
mcpi $r593 $r584 i16                    ; copy memory
movi $r596 i32                          ; get offset to array element
add $r596 $r575 $r596                   ; add array element offset to array base
mcpi $r596 $r589 i16                    ; copy memory
addi $r597 $r573 i8                     ; get offset to aggregate element
mcpi $r597 $r575 i48                    ; copy memory
addi $r598 $$locbase i160               ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
addi $r599 $$locbase i144               ; get offset to local __ptr slice
move $$arg0 $r598                       ; [call]: pass argument 0
move $$arg1 $r599                       ; [call]: pass argument 1
fncall .2                               ; [call]: call encode_allow_alias_12
load $r602 data_NonConfigurable_1       ; load constant from data section
lw $r603 $$locbase i18                  ; load slice pointer for logging data
lw $r604 $$locbase i19                  ; load slice size for logging data
logd $zero $r602 $r603 $r604            ; log slice
load $r605 data_NonConfigurable_10      ; load constant from data section
and $r606 $r571 $r605
load $r607 data_NonConfigurable_21      ; load constant from data section
or $r608 $r607 $r606
rvrt $r608
DIFF------------------------------
.program:
DIFF------------------------------
.program:
DIFF------------------------------
.program:
.0                                      ; --- start of function: __entry ---
move $$locbase $sp                      ; save locals base register for function __entry
cfei i608                               ; allocate 608 bytes for locals and 0 slots for call arguments
.48
addr $r1 data_NonConfigurable_0         ; get __const_global's address in data section
addi $r2 $$locbase i16                  ; get offset to local __ptr { ptr, u64 }
sw $$locbase $r1 i2                     ; store word
addi $r3 $r2 i8                         ; get offset to aggregate element
movi $r4 i454                           ; initialize constant into register
sw $$locbase $r4 i3                     ; store word
addi $r5 $$locbase i232                 ; get offset to local __ptr slice
mcpi $r5 $r2 i16                        ; copy memory
addi $r6 $$locbase i456                 ; get offset to local __ptr slice
mcpi $r6 $r5 i16                        ; copy memory
addi $r7 $$locbase i456                 ; get offset to local __ptr slice
addi $r8 $$locbase i472                 ; get offset to local __ptr slice
mcpi $r8 $r7 i16                        ; copy memory
addi $r9 $$locbase i472                 ; get offset to local __ptr slice
move $r10 $r9                           ; return value from ASM block with return register s
 mcpi $$locbase $r10 i16                 ; copy memory
 mcpi $$locbase $r9 i16                  ; copy memory
addi $r11 $$locbase i416                ; get offset to local __ptr { ptr, u64 }
mcpi $r11 $$locbase i16                 ; copy memory
addi $r12 $$locbase i416                ; get offset to local __ptr { ptr, u64 }
addi $r13 $$locbase i432                ; get offset to local __ptr { ptr, u64 }
mcpi $r13 $r12 i16                      ; copy memory
addi $r14 $$locbase i432                ; get offset to local __ptr { ptr, u64 }
lw $r15 $$locbase i54                   ; load word
move $r16 $fp                           ; return value from ASM block with return register fp
movi $r17 i592                          ; initialize constant into register
 add $r18 $r16 $r17
 add $r18 $fp $r17
lw $r19 $fp i74                         ; lw val ptr i0
move $r20 $r19                          ; return value from ASM block with return register val
move $r21 $fp                           ; return value from ASM block with return register fp
movi $r22 i584                          ; initialize constant into register
 add $r23 $r21 $r22
 add $r23 $fp $r22
lw $r24 $fp i73                         ; lw val ptr i0
move $r25 $r24                          ; return value from ASM block with return register val
 move $r26 $r25                          ; return value from ASM block with return register ptr
 move $r26 $r24                          ; return value from ASM block with return register ptr
addi $r27 $$locbase i376                ; get offset to local __ptr { ptr }
 sw $$locbase $r26 i47                   ; store word
 sw $$locbase $r24 i47                   ; store word
addi $r28 $$locbase i448                ; get offset to local __ptr { ptr }
mcpi $r28 $r27 i8                       ; copy memory
addi $r29 $$locbase i448                ; get offset to local __ptr { ptr }
lw $r30 $$locbase i56                   ; load word
lw $r31 $r30 i0                         ; lw val ptr i0
move $r32 $r31                          ; return value from ASM block with return register val
lw $r33 $$locbase i56                   ; load word
movi $r34 i8                            ; initialize constant into register
add $r35 $r33 $r34
sw $$locbase $r35 i56                   ; store word
addi $r36 $$locbase i448                ; get offset to local __ptr { ptr }
addi $r37 $$locbase i488                ; get offset to local __ptr { ptr }
mcpi $r37 $r36 i8                       ; copy memory
addi $r38 $$locbase i488                ; get offset to local __ptr { ptr }
lw $r39 $$locbase i61                   ; load word
movi $r40 i20                           ; initialize constant into register
eq $r41 $r32 $r40
jnzi $r41 .49
ji  .50
.49
movi $r43 i20                           ; initialize constant into register
addi $r42 $r15 i332
meq $r42 $r39 $r42 $r43
move $r44 $r42                          ; return value from ASM block with return register r
 jnzi $r44 .51
 jnzi $r42 .51
ji  .50
.50
movi $r45 i22                           ; initialize constant into register
eq $r46 $r32 $r45
jnzi $r46 .52
ji  .53
.52
movi $r48 i22                           ; initialize constant into register
addi $r47 $r15 i247
meq $r47 $r39 $r47 $r48
move $r49 $r47                          ; return value from ASM block with return register r
 jnzi $r49 .54
 jnzi $r47 .54
ji  .53
.53
movi $r50 i23                           ; initialize constant into register
eq $r51 $r32 $r50
jnzi $r51 .55
ji  .56
.55
movi $r53 i23                           ; initialize constant into register
addi $r52 $r15 i269
meq $r52 $r39 $r52 $r53
move $r54 $r52                          ; return value from ASM block with return register r
 jnzi $r54 .57
 jnzi $r52 .57
ji  .56
.56
movi $r55 i24                           ; initialize constant into register
eq $r56 $r32 $r55
jnzi $r56 .58
ji  .59
.58
movi $r58 i24                           ; initialize constant into register
addi $r57 $r15 i389
meq $r57 $r39 $r57 $r58
move $r59 $r57                          ; return value from ASM block with return register r
 jnzi $r59 .60
 jnzi $r57 .60
ji  .59
.59
movi $r60 i25                           ; initialize constant into register
eq $r61 $r32 $r60
jnzi $r61 .61
ji  .62
.61
movi $r63 i25                           ; initialize constant into register
addi $r62 $r15 i31
meq $r62 $r39 $r62 $r63
move $r64 $r62                          ; return value from ASM block with return register r
 jnzi $r64 .63
 jnzi $r62 .63
ji  .62
.62
movi $r65 i31                           ; initialize constant into register
eq $r66 $r32 $r65
jnzi $r66 .64
ji  .65
.64
movi $r68 i31                           ; initialize constant into register
addi $r67 $r15 i0
meq $r67 $r39 $r67 $r68
move $r69 $r67                          ; return value from ASM block with return register r
 jnzi $r69 .66
 jnzi $r67 .66
ji  .65
.65
movi $r70 i34                           ; initialize constant into register
eq $r71 $r32 $r70
jnzi $r71 .67
ji  .68
.67
movi $r73 i34                           ; initialize constant into register
addi $r72 $r15 i144
meq $r72 $r39 $r72 $r73
move $r74 $r72                          ; return value from ASM block with return register r
 jnzi $r74 .69
 jnzi $r72 .69
ji  .68
.68
movi $r75 i37                           ; initialize constant into register
eq $r76 $r32 $r75
jnzi $r76 .70
ji  .71
.70
movi $r78 i37                           ; initialize constant into register
addi $r77 $r15 i352
meq $r77 $r39 $r77 $r78
move $r79 $r77                          ; return value from ASM block with return register r
 jnzi $r79 .72
 jnzi $r77 .72
ji  .71
.71
movi $r80 i39                           ; initialize constant into register
eq $r81 $r32 $r80
jnzi $r81 .73
ji  .74
.73
movi $r83 i39                           ; initialize constant into register
addi $r82 $r15 i56
meq $r82 $r39 $r82 $r83
move $r84 $r82                          ; return value from ASM block with return register r
 jnzi $r84 .75
 jnzi $r82 .75
ji  .74
.74
movi $r85 i40                           ; initialize constant into register
eq $r86 $r32 $r85
jnzi $r86 .76
ji  .77
.76
movi $r88 i40                           ; initialize constant into register
addi $r87 $r15 i292
meq $r87 $r39 $r87 $r88
move $r89 $r87                          ; return value from ASM block with return register r
 jnzi $r89 .78
 jnzi $r87 .78
ji  .77
.77
movi $r90 i41                           ; initialize constant into register
eq $r91 $r32 $r90
jnzi $r91 .79
ji  .80
.79
movi $r93 i41                           ; initialize constant into register
addi $r92 $r15 i413
meq $r92 $r39 $r92 $r93
move $r94 $r92                          ; return value from ASM block with return register r
 jnzi $r94 .81
 jnzi $r92 .81
ji  .80
.80
movi $r95 i49                           ; initialize constant into register
eq $r96 $r32 $r95
jnzi $r96 .82
ji  .83
.82
movi $r98 i49                           ; initialize constant into register
addi $r97 $r15 i95
meq $r97 $r39 $r97 $r98
move $r99 $r97                          ; return value from ASM block with return register r
 jnzi $r99 .84
 jnzi $r97 .84
ji  .83
.83
movi $r100 i69                          ; initialize constant into register
eq $r101 $r32 $r100
jnzi $r101 .85
ji  .86
.85
movi $r103 i69                          ; initialize constant into register
addi $r102 $r15 i178
meq $r102 $r39 $r102 $r103
move $r104 $r102                        ; return value from ASM block with return register r
 jnzi $r104 .87
 jnzi $r102 .87
ji  .86
.86
movi $r105 i123                         ; initialize constant into register
rvrt $r105
.87
addi $r106 $$locbase i176               ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
sw $$locbase $one i22                   ; store word
addi $r107 $r106 i55                    ; get offset to aggregate element
movi $r108 i42                          ; initialize constant into register
sb $r107 $r108 i0                       ; store byte
addi $r109 $$locbase i552               ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
mcpi $r109 $r106 i56                    ; copy memory
addi $r110 $$locbase i552               ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
addi $r111 $$locbase i360               ; get offset to local __ptr slice
move $$arg0 $r110                       ; [call]: pass argument 0
move $$arg1 $r111                       ; [call]: pass argument 1
fncall .2                               ; [call]: call encode_allow_alias_12
 move $r112 $zero                        ; [call]: return unit value
 movi $r112 i0                           ; [call]: return unit value
addi $r113 $$locbase i312               ; get offset to local __ptr slice
mcpi $r113 $r111 i16                    ; copy memory
load $r114 data_NonConfigurable_1       ; load constant from data section
lw $r115 $$locbase i39                  ; load slice pointer for logging data
lw $r116 $$locbase i40                  ; load slice size for logging data
logd $zero $r114 $r115 $r116            ; log slice
load $r117 data_NonConfigurable_2       ; load constant from data section
rvrt $r117
.84
addr $r118 data_NonConfigurable_3       ; get __const_global7's address in data section
addi $r119 $$locbase i160               ; get offset to local __ptr { ptr, u64 }
sw $$locbase $r118 i20                  ; store word
addi $r120 $r119 i8                     ; get offset to aggregate element
movi $r121 i35                          ; initialize constant into register
sw $$locbase $r121 i21                  ; store word
addi $r122 $$locbase i264               ; get offset to local __ptr slice
mcpi $r122 $r119 i16                    ; copy memory
addi $r123 $$locbase i400               ; get offset to local __ptr slice
mcpi $r123 $r122 i16                    ; copy memory
move $$arg0 $r123                       ; [call]: pass argument 0
 move $$arg1 $zero                       ; [call]: pass argument 1
 movi $$arg1 i0                          ; [call]: pass argument 1
fncall .12                              ; [call]: call generic_panic_41
 move $r124 $zero                        ; [call]: return unit value
 move $r125 $zero                        ; return value from ASM block with return register zero
 retd $r125 $zero
 movi $r124 i0                           ; [call]: return unit value
 movi $r125 i0                           ; return value from ASM block with return register zero
 retd $zero $zero
.81
 move $$arg0 $zero                       ; [call]: pass argument 0
 movi $$arg0 i0                          ; [call]: pass argument 0
fncall .16                              ; [call]: call nested_panic_non_inlined_47
 move $r126 $zero                        ; [call]: return unit value
 move $r127 $zero                        ; return value from ASM block with return register zero
 retd $r127 $zero
 movi $r126 i0                           ; [call]: return unit value
 movi $r127 i0                           ; return value from ASM block with return register zero
 retd $zero $zero
.78
 move $$arg0 $zero                       ; [call]: pass argument 0
 movi $$arg0 i0                          ; [call]: pass argument 0
fncall .14                              ; [call]: call generic_panic_with_unit_43
 move $r128 $zero                        ; [call]: return unit value
 move $r129 $zero                        ; return value from ASM block with return register zero
 retd $r129 $zero
 movi $r128 i0                           ; [call]: return unit value
 movi $r129 i0                           ; return value from ASM block with return register zero
 retd $zero $zero
.75
load $r130 data_NonConfigurable_4       ; load constant from data section
rvrt $r130
.72
 move $$arg0 $zero                       ; [call]: pass argument 0
 movi $$arg0 i0                          ; [call]: pass argument 0
fncall .20                              ; [call]: call nested_panic_inlined_same_revert_code_54
 move $r131 $zero                        ; [call]: return unit value
 move $r132 $zero                        ; return value from ASM block with return register zero
 retd $r132 $zero
 movi $r131 i0                           ; [call]: return unit value
 movi $r132 i0                           ; return value from ASM block with return register zero
 retd $zero $zero
.69
addi $r133 $$locbase i104               ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
sw $$locbase $zero i13                  ; store word
addi $r134 $$locbase i496               ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
mcpi $r134 $r133 i56                    ; copy memory
addi $r135 $$locbase i496               ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
addi $r136 $$locbase i344               ; get offset to local __ptr slice
move $$arg0 $r135                       ; [call]: pass argument 0
move $$arg1 $r136                       ; [call]: pass argument 1
fncall .2                               ; [call]: call encode_allow_alias_12
 move $r137 $zero                        ; [call]: return unit value
 movi $r137 i0                           ; [call]: return unit value
addi $r138 $$locbase i296               ; get offset to local __ptr slice
mcpi $r138 $r136 i16                    ; copy memory
load $r139 data_NonConfigurable_1       ; load constant from data section
lw $r140 $$locbase i37                  ; load slice pointer for logging data
lw $r141 $$locbase i38                  ; load slice size for logging data
logd $zero $r139 $r140 $r141            ; log slice
load $r142 data_NonConfigurable_2       ; load constant from data section
rvrt $r142
.66
load $r143 data_NonConfigurable_5       ; load constant from data section
rvrt $r143
.63
addi $r144 $$locbase i48                ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
movi $r145 i2                           ; initialize constant into register
sw $$locbase $r145 i6                   ; store word
addi $r146 $r144 i55                    ; get offset to aggregate element
sb $r146 $one i0                        ; store byte
addi $r147 $$locbase i328               ; get offset to local __ptr slice
move $$arg0 $r144                       ; [call]: pass argument 0
move $$arg1 $r147                       ; [call]: pass argument 1
fncall .2                               ; [call]: call encode_allow_alias_12
 move $r148 $zero                        ; [call]: return unit value
 movi $r148 i0                           ; [call]: return unit value
addi $r149 $$locbase i280               ; get offset to local __ptr slice
mcpi $r149 $r147 i16                    ; copy memory
load $r150 data_NonConfigurable_1       ; load constant from data section
lw $r151 $$locbase i35                  ; load slice pointer for logging data
lw $r152 $$locbase i36                  ; load slice size for logging data
logd $zero $r150 $r151 $r152            ; log slice
load $r153 data_NonConfigurable_6       ; load constant from data section
rvrt $r153
.60
 move $$arg0 $zero                       ; [call]: pass argument 0
 movi $$arg0 i0                          ; [call]: pass argument 0
fncall .16                              ; [call]: call nested_panic_non_inlined_47
 move $r154 $zero                        ; [call]: return unit value
 move $r155 $zero                        ; return value from ASM block with return register zero
 retd $r155 $zero
 movi $r154 i0                           ; [call]: return unit value
 movi $r155 i0                           ; return value from ASM block with return register zero
 retd $zero $zero
.57
 move $$arg0 $zero                       ; [call]: pass argument 0
 movi $$arg0 i0                          ; [call]: pass argument 0
fncall .14                              ; [call]: call generic_panic_with_unit_43
 move $r156 $zero                        ; [call]: return unit value
 move $r157 $zero                        ; return value from ASM block with return register zero
 retd $r157 $zero
 movi $r156 i0                           ; [call]: return unit value
 movi $r157 i0                           ; return value from ASM block with return register zero
 retd $zero $zero
.54
addr $r158 data_NonConfigurable_7       ; get __const_global3's address in data section
addi $r159 $$locbase i32                ; get offset to local __ptr { ptr, u64 }
sw $$locbase $r158 i4                   ; store word
addi $r160 $r159 i8                     ; get offset to aggregate element
movi $r161 i25                          ; initialize constant into register
sw $$locbase $r161 i5                   ; store word
addi $r162 $$locbase i248               ; get offset to local __ptr slice
mcpi $r162 $r159 i16                    ; copy memory
addi $r163 $$locbase i384               ; get offset to local __ptr slice
mcpi $r163 $r162 i16                    ; copy memory
move $$arg0 $r163                       ; [call]: pass argument 0
 move $$arg1 $zero                       ; [call]: pass argument 1
 movi $$arg1 i0                          ; [call]: pass argument 1
fncall .12                              ; [call]: call generic_panic_41
 move $r164 $zero                        ; [call]: return unit value
 move $r165 $zero                        ; return value from ASM block with return register zero
 retd $r165 $zero
 movi $r164 i0                           ; [call]: return unit value
 movi $r165 i0                           ; return value from ASM block with return register zero
 retd $zero $zero
.51
 move $$arg0 $zero                       ; [call]: pass argument 0
 movi $$arg0 i0                          ; [call]: pass argument 0
fncall .20                              ; [call]: call nested_panic_inlined_same_revert_code_54
 move $r166 $zero                        ; [call]: return unit value
 move $r167 $zero                        ; return value from ASM block with return register zero
 retd $r167 $zero
 movi $r166 i0                           ; [call]: return unit value
 movi $r167 i0                           ; return value from ASM block with return register zero
 retd $zero $zero
DIFF------------------------------
.program:
.0                                      ; --- start of function: __entry ---
move $$locbase $sp                      ; save locals base register for function __entry
cfei i608                               ; allocate 608 bytes for locals and 0 slots for call arguments
.48
addr $r1 data_NonConfigurable_0         ; get __const_global's address in data section
addi $r2 $$locbase i16                  ; get offset to local __ptr { ptr, u64 }
sw $$locbase $r1 i2                     ; store word
movi $r4 i454                           ; initialize constant into register
sw $$locbase $r4 i3                     ; store word
addi $r5 $$locbase i232                 ; get offset to local __ptr slice
mcpi $r5 $r2 i16                        ; copy memory
addi $r6 $$locbase i456                 ; get offset to local __ptr slice
mcpi $r6 $r5 i16                        ; copy memory
addi $r7 $$locbase i456                 ; get offset to local __ptr slice
addi $r8 $$locbase i472                 ; get offset to local __ptr slice
mcpi $r8 $r7 i16                        ; copy memory
addi $r9 $$locbase i472                 ; get offset to local __ptr slice
mcpi $$locbase $r9 i16                  ; copy memory
addi $r11 $$locbase i416                ; get offset to local __ptr { ptr, u64 }
mcpi $r11 $$locbase i16                 ; copy memory
addi $r12 $$locbase i416                ; get offset to local __ptr { ptr, u64 }
addi $r13 $$locbase i432                ; get offset to local __ptr { ptr, u64 }
mcpi $r13 $r12 i16                      ; copy memory
lw $r15 $$locbase i54                   ; load word
lw $r24 $fp i73                         ; lw val ptr i0
addi $r27 $$locbase i376                ; get offset to local __ptr { ptr }
sw $$locbase $r24 i47                   ; store word
addi $r28 $$locbase i448                ; get offset to local __ptr { ptr }
mcpi $r28 $r27 i8                       ; copy memory
lw $r30 $$locbase i56                   ; load word
lw $r31 $r30 i0                         ; lw val ptr i0
move $r32 $r31                          ; return value from ASM block with return register val
lw $r33 $$locbase i56                   ; load word
movi $r34 i8                            ; initialize constant into register
add $r35 $r33 $r34
sw $$locbase $r35 i56                   ; store word
addi $r36 $$locbase i448                ; get offset to local __ptr { ptr }
addi $r37 $$locbase i488                ; get offset to local __ptr { ptr }
mcpi $r37 $r36 i8                       ; copy memory
lw $r39 $$locbase i61                   ; load word
movi $r40 i20                           ; initialize constant into register
eq $r41 $r32 $r40
jnzi $r41 .49
ji  .50
.49
movi $r43 i20                           ; initialize constant into register
addi $r42 $r15 i332
meq $r42 $r39 $r42 $r43
jnzi $r42 .51
.50
movi $r45 i22                           ; initialize constant into register
eq $r46 $r32 $r45
jnzi $r46 .52
ji  .53
.52
movi $r48 i22                           ; initialize constant into register
addi $r47 $r15 i247
meq $r47 $r39 $r47 $r48
jnzi $r47 .54
.53
movi $r50 i23                           ; initialize constant into register
eq $r51 $r32 $r50
jnzi $r51 .55
ji  .56
.55
movi $r53 i23                           ; initialize constant into register
addi $r52 $r15 i269
meq $r52 $r39 $r52 $r53
jnzi $r52 .57
.56
movi $r55 i24                           ; initialize constant into register
eq $r56 $r32 $r55
jnzi $r56 .58
ji  .59
.58
movi $r58 i24                           ; initialize constant into register
addi $r57 $r15 i389
meq $r57 $r39 $r57 $r58
jnzi $r57 .60
.59
movi $r60 i25                           ; initialize constant into register
eq $r61 $r32 $r60
jnzi $r61 .61
ji  .62
.61
movi $r63 i25                           ; initialize constant into register
addi $r62 $r15 i31
meq $r62 $r39 $r62 $r63
jnzi $r62 .63
.62
movi $r65 i31                           ; initialize constant into register
eq $r66 $r32 $r65
jnzi $r66 .64
ji  .65
.64
movi $r68 i31                           ; initialize constant into register
addi $r67 $r15 i0
meq $r67 $r39 $r67 $r68
jnzi $r67 .66
.65
movi $r70 i34                           ; initialize constant into register
eq $r71 $r32 $r70
jnzi $r71 .67
ji  .68
.67
movi $r73 i34                           ; initialize constant into register
addi $r72 $r15 i144
meq $r72 $r39 $r72 $r73
jnzi $r72 .69
.68
movi $r75 i37                           ; initialize constant into register
eq $r76 $r32 $r75
jnzi $r76 .70
ji  .71
.70
movi $r78 i37                           ; initialize constant into register
addi $r77 $r15 i352
meq $r77 $r39 $r77 $r78
jnzi $r77 .72
.71
movi $r80 i39                           ; initialize constant into register
eq $r81 $r32 $r80
jnzi $r81 .73
ji  .74
.73
movi $r83 i39                           ; initialize constant into register
addi $r82 $r15 i56
meq $r82 $r39 $r82 $r83
jnzi $r82 .75
.74
movi $r85 i40                           ; initialize constant into register
eq $r86 $r32 $r85
jnzi $r86 .76
ji  .77
.76
movi $r88 i40                           ; initialize constant into register
addi $r87 $r15 i292
meq $r87 $r39 $r87 $r88
jnzi $r87 .78
.77
movi $r90 i41                           ; initialize constant into register
eq $r91 $r32 $r90
jnzi $r91 .79
ji  .80
.79
movi $r93 i41                           ; initialize constant into register
addi $r92 $r15 i413
meq $r92 $r39 $r92 $r93
jnzi $r92 .81
.80
movi $r95 i49                           ; initialize constant into register
eq $r96 $r32 $r95
jnzi $r96 .82
ji  .83
.82
movi $r98 i49                           ; initialize constant into register
addi $r97 $r15 i95
meq $r97 $r39 $r97 $r98
jnzi $r97 .84
.83
movi $r100 i69                          ; initialize constant into register
eq $r101 $r32 $r100
jnzi $r101 .85
ji  .86
.85
movi $r103 i69                          ; initialize constant into register
addi $r102 $r15 i178
meq $r102 $r39 $r102 $r103
jnzi $r102 .87
.86
movi $r105 i123                         ; initialize constant into register
rvrt $r105
.87
addi $r106 $$locbase i176               ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
sw $$locbase $one i22                   ; store word
addi $r107 $r106 i55                    ; get offset to aggregate element
movi $r108 i42                          ; initialize constant into register
sb $r107 $r108 i0                       ; store byte
addi $r109 $$locbase i552               ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
mcpi $r109 $r106 i56                    ; copy memory
addi $r110 $$locbase i552               ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
addi $r111 $$locbase i360               ; get offset to local __ptr slice
move $$arg0 $r110                       ; [call]: pass argument 0
move $$arg1 $r111                       ; [call]: pass argument 1
fncall .2                               ; [call]: call encode_allow_alias_12
addi $r113 $$locbase i312               ; get offset to local __ptr slice
mcpi $r113 $r111 i16                    ; copy memory
load $r114 data_NonConfigurable_1       ; load constant from data section
lw $r115 $$locbase i39                  ; load slice pointer for logging data
lw $r116 $$locbase i40                  ; load slice size for logging data
logd $zero $r114 $r115 $r116            ; log slice
load $r117 data_NonConfigurable_2       ; load constant from data section
rvrt $r117
.84
addr $r118 data_NonConfigurable_3       ; get __const_global7's address in data section
addi $r119 $$locbase i160               ; get offset to local __ptr { ptr, u64 }
sw $$locbase $r118 i20                  ; store word
movi $r121 i35                          ; initialize constant into register
sw $$locbase $r121 i21                  ; store word
addi $r122 $$locbase i264               ; get offset to local __ptr slice
mcpi $r122 $r119 i16                    ; copy memory
addi $r123 $$locbase i400               ; get offset to local __ptr slice
mcpi $r123 $r122 i16                    ; copy memory
move $$arg0 $r123                       ; [call]: pass argument 0
movi $$arg1 i0                          ; [call]: pass argument 1
fncall .12                              ; [call]: call generic_panic_41
retd $zero $zero
.81
movi $$arg0 i0                          ; [call]: pass argument 0
fncall .16                              ; [call]: call nested_panic_non_inlined_47
retd $zero $zero
.78
movi $$arg0 i0                          ; [call]: pass argument 0
fncall .14                              ; [call]: call generic_panic_with_unit_43
retd $zero $zero
.75
load $r130 data_NonConfigurable_4       ; load constant from data section
rvrt $r130
.72
movi $$arg0 i0                          ; [call]: pass argument 0
fncall .20                              ; [call]: call nested_panic_inlined_same_revert_code_54
retd $zero $zero
.69
addi $r133 $$locbase i104               ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
sw $$locbase $zero i13                  ; store word
addi $r134 $$locbase i496               ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
mcpi $r134 $r133 i56                    ; copy memory
addi $r135 $$locbase i496               ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
addi $r136 $$locbase i344               ; get offset to local __ptr slice
move $$arg0 $r135                       ; [call]: pass argument 0
move $$arg1 $r136                       ; [call]: pass argument 1
fncall .2                               ; [call]: call encode_allow_alias_12
addi $r138 $$locbase i296               ; get offset to local __ptr slice
mcpi $r138 $r136 i16                    ; copy memory
load $r139 data_NonConfigurable_1       ; load constant from data section
lw $r140 $$locbase i37                  ; load slice pointer for logging data
lw $r141 $$locbase i38                  ; load slice size for logging data
logd $zero $r139 $r140 $r141            ; log slice
load $r142 data_NonConfigurable_2       ; load constant from data section
rvrt $r142
.66
load $r143 data_NonConfigurable_5       ; load constant from data section
rvrt $r143
.63
addi $r144 $$locbase i48                ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
movi $r145 i2                           ; initialize constant into register
sw $$locbase $r145 i6                   ; store word
addi $r146 $r144 i55                    ; get offset to aggregate element
sb $r146 $one i0                        ; store byte
addi $r147 $$locbase i328               ; get offset to local __ptr slice
move $$arg0 $r144                       ; [call]: pass argument 0
move $$arg1 $r147                       ; [call]: pass argument 1
fncall .2                               ; [call]: call encode_allow_alias_12
addi $r149 $$locbase i280               ; get offset to local __ptr slice
mcpi $r149 $r147 i16                    ; copy memory
load $r150 data_NonConfigurable_1       ; load constant from data section
lw $r151 $$locbase i35                  ; load slice pointer for logging data
lw $r152 $$locbase i36                  ; load slice size for logging data
logd $zero $r150 $r151 $r152            ; log slice
load $r153 data_NonConfigurable_6       ; load constant from data section
rvrt $r153
.60
movi $$arg0 i0                          ; [call]: pass argument 0
fncall .16                              ; [call]: call nested_panic_non_inlined_47
retd $zero $zero
.57
movi $$arg0 i0                          ; [call]: pass argument 0
fncall .14                              ; [call]: call generic_panic_with_unit_43
retd $zero $zero
.54
addr $r158 data_NonConfigurable_7       ; get __const_global3's address in data section
addi $r159 $$locbase i32                ; get offset to local __ptr { ptr, u64 }
sw $$locbase $r158 i4                   ; store word
movi $r161 i25                          ; initialize constant into register
sw $$locbase $r161 i5                   ; store word
addi $r162 $$locbase i248               ; get offset to local __ptr slice
mcpi $r162 $r159 i16                    ; copy memory
addi $r163 $$locbase i384               ; get offset to local __ptr slice
mcpi $r163 $r162 i16                    ; copy memory
move $$arg0 $r163                       ; [call]: pass argument 0
movi $$arg1 i0                          ; [call]: pass argument 1
fncall .12                              ; [call]: call generic_panic_41
retd $zero $zero
.51
movi $$arg0 i0                          ; [call]: pass argument 0
fncall .20                              ; [call]: call nested_panic_inlined_same_revert_code_54
retd $zero $zero
DIFF------------------------------
.program:
.0                                      ; --- start of function: __entry ---
move $$locbase $sp                      ; save locals base register for function __entry
cfei i608                               ; allocate 608 bytes for locals and 0 slots for call arguments
.48
addr $r1 data_NonConfigurable_0         ; get __const_global's address in data section
addi $r2 $$locbase i16                  ; get offset to local __ptr { ptr, u64 }
sw $$locbase $r1 i2                     ; store word
movi $r4 i454                           ; initialize constant into register
sw $$locbase $r4 i3                     ; store word
addi $r5 $$locbase i232                 ; get offset to local __ptr slice
mcpi $r5 $r2 i16                        ; copy memory
addi $r6 $$locbase i456                 ; get offset to local __ptr slice
mcpi $r6 $r5 i16                        ; copy memory
addi $r7 $$locbase i456                 ; get offset to local __ptr slice
addi $r8 $$locbase i472                 ; get offset to local __ptr slice
mcpi $r8 $r7 i16                        ; copy memory
addi $r9 $$locbase i472                 ; get offset to local __ptr slice
mcpi $$locbase $r9 i16                  ; copy memory
addi $r11 $$locbase i416                ; get offset to local __ptr { ptr, u64 }
mcpi $r11 $$locbase i16                 ; copy memory
addi $r12 $$locbase i416                ; get offset to local __ptr { ptr, u64 }
addi $r13 $$locbase i432                ; get offset to local __ptr { ptr, u64 }
mcpi $r13 $r12 i16                      ; copy memory
lw $r15 $$locbase i54                   ; load word
lw $r24 $fp i73                         ; lw val ptr i0
addi $r27 $$locbase i376                ; get offset to local __ptr { ptr }
sw $$locbase $r24 i47                   ; store word
addi $r28 $$locbase i448                ; get offset to local __ptr { ptr }
mcpi $r28 $r27 i8                       ; copy memory
lw $r30 $$locbase i56                   ; load word
lw $r31 $r30 i0                         ; lw val ptr i0
move $r32 $r31                          ; return value from ASM block with return register val
lw $r33 $$locbase i56                   ; load word
movi $r34 i8                            ; initialize constant into register
add $r35 $r33 $r34
sw $$locbase $r35 i56                   ; store word
addi $r36 $$locbase i448                ; get offset to local __ptr { ptr }
addi $r37 $$locbase i488                ; get offset to local __ptr { ptr }
mcpi $r37 $r36 i8                       ; copy memory
lw $r39 $$locbase i61                   ; load word
movi $r40 i20                           ; initialize constant into register
eq $r41 $r32 $r40
jnzi $r41 .49
ji  .50
.49
movi $r43 i20                           ; initialize constant into register
addi $r42 $r15 i332
meq $r42 $r39 $r42 $r43
jnzi $r42 .51
.50
movi $r45 i22                           ; initialize constant into register
eq $r46 $r32 $r45
jnzi $r46 .52
ji  .53
.52
movi $r48 i22                           ; initialize constant into register
addi $r47 $r15 i247
meq $r47 $r39 $r47 $r48
jnzi $r47 .54
.53
movi $r50 i23                           ; initialize constant into register
eq $r51 $r32 $r50
jnzi $r51 .55
ji  .56
.55
movi $r53 i23                           ; initialize constant into register
addi $r52 $r15 i269
meq $r52 $r39 $r52 $r53
jnzi $r52 .57
.56
movi $r55 i24                           ; initialize constant into register
eq $r56 $r32 $r55
jnzi $r56 .58
ji  .59
.58
movi $r58 i24                           ; initialize constant into register
addi $r57 $r15 i389
meq $r57 $r39 $r57 $r58
jnzi $r57 .60
.59
movi $r60 i25                           ; initialize constant into register
eq $r61 $r32 $r60
jnzi $r61 .61
ji  .62
.61
movi $r63 i25                           ; initialize constant into register
addi $r62 $r15 i31
meq $r62 $r39 $r62 $r63
jnzi $r62 .63
.62
movi $r65 i31                           ; initialize constant into register
eq $r66 $r32 $r65
jnzi $r66 .64
ji  .65
.64
movi $r68 i31                           ; initialize constant into register
addi $r67 $r15 i0
meq $r67 $r39 $r67 $r68
jnzi $r67 .66
.65
movi $r70 i34                           ; initialize constant into register
eq $r71 $r32 $r70
jnzi $r71 .67
ji  .68
.67
movi $r73 i34                           ; initialize constant into register
addi $r72 $r15 i144
meq $r72 $r39 $r72 $r73
jnzi $r72 .69
.68
movi $r75 i37                           ; initialize constant into register
eq $r76 $r32 $r75
jnzi $r76 .70
ji  .71
.70
movi $r78 i37                           ; initialize constant into register
addi $r77 $r15 i352
meq $r77 $r39 $r77 $r78
jnzi $r77 .72
.71
movi $r80 i39                           ; initialize constant into register
eq $r81 $r32 $r80
jnzi $r81 .73
ji  .74
.73
movi $r83 i39                           ; initialize constant into register
addi $r82 $r15 i56
meq $r82 $r39 $r82 $r83
jnzi $r82 .75
.74
movi $r85 i40                           ; initialize constant into register
eq $r86 $r32 $r85
jnzi $r86 .76
ji  .77
.76
movi $r88 i40                           ; initialize constant into register
addi $r87 $r15 i292
meq $r87 $r39 $r87 $r88
jnzi $r87 .78
.77
movi $r90 i41                           ; initialize constant into register
eq $r91 $r32 $r90
jnzi $r91 .79
ji  .80
.79
movi $r93 i41                           ; initialize constant into register
addi $r92 $r15 i413
meq $r92 $r39 $r92 $r93
jnzi $r92 .81
.80
movi $r95 i49                           ; initialize constant into register
eq $r96 $r32 $r95
jnzi $r96 .82
ji  .83
.82
movi $r98 i49                           ; initialize constant into register
addi $r97 $r15 i95
meq $r97 $r39 $r97 $r98
jnzi $r97 .84
.83
movi $r100 i69                          ; initialize constant into register
eq $r101 $r32 $r100
jnzi $r101 .85
ji  .86
.85
movi $r103 i69                          ; initialize constant into register
addi $r102 $r15 i178
meq $r102 $r39 $r102 $r103
jnzi $r102 .87
.86
movi $r105 i123                         ; initialize constant into register
rvrt $r105
.87
addi $r106 $$locbase i176               ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
sw $$locbase $one i22                   ; store word
addi $r107 $r106 i55                    ; get offset to aggregate element
movi $r108 i42                          ; initialize constant into register
sb $r107 $r108 i0                       ; store byte
addi $r109 $$locbase i552               ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
mcpi $r109 $r106 i56                    ; copy memory
addi $r110 $$locbase i552               ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
addi $r111 $$locbase i360               ; get offset to local __ptr slice
move $$arg0 $r110                       ; [call]: pass argument 0
move $$arg1 $r111                       ; [call]: pass argument 1
fncall .2                               ; [call]: call encode_allow_alias_12
addi $r113 $$locbase i312               ; get offset to local __ptr slice
mcpi $r113 $r111 i16                    ; copy memory
load $r114 data_NonConfigurable_1       ; load constant from data section
lw $r115 $$locbase i39                  ; load slice pointer for logging data
lw $r116 $$locbase i40                  ; load slice size for logging data
logd $zero $r114 $r115 $r116            ; log slice
load $r117 data_NonConfigurable_2       ; load constant from data section
rvrt $r117
.84
addr $r118 data_NonConfigurable_3       ; get __const_global7's address in data section
addi $r119 $$locbase i160               ; get offset to local __ptr { ptr, u64 }
sw $$locbase $r118 i20                  ; store word
movi $r121 i35                          ; initialize constant into register
sw $$locbase $r121 i21                  ; store word
addi $r122 $$locbase i264               ; get offset to local __ptr slice
mcpi $r122 $r119 i16                    ; copy memory
addi $r123 $$locbase i400               ; get offset to local __ptr slice
mcpi $r123 $r122 i16                    ; copy memory
move $$arg0 $r123                       ; [call]: pass argument 0
movi $$arg1 i0                          ; [call]: pass argument 1
fncall .12                              ; [call]: call generic_panic_41
retd $zero $zero
.81
movi $$arg0 i0                          ; [call]: pass argument 0
fncall .16                              ; [call]: call nested_panic_non_inlined_47
retd $zero $zero
.78
movi $$arg0 i0                          ; [call]: pass argument 0
fncall .14                              ; [call]: call generic_panic_with_unit_43
retd $zero $zero
.75
load $r130 data_NonConfigurable_4       ; load constant from data section
rvrt $r130
.72
movi $$arg0 i0                          ; [call]: pass argument 0
fncall .20                              ; [call]: call nested_panic_inlined_same_revert_code_54
retd $zero $zero
.69
addi $r133 $$locbase i104               ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
sw $$locbase $zero i13                  ; store word
addi $r134 $$locbase i496               ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
mcpi $r134 $r133 i56                    ; copy memory
addi $r135 $$locbase i496               ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
addi $r136 $$locbase i344               ; get offset to local __ptr slice
move $$arg0 $r135                       ; [call]: pass argument 0
move $$arg1 $r136                       ; [call]: pass argument 1
fncall .2                               ; [call]: call encode_allow_alias_12
addi $r138 $$locbase i296               ; get offset to local __ptr slice
mcpi $r138 $r136 i16                    ; copy memory
load $r139 data_NonConfigurable_1       ; load constant from data section
lw $r140 $$locbase i37                  ; load slice pointer for logging data
lw $r141 $$locbase i38                  ; load slice size for logging data
logd $zero $r139 $r140 $r141            ; log slice
load $r142 data_NonConfigurable_2       ; load constant from data section
rvrt $r142
.66
load $r143 data_NonConfigurable_5       ; load constant from data section
rvrt $r143
.63
addi $r144 $$locbase i48                ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
movi $r145 i2                           ; initialize constant into register
sw $$locbase $r145 i6                   ; store word
addi $r146 $r144 i55                    ; get offset to aggregate element
sb $r146 $one i0                        ; store byte
addi $r147 $$locbase i328               ; get offset to local __ptr slice
move $$arg0 $r144                       ; [call]: pass argument 0
move $$arg1 $r147                       ; [call]: pass argument 1
fncall .2                               ; [call]: call encode_allow_alias_12
addi $r149 $$locbase i280               ; get offset to local __ptr slice
mcpi $r149 $r147 i16                    ; copy memory
load $r150 data_NonConfigurable_1       ; load constant from data section
lw $r151 $$locbase i35                  ; load slice pointer for logging data
lw $r152 $$locbase i36                  ; load slice size for logging data
logd $zero $r150 $r151 $r152            ; log slice
load $r153 data_NonConfigurable_6       ; load constant from data section
rvrt $r153
.60
movi $$arg0 i0                          ; [call]: pass argument 0
fncall .16                              ; [call]: call nested_panic_non_inlined_47
retd $zero $zero
.57
movi $$arg0 i0                          ; [call]: pass argument 0
fncall .14                              ; [call]: call generic_panic_with_unit_43
retd $zero $zero
.54
addr $r158 data_NonConfigurable_7       ; get __const_global3's address in data section
addi $r159 $$locbase i32                ; get offset to local __ptr { ptr, u64 }
sw $$locbase $r158 i4                   ; store word
movi $r161 i25                          ; initialize constant into register
sw $$locbase $r161 i5                   ; store word
addi $r162 $$locbase i248               ; get offset to local __ptr slice
mcpi $r162 $r159 i16                    ; copy memory
addi $r163 $$locbase i384               ; get offset to local __ptr slice
mcpi $r163 $r162 i16                    ; copy memory
move $$arg0 $r163                       ; [call]: pass argument 0
movi $$arg1 i0                          ; [call]: pass argument 1
fncall .12                              ; [call]: call generic_panic_41
retd $zero $zero
.51
movi $$arg0 i0                          ; [call]: pass argument 0
fncall .20                              ; [call]: call nested_panic_inlined_same_revert_code_54
retd $zero $zero
DIFF------------------------------
.program:
.0                                      ; --- start of function: __entry ---
move $$locbase $sp                      ; save locals base register for function __entry
cfei i608                               ; allocate 608 bytes for locals and 0 slots for call arguments
.48
addr $r1 data_NonConfigurable_0         ; get __const_global's address in data section
addi $r2 $$locbase i16                  ; get offset to local __ptr { ptr, u64 }
sw $$locbase $r1 i2                     ; store word
movi $r4 i454                           ; initialize constant into register
sw $$locbase $r4 i3                     ; store word
addi $r5 $$locbase i232                 ; get offset to local __ptr slice
mcpi $r5 $r2 i16                        ; copy memory
addi $r6 $$locbase i456                 ; get offset to local __ptr slice
mcpi $r6 $r5 i16                        ; copy memory
addi $r7 $$locbase i456                 ; get offset to local __ptr slice
addi $r8 $$locbase i472                 ; get offset to local __ptr slice
mcpi $r8 $r7 i16                        ; copy memory
addi $r9 $$locbase i472                 ; get offset to local __ptr slice
mcpi $$locbase $r9 i16                  ; copy memory
addi $r11 $$locbase i416                ; get offset to local __ptr { ptr, u64 }
mcpi $r11 $$locbase i16                 ; copy memory
addi $r12 $$locbase i416                ; get offset to local __ptr { ptr, u64 }
addi $r13 $$locbase i432                ; get offset to local __ptr { ptr, u64 }
mcpi $r13 $r12 i16                      ; copy memory
lw $r15 $$locbase i54                   ; load word
lw $r24 $fp i73                         ; lw val ptr i0
addi $r27 $$locbase i376                ; get offset to local __ptr { ptr }
sw $$locbase $r24 i47                   ; store word
addi $r28 $$locbase i448                ; get offset to local __ptr { ptr }
mcpi $r28 $r27 i8                       ; copy memory
lw $r30 $$locbase i56                   ; load word
lw $r31 $r30 i0                         ; lw val ptr i0
move $r32 $r31                          ; return value from ASM block with return register val
lw $r33 $$locbase i56                   ; load word
movi $r34 i8                            ; initialize constant into register
add $r35 $r33 $r34
sw $$locbase $r35 i56                   ; store word
addi $r36 $$locbase i448                ; get offset to local __ptr { ptr }
addi $r37 $$locbase i488                ; get offset to local __ptr { ptr }
mcpi $r37 $r36 i8                       ; copy memory
lw $r39 $$locbase i61                   ; load word
movi $r40 i20                           ; initialize constant into register
eq $r41 $r32 $r40
jnzi $r41 .49
ji  .50
.49
movi $r43 i20                           ; initialize constant into register
addi $r42 $r15 i332
meq $r42 $r39 $r42 $r43
jnzi $r42 .51
.50
movi $r45 i22                           ; initialize constant into register
eq $r46 $r32 $r45
jnzi $r46 .52
ji  .53
.52
movi $r48 i22                           ; initialize constant into register
addi $r47 $r15 i247
meq $r47 $r39 $r47 $r48
jnzi $r47 .54
.53
movi $r50 i23                           ; initialize constant into register
eq $r51 $r32 $r50
jnzi $r51 .55
ji  .56
.55
movi $r53 i23                           ; initialize constant into register
addi $r52 $r15 i269
meq $r52 $r39 $r52 $r53
jnzi $r52 .57
.56
movi $r55 i24                           ; initialize constant into register
eq $r56 $r32 $r55
jnzi $r56 .58
ji  .59
.58
movi $r58 i24                           ; initialize constant into register
addi $r57 $r15 i389
meq $r57 $r39 $r57 $r58
jnzi $r57 .60
.59
movi $r60 i25                           ; initialize constant into register
eq $r61 $r32 $r60
jnzi $r61 .61
ji  .62
.61
movi $r63 i25                           ; initialize constant into register
addi $r62 $r15 i31
meq $r62 $r39 $r62 $r63
jnzi $r62 .63
.62
movi $r65 i31                           ; initialize constant into register
eq $r66 $r32 $r65
jnzi $r66 .64
ji  .65
.64
movi $r68 i31                           ; initialize constant into register
addi $r67 $r15 i0
meq $r67 $r39 $r67 $r68
jnzi $r67 .66
.65
movi $r70 i34                           ; initialize constant into register
eq $r71 $r32 $r70
jnzi $r71 .67
ji  .68
.67
movi $r73 i34                           ; initialize constant into register
addi $r72 $r15 i144
meq $r72 $r39 $r72 $r73
jnzi $r72 .69
.68
movi $r75 i37                           ; initialize constant into register
eq $r76 $r32 $r75
jnzi $r76 .70
ji  .71
.70
movi $r78 i37                           ; initialize constant into register
addi $r77 $r15 i352
meq $r77 $r39 $r77 $r78
jnzi $r77 .72
.71
movi $r80 i39                           ; initialize constant into register
eq $r81 $r32 $r80
jnzi $r81 .73
ji  .74
.73
movi $r83 i39                           ; initialize constant into register
addi $r82 $r15 i56
meq $r82 $r39 $r82 $r83
jnzi $r82 .75
.74
movi $r85 i40                           ; initialize constant into register
eq $r86 $r32 $r85
jnzi $r86 .76
ji  .77
.76
movi $r88 i40                           ; initialize constant into register
addi $r87 $r15 i292
meq $r87 $r39 $r87 $r88
jnzi $r87 .78
.77
movi $r90 i41                           ; initialize constant into register
eq $r91 $r32 $r90
jnzi $r91 .79
ji  .80
.79
movi $r93 i41                           ; initialize constant into register
addi $r92 $r15 i413
meq $r92 $r39 $r92 $r93
jnzi $r92 .81
.80
movi $r95 i49                           ; initialize constant into register
eq $r96 $r32 $r95
jnzi $r96 .82
ji  .83
.82
movi $r98 i49                           ; initialize constant into register
addi $r97 $r15 i95
meq $r97 $r39 $r97 $r98
jnzi $r97 .84
.83
movi $r100 i69                          ; initialize constant into register
eq $r101 $r32 $r100
jnzi $r101 .85
ji  .86
.85
movi $r103 i69                          ; initialize constant into register
addi $r102 $r15 i178
meq $r102 $r39 $r102 $r103
jnzi $r102 .87
.86
movi $r105 i123                         ; initialize constant into register
rvrt $r105
.87
addi $r106 $$locbase i176               ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
sw $$locbase $one i22                   ; store word
addi $r107 $r106 i55                    ; get offset to aggregate element
movi $r108 i42                          ; initialize constant into register
sb $r107 $r108 i0                       ; store byte
addi $r109 $$locbase i552               ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
mcpi $r109 $r106 i56                    ; copy memory
addi $r110 $$locbase i552               ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
addi $r111 $$locbase i360               ; get offset to local __ptr slice
move $$arg0 $r110                       ; [call]: pass argument 0
move $$arg1 $r111                       ; [call]: pass argument 1
fncall .2                               ; [call]: call encode_allow_alias_12
addi $r113 $$locbase i312               ; get offset to local __ptr slice
mcpi $r113 $r111 i16                    ; copy memory
load $r114 data_NonConfigurable_1       ; load constant from data section
lw $r115 $$locbase i39                  ; load slice pointer for logging data
lw $r116 $$locbase i40                  ; load slice size for logging data
logd $zero $r114 $r115 $r116            ; log slice
load $r117 data_NonConfigurable_2       ; load constant from data section
rvrt $r117
.84
addr $r118 data_NonConfigurable_3       ; get __const_global7's address in data section
addi $r119 $$locbase i160               ; get offset to local __ptr { ptr, u64 }
sw $$locbase $r118 i20                  ; store word
movi $r121 i35                          ; initialize constant into register
sw $$locbase $r121 i21                  ; store word
addi $r122 $$locbase i264               ; get offset to local __ptr slice
mcpi $r122 $r119 i16                    ; copy memory
addi $r123 $$locbase i400               ; get offset to local __ptr slice
mcpi $r123 $r122 i16                    ; copy memory
move $$arg0 $r123                       ; [call]: pass argument 0
movi $$arg1 i0                          ; [call]: pass argument 1
fncall .12                              ; [call]: call generic_panic_41
retd $zero $zero
.81
movi $$arg0 i0                          ; [call]: pass argument 0
fncall .16                              ; [call]: call nested_panic_non_inlined_47
retd $zero $zero
.78
movi $$arg0 i0                          ; [call]: pass argument 0
fncall .14                              ; [call]: call generic_panic_with_unit_43
retd $zero $zero
.75
load $r130 data_NonConfigurable_4       ; load constant from data section
rvrt $r130
.72
movi $$arg0 i0                          ; [call]: pass argument 0
fncall .20                              ; [call]: call nested_panic_inlined_same_revert_code_54
retd $zero $zero
.69
addi $r133 $$locbase i104               ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
sw $$locbase $zero i13                  ; store word
addi $r134 $$locbase i496               ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
mcpi $r134 $r133 i56                    ; copy memory
addi $r135 $$locbase i496               ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
addi $r136 $$locbase i344               ; get offset to local __ptr slice
move $$arg0 $r135                       ; [call]: pass argument 0
move $$arg1 $r136                       ; [call]: pass argument 1
fncall .2                               ; [call]: call encode_allow_alias_12
addi $r138 $$locbase i296               ; get offset to local __ptr slice
mcpi $r138 $r136 i16                    ; copy memory
load $r139 data_NonConfigurable_1       ; load constant from data section
lw $r140 $$locbase i37                  ; load slice pointer for logging data
lw $r141 $$locbase i38                  ; load slice size for logging data
logd $zero $r139 $r140 $r141            ; log slice
load $r142 data_NonConfigurable_2       ; load constant from data section
rvrt $r142
.66
load $r143 data_NonConfigurable_5       ; load constant from data section
rvrt $r143
.63
addi $r144 $$locbase i48                ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
movi $r145 i2                           ; initialize constant into register
sw $$locbase $r145 i6                   ; store word
addi $r146 $r144 i55                    ; get offset to aggregate element
sb $r146 $one i0                        ; store byte
addi $r147 $$locbase i328               ; get offset to local __ptr slice
move $$arg0 $r144                       ; [call]: pass argument 0
move $$arg1 $r147                       ; [call]: pass argument 1
fncall .2                               ; [call]: call encode_allow_alias_12
addi $r149 $$locbase i280               ; get offset to local __ptr slice
mcpi $r149 $r147 i16                    ; copy memory
load $r150 data_NonConfigurable_1       ; load constant from data section
lw $r151 $$locbase i35                  ; load slice pointer for logging data
lw $r152 $$locbase i36                  ; load slice size for logging data
logd $zero $r150 $r151 $r152            ; log slice
load $r153 data_NonConfigurable_6       ; load constant from data section
rvrt $r153
.60
movi $$arg0 i0                          ; [call]: pass argument 0
fncall .16                              ; [call]: call nested_panic_non_inlined_47
retd $zero $zero
.57
movi $$arg0 i0                          ; [call]: pass argument 0
fncall .14                              ; [call]: call generic_panic_with_unit_43
retd $zero $zero
.54
addr $r158 data_NonConfigurable_7       ; get __const_global3's address in data section
addi $r159 $$locbase i32                ; get offset to local __ptr { ptr, u64 }
sw $$locbase $r158 i4                   ; store word
movi $r161 i25                          ; initialize constant into register
sw $$locbase $r161 i5                   ; store word
addi $r162 $$locbase i248               ; get offset to local __ptr slice
mcpi $r162 $r159 i16                    ; copy memory
addi $r163 $$locbase i384               ; get offset to local __ptr slice
mcpi $r163 $r162 i16                    ; copy memory
move $$arg0 $r163                       ; [call]: pass argument 0
movi $$arg1 i0                          ; [call]: pass argument 1
fncall .12                              ; [call]: call generic_panic_41
retd $zero $zero
.51
movi $$arg0 i0                          ; [call]: pass argument 0
fncall .20                              ; [call]: call nested_panic_inlined_same_revert_code_54
retd $zero $zero
DIFF------------------------------
.program:
.22                                     ; --- start of function: test_panicking_in_contract_self_impl ---
move $$locbase $sp                      ; save locals base register for function test_panicking_in_contract_self_impl
cfei i64                                ; allocate 64 bytes for locals and 0 slots for call arguments
.134
addr $r610 data_NonConfigurable_23      ; get panicking_contract::CONTRACT_ID's address in data section
addr $r611 data_NonConfigurable_24      ; get __const_global8's address in data section
sw $$locbase $r611 i0                   ; store word
addi $r612 $$locbase i8                 ; get offset to aggregate element
movi $r613 i39                          ; initialize constant into register
sw $$locbase $r613 i1                   ; store word
addi $r614 $$locbase i16                ; get offset to local __ptr slice
mcpi $r614 $$locbase i16                ; copy memory
addi $r615 $$locbase i32                ; get offset to local __ptr b256
mcpi $r615 $r610 i32                    ; copy memory
addi $r616 $$locbase i16                ; get offset to local __ptr slice
load $r617 data_NonConfigurable_22      ; get local constant
move $$arg0 $r615                       ; [call]: pass argument 0
move $$arg1 $r616                       ; [call]: pass argument 1
 move $$arg2 $zero                       ; [call]: pass argument 2
 move $$arg3 $zero                       ; [call]: pass argument 3
 movi $$arg2 i0                          ; [call]: pass argument 2
 movi $$arg3 i0                          ; [call]: pass argument 3
move $$arg4 $r617                       ; [call]: pass argument 4
load $r618 data_NonConfigurable_25      ; load constant from data section
move $$arg5 $r618                       ; [call]: pass argument 5
fncall .24                              ; [call]: call contract_call_63
 move $r619 $zero                        ; [call]: return unit value
 movi $r619 i0                           ; [call]: return unit value
ret $zero                               ; return unit as zero
DIFF------------------------------
.program:
.22                                     ; --- start of function: test_panicking_in_contract_self_impl ---
move $$locbase $sp                      ; save locals base register for function test_panicking_in_contract_self_impl
cfei i64                                ; allocate 64 bytes for locals and 0 slots for call arguments
.134
addr $r610 data_NonConfigurable_23      ; get panicking_contract::CONTRACT_ID's address in data section
addr $r611 data_NonConfigurable_24      ; get __const_global8's address in data section
sw $$locbase $r611 i0                   ; store word
movi $r613 i39                          ; initialize constant into register
sw $$locbase $r613 i1                   ; store word
addi $r614 $$locbase i16                ; get offset to local __ptr slice
mcpi $r614 $$locbase i16                ; copy memory
addi $r615 $$locbase i32                ; get offset to local __ptr b256
mcpi $r615 $r610 i32                    ; copy memory
addi $r616 $$locbase i16                ; get offset to local __ptr slice
load $r617 data_NonConfigurable_22      ; get local constant
move $$arg0 $r615                       ; [call]: pass argument 0
move $$arg1 $r616                       ; [call]: pass argument 1
movi $$arg2 i0                          ; [call]: pass argument 2
movi $$arg3 i0                          ; [call]: pass argument 3
move $$arg4 $r617                       ; [call]: pass argument 4
load $r618 data_NonConfigurable_25      ; load constant from data section
move $$arg5 $r618                       ; [call]: pass argument 5
fncall .24                              ; [call]: call contract_call_63
ret $zero                               ; return unit as zero
DIFF------------------------------
.program:
.22                                     ; --- start of function: test_panicking_in_contract_self_impl ---
move $$locbase $sp                      ; save locals base register for function test_panicking_in_contract_self_impl
cfei i64                                ; allocate 64 bytes for locals and 0 slots for call arguments
.134
addr $r610 data_NonConfigurable_23      ; get panicking_contract::CONTRACT_ID's address in data section
addr $r611 data_NonConfigurable_24      ; get __const_global8's address in data section
sw $$locbase $r611 i0                   ; store word
movi $r613 i39                          ; initialize constant into register
sw $$locbase $r613 i1                   ; store word
addi $r614 $$locbase i16                ; get offset to local __ptr slice
mcpi $r614 $$locbase i16                ; copy memory
addi $r615 $$locbase i32                ; get offset to local __ptr b256
mcpi $r615 $r610 i32                    ; copy memory
addi $r616 $$locbase i16                ; get offset to local __ptr slice
load $r617 data_NonConfigurable_22      ; get local constant
move $$arg0 $r615                       ; [call]: pass argument 0
move $$arg1 $r616                       ; [call]: pass argument 1
movi $$arg2 i0                          ; [call]: pass argument 2
movi $$arg3 i0                          ; [call]: pass argument 3
move $$arg4 $r617                       ; [call]: pass argument 4
load $r618 data_NonConfigurable_25      ; load constant from data section
move $$arg5 $r618                       ; [call]: pass argument 5
fncall .24                              ; [call]: call contract_call_63
ret $zero                               ; return unit as zero
DIFF------------------------------
.program:
.22                                     ; --- start of function: test_panicking_in_contract_self_impl ---
move $$locbase $sp                      ; save locals base register for function test_panicking_in_contract_self_impl
cfei i64                                ; allocate 64 bytes for locals and 0 slots for call arguments
.134
addr $r610 data_NonConfigurable_23      ; get panicking_contract::CONTRACT_ID's address in data section
addr $r611 data_NonConfigurable_24      ; get __const_global8's address in data section
sw $$locbase $r611 i0                   ; store word
movi $r613 i39                          ; initialize constant into register
sw $$locbase $r613 i1                   ; store word
addi $r614 $$locbase i16                ; get offset to local __ptr slice
mcpi $r614 $$locbase i16                ; copy memory
addi $r615 $$locbase i32                ; get offset to local __ptr b256
mcpi $r615 $r610 i32                    ; copy memory
addi $r616 $$locbase i16                ; get offset to local __ptr slice
load $r617 data_NonConfigurable_22      ; get local constant
move $$arg0 $r615                       ; [call]: pass argument 0
move $$arg1 $r616                       ; [call]: pass argument 1
movi $$arg2 i0                          ; [call]: pass argument 2
movi $$arg3 i0                          ; [call]: pass argument 3
move $$arg4 $r617                       ; [call]: pass argument 4
load $r618 data_NonConfigurable_25      ; load constant from data section
move $$arg5 $r618                       ; [call]: pass argument 5
fncall .24                              ; [call]: call contract_call_63
ret $zero                               ; return unit as zero
DIFF------------------------------
.program:
.26                                     ; --- start of function: test_directly_panicking_method ---
move $$locbase $sp                      ; save locals base register for function test_directly_panicking_method
cfei i64                                ; allocate 64 bytes for locals and 0 slots for call arguments
.136
addr $r663 data_NonConfigurable_23      ; get panicking_contract::CONTRACT_ID's address in data section
addr $r664 data_NonConfigurable_26      ; get __const_global9's address in data section
sw $$locbase $r664 i0                   ; store word
addi $r665 $$locbase i8                 ; get offset to aggregate element
movi $r666 i33                          ; initialize constant into register
sw $$locbase $r666 i1                   ; store word
addi $r667 $$locbase i16                ; get offset to local __ptr slice
mcpi $r667 $$locbase i16                ; copy memory
addi $r668 $$locbase i32                ; get offset to local __ptr b256
mcpi $r668 $r663 i32                    ; copy memory
addi $r669 $$locbase i16                ; get offset to local __ptr slice
load $r670 data_NonConfigurable_22      ; get local constant
move $$arg0 $r668                       ; [call]: pass argument 0
move $$arg1 $r669                       ; [call]: pass argument 1
 move $$arg2 $zero                       ; [call]: pass argument 2
 move $$arg3 $zero                       ; [call]: pass argument 3
 movi $$arg2 i0                          ; [call]: pass argument 2
 movi $$arg3 i0                          ; [call]: pass argument 3
move $$arg4 $r670                       ; [call]: pass argument 4
load $r671 data_NonConfigurable_25      ; load constant from data section
move $$arg5 $r671                       ; [call]: pass argument 5
fncall .24                              ; [call]: call contract_call_63
 move $r672 $zero                        ; [call]: return unit value
 movi $r672 i0                           ; [call]: return unit value
ret $zero                               ; return unit as zero
DIFF------------------------------
.program:
.26                                     ; --- start of function: test_directly_panicking_method ---
move $$locbase $sp                      ; save locals base register for function test_directly_panicking_method
cfei i64                                ; allocate 64 bytes for locals and 0 slots for call arguments
.136
addr $r663 data_NonConfigurable_23      ; get panicking_contract::CONTRACT_ID's address in data section
addr $r664 data_NonConfigurable_26      ; get __const_global9's address in data section
sw $$locbase $r664 i0                   ; store word
movi $r666 i33                          ; initialize constant into register
sw $$locbase $r666 i1                   ; store word
addi $r667 $$locbase i16                ; get offset to local __ptr slice
mcpi $r667 $$locbase i16                ; copy memory
addi $r668 $$locbase i32                ; get offset to local __ptr b256
mcpi $r668 $r663 i32                    ; copy memory
addi $r669 $$locbase i16                ; get offset to local __ptr slice
load $r670 data_NonConfigurable_22      ; get local constant
move $$arg0 $r668                       ; [call]: pass argument 0
move $$arg1 $r669                       ; [call]: pass argument 1
movi $$arg2 i0                          ; [call]: pass argument 2
movi $$arg3 i0                          ; [call]: pass argument 3
move $$arg4 $r670                       ; [call]: pass argument 4
load $r671 data_NonConfigurable_25      ; load constant from data section
move $$arg5 $r671                       ; [call]: pass argument 5
fncall .24                              ; [call]: call contract_call_63
ret $zero                               ; return unit as zero
DIFF------------------------------
.program:
.26                                     ; --- start of function: test_directly_panicking_method ---
move $$locbase $sp                      ; save locals base register for function test_directly_panicking_method
cfei i64                                ; allocate 64 bytes for locals and 0 slots for call arguments
.136
addr $r663 data_NonConfigurable_23      ; get panicking_contract::CONTRACT_ID's address in data section
addr $r664 data_NonConfigurable_26      ; get __const_global9's address in data section
sw $$locbase $r664 i0                   ; store word
movi $r666 i33                          ; initialize constant into register
sw $$locbase $r666 i1                   ; store word
addi $r667 $$locbase i16                ; get offset to local __ptr slice
mcpi $r667 $$locbase i16                ; copy memory
addi $r668 $$locbase i32                ; get offset to local __ptr b256
mcpi $r668 $r663 i32                    ; copy memory
addi $r669 $$locbase i16                ; get offset to local __ptr slice
load $r670 data_NonConfigurable_22      ; get local constant
move $$arg0 $r668                       ; [call]: pass argument 0
move $$arg1 $r669                       ; [call]: pass argument 1
movi $$arg2 i0                          ; [call]: pass argument 2
movi $$arg3 i0                          ; [call]: pass argument 3
move $$arg4 $r670                       ; [call]: pass argument 4
load $r671 data_NonConfigurable_25      ; load constant from data section
move $$arg5 $r671                       ; [call]: pass argument 5
fncall .24                              ; [call]: call contract_call_63
ret $zero                               ; return unit as zero
DIFF------------------------------
.program:
.26                                     ; --- start of function: test_directly_panicking_method ---
move $$locbase $sp                      ; save locals base register for function test_directly_panicking_method
cfei i64                                ; allocate 64 bytes for locals and 0 slots for call arguments
.136
addr $r663 data_NonConfigurable_23      ; get panicking_contract::CONTRACT_ID's address in data section
addr $r664 data_NonConfigurable_26      ; get __const_global9's address in data section
sw $$locbase $r664 i0                   ; store word
movi $r666 i33                          ; initialize constant into register
sw $$locbase $r666 i1                   ; store word
addi $r667 $$locbase i16                ; get offset to local __ptr slice
mcpi $r667 $$locbase i16                ; copy memory
addi $r668 $$locbase i32                ; get offset to local __ptr b256
mcpi $r668 $r663 i32                    ; copy memory
addi $r669 $$locbase i16                ; get offset to local __ptr slice
load $r670 data_NonConfigurable_22      ; get local constant
move $$arg0 $r668                       ; [call]: pass argument 0
move $$arg1 $r669                       ; [call]: pass argument 1
movi $$arg2 i0                          ; [call]: pass argument 2
movi $$arg3 i0                          ; [call]: pass argument 3
move $$arg4 $r670                       ; [call]: pass argument 4
load $r671 data_NonConfigurable_25      ; load constant from data section
move $$arg5 $r671                       ; [call]: pass argument 5
fncall .24                              ; [call]: call contract_call_63
ret $zero                               ; return unit as zero
DIFF------------------------------
.program:
.28                                     ; --- start of function: test_nested_panic_inlined ---
move $$locbase $sp                      ; save locals base register for function test_nested_panic_inlined
cfei i64                                ; allocate 64 bytes for locals and 0 slots for call arguments
.137
addr $r674 data_NonConfigurable_23      ; get panicking_contract::CONTRACT_ID's address in data section
addr $r675 data_NonConfigurable_27      ; get __const_global10's address in data section
sw $$locbase $r675 i0                   ; store word
addi $r676 $$locbase i8                 ; get offset to aggregate element
movi $r677 i28                          ; initialize constant into register
sw $$locbase $r677 i1                   ; store word
addi $r678 $$locbase i16                ; get offset to local __ptr slice
mcpi $r678 $$locbase i16                ; copy memory
addi $r679 $$locbase i32                ; get offset to local __ptr b256
mcpi $r679 $r674 i32                    ; copy memory
addi $r680 $$locbase i16                ; get offset to local __ptr slice
load $r681 data_NonConfigurable_22      ; get local constant
move $$arg0 $r679                       ; [call]: pass argument 0
move $$arg1 $r680                       ; [call]: pass argument 1
 move $$arg2 $zero                       ; [call]: pass argument 2
 move $$arg3 $zero                       ; [call]: pass argument 3
 movi $$arg2 i0                          ; [call]: pass argument 2
 movi $$arg3 i0                          ; [call]: pass argument 3
move $$arg4 $r681                       ; [call]: pass argument 4
load $r682 data_NonConfigurable_25      ; load constant from data section
move $$arg5 $r682                       ; [call]: pass argument 5
fncall .24                              ; [call]: call contract_call_63
 move $r683 $zero                        ; [call]: return unit value
 movi $r683 i0                           ; [call]: return unit value
ret $zero                               ; return unit as zero
DIFF------------------------------
.program:
.28                                     ; --- start of function: test_nested_panic_inlined ---
move $$locbase $sp                      ; save locals base register for function test_nested_panic_inlined
cfei i64                                ; allocate 64 bytes for locals and 0 slots for call arguments
.137
addr $r674 data_NonConfigurable_23      ; get panicking_contract::CONTRACT_ID's address in data section
addr $r675 data_NonConfigurable_27      ; get __const_global10's address in data section
sw $$locbase $r675 i0                   ; store word
movi $r677 i28                          ; initialize constant into register
sw $$locbase $r677 i1                   ; store word
addi $r678 $$locbase i16                ; get offset to local __ptr slice
mcpi $r678 $$locbase i16                ; copy memory
addi $r679 $$locbase i32                ; get offset to local __ptr b256
mcpi $r679 $r674 i32                    ; copy memory
addi $r680 $$locbase i16                ; get offset to local __ptr slice
load $r681 data_NonConfigurable_22      ; get local constant
move $$arg0 $r679                       ; [call]: pass argument 0
move $$arg1 $r680                       ; [call]: pass argument 1
movi $$arg2 i0                          ; [call]: pass argument 2
movi $$arg3 i0                          ; [call]: pass argument 3
move $$arg4 $r681                       ; [call]: pass argument 4
load $r682 data_NonConfigurable_25      ; load constant from data section
move $$arg5 $r682                       ; [call]: pass argument 5
fncall .24                              ; [call]: call contract_call_63
ret $zero                               ; return unit as zero
DIFF------------------------------
.program:
.28                                     ; --- start of function: test_nested_panic_inlined ---
move $$locbase $sp                      ; save locals base register for function test_nested_panic_inlined
cfei i64                                ; allocate 64 bytes for locals and 0 slots for call arguments
.137
addr $r674 data_NonConfigurable_23      ; get panicking_contract::CONTRACT_ID's address in data section
addr $r675 data_NonConfigurable_27      ; get __const_global10's address in data section
sw $$locbase $r675 i0                   ; store word
movi $r677 i28                          ; initialize constant into register
sw $$locbase $r677 i1                   ; store word
addi $r678 $$locbase i16                ; get offset to local __ptr slice
mcpi $r678 $$locbase i16                ; copy memory
addi $r679 $$locbase i32                ; get offset to local __ptr b256
mcpi $r679 $r674 i32                    ; copy memory
addi $r680 $$locbase i16                ; get offset to local __ptr slice
load $r681 data_NonConfigurable_22      ; get local constant
move $$arg0 $r679                       ; [call]: pass argument 0
move $$arg1 $r680                       ; [call]: pass argument 1
movi $$arg2 i0                          ; [call]: pass argument 2
movi $$arg3 i0                          ; [call]: pass argument 3
move $$arg4 $r681                       ; [call]: pass argument 4
load $r682 data_NonConfigurable_25      ; load constant from data section
move $$arg5 $r682                       ; [call]: pass argument 5
fncall .24                              ; [call]: call contract_call_63
ret $zero                               ; return unit as zero
DIFF------------------------------
.program:
.28                                     ; --- start of function: test_nested_panic_inlined ---
move $$locbase $sp                      ; save locals base register for function test_nested_panic_inlined
cfei i64                                ; allocate 64 bytes for locals and 0 slots for call arguments
.137
addr $r674 data_NonConfigurable_23      ; get panicking_contract::CONTRACT_ID's address in data section
addr $r675 data_NonConfigurable_27      ; get __const_global10's address in data section
sw $$locbase $r675 i0                   ; store word
movi $r677 i28                          ; initialize constant into register
sw $$locbase $r677 i1                   ; store word
addi $r678 $$locbase i16                ; get offset to local __ptr slice
mcpi $r678 $$locbase i16                ; copy memory
addi $r679 $$locbase i32                ; get offset to local __ptr b256
mcpi $r679 $r674 i32                    ; copy memory
addi $r680 $$locbase i16                ; get offset to local __ptr slice
load $r681 data_NonConfigurable_22      ; get local constant
move $$arg0 $r679                       ; [call]: pass argument 0
move $$arg1 $r680                       ; [call]: pass argument 1
movi $$arg2 i0                          ; [call]: pass argument 2
movi $$arg3 i0                          ; [call]: pass argument 3
move $$arg4 $r681                       ; [call]: pass argument 4
load $r682 data_NonConfigurable_25      ; load constant from data section
move $$arg5 $r682                       ; [call]: pass argument 5
fncall .24                              ; [call]: call contract_call_63
ret $zero                               ; return unit as zero
DIFF------------------------------
.program:
.30                                     ; --- start of function: test_nested_panic_inlined_same_revert_code ---
move $$locbase $sp                      ; save locals base register for function test_nested_panic_inlined_same_revert_code
cfei i64                                ; allocate 64 bytes for locals and 0 slots for call arguments
.138
addr $r685 data_NonConfigurable_23      ; get panicking_contract::CONTRACT_ID's address in data section
addr $r686 data_NonConfigurable_28      ; get __const_global11's address in data section
sw $$locbase $r686 i0                   ; store word
addi $r687 $$locbase i8                 ; get offset to aggregate element
movi $r688 i28                          ; initialize constant into register
sw $$locbase $r688 i1                   ; store word
addi $r689 $$locbase i16                ; get offset to local __ptr slice
mcpi $r689 $$locbase i16                ; copy memory
addi $r690 $$locbase i32                ; get offset to local __ptr b256
mcpi $r690 $r685 i32                    ; copy memory
addi $r691 $$locbase i16                ; get offset to local __ptr slice
load $r692 data_NonConfigurable_22      ; get local constant
move $$arg0 $r690                       ; [call]: pass argument 0
move $$arg1 $r691                       ; [call]: pass argument 1
 move $$arg2 $zero                       ; [call]: pass argument 2
 move $$arg3 $zero                       ; [call]: pass argument 3
 movi $$arg2 i0                          ; [call]: pass argument 2
 movi $$arg3 i0                          ; [call]: pass argument 3
move $$arg4 $r692                       ; [call]: pass argument 4
load $r693 data_NonConfigurable_25      ; load constant from data section
move $$arg5 $r693                       ; [call]: pass argument 5
fncall .24                              ; [call]: call contract_call_63
 move $r694 $zero                        ; [call]: return unit value
 movi $r694 i0                           ; [call]: return unit value
ret $zero                               ; return unit as zero
DIFF------------------------------
.program:
.30                                     ; --- start of function: test_nested_panic_inlined_same_revert_code ---
move $$locbase $sp                      ; save locals base register for function test_nested_panic_inlined_same_revert_code
cfei i64                                ; allocate 64 bytes for locals and 0 slots for call arguments
.138
addr $r685 data_NonConfigurable_23      ; get panicking_contract::CONTRACT_ID's address in data section
addr $r686 data_NonConfigurable_28      ; get __const_global11's address in data section
sw $$locbase $r686 i0                   ; store word
movi $r688 i28                          ; initialize constant into register
sw $$locbase $r688 i1                   ; store word
addi $r689 $$locbase i16                ; get offset to local __ptr slice
mcpi $r689 $$locbase i16                ; copy memory
addi $r690 $$locbase i32                ; get offset to local __ptr b256
mcpi $r690 $r685 i32                    ; copy memory
addi $r691 $$locbase i16                ; get offset to local __ptr slice
load $r692 data_NonConfigurable_22      ; get local constant
move $$arg0 $r690                       ; [call]: pass argument 0
move $$arg1 $r691                       ; [call]: pass argument 1
movi $$arg2 i0                          ; [call]: pass argument 2
movi $$arg3 i0                          ; [call]: pass argument 3
move $$arg4 $r692                       ; [call]: pass argument 4
load $r693 data_NonConfigurable_25      ; load constant from data section
move $$arg5 $r693                       ; [call]: pass argument 5
fncall .24                              ; [call]: call contract_call_63
ret $zero                               ; return unit as zero
DIFF------------------------------
.program:
.30                                     ; --- start of function: test_nested_panic_inlined_same_revert_code ---
move $$locbase $sp                      ; save locals base register for function test_nested_panic_inlined_same_revert_code
cfei i64                                ; allocate 64 bytes for locals and 0 slots for call arguments
.138
addr $r685 data_NonConfigurable_23      ; get panicking_contract::CONTRACT_ID's address in data section
addr $r686 data_NonConfigurable_28      ; get __const_global11's address in data section
sw $$locbase $r686 i0                   ; store word
movi $r688 i28                          ; initialize constant into register
sw $$locbase $r688 i1                   ; store word
addi $r689 $$locbase i16                ; get offset to local __ptr slice
mcpi $r689 $$locbase i16                ; copy memory
addi $r690 $$locbase i32                ; get offset to local __ptr b256
mcpi $r690 $r685 i32                    ; copy memory
addi $r691 $$locbase i16                ; get offset to local __ptr slice
load $r692 data_NonConfigurable_22      ; get local constant
move $$arg0 $r690                       ; [call]: pass argument 0
move $$arg1 $r691                       ; [call]: pass argument 1
movi $$arg2 i0                          ; [call]: pass argument 2
movi $$arg3 i0                          ; [call]: pass argument 3
move $$arg4 $r692                       ; [call]: pass argument 4
load $r693 data_NonConfigurable_25      ; load constant from data section
move $$arg5 $r693                       ; [call]: pass argument 5
fncall .24                              ; [call]: call contract_call_63
ret $zero                               ; return unit as zero
DIFF------------------------------
.program:
.30                                     ; --- start of function: test_nested_panic_inlined_same_revert_code ---
move $$locbase $sp                      ; save locals base register for function test_nested_panic_inlined_same_revert_code
cfei i64                                ; allocate 64 bytes for locals and 0 slots for call arguments
.138
addr $r685 data_NonConfigurable_23      ; get panicking_contract::CONTRACT_ID's address in data section
addr $r686 data_NonConfigurable_28      ; get __const_global11's address in data section
sw $$locbase $r686 i0                   ; store word
movi $r688 i28                          ; initialize constant into register
sw $$locbase $r688 i1                   ; store word
addi $r689 $$locbase i16                ; get offset to local __ptr slice
mcpi $r689 $$locbase i16                ; copy memory
addi $r690 $$locbase i32                ; get offset to local __ptr b256
mcpi $r690 $r685 i32                    ; copy memory
addi $r691 $$locbase i16                ; get offset to local __ptr slice
load $r692 data_NonConfigurable_22      ; get local constant
move $$arg0 $r690                       ; [call]: pass argument 0
move $$arg1 $r691                       ; [call]: pass argument 1
movi $$arg2 i0                          ; [call]: pass argument 2
movi $$arg3 i0                          ; [call]: pass argument 3
move $$arg4 $r692                       ; [call]: pass argument 4
load $r693 data_NonConfigurable_25      ; load constant from data section
move $$arg5 $r693                       ; [call]: pass argument 5
fncall .24                              ; [call]: call contract_call_63
ret $zero                               ; return unit as zero
DIFF------------------------------
.program:
.32                                     ; --- start of function: test_nested_panic_non_inlined ---
move $$locbase $sp                      ; save locals base register for function test_nested_panic_non_inlined
cfei i64                                ; allocate 64 bytes for locals and 0 slots for call arguments
.139
addr $r696 data_NonConfigurable_23      ; get panicking_contract::CONTRACT_ID's address in data section
addr $r697 data_NonConfigurable_29      ; get __const_global12's address in data section
sw $$locbase $r697 i0                   ; store word
addi $r698 $$locbase i8                 ; get offset to aggregate element
movi $r699 i32                          ; initialize constant into register
sw $$locbase $r699 i1                   ; store word
addi $r700 $$locbase i16                ; get offset to local __ptr slice
mcpi $r700 $$locbase i16                ; copy memory
addi $r701 $$locbase i32                ; get offset to local __ptr b256
mcpi $r701 $r696 i32                    ; copy memory
addi $r702 $$locbase i16                ; get offset to local __ptr slice
load $r703 data_NonConfigurable_22      ; get local constant
move $$arg0 $r701                       ; [call]: pass argument 0
move $$arg1 $r702                       ; [call]: pass argument 1
 move $$arg2 $zero                       ; [call]: pass argument 2
 move $$arg3 $zero                       ; [call]: pass argument 3
 movi $$arg2 i0                          ; [call]: pass argument 2
 movi $$arg3 i0                          ; [call]: pass argument 3
move $$arg4 $r703                       ; [call]: pass argument 4
load $r704 data_NonConfigurable_25      ; load constant from data section
move $$arg5 $r704                       ; [call]: pass argument 5
fncall .24                              ; [call]: call contract_call_63
 move $r705 $zero                        ; [call]: return unit value
 movi $r705 i0                           ; [call]: return unit value
ret $zero                               ; return unit as zero
DIFF------------------------------
.program:
.32                                     ; --- start of function: test_nested_panic_non_inlined ---
move $$locbase $sp                      ; save locals base register for function test_nested_panic_non_inlined
cfei i64                                ; allocate 64 bytes for locals and 0 slots for call arguments
.139
addr $r696 data_NonConfigurable_23      ; get panicking_contract::CONTRACT_ID's address in data section
addr $r697 data_NonConfigurable_29      ; get __const_global12's address in data section
sw $$locbase $r697 i0                   ; store word
movi $r699 i32                          ; initialize constant into register
sw $$locbase $r699 i1                   ; store word
addi $r700 $$locbase i16                ; get offset to local __ptr slice
mcpi $r700 $$locbase i16                ; copy memory
addi $r701 $$locbase i32                ; get offset to local __ptr b256
mcpi $r701 $r696 i32                    ; copy memory
addi $r702 $$locbase i16                ; get offset to local __ptr slice
load $r703 data_NonConfigurable_22      ; get local constant
move $$arg0 $r701                       ; [call]: pass argument 0
move $$arg1 $r702                       ; [call]: pass argument 1
movi $$arg2 i0                          ; [call]: pass argument 2
movi $$arg3 i0                          ; [call]: pass argument 3
move $$arg4 $r703                       ; [call]: pass argument 4
load $r704 data_NonConfigurable_25      ; load constant from data section
move $$arg5 $r704                       ; [call]: pass argument 5
fncall .24                              ; [call]: call contract_call_63
ret $zero                               ; return unit as zero
DIFF------------------------------
.program:
.32                                     ; --- start of function: test_nested_panic_non_inlined ---
move $$locbase $sp                      ; save locals base register for function test_nested_panic_non_inlined
cfei i64                                ; allocate 64 bytes for locals and 0 slots for call arguments
.139
addr $r696 data_NonConfigurable_23      ; get panicking_contract::CONTRACT_ID's address in data section
addr $r697 data_NonConfigurable_29      ; get __const_global12's address in data section
sw $$locbase $r697 i0                   ; store word
movi $r699 i32                          ; initialize constant into register
sw $$locbase $r699 i1                   ; store word
addi $r700 $$locbase i16                ; get offset to local __ptr slice
mcpi $r700 $$locbase i16                ; copy memory
addi $r701 $$locbase i32                ; get offset to local __ptr b256
mcpi $r701 $r696 i32                    ; copy memory
addi $r702 $$locbase i16                ; get offset to local __ptr slice
load $r703 data_NonConfigurable_22      ; get local constant
move $$arg0 $r701                       ; [call]: pass argument 0
move $$arg1 $r702                       ; [call]: pass argument 1
movi $$arg2 i0                          ; [call]: pass argument 2
movi $$arg3 i0                          ; [call]: pass argument 3
move $$arg4 $r703                       ; [call]: pass argument 4
load $r704 data_NonConfigurable_25      ; load constant from data section
move $$arg5 $r704                       ; [call]: pass argument 5
fncall .24                              ; [call]: call contract_call_63
ret $zero                               ; return unit as zero
DIFF------------------------------
.program:
.32                                     ; --- start of function: test_nested_panic_non_inlined ---
move $$locbase $sp                      ; save locals base register for function test_nested_panic_non_inlined
cfei i64                                ; allocate 64 bytes for locals and 0 slots for call arguments
.139
addr $r696 data_NonConfigurable_23      ; get panicking_contract::CONTRACT_ID's address in data section
addr $r697 data_NonConfigurable_29      ; get __const_global12's address in data section
sw $$locbase $r697 i0                   ; store word
movi $r699 i32                          ; initialize constant into register
sw $$locbase $r699 i1                   ; store word
addi $r700 $$locbase i16                ; get offset to local __ptr slice
mcpi $r700 $$locbase i16                ; copy memory
addi $r701 $$locbase i32                ; get offset to local __ptr b256
mcpi $r701 $r696 i32                    ; copy memory
addi $r702 $$locbase i16                ; get offset to local __ptr slice
load $r703 data_NonConfigurable_22      ; get local constant
move $$arg0 $r701                       ; [call]: pass argument 0
move $$arg1 $r702                       ; [call]: pass argument 1
movi $$arg2 i0                          ; [call]: pass argument 2
movi $$arg3 i0                          ; [call]: pass argument 3
move $$arg4 $r703                       ; [call]: pass argument 4
load $r704 data_NonConfigurable_25      ; load constant from data section
move $$arg5 $r704                       ; [call]: pass argument 5
fncall .24                              ; [call]: call contract_call_63
ret $zero                               ; return unit as zero
DIFF------------------------------
.program:
.34                                     ; --- start of function: test_nested_panic_non_inlined_same_revert_code ---
move $$locbase $sp                      ; save locals base register for function test_nested_panic_non_inlined_same_revert_code
cfei i64                                ; allocate 64 bytes for locals and 0 slots for call arguments
.140
addr $r707 data_NonConfigurable_23      ; get panicking_contract::CONTRACT_ID's address in data section
addr $r708 data_NonConfigurable_30      ; get __const_global13's address in data section
sw $$locbase $r708 i0                   ; store word
addi $r709 $$locbase i8                 ; get offset to aggregate element
movi $r710 i32                          ; initialize constant into register
sw $$locbase $r710 i1                   ; store word
addi $r711 $$locbase i16                ; get offset to local __ptr slice
mcpi $r711 $$locbase i16                ; copy memory
addi $r712 $$locbase i32                ; get offset to local __ptr b256
mcpi $r712 $r707 i32                    ; copy memory
addi $r713 $$locbase i16                ; get offset to local __ptr slice
load $r714 data_NonConfigurable_22      ; get local constant
move $$arg0 $r712                       ; [call]: pass argument 0
move $$arg1 $r713                       ; [call]: pass argument 1
 move $$arg2 $zero                       ; [call]: pass argument 2
 move $$arg3 $zero                       ; [call]: pass argument 3
 movi $$arg2 i0                          ; [call]: pass argument 2
 movi $$arg3 i0                          ; [call]: pass argument 3
move $$arg4 $r714                       ; [call]: pass argument 4
load $r715 data_NonConfigurable_25      ; load constant from data section
move $$arg5 $r715                       ; [call]: pass argument 5
fncall .24                              ; [call]: call contract_call_63
 move $r716 $zero                        ; [call]: return unit value
 movi $r716 i0                           ; [call]: return unit value
ret $zero                               ; return unit as zero
DIFF------------------------------
.program:
.34                                     ; --- start of function: test_nested_panic_non_inlined_same_revert_code ---
move $$locbase $sp                      ; save locals base register for function test_nested_panic_non_inlined_same_revert_code
cfei i64                                ; allocate 64 bytes for locals and 0 slots for call arguments
.140
addr $r707 data_NonConfigurable_23      ; get panicking_contract::CONTRACT_ID's address in data section
addr $r708 data_NonConfigurable_30      ; get __const_global13's address in data section
sw $$locbase $r708 i0                   ; store word
movi $r710 i32                          ; initialize constant into register
sw $$locbase $r710 i1                   ; store word
addi $r711 $$locbase i16                ; get offset to local __ptr slice
mcpi $r711 $$locbase i16                ; copy memory
addi $r712 $$locbase i32                ; get offset to local __ptr b256
mcpi $r712 $r707 i32                    ; copy memory
addi $r713 $$locbase i16                ; get offset to local __ptr slice
load $r714 data_NonConfigurable_22      ; get local constant
move $$arg0 $r712                       ; [call]: pass argument 0
move $$arg1 $r713                       ; [call]: pass argument 1
movi $$arg2 i0                          ; [call]: pass argument 2
movi $$arg3 i0                          ; [call]: pass argument 3
move $$arg4 $r714                       ; [call]: pass argument 4
load $r715 data_NonConfigurable_25      ; load constant from data section
move $$arg5 $r715                       ; [call]: pass argument 5
fncall .24                              ; [call]: call contract_call_63
ret $zero                               ; return unit as zero
DIFF------------------------------
.program:
.34                                     ; --- start of function: test_nested_panic_non_inlined_same_revert_code ---
move $$locbase $sp                      ; save locals base register for function test_nested_panic_non_inlined_same_revert_code
cfei i64                                ; allocate 64 bytes for locals and 0 slots for call arguments
.140
addr $r707 data_NonConfigurable_23      ; get panicking_contract::CONTRACT_ID's address in data section
addr $r708 data_NonConfigurable_30      ; get __const_global13's address in data section
sw $$locbase $r708 i0                   ; store word
movi $r710 i32                          ; initialize constant into register
sw $$locbase $r710 i1                   ; store word
addi $r711 $$locbase i16                ; get offset to local __ptr slice
mcpi $r711 $$locbase i16                ; copy memory
addi $r712 $$locbase i32                ; get offset to local __ptr b256
mcpi $r712 $r707 i32                    ; copy memory
addi $r713 $$locbase i16                ; get offset to local __ptr slice
load $r714 data_NonConfigurable_22      ; get local constant
move $$arg0 $r712                       ; [call]: pass argument 0
move $$arg1 $r713                       ; [call]: pass argument 1
movi $$arg2 i0                          ; [call]: pass argument 2
movi $$arg3 i0                          ; [call]: pass argument 3
move $$arg4 $r714                       ; [call]: pass argument 4
load $r715 data_NonConfigurable_25      ; load constant from data section
move $$arg5 $r715                       ; [call]: pass argument 5
fncall .24                              ; [call]: call contract_call_63
ret $zero                               ; return unit as zero
DIFF------------------------------
.program:
.34                                     ; --- start of function: test_nested_panic_non_inlined_same_revert_code ---
move $$locbase $sp                      ; save locals base register for function test_nested_panic_non_inlined_same_revert_code
cfei i64                                ; allocate 64 bytes for locals and 0 slots for call arguments
.140
addr $r707 data_NonConfigurable_23      ; get panicking_contract::CONTRACT_ID's address in data section
addr $r708 data_NonConfigurable_30      ; get __const_global13's address in data section
sw $$locbase $r708 i0                   ; store word
movi $r710 i32                          ; initialize constant into register
sw $$locbase $r710 i1                   ; store word
addi $r711 $$locbase i16                ; get offset to local __ptr slice
mcpi $r711 $$locbase i16                ; copy memory
addi $r712 $$locbase i32                ; get offset to local __ptr b256
mcpi $r712 $r707 i32                    ; copy memory
addi $r713 $$locbase i16                ; get offset to local __ptr slice
load $r714 data_NonConfigurable_22      ; get local constant
move $$arg0 $r712                       ; [call]: pass argument 0
move $$arg1 $r713                       ; [call]: pass argument 1
movi $$arg2 i0                          ; [call]: pass argument 2
movi $$arg3 i0                          ; [call]: pass argument 3
move $$arg4 $r714                       ; [call]: pass argument 4
load $r715 data_NonConfigurable_25      ; load constant from data section
move $$arg5 $r715                       ; [call]: pass argument 5
fncall .24                              ; [call]: call contract_call_63
ret $zero                               ; return unit as zero
DIFF------------------------------
.program:
.36                                     ; --- start of function: test_generic_panic_with_unit ---
move $$locbase $sp                      ; save locals base register for function test_generic_panic_with_unit
cfei i64                                ; allocate 64 bytes for locals and 0 slots for call arguments
.141
addr $r718 data_NonConfigurable_23      ; get panicking_contract::CONTRACT_ID's address in data section
addr $r719 data_NonConfigurable_31      ; get __const_global14's address in data section
sw $$locbase $r719 i0                   ; store word
addi $r720 $$locbase i8                 ; get offset to aggregate element
movi $r721 i31                          ; initialize constant into register
sw $$locbase $r721 i1                   ; store word
addi $r722 $$locbase i16                ; get offset to local __ptr slice
mcpi $r722 $$locbase i16                ; copy memory
addi $r723 $$locbase i32                ; get offset to local __ptr b256
mcpi $r723 $r718 i32                    ; copy memory
addi $r724 $$locbase i16                ; get offset to local __ptr slice
load $r725 data_NonConfigurable_22      ; get local constant
move $$arg0 $r723                       ; [call]: pass argument 0
move $$arg1 $r724                       ; [call]: pass argument 1
 move $$arg2 $zero                       ; [call]: pass argument 2
 move $$arg3 $zero                       ; [call]: pass argument 3
 movi $$arg2 i0                          ; [call]: pass argument 2
 movi $$arg3 i0                          ; [call]: pass argument 3
move $$arg4 $r725                       ; [call]: pass argument 4
load $r726 data_NonConfigurable_25      ; load constant from data section
move $$arg5 $r726                       ; [call]: pass argument 5
fncall .24                              ; [call]: call contract_call_63
 move $r727 $zero                        ; [call]: return unit value
 movi $r727 i0                           ; [call]: return unit value
ret $zero                               ; return unit as zero
DIFF------------------------------
.program:
.36                                     ; --- start of function: test_generic_panic_with_unit ---
move $$locbase $sp                      ; save locals base register for function test_generic_panic_with_unit
cfei i64                                ; allocate 64 bytes for locals and 0 slots for call arguments
.141
addr $r718 data_NonConfigurable_23      ; get panicking_contract::CONTRACT_ID's address in data section
addr $r719 data_NonConfigurable_31      ; get __const_global14's address in data section
sw $$locbase $r719 i0                   ; store word
movi $r721 i31                          ; initialize constant into register
sw $$locbase $r721 i1                   ; store word
addi $r722 $$locbase i16                ; get offset to local __ptr slice
mcpi $r722 $$locbase i16                ; copy memory
addi $r723 $$locbase i32                ; get offset to local __ptr b256
mcpi $r723 $r718 i32                    ; copy memory
addi $r724 $$locbase i16                ; get offset to local __ptr slice
load $r725 data_NonConfigurable_22      ; get local constant
move $$arg0 $r723                       ; [call]: pass argument 0
move $$arg1 $r724                       ; [call]: pass argument 1
movi $$arg2 i0                          ; [call]: pass argument 2
movi $$arg3 i0                          ; [call]: pass argument 3
move $$arg4 $r725                       ; [call]: pass argument 4
load $r726 data_NonConfigurable_25      ; load constant from data section
move $$arg5 $r726                       ; [call]: pass argument 5
fncall .24                              ; [call]: call contract_call_63
ret $zero                               ; return unit as zero
DIFF------------------------------
.program:
.36                                     ; --- start of function: test_generic_panic_with_unit ---
move $$locbase $sp                      ; save locals base register for function test_generic_panic_with_unit
cfei i64                                ; allocate 64 bytes for locals and 0 slots for call arguments
.141
addr $r718 data_NonConfigurable_23      ; get panicking_contract::CONTRACT_ID's address in data section
addr $r719 data_NonConfigurable_31      ; get __const_global14's address in data section
sw $$locbase $r719 i0                   ; store word
movi $r721 i31                          ; initialize constant into register
sw $$locbase $r721 i1                   ; store word
addi $r722 $$locbase i16                ; get offset to local __ptr slice
mcpi $r722 $$locbase i16                ; copy memory
addi $r723 $$locbase i32                ; get offset to local __ptr b256
mcpi $r723 $r718 i32                    ; copy memory
addi $r724 $$locbase i16                ; get offset to local __ptr slice
load $r725 data_NonConfigurable_22      ; get local constant
move $$arg0 $r723                       ; [call]: pass argument 0
move $$arg1 $r724                       ; [call]: pass argument 1
movi $$arg2 i0                          ; [call]: pass argument 2
movi $$arg3 i0                          ; [call]: pass argument 3
move $$arg4 $r725                       ; [call]: pass argument 4
load $r726 data_NonConfigurable_25      ; load constant from data section
move $$arg5 $r726                       ; [call]: pass argument 5
fncall .24                              ; [call]: call contract_call_63
ret $zero                               ; return unit as zero
DIFF------------------------------
.program:
.36                                     ; --- start of function: test_generic_panic_with_unit ---
move $$locbase $sp                      ; save locals base register for function test_generic_panic_with_unit
cfei i64                                ; allocate 64 bytes for locals and 0 slots for call arguments
.141
addr $r718 data_NonConfigurable_23      ; get panicking_contract::CONTRACT_ID's address in data section
addr $r719 data_NonConfigurable_31      ; get __const_global14's address in data section
sw $$locbase $r719 i0                   ; store word
movi $r721 i31                          ; initialize constant into register
sw $$locbase $r721 i1                   ; store word
addi $r722 $$locbase i16                ; get offset to local __ptr slice
mcpi $r722 $$locbase i16                ; copy memory
addi $r723 $$locbase i32                ; get offset to local __ptr b256
mcpi $r723 $r718 i32                    ; copy memory
addi $r724 $$locbase i16                ; get offset to local __ptr slice
load $r725 data_NonConfigurable_22      ; get local constant
move $$arg0 $r723                       ; [call]: pass argument 0
move $$arg1 $r724                       ; [call]: pass argument 1
movi $$arg2 i0                          ; [call]: pass argument 2
movi $$arg3 i0                          ; [call]: pass argument 3
move $$arg4 $r725                       ; [call]: pass argument 4
load $r726 data_NonConfigurable_25      ; load constant from data section
move $$arg5 $r726                       ; [call]: pass argument 5
fncall .24                              ; [call]: call contract_call_63
ret $zero                               ; return unit as zero
DIFF------------------------------
.program:
.38                                     ; --- start of function: test_generic_panic_with_unit_same_revert_code ---
move $$locbase $sp                      ; save locals base register for function test_generic_panic_with_unit_same_revert_code
cfei i64                                ; allocate 64 bytes for locals and 0 slots for call arguments
.142
addr $r729 data_NonConfigurable_23      ; get panicking_contract::CONTRACT_ID's address in data section
addr $r730 data_NonConfigurable_32      ; get __const_global15's address in data section
sw $$locbase $r730 i0                   ; store word
addi $r731 $$locbase i8                 ; get offset to aggregate element
movi $r732 i31                          ; initialize constant into register
sw $$locbase $r732 i1                   ; store word
addi $r733 $$locbase i16                ; get offset to local __ptr slice
mcpi $r733 $$locbase i16                ; copy memory
addi $r734 $$locbase i32                ; get offset to local __ptr b256
mcpi $r734 $r729 i32                    ; copy memory
addi $r735 $$locbase i16                ; get offset to local __ptr slice
load $r736 data_NonConfigurable_22      ; get local constant
move $$arg0 $r734                       ; [call]: pass argument 0
move $$arg1 $r735                       ; [call]: pass argument 1
 move $$arg2 $zero                       ; [call]: pass argument 2
 move $$arg3 $zero                       ; [call]: pass argument 3
 movi $$arg2 i0                          ; [call]: pass argument 2
 movi $$arg3 i0                          ; [call]: pass argument 3
move $$arg4 $r736                       ; [call]: pass argument 4
load $r737 data_NonConfigurable_25      ; load constant from data section
move $$arg5 $r737                       ; [call]: pass argument 5
fncall .24                              ; [call]: call contract_call_63
 move $r738 $zero                        ; [call]: return unit value
 movi $r738 i0                           ; [call]: return unit value
ret $zero                               ; return unit as zero
DIFF------------------------------
.program:
.38                                     ; --- start of function: test_generic_panic_with_unit_same_revert_code ---
move $$locbase $sp                      ; save locals base register for function test_generic_panic_with_unit_same_revert_code
cfei i64                                ; allocate 64 bytes for locals and 0 slots for call arguments
.142
addr $r729 data_NonConfigurable_23      ; get panicking_contract::CONTRACT_ID's address in data section
addr $r730 data_NonConfigurable_32      ; get __const_global15's address in data section
sw $$locbase $r730 i0                   ; store word
movi $r732 i31                          ; initialize constant into register
sw $$locbase $r732 i1                   ; store word
addi $r733 $$locbase i16                ; get offset to local __ptr slice
mcpi $r733 $$locbase i16                ; copy memory
addi $r734 $$locbase i32                ; get offset to local __ptr b256
mcpi $r734 $r729 i32                    ; copy memory
addi $r735 $$locbase i16                ; get offset to local __ptr slice
load $r736 data_NonConfigurable_22      ; get local constant
move $$arg0 $r734                       ; [call]: pass argument 0
move $$arg1 $r735                       ; [call]: pass argument 1
movi $$arg2 i0                          ; [call]: pass argument 2
movi $$arg3 i0                          ; [call]: pass argument 3
move $$arg4 $r736                       ; [call]: pass argument 4
load $r737 data_NonConfigurable_25      ; load constant from data section
move $$arg5 $r737                       ; [call]: pass argument 5
fncall .24                              ; [call]: call contract_call_63
ret $zero                               ; return unit as zero
DIFF------------------------------
.program:
.38                                     ; --- start of function: test_generic_panic_with_unit_same_revert_code ---
move $$locbase $sp                      ; save locals base register for function test_generic_panic_with_unit_same_revert_code
cfei i64                                ; allocate 64 bytes for locals and 0 slots for call arguments
.142
addr $r729 data_NonConfigurable_23      ; get panicking_contract::CONTRACT_ID's address in data section
addr $r730 data_NonConfigurable_32      ; get __const_global15's address in data section
sw $$locbase $r730 i0                   ; store word
movi $r732 i31                          ; initialize constant into register
sw $$locbase $r732 i1                   ; store word
addi $r733 $$locbase i16                ; get offset to local __ptr slice
mcpi $r733 $$locbase i16                ; copy memory
addi $r734 $$locbase i32                ; get offset to local __ptr b256
mcpi $r734 $r729 i32                    ; copy memory
addi $r735 $$locbase i16                ; get offset to local __ptr slice
load $r736 data_NonConfigurable_22      ; get local constant
move $$arg0 $r734                       ; [call]: pass argument 0
move $$arg1 $r735                       ; [call]: pass argument 1
movi $$arg2 i0                          ; [call]: pass argument 2
movi $$arg3 i0                          ; [call]: pass argument 3
move $$arg4 $r736                       ; [call]: pass argument 4
load $r737 data_NonConfigurable_25      ; load constant from data section
move $$arg5 $r737                       ; [call]: pass argument 5
fncall .24                              ; [call]: call contract_call_63
ret $zero                               ; return unit as zero
DIFF------------------------------
.program:
.38                                     ; --- start of function: test_generic_panic_with_unit_same_revert_code ---
move $$locbase $sp                      ; save locals base register for function test_generic_panic_with_unit_same_revert_code
cfei i64                                ; allocate 64 bytes for locals and 0 slots for call arguments
.142
addr $r729 data_NonConfigurable_23      ; get panicking_contract::CONTRACT_ID's address in data section
addr $r730 data_NonConfigurable_32      ; get __const_global15's address in data section
sw $$locbase $r730 i0                   ; store word
movi $r732 i31                          ; initialize constant into register
sw $$locbase $r732 i1                   ; store word
addi $r733 $$locbase i16                ; get offset to local __ptr slice
mcpi $r733 $$locbase i16                ; copy memory
addi $r734 $$locbase i32                ; get offset to local __ptr b256
mcpi $r734 $r729 i32                    ; copy memory
addi $r735 $$locbase i16                ; get offset to local __ptr slice
load $r736 data_NonConfigurable_22      ; get local constant
move $$arg0 $r734                       ; [call]: pass argument 0
move $$arg1 $r735                       ; [call]: pass argument 1
movi $$arg2 i0                          ; [call]: pass argument 2
movi $$arg3 i0                          ; [call]: pass argument 3
move $$arg4 $r736                       ; [call]: pass argument 4
load $r737 data_NonConfigurable_25      ; load constant from data section
move $$arg5 $r737                       ; [call]: pass argument 5
fncall .24                              ; [call]: call contract_call_63
ret $zero                               ; return unit as zero
DIFF------------------------------
.program:
.40                                     ; --- start of function: test_generic_panic_with_str ---
move $$locbase $sp                      ; save locals base register for function test_generic_panic_with_str
cfei i64                                ; allocate 64 bytes for locals and 0 slots for call arguments
.143
addr $r740 data_NonConfigurable_23      ; get panicking_contract::CONTRACT_ID's address in data section
addr $r741 data_NonConfigurable_33      ; get __const_global16's address in data section
sw $$locbase $r741 i0                   ; store word
addi $r742 $$locbase i8                 ; get offset to aggregate element
movi $r743 i30                          ; initialize constant into register
sw $$locbase $r743 i1                   ; store word
addi $r744 $$locbase i16                ; get offset to local __ptr slice
mcpi $r744 $$locbase i16                ; copy memory
addi $r745 $$locbase i32                ; get offset to local __ptr b256
mcpi $r745 $r740 i32                    ; copy memory
addi $r746 $$locbase i16                ; get offset to local __ptr slice
load $r747 data_NonConfigurable_22      ; get local constant
move $$arg0 $r745                       ; [call]: pass argument 0
move $$arg1 $r746                       ; [call]: pass argument 1
 move $$arg2 $zero                       ; [call]: pass argument 2
 move $$arg3 $zero                       ; [call]: pass argument 3
 movi $$arg2 i0                          ; [call]: pass argument 2
 movi $$arg3 i0                          ; [call]: pass argument 3
move $$arg4 $r747                       ; [call]: pass argument 4
load $r748 data_NonConfigurable_25      ; load constant from data section
move $$arg5 $r748                       ; [call]: pass argument 5
fncall .24                              ; [call]: call contract_call_63
 move $r749 $zero                        ; [call]: return unit value
 movi $r749 i0                           ; [call]: return unit value
ret $zero                               ; return unit as zero
DIFF------------------------------
.program:
.40                                     ; --- start of function: test_generic_panic_with_str ---
move $$locbase $sp                      ; save locals base register for function test_generic_panic_with_str
cfei i64                                ; allocate 64 bytes for locals and 0 slots for call arguments
.143
addr $r740 data_NonConfigurable_23      ; get panicking_contract::CONTRACT_ID's address in data section
addr $r741 data_NonConfigurable_33      ; get __const_global16's address in data section
sw $$locbase $r741 i0                   ; store word
movi $r743 i30                          ; initialize constant into register
sw $$locbase $r743 i1                   ; store word
addi $r744 $$locbase i16                ; get offset to local __ptr slice
mcpi $r744 $$locbase i16                ; copy memory
addi $r745 $$locbase i32                ; get offset to local __ptr b256
mcpi $r745 $r740 i32                    ; copy memory
addi $r746 $$locbase i16                ; get offset to local __ptr slice
load $r747 data_NonConfigurable_22      ; get local constant
move $$arg0 $r745                       ; [call]: pass argument 0
move $$arg1 $r746                       ; [call]: pass argument 1
movi $$arg2 i0                          ; [call]: pass argument 2
movi $$arg3 i0                          ; [call]: pass argument 3
move $$arg4 $r747                       ; [call]: pass argument 4
load $r748 data_NonConfigurable_25      ; load constant from data section
move $$arg5 $r748                       ; [call]: pass argument 5
fncall .24                              ; [call]: call contract_call_63
ret $zero                               ; return unit as zero
DIFF------------------------------
.program:
.40                                     ; --- start of function: test_generic_panic_with_str ---
move $$locbase $sp                      ; save locals base register for function test_generic_panic_with_str
cfei i64                                ; allocate 64 bytes for locals and 0 slots for call arguments
.143
addr $r740 data_NonConfigurable_23      ; get panicking_contract::CONTRACT_ID's address in data section
addr $r741 data_NonConfigurable_33      ; get __const_global16's address in data section
sw $$locbase $r741 i0                   ; store word
movi $r743 i30                          ; initialize constant into register
sw $$locbase $r743 i1                   ; store word
addi $r744 $$locbase i16                ; get offset to local __ptr slice
mcpi $r744 $$locbase i16                ; copy memory
addi $r745 $$locbase i32                ; get offset to local __ptr b256
mcpi $r745 $r740 i32                    ; copy memory
addi $r746 $$locbase i16                ; get offset to local __ptr slice
load $r747 data_NonConfigurable_22      ; get local constant
move $$arg0 $r745                       ; [call]: pass argument 0
move $$arg1 $r746                       ; [call]: pass argument 1
movi $$arg2 i0                          ; [call]: pass argument 2
movi $$arg3 i0                          ; [call]: pass argument 3
move $$arg4 $r747                       ; [call]: pass argument 4
load $r748 data_NonConfigurable_25      ; load constant from data section
move $$arg5 $r748                       ; [call]: pass argument 5
fncall .24                              ; [call]: call contract_call_63
ret $zero                               ; return unit as zero
DIFF------------------------------
.program:
.40                                     ; --- start of function: test_generic_panic_with_str ---
move $$locbase $sp                      ; save locals base register for function test_generic_panic_with_str
cfei i64                                ; allocate 64 bytes for locals and 0 slots for call arguments
.143
addr $r740 data_NonConfigurable_23      ; get panicking_contract::CONTRACT_ID's address in data section
addr $r741 data_NonConfigurable_33      ; get __const_global16's address in data section
sw $$locbase $r741 i0                   ; store word
movi $r743 i30                          ; initialize constant into register
sw $$locbase $r743 i1                   ; store word
addi $r744 $$locbase i16                ; get offset to local __ptr slice
mcpi $r744 $$locbase i16                ; copy memory
addi $r745 $$locbase i32                ; get offset to local __ptr b256
mcpi $r745 $r740 i32                    ; copy memory
addi $r746 $$locbase i16                ; get offset to local __ptr slice
load $r747 data_NonConfigurable_22      ; get local constant
move $$arg0 $r745                       ; [call]: pass argument 0
move $$arg1 $r746                       ; [call]: pass argument 1
movi $$arg2 i0                          ; [call]: pass argument 2
movi $$arg3 i0                          ; [call]: pass argument 3
move $$arg4 $r747                       ; [call]: pass argument 4
load $r748 data_NonConfigurable_25      ; load constant from data section
move $$arg5 $r748                       ; [call]: pass argument 5
fncall .24                              ; [call]: call contract_call_63
ret $zero                               ; return unit as zero
DIFF------------------------------
.program:
.42                                     ; --- start of function: test_generic_panic_with_different_str_same_revert_code ---
move $$locbase $sp                      ; save locals base register for function test_generic_panic_with_different_str_same_revert_code
cfei i64                                ; allocate 64 bytes for locals and 0 slots for call arguments
.144
addr $r751 data_NonConfigurable_23      ; get panicking_contract::CONTRACT_ID's address in data section
addr $r752 data_NonConfigurable_34      ; get __const_global17's address in data section
sw $$locbase $r752 i0                   ; store word
addi $r753 $$locbase i8                 ; get offset to aggregate element
movi $r754 i57                          ; initialize constant into register
sw $$locbase $r754 i1                   ; store word
addi $r755 $$locbase i16                ; get offset to local __ptr slice
mcpi $r755 $$locbase i16                ; copy memory
addi $r756 $$locbase i32                ; get offset to local __ptr b256
mcpi $r756 $r751 i32                    ; copy memory
addi $r757 $$locbase i16                ; get offset to local __ptr slice
load $r758 data_NonConfigurable_22      ; get local constant
move $$arg0 $r756                       ; [call]: pass argument 0
move $$arg1 $r757                       ; [call]: pass argument 1
 move $$arg2 $zero                       ; [call]: pass argument 2
 move $$arg3 $zero                       ; [call]: pass argument 3
 movi $$arg2 i0                          ; [call]: pass argument 2
 movi $$arg3 i0                          ; [call]: pass argument 3
move $$arg4 $r758                       ; [call]: pass argument 4
load $r759 data_NonConfigurable_25      ; load constant from data section
move $$arg5 $r759                       ; [call]: pass argument 5
fncall .24                              ; [call]: call contract_call_63
 move $r760 $zero                        ; [call]: return unit value
 movi $r760 i0                           ; [call]: return unit value
ret $zero                               ; return unit as zero
DIFF------------------------------
.program:
.42                                     ; --- start of function: test_generic_panic_with_different_str_same_revert_code ---
move $$locbase $sp                      ; save locals base register for function test_generic_panic_with_different_str_same_revert_code
cfei i64                                ; allocate 64 bytes for locals and 0 slots for call arguments
.144
addr $r751 data_NonConfigurable_23      ; get panicking_contract::CONTRACT_ID's address in data section
addr $r752 data_NonConfigurable_34      ; get __const_global17's address in data section
sw $$locbase $r752 i0                   ; store word
movi $r754 i57                          ; initialize constant into register
sw $$locbase $r754 i1                   ; store word
addi $r755 $$locbase i16                ; get offset to local __ptr slice
mcpi $r755 $$locbase i16                ; copy memory
addi $r756 $$locbase i32                ; get offset to local __ptr b256
mcpi $r756 $r751 i32                    ; copy memory
addi $r757 $$locbase i16                ; get offset to local __ptr slice
load $r758 data_NonConfigurable_22      ; get local constant
move $$arg0 $r756                       ; [call]: pass argument 0
move $$arg1 $r757                       ; [call]: pass argument 1
movi $$arg2 i0                          ; [call]: pass argument 2
movi $$arg3 i0                          ; [call]: pass argument 3
move $$arg4 $r758                       ; [call]: pass argument 4
load $r759 data_NonConfigurable_25      ; load constant from data section
move $$arg5 $r759                       ; [call]: pass argument 5
fncall .24                              ; [call]: call contract_call_63
ret $zero                               ; return unit as zero
DIFF------------------------------
.program:
.42                                     ; --- start of function: test_generic_panic_with_different_str_same_revert_code ---
move $$locbase $sp                      ; save locals base register for function test_generic_panic_with_different_str_same_revert_code
cfei i64                                ; allocate 64 bytes for locals and 0 slots for call arguments
.144
addr $r751 data_NonConfigurable_23      ; get panicking_contract::CONTRACT_ID's address in data section
addr $r752 data_NonConfigurable_34      ; get __const_global17's address in data section
sw $$locbase $r752 i0                   ; store word
movi $r754 i57                          ; initialize constant into register
sw $$locbase $r754 i1                   ; store word
addi $r755 $$locbase i16                ; get offset to local __ptr slice
mcpi $r755 $$locbase i16                ; copy memory
addi $r756 $$locbase i32                ; get offset to local __ptr b256
mcpi $r756 $r751 i32                    ; copy memory
addi $r757 $$locbase i16                ; get offset to local __ptr slice
load $r758 data_NonConfigurable_22      ; get local constant
move $$arg0 $r756                       ; [call]: pass argument 0
move $$arg1 $r757                       ; [call]: pass argument 1
movi $$arg2 i0                          ; [call]: pass argument 2
movi $$arg3 i0                          ; [call]: pass argument 3
move $$arg4 $r758                       ; [call]: pass argument 4
load $r759 data_NonConfigurable_25      ; load constant from data section
move $$arg5 $r759                       ; [call]: pass argument 5
fncall .24                              ; [call]: call contract_call_63
ret $zero                               ; return unit as zero
DIFF------------------------------
.program:
.42                                     ; --- start of function: test_generic_panic_with_different_str_same_revert_code ---
move $$locbase $sp                      ; save locals base register for function test_generic_panic_with_different_str_same_revert_code
cfei i64                                ; allocate 64 bytes for locals and 0 slots for call arguments
.144
addr $r751 data_NonConfigurable_23      ; get panicking_contract::CONTRACT_ID's address in data section
addr $r752 data_NonConfigurable_34      ; get __const_global17's address in data section
sw $$locbase $r752 i0                   ; store word
movi $r754 i57                          ; initialize constant into register
sw $$locbase $r754 i1                   ; store word
addi $r755 $$locbase i16                ; get offset to local __ptr slice
mcpi $r755 $$locbase i16                ; copy memory
addi $r756 $$locbase i32                ; get offset to local __ptr b256
mcpi $r756 $r751 i32                    ; copy memory
addi $r757 $$locbase i16                ; get offset to local __ptr slice
load $r758 data_NonConfigurable_22      ; get local constant
move $$arg0 $r756                       ; [call]: pass argument 0
move $$arg1 $r757                       ; [call]: pass argument 1
movi $$arg2 i0                          ; [call]: pass argument 2
movi $$arg3 i0                          ; [call]: pass argument 3
move $$arg4 $r758                       ; [call]: pass argument 4
load $r759 data_NonConfigurable_25      ; load constant from data section
move $$arg5 $r759                       ; [call]: pass argument 5
fncall .24                              ; [call]: call contract_call_63
ret $zero                               ; return unit as zero
DIFF------------------------------
.program:
.44                                     ; --- start of function: test_generic_panic_with_error_type_enum ---
move $$locbase $sp                      ; save locals base register for function test_generic_panic_with_error_type_enum
cfei i64                                ; allocate 64 bytes for locals and 0 slots for call arguments
.145
addr $r762 data_NonConfigurable_23      ; get panicking_contract::CONTRACT_ID's address in data section
addr $r763 data_NonConfigurable_35      ; get __const_global18's address in data section
sw $$locbase $r763 i0                   ; store word
addi $r764 $$locbase i8                 ; get offset to aggregate element
movi $r765 i42                          ; initialize constant into register
sw $$locbase $r765 i1                   ; store word
addi $r766 $$locbase i16                ; get offset to local __ptr slice
mcpi $r766 $$locbase i16                ; copy memory
addi $r767 $$locbase i32                ; get offset to local __ptr b256
mcpi $r767 $r762 i32                    ; copy memory
addi $r768 $$locbase i16                ; get offset to local __ptr slice
load $r769 data_NonConfigurable_22      ; get local constant
move $$arg0 $r767                       ; [call]: pass argument 0
move $$arg1 $r768                       ; [call]: pass argument 1
 move $$arg2 $zero                       ; [call]: pass argument 2
 move $$arg3 $zero                       ; [call]: pass argument 3
 movi $$arg2 i0                          ; [call]: pass argument 2
 movi $$arg3 i0                          ; [call]: pass argument 3
move $$arg4 $r769                       ; [call]: pass argument 4
load $r770 data_NonConfigurable_25      ; load constant from data section
move $$arg5 $r770                       ; [call]: pass argument 5
fncall .24                              ; [call]: call contract_call_63
 move $r771 $zero                        ; [call]: return unit value
 movi $r771 i0                           ; [call]: return unit value
ret $zero                               ; return unit as zero
DIFF------------------------------
.program:
.44                                     ; --- start of function: test_generic_panic_with_error_type_enum ---
move $$locbase $sp                      ; save locals base register for function test_generic_panic_with_error_type_enum
cfei i64                                ; allocate 64 bytes for locals and 0 slots for call arguments
.145
addr $r762 data_NonConfigurable_23      ; get panicking_contract::CONTRACT_ID's address in data section
addr $r763 data_NonConfigurable_35      ; get __const_global18's address in data section
sw $$locbase $r763 i0                   ; store word
movi $r765 i42                          ; initialize constant into register
sw $$locbase $r765 i1                   ; store word
addi $r766 $$locbase i16                ; get offset to local __ptr slice
mcpi $r766 $$locbase i16                ; copy memory
addi $r767 $$locbase i32                ; get offset to local __ptr b256
mcpi $r767 $r762 i32                    ; copy memory
addi $r768 $$locbase i16                ; get offset to local __ptr slice
load $r769 data_NonConfigurable_22      ; get local constant
move $$arg0 $r767                       ; [call]: pass argument 0
move $$arg1 $r768                       ; [call]: pass argument 1
movi $$arg2 i0                          ; [call]: pass argument 2
movi $$arg3 i0                          ; [call]: pass argument 3
move $$arg4 $r769                       ; [call]: pass argument 4
load $r770 data_NonConfigurable_25      ; load constant from data section
move $$arg5 $r770                       ; [call]: pass argument 5
fncall .24                              ; [call]: call contract_call_63
ret $zero                               ; return unit as zero
DIFF------------------------------
.program:
.44                                     ; --- start of function: test_generic_panic_with_error_type_enum ---
move $$locbase $sp                      ; save locals base register for function test_generic_panic_with_error_type_enum
cfei i64                                ; allocate 64 bytes for locals and 0 slots for call arguments
.145
addr $r762 data_NonConfigurable_23      ; get panicking_contract::CONTRACT_ID's address in data section
addr $r763 data_NonConfigurable_35      ; get __const_global18's address in data section
sw $$locbase $r763 i0                   ; store word
movi $r765 i42                          ; initialize constant into register
sw $$locbase $r765 i1                   ; store word
addi $r766 $$locbase i16                ; get offset to local __ptr slice
mcpi $r766 $$locbase i16                ; copy memory
addi $r767 $$locbase i32                ; get offset to local __ptr b256
mcpi $r767 $r762 i32                    ; copy memory
addi $r768 $$locbase i16                ; get offset to local __ptr slice
load $r769 data_NonConfigurable_22      ; get local constant
move $$arg0 $r767                       ; [call]: pass argument 0
move $$arg1 $r768                       ; [call]: pass argument 1
movi $$arg2 i0                          ; [call]: pass argument 2
movi $$arg3 i0                          ; [call]: pass argument 3
move $$arg4 $r769                       ; [call]: pass argument 4
load $r770 data_NonConfigurable_25      ; load constant from data section
move $$arg5 $r770                       ; [call]: pass argument 5
fncall .24                              ; [call]: call contract_call_63
ret $zero                               ; return unit as zero
DIFF------------------------------
.program:
.44                                     ; --- start of function: test_generic_panic_with_error_type_enum ---
move $$locbase $sp                      ; save locals base register for function test_generic_panic_with_error_type_enum
cfei i64                                ; allocate 64 bytes for locals and 0 slots for call arguments
.145
addr $r762 data_NonConfigurable_23      ; get panicking_contract::CONTRACT_ID's address in data section
addr $r763 data_NonConfigurable_35      ; get __const_global18's address in data section
sw $$locbase $r763 i0                   ; store word
movi $r765 i42                          ; initialize constant into register
sw $$locbase $r765 i1                   ; store word
addi $r766 $$locbase i16                ; get offset to local __ptr slice
mcpi $r766 $$locbase i16                ; copy memory
addi $r767 $$locbase i32                ; get offset to local __ptr b256
mcpi $r767 $r762 i32                    ; copy memory
addi $r768 $$locbase i16                ; get offset to local __ptr slice
load $r769 data_NonConfigurable_22      ; get local constant
move $$arg0 $r767                       ; [call]: pass argument 0
move $$arg1 $r768                       ; [call]: pass argument 1
movi $$arg2 i0                          ; [call]: pass argument 2
movi $$arg3 i0                          ; [call]: pass argument 3
move $$arg4 $r769                       ; [call]: pass argument 4
load $r770 data_NonConfigurable_25      ; load constant from data section
move $$arg5 $r770                       ; [call]: pass argument 5
fncall .24                              ; [call]: call contract_call_63
ret $zero                               ; return unit as zero
DIFF------------------------------
.program:
.46                                     ; --- start of function: test_generic_panic_with_error_type_enum_different_variant_same_revert_code ---
move $$locbase $sp                      ; save locals base register for function test_generic_panic_with_error_type_enum_different_variant_same_revert_code
cfei i64                                ; allocate 64 bytes for locals and 0 slots for call arguments
.146
addr $r773 data_NonConfigurable_23      ; get panicking_contract::CONTRACT_ID's address in data section
addr $r774 data_NonConfigurable_36      ; get __const_global19's address in data section
sw $$locbase $r774 i0                   ; store word
addi $r775 $$locbase i8                 ; get offset to aggregate element
movi $r776 i77                          ; initialize constant into register
sw $$locbase $r776 i1                   ; store word
addi $r777 $$locbase i16                ; get offset to local __ptr slice
mcpi $r777 $$locbase i16                ; copy memory
addi $r778 $$locbase i32                ; get offset to local __ptr b256
mcpi $r778 $r773 i32                    ; copy memory
addi $r779 $$locbase i16                ; get offset to local __ptr slice
load $r780 data_NonConfigurable_22      ; get local constant
move $$arg0 $r778                       ; [call]: pass argument 0
move $$arg1 $r779                       ; [call]: pass argument 1
 move $$arg2 $zero                       ; [call]: pass argument 2
 move $$arg3 $zero                       ; [call]: pass argument 3
 movi $$arg2 i0                          ; [call]: pass argument 2
 movi $$arg3 i0                          ; [call]: pass argument 3
move $$arg4 $r780                       ; [call]: pass argument 4
load $r781 data_NonConfigurable_25      ; load constant from data section
move $$arg5 $r781                       ; [call]: pass argument 5
fncall .24                              ; [call]: call contract_call_63
 move $r782 $zero                        ; [call]: return unit value
 movi $r782 i0                           ; [call]: return unit value
ret $zero                               ; return unit as zero
DIFF------------------------------
.program:
.46                                     ; --- start of function: test_generic_panic_with_error_type_enum_different_variant_same_revert_code ---
move $$locbase $sp                      ; save locals base register for function test_generic_panic_with_error_type_enum_different_variant_same_revert_code
cfei i64                                ; allocate 64 bytes for locals and 0 slots for call arguments
.146
addr $r773 data_NonConfigurable_23      ; get panicking_contract::CONTRACT_ID's address in data section
addr $r774 data_NonConfigurable_36      ; get __const_global19's address in data section
sw $$locbase $r774 i0                   ; store word
movi $r776 i77                          ; initialize constant into register
sw $$locbase $r776 i1                   ; store word
addi $r777 $$locbase i16                ; get offset to local __ptr slice
mcpi $r777 $$locbase i16                ; copy memory
addi $r778 $$locbase i32                ; get offset to local __ptr b256
mcpi $r778 $r773 i32                    ; copy memory
addi $r779 $$locbase i16                ; get offset to local __ptr slice
load $r780 data_NonConfigurable_22      ; get local constant
move $$arg0 $r778                       ; [call]: pass argument 0
move $$arg1 $r779                       ; [call]: pass argument 1
movi $$arg2 i0                          ; [call]: pass argument 2
movi $$arg3 i0                          ; [call]: pass argument 3
move $$arg4 $r780                       ; [call]: pass argument 4
load $r781 data_NonConfigurable_25      ; load constant from data section
move $$arg5 $r781                       ; [call]: pass argument 5
fncall .24                              ; [call]: call contract_call_63
ret $zero                               ; return unit as zero
DIFF------------------------------
.program:
.46                                     ; --- start of function: test_generic_panic_with_error_type_enum_different_variant_same_revert_code ---
move $$locbase $sp                      ; save locals base register for function test_generic_panic_with_error_type_enum_different_variant_same_revert_code
cfei i64                                ; allocate 64 bytes for locals and 0 slots for call arguments
.146
addr $r773 data_NonConfigurable_23      ; get panicking_contract::CONTRACT_ID's address in data section
addr $r774 data_NonConfigurable_36      ; get __const_global19's address in data section
sw $$locbase $r774 i0                   ; store word
movi $r776 i77                          ; initialize constant into register
sw $$locbase $r776 i1                   ; store word
addi $r777 $$locbase i16                ; get offset to local __ptr slice
mcpi $r777 $$locbase i16                ; copy memory
addi $r778 $$locbase i32                ; get offset to local __ptr b256
mcpi $r778 $r773 i32                    ; copy memory
addi $r779 $$locbase i16                ; get offset to local __ptr slice
load $r780 data_NonConfigurable_22      ; get local constant
move $$arg0 $r778                       ; [call]: pass argument 0
move $$arg1 $r779                       ; [call]: pass argument 1
movi $$arg2 i0                          ; [call]: pass argument 2
movi $$arg3 i0                          ; [call]: pass argument 3
move $$arg4 $r780                       ; [call]: pass argument 4
load $r781 data_NonConfigurable_25      ; load constant from data section
move $$arg5 $r781                       ; [call]: pass argument 5
fncall .24                              ; [call]: call contract_call_63
ret $zero                               ; return unit as zero
DIFF------------------------------
.program:
.46                                     ; --- start of function: test_generic_panic_with_error_type_enum_different_variant_same_revert_code ---
move $$locbase $sp                      ; save locals base register for function test_generic_panic_with_error_type_enum_different_variant_same_revert_code
cfei i64                                ; allocate 64 bytes for locals and 0 slots for call arguments
.146
addr $r773 data_NonConfigurable_23      ; get panicking_contract::CONTRACT_ID's address in data section
addr $r774 data_NonConfigurable_36      ; get __const_global19's address in data section
sw $$locbase $r774 i0                   ; store word
movi $r776 i77                          ; initialize constant into register
sw $$locbase $r776 i1                   ; store word
addi $r777 $$locbase i16                ; get offset to local __ptr slice
mcpi $r777 $$locbase i16                ; copy memory
addi $r778 $$locbase i32                ; get offset to local __ptr b256
mcpi $r778 $r773 i32                    ; copy memory
addi $r779 $$locbase i16                ; get offset to local __ptr slice
load $r780 data_NonConfigurable_22      ; get local constant
move $$arg0 $r778                       ; [call]: pass argument 0
move $$arg1 $r779                       ; [call]: pass argument 1
movi $$arg2 i0                          ; [call]: pass argument 2
movi $$arg3 i0                          ; [call]: pass argument 3
move $$arg4 $r780                       ; [call]: pass argument 4
load $r781 data_NonConfigurable_25      ; load constant from data section
move $$arg5 $r781                       ; [call]: pass argument 5
fncall .24                              ; [call]: call contract_call_63
ret $zero                               ; return unit as zero
DIFF------------------------------
.program:
.2                                      ; --- start of function: encode_allow_alias_12 ---
pusha .2                                ; save all registers
move $$locbase $sp                      ; save locals base register for function encode_allow_alias_12
cfei i1520                              ; allocate 1520 bytes for locals and 0 slots for call arguments
move $r168 $$arg0                       ; save argument 0 (item)
move $r169 $$arg1                       ; save argument 1 (__ret_value)
move $r170 $$reta                       ; save return address
.88
 move $r171 $zero                        ; move parameter from branch to block argument
 jnzi $zero .89
 movi $r171 i0                           ; move parameter from branch to block argument
 
ji  .90
.89
 move $r171 $one                         ; move parameter from branch to block argument
 movi $r171 i1                           ; move parameter from branch to block argument
ji  .90
.90
move $r174 $r171                        ; move parameter from branch to block argument
 move $r175 $r174                        ; move parameter from branch to block argument
 jnzi $r174 .91
 move $r175 $r171                        ; move parameter from branch to block argument
 jnzi $r171 .91
ji  .92
.91
 move $r175 $one                         ; move parameter from branch to block argument
 movi $r175 i1                           ; move parameter from branch to block argument
ji  .92
.92
move $r178 $r175                        ; move parameter from branch to block argument
 move $r179 $r178                        ; move parameter from branch to block argument
 jnzi $r178 .93
 move $r179 $r175                        ; move parameter from branch to block argument
 jnzi $r175 .93
ji  .94
.93
 move $r179 $zero                        ; move parameter from branch to block argument
 movi $r179 i0                           ; move parameter from branch to block argument
ji  .94
.94
move $r182 $r179                        ; move parameter from branch to block argument
 jnzi $r182 .95
 jnzi $r179 .95
ji  .96
.96
addi $r183 $$locbase i456               ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r183                       ; [call]: pass argument 0
fncall .8                               ; [call]: call new_38
 move $r184 $zero                        ; [call]: return unit value
 movi $r184 i0                           ; [call]: return unit value
addi $r185 $$locbase i1336              ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
mcpi $r185 $r168 i56                    ; copy memory
addi $r186 $$locbase i928               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r186 $r183 i24                    ; copy memory
addi $r187 $$locbase i1336              ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
addi $r188 $$locbase i208               ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
mcpi $r188 $r187 i56                    ; copy memory
addi $r189 $$locbase i208               ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
lw $r190 $$locbase i26                  ; load word
eq $r191 $r190 $zero
jnzi $r191 .97
ji  .98
.98
addi $r192 $$locbase i208               ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
lw $r193 $$locbase i26                  ; load word
eq $r194 $r193 $one
jnzi $r194 .99
ji  .100
.100
addi $r195 $$locbase i208               ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
lw $r196 $$locbase i26                  ; load word
movi $r197 i2                           ; initialize constant into register
eq $r198 $r196 $r197
jnzi $r198 .101
ji  .102
.102
addi $r199 $$locbase i208               ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
lw $r200 $$locbase i26                  ; load word
movi $r201 i3                           ; initialize constant into register
eq $r202 $r200 $r201
jnzi $r202 .103
ji  .104
.104
addi $r203 $$locbase i208               ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
lw $r204 $$locbase i26                  ; load word
movi $r205 i4                           ; initialize constant into register
eq $r206 $r204 $r205
jnzi $r206 .105
ji  .106
.106
load $r207 data_NonConfigurable_8       ; load constant from data section
rvrt $r207
.105
addi $r208 $$locbase i208               ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
addi $r209 $r208 i8                     ; get offset to aggregate element
addi $r210 $$locbase i1472              ; get offset to local __ptr [slice; 3]
mcpi $r210 $r209 i48                    ; copy memory
addi $r211 $$locbase i928               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r212 $$locbase i688               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r212 $r211 i24                    ; copy memory
addi $r213 $$locbase i408               ; get offset to local __ptr { { ptr, u64, u64 } }
movi $r214 i4                           ; initialize constant into register
 move $$arg0 $r214                       ; [call]: pass argument 0
 movi $$arg0 i4                          ; [call]: pass argument 0
move $$arg1 $r212                       ; [call]: pass argument 1
move $$arg2 $r213                       ; [call]: pass argument 2
fncall .4                               ; [call]: call abi_encode_30
 move $r215 $zero                        ; [call]: return unit value
 movi $r215 i0                           ; [call]: return unit value
addi $r216 $$locbase i1264              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r216 $r213 i24                    ; copy memory
addi $r217 $$locbase i1472              ; get offset to local __ptr [slice; 3]
addi $r218 $$locbase i1264              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r219 $$locbase i1408              ; get offset to local __ptr [slice; 3]
mcpi $r219 $r217 i48                    ; copy memory
addi $r220 $$locbase i1024              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r220 $r218 i24                    ; copy memory
addi $r221 $$locbase i1024              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r222 $$locbase i1096              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r222 $r221 i24                    ; copy memory
 move $r223 $zero                        ; move parameter from branch to block argument
 movi $r223 i0                           ; move parameter from branch to block argument
ji  .107
.107
move $r225 $r223                        ; move parameter from branch to block argument
movi $r226 i3                           ; initialize constant into register
 lt $r227 $r225 $r226
 lt $r227 $r223 $r226
jnzi $r227 .108
ji  .109
.109
addi $r228 $$locbase i1096              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r229 $$locbase i1288              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r229 $r228 i24                    ; copy memory
addi $r230 $$locbase i1288              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r231 $$locbase i776               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r231 $r230 i24                    ; copy memory
move $r232 $r231                        ; move parameter from branch to block argument
ji  .110
.108
addi $r233 $$locbase i1408              ; get offset to local __ptr [slice; 3]
movi $r234 i16                          ; get array element size
mul $r235 $r225 $r234                   ; get offset to array element
add $r235 $r233 $r235                   ; add array element offset to array base
addi $r236 $$locbase i1096              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r237 $$locbase i712               ; get offset to local __ptr slice
mcpi $r237 $r235 i16                    ; copy memory
addi $r238 $$locbase i728               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r238 $r236 i24                    ; copy memory
addi $r239 $$locbase i432               ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r237                       ; [call]: pass argument 0
move $$arg1 $r238                       ; [call]: pass argument 1
move $$arg2 $r239                       ; [call]: pass argument 2
fncall .6                               ; [call]: call abi_encode_36
 move $r240 $zero                        ; [call]: return unit value
 movi $r240 i0                           ; [call]: return unit value
addi $r241 $$locbase i1096              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r241 $r239 i24                    ; copy memory
add $r242 $r225 $one
move $r223 $r242                        ; move parameter from branch to block argument
ji  .107
.103
addi $r244 $$locbase i208               ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
addi $r245 $r244 i40                    ; get offset to aggregate element
addi $r246 $$locbase i1456              ; get offset to local __ptr { u64, u64 }
mcpi $r246 $r245 i16                    ; copy memory
addi $r247 $$locbase i928               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r248 $$locbase i616               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r248 $r247 i24                    ; copy memory
addi $r249 $$locbase i336               ; get offset to local __ptr { { ptr, u64, u64 } }
movi $r250 i3                           ; initialize constant into register
 move $$arg0 $r250                       ; [call]: pass argument 0
 movi $$arg0 i3                          ; [call]: pass argument 0
move $$arg1 $r248                       ; [call]: pass argument 1
move $$arg2 $r249                       ; [call]: pass argument 2
fncall .4                               ; [call]: call abi_encode_30
 move $r251 $zero                        ; [call]: return unit value
 movi $r251 i0                           ; [call]: return unit value
addi $r252 $$locbase i1216              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r252 $r249 i24                    ; copy memory
addi $r253 $$locbase i1456              ; get offset to local __ptr { u64, u64 }
addi $r254 $$locbase i1216              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r255 $$locbase i1392              ; get offset to local __ptr { u64, u64 }
mcpi $r255 $r253 i16                    ; copy memory
addi $r256 $$locbase i1000              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r256 $r254 i24                    ; copy memory
addi $r257 $$locbase i1392              ; get offset to local __ptr { u64, u64 }
lw $r258 $$locbase i174                 ; load word
addi $r259 $$locbase i1000              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r260 $$locbase i640               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r260 $r259 i24                    ; copy memory
addi $r261 $$locbase i360               ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r258                       ; [call]: pass argument 0
move $$arg1 $r260                       ; [call]: pass argument 1
move $$arg2 $r261                       ; [call]: pass argument 2
fncall .4                               ; [call]: call abi_encode_30
 move $r262 $zero                        ; [call]: return unit value
 movi $r262 i0                           ; [call]: return unit value
addi $r263 $$locbase i1072              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r263 $r261 i24                    ; copy memory
addi $r264 $$locbase i1392              ; get offset to local __ptr { u64, u64 }
addi $r265 $r264 i8                     ; get offset to aggregate element
lw $r266 $$locbase i175                 ; load word
addi $r267 $$locbase i1072              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r268 $$locbase i664               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r268 $r267 i24                    ; copy memory
addi $r269 $$locbase i384               ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r266                       ; [call]: pass argument 0
move $$arg1 $r268                       ; [call]: pass argument 1
move $$arg2 $r269                       ; [call]: pass argument 2
fncall .4                               ; [call]: call abi_encode_30
 move $r270 $zero                        ; [call]: return unit value
 movi $r270 i0                           ; [call]: return unit value
addi $r271 $$locbase i1144              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r271 $r269 i24                    ; copy memory
addi $r272 $$locbase i1144              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r273 $$locbase i1240              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r273 $r272 i24                    ; copy memory
addi $r274 $$locbase i1240              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r275 $$locbase i776               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r275 $r274 i24                    ; copy memory
move $r232 $r275                        ; move parameter from branch to block argument
ji  .110
.110
move $r278 $r232                        ; move parameter from branch to block argument
addi $r279 $$locbase i800               ; get offset to local __ptr { { ptr, u64, u64 } }
 mcpi $r279 $r278 i24                    ; copy memory
 mcpi $r279 $r232 i24                    ; copy memory
move $r280 $r279                        ; move parameter from branch to block argument
ji  .111
.101
addi $r281 $$locbase i208               ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
addi $r282 $r281 i55                    ; get offset to aggregate element
lb $r283 $r282 i0                       ; load byte
addi $r284 $$locbase i928               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r285 $$locbase i592               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r285 $r284 i24                    ; copy memory
addi $r286 $$locbase i312               ; get offset to local __ptr { { ptr, u64, u64 } }
movi $r287 i2                           ; initialize constant into register
 move $$arg0 $r287                       ; [call]: pass argument 0
 movi $$arg0 i2                          ; [call]: pass argument 0
move $$arg1 $r285                       ; [call]: pass argument 1
move $$arg2 $r286                       ; [call]: pass argument 2
fncall .4                               ; [call]: call abi_encode_30
 move $r288 $zero                        ; [call]: return unit value
 movi $r288 i0                           ; [call]: return unit value
addi $r289 $$locbase i1168              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r289 $r286 i24                    ; copy memory
addi $r290 $$locbase i1168              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r291 $$locbase i976               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r291 $r290 i24                    ; copy memory
addi $r292 $$locbase i520               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r293 $$locbase i976               ; get offset to local __ptr { { ptr, u64, u64 } }
move $r294 $r293                        ; return value from ASM block with return register buffer
addi $r295 $$locbase i48                ; get offset to local __ptr { ptr, u64, u64 }
 mcpi $r295 $r294 i24                    ; copy memory
 mcpi $r295 $r293 i24                    ; copy memory
addi $r296 $$locbase i136               ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r296 $r295 i24                    ; copy memory
lw $r297 $$locbase i17                  ; load word
addi $r298 $r296 i8                     ; get offset to aggregate element
lw $r299 $$locbase i18                  ; load word
addi $r300 $r296 i16                    ; get offset to aggregate element
lw $r301 $$locbase i19                  ; load word
add $r302 $r301 $one
gt $r303 $r302 $r299
move $r304 $r297                        ; move parameter from branch to block argument
move $r305 $r299                        ; move parameter from branch to block argument
jnzi $r303 .112
ji  .113
.112
movi $r306 i2                           ; initialize constant into register
mul $r307 $r299 $r306
add $r308 $r307 $one
aloc $r308
mcp $hp $r297 $r301
move $r309 $hp                          ; return value from ASM block with return register hp
 move $r304 $r309                        ; move parameter from branch to block argument
 move $r304 $hp                          ; move parameter from branch to block argument
move $r305 $r308                        ; move parameter from branch to block argument
ji  .113
.113
move $r313 $r304                        ; move parameter from branch to block argument
move $r315 $r305                        ; move parameter from branch to block argument
 add $r316 $r313 $r301
 add $r316 $r304 $r301
sb $r316 $r283 i0                       ; store byte
addi $r317 $$locbase i184               ; get offset to local __ptr { ptr, u64, u64 }
sw $$locbase $r313 i23                  ; store word
addi $r318 $r317 i8                     ; get offset to aggregate element
sw $$locbase $r315 i24                  ; store word
addi $r319 $r317 i16                    ; get offset to aggregate element
sw $$locbase $r302 i25                  ; store word
move $r320 $r317                        ; return value from ASM block with return register buffer
addi $r321 $$locbase i72                ; get offset to local __ptr { ptr, u64, u64 }
 mcpi $r321 $r320 i24                    ; copy memory
 mcpi $r321 $r317 i24                    ; copy memory
mcpi $r292 $r321 i24                    ; copy memory
addi $r322 $$locbase i1192              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r322 $r292 i24                    ; copy memory
addi $r323 $$locbase i1192              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r324 $$locbase i800               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r324 $r323 i24                    ; copy memory
move $r280 $r324                        ; move parameter from branch to block argument
ji  .111
.111
move $r327 $r280                        ; move parameter from branch to block argument
addi $r328 $$locbase i824               ; get offset to local __ptr { { ptr, u64, u64 } }
 mcpi $r328 $r327 i24                    ; copy memory
 mcpi $r328 $r280 i24                    ; copy memory
move $r329 $r328                        ; move parameter from branch to block argument
ji  .114
.99
addi $r330 $$locbase i208               ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
addi $r331 $r330 i55                    ; get offset to aggregate element
lb $r332 $r331 i0                       ; load byte
addi $r333 $$locbase i928               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r334 $$locbase i568               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r334 $r333 i24                    ; copy memory
addi $r335 $$locbase i288               ; get offset to local __ptr { { ptr, u64, u64 } }
 move $$arg0 $one                        ; [call]: pass argument 0
 movi $$arg0 i1                          ; [call]: pass argument 0
move $$arg1 $r334                       ; [call]: pass argument 1
move $$arg2 $r335                       ; [call]: pass argument 2
fncall .4                               ; [call]: call abi_encode_30
 move $r336 $zero                        ; [call]: return unit value
 movi $r336 i0                           ; [call]: return unit value
addi $r337 $$locbase i1048              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r337 $r335 i24                    ; copy memory
addi $r338 $$locbase i1048              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r339 $$locbase i952               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r339 $r338 i24                    ; copy memory
addi $r340 $$locbase i496               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r341 $$locbase i952               ; get offset to local __ptr { { ptr, u64, u64 } }
move $r342 $r341                        ; return value from ASM block with return register buffer
 mcpi $$locbase $r342 i24                ; copy memory
 mcpi $$locbase $r341 i24                ; copy memory
addi $r343 $$locbase i112               ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r343 $$locbase i24                ; copy memory
lw $r344 $$locbase i14                  ; load word
addi $r345 $r343 i8                     ; get offset to aggregate element
lw $r346 $$locbase i15                  ; load word
addi $r347 $r343 i16                    ; get offset to aggregate element
lw $r348 $$locbase i16                  ; load word
add $r349 $r348 $one
gt $r350 $r349 $r346
move $r351 $r344                        ; move parameter from branch to block argument
move $r352 $r346                        ; move parameter from branch to block argument
jnzi $r350 .115
ji  .116
.115
movi $r353 i2                           ; initialize constant into register
mul $r354 $r346 $r353
add $r355 $r354 $one
aloc $r355
mcp $hp $r344 $r348
move $r356 $hp                          ; return value from ASM block with return register hp
 move $r351 $r356                        ; move parameter from branch to block argument
 move $r351 $hp                          ; move parameter from branch to block argument
move $r352 $r355                        ; move parameter from branch to block argument
ji  .116
.116
move $r360 $r351                        ; move parameter from branch to block argument
move $r362 $r352                        ; move parameter from branch to block argument
 add $r363 $r360 $r348
 add $r363 $r351 $r348
sb $r363 $r332 i0                       ; store byte
addi $r364 $$locbase i160               ; get offset to local __ptr { ptr, u64, u64 }
sw $$locbase $r360 i20                  ; store word
addi $r365 $r364 i8                     ; get offset to aggregate element
sw $$locbase $r362 i21                  ; store word
addi $r366 $r364 i16                    ; get offset to aggregate element
sw $$locbase $r349 i22                  ; store word
move $r367 $r364                        ; return value from ASM block with return register buffer
addi $r368 $$locbase i24                ; get offset to local __ptr { ptr, u64, u64 }
 mcpi $r368 $r367 i24                    ; copy memory
 mcpi $r368 $r364 i24                    ; copy memory
mcpi $r340 $r368 i24                    ; copy memory
addi $r369 $$locbase i1120              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r369 $r340 i24                    ; copy memory
addi $r370 $$locbase i1120              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r371 $$locbase i824               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r371 $r370 i24                    ; copy memory
move $r329 $r371                        ; move parameter from branch to block argument
ji  .114
.114
move $r374 $r329                        ; move parameter from branch to block argument
addi $r375 $$locbase i848               ; get offset to local __ptr { { ptr, u64, u64 } }
 mcpi $r375 $r374 i24                    ; copy memory
 mcpi $r375 $r329 i24                    ; copy memory
move $r376 $r375                        ; move parameter from branch to block argument
ji  .117
.97
addi $r377 $$locbase i928               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r378 $$locbase i544               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r378 $r377 i24                    ; copy memory
addi $r379 $$locbase i264               ; get offset to local __ptr { { ptr, u64, u64 } }
 move $$arg0 $zero                       ; [call]: pass argument 0
 movi $$arg0 i0                          ; [call]: pass argument 0
move $$arg1 $r378                       ; [call]: pass argument 1
move $$arg2 $r379                       ; [call]: pass argument 2
fncall .4                               ; [call]: call abi_encode_30
 move $r380 $zero                        ; [call]: return unit value
 movi $r380 i0                           ; [call]: return unit value
addi $r381 $$locbase i848               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r381 $r379 i24                    ; copy memory
move $r376 $r381                        ; move parameter from branch to block argument
ji  .117
.117
move $r384 $r376                        ; move parameter from branch to block argument
addi $r385 $$locbase i1312              ; get offset to local __ptr { { ptr, u64, u64 } }
 mcpi $r385 $r384 i24                    ; copy memory
 mcpi $r385 $r376 i24                    ; copy memory
addi $r386 $$locbase i1312              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r387 $$locbase i904               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r387 $r386 i24                    ; copy memory
addi $r388 $$locbase i904               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r389 $$locbase i752               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r389 $r388 i24                    ; copy memory
addi $r390 $$locbase i480               ; get offset to local __ptr slice
move $$arg0 $r389                       ; [call]: pass argument 0
move $$arg1 $r390                       ; [call]: pass argument 1
fncall .10                              ; [call]: call as_raw_slice_39
 move $r391 $zero                        ; [call]: return unit value
 movi $r391 i0                           ; [call]: return unit value
addi $r392 $$locbase i872               ; get offset to local __ptr slice
mcpi $r392 $r390 i16                    ; copy memory
move $r393 $r392                        ; move parameter from branch to block argument
ji  .118
.95
addi $r394 $$locbase i888               ; get offset to local __ptr { __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }, u64 }
sw $$locbase $r168 i111                 ; store word
addi $r395 $r394 i8                     ; get offset to aggregate element
movi $r396 i56                          ; initialize constant into register
sw $$locbase $r396 i112                 ; store word
addi $r397 $$locbase i96                ; get offset to local __ptr { __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }, u64 }
mcpi $r397 $r394 i16                    ; copy memory
addi $r398 $$locbase i872               ; get offset to local __ptr slice
mcpi $r398 $r397 i16                    ; copy memory
move $r393 $r398                        ; move parameter from branch to block argument
ji  .118
.118
move $r401 $r393                        ; move parameter from branch to block argument
 mcpi $r169 $r401 i16                    ; copy memory
 mcpi $r169 $r393 i16                    ; copy memory
ji  .3
.3
cfsi i1520                              ; free 1520 bytes for locals and 0 slots for extra call arguments
move $$reta $r170                       ; restore return address
popa .2                                 ; restore all registers
jal $zero $$reta i0                     ; return from call
DIFF------------------------------
.program:
.2                                      ; --- start of function: encode_allow_alias_12 ---
pusha .2                                ; save all registers
move $$locbase $sp                      ; save locals base register for function encode_allow_alias_12
cfei i1520                              ; allocate 1520 bytes for locals and 0 slots for call arguments
move $r168 $$arg0                       ; save argument 0 (item)
move $r169 $$arg1                       ; save argument 1 (__ret_value)
move $r170 $$reta                       ; save return address
.88
movi $r171 i0                           ; move parameter from branch to block argument
.90
 move $r175 $r171                        ; move parameter from branch to block argument
 jnzi $r171 .91
 movi $r175 i0                           ; move parameter from branch to block argument
 
ji  .92
.91
movi $r175 i1                           ; move parameter from branch to block argument
.92
move $r179 $r175                        ; move parameter from branch to block argument
jnzi $r175 .93
ji  .94
.93
movi $r179 i0                           ; move parameter from branch to block argument
.94
jnzi $r179 .95
.96
addi $r183 $$locbase i456               ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r183                       ; [call]: pass argument 0
fncall .8                               ; [call]: call new_38
addi $r185 $$locbase i1336              ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
mcpi $r185 $r168 i56                    ; copy memory
addi $r186 $$locbase i928               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r186 $r183 i24                    ; copy memory
addi $r187 $$locbase i1336              ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
addi $r188 $$locbase i208               ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
mcpi $r188 $r187 i56                    ; copy memory
lw $r190 $$locbase i26                  ; load word
eq $r191 $r190 $zero
jnzi $r191 .97
.98
lw $r193 $$locbase i26                  ; load word
eq $r194 $r193 $one
jnzi $r194 .99
.100
lw $r196 $$locbase i26                  ; load word
movi $r197 i2                           ; initialize constant into register
eq $r198 $r196 $r197
jnzi $r198 .101
.102
lw $r200 $$locbase i26                  ; load word
movi $r201 i3                           ; initialize constant into register
eq $r202 $r200 $r201
jnzi $r202 .103
.104
lw $r204 $$locbase i26                  ; load word
movi $r205 i4                           ; initialize constant into register
eq $r206 $r204 $r205
jnzi $r206 .105
.106
load $r207 data_NonConfigurable_8       ; load constant from data section
rvrt $r207
.105
addi $r208 $$locbase i208               ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
addi $r209 $r208 i8                     ; get offset to aggregate element
addi $r210 $$locbase i1472              ; get offset to local __ptr [slice; 3]
mcpi $r210 $r209 i48                    ; copy memory
addi $r211 $$locbase i928               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r212 $$locbase i688               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r212 $r211 i24                    ; copy memory
addi $r213 $$locbase i408               ; get offset to local __ptr { { ptr, u64, u64 } }
movi $$arg0 i4                          ; [call]: pass argument 0
move $$arg1 $r212                       ; [call]: pass argument 1
move $$arg2 $r213                       ; [call]: pass argument 2
fncall .4                               ; [call]: call abi_encode_30
addi $r216 $$locbase i1264              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r216 $r213 i24                    ; copy memory
addi $r217 $$locbase i1472              ; get offset to local __ptr [slice; 3]
addi $r218 $$locbase i1264              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r219 $$locbase i1408              ; get offset to local __ptr [slice; 3]
mcpi $r219 $r217 i48                    ; copy memory
addi $r220 $$locbase i1024              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r220 $r218 i24                    ; copy memory
addi $r221 $$locbase i1024              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r222 $$locbase i1096              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r222 $r221 i24                    ; copy memory
movi $r223 i0                           ; move parameter from branch to block argument
.107
move $r225 $r223                        ; move parameter from branch to block argument
movi $r226 i3                           ; initialize constant into register
lt $r227 $r223 $r226
jnzi $r227 .108
.109
addi $r228 $$locbase i1096              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r229 $$locbase i1288              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r229 $r228 i24                    ; copy memory
addi $r230 $$locbase i1288              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r231 $$locbase i776               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r231 $r230 i24                    ; copy memory
move $r232 $r231                        ; move parameter from branch to block argument
ji  .110
.108
addi $r233 $$locbase i1408              ; get offset to local __ptr [slice; 3]
movi $r234 i16                          ; get array element size
mul $r235 $r225 $r234                   ; get offset to array element
add $r235 $r233 $r235                   ; add array element offset to array base
addi $r236 $$locbase i1096              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r237 $$locbase i712               ; get offset to local __ptr slice
mcpi $r237 $r235 i16                    ; copy memory
addi $r238 $$locbase i728               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r238 $r236 i24                    ; copy memory
addi $r239 $$locbase i432               ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r237                       ; [call]: pass argument 0
move $$arg1 $r238                       ; [call]: pass argument 1
move $$arg2 $r239                       ; [call]: pass argument 2
fncall .6                               ; [call]: call abi_encode_36
addi $r241 $$locbase i1096              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r241 $r239 i24                    ; copy memory
add $r242 $r225 $one
move $r223 $r242                        ; move parameter from branch to block argument
ji  .107
.103
addi $r244 $$locbase i208               ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
addi $r245 $r244 i40                    ; get offset to aggregate element
addi $r246 $$locbase i1456              ; get offset to local __ptr { u64, u64 }
mcpi $r246 $r245 i16                    ; copy memory
addi $r247 $$locbase i928               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r248 $$locbase i616               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r248 $r247 i24                    ; copy memory
addi $r249 $$locbase i336               ; get offset to local __ptr { { ptr, u64, u64 } }
movi $$arg0 i3                          ; [call]: pass argument 0
move $$arg1 $r248                       ; [call]: pass argument 1
move $$arg2 $r249                       ; [call]: pass argument 2
fncall .4                               ; [call]: call abi_encode_30
addi $r252 $$locbase i1216              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r252 $r249 i24                    ; copy memory
addi $r253 $$locbase i1456              ; get offset to local __ptr { u64, u64 }
addi $r254 $$locbase i1216              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r255 $$locbase i1392              ; get offset to local __ptr { u64, u64 }
mcpi $r255 $r253 i16                    ; copy memory
addi $r256 $$locbase i1000              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r256 $r254 i24                    ; copy memory
lw $r258 $$locbase i174                 ; load word
addi $r259 $$locbase i1000              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r260 $$locbase i640               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r260 $r259 i24                    ; copy memory
addi $r261 $$locbase i360               ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r258                       ; [call]: pass argument 0
move $$arg1 $r260                       ; [call]: pass argument 1
move $$arg2 $r261                       ; [call]: pass argument 2
fncall .4                               ; [call]: call abi_encode_30
addi $r263 $$locbase i1072              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r263 $r261 i24                    ; copy memory
lw $r266 $$locbase i175                 ; load word
addi $r267 $$locbase i1072              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r268 $$locbase i664               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r268 $r267 i24                    ; copy memory
addi $r269 $$locbase i384               ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r266                       ; [call]: pass argument 0
move $$arg1 $r268                       ; [call]: pass argument 1
move $$arg2 $r269                       ; [call]: pass argument 2
fncall .4                               ; [call]: call abi_encode_30
addi $r271 $$locbase i1144              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r271 $r269 i24                    ; copy memory
addi $r272 $$locbase i1144              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r273 $$locbase i1240              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r273 $r272 i24                    ; copy memory
addi $r274 $$locbase i1240              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r275 $$locbase i776               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r275 $r274 i24                    ; copy memory
move $r232 $r275                        ; move parameter from branch to block argument
.110
addi $r279 $$locbase i800               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r279 $r232 i24                    ; copy memory
move $r280 $r279                        ; move parameter from branch to block argument
ji  .111
.101
addi $r281 $$locbase i208               ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
addi $r282 $r281 i55                    ; get offset to aggregate element
lb $r283 $r282 i0                       ; load byte
addi $r284 $$locbase i928               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r285 $$locbase i592               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r285 $r284 i24                    ; copy memory
addi $r286 $$locbase i312               ; get offset to local __ptr { { ptr, u64, u64 } }
movi $$arg0 i2                          ; [call]: pass argument 0
move $$arg1 $r285                       ; [call]: pass argument 1
move $$arg2 $r286                       ; [call]: pass argument 2
fncall .4                               ; [call]: call abi_encode_30
addi $r289 $$locbase i1168              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r289 $r286 i24                    ; copy memory
addi $r290 $$locbase i1168              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r291 $$locbase i976               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r291 $r290 i24                    ; copy memory
addi $r292 $$locbase i520               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r293 $$locbase i976               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r295 $$locbase i48                ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r295 $r293 i24                    ; copy memory
addi $r296 $$locbase i136               ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r296 $r295 i24                    ; copy memory
lw $r297 $$locbase i17                  ; load word
lw $r299 $$locbase i18                  ; load word
lw $r301 $$locbase i19                  ; load word
add $r302 $r301 $one
gt $r303 $r302 $r299
move $r304 $r297                        ; move parameter from branch to block argument
move $r305 $r299                        ; move parameter from branch to block argument
jnzi $r303 .112
ji  .113
.112
movi $r306 i2                           ; initialize constant into register
mul $r307 $r299 $r306
add $r308 $r307 $one
aloc $r308
mcp $hp $r297 $r301
move $r304 $hp                          ; move parameter from branch to block argument
move $r305 $r308                        ; move parameter from branch to block argument
.113
move $r313 $r304                        ; move parameter from branch to block argument
move $r315 $r305                        ; move parameter from branch to block argument
add $r316 $r304 $r301
sb $r316 $r283 i0                       ; store byte
addi $r317 $$locbase i184               ; get offset to local __ptr { ptr, u64, u64 }
sw $$locbase $r313 i23                  ; store word
sw $$locbase $r315 i24                  ; store word
sw $$locbase $r302 i25                  ; store word
addi $r321 $$locbase i72                ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r321 $r317 i24                    ; copy memory
mcpi $r292 $r321 i24                    ; copy memory
addi $r322 $$locbase i1192              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r322 $r292 i24                    ; copy memory
addi $r323 $$locbase i1192              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r324 $$locbase i800               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r324 $r323 i24                    ; copy memory
move $r280 $r324                        ; move parameter from branch to block argument
.111
addi $r328 $$locbase i824               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r328 $r280 i24                    ; copy memory
move $r329 $r328                        ; move parameter from branch to block argument
ji  .114
.99
addi $r330 $$locbase i208               ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
addi $r331 $r330 i55                    ; get offset to aggregate element
lb $r332 $r331 i0                       ; load byte
addi $r333 $$locbase i928               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r334 $$locbase i568               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r334 $r333 i24                    ; copy memory
addi $r335 $$locbase i288               ; get offset to local __ptr { { ptr, u64, u64 } }
movi $$arg0 i1                          ; [call]: pass argument 0
move $$arg1 $r334                       ; [call]: pass argument 1
move $$arg2 $r335                       ; [call]: pass argument 2
fncall .4                               ; [call]: call abi_encode_30
addi $r337 $$locbase i1048              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r337 $r335 i24                    ; copy memory
addi $r338 $$locbase i1048              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r339 $$locbase i952               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r339 $r338 i24                    ; copy memory
addi $r340 $$locbase i496               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r341 $$locbase i952               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $$locbase $r341 i24                ; copy memory
addi $r343 $$locbase i112               ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r343 $$locbase i24                ; copy memory
lw $r344 $$locbase i14                  ; load word
lw $r346 $$locbase i15                  ; load word
lw $r348 $$locbase i16                  ; load word
add $r349 $r348 $one
gt $r350 $r349 $r346
move $r351 $r344                        ; move parameter from branch to block argument
move $r352 $r346                        ; move parameter from branch to block argument
jnzi $r350 .115
ji  .116
.115
movi $r353 i2                           ; initialize constant into register
mul $r354 $r346 $r353
add $r355 $r354 $one
aloc $r355
mcp $hp $r344 $r348
move $r351 $hp                          ; move parameter from branch to block argument
move $r352 $r355                        ; move parameter from branch to block argument
.116
move $r360 $r351                        ; move parameter from branch to block argument
move $r362 $r352                        ; move parameter from branch to block argument
add $r363 $r351 $r348
sb $r363 $r332 i0                       ; store byte
addi $r364 $$locbase i160               ; get offset to local __ptr { ptr, u64, u64 }
sw $$locbase $r360 i20                  ; store word
sw $$locbase $r362 i21                  ; store word
sw $$locbase $r349 i22                  ; store word
addi $r368 $$locbase i24                ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r368 $r364 i24                    ; copy memory
mcpi $r340 $r368 i24                    ; copy memory
addi $r369 $$locbase i1120              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r369 $r340 i24                    ; copy memory
addi $r370 $$locbase i1120              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r371 $$locbase i824               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r371 $r370 i24                    ; copy memory
move $r329 $r371                        ; move parameter from branch to block argument
.114
addi $r375 $$locbase i848               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r375 $r329 i24                    ; copy memory
move $r376 $r375                        ; move parameter from branch to block argument
ji  .117
.97
addi $r377 $$locbase i928               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r378 $$locbase i544               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r378 $r377 i24                    ; copy memory
addi $r379 $$locbase i264               ; get offset to local __ptr { { ptr, u64, u64 } }
movi $$arg0 i0                          ; [call]: pass argument 0
move $$arg1 $r378                       ; [call]: pass argument 1
move $$arg2 $r379                       ; [call]: pass argument 2
fncall .4                               ; [call]: call abi_encode_30
addi $r381 $$locbase i848               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r381 $r379 i24                    ; copy memory
move $r376 $r381                        ; move parameter from branch to block argument
.117
addi $r385 $$locbase i1312              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r385 $r376 i24                    ; copy memory
addi $r386 $$locbase i1312              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r387 $$locbase i904               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r387 $r386 i24                    ; copy memory
addi $r388 $$locbase i904               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r389 $$locbase i752               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r389 $r388 i24                    ; copy memory
addi $r390 $$locbase i480               ; get offset to local __ptr slice
move $$arg0 $r389                       ; [call]: pass argument 0
move $$arg1 $r390                       ; [call]: pass argument 1
fncall .10                              ; [call]: call as_raw_slice_39
addi $r392 $$locbase i872               ; get offset to local __ptr slice
mcpi $r392 $r390 i16                    ; copy memory
move $r393 $r392                        ; move parameter from branch to block argument
ji  .118
.95
addi $r394 $$locbase i888               ; get offset to local __ptr { __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }, u64 }
sw $$locbase $r168 i111                 ; store word
movi $r396 i56                          ; initialize constant into register
sw $$locbase $r396 i112                 ; store word
addi $r397 $$locbase i96                ; get offset to local __ptr { __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }, u64 }
mcpi $r397 $r394 i16                    ; copy memory
addi $r398 $$locbase i872               ; get offset to local __ptr slice
mcpi $r398 $r397 i16                    ; copy memory
move $r393 $r398                        ; move parameter from branch to block argument
.118
mcpi $r169 $r393 i16                    ; copy memory
.3
cfsi i1520                              ; free 1520 bytes for locals and 0 slots for extra call arguments
move $$reta $r170                       ; restore return address
popa .2                                 ; restore all registers
jal $zero $$reta i0                     ; return from call
DIFF------------------------------
.program:
.2                                      ; --- start of function: encode_allow_alias_12 ---
pusha .2                                ; save all registers
move $$locbase $sp                      ; save locals base register for function encode_allow_alias_12
cfei i1520                              ; allocate 1520 bytes for locals and 0 slots for call arguments
move $r168 $$arg0                       ; save argument 0 (item)
move $r169 $$arg1                       ; save argument 1 (__ret_value)
move $r170 $$reta                       ; save return address
.88
.90
movi $r175 i0                           ; move parameter from branch to block argument
.92
 move $r179 $r175                        ; move parameter from branch to block argument
 jnzi $r175 .93
 movi $r179 i0                           ; move parameter from branch to block argument
 
ji  .94
.93
 movi $r179 i0                           ; move parameter from branch to block argument
                                         ; move parameter from branch to block argument
.94
jnzi $r179 .95
.96
addi $r183 $$locbase i456               ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r183                       ; [call]: pass argument 0
fncall .8                               ; [call]: call new_38
addi $r185 $$locbase i1336              ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
mcpi $r185 $r168 i56                    ; copy memory
addi $r186 $$locbase i928               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r186 $r183 i24                    ; copy memory
addi $r187 $$locbase i1336              ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
addi $r188 $$locbase i208               ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
mcpi $r188 $r187 i56                    ; copy memory
lw $r190 $$locbase i26                  ; load word
eq $r191 $r190 $zero
jnzi $r191 .97
.98
lw $r193 $$locbase i26                  ; load word
eq $r194 $r193 $one
jnzi $r194 .99
.100
lw $r196 $$locbase i26                  ; load word
movi $r197 i2                           ; initialize constant into register
eq $r198 $r196 $r197
jnzi $r198 .101
.102
lw $r200 $$locbase i26                  ; load word
movi $r201 i3                           ; initialize constant into register
eq $r202 $r200 $r201
jnzi $r202 .103
.104
lw $r204 $$locbase i26                  ; load word
movi $r205 i4                           ; initialize constant into register
eq $r206 $r204 $r205
jnzi $r206 .105
.106
load $r207 data_NonConfigurable_8       ; load constant from data section
rvrt $r207
.105
addi $r208 $$locbase i208               ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
addi $r209 $r208 i8                     ; get offset to aggregate element
addi $r210 $$locbase i1472              ; get offset to local __ptr [slice; 3]
mcpi $r210 $r209 i48                    ; copy memory
addi $r211 $$locbase i928               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r212 $$locbase i688               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r212 $r211 i24                    ; copy memory
addi $r213 $$locbase i408               ; get offset to local __ptr { { ptr, u64, u64 } }
movi $$arg0 i4                          ; [call]: pass argument 0
move $$arg1 $r212                       ; [call]: pass argument 1
move $$arg2 $r213                       ; [call]: pass argument 2
fncall .4                               ; [call]: call abi_encode_30
addi $r216 $$locbase i1264              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r216 $r213 i24                    ; copy memory
addi $r217 $$locbase i1472              ; get offset to local __ptr [slice; 3]
addi $r218 $$locbase i1264              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r219 $$locbase i1408              ; get offset to local __ptr [slice; 3]
mcpi $r219 $r217 i48                    ; copy memory
addi $r220 $$locbase i1024              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r220 $r218 i24                    ; copy memory
addi $r221 $$locbase i1024              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r222 $$locbase i1096              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r222 $r221 i24                    ; copy memory
movi $r223 i0                           ; move parameter from branch to block argument
.107
move $r225 $r223                        ; move parameter from branch to block argument
movi $r226 i3                           ; initialize constant into register
lt $r227 $r223 $r226
jnzi $r227 .108
.109
addi $r228 $$locbase i1096              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r229 $$locbase i1288              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r229 $r228 i24                    ; copy memory
addi $r230 $$locbase i1288              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r231 $$locbase i776               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r231 $r230 i24                    ; copy memory
move $r232 $r231                        ; move parameter from branch to block argument
ji  .110
.108
addi $r233 $$locbase i1408              ; get offset to local __ptr [slice; 3]
movi $r234 i16                          ; get array element size
mul $r235 $r225 $r234                   ; get offset to array element
add $r235 $r233 $r235                   ; add array element offset to array base
addi $r236 $$locbase i1096              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r237 $$locbase i712               ; get offset to local __ptr slice
mcpi $r237 $r235 i16                    ; copy memory
addi $r238 $$locbase i728               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r238 $r236 i24                    ; copy memory
addi $r239 $$locbase i432               ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r237                       ; [call]: pass argument 0
move $$arg1 $r238                       ; [call]: pass argument 1
move $$arg2 $r239                       ; [call]: pass argument 2
fncall .6                               ; [call]: call abi_encode_36
addi $r241 $$locbase i1096              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r241 $r239 i24                    ; copy memory
add $r242 $r225 $one
move $r223 $r242                        ; move parameter from branch to block argument
ji  .107
.103
addi $r244 $$locbase i208               ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
addi $r245 $r244 i40                    ; get offset to aggregate element
addi $r246 $$locbase i1456              ; get offset to local __ptr { u64, u64 }
mcpi $r246 $r245 i16                    ; copy memory
addi $r247 $$locbase i928               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r248 $$locbase i616               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r248 $r247 i24                    ; copy memory
addi $r249 $$locbase i336               ; get offset to local __ptr { { ptr, u64, u64 } }
movi $$arg0 i3                          ; [call]: pass argument 0
move $$arg1 $r248                       ; [call]: pass argument 1
move $$arg2 $r249                       ; [call]: pass argument 2
fncall .4                               ; [call]: call abi_encode_30
addi $r252 $$locbase i1216              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r252 $r249 i24                    ; copy memory
addi $r253 $$locbase i1456              ; get offset to local __ptr { u64, u64 }
addi $r254 $$locbase i1216              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r255 $$locbase i1392              ; get offset to local __ptr { u64, u64 }
mcpi $r255 $r253 i16                    ; copy memory
addi $r256 $$locbase i1000              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r256 $r254 i24                    ; copy memory
lw $r258 $$locbase i174                 ; load word
addi $r259 $$locbase i1000              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r260 $$locbase i640               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r260 $r259 i24                    ; copy memory
addi $r261 $$locbase i360               ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r258                       ; [call]: pass argument 0
move $$arg1 $r260                       ; [call]: pass argument 1
move $$arg2 $r261                       ; [call]: pass argument 2
fncall .4                               ; [call]: call abi_encode_30
addi $r263 $$locbase i1072              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r263 $r261 i24                    ; copy memory
lw $r266 $$locbase i175                 ; load word
addi $r267 $$locbase i1072              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r268 $$locbase i664               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r268 $r267 i24                    ; copy memory
addi $r269 $$locbase i384               ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r266                       ; [call]: pass argument 0
move $$arg1 $r268                       ; [call]: pass argument 1
move $$arg2 $r269                       ; [call]: pass argument 2
fncall .4                               ; [call]: call abi_encode_30
addi $r271 $$locbase i1144              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r271 $r269 i24                    ; copy memory
addi $r272 $$locbase i1144              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r273 $$locbase i1240              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r273 $r272 i24                    ; copy memory
addi $r274 $$locbase i1240              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r275 $$locbase i776               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r275 $r274 i24                    ; copy memory
move $r232 $r275                        ; move parameter from branch to block argument
.110
addi $r279 $$locbase i800               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r279 $r232 i24                    ; copy memory
move $r280 $r279                        ; move parameter from branch to block argument
ji  .111
.101
addi $r281 $$locbase i208               ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
addi $r282 $r281 i55                    ; get offset to aggregate element
lb $r283 $r282 i0                       ; load byte
addi $r284 $$locbase i928               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r285 $$locbase i592               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r285 $r284 i24                    ; copy memory
addi $r286 $$locbase i312               ; get offset to local __ptr { { ptr, u64, u64 } }
movi $$arg0 i2                          ; [call]: pass argument 0
move $$arg1 $r285                       ; [call]: pass argument 1
move $$arg2 $r286                       ; [call]: pass argument 2
fncall .4                               ; [call]: call abi_encode_30
addi $r289 $$locbase i1168              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r289 $r286 i24                    ; copy memory
addi $r290 $$locbase i1168              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r291 $$locbase i976               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r291 $r290 i24                    ; copy memory
addi $r292 $$locbase i520               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r293 $$locbase i976               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r295 $$locbase i48                ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r295 $r293 i24                    ; copy memory
addi $r296 $$locbase i136               ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r296 $r295 i24                    ; copy memory
lw $r297 $$locbase i17                  ; load word
lw $r299 $$locbase i18                  ; load word
lw $r301 $$locbase i19                  ; load word
add $r302 $r301 $one
gt $r303 $r302 $r299
move $r304 $r297                        ; move parameter from branch to block argument
move $r305 $r299                        ; move parameter from branch to block argument
jnzi $r303 .112
ji  .113
.112
movi $r306 i2                           ; initialize constant into register
mul $r307 $r299 $r306
add $r308 $r307 $one
aloc $r308
mcp $hp $r297 $r301
move $r304 $hp                          ; move parameter from branch to block argument
move $r305 $r308                        ; move parameter from branch to block argument
.113
move $r313 $r304                        ; move parameter from branch to block argument
move $r315 $r305                        ; move parameter from branch to block argument
add $r316 $r304 $r301
sb $r316 $r283 i0                       ; store byte
addi $r317 $$locbase i184               ; get offset to local __ptr { ptr, u64, u64 }
sw $$locbase $r313 i23                  ; store word
sw $$locbase $r315 i24                  ; store word
sw $$locbase $r302 i25                  ; store word
addi $r321 $$locbase i72                ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r321 $r317 i24                    ; copy memory
mcpi $r292 $r321 i24                    ; copy memory
addi $r322 $$locbase i1192              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r322 $r292 i24                    ; copy memory
addi $r323 $$locbase i1192              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r324 $$locbase i800               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r324 $r323 i24                    ; copy memory
move $r280 $r324                        ; move parameter from branch to block argument
.111
addi $r328 $$locbase i824               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r328 $r280 i24                    ; copy memory
move $r329 $r328                        ; move parameter from branch to block argument
ji  .114
.99
addi $r330 $$locbase i208               ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
addi $r331 $r330 i55                    ; get offset to aggregate element
lb $r332 $r331 i0                       ; load byte
addi $r333 $$locbase i928               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r334 $$locbase i568               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r334 $r333 i24                    ; copy memory
addi $r335 $$locbase i288               ; get offset to local __ptr { { ptr, u64, u64 } }
movi $$arg0 i1                          ; [call]: pass argument 0
move $$arg1 $r334                       ; [call]: pass argument 1
move $$arg2 $r335                       ; [call]: pass argument 2
fncall .4                               ; [call]: call abi_encode_30
addi $r337 $$locbase i1048              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r337 $r335 i24                    ; copy memory
addi $r338 $$locbase i1048              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r339 $$locbase i952               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r339 $r338 i24                    ; copy memory
addi $r340 $$locbase i496               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r341 $$locbase i952               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $$locbase $r341 i24                ; copy memory
addi $r343 $$locbase i112               ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r343 $$locbase i24                ; copy memory
lw $r344 $$locbase i14                  ; load word
lw $r346 $$locbase i15                  ; load word
lw $r348 $$locbase i16                  ; load word
add $r349 $r348 $one
gt $r350 $r349 $r346
move $r351 $r344                        ; move parameter from branch to block argument
move $r352 $r346                        ; move parameter from branch to block argument
jnzi $r350 .115
ji  .116
.115
movi $r353 i2                           ; initialize constant into register
mul $r354 $r346 $r353
add $r355 $r354 $one
aloc $r355
mcp $hp $r344 $r348
move $r351 $hp                          ; move parameter from branch to block argument
move $r352 $r355                        ; move parameter from branch to block argument
.116
move $r360 $r351                        ; move parameter from branch to block argument
move $r362 $r352                        ; move parameter from branch to block argument
add $r363 $r351 $r348
sb $r363 $r332 i0                       ; store byte
addi $r364 $$locbase i160               ; get offset to local __ptr { ptr, u64, u64 }
sw $$locbase $r360 i20                  ; store word
sw $$locbase $r362 i21                  ; store word
sw $$locbase $r349 i22                  ; store word
addi $r368 $$locbase i24                ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r368 $r364 i24                    ; copy memory
mcpi $r340 $r368 i24                    ; copy memory
addi $r369 $$locbase i1120              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r369 $r340 i24                    ; copy memory
addi $r370 $$locbase i1120              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r371 $$locbase i824               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r371 $r370 i24                    ; copy memory
move $r329 $r371                        ; move parameter from branch to block argument
.114
addi $r375 $$locbase i848               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r375 $r329 i24                    ; copy memory
move $r376 $r375                        ; move parameter from branch to block argument
ji  .117
.97
addi $r377 $$locbase i928               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r378 $$locbase i544               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r378 $r377 i24                    ; copy memory
addi $r379 $$locbase i264               ; get offset to local __ptr { { ptr, u64, u64 } }
movi $$arg0 i0                          ; [call]: pass argument 0
move $$arg1 $r378                       ; [call]: pass argument 1
move $$arg2 $r379                       ; [call]: pass argument 2
fncall .4                               ; [call]: call abi_encode_30
addi $r381 $$locbase i848               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r381 $r379 i24                    ; copy memory
move $r376 $r381                        ; move parameter from branch to block argument
.117
addi $r385 $$locbase i1312              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r385 $r376 i24                    ; copy memory
addi $r386 $$locbase i1312              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r387 $$locbase i904               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r387 $r386 i24                    ; copy memory
addi $r388 $$locbase i904               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r389 $$locbase i752               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r389 $r388 i24                    ; copy memory
addi $r390 $$locbase i480               ; get offset to local __ptr slice
move $$arg0 $r389                       ; [call]: pass argument 0
move $$arg1 $r390                       ; [call]: pass argument 1
fncall .10                              ; [call]: call as_raw_slice_39
addi $r392 $$locbase i872               ; get offset to local __ptr slice
mcpi $r392 $r390 i16                    ; copy memory
move $r393 $r392                        ; move parameter from branch to block argument
ji  .118
.95
addi $r394 $$locbase i888               ; get offset to local __ptr { __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }, u64 }
sw $$locbase $r168 i111                 ; store word
movi $r396 i56                          ; initialize constant into register
sw $$locbase $r396 i112                 ; store word
addi $r397 $$locbase i96                ; get offset to local __ptr { __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }, u64 }
mcpi $r397 $r394 i16                    ; copy memory
addi $r398 $$locbase i872               ; get offset to local __ptr slice
mcpi $r398 $r397 i16                    ; copy memory
move $r393 $r398                        ; move parameter from branch to block argument
.118
mcpi $r169 $r393 i16                    ; copy memory
.3
cfsi i1520                              ; free 1520 bytes for locals and 0 slots for extra call arguments
move $$reta $r170                       ; restore return address
popa .2                                 ; restore all registers
jal $zero $$reta i0                     ; return from call
DIFF------------------------------
.program:
.2                                      ; --- start of function: encode_allow_alias_12 ---
pusha .2                                ; save all registers
move $$locbase $sp                      ; save locals base register for function encode_allow_alias_12
cfei i1520                              ; allocate 1520 bytes for locals and 0 slots for call arguments
move $r168 $$arg0                       ; save argument 0 (item)
move $r169 $$arg1                       ; save argument 1 (__ret_value)
move $r170 $$reta                       ; save return address
.88
.90
.92
movi $r179 i0                           ; move parameter from branch to block argument
.94
 jnzi $r179 .95
 
.96
addi $r183 $$locbase i456               ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r183                       ; [call]: pass argument 0
fncall .8                               ; [call]: call new_38
addi $r185 $$locbase i1336              ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
mcpi $r185 $r168 i56                    ; copy memory
addi $r186 $$locbase i928               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r186 $r183 i24                    ; copy memory
addi $r187 $$locbase i1336              ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
addi $r188 $$locbase i208               ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
mcpi $r188 $r187 i56                    ; copy memory
lw $r190 $$locbase i26                  ; load word
eq $r191 $r190 $zero
jnzi $r191 .97
.98
lw $r193 $$locbase i26                  ; load word
eq $r194 $r193 $one
jnzi $r194 .99
.100
lw $r196 $$locbase i26                  ; load word
movi $r197 i2                           ; initialize constant into register
eq $r198 $r196 $r197
jnzi $r198 .101
.102
lw $r200 $$locbase i26                  ; load word
movi $r201 i3                           ; initialize constant into register
eq $r202 $r200 $r201
jnzi $r202 .103
.104
lw $r204 $$locbase i26                  ; load word
movi $r205 i4                           ; initialize constant into register
eq $r206 $r204 $r205
jnzi $r206 .105
.106
load $r207 data_NonConfigurable_8       ; load constant from data section
rvrt $r207
.105
addi $r208 $$locbase i208               ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
addi $r209 $r208 i8                     ; get offset to aggregate element
addi $r210 $$locbase i1472              ; get offset to local __ptr [slice; 3]
mcpi $r210 $r209 i48                    ; copy memory
addi $r211 $$locbase i928               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r212 $$locbase i688               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r212 $r211 i24                    ; copy memory
addi $r213 $$locbase i408               ; get offset to local __ptr { { ptr, u64, u64 } }
movi $$arg0 i4                          ; [call]: pass argument 0
move $$arg1 $r212                       ; [call]: pass argument 1
move $$arg2 $r213                       ; [call]: pass argument 2
fncall .4                               ; [call]: call abi_encode_30
addi $r216 $$locbase i1264              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r216 $r213 i24                    ; copy memory
addi $r217 $$locbase i1472              ; get offset to local __ptr [slice; 3]
addi $r218 $$locbase i1264              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r219 $$locbase i1408              ; get offset to local __ptr [slice; 3]
mcpi $r219 $r217 i48                    ; copy memory
addi $r220 $$locbase i1024              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r220 $r218 i24                    ; copy memory
addi $r221 $$locbase i1024              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r222 $$locbase i1096              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r222 $r221 i24                    ; copy memory
movi $r223 i0                           ; move parameter from branch to block argument
.107
move $r225 $r223                        ; move parameter from branch to block argument
movi $r226 i3                           ; initialize constant into register
lt $r227 $r223 $r226
jnzi $r227 .108
.109
addi $r228 $$locbase i1096              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r229 $$locbase i1288              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r229 $r228 i24                    ; copy memory
addi $r230 $$locbase i1288              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r231 $$locbase i776               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r231 $r230 i24                    ; copy memory
move $r232 $r231                        ; move parameter from branch to block argument
ji  .110
.108
addi $r233 $$locbase i1408              ; get offset to local __ptr [slice; 3]
movi $r234 i16                          ; get array element size
mul $r235 $r225 $r234                   ; get offset to array element
add $r235 $r233 $r235                   ; add array element offset to array base
addi $r236 $$locbase i1096              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r237 $$locbase i712               ; get offset to local __ptr slice
mcpi $r237 $r235 i16                    ; copy memory
addi $r238 $$locbase i728               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r238 $r236 i24                    ; copy memory
addi $r239 $$locbase i432               ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r237                       ; [call]: pass argument 0
move $$arg1 $r238                       ; [call]: pass argument 1
move $$arg2 $r239                       ; [call]: pass argument 2
fncall .6                               ; [call]: call abi_encode_36
addi $r241 $$locbase i1096              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r241 $r239 i24                    ; copy memory
add $r242 $r225 $one
move $r223 $r242                        ; move parameter from branch to block argument
ji  .107
.103
addi $r244 $$locbase i208               ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
addi $r245 $r244 i40                    ; get offset to aggregate element
addi $r246 $$locbase i1456              ; get offset to local __ptr { u64, u64 }
mcpi $r246 $r245 i16                    ; copy memory
addi $r247 $$locbase i928               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r248 $$locbase i616               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r248 $r247 i24                    ; copy memory
addi $r249 $$locbase i336               ; get offset to local __ptr { { ptr, u64, u64 } }
movi $$arg0 i3                          ; [call]: pass argument 0
move $$arg1 $r248                       ; [call]: pass argument 1
move $$arg2 $r249                       ; [call]: pass argument 2
fncall .4                               ; [call]: call abi_encode_30
addi $r252 $$locbase i1216              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r252 $r249 i24                    ; copy memory
addi $r253 $$locbase i1456              ; get offset to local __ptr { u64, u64 }
addi $r254 $$locbase i1216              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r255 $$locbase i1392              ; get offset to local __ptr { u64, u64 }
mcpi $r255 $r253 i16                    ; copy memory
addi $r256 $$locbase i1000              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r256 $r254 i24                    ; copy memory
lw $r258 $$locbase i174                 ; load word
addi $r259 $$locbase i1000              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r260 $$locbase i640               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r260 $r259 i24                    ; copy memory
addi $r261 $$locbase i360               ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r258                       ; [call]: pass argument 0
move $$arg1 $r260                       ; [call]: pass argument 1
move $$arg2 $r261                       ; [call]: pass argument 2
fncall .4                               ; [call]: call abi_encode_30
addi $r263 $$locbase i1072              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r263 $r261 i24                    ; copy memory
lw $r266 $$locbase i175                 ; load word
addi $r267 $$locbase i1072              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r268 $$locbase i664               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r268 $r267 i24                    ; copy memory
addi $r269 $$locbase i384               ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r266                       ; [call]: pass argument 0
move $$arg1 $r268                       ; [call]: pass argument 1
move $$arg2 $r269                       ; [call]: pass argument 2
fncall .4                               ; [call]: call abi_encode_30
addi $r271 $$locbase i1144              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r271 $r269 i24                    ; copy memory
addi $r272 $$locbase i1144              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r273 $$locbase i1240              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r273 $r272 i24                    ; copy memory
addi $r274 $$locbase i1240              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r275 $$locbase i776               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r275 $r274 i24                    ; copy memory
move $r232 $r275                        ; move parameter from branch to block argument
.110
addi $r279 $$locbase i800               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r279 $r232 i24                    ; copy memory
move $r280 $r279                        ; move parameter from branch to block argument
ji  .111
.101
addi $r281 $$locbase i208               ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
addi $r282 $r281 i55                    ; get offset to aggregate element
lb $r283 $r282 i0                       ; load byte
addi $r284 $$locbase i928               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r285 $$locbase i592               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r285 $r284 i24                    ; copy memory
addi $r286 $$locbase i312               ; get offset to local __ptr { { ptr, u64, u64 } }
movi $$arg0 i2                          ; [call]: pass argument 0
move $$arg1 $r285                       ; [call]: pass argument 1
move $$arg2 $r286                       ; [call]: pass argument 2
fncall .4                               ; [call]: call abi_encode_30
addi $r289 $$locbase i1168              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r289 $r286 i24                    ; copy memory
addi $r290 $$locbase i1168              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r291 $$locbase i976               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r291 $r290 i24                    ; copy memory
addi $r292 $$locbase i520               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r293 $$locbase i976               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r295 $$locbase i48                ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r295 $r293 i24                    ; copy memory
addi $r296 $$locbase i136               ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r296 $r295 i24                    ; copy memory
lw $r297 $$locbase i17                  ; load word
lw $r299 $$locbase i18                  ; load word
lw $r301 $$locbase i19                  ; load word
add $r302 $r301 $one
gt $r303 $r302 $r299
move $r304 $r297                        ; move parameter from branch to block argument
move $r305 $r299                        ; move parameter from branch to block argument
jnzi $r303 .112
ji  .113
.112
movi $r306 i2                           ; initialize constant into register
mul $r307 $r299 $r306
add $r308 $r307 $one
aloc $r308
mcp $hp $r297 $r301
move $r304 $hp                          ; move parameter from branch to block argument
move $r305 $r308                        ; move parameter from branch to block argument
.113
move $r313 $r304                        ; move parameter from branch to block argument
move $r315 $r305                        ; move parameter from branch to block argument
add $r316 $r304 $r301
sb $r316 $r283 i0                       ; store byte
addi $r317 $$locbase i184               ; get offset to local __ptr { ptr, u64, u64 }
sw $$locbase $r313 i23                  ; store word
sw $$locbase $r315 i24                  ; store word
sw $$locbase $r302 i25                  ; store word
addi $r321 $$locbase i72                ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r321 $r317 i24                    ; copy memory
mcpi $r292 $r321 i24                    ; copy memory
addi $r322 $$locbase i1192              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r322 $r292 i24                    ; copy memory
addi $r323 $$locbase i1192              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r324 $$locbase i800               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r324 $r323 i24                    ; copy memory
move $r280 $r324                        ; move parameter from branch to block argument
.111
addi $r328 $$locbase i824               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r328 $r280 i24                    ; copy memory
move $r329 $r328                        ; move parameter from branch to block argument
ji  .114
.99
addi $r330 $$locbase i208               ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
addi $r331 $r330 i55                    ; get offset to aggregate element
lb $r332 $r331 i0                       ; load byte
addi $r333 $$locbase i928               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r334 $$locbase i568               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r334 $r333 i24                    ; copy memory
addi $r335 $$locbase i288               ; get offset to local __ptr { { ptr, u64, u64 } }
movi $$arg0 i1                          ; [call]: pass argument 0
move $$arg1 $r334                       ; [call]: pass argument 1
move $$arg2 $r335                       ; [call]: pass argument 2
fncall .4                               ; [call]: call abi_encode_30
addi $r337 $$locbase i1048              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r337 $r335 i24                    ; copy memory
addi $r338 $$locbase i1048              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r339 $$locbase i952               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r339 $r338 i24                    ; copy memory
addi $r340 $$locbase i496               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r341 $$locbase i952               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $$locbase $r341 i24                ; copy memory
addi $r343 $$locbase i112               ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r343 $$locbase i24                ; copy memory
lw $r344 $$locbase i14                  ; load word
lw $r346 $$locbase i15                  ; load word
lw $r348 $$locbase i16                  ; load word
add $r349 $r348 $one
gt $r350 $r349 $r346
move $r351 $r344                        ; move parameter from branch to block argument
move $r352 $r346                        ; move parameter from branch to block argument
jnzi $r350 .115
ji  .116
.115
movi $r353 i2                           ; initialize constant into register
mul $r354 $r346 $r353
add $r355 $r354 $one
aloc $r355
mcp $hp $r344 $r348
move $r351 $hp                          ; move parameter from branch to block argument
move $r352 $r355                        ; move parameter from branch to block argument
.116
move $r360 $r351                        ; move parameter from branch to block argument
move $r362 $r352                        ; move parameter from branch to block argument
add $r363 $r351 $r348
sb $r363 $r332 i0                       ; store byte
addi $r364 $$locbase i160               ; get offset to local __ptr { ptr, u64, u64 }
sw $$locbase $r360 i20                  ; store word
sw $$locbase $r362 i21                  ; store word
sw $$locbase $r349 i22                  ; store word
addi $r368 $$locbase i24                ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r368 $r364 i24                    ; copy memory
mcpi $r340 $r368 i24                    ; copy memory
addi $r369 $$locbase i1120              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r369 $r340 i24                    ; copy memory
addi $r370 $$locbase i1120              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r371 $$locbase i824               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r371 $r370 i24                    ; copy memory
move $r329 $r371                        ; move parameter from branch to block argument
.114
addi $r375 $$locbase i848               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r375 $r329 i24                    ; copy memory
move $r376 $r375                        ; move parameter from branch to block argument
ji  .117
.97
addi $r377 $$locbase i928               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r378 $$locbase i544               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r378 $r377 i24                    ; copy memory
addi $r379 $$locbase i264               ; get offset to local __ptr { { ptr, u64, u64 } }
movi $$arg0 i0                          ; [call]: pass argument 0
move $$arg1 $r378                       ; [call]: pass argument 1
move $$arg2 $r379                       ; [call]: pass argument 2
fncall .4                               ; [call]: call abi_encode_30
addi $r381 $$locbase i848               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r381 $r379 i24                    ; copy memory
move $r376 $r381                        ; move parameter from branch to block argument
.117
addi $r385 $$locbase i1312              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r385 $r376 i24                    ; copy memory
addi $r386 $$locbase i1312              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r387 $$locbase i904               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r387 $r386 i24                    ; copy memory
addi $r388 $$locbase i904               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r389 $$locbase i752               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r389 $r388 i24                    ; copy memory
addi $r390 $$locbase i480               ; get offset to local __ptr slice
move $$arg0 $r389                       ; [call]: pass argument 0
move $$arg1 $r390                       ; [call]: pass argument 1
fncall .10                              ; [call]: call as_raw_slice_39
addi $r392 $$locbase i872               ; get offset to local __ptr slice
mcpi $r392 $r390 i16                    ; copy memory
move $r393 $r392                        ; move parameter from branch to block argument
ji  .118
.95
addi $r394 $$locbase i888               ; get offset to local __ptr { __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }, u64 }
sw $$locbase $r168 i111                 ; store word
movi $r396 i56                          ; initialize constant into register
sw $$locbase $r396 i112                 ; store word
addi $r397 $$locbase i96                ; get offset to local __ptr { __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }, u64 }
mcpi $r397 $r394 i16                    ; copy memory
addi $r398 $$locbase i872               ; get offset to local __ptr slice
mcpi $r398 $r397 i16                    ; copy memory
move $r393 $r398                        ; move parameter from branch to block argument
.118
mcpi $r169 $r393 i16                    ; copy memory
.3
cfsi i1520                              ; free 1520 bytes for locals and 0 slots for extra call arguments
move $$reta $r170                       ; restore return address
popa .2                                 ; restore all registers
jal $zero $$reta i0                     ; return from call
DIFF------------------------------
.program:
.2                                      ; --- start of function: encode_allow_alias_12 ---
pusha .2                                ; save all registers
move $$locbase $sp                      ; save locals base register for function encode_allow_alias_12
cfei i1520                              ; allocate 1520 bytes for locals and 0 slots for call arguments
move $r168 $$arg0                       ; save argument 0 (item)
move $r169 $$arg1                       ; save argument 1 (__ret_value)
move $r170 $$reta                       ; save return address
.88
.90
.92
.94
.96
addi $r183 $$locbase i456               ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r183                       ; [call]: pass argument 0
fncall .8                               ; [call]: call new_38
addi $r185 $$locbase i1336              ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
mcpi $r185 $r168 i56                    ; copy memory
addi $r186 $$locbase i928               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r186 $r183 i24                    ; copy memory
addi $r187 $$locbase i1336              ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
addi $r188 $$locbase i208               ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
mcpi $r188 $r187 i56                    ; copy memory
lw $r190 $$locbase i26                  ; load word
eq $r191 $r190 $zero
jnzi $r191 .97
.98
lw $r193 $$locbase i26                  ; load word
eq $r194 $r193 $one
jnzi $r194 .99
.100
lw $r196 $$locbase i26                  ; load word
movi $r197 i2                           ; initialize constant into register
eq $r198 $r196 $r197
jnzi $r198 .101
.102
lw $r200 $$locbase i26                  ; load word
movi $r201 i3                           ; initialize constant into register
eq $r202 $r200 $r201
jnzi $r202 .103
.104
lw $r204 $$locbase i26                  ; load word
movi $r205 i4                           ; initialize constant into register
eq $r206 $r204 $r205
jnzi $r206 .105
.106
load $r207 data_NonConfigurable_8       ; load constant from data section
rvrt $r207
.105
addi $r208 $$locbase i208               ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
addi $r209 $r208 i8                     ; get offset to aggregate element
addi $r210 $$locbase i1472              ; get offset to local __ptr [slice; 3]
mcpi $r210 $r209 i48                    ; copy memory
addi $r211 $$locbase i928               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r212 $$locbase i688               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r212 $r211 i24                    ; copy memory
addi $r213 $$locbase i408               ; get offset to local __ptr { { ptr, u64, u64 } }
movi $$arg0 i4                          ; [call]: pass argument 0
move $$arg1 $r212                       ; [call]: pass argument 1
move $$arg2 $r213                       ; [call]: pass argument 2
fncall .4                               ; [call]: call abi_encode_30
addi $r216 $$locbase i1264              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r216 $r213 i24                    ; copy memory
addi $r217 $$locbase i1472              ; get offset to local __ptr [slice; 3]
addi $r218 $$locbase i1264              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r219 $$locbase i1408              ; get offset to local __ptr [slice; 3]
mcpi $r219 $r217 i48                    ; copy memory
addi $r220 $$locbase i1024              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r220 $r218 i24                    ; copy memory
addi $r221 $$locbase i1024              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r222 $$locbase i1096              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r222 $r221 i24                    ; copy memory
movi $r223 i0                           ; move parameter from branch to block argument
.107
move $r225 $r223                        ; move parameter from branch to block argument
movi $r226 i3                           ; initialize constant into register
lt $r227 $r223 $r226
jnzi $r227 .108
.109
addi $r228 $$locbase i1096              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r229 $$locbase i1288              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r229 $r228 i24                    ; copy memory
addi $r230 $$locbase i1288              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r231 $$locbase i776               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r231 $r230 i24                    ; copy memory
move $r232 $r231                        ; move parameter from branch to block argument
ji  .110
.108
addi $r233 $$locbase i1408              ; get offset to local __ptr [slice; 3]
movi $r234 i16                          ; get array element size
mul $r235 $r225 $r234                   ; get offset to array element
add $r235 $r233 $r235                   ; add array element offset to array base
addi $r236 $$locbase i1096              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r237 $$locbase i712               ; get offset to local __ptr slice
mcpi $r237 $r235 i16                    ; copy memory
addi $r238 $$locbase i728               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r238 $r236 i24                    ; copy memory
addi $r239 $$locbase i432               ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r237                       ; [call]: pass argument 0
move $$arg1 $r238                       ; [call]: pass argument 1
move $$arg2 $r239                       ; [call]: pass argument 2
fncall .6                               ; [call]: call abi_encode_36
addi $r241 $$locbase i1096              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r241 $r239 i24                    ; copy memory
add $r242 $r225 $one
move $r223 $r242                        ; move parameter from branch to block argument
ji  .107
.103
addi $r244 $$locbase i208               ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
addi $r245 $r244 i40                    ; get offset to aggregate element
addi $r246 $$locbase i1456              ; get offset to local __ptr { u64, u64 }
mcpi $r246 $r245 i16                    ; copy memory
addi $r247 $$locbase i928               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r248 $$locbase i616               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r248 $r247 i24                    ; copy memory
addi $r249 $$locbase i336               ; get offset to local __ptr { { ptr, u64, u64 } }
movi $$arg0 i3                          ; [call]: pass argument 0
move $$arg1 $r248                       ; [call]: pass argument 1
move $$arg2 $r249                       ; [call]: pass argument 2
fncall .4                               ; [call]: call abi_encode_30
addi $r252 $$locbase i1216              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r252 $r249 i24                    ; copy memory
addi $r253 $$locbase i1456              ; get offset to local __ptr { u64, u64 }
addi $r254 $$locbase i1216              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r255 $$locbase i1392              ; get offset to local __ptr { u64, u64 }
mcpi $r255 $r253 i16                    ; copy memory
addi $r256 $$locbase i1000              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r256 $r254 i24                    ; copy memory
lw $r258 $$locbase i174                 ; load word
addi $r259 $$locbase i1000              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r260 $$locbase i640               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r260 $r259 i24                    ; copy memory
addi $r261 $$locbase i360               ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r258                       ; [call]: pass argument 0
move $$arg1 $r260                       ; [call]: pass argument 1
move $$arg2 $r261                       ; [call]: pass argument 2
fncall .4                               ; [call]: call abi_encode_30
addi $r263 $$locbase i1072              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r263 $r261 i24                    ; copy memory
lw $r266 $$locbase i175                 ; load word
addi $r267 $$locbase i1072              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r268 $$locbase i664               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r268 $r267 i24                    ; copy memory
addi $r269 $$locbase i384               ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r266                       ; [call]: pass argument 0
move $$arg1 $r268                       ; [call]: pass argument 1
move $$arg2 $r269                       ; [call]: pass argument 2
fncall .4                               ; [call]: call abi_encode_30
addi $r271 $$locbase i1144              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r271 $r269 i24                    ; copy memory
addi $r272 $$locbase i1144              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r273 $$locbase i1240              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r273 $r272 i24                    ; copy memory
addi $r274 $$locbase i1240              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r275 $$locbase i776               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r275 $r274 i24                    ; copy memory
move $r232 $r275                        ; move parameter from branch to block argument
.110
addi $r279 $$locbase i800               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r279 $r232 i24                    ; copy memory
move $r280 $r279                        ; move parameter from branch to block argument
ji  .111
.101
addi $r281 $$locbase i208               ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
addi $r282 $r281 i55                    ; get offset to aggregate element
lb $r283 $r282 i0                       ; load byte
addi $r284 $$locbase i928               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r285 $$locbase i592               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r285 $r284 i24                    ; copy memory
addi $r286 $$locbase i312               ; get offset to local __ptr { { ptr, u64, u64 } }
movi $$arg0 i2                          ; [call]: pass argument 0
move $$arg1 $r285                       ; [call]: pass argument 1
move $$arg2 $r286                       ; [call]: pass argument 2
fncall .4                               ; [call]: call abi_encode_30
addi $r289 $$locbase i1168              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r289 $r286 i24                    ; copy memory
addi $r290 $$locbase i1168              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r291 $$locbase i976               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r291 $r290 i24                    ; copy memory
addi $r292 $$locbase i520               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r293 $$locbase i976               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r295 $$locbase i48                ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r295 $r293 i24                    ; copy memory
addi $r296 $$locbase i136               ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r296 $r295 i24                    ; copy memory
lw $r297 $$locbase i17                  ; load word
lw $r299 $$locbase i18                  ; load word
lw $r301 $$locbase i19                  ; load word
add $r302 $r301 $one
gt $r303 $r302 $r299
move $r304 $r297                        ; move parameter from branch to block argument
move $r305 $r299                        ; move parameter from branch to block argument
jnzi $r303 .112
ji  .113
.112
movi $r306 i2                           ; initialize constant into register
mul $r307 $r299 $r306
add $r308 $r307 $one
aloc $r308
mcp $hp $r297 $r301
move $r304 $hp                          ; move parameter from branch to block argument
move $r305 $r308                        ; move parameter from branch to block argument
.113
move $r313 $r304                        ; move parameter from branch to block argument
move $r315 $r305                        ; move parameter from branch to block argument
add $r316 $r304 $r301
sb $r316 $r283 i0                       ; store byte
addi $r317 $$locbase i184               ; get offset to local __ptr { ptr, u64, u64 }
sw $$locbase $r313 i23                  ; store word
sw $$locbase $r315 i24                  ; store word
sw $$locbase $r302 i25                  ; store word
addi $r321 $$locbase i72                ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r321 $r317 i24                    ; copy memory
mcpi $r292 $r321 i24                    ; copy memory
addi $r322 $$locbase i1192              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r322 $r292 i24                    ; copy memory
addi $r323 $$locbase i1192              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r324 $$locbase i800               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r324 $r323 i24                    ; copy memory
move $r280 $r324                        ; move parameter from branch to block argument
.111
addi $r328 $$locbase i824               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r328 $r280 i24                    ; copy memory
move $r329 $r328                        ; move parameter from branch to block argument
ji  .114
.99
addi $r330 $$locbase i208               ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
addi $r331 $r330 i55                    ; get offset to aggregate element
lb $r332 $r331 i0                       ; load byte
addi $r333 $$locbase i928               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r334 $$locbase i568               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r334 $r333 i24                    ; copy memory
addi $r335 $$locbase i288               ; get offset to local __ptr { { ptr, u64, u64 } }
movi $$arg0 i1                          ; [call]: pass argument 0
move $$arg1 $r334                       ; [call]: pass argument 1
move $$arg2 $r335                       ; [call]: pass argument 2
fncall .4                               ; [call]: call abi_encode_30
addi $r337 $$locbase i1048              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r337 $r335 i24                    ; copy memory
addi $r338 $$locbase i1048              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r339 $$locbase i952               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r339 $r338 i24                    ; copy memory
addi $r340 $$locbase i496               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r341 $$locbase i952               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $$locbase $r341 i24                ; copy memory
addi $r343 $$locbase i112               ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r343 $$locbase i24                ; copy memory
lw $r344 $$locbase i14                  ; load word
lw $r346 $$locbase i15                  ; load word
lw $r348 $$locbase i16                  ; load word
add $r349 $r348 $one
gt $r350 $r349 $r346
move $r351 $r344                        ; move parameter from branch to block argument
move $r352 $r346                        ; move parameter from branch to block argument
jnzi $r350 .115
ji  .116
.115
movi $r353 i2                           ; initialize constant into register
mul $r354 $r346 $r353
add $r355 $r354 $one
aloc $r355
mcp $hp $r344 $r348
move $r351 $hp                          ; move parameter from branch to block argument
move $r352 $r355                        ; move parameter from branch to block argument
.116
move $r360 $r351                        ; move parameter from branch to block argument
move $r362 $r352                        ; move parameter from branch to block argument
add $r363 $r351 $r348
sb $r363 $r332 i0                       ; store byte
addi $r364 $$locbase i160               ; get offset to local __ptr { ptr, u64, u64 }
sw $$locbase $r360 i20                  ; store word
sw $$locbase $r362 i21                  ; store word
sw $$locbase $r349 i22                  ; store word
addi $r368 $$locbase i24                ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r368 $r364 i24                    ; copy memory
mcpi $r340 $r368 i24                    ; copy memory
addi $r369 $$locbase i1120              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r369 $r340 i24                    ; copy memory
addi $r370 $$locbase i1120              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r371 $$locbase i824               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r371 $r370 i24                    ; copy memory
move $r329 $r371                        ; move parameter from branch to block argument
.114
addi $r375 $$locbase i848               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r375 $r329 i24                    ; copy memory
move $r376 $r375                        ; move parameter from branch to block argument
ji  .117
.97
addi $r377 $$locbase i928               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r378 $$locbase i544               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r378 $r377 i24                    ; copy memory
addi $r379 $$locbase i264               ; get offset to local __ptr { { ptr, u64, u64 } }
movi $$arg0 i0                          ; [call]: pass argument 0
move $$arg1 $r378                       ; [call]: pass argument 1
move $$arg2 $r379                       ; [call]: pass argument 2
fncall .4                               ; [call]: call abi_encode_30
addi $r381 $$locbase i848               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r381 $r379 i24                    ; copy memory
move $r376 $r381                        ; move parameter from branch to block argument
.117
addi $r385 $$locbase i1312              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r385 $r376 i24                    ; copy memory
addi $r386 $$locbase i1312              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r387 $$locbase i904               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r387 $r386 i24                    ; copy memory
addi $r388 $$locbase i904               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r389 $$locbase i752               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r389 $r388 i24                    ; copy memory
addi $r390 $$locbase i480               ; get offset to local __ptr slice
move $$arg0 $r389                       ; [call]: pass argument 0
move $$arg1 $r390                       ; [call]: pass argument 1
fncall .10                              ; [call]: call as_raw_slice_39
addi $r392 $$locbase i872               ; get offset to local __ptr slice
mcpi $r392 $r390 i16                    ; copy memory
move $r393 $r392                        ; move parameter from branch to block argument
.118
 mcpi $r169 $r393 i16                    ; copy memory
 mcpi $r169 $r392 i16                    ; copy memory
.3
cfsi i1520                              ; free 1520 bytes for locals and 0 slots for extra call arguments
move $$reta $r170                       ; restore return address
popa .2                                 ; restore all registers
jal $zero $$reta i0                     ; return from call
DIFF------------------------------
.program:
.2                                      ; --- start of function: encode_allow_alias_12 ---
pusha .2                                ; save all registers
move $$locbase $sp                      ; save locals base register for function encode_allow_alias_12
cfei i1520                              ; allocate 1520 bytes for locals and 0 slots for call arguments
move $r168 $$arg0                       ; save argument 0 (item)
move $r169 $$arg1                       ; save argument 1 (__ret_value)
move $r170 $$reta                       ; save return address
.88
.90
.92
.94
.96
addi $r183 $$locbase i456               ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r183                       ; [call]: pass argument 0
fncall .8                               ; [call]: call new_38
addi $r185 $$locbase i1336              ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
mcpi $r185 $r168 i56                    ; copy memory
addi $r186 $$locbase i928               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r186 $r183 i24                    ; copy memory
addi $r187 $$locbase i1336              ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
addi $r188 $$locbase i208               ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
mcpi $r188 $r187 i56                    ; copy memory
lw $r190 $$locbase i26                  ; load word
eq $r191 $r190 $zero
jnzi $r191 .97
.98
lw $r193 $$locbase i26                  ; load word
eq $r194 $r193 $one
jnzi $r194 .99
.100
lw $r196 $$locbase i26                  ; load word
movi $r197 i2                           ; initialize constant into register
eq $r198 $r196 $r197
jnzi $r198 .101
.102
lw $r200 $$locbase i26                  ; load word
movi $r201 i3                           ; initialize constant into register
eq $r202 $r200 $r201
jnzi $r202 .103
.104
lw $r204 $$locbase i26                  ; load word
movi $r205 i4                           ; initialize constant into register
eq $r206 $r204 $r205
jnzi $r206 .105
.106
load $r207 data_NonConfigurable_8       ; load constant from data section
rvrt $r207
.105
addi $r208 $$locbase i208               ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
addi $r209 $r208 i8                     ; get offset to aggregate element
addi $r210 $$locbase i1472              ; get offset to local __ptr [slice; 3]
mcpi $r210 $r209 i48                    ; copy memory
addi $r211 $$locbase i928               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r212 $$locbase i688               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r212 $r211 i24                    ; copy memory
addi $r213 $$locbase i408               ; get offset to local __ptr { { ptr, u64, u64 } }
movi $$arg0 i4                          ; [call]: pass argument 0
move $$arg1 $r212                       ; [call]: pass argument 1
move $$arg2 $r213                       ; [call]: pass argument 2
fncall .4                               ; [call]: call abi_encode_30
addi $r216 $$locbase i1264              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r216 $r213 i24                    ; copy memory
addi $r217 $$locbase i1472              ; get offset to local __ptr [slice; 3]
addi $r218 $$locbase i1264              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r219 $$locbase i1408              ; get offset to local __ptr [slice; 3]
mcpi $r219 $r217 i48                    ; copy memory
addi $r220 $$locbase i1024              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r220 $r218 i24                    ; copy memory
addi $r221 $$locbase i1024              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r222 $$locbase i1096              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r222 $r221 i24                    ; copy memory
movi $r223 i0                           ; move parameter from branch to block argument
.107
move $r225 $r223                        ; move parameter from branch to block argument
movi $r226 i3                           ; initialize constant into register
lt $r227 $r223 $r226
jnzi $r227 .108
.109
addi $r228 $$locbase i1096              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r229 $$locbase i1288              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r229 $r228 i24                    ; copy memory
addi $r230 $$locbase i1288              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r231 $$locbase i776               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r231 $r230 i24                    ; copy memory
move $r232 $r231                        ; move parameter from branch to block argument
ji  .110
.108
addi $r233 $$locbase i1408              ; get offset to local __ptr [slice; 3]
movi $r234 i16                          ; get array element size
mul $r235 $r225 $r234                   ; get offset to array element
add $r235 $r233 $r235                   ; add array element offset to array base
addi $r236 $$locbase i1096              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r237 $$locbase i712               ; get offset to local __ptr slice
mcpi $r237 $r235 i16                    ; copy memory
addi $r238 $$locbase i728               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r238 $r236 i24                    ; copy memory
addi $r239 $$locbase i432               ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r237                       ; [call]: pass argument 0
move $$arg1 $r238                       ; [call]: pass argument 1
move $$arg2 $r239                       ; [call]: pass argument 2
fncall .6                               ; [call]: call abi_encode_36
addi $r241 $$locbase i1096              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r241 $r239 i24                    ; copy memory
add $r242 $r225 $one
move $r223 $r242                        ; move parameter from branch to block argument
ji  .107
.103
addi $r244 $$locbase i208               ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
addi $r245 $r244 i40                    ; get offset to aggregate element
addi $r246 $$locbase i1456              ; get offset to local __ptr { u64, u64 }
mcpi $r246 $r245 i16                    ; copy memory
addi $r247 $$locbase i928               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r248 $$locbase i616               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r248 $r247 i24                    ; copy memory
addi $r249 $$locbase i336               ; get offset to local __ptr { { ptr, u64, u64 } }
movi $$arg0 i3                          ; [call]: pass argument 0
move $$arg1 $r248                       ; [call]: pass argument 1
move $$arg2 $r249                       ; [call]: pass argument 2
fncall .4                               ; [call]: call abi_encode_30
addi $r252 $$locbase i1216              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r252 $r249 i24                    ; copy memory
addi $r253 $$locbase i1456              ; get offset to local __ptr { u64, u64 }
addi $r254 $$locbase i1216              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r255 $$locbase i1392              ; get offset to local __ptr { u64, u64 }
mcpi $r255 $r253 i16                    ; copy memory
addi $r256 $$locbase i1000              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r256 $r254 i24                    ; copy memory
lw $r258 $$locbase i174                 ; load word
addi $r259 $$locbase i1000              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r260 $$locbase i640               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r260 $r259 i24                    ; copy memory
addi $r261 $$locbase i360               ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r258                       ; [call]: pass argument 0
move $$arg1 $r260                       ; [call]: pass argument 1
move $$arg2 $r261                       ; [call]: pass argument 2
fncall .4                               ; [call]: call abi_encode_30
addi $r263 $$locbase i1072              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r263 $r261 i24                    ; copy memory
lw $r266 $$locbase i175                 ; load word
addi $r267 $$locbase i1072              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r268 $$locbase i664               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r268 $r267 i24                    ; copy memory
addi $r269 $$locbase i384               ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r266                       ; [call]: pass argument 0
move $$arg1 $r268                       ; [call]: pass argument 1
move $$arg2 $r269                       ; [call]: pass argument 2
fncall .4                               ; [call]: call abi_encode_30
addi $r271 $$locbase i1144              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r271 $r269 i24                    ; copy memory
addi $r272 $$locbase i1144              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r273 $$locbase i1240              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r273 $r272 i24                    ; copy memory
addi $r274 $$locbase i1240              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r275 $$locbase i776               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r275 $r274 i24                    ; copy memory
move $r232 $r275                        ; move parameter from branch to block argument
.110
addi $r279 $$locbase i800               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r279 $r232 i24                    ; copy memory
move $r280 $r279                        ; move parameter from branch to block argument
ji  .111
.101
addi $r281 $$locbase i208               ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
addi $r282 $r281 i55                    ; get offset to aggregate element
lb $r283 $r282 i0                       ; load byte
addi $r284 $$locbase i928               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r285 $$locbase i592               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r285 $r284 i24                    ; copy memory
addi $r286 $$locbase i312               ; get offset to local __ptr { { ptr, u64, u64 } }
movi $$arg0 i2                          ; [call]: pass argument 0
move $$arg1 $r285                       ; [call]: pass argument 1
move $$arg2 $r286                       ; [call]: pass argument 2
fncall .4                               ; [call]: call abi_encode_30
addi $r289 $$locbase i1168              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r289 $r286 i24                    ; copy memory
addi $r290 $$locbase i1168              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r291 $$locbase i976               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r291 $r290 i24                    ; copy memory
addi $r292 $$locbase i520               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r293 $$locbase i976               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r295 $$locbase i48                ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r295 $r293 i24                    ; copy memory
addi $r296 $$locbase i136               ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r296 $r295 i24                    ; copy memory
lw $r297 $$locbase i17                  ; load word
lw $r299 $$locbase i18                  ; load word
lw $r301 $$locbase i19                  ; load word
add $r302 $r301 $one
gt $r303 $r302 $r299
move $r304 $r297                        ; move parameter from branch to block argument
move $r305 $r299                        ; move parameter from branch to block argument
jnzi $r303 .112
ji  .113
.112
movi $r306 i2                           ; initialize constant into register
mul $r307 $r299 $r306
add $r308 $r307 $one
aloc $r308
mcp $hp $r297 $r301
move $r304 $hp                          ; move parameter from branch to block argument
move $r305 $r308                        ; move parameter from branch to block argument
.113
move $r313 $r304                        ; move parameter from branch to block argument
move $r315 $r305                        ; move parameter from branch to block argument
add $r316 $r304 $r301
sb $r316 $r283 i0                       ; store byte
addi $r317 $$locbase i184               ; get offset to local __ptr { ptr, u64, u64 }
sw $$locbase $r313 i23                  ; store word
sw $$locbase $r315 i24                  ; store word
sw $$locbase $r302 i25                  ; store word
addi $r321 $$locbase i72                ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r321 $r317 i24                    ; copy memory
mcpi $r292 $r321 i24                    ; copy memory
addi $r322 $$locbase i1192              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r322 $r292 i24                    ; copy memory
addi $r323 $$locbase i1192              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r324 $$locbase i800               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r324 $r323 i24                    ; copy memory
move $r280 $r324                        ; move parameter from branch to block argument
.111
addi $r328 $$locbase i824               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r328 $r280 i24                    ; copy memory
move $r329 $r328                        ; move parameter from branch to block argument
ji  .114
.99
addi $r330 $$locbase i208               ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
addi $r331 $r330 i55                    ; get offset to aggregate element
lb $r332 $r331 i0                       ; load byte
addi $r333 $$locbase i928               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r334 $$locbase i568               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r334 $r333 i24                    ; copy memory
addi $r335 $$locbase i288               ; get offset to local __ptr { { ptr, u64, u64 } }
movi $$arg0 i1                          ; [call]: pass argument 0
move $$arg1 $r334                       ; [call]: pass argument 1
move $$arg2 $r335                       ; [call]: pass argument 2
fncall .4                               ; [call]: call abi_encode_30
addi $r337 $$locbase i1048              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r337 $r335 i24                    ; copy memory
addi $r338 $$locbase i1048              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r339 $$locbase i952               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r339 $r338 i24                    ; copy memory
addi $r340 $$locbase i496               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r341 $$locbase i952               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $$locbase $r341 i24                ; copy memory
addi $r343 $$locbase i112               ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r343 $$locbase i24                ; copy memory
lw $r344 $$locbase i14                  ; load word
lw $r346 $$locbase i15                  ; load word
lw $r348 $$locbase i16                  ; load word
add $r349 $r348 $one
gt $r350 $r349 $r346
move $r351 $r344                        ; move parameter from branch to block argument
move $r352 $r346                        ; move parameter from branch to block argument
jnzi $r350 .115
ji  .116
.115
movi $r353 i2                           ; initialize constant into register
mul $r354 $r346 $r353
add $r355 $r354 $one
aloc $r355
mcp $hp $r344 $r348
move $r351 $hp                          ; move parameter from branch to block argument
move $r352 $r355                        ; move parameter from branch to block argument
.116
move $r360 $r351                        ; move parameter from branch to block argument
move $r362 $r352                        ; move parameter from branch to block argument
add $r363 $r351 $r348
sb $r363 $r332 i0                       ; store byte
addi $r364 $$locbase i160               ; get offset to local __ptr { ptr, u64, u64 }
sw $$locbase $r360 i20                  ; store word
sw $$locbase $r362 i21                  ; store word
sw $$locbase $r349 i22                  ; store word
addi $r368 $$locbase i24                ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r368 $r364 i24                    ; copy memory
mcpi $r340 $r368 i24                    ; copy memory
addi $r369 $$locbase i1120              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r369 $r340 i24                    ; copy memory
addi $r370 $$locbase i1120              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r371 $$locbase i824               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r371 $r370 i24                    ; copy memory
move $r329 $r371                        ; move parameter from branch to block argument
.114
addi $r375 $$locbase i848               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r375 $r329 i24                    ; copy memory
move $r376 $r375                        ; move parameter from branch to block argument
ji  .117
.97
addi $r377 $$locbase i928               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r378 $$locbase i544               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r378 $r377 i24                    ; copy memory
addi $r379 $$locbase i264               ; get offset to local __ptr { { ptr, u64, u64 } }
movi $$arg0 i0                          ; [call]: pass argument 0
move $$arg1 $r378                       ; [call]: pass argument 1
move $$arg2 $r379                       ; [call]: pass argument 2
fncall .4                               ; [call]: call abi_encode_30
addi $r381 $$locbase i848               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r381 $r379 i24                    ; copy memory
move $r376 $r381                        ; move parameter from branch to block argument
.117
addi $r385 $$locbase i1312              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r385 $r376 i24                    ; copy memory
addi $r386 $$locbase i1312              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r387 $$locbase i904               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r387 $r386 i24                    ; copy memory
addi $r388 $$locbase i904               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r389 $$locbase i752               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r389 $r388 i24                    ; copy memory
addi $r390 $$locbase i480               ; get offset to local __ptr slice
move $$arg0 $r389                       ; [call]: pass argument 0
move $$arg1 $r390                       ; [call]: pass argument 1
fncall .10                              ; [call]: call as_raw_slice_39
addi $r392 $$locbase i872               ; get offset to local __ptr slice
mcpi $r392 $r390 i16                    ; copy memory
.118
mcpi $r169 $r392 i16                    ; copy memory
.3
cfsi i1520                              ; free 1520 bytes for locals and 0 slots for extra call arguments
move $$reta $r170                       ; restore return address
popa .2                                 ; restore all registers
jal $zero $$reta i0                     ; return from call
DIFF------------------------------
.program:
.2                                      ; --- start of function: encode_allow_alias_12 ---
pusha .2                                ; save all registers
move $$locbase $sp                      ; save locals base register for function encode_allow_alias_12
cfei i1520                              ; allocate 1520 bytes for locals and 0 slots for call arguments
move $r168 $$arg0                       ; save argument 0 (item)
move $r169 $$arg1                       ; save argument 1 (__ret_value)
move $r170 $$reta                       ; save return address
.88
.90
.92
.94
.96
addi $r183 $$locbase i456               ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r183                       ; [call]: pass argument 0
fncall .8                               ; [call]: call new_38
addi $r185 $$locbase i1336              ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
mcpi $r185 $r168 i56                    ; copy memory
addi $r186 $$locbase i928               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r186 $r183 i24                    ; copy memory
addi $r187 $$locbase i1336              ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
addi $r188 $$locbase i208               ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
mcpi $r188 $r187 i56                    ; copy memory
lw $r190 $$locbase i26                  ; load word
eq $r191 $r190 $zero
jnzi $r191 .97
.98
lw $r193 $$locbase i26                  ; load word
eq $r194 $r193 $one
jnzi $r194 .99
.100
lw $r196 $$locbase i26                  ; load word
movi $r197 i2                           ; initialize constant into register
eq $r198 $r196 $r197
jnzi $r198 .101
.102
lw $r200 $$locbase i26                  ; load word
movi $r201 i3                           ; initialize constant into register
eq $r202 $r200 $r201
jnzi $r202 .103
.104
lw $r204 $$locbase i26                  ; load word
movi $r205 i4                           ; initialize constant into register
eq $r206 $r204 $r205
jnzi $r206 .105
.106
load $r207 data_NonConfigurable_8       ; load constant from data section
rvrt $r207
.105
addi $r208 $$locbase i208               ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
addi $r209 $r208 i8                     ; get offset to aggregate element
addi $r210 $$locbase i1472              ; get offset to local __ptr [slice; 3]
mcpi $r210 $r209 i48                    ; copy memory
addi $r211 $$locbase i928               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r212 $$locbase i688               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r212 $r211 i24                    ; copy memory
addi $r213 $$locbase i408               ; get offset to local __ptr { { ptr, u64, u64 } }
movi $$arg0 i4                          ; [call]: pass argument 0
move $$arg1 $r212                       ; [call]: pass argument 1
move $$arg2 $r213                       ; [call]: pass argument 2
fncall .4                               ; [call]: call abi_encode_30
addi $r216 $$locbase i1264              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r216 $r213 i24                    ; copy memory
addi $r217 $$locbase i1472              ; get offset to local __ptr [slice; 3]
addi $r218 $$locbase i1264              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r219 $$locbase i1408              ; get offset to local __ptr [slice; 3]
mcpi $r219 $r217 i48                    ; copy memory
addi $r220 $$locbase i1024              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r220 $r218 i24                    ; copy memory
addi $r221 $$locbase i1024              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r222 $$locbase i1096              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r222 $r221 i24                    ; copy memory
movi $r223 i0                           ; move parameter from branch to block argument
.107
move $r225 $r223                        ; move parameter from branch to block argument
movi $r226 i3                           ; initialize constant into register
lt $r227 $r223 $r226
jnzi $r227 .108
.109
addi $r228 $$locbase i1096              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r229 $$locbase i1288              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r229 $r228 i24                    ; copy memory
addi $r230 $$locbase i1288              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r231 $$locbase i776               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r231 $r230 i24                    ; copy memory
move $r232 $r231                        ; move parameter from branch to block argument
ji  .110
.108
addi $r233 $$locbase i1408              ; get offset to local __ptr [slice; 3]
movi $r234 i16                          ; get array element size
mul $r235 $r225 $r234                   ; get offset to array element
add $r235 $r233 $r235                   ; add array element offset to array base
addi $r236 $$locbase i1096              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r237 $$locbase i712               ; get offset to local __ptr slice
mcpi $r237 $r235 i16                    ; copy memory
addi $r238 $$locbase i728               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r238 $r236 i24                    ; copy memory
addi $r239 $$locbase i432               ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r237                       ; [call]: pass argument 0
move $$arg1 $r238                       ; [call]: pass argument 1
move $$arg2 $r239                       ; [call]: pass argument 2
fncall .6                               ; [call]: call abi_encode_36
addi $r241 $$locbase i1096              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r241 $r239 i24                    ; copy memory
add $r242 $r225 $one
move $r223 $r242                        ; move parameter from branch to block argument
ji  .107
.103
addi $r244 $$locbase i208               ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
addi $r245 $r244 i40                    ; get offset to aggregate element
addi $r246 $$locbase i1456              ; get offset to local __ptr { u64, u64 }
mcpi $r246 $r245 i16                    ; copy memory
addi $r247 $$locbase i928               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r248 $$locbase i616               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r248 $r247 i24                    ; copy memory
addi $r249 $$locbase i336               ; get offset to local __ptr { { ptr, u64, u64 } }
movi $$arg0 i3                          ; [call]: pass argument 0
move $$arg1 $r248                       ; [call]: pass argument 1
move $$arg2 $r249                       ; [call]: pass argument 2
fncall .4                               ; [call]: call abi_encode_30
addi $r252 $$locbase i1216              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r252 $r249 i24                    ; copy memory
addi $r253 $$locbase i1456              ; get offset to local __ptr { u64, u64 }
addi $r254 $$locbase i1216              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r255 $$locbase i1392              ; get offset to local __ptr { u64, u64 }
mcpi $r255 $r253 i16                    ; copy memory
addi $r256 $$locbase i1000              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r256 $r254 i24                    ; copy memory
lw $r258 $$locbase i174                 ; load word
addi $r259 $$locbase i1000              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r260 $$locbase i640               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r260 $r259 i24                    ; copy memory
addi $r261 $$locbase i360               ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r258                       ; [call]: pass argument 0
move $$arg1 $r260                       ; [call]: pass argument 1
move $$arg2 $r261                       ; [call]: pass argument 2
fncall .4                               ; [call]: call abi_encode_30
addi $r263 $$locbase i1072              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r263 $r261 i24                    ; copy memory
lw $r266 $$locbase i175                 ; load word
addi $r267 $$locbase i1072              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r268 $$locbase i664               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r268 $r267 i24                    ; copy memory
addi $r269 $$locbase i384               ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r266                       ; [call]: pass argument 0
move $$arg1 $r268                       ; [call]: pass argument 1
move $$arg2 $r269                       ; [call]: pass argument 2
fncall .4                               ; [call]: call abi_encode_30
addi $r271 $$locbase i1144              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r271 $r269 i24                    ; copy memory
addi $r272 $$locbase i1144              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r273 $$locbase i1240              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r273 $r272 i24                    ; copy memory
addi $r274 $$locbase i1240              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r275 $$locbase i776               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r275 $r274 i24                    ; copy memory
move $r232 $r275                        ; move parameter from branch to block argument
.110
addi $r279 $$locbase i800               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r279 $r232 i24                    ; copy memory
move $r280 $r279                        ; move parameter from branch to block argument
ji  .111
.101
addi $r281 $$locbase i208               ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
addi $r282 $r281 i55                    ; get offset to aggregate element
lb $r283 $r282 i0                       ; load byte
addi $r284 $$locbase i928               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r285 $$locbase i592               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r285 $r284 i24                    ; copy memory
addi $r286 $$locbase i312               ; get offset to local __ptr { { ptr, u64, u64 } }
movi $$arg0 i2                          ; [call]: pass argument 0
move $$arg1 $r285                       ; [call]: pass argument 1
move $$arg2 $r286                       ; [call]: pass argument 2
fncall .4                               ; [call]: call abi_encode_30
addi $r289 $$locbase i1168              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r289 $r286 i24                    ; copy memory
addi $r290 $$locbase i1168              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r291 $$locbase i976               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r291 $r290 i24                    ; copy memory
addi $r292 $$locbase i520               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r293 $$locbase i976               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r295 $$locbase i48                ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r295 $r293 i24                    ; copy memory
addi $r296 $$locbase i136               ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r296 $r295 i24                    ; copy memory
lw $r297 $$locbase i17                  ; load word
lw $r299 $$locbase i18                  ; load word
lw $r301 $$locbase i19                  ; load word
add $r302 $r301 $one
gt $r303 $r302 $r299
move $r304 $r297                        ; move parameter from branch to block argument
move $r305 $r299                        ; move parameter from branch to block argument
jnzi $r303 .112
ji  .113
.112
movi $r306 i2                           ; initialize constant into register
mul $r307 $r299 $r306
add $r308 $r307 $one
aloc $r308
mcp $hp $r297 $r301
move $r304 $hp                          ; move parameter from branch to block argument
move $r305 $r308                        ; move parameter from branch to block argument
.113
move $r313 $r304                        ; move parameter from branch to block argument
move $r315 $r305                        ; move parameter from branch to block argument
add $r316 $r304 $r301
sb $r316 $r283 i0                       ; store byte
addi $r317 $$locbase i184               ; get offset to local __ptr { ptr, u64, u64 }
sw $$locbase $r313 i23                  ; store word
sw $$locbase $r315 i24                  ; store word
sw $$locbase $r302 i25                  ; store word
addi $r321 $$locbase i72                ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r321 $r317 i24                    ; copy memory
mcpi $r292 $r321 i24                    ; copy memory
addi $r322 $$locbase i1192              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r322 $r292 i24                    ; copy memory
addi $r323 $$locbase i1192              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r324 $$locbase i800               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r324 $r323 i24                    ; copy memory
move $r280 $r324                        ; move parameter from branch to block argument
.111
addi $r328 $$locbase i824               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r328 $r280 i24                    ; copy memory
move $r329 $r328                        ; move parameter from branch to block argument
ji  .114
.99
addi $r330 $$locbase i208               ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
addi $r331 $r330 i55                    ; get offset to aggregate element
lb $r332 $r331 i0                       ; load byte
addi $r333 $$locbase i928               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r334 $$locbase i568               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r334 $r333 i24                    ; copy memory
addi $r335 $$locbase i288               ; get offset to local __ptr { { ptr, u64, u64 } }
movi $$arg0 i1                          ; [call]: pass argument 0
move $$arg1 $r334                       ; [call]: pass argument 1
move $$arg2 $r335                       ; [call]: pass argument 2
fncall .4                               ; [call]: call abi_encode_30
addi $r337 $$locbase i1048              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r337 $r335 i24                    ; copy memory
addi $r338 $$locbase i1048              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r339 $$locbase i952               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r339 $r338 i24                    ; copy memory
addi $r340 $$locbase i496               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r341 $$locbase i952               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $$locbase $r341 i24                ; copy memory
addi $r343 $$locbase i112               ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r343 $$locbase i24                ; copy memory
lw $r344 $$locbase i14                  ; load word
lw $r346 $$locbase i15                  ; load word
lw $r348 $$locbase i16                  ; load word
add $r349 $r348 $one
gt $r350 $r349 $r346
move $r351 $r344                        ; move parameter from branch to block argument
move $r352 $r346                        ; move parameter from branch to block argument
jnzi $r350 .115
ji  .116
.115
movi $r353 i2                           ; initialize constant into register
mul $r354 $r346 $r353
add $r355 $r354 $one
aloc $r355
mcp $hp $r344 $r348
move $r351 $hp                          ; move parameter from branch to block argument
move $r352 $r355                        ; move parameter from branch to block argument
.116
move $r360 $r351                        ; move parameter from branch to block argument
move $r362 $r352                        ; move parameter from branch to block argument
add $r363 $r351 $r348
sb $r363 $r332 i0                       ; store byte
addi $r364 $$locbase i160               ; get offset to local __ptr { ptr, u64, u64 }
sw $$locbase $r360 i20                  ; store word
sw $$locbase $r362 i21                  ; store word
sw $$locbase $r349 i22                  ; store word
addi $r368 $$locbase i24                ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r368 $r364 i24                    ; copy memory
mcpi $r340 $r368 i24                    ; copy memory
addi $r369 $$locbase i1120              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r369 $r340 i24                    ; copy memory
addi $r370 $$locbase i1120              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r371 $$locbase i824               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r371 $r370 i24                    ; copy memory
move $r329 $r371                        ; move parameter from branch to block argument
.114
addi $r375 $$locbase i848               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r375 $r329 i24                    ; copy memory
move $r376 $r375                        ; move parameter from branch to block argument
ji  .117
.97
addi $r377 $$locbase i928               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r378 $$locbase i544               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r378 $r377 i24                    ; copy memory
addi $r379 $$locbase i264               ; get offset to local __ptr { { ptr, u64, u64 } }
movi $$arg0 i0                          ; [call]: pass argument 0
move $$arg1 $r378                       ; [call]: pass argument 1
move $$arg2 $r379                       ; [call]: pass argument 2
fncall .4                               ; [call]: call abi_encode_30
addi $r381 $$locbase i848               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r381 $r379 i24                    ; copy memory
move $r376 $r381                        ; move parameter from branch to block argument
.117
addi $r385 $$locbase i1312              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r385 $r376 i24                    ; copy memory
addi $r386 $$locbase i1312              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r387 $$locbase i904               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r387 $r386 i24                    ; copy memory
addi $r388 $$locbase i904               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r389 $$locbase i752               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r389 $r388 i24                    ; copy memory
addi $r390 $$locbase i480               ; get offset to local __ptr slice
move $$arg0 $r389                       ; [call]: pass argument 0
move $$arg1 $r390                       ; [call]: pass argument 1
fncall .10                              ; [call]: call as_raw_slice_39
addi $r392 $$locbase i872               ; get offset to local __ptr slice
mcpi $r392 $r390 i16                    ; copy memory
.118
mcpi $r169 $r392 i16                    ; copy memory
.3
cfsi i1520                              ; free 1520 bytes for locals and 0 slots for extra call arguments
move $$reta $r170                       ; restore return address
popa .2                                 ; restore all registers
jal $zero $$reta i0                     ; return from call
DIFF------------------------------
.program:
.2                                      ; --- start of function: encode_allow_alias_12 ---
pusha .2                                ; save all registers
move $$locbase $sp                      ; save locals base register for function encode_allow_alias_12
cfei i1520                              ; allocate 1520 bytes for locals and 0 slots for call arguments
move $r168 $$arg0                       ; save argument 0 (item)
move $r169 $$arg1                       ; save argument 1 (__ret_value)
move $r170 $$reta                       ; save return address
.88
.90
.92
.94
.96
addi $r183 $$locbase i456               ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r183                       ; [call]: pass argument 0
fncall .8                               ; [call]: call new_38
addi $r185 $$locbase i1336              ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
mcpi $r185 $r168 i56                    ; copy memory
addi $r186 $$locbase i928               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r186 $r183 i24                    ; copy memory
addi $r187 $$locbase i1336              ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
addi $r188 $$locbase i208               ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
mcpi $r188 $r187 i56                    ; copy memory
lw $r190 $$locbase i26                  ; load word
eq $r191 $r190 $zero
jnzi $r191 .97
.98
lw $r193 $$locbase i26                  ; load word
eq $r194 $r193 $one
jnzi $r194 .99
.100
lw $r196 $$locbase i26                  ; load word
movi $r197 i2                           ; initialize constant into register
eq $r198 $r196 $r197
jnzi $r198 .101
.102
lw $r200 $$locbase i26                  ; load word
movi $r201 i3                           ; initialize constant into register
eq $r202 $r200 $r201
jnzi $r202 .103
.104
lw $r204 $$locbase i26                  ; load word
movi $r205 i4                           ; initialize constant into register
eq $r206 $r204 $r205
jnzi $r206 .105
.106
load $r207 data_NonConfigurable_8       ; load constant from data section
rvrt $r207
.105
addi $r208 $$locbase i208               ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
addi $r209 $r208 i8                     ; get offset to aggregate element
addi $r210 $$locbase i1472              ; get offset to local __ptr [slice; 3]
mcpi $r210 $r209 i48                    ; copy memory
addi $r211 $$locbase i928               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r212 $$locbase i688               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r212 $r211 i24                    ; copy memory
addi $r213 $$locbase i408               ; get offset to local __ptr { { ptr, u64, u64 } }
movi $$arg0 i4                          ; [call]: pass argument 0
move $$arg1 $r212                       ; [call]: pass argument 1
move $$arg2 $r213                       ; [call]: pass argument 2
fncall .4                               ; [call]: call abi_encode_30
addi $r216 $$locbase i1264              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r216 $r213 i24                    ; copy memory
addi $r217 $$locbase i1472              ; get offset to local __ptr [slice; 3]
addi $r218 $$locbase i1264              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r219 $$locbase i1408              ; get offset to local __ptr [slice; 3]
mcpi $r219 $r217 i48                    ; copy memory
addi $r220 $$locbase i1024              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r220 $r218 i24                    ; copy memory
addi $r221 $$locbase i1024              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r222 $$locbase i1096              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r222 $r221 i24                    ; copy memory
movi $r223 i0                           ; move parameter from branch to block argument
.107
move $r225 $r223                        ; move parameter from branch to block argument
movi $r226 i3                           ; initialize constant into register
lt $r227 $r223 $r226
jnzi $r227 .108
.109
addi $r228 $$locbase i1096              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r229 $$locbase i1288              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r229 $r228 i24                    ; copy memory
addi $r230 $$locbase i1288              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r231 $$locbase i776               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r231 $r230 i24                    ; copy memory
move $r232 $r231                        ; move parameter from branch to block argument
ji  .110
.108
addi $r233 $$locbase i1408              ; get offset to local __ptr [slice; 3]
movi $r234 i16                          ; get array element size
mul $r235 $r225 $r234                   ; get offset to array element
add $r235 $r233 $r235                   ; add array element offset to array base
addi $r236 $$locbase i1096              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r237 $$locbase i712               ; get offset to local __ptr slice
mcpi $r237 $r235 i16                    ; copy memory
addi $r238 $$locbase i728               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r238 $r236 i24                    ; copy memory
addi $r239 $$locbase i432               ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r237                       ; [call]: pass argument 0
move $$arg1 $r238                       ; [call]: pass argument 1
move $$arg2 $r239                       ; [call]: pass argument 2
fncall .6                               ; [call]: call abi_encode_36
addi $r241 $$locbase i1096              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r241 $r239 i24                    ; copy memory
add $r242 $r225 $one
move $r223 $r242                        ; move parameter from branch to block argument
ji  .107
.103
addi $r244 $$locbase i208               ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
addi $r245 $r244 i40                    ; get offset to aggregate element
addi $r246 $$locbase i1456              ; get offset to local __ptr { u64, u64 }
mcpi $r246 $r245 i16                    ; copy memory
addi $r247 $$locbase i928               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r248 $$locbase i616               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r248 $r247 i24                    ; copy memory
addi $r249 $$locbase i336               ; get offset to local __ptr { { ptr, u64, u64 } }
movi $$arg0 i3                          ; [call]: pass argument 0
move $$arg1 $r248                       ; [call]: pass argument 1
move $$arg2 $r249                       ; [call]: pass argument 2
fncall .4                               ; [call]: call abi_encode_30
addi $r252 $$locbase i1216              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r252 $r249 i24                    ; copy memory
addi $r253 $$locbase i1456              ; get offset to local __ptr { u64, u64 }
addi $r254 $$locbase i1216              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r255 $$locbase i1392              ; get offset to local __ptr { u64, u64 }
mcpi $r255 $r253 i16                    ; copy memory
addi $r256 $$locbase i1000              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r256 $r254 i24                    ; copy memory
lw $r258 $$locbase i174                 ; load word
addi $r259 $$locbase i1000              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r260 $$locbase i640               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r260 $r259 i24                    ; copy memory
addi $r261 $$locbase i360               ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r258                       ; [call]: pass argument 0
move $$arg1 $r260                       ; [call]: pass argument 1
move $$arg2 $r261                       ; [call]: pass argument 2
fncall .4                               ; [call]: call abi_encode_30
addi $r263 $$locbase i1072              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r263 $r261 i24                    ; copy memory
lw $r266 $$locbase i175                 ; load word
addi $r267 $$locbase i1072              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r268 $$locbase i664               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r268 $r267 i24                    ; copy memory
addi $r269 $$locbase i384               ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r266                       ; [call]: pass argument 0
move $$arg1 $r268                       ; [call]: pass argument 1
move $$arg2 $r269                       ; [call]: pass argument 2
fncall .4                               ; [call]: call abi_encode_30
addi $r271 $$locbase i1144              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r271 $r269 i24                    ; copy memory
addi $r272 $$locbase i1144              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r273 $$locbase i1240              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r273 $r272 i24                    ; copy memory
addi $r274 $$locbase i1240              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r275 $$locbase i776               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r275 $r274 i24                    ; copy memory
move $r232 $r275                        ; move parameter from branch to block argument
.110
addi $r279 $$locbase i800               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r279 $r232 i24                    ; copy memory
move $r280 $r279                        ; move parameter from branch to block argument
ji  .111
.101
addi $r281 $$locbase i208               ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
addi $r282 $r281 i55                    ; get offset to aggregate element
lb $r283 $r282 i0                       ; load byte
addi $r284 $$locbase i928               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r285 $$locbase i592               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r285 $r284 i24                    ; copy memory
addi $r286 $$locbase i312               ; get offset to local __ptr { { ptr, u64, u64 } }
movi $$arg0 i2                          ; [call]: pass argument 0
move $$arg1 $r285                       ; [call]: pass argument 1
move $$arg2 $r286                       ; [call]: pass argument 2
fncall .4                               ; [call]: call abi_encode_30
addi $r289 $$locbase i1168              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r289 $r286 i24                    ; copy memory
addi $r290 $$locbase i1168              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r291 $$locbase i976               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r291 $r290 i24                    ; copy memory
addi $r292 $$locbase i520               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r293 $$locbase i976               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r295 $$locbase i48                ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r295 $r293 i24                    ; copy memory
addi $r296 $$locbase i136               ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r296 $r295 i24                    ; copy memory
lw $r297 $$locbase i17                  ; load word
lw $r299 $$locbase i18                  ; load word
lw $r301 $$locbase i19                  ; load word
add $r302 $r301 $one
gt $r303 $r302 $r299
move $r304 $r297                        ; move parameter from branch to block argument
move $r305 $r299                        ; move parameter from branch to block argument
jnzi $r303 .112
ji  .113
.112
movi $r306 i2                           ; initialize constant into register
mul $r307 $r299 $r306
add $r308 $r307 $one
aloc $r308
mcp $hp $r297 $r301
move $r304 $hp                          ; move parameter from branch to block argument
move $r305 $r308                        ; move parameter from branch to block argument
.113
move $r313 $r304                        ; move parameter from branch to block argument
move $r315 $r305                        ; move parameter from branch to block argument
add $r316 $r304 $r301
sb $r316 $r283 i0                       ; store byte
addi $r317 $$locbase i184               ; get offset to local __ptr { ptr, u64, u64 }
sw $$locbase $r313 i23                  ; store word
sw $$locbase $r315 i24                  ; store word
sw $$locbase $r302 i25                  ; store word
addi $r321 $$locbase i72                ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r321 $r317 i24                    ; copy memory
mcpi $r292 $r321 i24                    ; copy memory
addi $r322 $$locbase i1192              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r322 $r292 i24                    ; copy memory
addi $r323 $$locbase i1192              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r324 $$locbase i800               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r324 $r323 i24                    ; copy memory
move $r280 $r324                        ; move parameter from branch to block argument
.111
addi $r328 $$locbase i824               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r328 $r280 i24                    ; copy memory
move $r329 $r328                        ; move parameter from branch to block argument
ji  .114
.99
addi $r330 $$locbase i208               ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
addi $r331 $r330 i55                    ; get offset to aggregate element
lb $r332 $r331 i0                       ; load byte
addi $r333 $$locbase i928               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r334 $$locbase i568               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r334 $r333 i24                    ; copy memory
addi $r335 $$locbase i288               ; get offset to local __ptr { { ptr, u64, u64 } }
movi $$arg0 i1                          ; [call]: pass argument 0
move $$arg1 $r334                       ; [call]: pass argument 1
move $$arg2 $r335                       ; [call]: pass argument 2
fncall .4                               ; [call]: call abi_encode_30
addi $r337 $$locbase i1048              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r337 $r335 i24                    ; copy memory
addi $r338 $$locbase i1048              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r339 $$locbase i952               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r339 $r338 i24                    ; copy memory
addi $r340 $$locbase i496               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r341 $$locbase i952               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $$locbase $r341 i24                ; copy memory
addi $r343 $$locbase i112               ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r343 $$locbase i24                ; copy memory
lw $r344 $$locbase i14                  ; load word
lw $r346 $$locbase i15                  ; load word
lw $r348 $$locbase i16                  ; load word
add $r349 $r348 $one
gt $r350 $r349 $r346
move $r351 $r344                        ; move parameter from branch to block argument
move $r352 $r346                        ; move parameter from branch to block argument
jnzi $r350 .115
ji  .116
.115
movi $r353 i2                           ; initialize constant into register
mul $r354 $r346 $r353
add $r355 $r354 $one
aloc $r355
mcp $hp $r344 $r348
move $r351 $hp                          ; move parameter from branch to block argument
move $r352 $r355                        ; move parameter from branch to block argument
.116
move $r360 $r351                        ; move parameter from branch to block argument
move $r362 $r352                        ; move parameter from branch to block argument
add $r363 $r351 $r348
sb $r363 $r332 i0                       ; store byte
addi $r364 $$locbase i160               ; get offset to local __ptr { ptr, u64, u64 }
sw $$locbase $r360 i20                  ; store word
sw $$locbase $r362 i21                  ; store word
sw $$locbase $r349 i22                  ; store word
addi $r368 $$locbase i24                ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r368 $r364 i24                    ; copy memory
mcpi $r340 $r368 i24                    ; copy memory
addi $r369 $$locbase i1120              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r369 $r340 i24                    ; copy memory
addi $r370 $$locbase i1120              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r371 $$locbase i824               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r371 $r370 i24                    ; copy memory
move $r329 $r371                        ; move parameter from branch to block argument
.114
addi $r375 $$locbase i848               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r375 $r329 i24                    ; copy memory
move $r376 $r375                        ; move parameter from branch to block argument
ji  .117
.97
addi $r377 $$locbase i928               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r378 $$locbase i544               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r378 $r377 i24                    ; copy memory
addi $r379 $$locbase i264               ; get offset to local __ptr { { ptr, u64, u64 } }
movi $$arg0 i0                          ; [call]: pass argument 0
move $$arg1 $r378                       ; [call]: pass argument 1
move $$arg2 $r379                       ; [call]: pass argument 2
fncall .4                               ; [call]: call abi_encode_30
addi $r381 $$locbase i848               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r381 $r379 i24                    ; copy memory
move $r376 $r381                        ; move parameter from branch to block argument
.117
addi $r385 $$locbase i1312              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r385 $r376 i24                    ; copy memory
addi $r386 $$locbase i1312              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r387 $$locbase i904               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r387 $r386 i24                    ; copy memory
addi $r388 $$locbase i904               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r389 $$locbase i752               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r389 $r388 i24                    ; copy memory
addi $r390 $$locbase i480               ; get offset to local __ptr slice
move $$arg0 $r389                       ; [call]: pass argument 0
move $$arg1 $r390                       ; [call]: pass argument 1
fncall .10                              ; [call]: call as_raw_slice_39
addi $r392 $$locbase i872               ; get offset to local __ptr slice
mcpi $r392 $r390 i16                    ; copy memory
.118
mcpi $r169 $r392 i16                    ; copy memory
.3
cfsi i1520                              ; free 1520 bytes for locals and 0 slots for extra call arguments
move $$reta $r170                       ; restore return address
popa .2                                 ; restore all registers
jal $zero $$reta i0                     ; return from call
DIFF------------------------------
.program:
.4                                      ; --- start of function: abi_encode_30 ---
pusha .4                                ; save all registers
move $$locbase $sp                      ; save locals base register for function abi_encode_30
cfei i144                               ; allocate 144 bytes for locals and 0 slots for call arguments
.119
addi $r403 $$locbase i120               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r403 $$arg1 i24                   ; copy memory
addi $r404 $$locbase i96                ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r405 $$locbase i120               ; get offset to local __ptr { { ptr, u64, u64 } }
move $r406 $r405                        ; return value from ASM block with return register buffer
 mcpi $$locbase $r406 i24                ; copy memory
 mcpi $$locbase $r405 i24                ; copy memory
addi $r407 $$locbase i48                ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r407 $$locbase i24                ; copy memory
lw $r408 $$locbase i6                   ; load word
addi $r409 $r407 i8                     ; get offset to aggregate element
lw $r410 $$locbase i7                   ; load word
addi $r411 $r407 i16                    ; get offset to aggregate element
lw $r412 $$locbase i8                   ; load word
movi $r413 i8                           ; initialize constant into register
add $r414 $r412 $r413
gt $r415 $r414 $r410
move $r416 $r408                        ; move parameter from branch to block argument
move $r417 $r410                        ; move parameter from branch to block argument
jnzi $r415 .120
ji  .121
.120
movi $r418 i2                           ; initialize constant into register
mul $r419 $r410 $r418
movi $r420 i8                           ; initialize constant into register
add $r421 $r419 $r420
aloc $r421
mcp $hp $r408 $r412
move $r422 $hp                          ; return value from ASM block with return register hp
 move $r416 $r422                        ; move parameter from branch to block argument
 move $r416 $hp                          ; move parameter from branch to block argument
move $r417 $r421                        ; move parameter from branch to block argument
ji  .121
.121
move $r426 $r416                        ; move parameter from branch to block argument
move $r428 $r417                        ; move parameter from branch to block argument
 add $r429 $r426 $r412
 add $r429 $r416 $r412
sw $r429 $$arg0 i0                      ; store word
addi $r430 $$locbase i72                ; get offset to local __ptr { ptr, u64, u64 }
sw $$locbase $r426 i9                   ; store word
addi $r431 $r430 i8                     ; get offset to aggregate element
sw $$locbase $r428 i10                  ; store word
addi $r432 $r430 i16                    ; get offset to aggregate element
sw $$locbase $r414 i11                  ; store word
move $r433 $r430                        ; return value from ASM block with return register buffer
addi $r434 $$locbase i24                ; get offset to local __ptr { ptr, u64, u64 }
 mcpi $r434 $r433 i24                    ; copy memory
 mcpi $r434 $r430 i24                    ; copy memory
mcpi $r404 $r434 i24                    ; copy memory
mcpi $$arg2 $r404 i24                   ; copy memory
ji  .5
.5
cfsi i144                               ; free 144 bytes for locals and 0 slots for extra call arguments
popa .4                                 ; restore all registers
jal $zero $$reta i0                     ; return from call
DIFF------------------------------
.program:
.4                                      ; --- start of function: abi_encode_30 ---
pusha .4                                ; save all registers
move $$locbase $sp                      ; save locals base register for function abi_encode_30
cfei i144                               ; allocate 144 bytes for locals and 0 slots for call arguments
.119
addi $r403 $$locbase i120               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r403 $$arg1 i24                   ; copy memory
addi $r404 $$locbase i96                ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r405 $$locbase i120               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $$locbase $r405 i24                ; copy memory
addi $r407 $$locbase i48                ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r407 $$locbase i24                ; copy memory
lw $r408 $$locbase i6                   ; load word
lw $r410 $$locbase i7                   ; load word
lw $r412 $$locbase i8                   ; load word
movi $r413 i8                           ; initialize constant into register
add $r414 $r412 $r413
gt $r415 $r414 $r410
move $r416 $r408                        ; move parameter from branch to block argument
move $r417 $r410                        ; move parameter from branch to block argument
jnzi $r415 .120
ji  .121
.120
movi $r418 i2                           ; initialize constant into register
mul $r419 $r410 $r418
movi $r420 i8                           ; initialize constant into register
add $r421 $r419 $r420
aloc $r421
mcp $hp $r408 $r412
move $r416 $hp                          ; move parameter from branch to block argument
move $r417 $r421                        ; move parameter from branch to block argument
.121
move $r426 $r416                        ; move parameter from branch to block argument
move $r428 $r417                        ; move parameter from branch to block argument
add $r429 $r416 $r412
sw $r429 $$arg0 i0                      ; store word
addi $r430 $$locbase i72                ; get offset to local __ptr { ptr, u64, u64 }
sw $$locbase $r426 i9                   ; store word
sw $$locbase $r428 i10                  ; store word
sw $$locbase $r414 i11                  ; store word
addi $r434 $$locbase i24                ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r434 $r430 i24                    ; copy memory
mcpi $r404 $r434 i24                    ; copy memory
mcpi $$arg2 $r404 i24                   ; copy memory
.5
cfsi i144                               ; free 144 bytes for locals and 0 slots for extra call arguments
popa .4                                 ; restore all registers
jal $zero $$reta i0                     ; return from call
DIFF------------------------------
.program:
.4                                      ; --- start of function: abi_encode_30 ---
pusha .4                                ; save all registers
move $$locbase $sp                      ; save locals base register for function abi_encode_30
cfei i144                               ; allocate 144 bytes for locals and 0 slots for call arguments
.119
addi $r403 $$locbase i120               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r403 $$arg1 i24                   ; copy memory
addi $r404 $$locbase i96                ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r405 $$locbase i120               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $$locbase $r405 i24                ; copy memory
addi $r407 $$locbase i48                ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r407 $$locbase i24                ; copy memory
lw $r408 $$locbase i6                   ; load word
lw $r410 $$locbase i7                   ; load word
lw $r412 $$locbase i8                   ; load word
movi $r413 i8                           ; initialize constant into register
add $r414 $r412 $r413
gt $r415 $r414 $r410
move $r416 $r408                        ; move parameter from branch to block argument
move $r417 $r410                        ; move parameter from branch to block argument
jnzi $r415 .120
ji  .121
.120
movi $r418 i2                           ; initialize constant into register
mul $r419 $r410 $r418
movi $r420 i8                           ; initialize constant into register
add $r421 $r419 $r420
aloc $r421
mcp $hp $r408 $r412
move $r416 $hp                          ; move parameter from branch to block argument
move $r417 $r421                        ; move parameter from branch to block argument
.121
move $r426 $r416                        ; move parameter from branch to block argument
move $r428 $r417                        ; move parameter from branch to block argument
add $r429 $r416 $r412
sw $r429 $$arg0 i0                      ; store word
addi $r430 $$locbase i72                ; get offset to local __ptr { ptr, u64, u64 }
sw $$locbase $r426 i9                   ; store word
sw $$locbase $r428 i10                  ; store word
sw $$locbase $r414 i11                  ; store word
addi $r434 $$locbase i24                ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r434 $r430 i24                    ; copy memory
mcpi $r404 $r434 i24                    ; copy memory
mcpi $$arg2 $r404 i24                   ; copy memory
.5
cfsi i144                               ; free 144 bytes for locals and 0 slots for extra call arguments
popa .4                                 ; restore all registers
jal $zero $$reta i0                     ; return from call
DIFF------------------------------
.program:
.4                                      ; --- start of function: abi_encode_30 ---
pusha .4                                ; save all registers
move $$locbase $sp                      ; save locals base register for function abi_encode_30
cfei i144                               ; allocate 144 bytes for locals and 0 slots for call arguments
.119
addi $r403 $$locbase i120               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r403 $$arg1 i24                   ; copy memory
addi $r404 $$locbase i96                ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r405 $$locbase i120               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $$locbase $r405 i24                ; copy memory
addi $r407 $$locbase i48                ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r407 $$locbase i24                ; copy memory
lw $r408 $$locbase i6                   ; load word
lw $r410 $$locbase i7                   ; load word
lw $r412 $$locbase i8                   ; load word
movi $r413 i8                           ; initialize constant into register
add $r414 $r412 $r413
gt $r415 $r414 $r410
move $r416 $r408                        ; move parameter from branch to block argument
move $r417 $r410                        ; move parameter from branch to block argument
jnzi $r415 .120
ji  .121
.120
movi $r418 i2                           ; initialize constant into register
mul $r419 $r410 $r418
movi $r420 i8                           ; initialize constant into register
add $r421 $r419 $r420
aloc $r421
mcp $hp $r408 $r412
move $r416 $hp                          ; move parameter from branch to block argument
move $r417 $r421                        ; move parameter from branch to block argument
.121
move $r426 $r416                        ; move parameter from branch to block argument
move $r428 $r417                        ; move parameter from branch to block argument
add $r429 $r416 $r412
sw $r429 $$arg0 i0                      ; store word
addi $r430 $$locbase i72                ; get offset to local __ptr { ptr, u64, u64 }
sw $$locbase $r426 i9                   ; store word
sw $$locbase $r428 i10                  ; store word
sw $$locbase $r414 i11                  ; store word
addi $r434 $$locbase i24                ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r434 $r430 i24                    ; copy memory
mcpi $r404 $r434 i24                    ; copy memory
mcpi $$arg2 $r404 i24                   ; copy memory
.5
cfsi i144                               ; free 144 bytes for locals and 0 slots for extra call arguments
popa .4                                 ; restore all registers
jal $zero $$reta i0                     ; return from call
DIFF------------------------------
.program:
.6                                      ; --- start of function: abi_encode_36 ---
pusha .6                                ; save all registers
move $$locbase $sp                      ; save locals base register for function abi_encode_36
cfei i224                               ; allocate 224 bytes for locals and 0 slots for call arguments
.122
addi $r436 $$locbase i208               ; get offset to local __ptr slice
mcpi $r436 $$arg0 i16                   ; copy memory
addi $r437 $$locbase i184               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r437 $$arg1 i24                   ; copy memory
addi $r438 $$locbase i160               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r439 $$locbase i184               ; get offset to local __ptr { { ptr, u64, u64 } }
move $r440 $r439                        ; return value from ASM block with return register buffer
 mcpi $$locbase $r440 i24                ; copy memory
 mcpi $$locbase $r439 i24                ; copy memory
addi $r441 $$locbase i80                ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r441 $$locbase i24                ; copy memory
lw $r442 $$locbase i10                  ; load word
addi $r443 $r441 i8                     ; get offset to aggregate element
lw $r444 $$locbase i11                  ; load word
addi $r445 $r441 i16                    ; get offset to aggregate element
lw $r446 $$locbase i12                  ; load word
addi $r447 $$locbase i208               ; get offset to local __ptr slice
addi $r448 $$locbase i40                ; get offset to local __ptr slice
mcpi $r448 $r447 i16                    ; copy memory
move $r449 $r447                        ; return value from ASM block with return register item
addi $r450 $$locbase i24                ; get offset to local __ptr { u64, u64 }
 mcpi $r450 $r449 i16                    ; copy memory
 mcpi $r450 $r447 i16                    ; copy memory
addi $r451 $$locbase i104               ; get offset to local __ptr { u64, u64 }
mcpi $r451 $r450 i16                    ; copy memory
addi $r452 $r451 i8                     ; get offset to aggregate element
lw $r453 $$locbase i14                  ; load word
movi $r454 i8                           ; initialize constant into register
add $r455 $r453 $r454
add $r456 $r446 $r455
gt $r457 $r456 $r444
move $r458 $r442                        ; move parameter from branch to block argument
move $r459 $r444                        ; move parameter from branch to block argument
jnzi $r457 .123
ji  .124
.123
movi $r460 i2                           ; initialize constant into register
mul $r461 $r444 $r460
add $r462 $r461 $r455
aloc $r462
mcp $hp $r442 $r446
move $r463 $hp                          ; return value from ASM block with return register hp
 move $r458 $r463                        ; move parameter from branch to block argument
 move $r458 $hp                          ; move parameter from branch to block argument
move $r459 $r462                        ; move parameter from branch to block argument
ji  .124
.124
move $r467 $r458                        ; move parameter from branch to block argument
move $r469 $r459                        ; move parameter from branch to block argument
addi $r470 $$locbase i120               ; get offset to local __ptr slice
mcpi $r470 $r448 i16                    ; copy memory
add $r471 $r467 $r446
lw $r473 $$locbase i16
sw $r471 $r473 i0
addi $r471 $r471 i8
lw $r472 $$locbase i15
mcp $r471 $r472 $r473
addi $r474 $r446 i8
add $r474 $r474 $r473
move $r475 $r474                        ; return value from ASM block with return register new_len
addi $r476 $$locbase i136               ; get offset to local __ptr { ptr, u64, u64 }
sw $$locbase $r467 i17                  ; store word
addi $r477 $r476 i8                     ; get offset to aggregate element
sw $$locbase $r469 i18                  ; store word
addi $r478 $r476 i16                    ; get offset to aggregate element
sw $$locbase $r475 i19                  ; store word
move $r479 $r476                        ; return value from ASM block with return register buffer
addi $r480 $$locbase i56                ; get offset to local __ptr { ptr, u64, u64 }
 mcpi $r480 $r479 i24                    ; copy memory
 mcpi $r480 $r476 i24                    ; copy memory
mcpi $r438 $r480 i24                    ; copy memory
mcpi $$arg2 $r438 i24                   ; copy memory
ji  .7
.7
cfsi i224                               ; free 224 bytes for locals and 0 slots for extra call arguments
popa .6                                 ; restore all registers
jal $zero $$reta i0                     ; return from call
DIFF------------------------------
.program:
.6                                      ; --- start of function: abi_encode_36 ---
pusha .6                                ; save all registers
move $$locbase $sp                      ; save locals base register for function abi_encode_36
cfei i224                               ; allocate 224 bytes for locals and 0 slots for call arguments
.122
addi $r436 $$locbase i208               ; get offset to local __ptr slice
mcpi $r436 $$arg0 i16                   ; copy memory
addi $r437 $$locbase i184               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r437 $$arg1 i24                   ; copy memory
addi $r438 $$locbase i160               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r439 $$locbase i184               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $$locbase $r439 i24                ; copy memory
addi $r441 $$locbase i80                ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r441 $$locbase i24                ; copy memory
lw $r442 $$locbase i10                  ; load word
lw $r444 $$locbase i11                  ; load word
lw $r446 $$locbase i12                  ; load word
addi $r447 $$locbase i208               ; get offset to local __ptr slice
addi $r448 $$locbase i40                ; get offset to local __ptr slice
mcpi $r448 $r447 i16                    ; copy memory
addi $r450 $$locbase i24                ; get offset to local __ptr { u64, u64 }
mcpi $r450 $r447 i16                    ; copy memory
addi $r451 $$locbase i104               ; get offset to local __ptr { u64, u64 }
mcpi $r451 $r450 i16                    ; copy memory
lw $r453 $$locbase i14                  ; load word
movi $r454 i8                           ; initialize constant into register
add $r455 $r453 $r454
add $r456 $r446 $r455
gt $r457 $r456 $r444
move $r458 $r442                        ; move parameter from branch to block argument
move $r459 $r444                        ; move parameter from branch to block argument
jnzi $r457 .123
ji  .124
.123
movi $r460 i2                           ; initialize constant into register
mul $r461 $r444 $r460
add $r462 $r461 $r455
aloc $r462
mcp $hp $r442 $r446
move $r458 $hp                          ; move parameter from branch to block argument
move $r459 $r462                        ; move parameter from branch to block argument
.124
move $r467 $r458                        ; move parameter from branch to block argument
move $r469 $r459                        ; move parameter from branch to block argument
addi $r470 $$locbase i120               ; get offset to local __ptr slice
mcpi $r470 $r448 i16                    ; copy memory
add $r471 $r467 $r446
lw $r473 $$locbase i16
sw $r471 $r473 i0
addi $r471 $r471 i8
lw $r472 $$locbase i15
mcp $r471 $r472 $r473
addi $r474 $r446 i8
add $r474 $r474 $r473
move $r475 $r474                        ; return value from ASM block with return register new_len
addi $r476 $$locbase i136               ; get offset to local __ptr { ptr, u64, u64 }
sw $$locbase $r467 i17                  ; store word
sw $$locbase $r469 i18                  ; store word
sw $$locbase $r475 i19                  ; store word
addi $r480 $$locbase i56                ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r480 $r476 i24                    ; copy memory
mcpi $r438 $r480 i24                    ; copy memory
mcpi $$arg2 $r438 i24                   ; copy memory
.7
cfsi i224                               ; free 224 bytes for locals and 0 slots for extra call arguments
popa .6                                 ; restore all registers
jal $zero $$reta i0                     ; return from call
DIFF------------------------------
.program:
.6                                      ; --- start of function: abi_encode_36 ---
pusha .6                                ; save all registers
move $$locbase $sp                      ; save locals base register for function abi_encode_36
cfei i224                               ; allocate 224 bytes for locals and 0 slots for call arguments
.122
addi $r436 $$locbase i208               ; get offset to local __ptr slice
mcpi $r436 $$arg0 i16                   ; copy memory
addi $r437 $$locbase i184               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r437 $$arg1 i24                   ; copy memory
addi $r438 $$locbase i160               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r439 $$locbase i184               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $$locbase $r439 i24                ; copy memory
addi $r441 $$locbase i80                ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r441 $$locbase i24                ; copy memory
lw $r442 $$locbase i10                  ; load word
lw $r444 $$locbase i11                  ; load word
lw $r446 $$locbase i12                  ; load word
addi $r447 $$locbase i208               ; get offset to local __ptr slice
addi $r448 $$locbase i40                ; get offset to local __ptr slice
mcpi $r448 $r447 i16                    ; copy memory
addi $r450 $$locbase i24                ; get offset to local __ptr { u64, u64 }
mcpi $r450 $r447 i16                    ; copy memory
addi $r451 $$locbase i104               ; get offset to local __ptr { u64, u64 }
mcpi $r451 $r450 i16                    ; copy memory
lw $r453 $$locbase i14                  ; load word
movi $r454 i8                           ; initialize constant into register
add $r455 $r453 $r454
add $r456 $r446 $r455
gt $r457 $r456 $r444
move $r458 $r442                        ; move parameter from branch to block argument
move $r459 $r444                        ; move parameter from branch to block argument
jnzi $r457 .123
ji  .124
.123
movi $r460 i2                           ; initialize constant into register
mul $r461 $r444 $r460
add $r462 $r461 $r455
aloc $r462
mcp $hp $r442 $r446
move $r458 $hp                          ; move parameter from branch to block argument
move $r459 $r462                        ; move parameter from branch to block argument
.124
move $r467 $r458                        ; move parameter from branch to block argument
move $r469 $r459                        ; move parameter from branch to block argument
addi $r470 $$locbase i120               ; get offset to local __ptr slice
mcpi $r470 $r448 i16                    ; copy memory
add $r471 $r467 $r446
lw $r473 $$locbase i16
sw $r471 $r473 i0
addi $r471 $r471 i8
lw $r472 $$locbase i15
mcp $r471 $r472 $r473
addi $r474 $r446 i8
add $r474 $r474 $r473
move $r475 $r474                        ; return value from ASM block with return register new_len
addi $r476 $$locbase i136               ; get offset to local __ptr { ptr, u64, u64 }
sw $$locbase $r467 i17                  ; store word
sw $$locbase $r469 i18                  ; store word
sw $$locbase $r475 i19                  ; store word
addi $r480 $$locbase i56                ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r480 $r476 i24                    ; copy memory
mcpi $r438 $r480 i24                    ; copy memory
mcpi $$arg2 $r438 i24                   ; copy memory
.7
cfsi i224                               ; free 224 bytes for locals and 0 slots for extra call arguments
popa .6                                 ; restore all registers
jal $zero $$reta i0                     ; return from call
DIFF------------------------------
.program:
.6                                      ; --- start of function: abi_encode_36 ---
pusha .6                                ; save all registers
move $$locbase $sp                      ; save locals base register for function abi_encode_36
cfei i224                               ; allocate 224 bytes for locals and 0 slots for call arguments
.122
addi $r436 $$locbase i208               ; get offset to local __ptr slice
mcpi $r436 $$arg0 i16                   ; copy memory
addi $r437 $$locbase i184               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r437 $$arg1 i24                   ; copy memory
addi $r438 $$locbase i160               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r439 $$locbase i184               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $$locbase $r439 i24                ; copy memory
addi $r441 $$locbase i80                ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r441 $$locbase i24                ; copy memory
lw $r442 $$locbase i10                  ; load word
lw $r444 $$locbase i11                  ; load word
lw $r446 $$locbase i12                  ; load word
addi $r447 $$locbase i208               ; get offset to local __ptr slice
addi $r448 $$locbase i40                ; get offset to local __ptr slice
mcpi $r448 $r447 i16                    ; copy memory
addi $r450 $$locbase i24                ; get offset to local __ptr { u64, u64 }
mcpi $r450 $r447 i16                    ; copy memory
addi $r451 $$locbase i104               ; get offset to local __ptr { u64, u64 }
mcpi $r451 $r450 i16                    ; copy memory
lw $r453 $$locbase i14                  ; load word
movi $r454 i8                           ; initialize constant into register
add $r455 $r453 $r454
add $r456 $r446 $r455
gt $r457 $r456 $r444
move $r458 $r442                        ; move parameter from branch to block argument
move $r459 $r444                        ; move parameter from branch to block argument
jnzi $r457 .123
ji  .124
.123
movi $r460 i2                           ; initialize constant into register
mul $r461 $r444 $r460
add $r462 $r461 $r455
aloc $r462
mcp $hp $r442 $r446
move $r458 $hp                          ; move parameter from branch to block argument
move $r459 $r462                        ; move parameter from branch to block argument
.124
move $r467 $r458                        ; move parameter from branch to block argument
move $r469 $r459                        ; move parameter from branch to block argument
addi $r470 $$locbase i120               ; get offset to local __ptr slice
mcpi $r470 $r448 i16                    ; copy memory
add $r471 $r467 $r446
lw $r473 $$locbase i16
sw $r471 $r473 i0
addi $r471 $r471 i8
lw $r472 $$locbase i15
mcp $r471 $r472 $r473
addi $r474 $r446 i8
add $r474 $r474 $r473
move $r475 $r474                        ; return value from ASM block with return register new_len
addi $r476 $$locbase i136               ; get offset to local __ptr { ptr, u64, u64 }
sw $$locbase $r467 i17                  ; store word
sw $$locbase $r469 i18                  ; store word
sw $$locbase $r475 i19                  ; store word
addi $r480 $$locbase i56                ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r480 $r476 i24                    ; copy memory
mcpi $r438 $r480 i24                    ; copy memory
mcpi $$arg2 $r438 i24                   ; copy memory
.7
cfsi i224                               ; free 224 bytes for locals and 0 slots for extra call arguments
popa .6                                 ; restore all registers
jal $zero $$reta i0                     ; return from call
DIFF------------------------------
.program:
.8                                      ; --- start of function: new_38 ---
pusha .8                                ; save all registers
move $$locbase $sp                      ; save locals base register for function new_38
cfei i72                                ; allocate 72 bytes for locals and 0 slots for call arguments
.125
addi $r482 $$locbase i48                ; get offset to local __ptr { { ptr, u64, u64 } }
movi $r483 i1024                        ; initialize constant into register
aloc $r483
move $r484 $hp                          ; return value from ASM block with return register hp
addi $r485 $$locbase i24                ; get offset to local __ptr { ptr, u64, u64 }
 sw $$locbase $r484 i3                   ; store word
 sw $$locbase $hp i3                     ; store word
addi $r486 $r485 i8                     ; get offset to aggregate element
movi $r487 i1024                        ; initialize constant into register
sw $$locbase $r487 i4                   ; store word
addi $r488 $r485 i16                    ; get offset to aggregate element
sw $$locbase $zero i5                   ; store word
move $r489 $r485                        ; return value from ASM block with return register buffer
 mcpi $$locbase $r489 i24                ; copy memory
 mcpi $$locbase $r485 i24                ; copy memory
mcpi $r482 $$locbase i24                ; copy memory
mcpi $$arg0 $r482 i24                   ; copy memory
ji  .9
.9
cfsi i72                                ; free 72 bytes for locals and 0 slots for extra call arguments
popa .8                                 ; restore all registers
jal $zero $$reta i0                     ; return from call
DIFF------------------------------
.program:
.8                                      ; --- start of function: new_38 ---
pusha .8                                ; save all registers
move $$locbase $sp                      ; save locals base register for function new_38
cfei i72                                ; allocate 72 bytes for locals and 0 slots for call arguments
.125
addi $r482 $$locbase i48                ; get offset to local __ptr { { ptr, u64, u64 } }
movi $r483 i1024                        ; initialize constant into register
aloc $r483
addi $r485 $$locbase i24                ; get offset to local __ptr { ptr, u64, u64 }
sw $$locbase $hp i3                     ; store word
movi $r487 i1024                        ; initialize constant into register
sw $$locbase $r487 i4                   ; store word
sw $$locbase $zero i5                   ; store word
mcpi $$locbase $r485 i24                ; copy memory
mcpi $r482 $$locbase i24                ; copy memory
mcpi $$arg0 $r482 i24                   ; copy memory
.9
cfsi i72                                ; free 72 bytes for locals and 0 slots for extra call arguments
popa .8                                 ; restore all registers
jal $zero $$reta i0                     ; return from call
DIFF------------------------------
.program:
.8                                      ; --- start of function: new_38 ---
pusha .8                                ; save all registers
move $$locbase $sp                      ; save locals base register for function new_38
cfei i72                                ; allocate 72 bytes for locals and 0 slots for call arguments
.125
addi $r482 $$locbase i48                ; get offset to local __ptr { { ptr, u64, u64 } }
movi $r483 i1024                        ; initialize constant into register
aloc $r483
addi $r485 $$locbase i24                ; get offset to local __ptr { ptr, u64, u64 }
sw $$locbase $hp i3                     ; store word
movi $r487 i1024                        ; initialize constant into register
sw $$locbase $r487 i4                   ; store word
sw $$locbase $zero i5                   ; store word
mcpi $$locbase $r485 i24                ; copy memory
mcpi $r482 $$locbase i24                ; copy memory
mcpi $$arg0 $r482 i24                   ; copy memory
.9
cfsi i72                                ; free 72 bytes for locals and 0 slots for extra call arguments
popa .8                                 ; restore all registers
jal $zero $$reta i0                     ; return from call
DIFF------------------------------
.program:
.8                                      ; --- start of function: new_38 ---
pusha .8                                ; save all registers
move $$locbase $sp                      ; save locals base register for function new_38
cfei i72                                ; allocate 72 bytes for locals and 0 slots for call arguments
.125
addi $r482 $$locbase i48                ; get offset to local __ptr { { ptr, u64, u64 } }
movi $r483 i1024                        ; initialize constant into register
aloc $r483
addi $r485 $$locbase i24                ; get offset to local __ptr { ptr, u64, u64 }
sw $$locbase $hp i3                     ; store word
movi $r487 i1024                        ; initialize constant into register
sw $$locbase $r487 i4                   ; store word
sw $$locbase $zero i5                   ; store word
mcpi $$locbase $r485 i24                ; copy memory
mcpi $r482 $$locbase i24                ; copy memory
mcpi $$arg0 $r482 i24                   ; copy memory
.9
cfsi i72                                ; free 72 bytes for locals and 0 slots for extra call arguments
popa .8                                 ; restore all registers
jal $zero $$reta i0                     ; return from call
DIFF------------------------------
.program:
.10                                     ; --- start of function: as_raw_slice_39 ---
pusha .10                               ; save all registers
move $$locbase $sp                      ; save locals base register for function as_raw_slice_39
cfei i56                                ; allocate 56 bytes for locals and 0 slots for call arguments
.126
addi $r491 $$locbase i32                ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r491 $$arg0 i24                   ; copy memory
addi $r492 $$locbase i32                ; get offset to local __ptr { { ptr, u64, u64 } }
move $r493 $r492                        ; return value from ASM block with return register buffer
lw $r494 $r492 i0                       ; load word
 addi $r495 $r493 i16                    ; get offset to aggregate element
 addi $r495 $r492 i16                    ; get offset to aggregate element
lw $r496 $r492 i2                       ; load word
addi $r497 $$locbase i16                ; get offset to local __ptr { ptr, u64 }
sw $$locbase $r494 i2                   ; store word
addi $r498 $r497 i8                     ; get offset to aggregate element
sw $$locbase $r496 i3                   ; store word
move $r499 $r497                        ; return value from ASM block with return register s
 mcpi $$locbase $r499 i16                ; copy memory
 mcpi $$locbase $r497 i16                ; copy memory
mcpi $$arg1 $$locbase i16               ; copy memory
ji  .11
.11
cfsi i56                                ; free 56 bytes for locals and 0 slots for extra call arguments
popa .10                                ; restore all registers
jal $zero $$reta i0                     ; return from call
DIFF------------------------------
.program:
.10                                     ; --- start of function: as_raw_slice_39 ---
pusha .10                               ; save all registers
move $$locbase $sp                      ; save locals base register for function as_raw_slice_39
cfei i56                                ; allocate 56 bytes for locals and 0 slots for call arguments
.126
addi $r491 $$locbase i32                ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r491 $$arg0 i24                   ; copy memory
addi $r492 $$locbase i32                ; get offset to local __ptr { { ptr, u64, u64 } }
lw $r494 $$locbase i4                   ; load word
lw $r496 $$locbase i6                   ; load word
addi $r497 $$locbase i16                ; get offset to local __ptr { ptr, u64 }
sw $$locbase $r494 i2                   ; store word
sw $$locbase $r496 i3                   ; store word
mcpi $$locbase $r497 i16                ; copy memory
mcpi $$arg1 $$locbase i16               ; copy memory
.11
cfsi i56                                ; free 56 bytes for locals and 0 slots for extra call arguments
popa .10                                ; restore all registers
jal $zero $$reta i0                     ; return from call
DIFF------------------------------
.program:
.10                                     ; --- start of function: as_raw_slice_39 ---
pusha .10                               ; save all registers
move $$locbase $sp                      ; save locals base register for function as_raw_slice_39
cfei i56                                ; allocate 56 bytes for locals and 0 slots for call arguments
.126
addi $r491 $$locbase i32                ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r491 $$arg0 i24                   ; copy memory
lw $r494 $$locbase i4                   ; load word
lw $r496 $$locbase i6                   ; load word
addi $r497 $$locbase i16                ; get offset to local __ptr { ptr, u64 }
sw $$locbase $r494 i2                   ; store word
sw $$locbase $r496 i3                   ; store word
mcpi $$locbase $r497 i16                ; copy memory
mcpi $$arg1 $$locbase i16               ; copy memory
.11
cfsi i56                                ; free 56 bytes for locals and 0 slots for extra call arguments
popa .10                                ; restore all registers
jal $zero $$reta i0                     ; return from call
DIFF------------------------------
.program:
.10                                     ; --- start of function: as_raw_slice_39 ---
pusha .10                               ; save all registers
move $$locbase $sp                      ; save locals base register for function as_raw_slice_39
cfei i56                                ; allocate 56 bytes for locals and 0 slots for call arguments
.126
addi $r491 $$locbase i32                ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r491 $$arg0 i24                   ; copy memory
lw $r494 $$locbase i4                   ; load word
lw $r496 $$locbase i6                   ; load word
addi $r497 $$locbase i16                ; get offset to local __ptr { ptr, u64 }
sw $$locbase $r494 i2                   ; store word
sw $$locbase $r496 i3                   ; store word
mcpi $$locbase $r497 i16                ; copy memory
mcpi $$arg1 $$locbase i16               ; copy memory
.11
cfsi i56                                ; free 56 bytes for locals and 0 slots for extra call arguments
popa .10                                ; restore all registers
jal $zero $$reta i0                     ; return from call
DIFF------------------------------
.program:
.12                                     ; --- start of function: generic_panic_41 ---
pusha .12                               ; save all registers
move $$locbase $sp                      ; save locals base register for function generic_panic_41
cfei i64                                ; allocate 64 bytes for locals and 0 slots for call arguments
move $r500 $$arg0                       ; save argument 0 (t)
move $r501 $$arg1                       ; save argument 1 (__backtrace)
move $r502 $$reta                       ; save return address
.127
addi $r503 $$locbase i16                ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r503                       ; [call]: pass argument 0
fncall .8                               ; [call]: call new_38
 move $r504 $zero                        ; [call]: return unit value
 movi $r504 i0                           ; [call]: return unit value
addi $r505 $$locbase i16                ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r506 $$locbase i40                ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r500                       ; [call]: pass argument 0
move $$arg1 $r505                       ; [call]: pass argument 1
move $$arg2 $r506                       ; [call]: pass argument 2
fncall .6                               ; [call]: call abi_encode_36
 move $r507 $zero                        ; [call]: return unit value
 movi $r507 i0                           ; [call]: return unit value
addi $r508 $$locbase i40                ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r508                       ; [call]: pass argument 0
move $$arg1 $$locbase                   ; [call]: pass argument 1
fncall .10                              ; [call]: call as_raw_slice_39
 move $r509 $zero                        ; [call]: return unit value
 movi $r509 i0                           ; [call]: return unit value
load $r510 data_NonConfigurable_9       ; load constant from data section
lw $r511 $$locbase i0                   ; load slice pointer for logging data
lw $r512 $$locbase i1                   ; load slice size for logging data
logd $zero $r510 $r511 $r512            ; log slice
load $r513 data_NonConfigurable_10      ; load constant from data section
and $r514 $r501 $r513
load $r515 data_NonConfigurable_11      ; load constant from data section
or $r516 $r515 $r514
rvrt $r516
.13
cfsi i64                                ; free 64 bytes for locals and 0 slots for extra call arguments
move $$reta $r502                       ; restore return address
popa .12                                ; restore all registers
jal $zero $$reta i0                     ; return from call
DIFF------------------------------
.program:
.12                                     ; --- start of function: generic_panic_41 ---
pusha .12                               ; save all registers
move $$locbase $sp                      ; save locals base register for function generic_panic_41
cfei i64                                ; allocate 64 bytes for locals and 0 slots for call arguments
move $r500 $$arg0                       ; save argument 0 (t)
move $r501 $$arg1                       ; save argument 1 (__backtrace)
.127
addi $r503 $$locbase i16                ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r503                       ; [call]: pass argument 0
fncall .8                               ; [call]: call new_38
addi $r505 $$locbase i16                ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r506 $$locbase i40                ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r500                       ; [call]: pass argument 0
move $$arg1 $r505                       ; [call]: pass argument 1
move $$arg2 $r506                       ; [call]: pass argument 2
fncall .6                               ; [call]: call abi_encode_36
addi $r508 $$locbase i40                ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r508                       ; [call]: pass argument 0
move $$arg1 $$locbase                   ; [call]: pass argument 1
fncall .10                              ; [call]: call as_raw_slice_39
load $r510 data_NonConfigurable_9       ; load constant from data section
lw $r511 $$locbase i0                   ; load slice pointer for logging data
lw $r512 $$locbase i1                   ; load slice size for logging data
logd $zero $r510 $r511 $r512            ; log slice
load $r513 data_NonConfigurable_10      ; load constant from data section
and $r514 $r501 $r513
load $r515 data_NonConfigurable_11      ; load constant from data section
or $r516 $r515 $r514
rvrt $r516
DIFF------------------------------
.program:
.12                                     ; --- start of function: generic_panic_41 ---
pusha .12                               ; save all registers
move $$locbase $sp                      ; save locals base register for function generic_panic_41
cfei i64                                ; allocate 64 bytes for locals and 0 slots for call arguments
move $r500 $$arg0                       ; save argument 0 (t)
move $r501 $$arg1                       ; save argument 1 (__backtrace)
.127
addi $r503 $$locbase i16                ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r503                       ; [call]: pass argument 0
fncall .8                               ; [call]: call new_38
addi $r505 $$locbase i16                ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r506 $$locbase i40                ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r500                       ; [call]: pass argument 0
move $$arg1 $r505                       ; [call]: pass argument 1
move $$arg2 $r506                       ; [call]: pass argument 2
fncall .6                               ; [call]: call abi_encode_36
addi $r508 $$locbase i40                ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r508                       ; [call]: pass argument 0
move $$arg1 $$locbase                   ; [call]: pass argument 1
fncall .10                              ; [call]: call as_raw_slice_39
load $r510 data_NonConfigurable_9       ; load constant from data section
lw $r511 $$locbase i0                   ; load slice pointer for logging data
lw $r512 $$locbase i1                   ; load slice size for logging data
logd $zero $r510 $r511 $r512            ; log slice
load $r513 data_NonConfigurable_10      ; load constant from data section
and $r514 $r501 $r513
load $r515 data_NonConfigurable_11      ; load constant from data section
or $r516 $r515 $r514
rvrt $r516
DIFF------------------------------
.program:
.12                                     ; --- start of function: generic_panic_41 ---
pusha .12                               ; save all registers
move $$locbase $sp                      ; save locals base register for function generic_panic_41
cfei i64                                ; allocate 64 bytes for locals and 0 slots for call arguments
move $r500 $$arg0                       ; save argument 0 (t)
move $r501 $$arg1                       ; save argument 1 (__backtrace)
.127
addi $r503 $$locbase i16                ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r503                       ; [call]: pass argument 0
fncall .8                               ; [call]: call new_38
addi $r505 $$locbase i16                ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r506 $$locbase i40                ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r500                       ; [call]: pass argument 0
move $$arg1 $r505                       ; [call]: pass argument 1
move $$arg2 $r506                       ; [call]: pass argument 2
fncall .6                               ; [call]: call abi_encode_36
addi $r508 $$locbase i40                ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r508                       ; [call]: pass argument 0
move $$arg1 $$locbase                   ; [call]: pass argument 1
fncall .10                              ; [call]: call as_raw_slice_39
load $r510 data_NonConfigurable_9       ; load constant from data section
lw $r511 $$locbase i0                   ; load slice pointer for logging data
lw $r512 $$locbase i1                   ; load slice size for logging data
logd $zero $r510 $r511 $r512            ; log slice
load $r513 data_NonConfigurable_10      ; load constant from data section
and $r514 $r501 $r513
load $r515 data_NonConfigurable_11      ; load constant from data section
or $r516 $r515 $r514
rvrt $r516
DIFF------------------------------
.program:
.14                                     ; --- start of function: generic_panic_with_unit_43 ---
pusha .14                               ; save all registers
move $$locbase $sp                      ; save locals base register for function generic_panic_with_unit_43
cfei i32                                ; allocate 32 bytes for locals and 0 slots for call arguments
.128
addi $r518 $$locbase i32                ; get offset to local __ptr ()
addi $r519 $$locbase i32                ; get offset to local __ptr ()
sw $$locbase $r519 i0                   ; store word
addi $r520 $$locbase i8                 ; get offset to aggregate element
sw $$locbase $zero i1                   ; store word
addi $r521 $$locbase i16                ; get offset to local __ptr slice
mcpi $r521 $$locbase i16                ; copy memory
load $r522 data_NonConfigurable_12      ; load constant from data section
lw $r523 $$locbase i2                   ; load slice pointer for logging data
lw $r524 $$locbase i3                   ; load slice size for logging data
logd $zero $r522 $r523 $r524            ; log slice
load $r525 data_NonConfigurable_10      ; load constant from data section
and $r526 $$arg0 $r525
load $r527 data_NonConfigurable_13      ; load constant from data section
or $r528 $r527 $r526
rvrt $r528
.15
cfsi i32                                ; free 32 bytes for locals and 0 slots for extra call arguments
popa .14                                ; restore all registers
jal $zero $$reta i0                     ; return from call
DIFF------------------------------
.program:
.14                                     ; --- start of function: generic_panic_with_unit_43 ---
pusha .14                               ; save all registers
move $$locbase $sp                      ; save locals base register for function generic_panic_with_unit_43
cfei i32                                ; allocate 32 bytes for locals and 0 slots for call arguments
.128
addi $r519 $$locbase i32                ; get offset to local __ptr ()
sw $$locbase $r519 i0                   ; store word
sw $$locbase $zero i1                   ; store word
addi $r521 $$locbase i16                ; get offset to local __ptr slice
mcpi $r521 $$locbase i16                ; copy memory
load $r522 data_NonConfigurable_12      ; load constant from data section
lw $r523 $$locbase i2                   ; load slice pointer for logging data
lw $r524 $$locbase i3                   ; load slice size for logging data
logd $zero $r522 $r523 $r524            ; log slice
load $r525 data_NonConfigurable_10      ; load constant from data section
and $r526 $$arg0 $r525
load $r527 data_NonConfigurable_13      ; load constant from data section
or $r528 $r527 $r526
rvrt $r528
DIFF------------------------------
.program:
.14                                     ; --- start of function: generic_panic_with_unit_43 ---
pusha .14                               ; save all registers
move $$locbase $sp                      ; save locals base register for function generic_panic_with_unit_43
cfei i32                                ; allocate 32 bytes for locals and 0 slots for call arguments
.128
addi $r519 $$locbase i32                ; get offset to local __ptr ()
sw $$locbase $r519 i0                   ; store word
sw $$locbase $zero i1                   ; store word
addi $r521 $$locbase i16                ; get offset to local __ptr slice
mcpi $r521 $$locbase i16                ; copy memory
load $r522 data_NonConfigurable_12      ; load constant from data section
lw $r523 $$locbase i2                   ; load slice pointer for logging data
lw $r524 $$locbase i3                   ; load slice size for logging data
logd $zero $r522 $r523 $r524            ; log slice
load $r525 data_NonConfigurable_10      ; load constant from data section
and $r526 $$arg0 $r525
load $r527 data_NonConfigurable_13      ; load constant from data section
or $r528 $r527 $r526
rvrt $r528
DIFF------------------------------
.program:
.14                                     ; --- start of function: generic_panic_with_unit_43 ---
pusha .14                               ; save all registers
move $$locbase $sp                      ; save locals base register for function generic_panic_with_unit_43
cfei i32                                ; allocate 32 bytes for locals and 0 slots for call arguments
.128
addi $r519 $$locbase i32                ; get offset to local __ptr ()
sw $$locbase $r519 i0                   ; store word
sw $$locbase $zero i1                   ; store word
addi $r521 $$locbase i16                ; get offset to local __ptr slice
mcpi $r521 $$locbase i16                ; copy memory
load $r522 data_NonConfigurable_12      ; load constant from data section
lw $r523 $$locbase i2                   ; load slice pointer for logging data
lw $r524 $$locbase i3                   ; load slice size for logging data
logd $zero $r522 $r523 $r524            ; log slice
load $r525 data_NonConfigurable_10      ; load constant from data section
and $r526 $$arg0 $r525
load $r527 data_NonConfigurable_13      ; load constant from data section
or $r528 $r527 $r526
rvrt $r528
DIFF------------------------------
.program:
.16                                     ; --- start of function: nested_panic_non_inlined_47 ---
pusha .16                               ; save all registers
move $$locbase $sp                      ; save locals base register for function nested_panic_non_inlined_47
cfei i200                               ; allocate 200 bytes for locals and 0 slots for call arguments
move $r529 $$arg0                       ; save argument 0 (__backtrace)
move $r530 $$reta                       ; save return address
.129
movi $r531 i4                           ; initialize constant into register
sw $$locbase $r531 i0                   ; store word
addi $r532 $$locbase i152               ; get offset to local __ptr [slice; 3]
addr $r533 data_NonConfigurable_14      ; get __const_global4's address in data section
addi $r534 $$locbase i56                ; get offset to local __ptr { ptr, u64 }
sw $$locbase $r533 i7                   ; store word
addi $r535 $r534 i8                     ; get offset to aggregate element
movi $r536 i4                           ; initialize constant into register
sw $$locbase $r536 i8                   ; store word
addi $r537 $$locbase i72                ; get offset to local __ptr slice
mcpi $r537 $r534 i16                    ; copy memory
addr $r538 data_NonConfigurable_15      ; get __const_global5's address in data section
addi $r539 $$locbase i88                ; get offset to local __ptr { ptr, u64 }
sw $$locbase $r538 i11                  ; store word
addi $r540 $r539 i8                     ; get offset to aggregate element
movi $r541 i6                           ; initialize constant into register
sw $$locbase $r541 i12                  ; store word
addi $r542 $$locbase i104               ; get offset to local __ptr slice
mcpi $r542 $r539 i16                    ; copy memory
addr $r543 data_NonConfigurable_16      ; get __const_global6's address in data section
addi $r544 $$locbase i120               ; get offset to local __ptr { ptr, u64 }
sw $$locbase $r543 i15                  ; store word
addi $r545 $r544 i8                     ; get offset to aggregate element
movi $r546 i17                          ; initialize constant into register
sw $$locbase $r546 i16                  ; store word
addi $r547 $$locbase i136               ; get offset to local __ptr slice
mcpi $r547 $r544 i16                    ; copy memory
movi $r548 i16                          ; get array element size
 mul $r549 $zero $r548                   ; get offset to array element
 add $r549 $r532 $r549                   ; add array element offset to array base
 movi $r549 i0                           ; get offset to array element
 add $r549 $r532 $zero                   ; add array element offset to array base
mcpi $r549 $r537 i16                    ; copy memory
movi $r550 i16                          ; get array element size
 mul $r551 $one $r550                    ; get offset to array element
 movi $r551 i16                          ; get offset to array element
add $r551 $r532 $r551                   ; add array element offset to array base
mcpi $r551 $r542 i16                    ; copy memory
movi $r552 i16                          ; get array element size
movi $r553 i2                           ; initialize constant into register
 mul $r554 $r553 $r552                   ; get offset to array element
 movi $r554 i32                          ; get offset to array element
add $r554 $r532 $r554                   ; add array element offset to array base
mcpi $r554 $r547 i16                    ; copy memory
addi $r555 $$locbase i8                 ; get offset to aggregate element
mcpi $r555 $r532 i48                    ; copy memory
 move $$arg0 $one                        ; [call]: pass argument 0
 movi $$arg0 i1                          ; [call]: pass argument 0
move $$arg1 $$locbase                   ; [call]: pass argument 1
move $$arg2 $r529                       ; [call]: pass argument 2
fncall .18                              ; [call]: call nested_panic_non_inlined_49
 move $r556 $zero                        ; [call]: return unit value
 movi $r556 i0                           ; [call]: return unit value
ji  .17
.17
cfsi i200                               ; free 200 bytes for locals and 0 slots for extra call arguments
move $$reta $r530                       ; restore return address
popa .16                                ; restore all registers
jal $zero $$reta i0                     ; return from call
DIFF------------------------------
.program:
.16                                     ; --- start of function: nested_panic_non_inlined_47 ---
pusha .16                               ; save all registers
move $$locbase $sp                      ; save locals base register for function nested_panic_non_inlined_47
cfei i200                               ; allocate 200 bytes for locals and 0 slots for call arguments
move $r529 $$arg0                       ; save argument 0 (__backtrace)
move $r530 $$reta                       ; save return address
.129
movi $r531 i4                           ; initialize constant into register
sw $$locbase $r531 i0                   ; store word
addi $r532 $$locbase i152               ; get offset to local __ptr [slice; 3]
addr $r533 data_NonConfigurable_14      ; get __const_global4's address in data section
addi $r534 $$locbase i56                ; get offset to local __ptr { ptr, u64 }
sw $$locbase $r533 i7                   ; store word
movi $r536 i4                           ; initialize constant into register
sw $$locbase $r536 i8                   ; store word
addi $r537 $$locbase i72                ; get offset to local __ptr slice
mcpi $r537 $r534 i16                    ; copy memory
addr $r538 data_NonConfigurable_15      ; get __const_global5's address in data section
addi $r539 $$locbase i88                ; get offset to local __ptr { ptr, u64 }
sw $$locbase $r538 i11                  ; store word
movi $r541 i6                           ; initialize constant into register
sw $$locbase $r541 i12                  ; store word
addi $r542 $$locbase i104               ; get offset to local __ptr slice
mcpi $r542 $r539 i16                    ; copy memory
addr $r543 data_NonConfigurable_16      ; get __const_global6's address in data section
addi $r544 $$locbase i120               ; get offset to local __ptr { ptr, u64 }
sw $$locbase $r543 i15                  ; store word
movi $r546 i17                          ; initialize constant into register
sw $$locbase $r546 i16                  ; store word
addi $r547 $$locbase i136               ; get offset to local __ptr slice
mcpi $r547 $r544 i16                    ; copy memory
add $r549 $r532 $zero                   ; add array element offset to array base
mcpi $r549 $r537 i16                    ; copy memory
movi $r551 i16                          ; get offset to array element
add $r551 $r532 $r551                   ; add array element offset to array base
mcpi $r551 $r542 i16                    ; copy memory
movi $r554 i32                          ; get offset to array element
add $r554 $r532 $r554                   ; add array element offset to array base
mcpi $r554 $r547 i16                    ; copy memory
addi $r555 $$locbase i8                 ; get offset to aggregate element
mcpi $r555 $r532 i48                    ; copy memory
movi $$arg0 i1                          ; [call]: pass argument 0
move $$arg1 $$locbase                   ; [call]: pass argument 1
move $$arg2 $r529                       ; [call]: pass argument 2
fncall .18                              ; [call]: call nested_panic_non_inlined_49
.17
cfsi i200                               ; free 200 bytes for locals and 0 slots for extra call arguments
move $$reta $r530                       ; restore return address
popa .16                                ; restore all registers
jal $zero $$reta i0                     ; return from call
DIFF------------------------------
.program:
.16                                     ; --- start of function: nested_panic_non_inlined_47 ---
pusha .16                               ; save all registers
move $$locbase $sp                      ; save locals base register for function nested_panic_non_inlined_47
cfei i200                               ; allocate 200 bytes for locals and 0 slots for call arguments
move $r529 $$arg0                       ; save argument 0 (__backtrace)
move $r530 $$reta                       ; save return address
.129
movi $r531 i4                           ; initialize constant into register
sw $$locbase $r531 i0                   ; store word
addi $r532 $$locbase i152               ; get offset to local __ptr [slice; 3]
addr $r533 data_NonConfigurable_14      ; get __const_global4's address in data section
addi $r534 $$locbase i56                ; get offset to local __ptr { ptr, u64 }
sw $$locbase $r533 i7                   ; store word
movi $r536 i4                           ; initialize constant into register
sw $$locbase $r536 i8                   ; store word
addi $r537 $$locbase i72                ; get offset to local __ptr slice
mcpi $r537 $r534 i16                    ; copy memory
addr $r538 data_NonConfigurable_15      ; get __const_global5's address in data section
addi $r539 $$locbase i88                ; get offset to local __ptr { ptr, u64 }
sw $$locbase $r538 i11                  ; store word
movi $r541 i6                           ; initialize constant into register
sw $$locbase $r541 i12                  ; store word
addi $r542 $$locbase i104               ; get offset to local __ptr slice
mcpi $r542 $r539 i16                    ; copy memory
addr $r543 data_NonConfigurable_16      ; get __const_global6's address in data section
addi $r544 $$locbase i120               ; get offset to local __ptr { ptr, u64 }
sw $$locbase $r543 i15                  ; store word
movi $r546 i17                          ; initialize constant into register
sw $$locbase $r546 i16                  ; store word
addi $r547 $$locbase i136               ; get offset to local __ptr slice
mcpi $r547 $r544 i16                    ; copy memory
add $r549 $r532 $zero                   ; add array element offset to array base
mcpi $r549 $r537 i16                    ; copy memory
movi $r551 i16                          ; get offset to array element
add $r551 $r532 $r551                   ; add array element offset to array base
mcpi $r551 $r542 i16                    ; copy memory
movi $r554 i32                          ; get offset to array element
add $r554 $r532 $r554                   ; add array element offset to array base
mcpi $r554 $r547 i16                    ; copy memory
addi $r555 $$locbase i8                 ; get offset to aggregate element
mcpi $r555 $r532 i48                    ; copy memory
movi $$arg0 i1                          ; [call]: pass argument 0
move $$arg1 $$locbase                   ; [call]: pass argument 1
move $$arg2 $r529                       ; [call]: pass argument 2
fncall .18                              ; [call]: call nested_panic_non_inlined_49
.17
cfsi i200                               ; free 200 bytes for locals and 0 slots for extra call arguments
move $$reta $r530                       ; restore return address
popa .16                                ; restore all registers
jal $zero $$reta i0                     ; return from call
DIFF------------------------------
.program:
.16                                     ; --- start of function: nested_panic_non_inlined_47 ---
pusha .16                               ; save all registers
move $$locbase $sp                      ; save locals base register for function nested_panic_non_inlined_47
cfei i200                               ; allocate 200 bytes for locals and 0 slots for call arguments
move $r529 $$arg0                       ; save argument 0 (__backtrace)
move $r530 $$reta                       ; save return address
.129
movi $r531 i4                           ; initialize constant into register
sw $$locbase $r531 i0                   ; store word
addi $r532 $$locbase i152               ; get offset to local __ptr [slice; 3]
addr $r533 data_NonConfigurable_14      ; get __const_global4's address in data section
addi $r534 $$locbase i56                ; get offset to local __ptr { ptr, u64 }
sw $$locbase $r533 i7                   ; store word
movi $r536 i4                           ; initialize constant into register
sw $$locbase $r536 i8                   ; store word
addi $r537 $$locbase i72                ; get offset to local __ptr slice
mcpi $r537 $r534 i16                    ; copy memory
addr $r538 data_NonConfigurable_15      ; get __const_global5's address in data section
addi $r539 $$locbase i88                ; get offset to local __ptr { ptr, u64 }
sw $$locbase $r538 i11                  ; store word
movi $r541 i6                           ; initialize constant into register
sw $$locbase $r541 i12                  ; store word
addi $r542 $$locbase i104               ; get offset to local __ptr slice
mcpi $r542 $r539 i16                    ; copy memory
addr $r543 data_NonConfigurable_16      ; get __const_global6's address in data section
addi $r544 $$locbase i120               ; get offset to local __ptr { ptr, u64 }
sw $$locbase $r543 i15                  ; store word
movi $r546 i17                          ; initialize constant into register
sw $$locbase $r546 i16                  ; store word
addi $r547 $$locbase i136               ; get offset to local __ptr slice
mcpi $r547 $r544 i16                    ; copy memory
add $r549 $r532 $zero                   ; add array element offset to array base
mcpi $r549 $r537 i16                    ; copy memory
movi $r551 i16                          ; get offset to array element
add $r551 $r532 $r551                   ; add array element offset to array base
mcpi $r551 $r542 i16                    ; copy memory
movi $r554 i32                          ; get offset to array element
add $r554 $r532 $r554                   ; add array element offset to array base
mcpi $r554 $r547 i16                    ; copy memory
addi $r555 $$locbase i8                 ; get offset to aggregate element
mcpi $r555 $r532 i48                    ; copy memory
movi $$arg0 i1                          ; [call]: pass argument 0
move $$arg1 $$locbase                   ; [call]: pass argument 1
move $$arg2 $r529                       ; [call]: pass argument 2
fncall .18                              ; [call]: call nested_panic_non_inlined_49
.17
cfsi i200                               ; free 200 bytes for locals and 0 slots for extra call arguments
move $$reta $r530                       ; restore return address
popa .16                                ; restore all registers
jal $zero $$reta i0                     ; return from call
DIFF------------------------------
.program:
.18                                     ; --- start of function: nested_panic_non_inlined_49 ---
pusha .18                               ; save all registers
move $$locbase $sp                      ; save locals base register for function nested_panic_non_inlined_49
cfei i72                                ; allocate 72 bytes for locals and 0 slots for call arguments
move $r557 $$arg0                       ; save argument 0 (to_panic)
move $r558 $$arg1                       ; save argument 1 (err)
move $r559 $$arg2                       ; save argument 2 (__backtrace)
move $r560 $$reta                       ; save return address
.130
addi $r561 $$locbase i16                ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
 mcpi $r561 $r558 i56                    ; copy memory
 mcpi $r561 $$arg1 i56                   ; copy memory
jnzi $r557 .131
ji  .132
.132
ji  .19
.131
addi $r562 $$locbase i16                ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
move $$arg0 $r562                       ; [call]: pass argument 0
move $$arg1 $$locbase                   ; [call]: pass argument 1
fncall .2                               ; [call]: call encode_allow_alias_12
 move $r563 $zero                        ; [call]: return unit value
 movi $r563 i0                           ; [call]: return unit value
load $r564 data_NonConfigurable_1       ; load constant from data section
lw $r565 $$locbase i0                   ; load slice pointer for logging data
lw $r566 $$locbase i1                   ; load slice size for logging data
logd $zero $r564 $r565 $r566            ; log slice
load $r567 data_NonConfigurable_10      ; load constant from data section
and $r568 $r559 $r567
load $r569 data_NonConfigurable_17      ; load constant from data section
or $r570 $r569 $r568
rvrt $r570
.19
cfsi i72                                ; free 72 bytes for locals and 0 slots for extra call arguments
move $$reta $r560                       ; restore return address
popa .18                                ; restore all registers
jal $zero $$reta i0                     ; return from call
DIFF------------------------------
.program:
.18                                     ; --- start of function: nested_panic_non_inlined_49 ---
pusha .18                               ; save all registers
move $$locbase $sp                      ; save locals base register for function nested_panic_non_inlined_49
cfei i72                                ; allocate 72 bytes for locals and 0 slots for call arguments
move $r557 $$arg0                       ; save argument 0 (to_panic)
move $r559 $$arg2                       ; save argument 2 (__backtrace)
move $r560 $$reta                       ; save return address
.130
addi $r561 $$locbase i16                ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
mcpi $r561 $$arg1 i56                   ; copy memory
jnzi $r557 .131
.132
ji  .19
.131
addi $r562 $$locbase i16                ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
move $$arg0 $r562                       ; [call]: pass argument 0
move $$arg1 $$locbase                   ; [call]: pass argument 1
fncall .2                               ; [call]: call encode_allow_alias_12
load $r564 data_NonConfigurable_1       ; load constant from data section
lw $r565 $$locbase i0                   ; load slice pointer for logging data
lw $r566 $$locbase i1                   ; load slice size for logging data
logd $zero $r564 $r565 $r566            ; log slice
load $r567 data_NonConfigurable_10      ; load constant from data section
and $r568 $r559 $r567
load $r569 data_NonConfigurable_17      ; load constant from data section
or $r570 $r569 $r568
rvrt $r570
.19
cfsi i72                                ; free 72 bytes for locals and 0 slots for extra call arguments
move $$reta $r560                       ; restore return address
popa .18                                ; restore all registers
jal $zero $$reta i0                     ; return from call
DIFF------------------------------
.program:
.18                                     ; --- start of function: nested_panic_non_inlined_49 ---
pusha .18                               ; save all registers
move $$locbase $sp                      ; save locals base register for function nested_panic_non_inlined_49
cfei i72                                ; allocate 72 bytes for locals and 0 slots for call arguments
move $r557 $$arg0                       ; save argument 0 (to_panic)
move $r559 $$arg2                       ; save argument 2 (__backtrace)
move $r560 $$reta                       ; save return address
.130
addi $r561 $$locbase i16                ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
mcpi $r561 $$arg1 i56                   ; copy memory
jnzi $r557 .131
.132
ji  .19
.131
addi $r562 $$locbase i16                ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
move $$arg0 $r562                       ; [call]: pass argument 0
move $$arg1 $$locbase                   ; [call]: pass argument 1
fncall .2                               ; [call]: call encode_allow_alias_12
load $r564 data_NonConfigurable_1       ; load constant from data section
lw $r565 $$locbase i0                   ; load slice pointer for logging data
lw $r566 $$locbase i1                   ; load slice size for logging data
logd $zero $r564 $r565 $r566            ; log slice
load $r567 data_NonConfigurable_10      ; load constant from data section
and $r568 $r559 $r567
load $r569 data_NonConfigurable_17      ; load constant from data section
or $r570 $r569 $r568
rvrt $r570
.19
cfsi i72                                ; free 72 bytes for locals and 0 slots for extra call arguments
move $$reta $r560                       ; restore return address
popa .18                                ; restore all registers
jal $zero $$reta i0                     ; return from call
DIFF------------------------------
.program:
.18                                     ; --- start of function: nested_panic_non_inlined_49 ---
pusha .18                               ; save all registers
move $$locbase $sp                      ; save locals base register for function nested_panic_non_inlined_49
cfei i72                                ; allocate 72 bytes for locals and 0 slots for call arguments
move $r557 $$arg0                       ; save argument 0 (to_panic)
move $r559 $$arg2                       ; save argument 2 (__backtrace)
move $r560 $$reta                       ; save return address
.130
addi $r561 $$locbase i16                ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
mcpi $r561 $$arg1 i56                   ; copy memory
jnzi $r557 .131
.132
ji  .19
.131
addi $r562 $$locbase i16                ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
move $$arg0 $r562                       ; [call]: pass argument 0
move $$arg1 $$locbase                   ; [call]: pass argument 1
fncall .2                               ; [call]: call encode_allow_alias_12
load $r564 data_NonConfigurable_1       ; load constant from data section
lw $r565 $$locbase i0                   ; load slice pointer for logging data
lw $r566 $$locbase i1                   ; load slice size for logging data
logd $zero $r564 $r565 $r566            ; log slice
load $r567 data_NonConfigurable_10      ; load constant from data section
and $r568 $r559 $r567
load $r569 data_NonConfigurable_17      ; load constant from data section
or $r570 $r569 $r568
rvrt $r570
.19
cfsi i72                                ; free 72 bytes for locals and 0 slots for extra call arguments
move $$reta $r560                       ; restore return address
popa .18                                ; restore all registers
jal $zero $$reta i0                     ; return from call
DIFF------------------------------
.program:
.20                                     ; --- start of function: nested_panic_inlined_same_revert_code_54 ---
pusha .20                               ; save all registers
move $$locbase $sp                      ; save locals base register for function nested_panic_inlined_same_revert_code_54
cfei i216                               ; allocate 216 bytes for locals and 0 slots for call arguments
move $r571 $$arg0                       ; save argument 0 (__backtrace)
move $r572 $$reta                       ; save return address
.133
addi $r573 $$locbase i160               ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
movi $r574 i4                           ; initialize constant into register
sw $$locbase $r574 i20                  ; store word
addi $r575 $$locbase i96                ; get offset to local __ptr [slice; 3]
addr $r576 data_NonConfigurable_18      ; get __const_global0's address in data section
sw $$locbase $r576 i0                   ; store word
addi $r577 $$locbase i8                 ; get offset to aggregate element
movi $r578 i7                           ; initialize constant into register
sw $$locbase $r578 i1                   ; store word
addi $r579 $$locbase i16                ; get offset to local __ptr slice
mcpi $r579 $$locbase i16                ; copy memory
addr $r580 data_NonConfigurable_19      ; get __const_global1's address in data section
addi $r581 $$locbase i32                ; get offset to local __ptr { ptr, u64 }
sw $$locbase $r580 i4                   ; store word
addi $r582 $r581 i8                     ; get offset to aggregate element
movi $r583 i7                           ; initialize constant into register
sw $$locbase $r583 i5                   ; store word
addi $r584 $$locbase i48                ; get offset to local __ptr slice
mcpi $r584 $r581 i16                    ; copy memory
addr $r585 data_NonConfigurable_20      ; get __const_global2's address in data section
addi $r586 $$locbase i64                ; get offset to local __ptr { ptr, u64 }
sw $$locbase $r585 i8                   ; store word
addi $r587 $r586 i8                     ; get offset to aggregate element
movi $r588 i22                          ; initialize constant into register
sw $$locbase $r588 i9                   ; store word
addi $r589 $$locbase i80                ; get offset to local __ptr slice
mcpi $r589 $r586 i16                    ; copy memory
movi $r590 i16                          ; get array element size
 mul $r591 $zero $r590                   ; get offset to array element
 add $r591 $r575 $r591                   ; add array element offset to array base
 movi $r591 i0                           ; get offset to array element
 add $r591 $r575 $zero                   ; add array element offset to array base
mcpi $r591 $r579 i16                    ; copy memory
movi $r592 i16                          ; get array element size
 mul $r593 $one $r592                    ; get offset to array element
 movi $r593 i16                          ; get offset to array element
add $r593 $r575 $r593                   ; add array element offset to array base
mcpi $r593 $r584 i16                    ; copy memory
movi $r594 i16                          ; get array element size
movi $r595 i2                           ; initialize constant into register
 mul $r596 $r595 $r594                   ; get offset to array element
 movi $r596 i32                          ; get offset to array element
add $r596 $r575 $r596                   ; add array element offset to array base
mcpi $r596 $r589 i16                    ; copy memory
addi $r597 $r573 i8                     ; get offset to aggregate element
mcpi $r597 $r575 i48                    ; copy memory
addi $r598 $$locbase i160               ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
addi $r599 $$locbase i144               ; get offset to local __ptr slice
move $$arg0 $r598                       ; [call]: pass argument 0
move $$arg1 $r599                       ; [call]: pass argument 1
fncall .2                               ; [call]: call encode_allow_alias_12
 move $r600 $zero                        ; [call]: return unit value
 movi $r600 i0                           ; [call]: return unit value
addi $r601 $$locbase i144               ; get offset to local __ptr slice
load $r602 data_NonConfigurable_1       ; load constant from data section
lw $r603 $$locbase i18                  ; load slice pointer for logging data
lw $r604 $$locbase i19                  ; load slice size for logging data
logd $zero $r602 $r603 $r604            ; log slice
load $r605 data_NonConfigurable_10      ; load constant from data section
and $r606 $r571 $r605
load $r607 data_NonConfigurable_21      ; load constant from data section
or $r608 $r607 $r606
rvrt $r608
.21
cfsi i216                               ; free 216 bytes for locals and 0 slots for extra call arguments
move $$reta $r572                       ; restore return address
popa .20                                ; restore all registers
jal $zero $$reta i0                     ; return from call
DIFF------------------------------
.program:
.20                                     ; --- start of function: nested_panic_inlined_same_revert_code_54 ---
pusha .20                               ; save all registers
move $$locbase $sp                      ; save locals base register for function nested_panic_inlined_same_revert_code_54
cfei i216                               ; allocate 216 bytes for locals and 0 slots for call arguments
move $r571 $$arg0                       ; save argument 0 (__backtrace)
.133
addi $r573 $$locbase i160               ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
movi $r574 i4                           ; initialize constant into register
sw $$locbase $r574 i20                  ; store word
addi $r575 $$locbase i96                ; get offset to local __ptr [slice; 3]
addr $r576 data_NonConfigurable_18      ; get __const_global0's address in data section
sw $$locbase $r576 i0                   ; store word
movi $r578 i7                           ; initialize constant into register
sw $$locbase $r578 i1                   ; store word
addi $r579 $$locbase i16                ; get offset to local __ptr slice
mcpi $r579 $$locbase i16                ; copy memory
addr $r580 data_NonConfigurable_19      ; get __const_global1's address in data section
addi $r581 $$locbase i32                ; get offset to local __ptr { ptr, u64 }
sw $$locbase $r580 i4                   ; store word
movi $r583 i7                           ; initialize constant into register
sw $$locbase $r583 i5                   ; store word
addi $r584 $$locbase i48                ; get offset to local __ptr slice
mcpi $r584 $r581 i16                    ; copy memory
addr $r585 data_NonConfigurable_20      ; get __const_global2's address in data section
addi $r586 $$locbase i64                ; get offset to local __ptr { ptr, u64 }
sw $$locbase $r585 i8                   ; store word
movi $r588 i22                          ; initialize constant into register
sw $$locbase $r588 i9                   ; store word
addi $r589 $$locbase i80                ; get offset to local __ptr slice
mcpi $r589 $r586 i16                    ; copy memory
add $r591 $r575 $zero                   ; add array element offset to array base
mcpi $r591 $r579 i16                    ; copy memory
movi $r593 i16                          ; get offset to array element
add $r593 $r575 $r593                   ; add array element offset to array base
mcpi $r593 $r584 i16                    ; copy memory
movi $r596 i32                          ; get offset to array element
add $r596 $r575 $r596                   ; add array element offset to array base
mcpi $r596 $r589 i16                    ; copy memory
addi $r597 $r573 i8                     ; get offset to aggregate element
mcpi $r597 $r575 i48                    ; copy memory
addi $r598 $$locbase i160               ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
addi $r599 $$locbase i144               ; get offset to local __ptr slice
move $$arg0 $r598                       ; [call]: pass argument 0
move $$arg1 $r599                       ; [call]: pass argument 1
fncall .2                               ; [call]: call encode_allow_alias_12
load $r602 data_NonConfigurable_1       ; load constant from data section
lw $r603 $$locbase i18                  ; load slice pointer for logging data
lw $r604 $$locbase i19                  ; load slice size for logging data
logd $zero $r602 $r603 $r604            ; log slice
load $r605 data_NonConfigurable_10      ; load constant from data section
and $r606 $r571 $r605
load $r607 data_NonConfigurable_21      ; load constant from data section
or $r608 $r607 $r606
rvrt $r608
DIFF------------------------------
.program:
.20                                     ; --- start of function: nested_panic_inlined_same_revert_code_54 ---
pusha .20                               ; save all registers
move $$locbase $sp                      ; save locals base register for function nested_panic_inlined_same_revert_code_54
cfei i216                               ; allocate 216 bytes for locals and 0 slots for call arguments
move $r571 $$arg0                       ; save argument 0 (__backtrace)
.133
addi $r573 $$locbase i160               ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
movi $r574 i4                           ; initialize constant into register
sw $$locbase $r574 i20                  ; store word
addi $r575 $$locbase i96                ; get offset to local __ptr [slice; 3]
addr $r576 data_NonConfigurable_18      ; get __const_global0's address in data section
sw $$locbase $r576 i0                   ; store word
movi $r578 i7                           ; initialize constant into register
sw $$locbase $r578 i1                   ; store word
addi $r579 $$locbase i16                ; get offset to local __ptr slice
mcpi $r579 $$locbase i16                ; copy memory
addr $r580 data_NonConfigurable_19      ; get __const_global1's address in data section
addi $r581 $$locbase i32                ; get offset to local __ptr { ptr, u64 }
sw $$locbase $r580 i4                   ; store word
movi $r583 i7                           ; initialize constant into register
sw $$locbase $r583 i5                   ; store word
addi $r584 $$locbase i48                ; get offset to local __ptr slice
mcpi $r584 $r581 i16                    ; copy memory
addr $r585 data_NonConfigurable_20      ; get __const_global2's address in data section
addi $r586 $$locbase i64                ; get offset to local __ptr { ptr, u64 }
sw $$locbase $r585 i8                   ; store word
movi $r588 i22                          ; initialize constant into register
sw $$locbase $r588 i9                   ; store word
addi $r589 $$locbase i80                ; get offset to local __ptr slice
mcpi $r589 $r586 i16                    ; copy memory
add $r591 $r575 $zero                   ; add array element offset to array base
mcpi $r591 $r579 i16                    ; copy memory
movi $r593 i16                          ; get offset to array element
add $r593 $r575 $r593                   ; add array element offset to array base
mcpi $r593 $r584 i16                    ; copy memory
movi $r596 i32                          ; get offset to array element
add $r596 $r575 $r596                   ; add array element offset to array base
mcpi $r596 $r589 i16                    ; copy memory
addi $r597 $r573 i8                     ; get offset to aggregate element
mcpi $r597 $r575 i48                    ; copy memory
addi $r598 $$locbase i160               ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
addi $r599 $$locbase i144               ; get offset to local __ptr slice
move $$arg0 $r598                       ; [call]: pass argument 0
move $$arg1 $r599                       ; [call]: pass argument 1
fncall .2                               ; [call]: call encode_allow_alias_12
load $r602 data_NonConfigurable_1       ; load constant from data section
lw $r603 $$locbase i18                  ; load slice pointer for logging data
lw $r604 $$locbase i19                  ; load slice size for logging data
logd $zero $r602 $r603 $r604            ; log slice
load $r605 data_NonConfigurable_10      ; load constant from data section
and $r606 $r571 $r605
load $r607 data_NonConfigurable_21      ; load constant from data section
or $r608 $r607 $r606
rvrt $r608
DIFF------------------------------
.program:
.20                                     ; --- start of function: nested_panic_inlined_same_revert_code_54 ---
pusha .20                               ; save all registers
move $$locbase $sp                      ; save locals base register for function nested_panic_inlined_same_revert_code_54
cfei i216                               ; allocate 216 bytes for locals and 0 slots for call arguments
move $r571 $$arg0                       ; save argument 0 (__backtrace)
.133
addi $r573 $$locbase i160               ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
movi $r574 i4                           ; initialize constant into register
sw $$locbase $r574 i20                  ; store word
addi $r575 $$locbase i96                ; get offset to local __ptr [slice; 3]
addr $r576 data_NonConfigurable_18      ; get __const_global0's address in data section
sw $$locbase $r576 i0                   ; store word
movi $r578 i7                           ; initialize constant into register
sw $$locbase $r578 i1                   ; store word
addi $r579 $$locbase i16                ; get offset to local __ptr slice
mcpi $r579 $$locbase i16                ; copy memory
addr $r580 data_NonConfigurable_19      ; get __const_global1's address in data section
addi $r581 $$locbase i32                ; get offset to local __ptr { ptr, u64 }
sw $$locbase $r580 i4                   ; store word
movi $r583 i7                           ; initialize constant into register
sw $$locbase $r583 i5                   ; store word
addi $r584 $$locbase i48                ; get offset to local __ptr slice
mcpi $r584 $r581 i16                    ; copy memory
addr $r585 data_NonConfigurable_20      ; get __const_global2's address in data section
addi $r586 $$locbase i64                ; get offset to local __ptr { ptr, u64 }
sw $$locbase $r585 i8                   ; store word
movi $r588 i22                          ; initialize constant into register
sw $$locbase $r588 i9                   ; store word
addi $r589 $$locbase i80                ; get offset to local __ptr slice
mcpi $r589 $r586 i16                    ; copy memory
add $r591 $r575 $zero                   ; add array element offset to array base
mcpi $r591 $r579 i16                    ; copy memory
movi $r593 i16                          ; get offset to array element
add $r593 $r575 $r593                   ; add array element offset to array base
mcpi $r593 $r584 i16                    ; copy memory
movi $r596 i32                          ; get offset to array element
add $r596 $r575 $r596                   ; add array element offset to array base
mcpi $r596 $r589 i16                    ; copy memory
addi $r597 $r573 i8                     ; get offset to aggregate element
mcpi $r597 $r575 i48                    ; copy memory
addi $r598 $$locbase i160               ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
addi $r599 $$locbase i144               ; get offset to local __ptr slice
move $$arg0 $r598                       ; [call]: pass argument 0
move $$arg1 $r599                       ; [call]: pass argument 1
fncall .2                               ; [call]: call encode_allow_alias_12
load $r602 data_NonConfigurable_1       ; load constant from data section
lw $r603 $$locbase i18                  ; load slice pointer for logging data
lw $r604 $$locbase i19                  ; load slice size for logging data
logd $zero $r602 $r603 $r604            ; log slice
load $r605 data_NonConfigurable_10      ; load constant from data section
and $r606 $r571 $r605
load $r607 data_NonConfigurable_21      ; load constant from data section
or $r608 $r607 $r606
rvrt $r608
DIFF------------------------------
.program:
.24                                     ; --- start of function: contract_call_63 ---
pusha .24                               ; save all registers
move $$locbase $sp                      ; save locals base register for function contract_call_63
cfei i384                               ; allocate 384 bytes for locals and 0 slots for call arguments
.135
addi $r621 $$locbase i208               ; get offset to local __ptr b256
mcpi $r621 $$arg0 i32                   ; copy memory
addi $r622 $$locbase i240               ; get offset to local __ptr slice
mcpi $r622 $$arg1 i16                   ; copy memory
addi $r623 $$locbase i176               ; get offset to local __ptr b256
mcpi $r623 $$arg4 i32                   ; copy memory
addi $r624 $$locbase i240               ; get offset to local __ptr ()
addi $r625 $$locbase i240               ; get offset to local __ptr ()
 move $r626 $zero                        ; copy ASM block argument's constant initial value to register
 aloc $r626                              ; aloc size
 movi $r626 i0                           ; copy ASM block argument's constant initial value to register
 aloc $zero                              ; aloc size
mcp $hp $r625 $r626                     ; mcp hp src size
move $r627 $hp                          ; return value from ASM block with return register hp
addi $r628 $$locbase i160               ; get offset to local __ptr { ptr, u64 }
 sw $$locbase $r627 i20                  ; store word
 sw $$locbase $hp i20                    ; store word
addi $r629 $r628 i8                     ; get offset to aggregate element
sw $$locbase $zero i21                  ; store word
move $r630 $r628                        ; return value from ASM block with return register s
 mcpi $$locbase $r630 i16                ; copy memory
 mcpi $$locbase $r628 i16                ; copy memory
addi $r631 $$locbase i304               ; get offset to local __ptr slice
mcpi $r631 $$locbase i16                ; copy memory
addi $r632 $$locbase i112               ; get offset to local __ptr { b256, u64, u64 }
addi $r633 $$locbase i208               ; get offset to local __ptr b256
addi $r634 $$locbase i240               ; get offset to local __ptr slice
addi $r635 $$locbase i320               ; get offset to local __ptr slice
mcpi $r635 $r634 i16                    ; copy memory
addi $r636 $$locbase i320               ; get offset to local __ptr slice
addi $r637 $$locbase i352               ; get offset to local __ptr slice
mcpi $r637 $r636 i16                    ; copy memory
addi $r638 $$locbase i352               ; get offset to local __ptr slice
move $r639 $r638                        ; return value from ASM block with return register ptr
addi $r640 $$locbase i16                ; get offset to local __ptr { ptr, u64 }
 mcpi $r640 $r639 i16                    ; copy memory
 mcpi $r640 $r638 i16                    ; copy memory
addi $r641 $$locbase i80                ; get offset to local __ptr { ptr, u64 }
mcpi $r641 $r640 i16                    ; copy memory
lw $r642 $$locbase i10                  ; load word
move $r643 $r642                        ; return value from ASM block with return register a
addi $r644 $$locbase i304               ; get offset to local __ptr slice
addi $r645 $$locbase i336               ; get offset to local __ptr slice
mcpi $r645 $r644 i16                    ; copy memory
addi $r646 $$locbase i336               ; get offset to local __ptr slice
addi $r647 $$locbase i368               ; get offset to local __ptr slice
mcpi $r647 $r646 i16                    ; copy memory
addi $r648 $$locbase i368               ; get offset to local __ptr slice
move $r649 $r648                        ; return value from ASM block with return register ptr
addi $r650 $$locbase i32                ; get offset to local __ptr { ptr, u64 }
 mcpi $r650 $r649 i16                    ; copy memory
 mcpi $r650 $r648 i16                    ; copy memory
addi $r651 $$locbase i96                ; get offset to local __ptr { ptr, u64 }
mcpi $r651 $r650 i16                    ; copy memory
lw $r652 $$locbase i12                  ; load word
move $r653 $r652                        ; return value from ASM block with return register a
mcpi $r632 $r633 i32                    ; copy memory
addi $r654 $r632 i32                    ; get offset to aggregate element
sw $$locbase $r643 i18                  ; store word
addi $r655 $r632 i40                    ; get offset to aggregate element
sw $$locbase $r653 i19                  ; store word
addi $r656 $$locbase i256               ; get offset to local __ptr { b256, u64, u64 }
mcpi $r656 $r632 i48                    ; copy memory
addi $r657 $$locbase i256               ; get offset to local __ptr { b256, u64, u64 }
addi $r658 $$locbase i176               ; get offset to local __ptr b256
addi $r659 $$locbase i48                ; get offset to local __ptr b256
mcpi $r659 $r658 i32                    ; copy memory
addi $r660 $$locbase i48                ; get offset to local __ptr b256
call $r657 $$arg3 $r660 $$arg5          ; call external contract
move $r661 $ret                         ; save external contract call result
ji  .25
.25
cfsi i384                               ; free 384 bytes for locals and 0 slots for extra call arguments
popa .24                                ; restore all registers
jal $zero $$reta i0                     ; return from call
DIFF------------------------------
.program:
.24                                     ; --- start of function: contract_call_63 ---
pusha .24                               ; save all registers
move $$locbase $sp                      ; save locals base register for function contract_call_63
cfei i384                               ; allocate 384 bytes for locals and 0 slots for call arguments
.135
addi $r621 $$locbase i208               ; get offset to local __ptr b256
mcpi $r621 $$arg0 i32                   ; copy memory
addi $r622 $$locbase i240               ; get offset to local __ptr slice
mcpi $r622 $$arg1 i16                   ; copy memory
addi $r623 $$locbase i176               ; get offset to local __ptr b256
mcpi $r623 $$arg4 i32                   ; copy memory
addi $r625 $$locbase i240               ; get offset to local __ptr ()
movi $r626 i0                           ; copy ASM block argument's constant initial value to register
aloc $zero                              ; aloc size
mcp $hp $r625 $r626                     ; mcp hp src size
addi $r628 $$locbase i160               ; get offset to local __ptr { ptr, u64 }
sw $$locbase $hp i20                    ; store word
sw $$locbase $zero i21                  ; store word
mcpi $$locbase $r628 i16                ; copy memory
addi $r631 $$locbase i304               ; get offset to local __ptr slice
mcpi $r631 $$locbase i16                ; copy memory
addi $r632 $$locbase i112               ; get offset to local __ptr { b256, u64, u64 }
addi $r633 $$locbase i208               ; get offset to local __ptr b256
addi $r634 $$locbase i240               ; get offset to local __ptr slice
addi $r635 $$locbase i320               ; get offset to local __ptr slice
mcpi $r635 $r634 i16                    ; copy memory
addi $r636 $$locbase i320               ; get offset to local __ptr slice
addi $r637 $$locbase i352               ; get offset to local __ptr slice
mcpi $r637 $r636 i16                    ; copy memory
addi $r638 $$locbase i352               ; get offset to local __ptr slice
addi $r640 $$locbase i16                ; get offset to local __ptr { ptr, u64 }
mcpi $r640 $r638 i16                    ; copy memory
addi $r641 $$locbase i80                ; get offset to local __ptr { ptr, u64 }
mcpi $r641 $r640 i16                    ; copy memory
lw $r642 $$locbase i10                  ; load word
move $r643 $r642                        ; return value from ASM block with return register a
addi $r644 $$locbase i304               ; get offset to local __ptr slice
addi $r645 $$locbase i336               ; get offset to local __ptr slice
mcpi $r645 $r644 i16                    ; copy memory
addi $r646 $$locbase i336               ; get offset to local __ptr slice
addi $r647 $$locbase i368               ; get offset to local __ptr slice
mcpi $r647 $r646 i16                    ; copy memory
addi $r648 $$locbase i368               ; get offset to local __ptr slice
addi $r650 $$locbase i32                ; get offset to local __ptr { ptr, u64 }
mcpi $r650 $r648 i16                    ; copy memory
addi $r651 $$locbase i96                ; get offset to local __ptr { ptr, u64 }
mcpi $r651 $r650 i16                    ; copy memory
lw $r652 $$locbase i12                  ; load word
move $r653 $r652                        ; return value from ASM block with return register a
mcpi $r632 $r633 i32                    ; copy memory
sw $$locbase $r643 i18                  ; store word
sw $$locbase $r653 i19                  ; store word
addi $r656 $$locbase i256               ; get offset to local __ptr { b256, u64, u64 }
mcpi $r656 $r632 i48                    ; copy memory
addi $r657 $$locbase i256               ; get offset to local __ptr { b256, u64, u64 }
addi $r658 $$locbase i176               ; get offset to local __ptr b256
addi $r659 $$locbase i48                ; get offset to local __ptr b256
mcpi $r659 $r658 i32                    ; copy memory
addi $r660 $$locbase i48                ; get offset to local __ptr b256
call $r657 $$arg3 $r660 $$arg5          ; call external contract
.25
cfsi i384                               ; free 384 bytes for locals and 0 slots for extra call arguments
popa .24                                ; restore all registers
jal $zero $$reta i0                     ; return from call
DIFF------------------------------
.program:
.24                                     ; --- start of function: contract_call_63 ---
pusha .24                               ; save all registers
move $$locbase $sp                      ; save locals base register for function contract_call_63
cfei i384                               ; allocate 384 bytes for locals and 0 slots for call arguments
.135
addi $r621 $$locbase i208               ; get offset to local __ptr b256
mcpi $r621 $$arg0 i32                   ; copy memory
addi $r622 $$locbase i240               ; get offset to local __ptr slice
mcpi $r622 $$arg1 i16                   ; copy memory
addi $r623 $$locbase i176               ; get offset to local __ptr b256
mcpi $r623 $$arg4 i32                   ; copy memory
addi $r625 $$locbase i240               ; get offset to local __ptr ()
movi $r626 i0                           ; copy ASM block argument's constant initial value to register
aloc $zero                              ; aloc size
mcp $hp $r625 $r626                     ; mcp hp src size
addi $r628 $$locbase i160               ; get offset to local __ptr { ptr, u64 }
sw $$locbase $hp i20                    ; store word
sw $$locbase $zero i21                  ; store word
mcpi $$locbase $r628 i16                ; copy memory
addi $r631 $$locbase i304               ; get offset to local __ptr slice
mcpi $r631 $$locbase i16                ; copy memory
addi $r632 $$locbase i112               ; get offset to local __ptr { b256, u64, u64 }
addi $r633 $$locbase i208               ; get offset to local __ptr b256
addi $r634 $$locbase i240               ; get offset to local __ptr slice
addi $r635 $$locbase i320               ; get offset to local __ptr slice
mcpi $r635 $r634 i16                    ; copy memory
addi $r636 $$locbase i320               ; get offset to local __ptr slice
addi $r637 $$locbase i352               ; get offset to local __ptr slice
mcpi $r637 $r636 i16                    ; copy memory
addi $r638 $$locbase i352               ; get offset to local __ptr slice
addi $r640 $$locbase i16                ; get offset to local __ptr { ptr, u64 }
mcpi $r640 $r638 i16                    ; copy memory
addi $r641 $$locbase i80                ; get offset to local __ptr { ptr, u64 }
mcpi $r641 $r640 i16                    ; copy memory
lw $r642 $$locbase i10                  ; load word
move $r643 $r642                        ; return value from ASM block with return register a
addi $r644 $$locbase i304               ; get offset to local __ptr slice
addi $r645 $$locbase i336               ; get offset to local __ptr slice
mcpi $r645 $r644 i16                    ; copy memory
addi $r646 $$locbase i336               ; get offset to local __ptr slice
addi $r647 $$locbase i368               ; get offset to local __ptr slice
mcpi $r647 $r646 i16                    ; copy memory
addi $r648 $$locbase i368               ; get offset to local __ptr slice
addi $r650 $$locbase i32                ; get offset to local __ptr { ptr, u64 }
mcpi $r650 $r648 i16                    ; copy memory
addi $r651 $$locbase i96                ; get offset to local __ptr { ptr, u64 }
mcpi $r651 $r650 i16                    ; copy memory
lw $r652 $$locbase i12                  ; load word
move $r653 $r652                        ; return value from ASM block with return register a
mcpi $r632 $r633 i32                    ; copy memory
sw $$locbase $r643 i18                  ; store word
sw $$locbase $r653 i19                  ; store word
addi $r656 $$locbase i256               ; get offset to local __ptr { b256, u64, u64 }
mcpi $r656 $r632 i48                    ; copy memory
addi $r657 $$locbase i256               ; get offset to local __ptr { b256, u64, u64 }
addi $r658 $$locbase i176               ; get offset to local __ptr b256
addi $r659 $$locbase i48                ; get offset to local __ptr b256
mcpi $r659 $r658 i32                    ; copy memory
addi $r660 $$locbase i48                ; get offset to local __ptr b256
call $r657 $$arg3 $r660 $$arg5          ; call external contract
.25
cfsi i384                               ; free 384 bytes for locals and 0 slots for extra call arguments
popa .24                                ; restore all registers
jal $zero $$reta i0                     ; return from call
DIFF------------------------------
.program:
.24                                     ; --- start of function: contract_call_63 ---
pusha .24                               ; save all registers
move $$locbase $sp                      ; save locals base register for function contract_call_63
cfei i384                               ; allocate 384 bytes for locals and 0 slots for call arguments
.135
addi $r621 $$locbase i208               ; get offset to local __ptr b256
mcpi $r621 $$arg0 i32                   ; copy memory
addi $r622 $$locbase i240               ; get offset to local __ptr slice
mcpi $r622 $$arg1 i16                   ; copy memory
addi $r623 $$locbase i176               ; get offset to local __ptr b256
mcpi $r623 $$arg4 i32                   ; copy memory
addi $r625 $$locbase i240               ; get offset to local __ptr ()
movi $r626 i0                           ; copy ASM block argument's constant initial value to register
aloc $zero                              ; aloc size
mcp $hp $r625 $r626                     ; mcp hp src size
addi $r628 $$locbase i160               ; get offset to local __ptr { ptr, u64 }
sw $$locbase $hp i20                    ; store word
sw $$locbase $zero i21                  ; store word
mcpi $$locbase $r628 i16                ; copy memory
addi $r631 $$locbase i304               ; get offset to local __ptr slice
mcpi $r631 $$locbase i16                ; copy memory
addi $r632 $$locbase i112               ; get offset to local __ptr { b256, u64, u64 }
addi $r633 $$locbase i208               ; get offset to local __ptr b256
addi $r634 $$locbase i240               ; get offset to local __ptr slice
addi $r635 $$locbase i320               ; get offset to local __ptr slice
mcpi $r635 $r634 i16                    ; copy memory
addi $r636 $$locbase i320               ; get offset to local __ptr slice
addi $r637 $$locbase i352               ; get offset to local __ptr slice
mcpi $r637 $r636 i16                    ; copy memory
addi $r638 $$locbase i352               ; get offset to local __ptr slice
addi $r640 $$locbase i16                ; get offset to local __ptr { ptr, u64 }
mcpi $r640 $r638 i16                    ; copy memory
addi $r641 $$locbase i80                ; get offset to local __ptr { ptr, u64 }
mcpi $r641 $r640 i16                    ; copy memory
lw $r642 $$locbase i10                  ; load word
move $r643 $r642                        ; return value from ASM block with return register a
addi $r644 $$locbase i304               ; get offset to local __ptr slice
addi $r645 $$locbase i336               ; get offset to local __ptr slice
mcpi $r645 $r644 i16                    ; copy memory
addi $r646 $$locbase i336               ; get offset to local __ptr slice
addi $r647 $$locbase i368               ; get offset to local __ptr slice
mcpi $r647 $r646 i16                    ; copy memory
addi $r648 $$locbase i368               ; get offset to local __ptr slice
addi $r650 $$locbase i32                ; get offset to local __ptr { ptr, u64 }
mcpi $r650 $r648 i16                    ; copy memory
addi $r651 $$locbase i96                ; get offset to local __ptr { ptr, u64 }
mcpi $r651 $r650 i16                    ; copy memory
lw $r652 $$locbase i12                  ; load word
move $r653 $r652                        ; return value from ASM block with return register a
mcpi $r632 $r633 i32                    ; copy memory
sw $$locbase $r643 i18                  ; store word
sw $$locbase $r653 i19                  ; store word
addi $r656 $$locbase i256               ; get offset to local __ptr { b256, u64, u64 }
mcpi $r656 $r632 i48                    ; copy memory
addi $r657 $$locbase i256               ; get offset to local __ptr { b256, u64, u64 }
addi $r658 $$locbase i176               ; get offset to local __ptr b256
addi $r659 $$locbase i48                ; get offset to local __ptr b256
mcpi $r659 $r658 i32                    ; copy memory
addi $r660 $$locbase i48                ; get offset to local __ptr b256
call $r657 $$arg3 $r660 $$arg5          ; call external contract
.25
cfsi i384                               ; free 384 bytes for locals and 0 slots for extra call arguments
popa .24                                ; restore all registers
jal $zero $$reta i0                     ; return from call
    Finished release [optimized + fuel] target(s) [6.232 KB] in ???
     Running 12 tests, filtered 0 tests

tested -- panicking_contract

      test test_panicking_in_contract_self_impl ... ok (???, 10292 gas)
           revert code: 8280000000000000
             panic message: panicking in contract self impl
             panicked:      in <Contract as PanickingContractAbi>::panicking_in_contract_self_impl
                                at panicking_contract@1.2.3, src/main.sw:22:9
      test test_directly_panicking_method ... ok (???, 11184 gas)
           revert code: 8200000000000000
             panic message: Error C.
             panic value:   C(true)
             panicked:      in <Contract as Abi>::directly_panicking_method
                                at panicking_contract@1.2.3, src/main.sw:28:9
           decoded log values:
C(true), log rb: 5503570629422409978
      test test_nested_panic_inlined ... ok (???, 11814 gas)
           revert code: 8000000000000000
             panic message: Error E.
             panic value:   E([AsciiString { data: "to have" }, AsciiString { data: "strings" }, AsciiString { data: "in error enum variants" }])
             panicked:      in panicking_lib::nested_panic_inlined
                                at panicking_lib, src/lib.sw:35:5
           decoded log values:
E([AsciiString { data: "to have" }, AsciiString { data: "strings" }, AsciiString { data: "in error enum variants" }]), log rb: 5503570629422409978
      test test_nested_panic_inlined_same_revert_code ... ok (???, 11814 gas)
           revert code: 8000000000000000
             panic message: Error E.
             panic value:   E([AsciiString { data: "to have" }, AsciiString { data: "strings" }, AsciiString { data: "in error enum variants" }])
             panicked:      in panicking_lib::nested_panic_inlined
                                at panicking_lib, src/lib.sw:35:5
           decoded log values:
E([AsciiString { data: "to have" }, AsciiString { data: "strings" }, AsciiString { data: "in error enum variants" }]), log rb: 5503570629422409978
      test test_nested_panic_non_inlined ... ok (???, 11868 gas)
           revert code: 8180000000000000
             panic message: Error E.
             panic value:   E([AsciiString { data: "this" }, AsciiString { data: "is not" }, AsciiString { data: "the best practice" }])
             panicked:      in panicking_lib::nested_panic_non_inlined
                                at panicking_lib, src/lib.sw:41:9
           decoded log values:
E([AsciiString { data: "this" }, AsciiString { data: "is not" }, AsciiString { data: "the best practice" }]), log rb: 5503570629422409978
      test test_nested_panic_non_inlined_same_revert_code ... ok (???, 11868 gas)
           revert code: 8180000000000000
             panic message: Error E.
             panic value:   E([AsciiString { data: "this" }, AsciiString { data: "is not" }, AsciiString { data: "the best practice" }])
             panicked:      in panicking_lib::nested_panic_non_inlined
                                at panicking_lib, src/lib.sw:41:9
           decoded log values:
E([AsciiString { data: "this" }, AsciiString { data: "is not" }, AsciiString { data: "the best practice" }]), log rb: 5503570629422409978
      test test_generic_panic_with_unit ... ok (???, 10758 gas)
           revert code: 8100000000000000
             panic value:   ()
             panicked:      in panicking_lib::generic_panic
                                at panicking_lib, src/lib.sw:74:5
           decoded log values:
(), log rb: 3330666440490685604
      test test_generic_panic_with_unit_same_revert_code ... ok (???, 10758 gas)
           revert code: 8100000000000000
             panic value:   ()
             panicked:      in panicking_lib::generic_panic
                                at panicking_lib, src/lib.sw:74:5
           decoded log values:
(), log rb: 3330666440490685604
      test test_generic_panic_with_str ... ok (???, 11039 gas)
           revert code: 8080000000000000
             panic message: generic panic with string
             panicked:      in panicking_lib::generic_panic
                                at panicking_lib, src/lib.sw:74:5
           decoded log values:
AsciiString { data: "generic panic with string" }, log rb: 10098701174489624218
      test test_generic_panic_with_different_str_same_revert_code ... ok (???, 11122 gas)
           revert code: 8080000000000000
             panic message: generic panic with different string
             panicked:      in panicking_lib::generic_panic
                                at panicking_lib, src/lib.sw:74:5
           decoded log values:
AsciiString { data: "generic panic with different string" }, log rb: 10098701174489624218
      test test_generic_panic_with_error_type_enum ... ok (???, 11091 gas)
           revert code: 8300000000000000
             panic message: Error A.
             panic value:   A
             panicked:      in panicking_lib::generic_panic
                                at panicking_lib, src/lib.sw:74:5
           decoded log values:
A, log rb: 5503570629422409978
      test test_generic_panic_with_error_type_enum_different_variant_same_revert_code ... ok (???, 11238 gas)
           revert code: 8300000000000000
             panic message: Error B.
             panic value:   B(42)
             panicked:      in panicking_lib::generic_panic
                                at panicking_lib, src/lib.sw:74:5
           decoded log values:
B(42), log rb: 5503570629422409978

test result: OK. 12 passed; 0 failed; finished in ???

    Finished in ???
