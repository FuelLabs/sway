---
source: test/src/snapshot/mod.rs
---
> forc test --path test/src/e2e_vm_tests/test_programs/should_pass/language/panic_expression/panicking_lib --test-threads 1 --logs --reverts
exit status: 0
output:
    Building test/src/e2e_vm_tests/test_programs/should_pass/language/panic_expression/panicking_lib
   Compiling library std (test/src/e2e_vm_tests/reduced_std_libs/sway-lib-std-core)
DIFF------------------------------
.program:
   Compiling library panicking_lib (test/src/e2e_vm_tests/test_programs/should_pass/language/panic_expression/panicking_lib)
DIFF------------------------------
.program:
DIFF------------------------------
.program:
.0                                      ; --- start of function: test_nested_panic_inlined ---
move $$locbase $sp                      ; [entry init: test_nested_panic_inlined]: set locals base register
cfei i0                                 ; [entry init: test_nested_panic_inlined]: allocate: locals 0 byte(s), call args 0 slot(s)
.62
movi $r1 i2                             ; initialize constant into register
 move $$arg0 $r1                         ; [call: call_nested_panic_inlined_0]: pass argument 0
 movi $$arg0 i2                          ; [call: call_nested_panic_inlined_0]: pass argument 0
fncall .2                               ; [call: call_nested_panic_inlined_0]: call function
 move $r2 $zero                          ; [call: call_nested_panic_inlined_0]: copy returned unit value
 movi $r2 i0                             ; [call: call_nested_panic_inlined_0]: copy returned unit value
ret $zero                               ; [entry end: test_nested_panic_inlined] return unit as zero
DIFF------------------------------
.program:
.20                                     ; --- start of function: test_nested_panic_inlined_same_revert_code ---
move $$locbase $sp                      ; [entry init: test_nested_panic_inlined_same_revert_code]: set locals base register
cfei i0                                 ; [entry init: test_nested_panic_inlined_same_revert_code]: allocate: locals 0 byte(s), call args 0 slot(s)
.114
movi $r485 i3                           ; initialize constant into register
 move $$arg0 $r485                       ; [call: call_nested_panic_inlined_0]: pass argument 0
 movi $$arg0 i3                          ; [call: call_nested_panic_inlined_0]: pass argument 0
fncall .2                               ; [call: call_nested_panic_inlined_0]: call function
 move $r486 $zero                        ; [call: call_nested_panic_inlined_0]: copy returned unit value
 movi $r486 i0                           ; [call: call_nested_panic_inlined_0]: copy returned unit value
ret $zero                               ; [entry end: test_nested_panic_inlined_same_revert_code] return unit as zero
DIFF------------------------------
.program:
.22                                     ; --- start of function: test_nested_panic_non_inlined ---
move $$locbase $sp                      ; [entry init: test_nested_panic_non_inlined]: set locals base register
cfei i0                                 ; [entry init: test_nested_panic_non_inlined]: allocate: locals 0 byte(s), call args 0 slot(s)
.115
movi $r488 i5                           ; initialize constant into register
 move $$arg0 $r488                       ; [call: call_nested_panic_non_inlined_31]: pass argument 0
 movi $$arg0 i5                          ; [call: call_nested_panic_non_inlined_31]: pass argument 0
fncall .24                              ; [call: call_nested_panic_non_inlined_31]: call function
 move $r489 $zero                        ; [call: call_nested_panic_non_inlined_31]: copy returned unit value
 movi $r489 i0                           ; [call: call_nested_panic_non_inlined_31]: copy returned unit value
ret $zero                               ; [entry end: test_nested_panic_non_inlined] return unit as zero
DIFF------------------------------
.program:
.28                                     ; --- start of function: test_nested_panic_non_inlined_same_revert_code ---
move $$locbase $sp                      ; [entry init: test_nested_panic_non_inlined_same_revert_code]: set locals base register
cfei i0                                 ; [entry init: test_nested_panic_non_inlined_same_revert_code]: allocate: locals 0 byte(s), call args 0 slot(s)
.120
movi $r541 i6                           ; initialize constant into register
 move $$arg0 $r541                       ; [call: call_nested_panic_non_inlined_31]: pass argument 0
 movi $$arg0 i6                          ; [call: call_nested_panic_non_inlined_31]: pass argument 0
fncall .24                              ; [call: call_nested_panic_non_inlined_31]: call function
 move $r542 $zero                        ; [call: call_nested_panic_non_inlined_31]: copy returned unit value
 movi $r542 i0                           ; [call: call_nested_panic_non_inlined_31]: copy returned unit value
ret $zero                               ; [entry end: test_nested_panic_non_inlined_same_revert_code] return unit as zero
DIFF------------------------------
.program:
.30                                     ; --- start of function: test_generic_panic_with_unit ---
move $$locbase $sp                      ; [entry init: test_generic_panic_with_unit]: set locals base register
cfei i32                                ; [entry init: test_generic_panic_with_unit]: allocate: locals 32 byte(s), call args 0 slot(s)
.121
addi $r544 $$locbase i32                ; get offset to local __ptr ()
addi $r545 $$locbase i32                ; get offset to local __ptr ()
addi $r546 $$locbase i16                ; get offset to local __ptr slice
move $$arg0 $r545                       ; [call: encode_allow_alias_34]: pass argument 0
move $$arg1 $r546                       ; [call: encode_allow_alias_34]: pass argument 1
fncall .32                              ; [call: encode_allow_alias_34]: call function
 move $r547 $zero                        ; [call: encode_allow_alias_34]: copy returned unit value
 movi $r547 i0                           ; [call: encode_allow_alias_34]: copy returned unit value
mcpi $$locbase $r546 i16                ; copy memory
load $r548 data_NonConfigurable_13      ; load constant from data section
lw $r549 $$locbase i0                   ; load slice pointer for logging data
lw $r550 $$locbase i1                   ; load slice size for logging data
logd $zero $r548 $r549 $r550            ; log slice
movi $r551 i7                           ; initialize constant into register
load $r552 data_NonConfigurable_4       ; load constant from data section
 and $r553 $r551 $r552
 andi $r553 $r552 i7
load $r554 data_NonConfigurable_14      ; load constant from data section
or $r555 $r554 $r553
rvrt $r555
DIFF------------------------------
.program:
.34                                     ; --- start of function: test_generic_panic_with_unit_same_revert_code ---
move $$locbase $sp                      ; [entry init: test_generic_panic_with_unit_same_revert_code]: set locals base register
cfei i32                                ; [entry init: test_generic_panic_with_unit_same_revert_code]: allocate: locals 32 byte(s), call args 0 slot(s)
.126
addi $r579 $$locbase i32                ; get offset to local __ptr ()
addi $r580 $$locbase i32                ; get offset to local __ptr ()
addi $r581 $$locbase i16                ; get offset to local __ptr slice
move $$arg0 $r580                       ; [call: encode_allow_alias_34]: pass argument 0
move $$arg1 $r581                       ; [call: encode_allow_alias_34]: pass argument 1
fncall .32                              ; [call: encode_allow_alias_34]: call function
 move $r582 $zero                        ; [call: encode_allow_alias_34]: copy returned unit value
 movi $r582 i0                           ; [call: encode_allow_alias_34]: copy returned unit value
mcpi $$locbase $r581 i16                ; copy memory
load $r583 data_NonConfigurable_13      ; load constant from data section
lw $r584 $$locbase i0                   ; load slice pointer for logging data
lw $r585 $$locbase i1                   ; load slice size for logging data
logd $zero $r583 $r584 $r585            ; log slice
movi $r586 i8                           ; initialize constant into register
load $r587 data_NonConfigurable_4       ; load constant from data section
 and $r588 $r586 $r587
 andi $r588 $r587 i8
load $r589 data_NonConfigurable_14      ; load constant from data section
or $r590 $r589 $r588
rvrt $r590
DIFF------------------------------
.program:
.36                                     ; --- start of function: test_generic_panic_with_str ---
move $$locbase $sp                      ; [entry init: test_generic_panic_with_str]: set locals base register
cfei i32                                ; [entry init: test_generic_panic_with_str]: allocate: locals 32 byte(s), call args 0 slot(s)
.127
addr $r592 data_NonConfigurable_15      ; get __const_global5's address in data section
sw $$locbase $r592 i0                   ; store word
addi $r593 $$locbase i8                 ; get offset to aggregate element
movi $r594 i25                          ; initialize constant into register
sw $$locbase $r594 i1                   ; store word
addi $r595 $$locbase i16                ; get offset to local __ptr slice
mcpi $r595 $$locbase i16                ; copy memory
addi $r596 $$locbase i16                ; get offset to local __ptr slice
move $$arg0 $r596                       ; [call: generic_panic_36]: pass argument 0
movi $r597 i9                           ; initialize constant into register
 move $$arg1 $r597                       ; [call: generic_panic_36]: pass argument 1
 movi $$arg1 i9                          ; [call: generic_panic_36]: pass argument 1
fncall .38                              ; [call: generic_panic_36]: call function
 move $r598 $zero                        ; [call: generic_panic_36]: copy returned unit value
 movi $r598 i0                           ; [call: generic_panic_36]: copy returned unit value
ret $zero                               ; [entry end: test_generic_panic_with_str] return unit as zero
DIFF------------------------------
.program:
.40                                     ; --- start of function: test_generic_panic_with_different_str_same_revert_code ---
move $$locbase $sp                      ; [entry init: test_generic_panic_with_different_str_same_revert_code]: set locals base register
cfei i32                                ; [entry init: test_generic_panic_with_different_str_same_revert_code]: allocate: locals 32 byte(s), call args 0 slot(s)
.132
addr $r639 data_NonConfigurable_18      ; get __const_global6's address in data section
sw $$locbase $r639 i0                   ; store word
addi $r640 $$locbase i8                 ; get offset to aggregate element
movi $r641 i30                          ; initialize constant into register
sw $$locbase $r641 i1                   ; store word
addi $r642 $$locbase i16                ; get offset to local __ptr slice
mcpi $r642 $$locbase i16                ; copy memory
addi $r643 $$locbase i16                ; get offset to local __ptr slice
move $$arg0 $r643                       ; [call: generic_panic_36]: pass argument 0
movi $r644 i10                          ; initialize constant into register
 move $$arg1 $r644                       ; [call: generic_panic_36]: pass argument 1
 movi $$arg1 i10                         ; [call: generic_panic_36]: pass argument 1
fncall .38                              ; [call: generic_panic_36]: call function
 move $r645 $zero                        ; [call: generic_panic_36]: copy returned unit value
 movi $r645 i0                           ; [call: generic_panic_36]: copy returned unit value
ret $zero                               ; [entry end: test_generic_panic_with_different_str_same_revert_code] return unit as zero
DIFF------------------------------
.program:
.42                                     ; --- start of function: test_generic_panic_with_error_type_enum_variant ---
move $$locbase $sp                      ; [entry init: test_generic_panic_with_error_type_enum_variant]: set locals base register
cfei i144                               ; [entry init: test_generic_panic_with_error_type_enum_variant]: allocate: locals 144 byte(s), call args 0 slot(s)
.133
sw $$locbase $zero i0                   ; store word
addi $r647 $$locbase i88                ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
mcpi $r647 $$locbase i56                ; copy memory
addi $r648 $$locbase i88                ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
addi $r649 $$locbase i72                ; get offset to local __ptr slice
move $$arg0 $r648                       ; [call: encode_allow_alias_2]: pass argument 0
move $$arg1 $r649                       ; [call: encode_allow_alias_2]: pass argument 1
fncall .4                               ; [call: encode_allow_alias_2]: call function
 move $r650 $zero                        ; [call: encode_allow_alias_2]: copy returned unit value
 movi $r650 i0                           ; [call: encode_allow_alias_2]: copy returned unit value
addi $r651 $$locbase i56                ; get offset to local __ptr slice
mcpi $r651 $r649 i16                    ; copy memory
load $r652 data_NonConfigurable_3       ; load constant from data section
lw $r653 $$locbase i7                   ; load slice pointer for logging data
lw $r654 $$locbase i8                   ; load slice size for logging data
logd $zero $r652 $r653 $r654            ; log slice
movi $r655 i11                          ; initialize constant into register
load $r656 data_NonConfigurable_4       ; load constant from data section
 and $r657 $r655 $r656
 andi $r657 $r656 i11
load $r658 data_NonConfigurable_19      ; load constant from data section
or $r659 $r658 $r657
rvrt $r659
DIFF------------------------------
.program:
.44                                     ; --- start of function: test_generic_panic_with_error_type_enum_different_variant_same_revert_code ---
move $$locbase $sp                      ; [entry init: test_generic_panic_with_error_type_enum_different_variant_same_revert_code]: set locals base register
cfei i144                               ; [entry init: test_generic_panic_with_error_type_enum_different_variant_same_revert_code]: allocate: locals 144 byte(s), call args 0 slot(s)
.134
sw $$locbase $zero i0                   ; store word
addi $r661 $$locbase i88                ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
mcpi $r661 $$locbase i56                ; copy memory
addi $r662 $$locbase i88                ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
addi $r663 $$locbase i72                ; get offset to local __ptr slice
move $$arg0 $r662                       ; [call: encode_allow_alias_2]: pass argument 0
move $$arg1 $r663                       ; [call: encode_allow_alias_2]: pass argument 1
fncall .4                               ; [call: encode_allow_alias_2]: call function
 move $r664 $zero                        ; [call: encode_allow_alias_2]: copy returned unit value
 movi $r664 i0                           ; [call: encode_allow_alias_2]: copy returned unit value
addi $r665 $$locbase i56                ; get offset to local __ptr slice
mcpi $r665 $r663 i16                    ; copy memory
load $r666 data_NonConfigurable_3       ; load constant from data section
lw $r667 $$locbase i7                   ; load slice pointer for logging data
lw $r668 $$locbase i8                   ; load slice size for logging data
logd $zero $r666 $r667 $r668            ; log slice
movi $r669 i12                          ; initialize constant into register
load $r670 data_NonConfigurable_4       ; load constant from data section
 and $r671 $r669 $r670
 andi $r671 $r670 i12
load $r672 data_NonConfigurable_19      ; load constant from data section
or $r673 $r672 $r671
rvrt $r673
DIFF------------------------------
.program:
.46                                     ; --- start of function: test_panic_without_arg ---
move $$locbase $sp                      ; [entry init: test_panic_without_arg]: set locals base register
cfei i32                                ; [entry init: test_panic_without_arg]: allocate: locals 32 byte(s), call args 0 slot(s)
.135
addi $r675 $$locbase i16                ; get offset to local __ptr slice
move $$arg0 $$locbase                   ; [call: encode_allow_alias_34]: pass argument 0
move $$arg1 $r675                       ; [call: encode_allow_alias_34]: pass argument 1
fncall .32                              ; [call: encode_allow_alias_34]: call function
 move $r676 $zero                        ; [call: encode_allow_alias_34]: copy returned unit value
 movi $r676 i0                           ; [call: encode_allow_alias_34]: copy returned unit value
mcpi $$locbase $r675 i16                ; copy memory
load $r677 data_NonConfigurable_13      ; load constant from data section
lw $r678 $$locbase i0                   ; load slice pointer for logging data
lw $r679 $$locbase i1                   ; load slice size for logging data
logd $zero $r677 $r678 $r679            ; log slice
load $r680 data_NonConfigurable_20      ; load constant from data section
rvrt $r680
DIFF------------------------------
.program:
.48                                     ; --- start of function: test_panic_with_unit ---
move $$locbase $sp                      ; [entry init: test_panic_with_unit]: set locals base register
cfei i32                                ; [entry init: test_panic_with_unit]: allocate: locals 32 byte(s), call args 0 slot(s)
.136
addi $r682 $$locbase i16                ; get offset to local __ptr slice
move $$arg0 $$locbase                   ; [call: encode_allow_alias_34]: pass argument 0
move $$arg1 $r682                       ; [call: encode_allow_alias_34]: pass argument 1
fncall .32                              ; [call: encode_allow_alias_34]: call function
 move $r683 $zero                        ; [call: encode_allow_alias_34]: copy returned unit value
 movi $r683 i0                           ; [call: encode_allow_alias_34]: copy returned unit value
mcpi $$locbase $r682 i16                ; copy memory
load $r684 data_NonConfigurable_13      ; load constant from data section
lw $r685 $$locbase i0                   ; load slice pointer for logging data
lw $r686 $$locbase i1                   ; load slice size for logging data
logd $zero $r684 $r685 $r686            ; log slice
load $r687 data_NonConfigurable_21      ; load constant from data section
rvrt $r687
DIFF------------------------------
.program:
.50                                     ; --- start of function: test_panic_with_str ---
move $$locbase $sp                      ; [entry init: test_panic_with_str]: set locals base register
cfei i0                                 ; [entry init: test_panic_with_str]: allocate: locals 0 byte(s), call args 0 slot(s)
.137
load $r689 data_NonConfigurable_22      ; load constant from data section
rvrt $r689
DIFF------------------------------
.program:
.52                                     ; --- start of function: test_panic_with_error_type_enum ---
move $$locbase $sp                      ; [entry init: test_panic_with_error_type_enum]: set locals base register
cfei i88                                ; [entry init: test_panic_with_error_type_enum]: allocate: locals 88 byte(s), call args 0 slot(s)
.138
movi $r691 i2                           ; initialize constant into register
sw $$locbase $r691 i0                   ; store word
addi $r692 $$locbase i55                ; get offset to aggregate element
sb $r692 $one i0                        ; store byte
addi $r693 $$locbase i72                ; get offset to local __ptr slice
move $$arg0 $$locbase                   ; [call: encode_allow_alias_2]: pass argument 0
move $$arg1 $r693                       ; [call: encode_allow_alias_2]: pass argument 1
fncall .4                               ; [call: encode_allow_alias_2]: call function
 move $r694 $zero                        ; [call: encode_allow_alias_2]: copy returned unit value
 movi $r694 i0                           ; [call: encode_allow_alias_2]: copy returned unit value
addi $r695 $$locbase i56                ; get offset to local __ptr slice
mcpi $r695 $r693 i16                    ; copy memory
load $r696 data_NonConfigurable_3       ; load constant from data section
lw $r697 $$locbase i7                   ; load slice pointer for logging data
lw $r698 $$locbase i8                   ; load slice size for logging data
logd $zero $r696 $r697 $r698            ; log slice
load $r699 data_NonConfigurable_23      ; load constant from data section
rvrt $r699
DIFF------------------------------
.program:
.54                                     ; --- start of function: test_panic_with_generic_error_type_enum ---
move $$locbase $sp                      ; [entry init: test_panic_with_generic_error_type_enum]: set locals base register
cfei i504                               ; [entry init: test_panic_with_generic_error_type_enum]: allocate: locals 504 byte(s), call args 0 slot(s)
.139
sw $$locbase $zero i0                   ; store word
addi $r701 $$locbase i8                 ; get offset to aggregate element
movi $r702 i42                          ; initialize constant into register
sw $$locbase $r702 i1                   ; store word
addi $r703 $$locbase i440               ; get offset to local __ptr __ptr { u64, ( u64 | bool ) }
sw $$locbase $$locbase i55              ; store word
addi $r704 $$locbase i472               ; get offset to local __ptr u64
load $r705 data_NonConfigurable_24      ; load constant from data section
sw $$locbase $r705 i59                  ; store word
addi $r706 $$locbase i448               ; get offset to local __ptr u64
load $r707 data_NonConfigurable_25      ; load constant from data section
sw $$locbase $r707 i56                  ; store word
addi $r708 $$locbase i472               ; get offset to local __ptr u64
lw $r709 $$locbase i59                  ; load word
addi $r710 $$locbase i448               ; get offset to local __ptr u64
lw $r711 $$locbase i56                  ; load word
eq $r712 $r709 $r711
move $r713 $r712                        ; move parameter from branch to block argument
jnzi $r712 .140
ji  .141
.140
 move $r713 $one                         ; move parameter from branch to block argument
 movi $r713 i1                           ; move parameter from branch to block argument
ji  .141
.141
move $r716 $r713                        ; move parameter from branch to block argument
 move $r717 $r716                        ; move parameter from branch to block argument
 jnzi $r716 .142
 move $r717 $r713                        ; move parameter from branch to block argument
 jnzi $r713 .142
ji  .143
.142
 move $r717 $one                         ; move parameter from branch to block argument
 movi $r717 i1                           ; move parameter from branch to block argument
ji  .143
.143
move $r720 $r717                        ; move parameter from branch to block argument
 jnzi $r720 .144
 jnzi $r717 .144
ji  .145
.145
addi $r721 $$locbase i440               ; get offset to local __ptr __ptr { u64, ( u64 | bool ) }
lw $r722 $$locbase i55                  ; load word
addi $r723 $$locbase i160               ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r723                       ; [call: new_29]: pass argument 0
fncall .16                              ; [call: new_29]: call function
 move $r724 $zero                        ; [call: new_29]: copy returned unit value
 movi $r724 i0                           ; [call: new_29]: copy returned unit value
addi $r725 $$locbase i480               ; get offset to local __ptr { u64, ( u64 | bool ) }
mcpi $r725 $r722 i16                    ; copy memory
addi $r726 $$locbase i320               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r726 $r723 i24                    ; copy memory
addi $r727 $$locbase i480               ; get offset to local __ptr { u64, ( u64 | bool ) }
addi $r728 $$locbase i48                ; get offset to local __ptr { u64, ( u64 | bool ) }
mcpi $r728 $r727 i16                    ; copy memory
addi $r729 $$locbase i480               ; get offset to local __ptr { u64, ( u64 | bool ) }
addi $r730 $$locbase i456               ; get offset to local __ptr u64
sw $$locbase $zero i57                  ; store word
lw $r731 $$locbase i60                  ; load word
addi $r732 $$locbase i456               ; get offset to local __ptr u64
lw $r733 $$locbase i57                  ; load word
eq $r734 $r731 $r733
jnzi $r734 .146
ji  .147
.147
addi $r735 $$locbase i48                ; get offset to local __ptr { u64, ( u64 | bool ) }
addi $r736 $$locbase i464               ; get offset to local __ptr u64
sw $$locbase $one i58                   ; store word
lw $r737 $$locbase i6                   ; load word
addi $r738 $$locbase i464               ; get offset to local __ptr u64
lw $r739 $$locbase i58                  ; load word
eq $r740 $r737 $r739
jnzi $r740 .148
ji  .149
.149
load $r741 data_NonConfigurable_8       ; load constant from data section
rvrt $r741
.148
addi $r742 $$locbase i48                ; get offset to local __ptr { u64, ( u64 | bool ) }
addi $r743 $r742 i15                    ; get offset to aggregate element
addi $r744 $$locbase i320               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r745 $$locbase i112               ; get offset to local __ptr { { ptr, u64, u64 } }
 move $$arg0 $one                        ; [call: abi_encode_21]: pass argument 0
 movi $$arg0 i1                          ; [call: abi_encode_21]: pass argument 0
move $$arg1 $r744                       ; [call: abi_encode_21]: pass argument 1
move $$arg2 $r745                       ; [call: abi_encode_21]: pass argument 2
fncall .10                              ; [call: abi_encode_21]: call function
 move $r746 $zero                        ; [call: abi_encode_21]: copy returned unit value
 movi $r746 i0                           ; [call: abi_encode_21]: copy returned unit value
addi $r747 $$locbase i392               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r747 $r745 i24                    ; copy memory
lb $r748 $r743 i0                       ; load byte
addi $r749 $$locbase i392               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r750 $$locbase i136               ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r748                       ; [call: abi_encode_23]: pass argument 0
move $$arg1 $r749                       ; [call: abi_encode_23]: pass argument 1
move $$arg2 $r750                       ; [call: abi_encode_23]: pass argument 2
fncall .12                              ; [call: abi_encode_23]: call function
 move $r751 $zero                        ; [call: abi_encode_23]: copy returned unit value
 movi $r751 i0                           ; [call: abi_encode_23]: copy returned unit value
addi $r752 $$locbase i416               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r752 $r750 i24                    ; copy memory
addi $r753 $$locbase i416               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r754 $$locbase i200               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r754 $r753 i24                    ; copy memory
addi $r755 $$locbase i224               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r755 $r754 i24                    ; copy memory
move $r756 $r755                        ; move parameter from branch to block argument
ji  .150
.146
addi $r757 $$locbase i48                ; get offset to local __ptr { u64, ( u64 | bool ) }
addi $r758 $r757 i8                     ; get offset to aggregate element
addi $r759 $$locbase i320               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r760 $$locbase i64                ; get offset to local __ptr { { ptr, u64, u64 } }
 move $$arg0 $zero                       ; [call: abi_encode_21]: pass argument 0
 movi $$arg0 i0                          ; [call: abi_encode_21]: pass argument 0
move $$arg1 $r759                       ; [call: abi_encode_21]: pass argument 1
move $$arg2 $r760                       ; [call: abi_encode_21]: pass argument 2
fncall .10                              ; [call: abi_encode_21]: call function
 move $r761 $zero                        ; [call: abi_encode_21]: copy returned unit value
 movi $r761 i0                           ; [call: abi_encode_21]: copy returned unit value
addi $r762 $$locbase i344               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r762 $r760 i24                    ; copy memory
lw $r763 $r758 i0                       ; load word
addi $r764 $$locbase i344               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r765 $$locbase i88                ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r763                       ; [call: abi_encode_21]: pass argument 0
move $$arg1 $r764                       ; [call: abi_encode_21]: pass argument 1
move $$arg2 $r765                       ; [call: abi_encode_21]: pass argument 2
fncall .10                              ; [call: abi_encode_21]: call function
 move $r766 $zero                        ; [call: abi_encode_21]: copy returned unit value
 movi $r766 i0                           ; [call: abi_encode_21]: copy returned unit value
addi $r767 $$locbase i368               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r767 $r765 i24                    ; copy memory
addi $r768 $$locbase i368               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r769 $$locbase i224               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r769 $r768 i24                    ; copy memory
move $r756 $r769                        ; move parameter from branch to block argument
ji  .150
.150
move $r772 $r756                        ; move parameter from branch to block argument
addi $r773 $$locbase i248               ; get offset to local __ptr { { ptr, u64, u64 } }
 mcpi $r773 $r772 i24                    ; copy memory
 mcpi $r773 $r756 i24                    ; copy memory
addi $r774 $$locbase i184               ; get offset to local __ptr slice
move $$arg0 $r773                       ; [call: as_raw_slice_30]: pass argument 0
move $$arg1 $r774                       ; [call: as_raw_slice_30]: pass argument 1
fncall .18                              ; [call: as_raw_slice_30]: call function
 move $r775 $zero                        ; [call: as_raw_slice_30]: copy returned unit value
 movi $r775 i0                           ; [call: as_raw_slice_30]: copy returned unit value
addi $r776 $$locbase i272               ; get offset to local __ptr slice
mcpi $r776 $r774 i16                    ; copy memory
move $r777 $r776                        ; move parameter from branch to block argument
ji  .151
.144
addi $r778 $$locbase i496               ; get offset to local __ptr u64
movi $r779 i16                          ; initialize constant into register
sw $$locbase $r779 i62                  ; store word
addi $r780 $$locbase i304               ; get offset to local __ptr { __ptr { u64, ( u64 | bool ) }, u64 }
addi $r781 $$locbase i440               ; get offset to local __ptr __ptr { u64, ( u64 | bool ) }
addi $r782 $$locbase i496               ; get offset to local __ptr u64
mcpi $r780 $r781 i8                     ; copy memory
addi $r783 $r780 i8                     ; get offset to aggregate element
mcpi $r783 $r782 i8                     ; copy memory
addi $r784 $$locbase i16                ; get offset to local __ptr { __ptr { u64, ( u64 | bool ) }, u64 }
mcpi $r784 $r780 i16                    ; copy memory
addi $r785 $$locbase i272               ; get offset to local __ptr slice
mcpi $r785 $r784 i16                    ; copy memory
move $r777 $r785                        ; move parameter from branch to block argument
ji  .151
.151
move $r788 $r777                        ; move parameter from branch to block argument
addi $r789 $$locbase i288               ; get offset to local __ptr slice
 mcpi $r789 $r788 i16                    ; copy memory
 mcpi $r789 $r777 i16                    ; copy memory
addi $r790 $$locbase i32                ; get offset to local __ptr slice
mcpi $r790 $r789 i16                    ; copy memory
load $r791 data_NonConfigurable_26      ; load constant from data section
lw $r792 $$locbase i4                   ; load slice pointer for logging data
lw $r793 $$locbase i5                   ; load slice size for logging data
logd $zero $r791 $r792 $r793            ; log slice
load $r794 data_NonConfigurable_27      ; load constant from data section
rvrt $r794
DIFF------------------------------
.program:
.56                                     ; --- start of function: test_panic_with_nested_generic_error_type ---
move $$locbase $sp                      ; [entry init: test_panic_with_nested_generic_error_type]: set locals base register
cfei i1128                              ; [entry init: test_panic_with_nested_generic_error_type]: allocate: locals 1128 byte(s), call args 0 slot(s)
.152
sw $$locbase $one i0                    ; store word
addi $r796 $$locbase i88                ; get offset to local __ptr { u64, ( bool | { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) } ) }
sw $$locbase $one i11                   ; store word
addi $r797 $$locbase i152               ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
movi $r798 i2                           ; initialize constant into register
sw $$locbase $r798 i19                  ; store word
addi $r799 $r797 i55                    ; get offset to aggregate element
sb $r799 $one i0                        ; store byte
addi $r800 $r796 i8                     ; get offset to aggregate element
mcpi $r800 $r797 i56                    ; copy memory
addi $r801 $$locbase i8                 ; get offset to aggregate element
mcpi $r801 $r796 i64                    ; copy memory
addi $r802 $$locbase i976               ; get offset to local __ptr __ptr { u64, ( u64 | { u64, ( bool | { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) } ) } ) }
sw $$locbase $$locbase i122             ; store word
addi $r803 $$locbase i1032              ; get offset to local __ptr u64
load $r804 data_NonConfigurable_28      ; load constant from data section
sw $$locbase $r804 i129                 ; store word
addi $r805 $$locbase i984               ; get offset to local __ptr u64
sw $$locbase $zero i123                 ; store word
addi $r806 $$locbase i1032              ; get offset to local __ptr u64
lw $r807 $$locbase i129                 ; load word
addi $r808 $$locbase i984               ; get offset to local __ptr u64
lw $r809 $$locbase i123                 ; load word
eq $r810 $r807 $r809
move $r811 $r810                        ; move parameter from branch to block argument
jnzi $r810 .153
ji  .154
.153
 move $r811 $one                         ; move parameter from branch to block argument
 movi $r811 i1                           ; move parameter from branch to block argument
ji  .154
.154
move $r814 $r811                        ; move parameter from branch to block argument
 move $r815 $r814                        ; move parameter from branch to block argument
 jnzi $r814 .155
 move $r815 $r811                        ; move parameter from branch to block argument
 jnzi $r811 .155
ji  .156
.155
addi $r816 $$locbase i1040              ; get offset to local __ptr u64
load $r817 data_NonConfigurable_29      ; load constant from data section
sw $$locbase $r817 i130                 ; store word
addi $r818 $$locbase i992               ; get offset to local __ptr u64
sw $$locbase $zero i124                 ; store word
addi $r819 $$locbase i1040              ; get offset to local __ptr u64
lw $r820 $$locbase i130                 ; load word
addi $r821 $$locbase i992               ; get offset to local __ptr u64
lw $r822 $$locbase i124                 ; load word
eq $r823 $r820 $r822
move $r824 $r823                        ; move parameter from branch to block argument
jnzi $r823 .157
ji  .158
.157
 move $r824 $one                         ; move parameter from branch to block argument
 movi $r824 i1                           ; move parameter from branch to block argument
ji  .158
.158
move $r827 $r824                        ; move parameter from branch to block argument
 move $r828 $r827                        ; move parameter from branch to block argument
 jnzi $r827 .159
 move $r828 $r824                        ; move parameter from branch to block argument
 jnzi $r824 .159
ji  .160
.159
fncall .6                               ; [call: is_encode_trivial_3]: call function
move $r829 $$retv                       ; [call: is_encode_trivial_3]: copy returned value
 move $r828 $r829                        ; move parameter from branch to block argument
 move $r828 $$retv                       ; move parameter from branch to block argument
ji  .160
.160
move $r832 $r828                        ; move parameter from branch to block argument
 move $r815 $r832                        ; move parameter from branch to block argument
 move $r815 $r828                        ; move parameter from branch to block argument
ji  .156
.156
move $r835 $r815                        ; move parameter from branch to block argument
 jnzi $r835 .161
 jnzi $r815 .161
ji  .162
.162
addi $r836 $$locbase i976               ; get offset to local __ptr __ptr { u64, ( u64 | { u64, ( bool | { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) } ) } ) }
lw $r837 $$locbase i122                 ; load word
addi $r838 $$locbase i528               ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r838                       ; [call: new_29]: pass argument 0
fncall .16                              ; [call: new_29]: call function
 move $r839 $zero                        ; [call: new_29]: copy returned unit value
 movi $r839 i0                           ; [call: new_29]: copy returned unit value
addi $r840 $$locbase i1048              ; get offset to local __ptr { u64, ( u64 | { u64, ( bool | { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) } ) } ) }
mcpi $r840 $r837 i72                    ; copy memory
addi $r841 $$locbase i760               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r841 $r838 i24                    ; copy memory
addi $r842 $$locbase i1048              ; get offset to local __ptr { u64, ( u64 | { u64, ( bool | { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) } ) } ) }
addi $r843 $$locbase i224               ; get offset to local __ptr { u64, ( u64 | { u64, ( bool | { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) } ) } ) }
mcpi $r843 $r842 i72                    ; copy memory
addi $r844 $$locbase i1048              ; get offset to local __ptr { u64, ( u64 | { u64, ( bool | { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) } ) } ) }
addi $r845 $$locbase i1016              ; get offset to local __ptr u64
sw $$locbase $zero i127                 ; store word
lw $r846 $$locbase i131                 ; load word
addi $r847 $$locbase i1016              ; get offset to local __ptr u64
lw $r848 $$locbase i127                 ; load word
eq $r849 $r846 $r848
jnzi $r849 .163
ji  .164
.164
addi $r850 $$locbase i224               ; get offset to local __ptr { u64, ( u64 | { u64, ( bool | { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) } ) } ) }
addi $r851 $$locbase i1000              ; get offset to local __ptr u64
sw $$locbase $one i125                  ; store word
lw $r852 $$locbase i28                  ; load word
addi $r853 $$locbase i1000              ; get offset to local __ptr u64
lw $r854 $$locbase i125                 ; load word
eq $r855 $r852 $r854
jnzi $r855 .165
ji  .166
.166
load $r856 data_NonConfigurable_8       ; load constant from data section
rvrt $r856
.165
addi $r857 $$locbase i224               ; get offset to local __ptr { u64, ( u64 | { u64, ( bool | { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) } ) } ) }
addi $r858 $r857 i8                     ; get offset to aggregate element
addi $r859 $$locbase i760               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r860 $$locbase i432               ; get offset to local __ptr { { ptr, u64, u64 } }
 move $$arg0 $one                        ; [call: abi_encode_21]: pass argument 0
 movi $$arg0 i1                          ; [call: abi_encode_21]: pass argument 0
move $$arg1 $r859                       ; [call: abi_encode_21]: pass argument 1
move $$arg2 $r860                       ; [call: abi_encode_21]: pass argument 2
fncall .10                              ; [call: abi_encode_21]: call function
 move $r861 $zero                        ; [call: abi_encode_21]: copy returned unit value
 movi $r861 i0                           ; [call: abi_encode_21]: copy returned unit value
addi $r862 $$locbase i904               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r862 $r860 i24                    ; copy memory
addi $r863 $$locbase i904               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r864 $$locbase i784               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r864 $r863 i24                    ; copy memory
addi $r865 $$locbase i296               ; get offset to local __ptr { u64, ( bool | { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) } ) }
mcpi $r865 $r858 i64                    ; copy memory
addi $r866 $$locbase i296               ; get offset to local __ptr { u64, ( bool | { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) } ) }
addi $r867 $$locbase i1024              ; get offset to local __ptr u64
sw $$locbase $zero i128                 ; store word
lw $r868 $$locbase i37                  ; load word
addi $r869 $$locbase i1024              ; get offset to local __ptr u64
lw $r870 $$locbase i128                 ; load word
eq $r871 $r868 $r870
jnzi $r871 .167
ji  .168
.168
addi $r872 $$locbase i296               ; get offset to local __ptr { u64, ( bool | { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) } ) }
addi $r873 $$locbase i1008              ; get offset to local __ptr u64
sw $$locbase $one i126                  ; store word
lw $r874 $$locbase i37                  ; load word
addi $r875 $$locbase i1008              ; get offset to local __ptr u64
lw $r876 $$locbase i126                 ; load word
eq $r877 $r874 $r876
jnzi $r877 .169
ji  .170
.170
load $r878 data_NonConfigurable_8       ; load constant from data section
rvrt $r878
.169
addi $r879 $$locbase i296               ; get offset to local __ptr { u64, ( bool | { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) } ) }
addi $r880 $r879 i8                     ; get offset to aggregate element
addi $r881 $$locbase i784               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r882 $$locbase i480               ; get offset to local __ptr { { ptr, u64, u64 } }
 move $$arg0 $one                        ; [call: abi_encode_21]: pass argument 0
 movi $$arg0 i1                          ; [call: abi_encode_21]: pass argument 0
move $$arg1 $r881                       ; [call: abi_encode_21]: pass argument 1
move $$arg2 $r882                       ; [call: abi_encode_21]: pass argument 2
fncall .10                              ; [call: abi_encode_21]: call function
 move $r883 $zero                        ; [call: abi_encode_21]: copy returned unit value
 movi $r883 i0                           ; [call: abi_encode_21]: copy returned unit value
addi $r884 $$locbase i928               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r884 $r882 i24                    ; copy memory
addi $r885 $$locbase i928               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r886 $$locbase i360               ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r880                       ; [call: abi_encode_20]: pass argument 0
move $$arg1 $r885                       ; [call: abi_encode_20]: pass argument 1
move $$arg2 $r886                       ; [call: abi_encode_20]: pass argument 2
fncall .8                               ; [call: abi_encode_20]: call function
 move $r887 $zero                        ; [call: abi_encode_20]: copy returned unit value
 movi $r887 i0                           ; [call: abi_encode_20]: copy returned unit value
addi $r888 $$locbase i952               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r888 $r886 i24                    ; copy memory
addi $r889 $$locbase i952               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r890 $$locbase i568               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r890 $r889 i24                    ; copy memory
addi $r891 $$locbase i592               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r891 $r890 i24                    ; copy memory
move $r892 $r891                        ; move parameter from branch to block argument
ji  .171
.167
addi $r893 $$locbase i296               ; get offset to local __ptr { u64, ( bool | { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) } ) }
addi $r894 $r893 i63                    ; get offset to aggregate element
addi $r895 $$locbase i784               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r896 $$locbase i456               ; get offset to local __ptr { { ptr, u64, u64 } }
 move $$arg0 $zero                       ; [call: abi_encode_21]: pass argument 0
 movi $$arg0 i0                          ; [call: abi_encode_21]: pass argument 0
move $$arg1 $r895                       ; [call: abi_encode_21]: pass argument 1
move $$arg2 $r896                       ; [call: abi_encode_21]: pass argument 2
fncall .10                              ; [call: abi_encode_21]: call function
 move $r897 $zero                        ; [call: abi_encode_21]: copy returned unit value
 movi $r897 i0                           ; [call: abi_encode_21]: copy returned unit value
addi $r898 $$locbase i832               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r898 $r896 i24                    ; copy memory
lb $r899 $r894 i0                       ; load byte
addi $r900 $$locbase i832               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r901 $$locbase i504               ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r899                       ; [call: abi_encode_23]: pass argument 0
move $$arg1 $r900                       ; [call: abi_encode_23]: pass argument 1
move $$arg2 $r901                       ; [call: abi_encode_23]: pass argument 2
fncall .12                              ; [call: abi_encode_23]: call function
 move $r902 $zero                        ; [call: abi_encode_23]: copy returned unit value
 movi $r902 i0                           ; [call: abi_encode_23]: copy returned unit value
addi $r903 $$locbase i880               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r903 $r901 i24                    ; copy memory
addi $r904 $$locbase i880               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r905 $$locbase i592               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r905 $r904 i24                    ; copy memory
move $r892 $r905                        ; move parameter from branch to block argument
ji  .171
.171
move $r908 $r892                        ; move parameter from branch to block argument
addi $r909 $$locbase i616               ; get offset to local __ptr { { ptr, u64, u64 } }
 mcpi $r909 $r908 i24                    ; copy memory
 mcpi $r909 $r892 i24                    ; copy memory
addi $r910 $$locbase i640               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r910 $r909 i24                    ; copy memory
addi $r911 $$locbase i664               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r911 $r910 i24                    ; copy memory
move $r912 $r911                        ; move parameter from branch to block argument
ji  .172
.163
addi $r913 $$locbase i224               ; get offset to local __ptr { u64, ( u64 | { u64, ( bool | { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) } ) } ) }
addi $r914 $r913 i64                    ; get offset to aggregate element
addi $r915 $$locbase i760               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r916 $$locbase i384               ; get offset to local __ptr { { ptr, u64, u64 } }
 move $$arg0 $zero                       ; [call: abi_encode_21]: pass argument 0
 movi $$arg0 i0                          ; [call: abi_encode_21]: pass argument 0
move $$arg1 $r915                       ; [call: abi_encode_21]: pass argument 1
move $$arg2 $r916                       ; [call: abi_encode_21]: pass argument 2
fncall .10                              ; [call: abi_encode_21]: call function
 move $r917 $zero                        ; [call: abi_encode_21]: copy returned unit value
 movi $r917 i0                           ; [call: abi_encode_21]: copy returned unit value
addi $r918 $$locbase i808               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r918 $r916 i24                    ; copy memory
lw $r919 $r914 i0                       ; load word
addi $r920 $$locbase i808               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r921 $$locbase i408               ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r919                       ; [call: abi_encode_21]: pass argument 0
move $$arg1 $r920                       ; [call: abi_encode_21]: pass argument 1
move $$arg2 $r921                       ; [call: abi_encode_21]: pass argument 2
fncall .10                              ; [call: abi_encode_21]: call function
 move $r922 $zero                        ; [call: abi_encode_21]: copy returned unit value
 movi $r922 i0                           ; [call: abi_encode_21]: copy returned unit value
addi $r923 $$locbase i856               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r923 $r921 i24                    ; copy memory
addi $r924 $$locbase i856               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r925 $$locbase i664               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r925 $r924 i24                    ; copy memory
move $r912 $r925                        ; move parameter from branch to block argument
ji  .172
.172
move $r928 $r912                        ; move parameter from branch to block argument
addi $r929 $$locbase i688               ; get offset to local __ptr { { ptr, u64, u64 } }
 mcpi $r929 $r928 i24                    ; copy memory
 mcpi $r929 $r912 i24                    ; copy memory
addi $r930 $$locbase i552               ; get offset to local __ptr slice
move $$arg0 $r929                       ; [call: as_raw_slice_30]: pass argument 0
move $$arg1 $r930                       ; [call: as_raw_slice_30]: pass argument 1
fncall .18                              ; [call: as_raw_slice_30]: call function
 move $r931 $zero                        ; [call: as_raw_slice_30]: copy returned unit value
 movi $r931 i0                           ; [call: as_raw_slice_30]: copy returned unit value
addi $r932 $$locbase i712               ; get offset to local __ptr slice
mcpi $r932 $r930 i16                    ; copy memory
move $r933 $r932                        ; move parameter from branch to block argument
ji  .173
.161
addi $r934 $$locbase i1120              ; get offset to local __ptr u64
movi $r935 i72                          ; initialize constant into register
sw $$locbase $r935 i140                 ; store word
addi $r936 $$locbase i744               ; get offset to local __ptr { __ptr { u64, ( u64 | { u64, ( bool | { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) } ) } ) }, u64 }
addi $r937 $$locbase i976               ; get offset to local __ptr __ptr { u64, ( u64 | { u64, ( bool | { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) } ) } ) }
addi $r938 $$locbase i1120              ; get offset to local __ptr u64
mcpi $r936 $r937 i8                     ; copy memory
addi $r939 $r936 i8                     ; get offset to aggregate element
mcpi $r939 $r938 i8                     ; copy memory
addi $r940 $$locbase i72                ; get offset to local __ptr { __ptr { u64, ( u64 | { u64, ( bool | { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) } ) } ) }, u64 }
mcpi $r940 $r936 i16                    ; copy memory
addi $r941 $$locbase i712               ; get offset to local __ptr slice
mcpi $r941 $r940 i16                    ; copy memory
move $r933 $r941                        ; move parameter from branch to block argument
ji  .173
.173
move $r944 $r933                        ; move parameter from branch to block argument
addi $r945 $$locbase i728               ; get offset to local __ptr slice
 mcpi $r945 $r944 i16                    ; copy memory
 mcpi $r945 $r933 i16                    ; copy memory
addi $r946 $$locbase i208               ; get offset to local __ptr slice
mcpi $r946 $r945 i16                    ; copy memory
load $r947 data_NonConfigurable_30      ; load constant from data section
lw $r948 $$locbase i26                  ; load slice pointer for logging data
lw $r949 $$locbase i27                  ; load slice size for logging data
logd $zero $r947 $r948 $r949            ; log slice
load $r950 data_NonConfigurable_31      ; load constant from data section
rvrt $r950
DIFF------------------------------
.program:
.58                                     ; --- start of function: test_panic_with_generic_error_type_enum_with_abi_encode ---
move $$locbase $sp                      ; [entry init: test_panic_with_generic_error_type_enum_with_abi_encode]: set locals base register
cfei i504                               ; [entry init: test_panic_with_generic_error_type_enum_with_abi_encode]: allocate: locals 504 byte(s), call args 0 slot(s)
.174
sw $$locbase $zero i0                   ; store word
addi $r952 $$locbase i8                 ; get offset to aggregate element
movi $r953 i42                          ; initialize constant into register
sw $$locbase $r953 i1                   ; store word
addi $r954 $$locbase i440               ; get offset to local __ptr __ptr { u64, ( u64 | bool ) }
sw $$locbase $$locbase i55              ; store word
addi $r955 $$locbase i472               ; get offset to local __ptr u64
load $r956 data_NonConfigurable_24      ; load constant from data section
sw $$locbase $r956 i59                  ; store word
addi $r957 $$locbase i448               ; get offset to local __ptr u64
load $r958 data_NonConfigurable_25      ; load constant from data section
sw $$locbase $r958 i56                  ; store word
addi $r959 $$locbase i472               ; get offset to local __ptr u64
lw $r960 $$locbase i59                  ; load word
addi $r961 $$locbase i448               ; get offset to local __ptr u64
lw $r962 $$locbase i56                  ; load word
eq $r963 $r960 $r962
move $r964 $r963                        ; move parameter from branch to block argument
jnzi $r963 .175
ji  .176
.175
 move $r964 $one                         ; move parameter from branch to block argument
 movi $r964 i1                           ; move parameter from branch to block argument
ji  .176
.176
move $r967 $r964                        ; move parameter from branch to block argument
 move $r968 $r967                        ; move parameter from branch to block argument
 jnzi $r967 .177
 move $r968 $r964                        ; move parameter from branch to block argument
 jnzi $r964 .177
ji  .178
.177
 move $r968 $one                         ; move parameter from branch to block argument
 movi $r968 i1                           ; move parameter from branch to block argument
ji  .178
.178
move $r971 $r968                        ; move parameter from branch to block argument
 jnzi $r971 .179
 jnzi $r968 .179
ji  .180
.180
addi $r972 $$locbase i440               ; get offset to local __ptr __ptr { u64, ( u64 | bool ) }
lw $r973 $$locbase i55                  ; load word
addi $r974 $$locbase i160               ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r974                       ; [call: new_29]: pass argument 0
fncall .16                              ; [call: new_29]: call function
 move $r975 $zero                        ; [call: new_29]: copy returned unit value
 movi $r975 i0                           ; [call: new_29]: copy returned unit value
addi $r976 $$locbase i480               ; get offset to local __ptr { u64, ( u64 | bool ) }
mcpi $r976 $r973 i16                    ; copy memory
addi $r977 $$locbase i320               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r977 $r974 i24                    ; copy memory
addi $r978 $$locbase i480               ; get offset to local __ptr { u64, ( u64 | bool ) }
addi $r979 $$locbase i48                ; get offset to local __ptr { u64, ( u64 | bool ) }
mcpi $r979 $r978 i16                    ; copy memory
addi $r980 $$locbase i480               ; get offset to local __ptr { u64, ( u64 | bool ) }
addi $r981 $$locbase i456               ; get offset to local __ptr u64
sw $$locbase $zero i57                  ; store word
lw $r982 $$locbase i60                  ; load word
addi $r983 $$locbase i456               ; get offset to local __ptr u64
lw $r984 $$locbase i57                  ; load word
eq $r985 $r982 $r984
jnzi $r985 .181
ji  .182
.182
addi $r986 $$locbase i48                ; get offset to local __ptr { u64, ( u64 | bool ) }
addi $r987 $$locbase i464               ; get offset to local __ptr u64
sw $$locbase $one i58                   ; store word
lw $r988 $$locbase i6                   ; load word
addi $r989 $$locbase i464               ; get offset to local __ptr u64
lw $r990 $$locbase i58                  ; load word
eq $r991 $r988 $r990
jnzi $r991 .183
ji  .184
.184
load $r992 data_NonConfigurable_8       ; load constant from data section
rvrt $r992
.183
addi $r993 $$locbase i48                ; get offset to local __ptr { u64, ( u64 | bool ) }
addi $r994 $r993 i15                    ; get offset to aggregate element
addi $r995 $$locbase i320               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r996 $$locbase i112               ; get offset to local __ptr { { ptr, u64, u64 } }
 move $$arg0 $one                        ; [call: abi_encode_21]: pass argument 0
 movi $$arg0 i1                          ; [call: abi_encode_21]: pass argument 0
move $$arg1 $r995                       ; [call: abi_encode_21]: pass argument 1
move $$arg2 $r996                       ; [call: abi_encode_21]: pass argument 2
fncall .10                              ; [call: abi_encode_21]: call function
 move $r997 $zero                        ; [call: abi_encode_21]: copy returned unit value
 movi $r997 i0                           ; [call: abi_encode_21]: copy returned unit value
addi $r998 $$locbase i392               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r998 $r996 i24                    ; copy memory
lb $r999 $r994 i0                       ; load byte
addi $r1000 $$locbase i392              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r1001 $$locbase i136              ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r999                       ; [call: abi_encode_23]: pass argument 0
move $$arg1 $r1000                      ; [call: abi_encode_23]: pass argument 1
move $$arg2 $r1001                      ; [call: abi_encode_23]: pass argument 2
fncall .12                              ; [call: abi_encode_23]: call function
 move $r1002 $zero                       ; [call: abi_encode_23]: copy returned unit value
 movi $r1002 i0                          ; [call: abi_encode_23]: copy returned unit value
addi $r1003 $$locbase i416              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r1003 $r1001 i24                  ; copy memory
addi $r1004 $$locbase i416              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r1005 $$locbase i200              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r1005 $r1004 i24                  ; copy memory
addi $r1006 $$locbase i224              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r1006 $r1005 i24                  ; copy memory
move $r1007 $r1006                      ; move parameter from branch to block argument
ji  .185
.181
addi $r1008 $$locbase i48               ; get offset to local __ptr { u64, ( u64 | bool ) }
addi $r1009 $r1008 i8                   ; get offset to aggregate element
addi $r1010 $$locbase i320              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r1011 $$locbase i64               ; get offset to local __ptr { { ptr, u64, u64 } }
 move $$arg0 $zero                       ; [call: abi_encode_21]: pass argument 0
 movi $$arg0 i0                          ; [call: abi_encode_21]: pass argument 0
move $$arg1 $r1010                      ; [call: abi_encode_21]: pass argument 1
move $$arg2 $r1011                      ; [call: abi_encode_21]: pass argument 2
fncall .10                              ; [call: abi_encode_21]: call function
 move $r1012 $zero                       ; [call: abi_encode_21]: copy returned unit value
 movi $r1012 i0                          ; [call: abi_encode_21]: copy returned unit value
addi $r1013 $$locbase i344              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r1013 $r1011 i24                  ; copy memory
lw $r1014 $r1009 i0                     ; load word
addi $r1015 $$locbase i344              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r1016 $$locbase i88               ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r1014                      ; [call: abi_encode_21]: pass argument 0
move $$arg1 $r1015                      ; [call: abi_encode_21]: pass argument 1
move $$arg2 $r1016                      ; [call: abi_encode_21]: pass argument 2
fncall .10                              ; [call: abi_encode_21]: call function
 move $r1017 $zero                       ; [call: abi_encode_21]: copy returned unit value
 movi $r1017 i0                          ; [call: abi_encode_21]: copy returned unit value
addi $r1018 $$locbase i368              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r1018 $r1016 i24                  ; copy memory
addi $r1019 $$locbase i368              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r1020 $$locbase i224              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r1020 $r1019 i24                  ; copy memory
move $r1007 $r1020                      ; move parameter from branch to block argument
ji  .185
.185
move $r1023 $r1007                      ; move parameter from branch to block argument
addi $r1024 $$locbase i248              ; get offset to local __ptr { { ptr, u64, u64 } }
 mcpi $r1024 $r1023 i24                  ; copy memory
 mcpi $r1024 $r1007 i24                  ; copy memory
addi $r1025 $$locbase i184              ; get offset to local __ptr slice
move $$arg0 $r1024                      ; [call: as_raw_slice_30]: pass argument 0
move $$arg1 $r1025                      ; [call: as_raw_slice_30]: pass argument 1
fncall .18                              ; [call: as_raw_slice_30]: call function
 move $r1026 $zero                       ; [call: as_raw_slice_30]: copy returned unit value
 movi $r1026 i0                          ; [call: as_raw_slice_30]: copy returned unit value
addi $r1027 $$locbase i272              ; get offset to local __ptr slice
mcpi $r1027 $r1025 i16                  ; copy memory
move $r1028 $r1027                      ; move parameter from branch to block argument
ji  .186
.179
addi $r1029 $$locbase i496              ; get offset to local __ptr u64
movi $r1030 i16                         ; initialize constant into register
sw $$locbase $r1030 i62                 ; store word
addi $r1031 $$locbase i304              ; get offset to local __ptr { __ptr { u64, ( u64 | bool ) }, u64 }
addi $r1032 $$locbase i440              ; get offset to local __ptr __ptr { u64, ( u64 | bool ) }
addi $r1033 $$locbase i496              ; get offset to local __ptr u64
mcpi $r1031 $r1032 i8                   ; copy memory
addi $r1034 $r1031 i8                   ; get offset to aggregate element
mcpi $r1034 $r1033 i8                   ; copy memory
addi $r1035 $$locbase i16               ; get offset to local __ptr { __ptr { u64, ( u64 | bool ) }, u64 }
mcpi $r1035 $r1031 i16                  ; copy memory
addi $r1036 $$locbase i272              ; get offset to local __ptr slice
mcpi $r1036 $r1035 i16                  ; copy memory
move $r1028 $r1036                      ; move parameter from branch to block argument
ji  .186
.186
move $r1039 $r1028                      ; move parameter from branch to block argument
addi $r1040 $$locbase i288              ; get offset to local __ptr slice
 mcpi $r1040 $r1039 i16                  ; copy memory
 mcpi $r1040 $r1028 i16                  ; copy memory
addi $r1041 $$locbase i32               ; get offset to local __ptr slice
mcpi $r1041 $r1040 i16                  ; copy memory
load $r1042 data_NonConfigurable_32     ; load constant from data section
lw $r1043 $$locbase i4                  ; load slice pointer for logging data
lw $r1044 $$locbase i5                  ; load slice size for logging data
logd $zero $r1042 $r1043 $r1044         ; log slice
load $r1045 data_NonConfigurable_33     ; load constant from data section
rvrt $r1045
DIFF------------------------------
.program:
.60                                     ; --- start of function: test_panic_with_nested_generic_error_type_enum_with_abi_encode ---
move $$locbase $sp                      ; [entry init: test_panic_with_nested_generic_error_type_enum_with_abi_encode]: set locals base register
cfei i1128                              ; [entry init: test_panic_with_nested_generic_error_type_enum_with_abi_encode]: allocate: locals 1128 byte(s), call args 0 slot(s)
.187
sw $$locbase $one i0                    ; store word
addi $r1047 $$locbase i88               ; get offset to local __ptr { u64, ( bool | { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) } ) }
sw $$locbase $one i11                   ; store word
addi $r1048 $$locbase i152              ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
movi $r1049 i2                          ; initialize constant into register
sw $$locbase $r1049 i19                 ; store word
addi $r1050 $r1048 i55                  ; get offset to aggregate element
sb $r1050 $one i0                       ; store byte
addi $r1051 $r1047 i8                   ; get offset to aggregate element
mcpi $r1051 $r1048 i56                  ; copy memory
addi $r1052 $$locbase i8                ; get offset to aggregate element
mcpi $r1052 $r1047 i64                  ; copy memory
addi $r1053 $$locbase i976              ; get offset to local __ptr __ptr { u64, ( u64 | { u64, ( bool | { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) } ) } ) }
sw $$locbase $$locbase i122             ; store word
addi $r1054 $$locbase i1032             ; get offset to local __ptr u64
load $r1055 data_NonConfigurable_28     ; load constant from data section
sw $$locbase $r1055 i129                ; store word
addi $r1056 $$locbase i984              ; get offset to local __ptr u64
sw $$locbase $zero i123                 ; store word
addi $r1057 $$locbase i1032             ; get offset to local __ptr u64
lw $r1058 $$locbase i129                ; load word
addi $r1059 $$locbase i984              ; get offset to local __ptr u64
lw $r1060 $$locbase i123                ; load word
eq $r1061 $r1058 $r1060
move $r1062 $r1061                      ; move parameter from branch to block argument
jnzi $r1061 .188
ji  .189
.188
 move $r1062 $one                        ; move parameter from branch to block argument
 movi $r1062 i1                          ; move parameter from branch to block argument
ji  .189
.189
move $r1065 $r1062                      ; move parameter from branch to block argument
 move $r1066 $r1065                      ; move parameter from branch to block argument
 jnzi $r1065 .190
 move $r1066 $r1062                      ; move parameter from branch to block argument
 jnzi $r1062 .190
ji  .191
.190
addi $r1067 $$locbase i1040             ; get offset to local __ptr u64
load $r1068 data_NonConfigurable_29     ; load constant from data section
sw $$locbase $r1068 i130                ; store word
addi $r1069 $$locbase i992              ; get offset to local __ptr u64
sw $$locbase $zero i124                 ; store word
addi $r1070 $$locbase i1040             ; get offset to local __ptr u64
lw $r1071 $$locbase i130                ; load word
addi $r1072 $$locbase i992              ; get offset to local __ptr u64
lw $r1073 $$locbase i124                ; load word
eq $r1074 $r1071 $r1073
move $r1075 $r1074                      ; move parameter from branch to block argument
jnzi $r1074 .192
ji  .193
.192
 move $r1075 $one                        ; move parameter from branch to block argument
 movi $r1075 i1                          ; move parameter from branch to block argument
ji  .193
.193
move $r1078 $r1075                      ; move parameter from branch to block argument
 move $r1079 $r1078                      ; move parameter from branch to block argument
 jnzi $r1078 .194
 move $r1079 $r1075                      ; move parameter from branch to block argument
 jnzi $r1075 .194
ji  .195
.194
fncall .6                               ; [call: is_encode_trivial_3]: call function
move $r1080 $$retv                      ; [call: is_encode_trivial_3]: copy returned value
 move $r1079 $r1080                      ; move parameter from branch to block argument
 move $r1079 $$retv                      ; move parameter from branch to block argument
ji  .195
.195
move $r1083 $r1079                      ; move parameter from branch to block argument
 move $r1066 $r1083                      ; move parameter from branch to block argument
 move $r1066 $r1079                      ; move parameter from branch to block argument
ji  .191
.191
move $r1086 $r1066                      ; move parameter from branch to block argument
 jnzi $r1086 .196
 jnzi $r1066 .196
ji  .197
.197
addi $r1087 $$locbase i976              ; get offset to local __ptr __ptr { u64, ( u64 | { u64, ( bool | { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) } ) } ) }
lw $r1088 $$locbase i122                ; load word
addi $r1089 $$locbase i528              ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r1089                      ; [call: new_29]: pass argument 0
fncall .16                              ; [call: new_29]: call function
 move $r1090 $zero                       ; [call: new_29]: copy returned unit value
 movi $r1090 i0                          ; [call: new_29]: copy returned unit value
addi $r1091 $$locbase i1048             ; get offset to local __ptr { u64, ( u64 | { u64, ( bool | { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) } ) } ) }
mcpi $r1091 $r1088 i72                  ; copy memory
addi $r1092 $$locbase i760              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r1092 $r1089 i24                  ; copy memory
addi $r1093 $$locbase i1048             ; get offset to local __ptr { u64, ( u64 | { u64, ( bool | { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) } ) } ) }
addi $r1094 $$locbase i224              ; get offset to local __ptr { u64, ( u64 | { u64, ( bool | { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) } ) } ) }
mcpi $r1094 $r1093 i72                  ; copy memory
addi $r1095 $$locbase i1048             ; get offset to local __ptr { u64, ( u64 | { u64, ( bool | { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) } ) } ) }
addi $r1096 $$locbase i1016             ; get offset to local __ptr u64
sw $$locbase $zero i127                 ; store word
lw $r1097 $$locbase i131                ; load word
addi $r1098 $$locbase i1016             ; get offset to local __ptr u64
lw $r1099 $$locbase i127                ; load word
eq $r1100 $r1097 $r1099
jnzi $r1100 .198
ji  .199
.199
addi $r1101 $$locbase i224              ; get offset to local __ptr { u64, ( u64 | { u64, ( bool | { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) } ) } ) }
addi $r1102 $$locbase i1000             ; get offset to local __ptr u64
sw $$locbase $one i125                  ; store word
lw $r1103 $$locbase i28                 ; load word
addi $r1104 $$locbase i1000             ; get offset to local __ptr u64
lw $r1105 $$locbase i125                ; load word
eq $r1106 $r1103 $r1105
jnzi $r1106 .200
ji  .201
.201
load $r1107 data_NonConfigurable_8      ; load constant from data section
rvrt $r1107
.200
addi $r1108 $$locbase i224              ; get offset to local __ptr { u64, ( u64 | { u64, ( bool | { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) } ) } ) }
addi $r1109 $r1108 i8                   ; get offset to aggregate element
addi $r1110 $$locbase i760              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r1111 $$locbase i432              ; get offset to local __ptr { { ptr, u64, u64 } }
 move $$arg0 $one                        ; [call: abi_encode_21]: pass argument 0
 movi $$arg0 i1                          ; [call: abi_encode_21]: pass argument 0
move $$arg1 $r1110                      ; [call: abi_encode_21]: pass argument 1
move $$arg2 $r1111                      ; [call: abi_encode_21]: pass argument 2
fncall .10                              ; [call: abi_encode_21]: call function
 move $r1112 $zero                       ; [call: abi_encode_21]: copy returned unit value
 movi $r1112 i0                          ; [call: abi_encode_21]: copy returned unit value
addi $r1113 $$locbase i904              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r1113 $r1111 i24                  ; copy memory
addi $r1114 $$locbase i904              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r1115 $$locbase i784              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r1115 $r1114 i24                  ; copy memory
addi $r1116 $$locbase i296              ; get offset to local __ptr { u64, ( bool | { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) } ) }
mcpi $r1116 $r1109 i64                  ; copy memory
addi $r1117 $$locbase i296              ; get offset to local __ptr { u64, ( bool | { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) } ) }
addi $r1118 $$locbase i1024             ; get offset to local __ptr u64
sw $$locbase $zero i128                 ; store word
lw $r1119 $$locbase i37                 ; load word
addi $r1120 $$locbase i1024             ; get offset to local __ptr u64
lw $r1121 $$locbase i128                ; load word
eq $r1122 $r1119 $r1121
jnzi $r1122 .202
ji  .203
.203
addi $r1123 $$locbase i296              ; get offset to local __ptr { u64, ( bool | { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) } ) }
addi $r1124 $$locbase i1008             ; get offset to local __ptr u64
sw $$locbase $one i126                  ; store word
lw $r1125 $$locbase i37                 ; load word
addi $r1126 $$locbase i1008             ; get offset to local __ptr u64
lw $r1127 $$locbase i126                ; load word
eq $r1128 $r1125 $r1127
jnzi $r1128 .204
ji  .205
.205
load $r1129 data_NonConfigurable_8      ; load constant from data section
rvrt $r1129
.204
addi $r1130 $$locbase i296              ; get offset to local __ptr { u64, ( bool | { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) } ) }
addi $r1131 $r1130 i8                   ; get offset to aggregate element
addi $r1132 $$locbase i784              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r1133 $$locbase i480              ; get offset to local __ptr { { ptr, u64, u64 } }
 move $$arg0 $one                        ; [call: abi_encode_21]: pass argument 0
 movi $$arg0 i1                          ; [call: abi_encode_21]: pass argument 0
move $$arg1 $r1132                      ; [call: abi_encode_21]: pass argument 1
move $$arg2 $r1133                      ; [call: abi_encode_21]: pass argument 2
fncall .10                              ; [call: abi_encode_21]: call function
 move $r1134 $zero                       ; [call: abi_encode_21]: copy returned unit value
 movi $r1134 i0                          ; [call: abi_encode_21]: copy returned unit value
addi $r1135 $$locbase i928              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r1135 $r1133 i24                  ; copy memory
addi $r1136 $$locbase i928              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r1137 $$locbase i360              ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r1131                      ; [call: abi_encode_20]: pass argument 0
move $$arg1 $r1136                      ; [call: abi_encode_20]: pass argument 1
move $$arg2 $r1137                      ; [call: abi_encode_20]: pass argument 2
fncall .8                               ; [call: abi_encode_20]: call function
 move $r1138 $zero                       ; [call: abi_encode_20]: copy returned unit value
 movi $r1138 i0                          ; [call: abi_encode_20]: copy returned unit value
addi $r1139 $$locbase i952              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r1139 $r1137 i24                  ; copy memory
addi $r1140 $$locbase i952              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r1141 $$locbase i568              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r1141 $r1140 i24                  ; copy memory
addi $r1142 $$locbase i592              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r1142 $r1141 i24                  ; copy memory
move $r1143 $r1142                      ; move parameter from branch to block argument
ji  .206
.202
addi $r1144 $$locbase i296              ; get offset to local __ptr { u64, ( bool | { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) } ) }
addi $r1145 $r1144 i63                  ; get offset to aggregate element
addi $r1146 $$locbase i784              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r1147 $$locbase i456              ; get offset to local __ptr { { ptr, u64, u64 } }
 move $$arg0 $zero                       ; [call: abi_encode_21]: pass argument 0
 movi $$arg0 i0                          ; [call: abi_encode_21]: pass argument 0
move $$arg1 $r1146                      ; [call: abi_encode_21]: pass argument 1
move $$arg2 $r1147                      ; [call: abi_encode_21]: pass argument 2
fncall .10                              ; [call: abi_encode_21]: call function
 move $r1148 $zero                       ; [call: abi_encode_21]: copy returned unit value
 movi $r1148 i0                          ; [call: abi_encode_21]: copy returned unit value
addi $r1149 $$locbase i832              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r1149 $r1147 i24                  ; copy memory
lb $r1150 $r1145 i0                     ; load byte
addi $r1151 $$locbase i832              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r1152 $$locbase i504              ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r1150                      ; [call: abi_encode_23]: pass argument 0
move $$arg1 $r1151                      ; [call: abi_encode_23]: pass argument 1
move $$arg2 $r1152                      ; [call: abi_encode_23]: pass argument 2
fncall .12                              ; [call: abi_encode_23]: call function
 move $r1153 $zero                       ; [call: abi_encode_23]: copy returned unit value
 movi $r1153 i0                          ; [call: abi_encode_23]: copy returned unit value
addi $r1154 $$locbase i880              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r1154 $r1152 i24                  ; copy memory
addi $r1155 $$locbase i880              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r1156 $$locbase i592              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r1156 $r1155 i24                  ; copy memory
move $r1143 $r1156                      ; move parameter from branch to block argument
ji  .206
.206
move $r1159 $r1143                      ; move parameter from branch to block argument
addi $r1160 $$locbase i616              ; get offset to local __ptr { { ptr, u64, u64 } }
 mcpi $r1160 $r1159 i24                  ; copy memory
 mcpi $r1160 $r1143 i24                  ; copy memory
addi $r1161 $$locbase i640              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r1161 $r1160 i24                  ; copy memory
addi $r1162 $$locbase i664              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r1162 $r1161 i24                  ; copy memory
move $r1163 $r1162                      ; move parameter from branch to block argument
ji  .207
.198
addi $r1164 $$locbase i224              ; get offset to local __ptr { u64, ( u64 | { u64, ( bool | { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) } ) } ) }
addi $r1165 $r1164 i64                  ; get offset to aggregate element
addi $r1166 $$locbase i760              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r1167 $$locbase i384              ; get offset to local __ptr { { ptr, u64, u64 } }
 move $$arg0 $zero                       ; [call: abi_encode_21]: pass argument 0
 movi $$arg0 i0                          ; [call: abi_encode_21]: pass argument 0
move $$arg1 $r1166                      ; [call: abi_encode_21]: pass argument 1
move $$arg2 $r1167                      ; [call: abi_encode_21]: pass argument 2
fncall .10                              ; [call: abi_encode_21]: call function
 move $r1168 $zero                       ; [call: abi_encode_21]: copy returned unit value
 movi $r1168 i0                          ; [call: abi_encode_21]: copy returned unit value
addi $r1169 $$locbase i808              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r1169 $r1167 i24                  ; copy memory
lw $r1170 $r1165 i0                     ; load word
addi $r1171 $$locbase i808              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r1172 $$locbase i408              ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r1170                      ; [call: abi_encode_21]: pass argument 0
move $$arg1 $r1171                      ; [call: abi_encode_21]: pass argument 1
move $$arg2 $r1172                      ; [call: abi_encode_21]: pass argument 2
fncall .10                              ; [call: abi_encode_21]: call function
 move $r1173 $zero                       ; [call: abi_encode_21]: copy returned unit value
 movi $r1173 i0                          ; [call: abi_encode_21]: copy returned unit value
addi $r1174 $$locbase i856              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r1174 $r1172 i24                  ; copy memory
addi $r1175 $$locbase i856              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r1176 $$locbase i664              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r1176 $r1175 i24                  ; copy memory
move $r1163 $r1176                      ; move parameter from branch to block argument
ji  .207
.207
move $r1179 $r1163                      ; move parameter from branch to block argument
addi $r1180 $$locbase i688              ; get offset to local __ptr { { ptr, u64, u64 } }
 mcpi $r1180 $r1179 i24                  ; copy memory
 mcpi $r1180 $r1163 i24                  ; copy memory
addi $r1181 $$locbase i552              ; get offset to local __ptr slice
move $$arg0 $r1180                      ; [call: as_raw_slice_30]: pass argument 0
move $$arg1 $r1181                      ; [call: as_raw_slice_30]: pass argument 1
fncall .18                              ; [call: as_raw_slice_30]: call function
 move $r1182 $zero                       ; [call: as_raw_slice_30]: copy returned unit value
 movi $r1182 i0                          ; [call: as_raw_slice_30]: copy returned unit value
addi $r1183 $$locbase i712              ; get offset to local __ptr slice
mcpi $r1183 $r1181 i16                  ; copy memory
move $r1184 $r1183                      ; move parameter from branch to block argument
ji  .208
.196
addi $r1185 $$locbase i1120             ; get offset to local __ptr u64
movi $r1186 i72                         ; initialize constant into register
sw $$locbase $r1186 i140                ; store word
addi $r1187 $$locbase i744              ; get offset to local __ptr { __ptr { u64, ( u64 | { u64, ( bool | { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) } ) } ) }, u64 }
addi $r1188 $$locbase i976              ; get offset to local __ptr __ptr { u64, ( u64 | { u64, ( bool | { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) } ) } ) }
addi $r1189 $$locbase i1120             ; get offset to local __ptr u64
mcpi $r1187 $r1188 i8                   ; copy memory
addi $r1190 $r1187 i8                   ; get offset to aggregate element
mcpi $r1190 $r1189 i8                   ; copy memory
addi $r1191 $$locbase i72               ; get offset to local __ptr { __ptr { u64, ( u64 | { u64, ( bool | { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) } ) } ) }, u64 }
mcpi $r1191 $r1187 i16                  ; copy memory
addi $r1192 $$locbase i712              ; get offset to local __ptr slice
mcpi $r1192 $r1191 i16                  ; copy memory
move $r1184 $r1192                      ; move parameter from branch to block argument
ji  .208
.208
move $r1195 $r1184                      ; move parameter from branch to block argument
addi $r1196 $$locbase i728              ; get offset to local __ptr slice
 mcpi $r1196 $r1195 i16                  ; copy memory
 mcpi $r1196 $r1184 i16                  ; copy memory
addi $r1197 $$locbase i208              ; get offset to local __ptr slice
mcpi $r1197 $r1196 i16                  ; copy memory
load $r1198 data_NonConfigurable_34     ; load constant from data section
lw $r1199 $$locbase i26                 ; load slice pointer for logging data
lw $r1200 $$locbase i27                 ; load slice size for logging data
logd $zero $r1198 $r1199 $r1200         ; log slice
load $r1201 data_NonConfigurable_35     ; load constant from data section
rvrt $r1201
DIFF------------------------------
.program:
.2                                      ; --- start of function: call_nested_panic_inlined_0 ---
pusha .2                                ; [fn init: call_nested_panic_inlined_0]: push all used registers to stack
move $$locbase $sp                      ; [fn init: call_nested_panic_inlined_0]: set locals base register
cfei i288                               ; [fn init: call_nested_panic_inlined_0]: allocate: locals 288 byte(s), call args 0 slot(s)
move $r3 $$arg0                         ; [fn init: call_nested_panic_inlined_0]: copy argument 0 (__backtrace)
move $r4 $$reta                         ; [fn init: call_nested_panic_inlined_0]: save return address
.63
movi $r5 i4                             ; initialize constant into register
sw $$locbase $r5 i0                     ; store word
addi $r6 $$locbase i152                 ; get offset to local __ptr [slice; 3]
addr $r7 data_NonConfigurable_0         ; get __const_global's address in data section
addi $r8 $$locbase i56                  ; get offset to local __ptr { ptr, u64 }
sw $$locbase $r7 i7                     ; store word
addi $r9 $r8 i8                         ; get offset to aggregate element
movi $r10 i7                            ; initialize constant into register
sw $$locbase $r10 i8                    ; store word
addi $r11 $$locbase i72                 ; get offset to local __ptr slice
mcpi $r11 $r8 i16                       ; copy memory
addr $r12 data_NonConfigurable_1        ; get __const_global0's address in data section
addi $r13 $$locbase i88                 ; get offset to local __ptr { ptr, u64 }
sw $$locbase $r12 i11                   ; store word
addi $r14 $r13 i8                       ; get offset to aggregate element
movi $r15 i7                            ; initialize constant into register
sw $$locbase $r15 i12                   ; store word
addi $r16 $$locbase i104                ; get offset to local __ptr slice
mcpi $r16 $r13 i16                      ; copy memory
addr $r17 data_NonConfigurable_2        ; get __const_global1's address in data section
addi $r18 $$locbase i120                ; get offset to local __ptr { ptr, u64 }
sw $$locbase $r17 i15                   ; store word
addi $r19 $r18 i8                       ; get offset to aggregate element
movi $r20 i22                           ; initialize constant into register
sw $$locbase $r20 i16                   ; store word
addi $r21 $$locbase i136                ; get offset to local __ptr slice
mcpi $r21 $r18 i16                      ; copy memory
movi $r22 i16                           ; get array element size
 mul $r23 $zero $r22                     ; get offset to array element
 add $r23 $r6 $r23                       ; add array element offset to array base
 mcpi $r23 $r11 i16                      ; copy memory
 movi $r23 i0                            ; get offset to array element
 move $r23 $r6                           ; add array element offset to array base
 mcpi $r6 $r11 i16                       ; copy memory
movi $r24 i16                           ; get array element size
 mul $r25 $one $r24                      ; get offset to array element
 add $r25 $r6 $r25                       ; add array element offset to array base
 movi $r25 i16                           ; get offset to array element
 addi $r25 $r6 i16                       ; add array element offset to array base
mcpi $r25 $r16 i16                      ; copy memory
movi $r26 i16                           ; get array element size
movi $r27 i2                            ; initialize constant into register
 mul $r28 $r27 $r26                      ; get offset to array element
 add $r28 $r6 $r28                       ; add array element offset to array base
 movi $r28 i32                           ; get offset to array element
 addi $r28 $r6 i32                       ; add array element offset to array base
mcpi $r28 $r21 i16                      ; copy memory
addi $r29 $$locbase i8                  ; get offset to aggregate element
mcpi $r29 $r6 i48                       ; copy memory
movi $r30 i11                           ; initialize constant into register
 sll $r31 $r3 $r30
 or $r32 $r31 $one
 slli $r31 $r3 i11
 ori $r32 $r31 i1
addi $r33 $$locbase i232                ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
mcpi $r33 $$locbase i56                 ; copy memory
addi $r34 $$locbase i232                ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
addi $r35 $$locbase i216                ; get offset to local __ptr slice
move $$arg0 $r34                        ; [call: encode_allow_alias_2]: pass argument 0
move $$arg1 $r35                        ; [call: encode_allow_alias_2]: pass argument 1
fncall .4                               ; [call: encode_allow_alias_2]: call function
 move $r36 $zero                         ; [call: encode_allow_alias_2]: copy returned unit value
 movi $r36 i0                            ; [call: encode_allow_alias_2]: copy returned unit value
addi $r37 $$locbase i200                ; get offset to local __ptr slice
mcpi $r37 $r35 i16                      ; copy memory
load $r38 data_NonConfigurable_3        ; load constant from data section
lw $r39 $$locbase i25                   ; load slice pointer for logging data
lw $r40 $$locbase i26                   ; load slice size for logging data
logd $zero $r38 $r39 $r40               ; log slice
load $r41 data_NonConfigurable_4        ; load constant from data section
and $r42 $r32 $r41
load $r43 data_NonConfigurable_5        ; load constant from data section
or $r44 $r43 $r42
rvrt $r44
.3
cfsi i288                               ; [fn end: call_nested_panic_inlined_0] free: locals 288 byte(s), call args 0 slot(s)
move $$reta $r4                         ; [fn end: call_nested_panic_inlined_0] restore return address
popa .2                                 ; [fn end: call_nested_panic_inlined_0] restore all used registers
jal $zero $$reta i0                     ; [fn end: call_nested_panic_inlined_0] return from call
DIFF------------------------------
.program:
.4                                      ; --- start of function: encode_allow_alias_2 ---
pusha .4                                ; [fn init: encode_allow_alias_2]: push all used registers to stack
move $$locbase $sp                      ; [fn init: encode_allow_alias_2]: set locals base register
cfei i232                               ; [fn init: encode_allow_alias_2]: allocate: locals 232 byte(s), call args 0 slot(s)
move $r45 $$arg0                        ; [fn init: encode_allow_alias_2]: copy argument 0 (item)
move $r46 $$arg1                        ; [fn init: encode_allow_alias_2]: copy argument 1 (__ret_value)
move $r47 $$reta                        ; [fn init: encode_allow_alias_2]: save return address
.64
addi $r48 $$locbase i216                ; get offset to local __ptr __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
 sw $$locbase $r45 i27                   ; store word
 sw $$locbase $$arg0 i27                 ; store word
fncall .6                               ; [call: is_encode_trivial_3]: call function
move $r49 $$retv                        ; [call: is_encode_trivial_3]: copy returned value
 jnzi $r49 .65
 jnzi $$retv .65
ji  .66
.66
addi $r50 $$locbase i216                ; get offset to local __ptr __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
lw $r51 $$locbase i27                   ; load word
addi $r52 $$locbase i40                 ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r52                        ; [call: new_29]: pass argument 0
fncall .16                              ; [call: new_29]: call function
 move $r53 $zero                         ; [call: new_29]: copy returned unit value
 movi $r53 i0                            ; [call: new_29]: copy returned unit value
addi $r54 $$locbase i80                 ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
mcpi $r54 $r51 i56                      ; copy memory
addi $r55 $$locbase i136                ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r55 $r52 i24                      ; copy memory
addi $r56 $$locbase i16                 ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r54                        ; [call: abi_encode_20]: pass argument 0
move $$arg1 $r55                        ; [call: abi_encode_20]: pass argument 1
move $$arg2 $r56                        ; [call: abi_encode_20]: pass argument 2
fncall .8                               ; [call: abi_encode_20]: call function
 move $r57 $zero                         ; [call: abi_encode_20]: copy returned unit value
 movi $r57 i0                            ; [call: abi_encode_20]: copy returned unit value
addi $r58 $$locbase i192                ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r58 $r56 i24                      ; copy memory
addi $r59 $$locbase i192                ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r60 $$locbase i64                 ; get offset to local __ptr slice
move $$arg0 $r59                        ; [call: as_raw_slice_30]: pass argument 0
move $$arg1 $r60                        ; [call: as_raw_slice_30]: pass argument 1
fncall .18                              ; [call: as_raw_slice_30]: call function
 move $r61 $zero                         ; [call: as_raw_slice_30]: copy returned unit value
 movi $r61 i0                            ; [call: as_raw_slice_30]: copy returned unit value
addi $r62 $$locbase i160                ; get offset to local __ptr slice
mcpi $r62 $r60 i16                      ; copy memory
move $r63 $r62                          ; move parameter from branch to block argument
ji  .67
.65
addi $r64 $$locbase i224                ; get offset to local __ptr u64
movi $r65 i56                           ; initialize constant into register
sw $$locbase $r65 i28                   ; store word
addi $r66 $$locbase i176                ; get offset to local __ptr { __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }, u64 }
addi $r67 $$locbase i216                ; get offset to local __ptr __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
addi $r68 $$locbase i224                ; get offset to local __ptr u64
mcpi $r66 $r67 i8                       ; copy memory
addi $r69 $r66 i8                       ; get offset to aggregate element
mcpi $r69 $r68 i8                       ; copy memory
mcpi $$locbase $r66 i16                 ; copy memory
addi $r70 $$locbase i160                ; get offset to local __ptr slice
mcpi $r70 $$locbase i16                 ; copy memory
move $r63 $r70                          ; move parameter from branch to block argument
ji  .67
.67
move $r73 $r63                          ; move parameter from branch to block argument
 mcpi $r46 $r73 i16                      ; copy memory
 mcpi $r46 $r63 i16                      ; copy memory
ji  .5
.5
cfsi i232                               ; [fn end: encode_allow_alias_2] free: locals 232 byte(s), call args 0 slot(s)
move $$reta $r47                        ; [fn end: encode_allow_alias_2] restore return address
popa .4                                 ; [fn end: encode_allow_alias_2] restore all used registers
jal $zero $$reta i0                     ; [fn end: encode_allow_alias_2] return from call
DIFF------------------------------
.program:
.6                                      ; --- start of function: is_encode_trivial_3 ---
pusha .6                                ; [fn init: is_encode_trivial_3]: push all used registers to stack
move $$locbase $sp                      ; [fn init: is_encode_trivial_3]: set locals base register
cfei i32                                ; [fn init: is_encode_trivial_3]: allocate: locals 32 byte(s), call args 0 slot(s)
.68
addi $r75 $$locbase i16                 ; get offset to local __ptr u64
load $r76 data_NonConfigurable_6        ; load constant from data section
sw $$locbase $r76 i2                    ; store word
sw $$locbase $zero i0                   ; store word
addi $r77 $$locbase i16                 ; get offset to local __ptr u64
lw $r78 $$locbase i2                    ; load word
lw $r79 $$locbase i0                    ; load word
eq $r80 $r78 $r79
move $r81 $r80                          ; move parameter from branch to block argument
jnzi $r80 .69
ji  .70
.69
 move $r81 $one                          ; move parameter from branch to block argument
 movi $r81 i1                            ; move parameter from branch to block argument
ji  .70
.70
move $r84 $r81                          ; move parameter from branch to block argument
 move $r85 $r84                          ; move parameter from branch to block argument
 jnzi $r84 .71
 move $r85 $r81                          ; move parameter from branch to block argument
 jnzi $r81 .71
ji  .72
.71
 move $r85 $one                          ; move parameter from branch to block argument
 movi $r85 i1                            ; move parameter from branch to block argument
ji  .72
.72
move $r88 $r85                          ; move parameter from branch to block argument
 move $r89 $r88                          ; move parameter from branch to block argument
 jnzi $r88 .73
 move $r89 $r85                          ; move parameter from branch to block argument
 jnzi $r85 .73
ji  .74
.73
 move $r89 $one                          ; move parameter from branch to block argument
 movi $r89 i1                            ; move parameter from branch to block argument
ji  .74
.74
move $r92 $r89                          ; move parameter from branch to block argument
 move $r93 $r92                          ; move parameter from branch to block argument
 jnzi $r92 .75
 move $r93 $r89                          ; move parameter from branch to block argument
 jnzi $r89 .75
ji  .76
.75
addi $r94 $$locbase i24                 ; get offset to local __ptr u64
load $r95 data_NonConfigurable_7        ; load constant from data section
sw $$locbase $r95 i3                    ; store word
addi $r96 $$locbase i8                  ; get offset to local __ptr u64
load $r97 data_NonConfigurable_7        ; load constant from data section
sw $$locbase $r97 i1                    ; store word
addi $r98 $$locbase i24                 ; get offset to local __ptr u64
lw $r99 $$locbase i3                    ; load word
addi $r100 $$locbase i8                 ; get offset to local __ptr u64
lw $r101 $$locbase i1                   ; load word
eq $r102 $r99 $r101
move $r103 $r102                        ; move parameter from branch to block argument
jnzi $r102 .77
ji  .78
.77
 move $r103 $one                         ; move parameter from branch to block argument
 movi $r103 i1                           ; move parameter from branch to block argument
ji  .78
.78
move $r106 $r103                        ; move parameter from branch to block argument
 move $r107 $r106                        ; move parameter from branch to block argument
 jnzi $r106 .79
 move $r107 $r103                        ; move parameter from branch to block argument
 jnzi $r103 .79
ji  .80
.79
 move $r107 $one                         ; move parameter from branch to block argument
 movi $r107 i1                           ; move parameter from branch to block argument
ji  .80
.80
move $r110 $r107                        ; move parameter from branch to block argument
 move $r93 $r110                         ; move parameter from branch to block argument
 move $r93 $r107                         ; move parameter from branch to block argument
ji  .76
.76
move $r113 $r93                         ; move parameter from branch to block argument
 move $r114 $r113                        ; move parameter from branch to block argument
 jnzi $r113 .81
 move $r114 $r93                         ; move parameter from branch to block argument
 jnzi $r93 .81
ji  .82
.81
 move $r114 $zero                        ; move parameter from branch to block argument
 movi $r114 i0                           ; move parameter from branch to block argument
ji  .82
.82
move $r117 $r114                        ; move parameter from branch to block argument
 move $$retv $r117                       ; [fn end: is_encode_trivial_3] set return value
 move $$retv $r114                       ; [fn end: is_encode_trivial_3] set return value
ji  .7
.7
cfsi i32                                ; [fn end: is_encode_trivial_3] free: locals 32 byte(s), call args 0 slot(s)
popa .6                                 ; [fn end: is_encode_trivial_3] restore all used registers
jal $zero $$reta i0                     ; [fn end: is_encode_trivial_3] return from call
DIFF------------------------------
.program:
.8                                      ; --- start of function: abi_encode_20 ---
pusha .8                                ; [fn init: abi_encode_20]: push all used registers to stack
move $$locbase $sp                      ; [fn init: abi_encode_20]: set locals base register
cfei i1528                              ; [fn init: abi_encode_20]: allocate: locals 1528 byte(s), call args 0 slot(s)
move $r118 $$arg0                       ; [fn init: abi_encode_20]: copy argument 0 (self)
move $r119 $$arg1                       ; [fn init: abi_encode_20]: copy argument 1 (buffer)
move $r120 $$arg2                       ; [fn init: abi_encode_20]: copy argument 2 (__ret_value)
move $r121 $$reta                       ; [fn init: abi_encode_20]: save return address
.83
addi $r122 $$locbase i1264              ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
 mcpi $r122 $r118 i56                    ; copy memory
 mcpi $r122 $$arg0 i56                   ; copy memory
addi $r123 $$locbase i816               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r123 $r119 i24                    ; copy memory
addi $r124 $$locbase i1264              ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
addi $r125 $$locbase i96                ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
mcpi $r125 $r124 i56                    ; copy memory
addi $r126 $$locbase i96                ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
addi $r127 $$locbase i1320              ; get offset to local __ptr u64
mcpi $r127 $r126 i8                     ; copy memory
addi $r128 $$locbase i1208              ; get offset to local __ptr u64
sw $$locbase $zero i151                 ; store word
addi $r129 $$locbase i1320              ; get offset to local __ptr u64
lw $r130 $$locbase i165                 ; load word
addi $r131 $$locbase i1208              ; get offset to local __ptr u64
lw $r132 $$locbase i151                 ; load word
eq $r133 $r130 $r132
jnzi $r133 .84
ji  .85
.85
addi $r134 $$locbase i96                ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
addi $r135 $$locbase i1336              ; get offset to local __ptr u64
mcpi $r135 $r134 i8                     ; copy memory
addi $r136 $$locbase i1216              ; get offset to local __ptr u64
sw $$locbase $one i152                  ; store word
addi $r137 $$locbase i1336              ; get offset to local __ptr u64
lw $r138 $$locbase i167                 ; load word
addi $r139 $$locbase i1216              ; get offset to local __ptr u64
lw $r140 $$locbase i152                 ; load word
eq $r141 $r138 $r140
jnzi $r141 .86
ji  .87
.87
addi $r142 $$locbase i96                ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
addi $r143 $$locbase i1360              ; get offset to local __ptr u64
mcpi $r143 $r142 i8                     ; copy memory
addi $r144 $$locbase i1232              ; get offset to local __ptr u64
movi $r145 i2                           ; initialize constant into register
sw $$locbase $r145 i154                 ; store word
addi $r146 $$locbase i1360              ; get offset to local __ptr u64
lw $r147 $$locbase i170                 ; load word
addi $r148 $$locbase i1232              ; get offset to local __ptr u64
lw $r149 $$locbase i154                 ; load word
eq $r150 $r147 $r149
jnzi $r150 .88
ji  .89
.89
addi $r151 $$locbase i96                ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
addi $r152 $$locbase i1368              ; get offset to local __ptr u64
mcpi $r152 $r151 i8                     ; copy memory
addi $r153 $$locbase i1240              ; get offset to local __ptr u64
movi $r154 i3                           ; initialize constant into register
sw $$locbase $r154 i155                 ; store word
addi $r155 $$locbase i1368              ; get offset to local __ptr u64
lw $r156 $$locbase i171                 ; load word
addi $r157 $$locbase i1240              ; get offset to local __ptr u64
lw $r158 $$locbase i155                 ; load word
eq $r159 $r156 $r158
jnzi $r159 .90
ji  .91
.91
addi $r160 $$locbase i96                ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
addi $r161 $$locbase i1392              ; get offset to local __ptr u64
mcpi $r161 $r160 i8                     ; copy memory
addi $r162 $$locbase i1248              ; get offset to local __ptr u64
movi $r163 i4                           ; initialize constant into register
sw $$locbase $r163 i156                 ; store word
addi $r164 $$locbase i1392              ; get offset to local __ptr u64
lw $r165 $$locbase i174                 ; load word
addi $r166 $$locbase i1248              ; get offset to local __ptr u64
lw $r167 $$locbase i156                 ; load word
eq $r168 $r165 $r167
jnzi $r168 .92
ji  .93
.93
load $r169 data_NonConfigurable_8       ; load constant from data section
rvrt $r169
.92
addi $r170 $$locbase i96                ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
addi $r171 $r170 i8                     ; get offset to aggregate element
addi $r172 $$locbase i1480              ; get offset to local __ptr [slice; 3]
mcpi $r172 $r171 i48                    ; copy memory
addi $r173 $$locbase i816               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r174 $$locbase i536               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r174 $r173 i24                    ; copy memory
addi $r175 $$locbase i296               ; get offset to local __ptr { { ptr, u64, u64 } }
movi $r176 i4                           ; initialize constant into register
 move $$arg0 $r176                       ; [call: abi_encode_21]: pass argument 0
 movi $$arg0 i4                          ; [call: abi_encode_21]: pass argument 0
move $$arg1 $r174                       ; [call: abi_encode_21]: pass argument 1
move $$arg2 $r175                       ; [call: abi_encode_21]: pass argument 2
fncall .10                              ; [call: abi_encode_21]: call function
 move $r177 $zero                        ; [call: abi_encode_21]: copy returned unit value
 movi $r177 i0                           ; [call: abi_encode_21]: copy returned unit value
addi $r178 $$locbase i1128              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r178 $r175 i24                    ; copy memory
addi $r179 $$locbase i1480              ; get offset to local __ptr [slice; 3]
addi $r180 $$locbase i1128              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r181 $$locbase i1400              ; get offset to local __ptr [slice; 3]
mcpi $r181 $r179 i48                    ; copy memory
addi $r182 $$locbase i888               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r182 $r180 i24                    ; copy memory
addi $r183 $$locbase i888               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r184 $$locbase i960               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r184 $r183 i24                    ; copy memory
addi $r185 $$locbase i1200              ; get offset to local __ptr u64
sw $$locbase $zero i150                 ; store word
ji  .94
.94
addi $r186 $$locbase i1200              ; get offset to local __ptr u64
addi $r187 $$locbase i1328              ; get offset to local __ptr u64
mcpi $r187 $r186 i8                     ; copy memory
addi $r188 $$locbase i1256              ; get offset to local __ptr u64
movi $r189 i3                           ; initialize constant into register
sw $$locbase $r189 i157                 ; store word
addi $r190 $$locbase i1328              ; get offset to local __ptr u64
lw $r191 $$locbase i166                 ; load word
addi $r192 $$locbase i1256              ; get offset to local __ptr u64
lw $r193 $$locbase i157                 ; load word
lt $r194 $r191 $r193
jnzi $r194 .95
ji  .96
.96
addi $r195 $$locbase i960               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r196 $$locbase i672               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r196 $r195 i24                    ; copy memory
addi $r197 $$locbase i1152              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r197 $r196 i24                    ; copy memory
addi $r198 $$locbase i1152              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r199 $$locbase i696               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r199 $r198 i24                    ; copy memory
addi $r200 $$locbase i720               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r200 $r199 i24                    ; copy memory
move $r201 $r200                        ; move parameter from branch to block argument
ji  .97
.95
addi $r202 $$locbase i1400              ; get offset to local __ptr [slice; 3]
addi $r203 $$locbase i1200              ; get offset to local __ptr u64
lw $r204 $$locbase i150                 ; load word
movi $r205 i16                          ; get array element size
 mul $r206 $r204 $r205                   ; get offset to array element
 muli $r206 $r204 i16                    ; get offset to array element
add $r206 $r202 $r206                   ; add array element offset to array base
addi $r207 $$locbase i960               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r208 $$locbase i584               ; get offset to local __ptr slice
mcpi $r208 $r206 i16                    ; copy memory
addi $r209 $$locbase i600               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r209 $r207 i24                    ; copy memory
addi $r210 $$locbase i344               ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r208                       ; [call: abi_encode_27]: pass argument 0
move $$arg1 $r209                       ; [call: abi_encode_27]: pass argument 1
move $$arg2 $r210                       ; [call: abi_encode_27]: pass argument 2
fncall .14                              ; [call: abi_encode_27]: call function
 move $r211 $zero                        ; [call: abi_encode_27]: copy returned unit value
 movi $r211 i0                           ; [call: abi_encode_27]: copy returned unit value
addi $r212 $$locbase i960               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r212 $r210 i24                    ; copy memory
addi $r213 $$locbase i1200              ; get offset to local __ptr u64
addi $r214 $$locbase i1344              ; get offset to local __ptr u64
mcpi $r214 $r213 i8                     ; copy memory
addi $r215 $$locbase i1224              ; get offset to local __ptr u64
sw $$locbase $one i153                  ; store word
addi $r216 $$locbase i1344              ; get offset to local __ptr u64
lw $r217 $$locbase i168                 ; load word
addi $r218 $$locbase i1224              ; get offset to local __ptr u64
lw $r219 $$locbase i153                 ; load word
add $r220 $r217 $r219
addi $r221 $$locbase i1200              ; get offset to local __ptr u64
sw $$locbase $r220 i150                 ; store word
ji  .94
.90
addi $r222 $$locbase i96                ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
addi $r223 $r222 i40                    ; get offset to aggregate element
addi $r224 $$locbase i1464              ; get offset to local __ptr { u64, u64 }
mcpi $r224 $r223 i16                    ; copy memory
addi $r225 $$locbase i816               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r226 $$locbase i464               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r226 $r225 i24                    ; copy memory
addi $r227 $$locbase i224               ; get offset to local __ptr { { ptr, u64, u64 } }
movi $r228 i3                           ; initialize constant into register
 move $$arg0 $r228                       ; [call: abi_encode_21]: pass argument 0
 movi $$arg0 i3                          ; [call: abi_encode_21]: pass argument 0
move $$arg1 $r226                       ; [call: abi_encode_21]: pass argument 1
move $$arg2 $r227                       ; [call: abi_encode_21]: pass argument 2
fncall .10                              ; [call: abi_encode_21]: call function
 move $r229 $zero                        ; [call: abi_encode_21]: copy returned unit value
 movi $r229 i0                           ; [call: abi_encode_21]: copy returned unit value
addi $r230 $$locbase i1080              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r230 $r227 i24                    ; copy memory
addi $r231 $$locbase i1464              ; get offset to local __ptr { u64, u64 }
addi $r232 $$locbase i1080              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r233 $$locbase i1376              ; get offset to local __ptr { u64, u64 }
mcpi $r233 $r231 i16                    ; copy memory
addi $r234 $$locbase i864               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r234 $r232 i24                    ; copy memory
addi $r235 $$locbase i1376              ; get offset to local __ptr { u64, u64 }
lw $r236 $$locbase i172                 ; load word
addi $r237 $$locbase i864               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r238 $$locbase i488               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r238 $r237 i24                    ; copy memory
addi $r239 $$locbase i248               ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r236                       ; [call: abi_encode_21]: pass argument 0
move $$arg1 $r238                       ; [call: abi_encode_21]: pass argument 1
move $$arg2 $r239                       ; [call: abi_encode_21]: pass argument 2
fncall .10                              ; [call: abi_encode_21]: call function
 move $r240 $zero                        ; [call: abi_encode_21]: copy returned unit value
 movi $r240 i0                           ; [call: abi_encode_21]: copy returned unit value
addi $r241 $$locbase i936               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r241 $r239 i24                    ; copy memory
addi $r242 $$locbase i1376              ; get offset to local __ptr { u64, u64 }
addi $r243 $r242 i8                     ; get offset to aggregate element
lw $r244 $$locbase i173                 ; load word
addi $r245 $$locbase i936               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r246 $$locbase i512               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r246 $r245 i24                    ; copy memory
addi $r247 $$locbase i272               ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r244                       ; [call: abi_encode_21]: pass argument 0
move $$arg1 $r246                       ; [call: abi_encode_21]: pass argument 1
move $$arg2 $r247                       ; [call: abi_encode_21]: pass argument 2
fncall .10                              ; [call: abi_encode_21]: call function
 move $r248 $zero                        ; [call: abi_encode_21]: copy returned unit value
 movi $r248 i0                           ; [call: abi_encode_21]: copy returned unit value
addi $r249 $$locbase i1008              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r249 $r247 i24                    ; copy memory
addi $r250 $$locbase i1008              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r251 $$locbase i648               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r251 $r250 i24                    ; copy memory
addi $r252 $$locbase i1104              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r252 $r251 i24                    ; copy memory
addi $r253 $$locbase i1104              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r254 $$locbase i720               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r254 $r253 i24                    ; copy memory
move $r201 $r254                        ; move parameter from branch to block argument
ji  .97
.97
move $r257 $r201                        ; move parameter from branch to block argument
addi $r258 $$locbase i744               ; get offset to local __ptr { { ptr, u64, u64 } }
 mcpi $r258 $r257 i24                    ; copy memory
 mcpi $r258 $r201 i24                    ; copy memory
move $r259 $r258                        ; move parameter from branch to block argument
ji  .98
.88
addi $r260 $$locbase i96                ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
addi $r261 $r260 i55                    ; get offset to aggregate element
addi $r262 $$locbase i1456              ; get offset to local __ptr bool
mcpi $r262 $r261 i1                     ; copy memory
addi $r263 $$locbase i816               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r264 $$locbase i440               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r264 $r263 i24                    ; copy memory
addi $r265 $$locbase i200               ; get offset to local __ptr { { ptr, u64, u64 } }
movi $r266 i2                           ; initialize constant into register
 move $$arg0 $r266                       ; [call: abi_encode_21]: pass argument 0
 movi $$arg0 i2                          ; [call: abi_encode_21]: pass argument 0
move $$arg1 $r264                       ; [call: abi_encode_21]: pass argument 1
move $$arg2 $r265                       ; [call: abi_encode_21]: pass argument 2
fncall .10                              ; [call: abi_encode_21]: call function
 move $r267 $zero                        ; [call: abi_encode_21]: copy returned unit value
 movi $r267 i0                           ; [call: abi_encode_21]: copy returned unit value
addi $r268 $$locbase i1032              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r268 $r265 i24                    ; copy memory
addi $r269 $$locbase i1456              ; get offset to local __ptr bool
lb $r270 $r269 i0                       ; load byte
addi $r271 $$locbase i1032              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r272 $$locbase i560               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r272 $r271 i24                    ; copy memory
addi $r273 $$locbase i320               ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r270                       ; [call: abi_encode_23]: pass argument 0
move $$arg1 $r272                       ; [call: abi_encode_23]: pass argument 1
move $$arg2 $r273                       ; [call: abi_encode_23]: pass argument 2
fncall .12                              ; [call: abi_encode_23]: call function
 move $r274 $zero                        ; [call: abi_encode_23]: copy returned unit value
 movi $r274 i0                           ; [call: abi_encode_23]: copy returned unit value
addi $r275 $$locbase i1056              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r275 $r273 i24                    ; copy memory
addi $r276 $$locbase i1056              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r277 $$locbase i744               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r277 $r276 i24                    ; copy memory
move $r259 $r277                        ; move parameter from branch to block argument
ji  .98
.98
move $r280 $r259                        ; move parameter from branch to block argument
addi $r281 $$locbase i768               ; get offset to local __ptr { { ptr, u64, u64 } }
 mcpi $r281 $r280 i24                    ; copy memory
 mcpi $r281 $r259 i24                    ; copy memory
move $r282 $r281                        ; move parameter from branch to block argument
ji  .99
.86
addi $r283 $$locbase i96                ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
addi $r284 $r283 i55                    ; get offset to aggregate element
addi $r285 $$locbase i1448              ; get offset to local __ptr u8
mcpi $r285 $r284 i1                     ; copy memory
addi $r286 $$locbase i816               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r287 $$locbase i416               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r287 $r286 i24                    ; copy memory
addi $r288 $$locbase i176               ; get offset to local __ptr { { ptr, u64, u64 } }
 move $$arg0 $one                        ; [call: abi_encode_21]: pass argument 0
 movi $$arg0 i1                          ; [call: abi_encode_21]: pass argument 0
move $$arg1 $r287                       ; [call: abi_encode_21]: pass argument 1
move $$arg2 $r288                       ; [call: abi_encode_21]: pass argument 2
fncall .10                              ; [call: abi_encode_21]: call function
 move $r289 $zero                        ; [call: abi_encode_21]: copy returned unit value
 movi $r289 i0                           ; [call: abi_encode_21]: copy returned unit value
addi $r290 $$locbase i912               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r290 $r288 i24                    ; copy memory
addi $r291 $$locbase i1448              ; get offset to local __ptr u8
addi $r292 $$locbase i912               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r293 $$locbase i1352              ; get offset to local __ptr u8
mcpi $r293 $r291 i1                     ; copy memory
addi $r294 $$locbase i840               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r294 $r292 i24                    ; copy memory
addi $r295 $$locbase i368               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r296 $$locbase i840               ; get offset to local __ptr { { ptr, u64, u64 } }
move $r297 $r296                        ; return value from ASM block with return register buffer
 mcpi $$locbase $r297 i24                ; copy memory
 mcpi $$locbase $r296 i24                ; copy memory
addi $r298 $$locbase i48                ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r298 $$locbase i24                ; copy memory
lw $r299 $$locbase i6                   ; load word
addi $r300 $r298 i8                     ; get offset to aggregate element
lw $r301 $$locbase i7                   ; load word
addi $r302 $r298 i16                    ; get offset to aggregate element
lw $r303 $$locbase i8                   ; load word
addi $r304 $$locbase i1352              ; get offset to local __ptr u8
lb $r305 $r304 i0                       ; load byte
 add $r306 $r303 $one
 addi $r306 $r303 i1
gt $r307 $r306 $r301
move $r308 $r299                        ; move parameter from branch to block argument
move $r309 $r301                        ; move parameter from branch to block argument
jnzi $r307 .100
ji  .101
.100
movi $r310 i2                           ; initialize constant into register
 mul $r311 $r301 $r310
 add $r312 $r311 $one
 muli $r311 $r301 i2
 addi $r312 $r311 i1
aloc $r312
mcp $hp $r299 $r303
move $r313 $hp                          ; return value from ASM block with return register hp
 move $r308 $r313                        ; move parameter from branch to block argument
 move $r308 $hp                          ; move parameter from branch to block argument
move $r309 $r312                        ; move parameter from branch to block argument
ji  .101
.101
move $r317 $r308                        ; move parameter from branch to block argument
move $r319 $r309                        ; move parameter from branch to block argument
 add $r320 $r317 $r303
 add $r320 $r308 $r303
sb $r320 $r305 i0                       ; store byte
 add $r321 $r303 $one
 addi $r321 $r303 i1
addi $r322 $$locbase i72                ; get offset to local __ptr { ptr, u64, u64 }
sw $$locbase $r317 i9                   ; store word
addi $r323 $r322 i8                     ; get offset to aggregate element
sw $$locbase $r319 i10                  ; store word
addi $r324 $r322 i16                    ; get offset to aggregate element
sw $$locbase $r321 i11                  ; store word
move $r325 $r322                        ; return value from ASM block with return register buffer
addi $r326 $$locbase i24                ; get offset to local __ptr { ptr, u64, u64 }
 mcpi $r326 $r325 i24                    ; copy memory
 mcpi $r326 $r322 i24                    ; copy memory
mcpi $r295 $r326 i24                    ; copy memory
addi $r327 $$locbase i624               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r327 $r295 i24                    ; copy memory
addi $r328 $$locbase i984               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r328 $r327 i24                    ; copy memory
addi $r329 $$locbase i984               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r330 $$locbase i768               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r330 $r329 i24                    ; copy memory
move $r282 $r330                        ; move parameter from branch to block argument
ji  .99
.99
move $r333 $r282                        ; move parameter from branch to block argument
addi $r334 $$locbase i792               ; get offset to local __ptr { { ptr, u64, u64 } }
 mcpi $r334 $r333 i24                    ; copy memory
 mcpi $r334 $r282 i24                    ; copy memory
move $r335 $r334                        ; move parameter from branch to block argument
ji  .102
.84
addi $r336 $$locbase i816               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r337 $$locbase i392               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r337 $r336 i24                    ; copy memory
addi $r338 $$locbase i152               ; get offset to local __ptr { { ptr, u64, u64 } }
 move $$arg0 $zero                       ; [call: abi_encode_21]: pass argument 0
 movi $$arg0 i0                          ; [call: abi_encode_21]: pass argument 0
move $$arg1 $r337                       ; [call: abi_encode_21]: pass argument 1
move $$arg2 $r338                       ; [call: abi_encode_21]: pass argument 2
fncall .10                              ; [call: abi_encode_21]: call function
 move $r339 $zero                        ; [call: abi_encode_21]: copy returned unit value
 movi $r339 i0                           ; [call: abi_encode_21]: copy returned unit value
addi $r340 $$locbase i792               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r340 $r338 i24                    ; copy memory
move $r335 $r340                        ; move parameter from branch to block argument
ji  .102
.102
move $r343 $r335                        ; move parameter from branch to block argument
addi $r344 $$locbase i1176              ; get offset to local __ptr { { ptr, u64, u64 } }
 mcpi $r344 $r343 i24                    ; copy memory
 mcpi $r344 $r335 i24                    ; copy memory
addi $r345 $$locbase i1176              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r120 $r345 i24                    ; copy memory
ji  .9
.9
cfsi i1528                              ; [fn end: abi_encode_20] free: locals 1528 byte(s), call args 0 slot(s)
move $$reta $r121                       ; [fn end: abi_encode_20] restore return address
popa .8                                 ; [fn end: abi_encode_20] restore all used registers
jal $zero $$reta i0                     ; [fn end: abi_encode_20] return from call
DIFF------------------------------
.program:
.10                                     ; --- start of function: abi_encode_21 ---
pusha .10                               ; [fn init: abi_encode_21]: push all used registers to stack
move $$locbase $sp                      ; [fn init: abi_encode_21]: set locals base register
cfei i152                               ; [fn init: abi_encode_21]: allocate: locals 152 byte(s), call args 0 slot(s)
.103
addi $r347 $$locbase i144               ; get offset to local __ptr u64
sw $$locbase $$arg0 i18                 ; store word
addi $r348 $$locbase i120               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r348 $$arg1 i24                   ; copy memory
addi $r349 $$locbase i96                ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r350 $$locbase i120               ; get offset to local __ptr { { ptr, u64, u64 } }
move $r351 $r350                        ; return value from ASM block with return register buffer
 mcpi $$locbase $r351 i24                ; copy memory
 mcpi $$locbase $r350 i24                ; copy memory
addi $r352 $$locbase i48                ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r352 $$locbase i24                ; copy memory
lw $r353 $$locbase i6                   ; load word
addi $r354 $r352 i8                     ; get offset to aggregate element
lw $r355 $$locbase i7                   ; load word
addi $r356 $r352 i16                    ; get offset to aggregate element
lw $r357 $$locbase i8                   ; load word
addi $r358 $$locbase i144               ; get offset to local __ptr u64
lw $r359 $$locbase i18                  ; load word
movi $r360 i8                           ; initialize constant into register
 add $r361 $r357 $r360
 addi $r361 $r357 i8
gt $r362 $r361 $r355
move $r363 $r353                        ; move parameter from branch to block argument
move $r364 $r355                        ; move parameter from branch to block argument
jnzi $r362 .104
ji  .105
.104
movi $r365 i2                           ; initialize constant into register
 mul $r366 $r355 $r365
 muli $r366 $r355 i2
movi $r367 i8                           ; initialize constant into register
 add $r368 $r366 $r367
 addi $r368 $r366 i8
aloc $r368
mcp $hp $r353 $r357
move $r369 $hp                          ; return value from ASM block with return register hp
 move $r363 $r369                        ; move parameter from branch to block argument
 move $r363 $hp                          ; move parameter from branch to block argument
move $r364 $r368                        ; move parameter from branch to block argument
ji  .105
.105
move $r373 $r363                        ; move parameter from branch to block argument
move $r375 $r364                        ; move parameter from branch to block argument
 add $r376 $r373 $r357
 add $r376 $r363 $r357
sw $r376 $r359 i0                       ; store word
movi $r377 i8                           ; initialize constant into register
 add $r378 $r357 $r377
 addi $r378 $r357 i8
addi $r379 $$locbase i72                ; get offset to local __ptr { ptr, u64, u64 }
sw $$locbase $r373 i9                   ; store word
addi $r380 $r379 i8                     ; get offset to aggregate element
sw $$locbase $r375 i10                  ; store word
addi $r381 $r379 i16                    ; get offset to aggregate element
sw $$locbase $r378 i11                  ; store word
move $r382 $r379                        ; return value from ASM block with return register buffer
addi $r383 $$locbase i24                ; get offset to local __ptr { ptr, u64, u64 }
 mcpi $r383 $r382 i24                    ; copy memory
 mcpi $r383 $r379 i24                    ; copy memory
mcpi $r349 $r383 i24                    ; copy memory
mcpi $$arg2 $r349 i24                   ; copy memory
ji  .11
.11
cfsi i152                               ; [fn end: abi_encode_21] free: locals 152 byte(s), call args 0 slot(s)
popa .10                                ; [fn end: abi_encode_21] restore all used registers
jal $zero $$reta i0                     ; [fn end: abi_encode_21] return from call
DIFF------------------------------
.program:
.12                                     ; --- start of function: abi_encode_23 ---
pusha .12                               ; [fn init: abi_encode_23]: push all used registers to stack
move $$locbase $sp                      ; [fn init: abi_encode_23]: set locals base register
cfei i152                               ; [fn init: abi_encode_23]: allocate: locals 152 byte(s), call args 0 slot(s)
.106
addi $r385 $$locbase i144               ; get offset to local __ptr bool
sb $r385 $$arg0 i0                      ; store byte
addi $r386 $$locbase i120               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r386 $$arg1 i24                   ; copy memory
addi $r387 $$locbase i96                ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r388 $$locbase i120               ; get offset to local __ptr { { ptr, u64, u64 } }
move $r389 $r388                        ; return value from ASM block with return register buffer
 mcpi $$locbase $r389 i24                ; copy memory
 mcpi $$locbase $r388 i24                ; copy memory
addi $r390 $$locbase i48                ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r390 $$locbase i24                ; copy memory
lw $r391 $$locbase i6                   ; load word
addi $r392 $r390 i8                     ; get offset to aggregate element
lw $r393 $$locbase i7                   ; load word
addi $r394 $r390 i16                    ; get offset to aggregate element
lw $r395 $$locbase i8                   ; load word
addi $r396 $$locbase i144               ; get offset to local __ptr bool
lb $r397 $r396 i0                       ; load byte
 add $r398 $r395 $one
 addi $r398 $r395 i1
gt $r399 $r398 $r393
move $r400 $r391                        ; move parameter from branch to block argument
move $r401 $r393                        ; move parameter from branch to block argument
jnzi $r399 .107
ji  .108
.107
movi $r402 i2                           ; initialize constant into register
 mul $r403 $r393 $r402
 add $r404 $r403 $one
 muli $r403 $r393 i2
 addi $r404 $r403 i1
aloc $r404
mcp $hp $r391 $r395
move $r405 $hp                          ; return value from ASM block with return register hp
 move $r400 $r405                        ; move parameter from branch to block argument
 move $r400 $hp                          ; move parameter from branch to block argument
move $r401 $r404                        ; move parameter from branch to block argument
ji  .108
.108
move $r409 $r400                        ; move parameter from branch to block argument
move $r411 $r401                        ; move parameter from branch to block argument
 add $r412 $r409 $r395
 add $r412 $r400 $r395
sb $r412 $r397 i0                       ; store byte
 add $r413 $r395 $one
 addi $r413 $r395 i1
addi $r414 $$locbase i72                ; get offset to local __ptr { ptr, u64, u64 }
sw $$locbase $r409 i9                   ; store word
addi $r415 $r414 i8                     ; get offset to aggregate element
sw $$locbase $r411 i10                  ; store word
addi $r416 $r414 i16                    ; get offset to aggregate element
sw $$locbase $r413 i11                  ; store word
move $r417 $r414                        ; return value from ASM block with return register buffer
addi $r418 $$locbase i24                ; get offset to local __ptr { ptr, u64, u64 }
 mcpi $r418 $r417 i24                    ; copy memory
 mcpi $r418 $r414 i24                    ; copy memory
mcpi $r387 $r418 i24                    ; copy memory
mcpi $$arg2 $r387 i24                   ; copy memory
ji  .13
.13
cfsi i152                               ; [fn end: abi_encode_23] free: locals 152 byte(s), call args 0 slot(s)
popa .12                                ; [fn end: abi_encode_23] restore all used registers
jal $zero $$reta i0                     ; [fn end: abi_encode_23] return from call
DIFF------------------------------
.program:
.14                                     ; --- start of function: abi_encode_27 ---
pusha .14                               ; [fn init: abi_encode_27]: push all used registers to stack
move $$locbase $sp                      ; [fn init: abi_encode_27]: set locals base register
cfei i224                               ; [fn init: abi_encode_27]: allocate: locals 224 byte(s), call args 0 slot(s)
.109
addi $r420 $$locbase i208               ; get offset to local __ptr slice
mcpi $r420 $$arg0 i16                   ; copy memory
addi $r421 $$locbase i184               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r421 $$arg1 i24                   ; copy memory
addi $r422 $$locbase i160               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r423 $$locbase i184               ; get offset to local __ptr { { ptr, u64, u64 } }
move $r424 $r423                        ; return value from ASM block with return register buffer
 mcpi $$locbase $r424 i24                ; copy memory
 mcpi $$locbase $r423 i24                ; copy memory
addi $r425 $$locbase i80                ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r425 $$locbase i24                ; copy memory
lw $r426 $$locbase i10                  ; load word
addi $r427 $r425 i8                     ; get offset to aggregate element
lw $r428 $$locbase i11                  ; load word
addi $r429 $r425 i16                    ; get offset to aggregate element
lw $r430 $$locbase i12                  ; load word
addi $r431 $$locbase i208               ; get offset to local __ptr slice
addi $r432 $$locbase i40                ; get offset to local __ptr slice
mcpi $r432 $r431 i16                    ; copy memory
move $r433 $r431                        ; return value from ASM block with return register item
addi $r434 $$locbase i24                ; get offset to local __ptr { u64, u64 }
 mcpi $r434 $r433 i16                    ; copy memory
 mcpi $r434 $r431 i16                    ; copy memory
addi $r435 $$locbase i104               ; get offset to local __ptr { u64, u64 }
mcpi $r435 $r434 i16                    ; copy memory
addi $r436 $r435 i8                     ; get offset to aggregate element
lw $r437 $$locbase i14                  ; load word
movi $r438 i8                           ; initialize constant into register
 add $r439 $r437 $r438
 addi $r439 $r437 i8
add $r440 $r430 $r439
gt $r441 $r440 $r428
move $r442 $r426                        ; move parameter from branch to block argument
move $r443 $r428                        ; move parameter from branch to block argument
jnzi $r441 .110
ji  .111
.110
movi $r444 i2                           ; initialize constant into register
 mul $r445 $r428 $r444
 muli $r445 $r428 i2
add $r446 $r445 $r439
aloc $r446
mcp $hp $r426 $r430
move $r447 $hp                          ; return value from ASM block with return register hp
 move $r442 $r447                        ; move parameter from branch to block argument
 move $r442 $hp                          ; move parameter from branch to block argument
move $r443 $r446                        ; move parameter from branch to block argument
ji  .111
.111
move $r451 $r442                        ; move parameter from branch to block argument
move $r453 $r443                        ; move parameter from branch to block argument
addi $r454 $$locbase i120               ; get offset to local __ptr slice
mcpi $r454 $r432 i16                    ; copy memory
add $r455 $r451 $r430
lw $r457 $$locbase i16
sw $r455 $r457 i0
addi $r455 $r455 i8
lw $r456 $$locbase i15
mcp $r455 $r456 $r457
addi $r458 $r430 i8
add $r458 $r458 $r457
move $r459 $r458                        ; return value from ASM block with return register new_len
addi $r460 $$locbase i136               ; get offset to local __ptr { ptr, u64, u64 }
sw $$locbase $r451 i17                  ; store word
addi $r461 $r460 i8                     ; get offset to aggregate element
sw $$locbase $r453 i18                  ; store word
addi $r462 $r460 i16                    ; get offset to aggregate element
sw $$locbase $r459 i19                  ; store word
move $r463 $r460                        ; return value from ASM block with return register buffer
addi $r464 $$locbase i56                ; get offset to local __ptr { ptr, u64, u64 }
 mcpi $r464 $r463 i24                    ; copy memory
 mcpi $r464 $r460 i24                    ; copy memory
mcpi $r422 $r464 i24                    ; copy memory
mcpi $$arg2 $r422 i24                   ; copy memory
ji  .15
.15
cfsi i224                               ; [fn end: abi_encode_27] free: locals 224 byte(s), call args 0 slot(s)
popa .14                                ; [fn end: abi_encode_27] restore all used registers
jal $zero $$reta i0                     ; [fn end: abi_encode_27] return from call
DIFF------------------------------
.program:
.16                                     ; --- start of function: new_29 ---
pusha .16                               ; [fn init: new_29]: push all used registers to stack
move $$locbase $sp                      ; [fn init: new_29]: set locals base register
cfei i72                                ; [fn init: new_29]: allocate: locals 72 byte(s), call args 0 slot(s)
.112
addi $r466 $$locbase i48                ; get offset to local __ptr { { ptr, u64, u64 } }
movi $r467 i1024                        ; initialize constant into register
aloc $r467
move $r468 $hp                          ; return value from ASM block with return register hp
addi $r469 $$locbase i24                ; get offset to local __ptr { ptr, u64, u64 }
 sw $$locbase $r468 i3                   ; store word
 sw $$locbase $hp i3                     ; store word
addi $r470 $r469 i8                     ; get offset to aggregate element
movi $r471 i1024                        ; initialize constant into register
sw $$locbase $r471 i4                   ; store word
addi $r472 $r469 i16                    ; get offset to aggregate element
sw $$locbase $zero i5                   ; store word
move $r473 $r469                        ; return value from ASM block with return register buffer
 mcpi $$locbase $r473 i24                ; copy memory
 mcpi $$locbase $r469 i24                ; copy memory
mcpi $r466 $$locbase i24                ; copy memory
mcpi $$arg0 $r466 i24                   ; copy memory
ji  .17
.17
cfsi i72                                ; [fn end: new_29] free: locals 72 byte(s), call args 0 slot(s)
popa .16                                ; [fn end: new_29] restore all used registers
jal $zero $$reta i0                     ; [fn end: new_29] return from call
DIFF------------------------------
.program:
.18                                     ; --- start of function: as_raw_slice_30 ---
pusha .18                               ; [fn init: as_raw_slice_30]: push all used registers to stack
move $$locbase $sp                      ; [fn init: as_raw_slice_30]: set locals base register
cfei i104                               ; [fn init: as_raw_slice_30]: allocate: locals 104 byte(s), call args 0 slot(s)
.113
addi $r475 $$locbase i80                ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r475 $$arg0 i24                   ; copy memory
addi $r476 $$locbase i80                ; get offset to local __ptr { { ptr, u64, u64 } }
move $r477 $r476                        ; return value from ASM block with return register buffer
 mcpi $$locbase $r477 i24                ; copy memory
 mcpi $$locbase $r476 i24                ; copy memory
addi $r478 $$locbase i40                ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r478 $$locbase i24                ; copy memory
addi $r479 $r478 i16                    ; get offset to aggregate element
addi $r480 $$locbase i64                ; get offset to local __ptr { ptr, u64 }
mcpi $r480 $r478 i8                     ; copy memory
addi $r481 $r480 i8                     ; get offset to aggregate element
mcpi $r481 $r479 i8                     ; copy memory
move $r482 $r480                        ; return value from ASM block with return register s
addi $r483 $$locbase i24                ; get offset to local __ptr slice
 mcpi $r483 $r482 i16                    ; copy memory
 mcpi $r483 $r480 i16                    ; copy memory
mcpi $$arg1 $r483 i16                   ; copy memory
ji  .19
.19
cfsi i104                               ; [fn end: as_raw_slice_30] free: locals 104 byte(s), call args 0 slot(s)
popa .18                                ; [fn end: as_raw_slice_30] restore all used registers
jal $zero $$reta i0                     ; [fn end: as_raw_slice_30] return from call
DIFF------------------------------
.program:
.24                                     ; --- start of function: call_nested_panic_non_inlined_31 ---
pusha .24                               ; [fn init: call_nested_panic_non_inlined_31]: push all used registers to stack
move $$locbase $sp                      ; [fn init: call_nested_panic_non_inlined_31]: set locals base register
cfei i200                               ; [fn init: call_nested_panic_non_inlined_31]: allocate: locals 200 byte(s), call args 0 slot(s)
move $r490 $$arg0                       ; [fn init: call_nested_panic_non_inlined_31]: copy argument 0 (__backtrace)
move $r491 $$reta                       ; [fn init: call_nested_panic_non_inlined_31]: save return address
.116
movi $r492 i4                           ; initialize constant into register
sw $$locbase $r492 i0                   ; store word
addi $r493 $$locbase i152               ; get offset to local __ptr [slice; 3]
addr $r494 data_NonConfigurable_9       ; get __const_global2's address in data section
addi $r495 $$locbase i56                ; get offset to local __ptr { ptr, u64 }
sw $$locbase $r494 i7                   ; store word
addi $r496 $r495 i8                     ; get offset to aggregate element
movi $r497 i4                           ; initialize constant into register
sw $$locbase $r497 i8                   ; store word
addi $r498 $$locbase i72                ; get offset to local __ptr slice
mcpi $r498 $r495 i16                    ; copy memory
addr $r499 data_NonConfigurable_10      ; get __const_global3's address in data section
addi $r500 $$locbase i88                ; get offset to local __ptr { ptr, u64 }
sw $$locbase $r499 i11                  ; store word
addi $r501 $r500 i8                     ; get offset to aggregate element
movi $r502 i6                           ; initialize constant into register
sw $$locbase $r502 i12                  ; store word
addi $r503 $$locbase i104               ; get offset to local __ptr slice
mcpi $r503 $r500 i16                    ; copy memory
addr $r504 data_NonConfigurable_11      ; get __const_global4's address in data section
addi $r505 $$locbase i120               ; get offset to local __ptr { ptr, u64 }
sw $$locbase $r504 i15                  ; store word
addi $r506 $r505 i8                     ; get offset to aggregate element
movi $r507 i17                          ; initialize constant into register
sw $$locbase $r507 i16                  ; store word
addi $r508 $$locbase i136               ; get offset to local __ptr slice
mcpi $r508 $r505 i16                    ; copy memory
movi $r509 i16                          ; get array element size
 mul $r510 $zero $r509                   ; get offset to array element
 add $r510 $r493 $r510                   ; add array element offset to array base
 mcpi $r510 $r498 i16                    ; copy memory
 movi $r510 i0                           ; get offset to array element
 move $r510 $r493                        ; add array element offset to array base
 mcpi $r493 $r498 i16                    ; copy memory
movi $r511 i16                          ; get array element size
 mul $r512 $one $r511                    ; get offset to array element
 add $r512 $r493 $r512                   ; add array element offset to array base
 movi $r512 i16                          ; get offset to array element
 addi $r512 $r493 i16                    ; add array element offset to array base
mcpi $r512 $r503 i16                    ; copy memory
movi $r513 i16                          ; get array element size
movi $r514 i2                           ; initialize constant into register
 mul $r515 $r514 $r513                   ; get offset to array element
 add $r515 $r493 $r515                   ; add array element offset to array base
 movi $r515 i32                          ; get offset to array element
 addi $r515 $r493 i32                    ; add array element offset to array base
mcpi $r515 $r508 i16                    ; copy memory
addi $r516 $$locbase i8                 ; get offset to aggregate element
mcpi $r516 $r493 i48                    ; copy memory
movi $r517 i11                          ; initialize constant into register
 sll $r518 $r490 $r517
 slli $r518 $r490 i11
movi $r519 i4                           ; initialize constant into register
 or $r520 $r518 $r519
 move $$arg0 $one                        ; [call: nested_panic_non_inlined_32]: pass argument 0
 ori $r520 $r518 i4
 movi $$arg0 i1                          ; [call: nested_panic_non_inlined_32]: pass argument 0
move $$arg1 $$locbase                   ; [call: nested_panic_non_inlined_32]: pass argument 1
move $$arg2 $r520                       ; [call: nested_panic_non_inlined_32]: pass argument 2
fncall .26                              ; [call: nested_panic_non_inlined_32]: call function
 move $r521 $zero                        ; [call: nested_panic_non_inlined_32]: copy returned unit value
 movi $r521 i0                           ; [call: nested_panic_non_inlined_32]: copy returned unit value
ji  .25
.25
cfsi i200                               ; [fn end: call_nested_panic_non_inlined_31] free: locals 200 byte(s), call args 0 slot(s)
move $$reta $r491                       ; [fn end: call_nested_panic_non_inlined_31] restore return address
popa .24                                ; [fn end: call_nested_panic_non_inlined_31] restore all used registers
jal $zero $$reta i0                     ; [fn end: call_nested_panic_non_inlined_31] return from call
DIFF------------------------------
.program:
.26                                     ; --- start of function: nested_panic_non_inlined_32 ---
pusha .26                               ; [fn init: nested_panic_non_inlined_32]: push all used registers to stack
move $$locbase $sp                      ; [fn init: nested_panic_non_inlined_32]: set locals base register
cfei i96                                ; [fn init: nested_panic_non_inlined_32]: allocate: locals 96 byte(s), call args 0 slot(s)
move $r522 $$arg0                       ; [fn init: nested_panic_non_inlined_32]: copy argument 0 (to_panic)
move $r523 $$arg1                       ; [fn init: nested_panic_non_inlined_32]: copy argument 1 (err)
move $r524 $$arg2                       ; [fn init: nested_panic_non_inlined_32]: copy argument 2 (__backtrace)
move $r525 $$reta                       ; [fn init: nested_panic_non_inlined_32]: save return address
.117
addi $r526 $$locbase i88                ; get offset to local __ptr bool
 sb $r526 $r522 i0                       ; store byte
 sb $r526 $$arg0 i0                      ; store byte
addi $r527 $$locbase i32                ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
mcpi $r527 $r523 i56                    ; copy memory
addi $r528 $$locbase i88                ; get offset to local __ptr bool
lb $r529 $r528 i0                       ; load byte
jnzi $r529 .118
ji  .119
.119
ji  .27
.118
addi $r530 $$locbase i32                ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
addi $r531 $$locbase i16                ; get offset to local __ptr slice
move $$arg0 $r530                       ; [call: encode_allow_alias_2]: pass argument 0
move $$arg1 $r531                       ; [call: encode_allow_alias_2]: pass argument 1
fncall .4                               ; [call: encode_allow_alias_2]: call function
 move $r532 $zero                        ; [call: encode_allow_alias_2]: copy returned unit value
 movi $r532 i0                           ; [call: encode_allow_alias_2]: copy returned unit value
mcpi $$locbase $r531 i16                ; copy memory
load $r533 data_NonConfigurable_3       ; load constant from data section
lw $r534 $$locbase i0                   ; load slice pointer for logging data
lw $r535 $$locbase i1                   ; load slice size for logging data
logd $zero $r533 $r534 $r535            ; log slice
load $r536 data_NonConfigurable_4       ; load constant from data section
and $r537 $r524 $r536
load $r538 data_NonConfigurable_12      ; load constant from data section
or $r539 $r538 $r537
rvrt $r539
.27
cfsi i96                                ; [fn end: nested_panic_non_inlined_32] free: locals 96 byte(s), call args 0 slot(s)
move $$reta $r525                       ; [fn end: nested_panic_non_inlined_32] restore return address
popa .26                                ; [fn end: nested_panic_non_inlined_32] restore all used registers
jal $zero $$reta i0                     ; [fn end: nested_panic_non_inlined_32] return from call
DIFF------------------------------
.program:
.32                                     ; --- start of function: encode_allow_alias_34 ---
pusha .32                               ; [fn init: encode_allow_alias_34]: push all used registers to stack
move $$locbase $sp                      ; [fn init: encode_allow_alias_34]: set locals base register
cfei i152                               ; [fn init: encode_allow_alias_34]: allocate: locals 152 byte(s), call args 0 slot(s)
move $r556 $$arg0                       ; [fn init: encode_allow_alias_34]: copy argument 0 (item)
move $r557 $$arg1                       ; [fn init: encode_allow_alias_34]: copy argument 1 (__ret_value)
move $r558 $$reta                       ; [fn init: encode_allow_alias_34]: save return address
.122
addi $r559 $$locbase i136               ; get offset to local __ptr __ptr ()
 sw $$locbase $r556 i17                  ; store word
 jnzi $one .123
 sw $$locbase $$arg0 i17                 ; store word
 ji  .123
ji  .124
.124
addi $r560 $$locbase i16                ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r560                       ; [call: new_29]: pass argument 0
fncall .16                              ; [call: new_29]: call function
 move $r561 $zero                        ; [call: new_29]: copy returned unit value
 movi $r561 i0                           ; [call: new_29]: copy returned unit value
addi $r562 $$locbase i112               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r562 $r560 i24                    ; copy memory
addi $r563 $$locbase i112               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r564 $$locbase i56                ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r564 $r563 i24                    ; copy memory
addi $r565 $$locbase i40                ; get offset to local __ptr slice
move $$arg0 $r564                       ; [call: as_raw_slice_30]: pass argument 0
move $$arg1 $r565                       ; [call: as_raw_slice_30]: pass argument 1
fncall .18                              ; [call: as_raw_slice_30]: call function
 move $r566 $zero                        ; [call: as_raw_slice_30]: copy returned unit value
 movi $r566 i0                           ; [call: as_raw_slice_30]: copy returned unit value
addi $r567 $$locbase i80                ; get offset to local __ptr slice
mcpi $r567 $r565 i16                    ; copy memory
move $r568 $r567                        ; move parameter from branch to block argument
ji  .125
.123
addi $r569 $$locbase i144               ; get offset to local __ptr u64
sw $$locbase $zero i18                  ; store word
addi $r570 $$locbase i96                ; get offset to local __ptr { __ptr (), u64 }
addi $r571 $$locbase i136               ; get offset to local __ptr __ptr ()
addi $r572 $$locbase i144               ; get offset to local __ptr u64
mcpi $r570 $r571 i8                     ; copy memory
addi $r573 $r570 i8                     ; get offset to aggregate element
mcpi $r573 $r572 i8                     ; copy memory
mcpi $$locbase $r570 i16                ; copy memory
addi $r574 $$locbase i80                ; get offset to local __ptr slice
mcpi $r574 $$locbase i16                ; copy memory
move $r568 $r574                        ; move parameter from branch to block argument
ji  .125
.125
move $r577 $r568                        ; move parameter from branch to block argument
 mcpi $r557 $r577 i16                    ; copy memory
 mcpi $r557 $r568 i16                    ; copy memory
ji  .33
.33
cfsi i152                               ; [fn end: encode_allow_alias_34] free: locals 152 byte(s), call args 0 slot(s)
move $$reta $r558                       ; [fn end: encode_allow_alias_34] restore return address
popa .32                                ; [fn end: encode_allow_alias_34] restore all used registers
jal $zero $$reta i0                     ; [fn end: encode_allow_alias_34] return from call
DIFF------------------------------
.program:
.38                                     ; --- start of function: generic_panic_36 ---
pusha .38                               ; [fn init: generic_panic_36]: push all used registers to stack
move $$locbase $sp                      ; [fn init: generic_panic_36]: set locals base register
cfei i240                               ; [fn init: generic_panic_36]: allocate: locals 240 byte(s), call args 0 slot(s)
move $r599 $$arg0                       ; [fn init: generic_panic_36]: copy argument 0 (t)
move $r600 $$arg1                       ; [fn init: generic_panic_36]: copy argument 1 (__backtrace)
move $r601 $$reta                       ; [fn init: generic_panic_36]: save return address
.128
addi $r602 $$locbase i224               ; get offset to local __ptr slice
 mcpi $r602 $r599 i16                    ; copy memory
 mcpi $r602 $$arg0 i16                   ; copy memory
addi $r603 $$locbase i224               ; get offset to local __ptr slice
addi $r604 $$locbase i208               ; get offset to local __ptr __ptr slice
sw $$locbase $r603 i26                  ; store word
 jnzi $zero .129
 
ji  .130
.130
addi $r605 $$locbase i208               ; get offset to local __ptr __ptr slice
lw $r606 $$locbase i26                  ; load word
addi $r607 $$locbase i56                ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r607                       ; [call: new_29]: pass argument 0
fncall .16                              ; [call: new_29]: call function
 move $r608 $zero                        ; [call: new_29]: copy returned unit value
 movi $r608 i0                           ; [call: new_29]: copy returned unit value
addi $r609 $$locbase i96                ; get offset to local __ptr slice
mcpi $r609 $r606 i16                    ; copy memory
addi $r610 $$locbase i112               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r610 $r607 i24                    ; copy memory
addi $r611 $$locbase i32                ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r609                       ; [call: abi_encode_27]: pass argument 0
move $$arg1 $r610                       ; [call: abi_encode_27]: pass argument 1
move $$arg2 $r611                       ; [call: abi_encode_27]: pass argument 2
fncall .14                              ; [call: abi_encode_27]: call function
 move $r612 $zero                        ; [call: abi_encode_27]: copy returned unit value
 movi $r612 i0                           ; [call: abi_encode_27]: copy returned unit value
addi $r613 $$locbase i184               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r613 $r611 i24                    ; copy memory
addi $r614 $$locbase i184               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r615 $$locbase i80                ; get offset to local __ptr slice
move $$arg0 $r614                       ; [call: as_raw_slice_30]: pass argument 0
move $$arg1 $r615                       ; [call: as_raw_slice_30]: pass argument 1
fncall .18                              ; [call: as_raw_slice_30]: call function
 move $r616 $zero                        ; [call: as_raw_slice_30]: copy returned unit value
 movi $r616 i0                           ; [call: as_raw_slice_30]: copy returned unit value
addi $r617 $$locbase i136               ; get offset to local __ptr slice
mcpi $r617 $r615 i16                    ; copy memory
move $r618 $r617                        ; move parameter from branch to block argument
ji  .131
.129
addi $r619 $$locbase i216               ; get offset to local __ptr u64
movi $r620 i16                          ; initialize constant into register
sw $$locbase $r620 i27                  ; store word
addi $r621 $$locbase i168               ; get offset to local __ptr { __ptr slice, u64 }
addi $r622 $$locbase i208               ; get offset to local __ptr __ptr slice
addi $r623 $$locbase i216               ; get offset to local __ptr u64
mcpi $r621 $r622 i8                     ; copy memory
addi $r624 $r621 i8                     ; get offset to aggregate element
mcpi $r624 $r623 i8                     ; copy memory
mcpi $$locbase $r621 i16                ; copy memory
addi $r625 $$locbase i136               ; get offset to local __ptr slice
mcpi $r625 $$locbase i16                ; copy memory
move $r618 $r625                        ; move parameter from branch to block argument
ji  .131
.131
move $r628 $r618                        ; move parameter from branch to block argument
addi $r629 $$locbase i152               ; get offset to local __ptr slice
 mcpi $r629 $r628 i16                    ; copy memory
 mcpi $r629 $r618 i16                    ; copy memory
addi $r630 $$locbase i16                ; get offset to local __ptr slice
mcpi $r630 $r629 i16                    ; copy memory
load $r631 data_NonConfigurable_16      ; load constant from data section
lw $r632 $$locbase i2                   ; load slice pointer for logging data
lw $r633 $$locbase i3                   ; load slice size for logging data
logd $zero $r631 $r632 $r633            ; log slice
load $r634 data_NonConfigurable_4       ; load constant from data section
and $r635 $r600 $r634
load $r636 data_NonConfigurable_17      ; load constant from data section
or $r637 $r636 $r635
rvrt $r637
.39
cfsi i240                               ; [fn end: generic_panic_36] free: locals 240 byte(s), call args 0 slot(s)
move $$reta $r601                       ; [fn end: generic_panic_36] restore return address
popa .38                                ; [fn end: generic_panic_36] restore all used registers
jal $zero $$reta i0                     ; [fn end: generic_panic_36] return from call
    Finished debug [unoptimized + fuel] target(s) [6.712 KB] in ???
     Running 18 tests, filtered 0 tests

tested -- panicking_lib

      test test_nested_panic_inlined ... ok (???, 1953 gas)
           revert code: 8000000000001001
             panic message: Error E.
             panic value:   E([AsciiString { data: "to have" }, AsciiString { data: "strings" }, AsciiString { data: "in error enum variants" }])
             panicked:      in panicking_lib::nested_panic_inlined
                               at panicking_lib, src/lib.sw:35:5
             backtrace:     called in panicking_lib::call_nested_panic_inlined
                                at panicking_lib, src/lib.sw:46:5
                              called in panicking_lib::test_nested_panic_inlined
                                at panicking_lib, src/lib.sw:55:5
           decoded log values:
E([AsciiString { data: "to have" }, AsciiString { data: "strings" }, AsciiString { data: "in error enum variants" }]), log rb: 2721958641300806892
      test test_nested_panic_inlined_same_revert_code ... ok (???, 1953 gas)
           revert code: 8000000000001801
             panic message: Error E.
             panic value:   E([AsciiString { data: "to have" }, AsciiString { data: "strings" }, AsciiString { data: "in error enum variants" }])
             panicked:      in panicking_lib::nested_panic_inlined
                               at panicking_lib, src/lib.sw:35:5
             backtrace:     called in panicking_lib::call_nested_panic_inlined
                                at panicking_lib, src/lib.sw:46:5
                              called in panicking_lib::test_nested_panic_inlined_same_revert_code
                                at panicking_lib, src/lib.sw:60:5
           decoded log values:
E([AsciiString { data: "to have" }, AsciiString { data: "strings" }, AsciiString { data: "in error enum variants" }]), log rb: 2721958641300806892
      test test_nested_panic_non_inlined ... ok (???, 1987 gas)
           revert code: 8080000000002804
             panic message: Error E.
             panic value:   E([AsciiString { data: "this" }, AsciiString { data: "is not" }, AsciiString { data: "the best practice" }])
             panicked:      in panicking_lib::nested_panic_non_inlined
                               at panicking_lib, src/lib.sw:41:9
             backtrace:     called in panicking_lib::call_nested_panic_non_inlined
                                at panicking_lib, src/lib.sw:50:5
                              called in panicking_lib::test_nested_panic_non_inlined
                                at panicking_lib, src/lib.sw:65:5
           decoded log values:
E([AsciiString { data: "this" }, AsciiString { data: "is not" }, AsciiString { data: "the best practice" }]), log rb: 2721958641300806892
      test test_nested_panic_non_inlined_same_revert_code ... ok (???, 1987 gas)
           revert code: 8080000000003004
             panic message: Error E.
             panic value:   E([AsciiString { data: "this" }, AsciiString { data: "is not" }, AsciiString { data: "the best practice" }])
             panicked:      in panicking_lib::nested_panic_non_inlined
                               at panicking_lib, src/lib.sw:41:9
             backtrace:     called in panicking_lib::call_nested_panic_non_inlined
                                at panicking_lib, src/lib.sw:50:5
                              called in panicking_lib::test_nested_panic_non_inlined_same_revert_code
                                at panicking_lib, src/lib.sw:70:5
           decoded log values:
E([AsciiString { data: "this" }, AsciiString { data: "is not" }, AsciiString { data: "the best practice" }]), log rb: 2721958641300806892
      test test_generic_panic_with_unit ... ok (???, 619 gas)
           revert code: 8100000000000007
             panic value:   ()
             panicked:      in panicking_lib::generic_panic
                               at panicking_lib, src/lib.sw:74:5
             backtrace:     called in panicking_lib::test_generic_panic_with_unit
                                at panicking_lib, src/lib.sw:83:5
           decoded log values:
(), log rb: 3330666440490685604
      test test_generic_panic_with_unit_same_revert_code ... ok (???, 619 gas)
           revert code: 8100000000000008
             panic value:   ()
             panicked:      in panicking_lib::generic_panic
                               at panicking_lib, src/lib.sw:74:5
             backtrace:     called in panicking_lib::test_generic_panic_with_unit_same_revert_code
                                at panicking_lib, src/lib.sw:88:5
           decoded log values:
(), log rb: 3330666440490685604
      test test_generic_panic_with_str ... ok (???, 916 gas)
           revert code: 8180000000000009
             panic message: generic panic with string
             panicked:      in panicking_lib::generic_panic
                               at panicking_lib, src/lib.sw:74:5
             backtrace:     called in panicking_lib::test_generic_panic_with_str
                                at panicking_lib, src/lib.sw:93:5
           decoded log values:
AsciiString { data: "generic panic with string" }, log rb: 10098701174489624218
      test test_generic_panic_with_different_str_same_revert_code ... ok (???, 917 gas)
           revert code: 818000000000000a
             panic message: generic panic different string
             panicked:      in panicking_lib::generic_panic
                               at panicking_lib, src/lib.sw:74:5
             backtrace:     called in panicking_lib::test_generic_panic_with_different_str_same_revert_code
                                at panicking_lib, src/lib.sw:98:5
           decoded log values:
AsciiString { data: "generic panic different string" }, log rb: 10098701174489624218
      test test_generic_panic_with_error_type_enum_variant ... ok (???, 1022 gas)
           revert code: 820000000000000b
             panic message: Error A.
             panic value:   A
             panicked:      in panicking_lib::generic_panic
                               at panicking_lib, src/lib.sw:74:5
             backtrace:     called in panicking_lib::test_generic_panic_with_error_type_enum_variant
                                at panicking_lib, src/lib.sw:103:5
           decoded log values:
A, log rb: 2721958641300806892
      test test_generic_panic_with_error_type_enum_different_variant_same_revert_code ... ok (???, 1022 gas)
           revert code: 820000000000000c
             panic message: Error A.
             panic value:   A
             panicked:      in panicking_lib::generic_panic
                               at panicking_lib, src/lib.sw:74:5
             backtrace:     called in panicking_lib::test_generic_panic_with_error_type_enum_different_variant_same_revert_code
                                at panicking_lib, src/lib.sw:108:5
           decoded log values:
A, log rb: 2721958641300806892
      test test_panic_without_arg ... ok (???, 611 gas)
           revert code: 8280000000000000
             panic value:   ()
             panicked:      in panicking_lib::test_panic_without_arg
                                at panicking_lib, src/lib.sw:113:5
           decoded log values:
(), log rb: 3330666440490685604
      test test_panic_with_unit ... ok (???, 611 gas)
           revert code: 8300000000000000
             panic value:   ()
             panicked:      in panicking_lib::test_panic_with_unit
                                at panicking_lib, src/lib.sw:118:5
           decoded log values:
(), log rb: 3330666440490685604
      test test_panic_with_str ... ok (???, 79 gas)
           revert code: 8380000000000000
             panic message: panic with string
             panicked:      in panicking_lib::test_panic_with_str
                                at panicking_lib, src/lib.sw:123:5
      test test_panic_with_error_type_enum ... ok (???, 1206 gas)
           revert code: 8400000000000000
             panic message: Error C.
             panic value:   C(true)
             panicked:      in panicking_lib::test_panic_with_error_type_enum
                                at panicking_lib, src/lib.sw:128:5
           decoded log values:
C(true), log rb: 2721958641300806892
      test test_panic_with_generic_error_type_enum ... ok (???, 985 gas)
           revert code: 8480000000000000
             panic value:   A(42)
             panicked:      in panicking_lib::test_panic_with_generic_error_type_enum
                                at panicking_lib, src/lib.sw:133:5
           decoded log values:
A(42), log rb: 12408470889216862137
      test test_panic_with_nested_generic_error_type ... ok (???, 1485 gas)
           revert code: 8500000000000000
             panic value:   B(B(C(true)))
             panicked:      in panicking_lib::test_panic_with_nested_generic_error_type
                                at panicking_lib, src/lib.sw:138:5
           decoded log values:
B(B(C(true))), log rb: 14988555917426256081
      test test_panic_with_generic_error_type_enum_with_abi_encode ... ok (???, 985 gas)
           revert code: 8580000000000000
             panic value:   A(42)
             panicked:      in panicking_lib::test_panic_with_generic_error_type_enum_with_abi_encode
                                at panicking_lib, src/lib.sw:143:5
           decoded log values:
A(42), log rb: 17388243649088655852
      test test_panic_with_nested_generic_error_type_enum_with_abi_encode ... ok (???, 1485 gas)
           revert code: 8600000000000000
             panic value:   B(B(C(true)))
             panicked:      in panicking_lib::test_panic_with_nested_generic_error_type_enum_with_abi_encode
                                at panicking_lib, src/lib.sw:148:5
           decoded log values:
B(B(C(true))), log rb: 3755100321495500961

test result: OK. 18 passed; 0 failed; finished in ???

    Finished in ???

> forc test --path test/src/e2e_vm_tests/test_programs/should_pass/language/panic_expression/panicking_lib --release --test-threads 1 --logs --reverts
exit status: 0
output:
    Building test/src/e2e_vm_tests/test_programs/should_pass/language/panic_expression/panicking_lib
   Compiling library std (test/src/e2e_vm_tests/reduced_std_libs/sway-lib-std-core)
DIFF------------------------------
.program:
DIFF------------------------------
.program:
   Compiling library panicking_lib (test/src/e2e_vm_tests/test_programs/should_pass/language/panic_expression/panicking_lib)
DIFF------------------------------
.program:
DIFF------------------------------
.program:
DIFF------------------------------
.program:
.0                                      ; --- start of function: test_nested_panic_inlined ---
move $$locbase $sp                      ; [entry init: test_nested_panic_inlined]: set locals base register
cfei i0                                 ; [entry init: test_nested_panic_inlined]: allocate: locals 0 byte(s), call args 0 slot(s)
.66
 move $$arg0 $zero                       ; [call: call_nested_panic_inlined_0]: pass argument 0
 movi $$arg0 i0                          ; [call: call_nested_panic_inlined_0]: pass argument 0
fncall .2                               ; [call: call_nested_panic_inlined_0]: call function
 move $r1 $zero                          ; [call: call_nested_panic_inlined_0]: copy returned unit value
 movi $r1 i0                             ; [call: call_nested_panic_inlined_0]: copy returned unit value
ret $zero                               ; [entry end: test_nested_panic_inlined] return unit as zero
DIFF------------------------------
.program:
.0                                      ; --- start of function: test_nested_panic_inlined ---
move $$locbase $sp                      ; [entry init: test_nested_panic_inlined]: set locals base register
cfei i0                                 ; [entry init: test_nested_panic_inlined]: allocate: locals 0 byte(s), call args 0 slot(s)
.66
movi $$arg0 i0                          ; [call: call_nested_panic_inlined_0]: pass argument 0
fncall .2                               ; [call: call_nested_panic_inlined_0]: call function
ret $zero                               ; [entry end: test_nested_panic_inlined] return unit as zero
DIFF------------------------------
.program:
.0                                      ; --- start of function: test_nested_panic_inlined ---
move $$locbase $sp                      ; [entry init: test_nested_panic_inlined]: set locals base register
cfei i0                                 ; [entry init: test_nested_panic_inlined]: allocate: locals 0 byte(s), call args 0 slot(s)
.66
movi $$arg0 i0                          ; [call: call_nested_panic_inlined_0]: pass argument 0
fncall .2                               ; [call: call_nested_panic_inlined_0]: call function
ret $zero                               ; [entry end: test_nested_panic_inlined] return unit as zero
DIFF------------------------------
.program:
.0                                      ; --- start of function: test_nested_panic_inlined ---
move $$locbase $sp                      ; [entry init: test_nested_panic_inlined]: set locals base register
cfei i0                                 ; [entry init: test_nested_panic_inlined]: allocate: locals 0 byte(s), call args 0 slot(s)
.66
movi $$arg0 i0                          ; [call: call_nested_panic_inlined_0]: pass argument 0
fncall .2                               ; [call: call_nested_panic_inlined_0]: call function
ret $zero                               ; [entry end: test_nested_panic_inlined] return unit as zero
DIFF------------------------------
.program:
.20                                     ; --- start of function: test_nested_panic_inlined_same_revert_code ---
move $$locbase $sp                      ; [entry init: test_nested_panic_inlined_same_revert_code]: set locals base register
cfei i0                                 ; [entry init: test_nested_panic_inlined_same_revert_code]: allocate: locals 0 byte(s), call args 0 slot(s)
.110
 move $$arg0 $zero                       ; [call: call_nested_panic_inlined_0]: pass argument 0
 movi $$arg0 i0                          ; [call: call_nested_panic_inlined_0]: pass argument 0
fncall .2                               ; [call: call_nested_panic_inlined_0]: call function
 move $r375 $zero                        ; [call: call_nested_panic_inlined_0]: copy returned unit value
 movi $r375 i0                           ; [call: call_nested_panic_inlined_0]: copy returned unit value
ret $zero                               ; [entry end: test_nested_panic_inlined_same_revert_code] return unit as zero
DIFF------------------------------
.program:
.20                                     ; --- start of function: test_nested_panic_inlined_same_revert_code ---
move $$locbase $sp                      ; [entry init: test_nested_panic_inlined_same_revert_code]: set locals base register
cfei i0                                 ; [entry init: test_nested_panic_inlined_same_revert_code]: allocate: locals 0 byte(s), call args 0 slot(s)
.110
movi $$arg0 i0                          ; [call: call_nested_panic_inlined_0]: pass argument 0
fncall .2                               ; [call: call_nested_panic_inlined_0]: call function
ret $zero                               ; [entry end: test_nested_panic_inlined_same_revert_code] return unit as zero
DIFF------------------------------
.program:
.20                                     ; --- start of function: test_nested_panic_inlined_same_revert_code ---
move $$locbase $sp                      ; [entry init: test_nested_panic_inlined_same_revert_code]: set locals base register
cfei i0                                 ; [entry init: test_nested_panic_inlined_same_revert_code]: allocate: locals 0 byte(s), call args 0 slot(s)
.110
movi $$arg0 i0                          ; [call: call_nested_panic_inlined_0]: pass argument 0
fncall .2                               ; [call: call_nested_panic_inlined_0]: call function
ret $zero                               ; [entry end: test_nested_panic_inlined_same_revert_code] return unit as zero
DIFF------------------------------
.program:
.20                                     ; --- start of function: test_nested_panic_inlined_same_revert_code ---
move $$locbase $sp                      ; [entry init: test_nested_panic_inlined_same_revert_code]: set locals base register
cfei i0                                 ; [entry init: test_nested_panic_inlined_same_revert_code]: allocate: locals 0 byte(s), call args 0 slot(s)
.110
movi $$arg0 i0                          ; [call: call_nested_panic_inlined_0]: pass argument 0
fncall .2                               ; [call: call_nested_panic_inlined_0]: call function
ret $zero                               ; [entry end: test_nested_panic_inlined_same_revert_code] return unit as zero
DIFF------------------------------
.program:
.22                                     ; --- start of function: test_nested_panic_non_inlined ---
move $$locbase $sp                      ; [entry init: test_nested_panic_non_inlined]: set locals base register
cfei i0                                 ; [entry init: test_nested_panic_non_inlined]: allocate: locals 0 byte(s), call args 0 slot(s)
.111
 move $$arg0 $zero                       ; [call: call_nested_panic_non_inlined_31]: pass argument 0
 movi $$arg0 i0                          ; [call: call_nested_panic_non_inlined_31]: pass argument 0
fncall .24                              ; [call: call_nested_panic_non_inlined_31]: call function
 move $r377 $zero                        ; [call: call_nested_panic_non_inlined_31]: copy returned unit value
 movi $r377 i0                           ; [call: call_nested_panic_non_inlined_31]: copy returned unit value
ret $zero                               ; [entry end: test_nested_panic_non_inlined] return unit as zero
DIFF------------------------------
.program:
.22                                     ; --- start of function: test_nested_panic_non_inlined ---
move $$locbase $sp                      ; [entry init: test_nested_panic_non_inlined]: set locals base register
cfei i0                                 ; [entry init: test_nested_panic_non_inlined]: allocate: locals 0 byte(s), call args 0 slot(s)
.111
movi $$arg0 i0                          ; [call: call_nested_panic_non_inlined_31]: pass argument 0
fncall .24                              ; [call: call_nested_panic_non_inlined_31]: call function
ret $zero                               ; [entry end: test_nested_panic_non_inlined] return unit as zero
DIFF------------------------------
.program:
.22                                     ; --- start of function: test_nested_panic_non_inlined ---
move $$locbase $sp                      ; [entry init: test_nested_panic_non_inlined]: set locals base register
cfei i0                                 ; [entry init: test_nested_panic_non_inlined]: allocate: locals 0 byte(s), call args 0 slot(s)
.111
movi $$arg0 i0                          ; [call: call_nested_panic_non_inlined_31]: pass argument 0
fncall .24                              ; [call: call_nested_panic_non_inlined_31]: call function
ret $zero                               ; [entry end: test_nested_panic_non_inlined] return unit as zero
DIFF------------------------------
.program:
.22                                     ; --- start of function: test_nested_panic_non_inlined ---
move $$locbase $sp                      ; [entry init: test_nested_panic_non_inlined]: set locals base register
cfei i0                                 ; [entry init: test_nested_panic_non_inlined]: allocate: locals 0 byte(s), call args 0 slot(s)
.111
movi $$arg0 i0                          ; [call: call_nested_panic_non_inlined_31]: pass argument 0
fncall .24                              ; [call: call_nested_panic_non_inlined_31]: call function
ret $zero                               ; [entry end: test_nested_panic_non_inlined] return unit as zero
DIFF------------------------------
.program:
.28                                     ; --- start of function: test_nested_panic_non_inlined_same_revert_code ---
move $$locbase $sp                      ; [entry init: test_nested_panic_non_inlined_same_revert_code]: set locals base register
cfei i0                                 ; [entry init: test_nested_panic_non_inlined_same_revert_code]: allocate: locals 0 byte(s), call args 0 slot(s)
.116
 move $$arg0 $zero                       ; [call: call_nested_panic_non_inlined_31]: pass argument 0
 movi $$arg0 i0                          ; [call: call_nested_panic_non_inlined_31]: pass argument 0
fncall .24                              ; [call: call_nested_panic_non_inlined_31]: call function
 move $r421 $zero                        ; [call: call_nested_panic_non_inlined_31]: copy returned unit value
 movi $r421 i0                           ; [call: call_nested_panic_non_inlined_31]: copy returned unit value
ret $zero                               ; [entry end: test_nested_panic_non_inlined_same_revert_code] return unit as zero
DIFF------------------------------
.program:
.28                                     ; --- start of function: test_nested_panic_non_inlined_same_revert_code ---
move $$locbase $sp                      ; [entry init: test_nested_panic_non_inlined_same_revert_code]: set locals base register
cfei i0                                 ; [entry init: test_nested_panic_non_inlined_same_revert_code]: allocate: locals 0 byte(s), call args 0 slot(s)
.116
movi $$arg0 i0                          ; [call: call_nested_panic_non_inlined_31]: pass argument 0
fncall .24                              ; [call: call_nested_panic_non_inlined_31]: call function
ret $zero                               ; [entry end: test_nested_panic_non_inlined_same_revert_code] return unit as zero
DIFF------------------------------
.program:
.28                                     ; --- start of function: test_nested_panic_non_inlined_same_revert_code ---
move $$locbase $sp                      ; [entry init: test_nested_panic_non_inlined_same_revert_code]: set locals base register
cfei i0                                 ; [entry init: test_nested_panic_non_inlined_same_revert_code]: allocate: locals 0 byte(s), call args 0 slot(s)
.116
movi $$arg0 i0                          ; [call: call_nested_panic_non_inlined_31]: pass argument 0
fncall .24                              ; [call: call_nested_panic_non_inlined_31]: call function
ret $zero                               ; [entry end: test_nested_panic_non_inlined_same_revert_code] return unit as zero
DIFF------------------------------
.program:
.28                                     ; --- start of function: test_nested_panic_non_inlined_same_revert_code ---
move $$locbase $sp                      ; [entry init: test_nested_panic_non_inlined_same_revert_code]: set locals base register
cfei i0                                 ; [entry init: test_nested_panic_non_inlined_same_revert_code]: allocate: locals 0 byte(s), call args 0 slot(s)
.116
movi $$arg0 i0                          ; [call: call_nested_panic_non_inlined_31]: pass argument 0
fncall .24                              ; [call: call_nested_panic_non_inlined_31]: call function
ret $zero                               ; [entry end: test_nested_panic_non_inlined_same_revert_code] return unit as zero
DIFF------------------------------
.program:
.30                                     ; --- start of function: test_generic_panic_with_unit ---
move $$locbase $sp                      ; [entry init: test_generic_panic_with_unit]: set locals base register
cfei i16                                ; [entry init: test_generic_panic_with_unit]: allocate: locals 16 byte(s), call args 0 slot(s)
.117
addi $r423 $$locbase i16                ; get offset to local __ptr ()
addi $r424 $$locbase i16                ; get offset to local __ptr ()
move $$arg0 $r424                       ; [call: encode_allow_alias_34]: pass argument 0
move $$arg1 $$locbase                   ; [call: encode_allow_alias_34]: pass argument 1
fncall .32                              ; [call: encode_allow_alias_34]: call function
 move $r425 $zero                        ; [call: encode_allow_alias_34]: copy returned unit value
 movi $r425 i0                           ; [call: encode_allow_alias_34]: copy returned unit value
load $r426 data_NonConfigurable_11      ; load constant from data section
lw $r427 $$locbase i0                   ; load slice pointer for logging data
lw $r428 $$locbase i1                   ; load slice size for logging data
logd $zero $r426 $r427 $r428            ; log slice
load $r429 data_NonConfigurable_12      ; load constant from data section
rvrt $r429
DIFF------------------------------
.program:
.30                                     ; --- start of function: test_generic_panic_with_unit ---
move $$locbase $sp                      ; [entry init: test_generic_panic_with_unit]: set locals base register
cfei i16                                ; [entry init: test_generic_panic_with_unit]: allocate: locals 16 byte(s), call args 0 slot(s)
.117
addi $r424 $$locbase i16                ; get offset to local __ptr ()
move $$arg0 $r424                       ; [call: encode_allow_alias_34]: pass argument 0
move $$arg1 $$locbase                   ; [call: encode_allow_alias_34]: pass argument 1
fncall .32                              ; [call: encode_allow_alias_34]: call function
load $r426 data_NonConfigurable_11      ; load constant from data section
lw $r427 $$locbase i0                   ; load slice pointer for logging data
lw $r428 $$locbase i1                   ; load slice size for logging data
logd $zero $r426 $r427 $r428            ; log slice
load $r429 data_NonConfigurable_12      ; load constant from data section
rvrt $r429
DIFF------------------------------
.program:
.30                                     ; --- start of function: test_generic_panic_with_unit ---
move $$locbase $sp                      ; [entry init: test_generic_panic_with_unit]: set locals base register
cfei i16                                ; [entry init: test_generic_panic_with_unit]: allocate: locals 16 byte(s), call args 0 slot(s)
.117
addi $r424 $$locbase i16                ; get offset to local __ptr ()
move $$arg0 $r424                       ; [call: encode_allow_alias_34]: pass argument 0
move $$arg1 $$locbase                   ; [call: encode_allow_alias_34]: pass argument 1
fncall .32                              ; [call: encode_allow_alias_34]: call function
load $r426 data_NonConfigurable_11      ; load constant from data section
lw $r427 $$locbase i0                   ; load slice pointer for logging data
lw $r428 $$locbase i1                   ; load slice size for logging data
logd $zero $r426 $r427 $r428            ; log slice
load $r429 data_NonConfigurable_12      ; load constant from data section
rvrt $r429
DIFF------------------------------
.program:
.30                                     ; --- start of function: test_generic_panic_with_unit ---
move $$locbase $sp                      ; [entry init: test_generic_panic_with_unit]: set locals base register
cfei i16                                ; [entry init: test_generic_panic_with_unit]: allocate: locals 16 byte(s), call args 0 slot(s)
.117
addi $r424 $$locbase i16                ; get offset to local __ptr ()
move $$arg0 $r424                       ; [call: encode_allow_alias_34]: pass argument 0
move $$arg1 $$locbase                   ; [call: encode_allow_alias_34]: pass argument 1
fncall .32                              ; [call: encode_allow_alias_34]: call function
load $r426 data_NonConfigurable_11      ; load constant from data section
lw $r427 $$locbase i0                   ; load slice pointer for logging data
lw $r428 $$locbase i1                   ; load slice size for logging data
logd $zero $r426 $r427 $r428            ; log slice
load $r429 data_NonConfigurable_12      ; load constant from data section
rvrt $r429
DIFF------------------------------
.program:
.34                                     ; --- start of function: test_generic_panic_with_unit_same_revert_code ---
move $$locbase $sp                      ; [entry init: test_generic_panic_with_unit_same_revert_code]: set locals base register
cfei i16                                ; [entry init: test_generic_panic_with_unit_same_revert_code]: allocate: locals 16 byte(s), call args 0 slot(s)
.119
addi $r433 $$locbase i16                ; get offset to local __ptr ()
addi $r434 $$locbase i16                ; get offset to local __ptr ()
move $$arg0 $r434                       ; [call: encode_allow_alias_34]: pass argument 0
move $$arg1 $$locbase                   ; [call: encode_allow_alias_34]: pass argument 1
fncall .32                              ; [call: encode_allow_alias_34]: call function
 move $r435 $zero                        ; [call: encode_allow_alias_34]: copy returned unit value
 movi $r435 i0                           ; [call: encode_allow_alias_34]: copy returned unit value
load $r436 data_NonConfigurable_11      ; load constant from data section
lw $r437 $$locbase i0                   ; load slice pointer for logging data
lw $r438 $$locbase i1                   ; load slice size for logging data
logd $zero $r436 $r437 $r438            ; log slice
load $r439 data_NonConfigurable_12      ; load constant from data section
rvrt $r439
DIFF------------------------------
.program:
.34                                     ; --- start of function: test_generic_panic_with_unit_same_revert_code ---
move $$locbase $sp                      ; [entry init: test_generic_panic_with_unit_same_revert_code]: set locals base register
cfei i16                                ; [entry init: test_generic_panic_with_unit_same_revert_code]: allocate: locals 16 byte(s), call args 0 slot(s)
.119
addi $r434 $$locbase i16                ; get offset to local __ptr ()
move $$arg0 $r434                       ; [call: encode_allow_alias_34]: pass argument 0
move $$arg1 $$locbase                   ; [call: encode_allow_alias_34]: pass argument 1
fncall .32                              ; [call: encode_allow_alias_34]: call function
load $r436 data_NonConfigurable_11      ; load constant from data section
lw $r437 $$locbase i0                   ; load slice pointer for logging data
lw $r438 $$locbase i1                   ; load slice size for logging data
logd $zero $r436 $r437 $r438            ; log slice
load $r439 data_NonConfigurable_12      ; load constant from data section
rvrt $r439
DIFF------------------------------
.program:
.34                                     ; --- start of function: test_generic_panic_with_unit_same_revert_code ---
move $$locbase $sp                      ; [entry init: test_generic_panic_with_unit_same_revert_code]: set locals base register
cfei i16                                ; [entry init: test_generic_panic_with_unit_same_revert_code]: allocate: locals 16 byte(s), call args 0 slot(s)
.119
addi $r434 $$locbase i16                ; get offset to local __ptr ()
move $$arg0 $r434                       ; [call: encode_allow_alias_34]: pass argument 0
move $$arg1 $$locbase                   ; [call: encode_allow_alias_34]: pass argument 1
fncall .32                              ; [call: encode_allow_alias_34]: call function
load $r436 data_NonConfigurable_11      ; load constant from data section
lw $r437 $$locbase i0                   ; load slice pointer for logging data
lw $r438 $$locbase i1                   ; load slice size for logging data
logd $zero $r436 $r437 $r438            ; log slice
load $r439 data_NonConfigurable_12      ; load constant from data section
rvrt $r439
DIFF------------------------------
.program:
.34                                     ; --- start of function: test_generic_panic_with_unit_same_revert_code ---
move $$locbase $sp                      ; [entry init: test_generic_panic_with_unit_same_revert_code]: set locals base register
cfei i16                                ; [entry init: test_generic_panic_with_unit_same_revert_code]: allocate: locals 16 byte(s), call args 0 slot(s)
.119
addi $r434 $$locbase i16                ; get offset to local __ptr ()
move $$arg0 $r434                       ; [call: encode_allow_alias_34]: pass argument 0
move $$arg1 $$locbase                   ; [call: encode_allow_alias_34]: pass argument 1
fncall .32                              ; [call: encode_allow_alias_34]: call function
load $r436 data_NonConfigurable_11      ; load constant from data section
lw $r437 $$locbase i0                   ; load slice pointer for logging data
lw $r438 $$locbase i1                   ; load slice size for logging data
logd $zero $r436 $r437 $r438            ; log slice
load $r439 data_NonConfigurable_12      ; load constant from data section
rvrt $r439
DIFF------------------------------
.program:
.36                                     ; --- start of function: test_generic_panic_with_str ---
move $$locbase $sp                      ; [entry init: test_generic_panic_with_str]: set locals base register
cfei i32                                ; [entry init: test_generic_panic_with_str]: allocate: locals 32 byte(s), call args 0 slot(s)
.120
addr $r441 data_NonConfigurable_13      ; get __const_global5's address in data section
sw $$locbase $r441 i0                   ; store word
addi $r442 $$locbase i8                 ; get offset to aggregate element
movi $r443 i25                          ; initialize constant into register
sw $$locbase $r443 i1                   ; store word
addi $r444 $$locbase i16                ; get offset to local __ptr slice
mcpi $r444 $$locbase i16                ; copy memory
addi $r445 $$locbase i16                ; get offset to local __ptr slice
move $$arg0 $r445                       ; [call: generic_panic_36]: pass argument 0
 move $$arg1 $zero                       ; [call: generic_panic_36]: pass argument 1
 movi $$arg1 i0                          ; [call: generic_panic_36]: pass argument 1
fncall .38                              ; [call: generic_panic_36]: call function
 move $r446 $zero                        ; [call: generic_panic_36]: copy returned unit value
 movi $r446 i0                           ; [call: generic_panic_36]: copy returned unit value
ret $zero                               ; [entry end: test_generic_panic_with_str] return unit as zero
DIFF------------------------------
.program:
.36                                     ; --- start of function: test_generic_panic_with_str ---
move $$locbase $sp                      ; [entry init: test_generic_panic_with_str]: set locals base register
cfei i32                                ; [entry init: test_generic_panic_with_str]: allocate: locals 32 byte(s), call args 0 slot(s)
.120
addr $r441 data_NonConfigurable_13      ; get __const_global5's address in data section
sw $$locbase $r441 i0                   ; store word
movi $r443 i25                          ; initialize constant into register
sw $$locbase $r443 i1                   ; store word
addi $r444 $$locbase i16                ; get offset to local __ptr slice
mcpi $r444 $$locbase i16                ; copy memory
addi $r445 $$locbase i16                ; get offset to local __ptr slice
move $$arg0 $r445                       ; [call: generic_panic_36]: pass argument 0
movi $$arg1 i0                          ; [call: generic_panic_36]: pass argument 1
fncall .38                              ; [call: generic_panic_36]: call function
ret $zero                               ; [entry end: test_generic_panic_with_str] return unit as zero
DIFF------------------------------
.program:
.36                                     ; --- start of function: test_generic_panic_with_str ---
move $$locbase $sp                      ; [entry init: test_generic_panic_with_str]: set locals base register
cfei i32                                ; [entry init: test_generic_panic_with_str]: allocate: locals 32 byte(s), call args 0 slot(s)
.120
addr $r441 data_NonConfigurable_13      ; get __const_global5's address in data section
sw $$locbase $r441 i0                   ; store word
movi $r443 i25                          ; initialize constant into register
sw $$locbase $r443 i1                   ; store word
addi $r444 $$locbase i16                ; get offset to local __ptr slice
mcpi $r444 $$locbase i16                ; copy memory
addi $r445 $$locbase i16                ; get offset to local __ptr slice
move $$arg0 $r445                       ; [call: generic_panic_36]: pass argument 0
movi $$arg1 i0                          ; [call: generic_panic_36]: pass argument 1
fncall .38                              ; [call: generic_panic_36]: call function
ret $zero                               ; [entry end: test_generic_panic_with_str] return unit as zero
DIFF------------------------------
.program:
.36                                     ; --- start of function: test_generic_panic_with_str ---
move $$locbase $sp                      ; [entry init: test_generic_panic_with_str]: set locals base register
cfei i32                                ; [entry init: test_generic_panic_with_str]: allocate: locals 32 byte(s), call args 0 slot(s)
.120
addr $r441 data_NonConfigurable_13      ; get __const_global5's address in data section
sw $$locbase $r441 i0                   ; store word
movi $r443 i25                          ; initialize constant into register
sw $$locbase $r443 i1                   ; store word
addi $r444 $$locbase i16                ; get offset to local __ptr slice
mcpi $r444 $$locbase i16                ; copy memory
addi $r445 $$locbase i16                ; get offset to local __ptr slice
move $$arg0 $r445                       ; [call: generic_panic_36]: pass argument 0
movi $$arg1 i0                          ; [call: generic_panic_36]: pass argument 1
fncall .38                              ; [call: generic_panic_36]: call function
ret $zero                               ; [entry end: test_generic_panic_with_str] return unit as zero
DIFF------------------------------
.program:
.40                                     ; --- start of function: test_generic_panic_with_different_str_same_revert_code ---
move $$locbase $sp                      ; [entry init: test_generic_panic_with_different_str_same_revert_code]: set locals base register
cfei i32                                ; [entry init: test_generic_panic_with_different_str_same_revert_code]: allocate: locals 32 byte(s), call args 0 slot(s)
.122
addr $r465 data_NonConfigurable_16      ; get __const_global6's address in data section
sw $$locbase $r465 i0                   ; store word
addi $r466 $$locbase i8                 ; get offset to aggregate element
movi $r467 i30                          ; initialize constant into register
sw $$locbase $r467 i1                   ; store word
addi $r468 $$locbase i16                ; get offset to local __ptr slice
mcpi $r468 $$locbase i16                ; copy memory
addi $r469 $$locbase i16                ; get offset to local __ptr slice
move $$arg0 $r469                       ; [call: generic_panic_36]: pass argument 0
 move $$arg1 $zero                       ; [call: generic_panic_36]: pass argument 1
 movi $$arg1 i0                          ; [call: generic_panic_36]: pass argument 1
fncall .38                              ; [call: generic_panic_36]: call function
 move $r470 $zero                        ; [call: generic_panic_36]: copy returned unit value
 movi $r470 i0                           ; [call: generic_panic_36]: copy returned unit value
ret $zero                               ; [entry end: test_generic_panic_with_different_str_same_revert_code] return unit as zero
DIFF------------------------------
.program:
.40                                     ; --- start of function: test_generic_panic_with_different_str_same_revert_code ---
move $$locbase $sp                      ; [entry init: test_generic_panic_with_different_str_same_revert_code]: set locals base register
cfei i32                                ; [entry init: test_generic_panic_with_different_str_same_revert_code]: allocate: locals 32 byte(s), call args 0 slot(s)
.122
addr $r465 data_NonConfigurable_16      ; get __const_global6's address in data section
sw $$locbase $r465 i0                   ; store word
movi $r467 i30                          ; initialize constant into register
sw $$locbase $r467 i1                   ; store word
addi $r468 $$locbase i16                ; get offset to local __ptr slice
mcpi $r468 $$locbase i16                ; copy memory
addi $r469 $$locbase i16                ; get offset to local __ptr slice
move $$arg0 $r469                       ; [call: generic_panic_36]: pass argument 0
movi $$arg1 i0                          ; [call: generic_panic_36]: pass argument 1
fncall .38                              ; [call: generic_panic_36]: call function
ret $zero                               ; [entry end: test_generic_panic_with_different_str_same_revert_code] return unit as zero
DIFF------------------------------
.program:
.40                                     ; --- start of function: test_generic_panic_with_different_str_same_revert_code ---
move $$locbase $sp                      ; [entry init: test_generic_panic_with_different_str_same_revert_code]: set locals base register
cfei i32                                ; [entry init: test_generic_panic_with_different_str_same_revert_code]: allocate: locals 32 byte(s), call args 0 slot(s)
.122
addr $r465 data_NonConfigurable_16      ; get __const_global6's address in data section
sw $$locbase $r465 i0                   ; store word
movi $r467 i30                          ; initialize constant into register
sw $$locbase $r467 i1                   ; store word
addi $r468 $$locbase i16                ; get offset to local __ptr slice
mcpi $r468 $$locbase i16                ; copy memory
addi $r469 $$locbase i16                ; get offset to local __ptr slice
move $$arg0 $r469                       ; [call: generic_panic_36]: pass argument 0
movi $$arg1 i0                          ; [call: generic_panic_36]: pass argument 1
fncall .38                              ; [call: generic_panic_36]: call function
ret $zero                               ; [entry end: test_generic_panic_with_different_str_same_revert_code] return unit as zero
DIFF------------------------------
.program:
.40                                     ; --- start of function: test_generic_panic_with_different_str_same_revert_code ---
move $$locbase $sp                      ; [entry init: test_generic_panic_with_different_str_same_revert_code]: set locals base register
cfei i32                                ; [entry init: test_generic_panic_with_different_str_same_revert_code]: allocate: locals 32 byte(s), call args 0 slot(s)
.122
addr $r465 data_NonConfigurable_16      ; get __const_global6's address in data section
sw $$locbase $r465 i0                   ; store word
movi $r467 i30                          ; initialize constant into register
sw $$locbase $r467 i1                   ; store word
addi $r468 $$locbase i16                ; get offset to local __ptr slice
mcpi $r468 $$locbase i16                ; copy memory
addi $r469 $$locbase i16                ; get offset to local __ptr slice
move $$arg0 $r469                       ; [call: generic_panic_36]: pass argument 0
movi $$arg1 i0                          ; [call: generic_panic_36]: pass argument 1
fncall .38                              ; [call: generic_panic_36]: call function
ret $zero                               ; [entry end: test_generic_panic_with_different_str_same_revert_code] return unit as zero
DIFF------------------------------
.program:
.42                                     ; --- start of function: test_generic_panic_with_error_type_enum_variant ---
move $$locbase $sp                      ; [entry init: test_generic_panic_with_error_type_enum_variant]: set locals base register
cfei i72                                ; [entry init: test_generic_panic_with_error_type_enum_variant]: allocate: locals 72 byte(s), call args 0 slot(s)
.123
addi $r472 $$locbase i16                ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
sw $$locbase $zero i2                   ; store word
addi $r473 $$locbase i16                ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
move $$arg0 $r473                       ; [call: encode_allow_alias_2]: pass argument 0
move $$arg1 $$locbase                   ; [call: encode_allow_alias_2]: pass argument 1
fncall .4                               ; [call: encode_allow_alias_2]: call function
 move $r474 $zero                        ; [call: encode_allow_alias_2]: copy returned unit value
 movi $r474 i0                           ; [call: encode_allow_alias_2]: copy returned unit value
load $r475 data_NonConfigurable_3       ; load constant from data section
lw $r476 $$locbase i0                   ; load slice pointer for logging data
lw $r477 $$locbase i1                   ; load slice size for logging data
logd $zero $r475 $r476 $r477            ; log slice
load $r478 data_NonConfigurable_17      ; load constant from data section
rvrt $r478
DIFF------------------------------
.program:
.42                                     ; --- start of function: test_generic_panic_with_error_type_enum_variant ---
move $$locbase $sp                      ; [entry init: test_generic_panic_with_error_type_enum_variant]: set locals base register
cfei i72                                ; [entry init: test_generic_panic_with_error_type_enum_variant]: allocate: locals 72 byte(s), call args 0 slot(s)
.123
sw $$locbase $zero i2                   ; store word
addi $r473 $$locbase i16                ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
move $$arg0 $r473                       ; [call: encode_allow_alias_2]: pass argument 0
move $$arg1 $$locbase                   ; [call: encode_allow_alias_2]: pass argument 1
fncall .4                               ; [call: encode_allow_alias_2]: call function
load $r475 data_NonConfigurable_3       ; load constant from data section
lw $r476 $$locbase i0                   ; load slice pointer for logging data
lw $r477 $$locbase i1                   ; load slice size for logging data
logd $zero $r475 $r476 $r477            ; log slice
load $r478 data_NonConfigurable_17      ; load constant from data section
rvrt $r478
DIFF------------------------------
.program:
.42                                     ; --- start of function: test_generic_panic_with_error_type_enum_variant ---
move $$locbase $sp                      ; [entry init: test_generic_panic_with_error_type_enum_variant]: set locals base register
cfei i72                                ; [entry init: test_generic_panic_with_error_type_enum_variant]: allocate: locals 72 byte(s), call args 0 slot(s)
.123
sw $$locbase $zero i2                   ; store word
addi $r473 $$locbase i16                ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
move $$arg0 $r473                       ; [call: encode_allow_alias_2]: pass argument 0
move $$arg1 $$locbase                   ; [call: encode_allow_alias_2]: pass argument 1
fncall .4                               ; [call: encode_allow_alias_2]: call function
load $r475 data_NonConfigurable_3       ; load constant from data section
lw $r476 $$locbase i0                   ; load slice pointer for logging data
lw $r477 $$locbase i1                   ; load slice size for logging data
logd $zero $r475 $r476 $r477            ; log slice
load $r478 data_NonConfigurable_17      ; load constant from data section
rvrt $r478
DIFF------------------------------
.program:
.42                                     ; --- start of function: test_generic_panic_with_error_type_enum_variant ---
move $$locbase $sp                      ; [entry init: test_generic_panic_with_error_type_enum_variant]: set locals base register
cfei i72                                ; [entry init: test_generic_panic_with_error_type_enum_variant]: allocate: locals 72 byte(s), call args 0 slot(s)
.123
sw $$locbase $zero i2                   ; store word
addi $r473 $$locbase i16                ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
move $$arg0 $r473                       ; [call: encode_allow_alias_2]: pass argument 0
move $$arg1 $$locbase                   ; [call: encode_allow_alias_2]: pass argument 1
fncall .4                               ; [call: encode_allow_alias_2]: call function
load $r475 data_NonConfigurable_3       ; load constant from data section
lw $r476 $$locbase i0                   ; load slice pointer for logging data
lw $r477 $$locbase i1                   ; load slice size for logging data
logd $zero $r475 $r476 $r477            ; log slice
load $r478 data_NonConfigurable_17      ; load constant from data section
rvrt $r478
DIFF------------------------------
.program:
.44                                     ; --- start of function: test_generic_panic_with_error_type_enum_different_variant_same_revert_code ---
move $$locbase $sp                      ; [entry init: test_generic_panic_with_error_type_enum_different_variant_same_revert_code]: set locals base register
cfei i72                                ; [entry init: test_generic_panic_with_error_type_enum_different_variant_same_revert_code]: allocate: locals 72 byte(s), call args 0 slot(s)
.124
addi $r480 $$locbase i16                ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
sw $$locbase $zero i2                   ; store word
addi $r481 $$locbase i16                ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
move $$arg0 $r481                       ; [call: encode_allow_alias_2]: pass argument 0
move $$arg1 $$locbase                   ; [call: encode_allow_alias_2]: pass argument 1
fncall .4                               ; [call: encode_allow_alias_2]: call function
 move $r482 $zero                        ; [call: encode_allow_alias_2]: copy returned unit value
 movi $r482 i0                           ; [call: encode_allow_alias_2]: copy returned unit value
load $r483 data_NonConfigurable_3       ; load constant from data section
lw $r484 $$locbase i0                   ; load slice pointer for logging data
lw $r485 $$locbase i1                   ; load slice size for logging data
logd $zero $r483 $r484 $r485            ; log slice
load $r486 data_NonConfigurable_17      ; load constant from data section
rvrt $r486
DIFF------------------------------
.program:
.44                                     ; --- start of function: test_generic_panic_with_error_type_enum_different_variant_same_revert_code ---
move $$locbase $sp                      ; [entry init: test_generic_panic_with_error_type_enum_different_variant_same_revert_code]: set locals base register
cfei i72                                ; [entry init: test_generic_panic_with_error_type_enum_different_variant_same_revert_code]: allocate: locals 72 byte(s), call args 0 slot(s)
.124
sw $$locbase $zero i2                   ; store word
addi $r481 $$locbase i16                ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
move $$arg0 $r481                       ; [call: encode_allow_alias_2]: pass argument 0
move $$arg1 $$locbase                   ; [call: encode_allow_alias_2]: pass argument 1
fncall .4                               ; [call: encode_allow_alias_2]: call function
load $r483 data_NonConfigurable_3       ; load constant from data section
lw $r484 $$locbase i0                   ; load slice pointer for logging data
lw $r485 $$locbase i1                   ; load slice size for logging data
logd $zero $r483 $r484 $r485            ; log slice
load $r486 data_NonConfigurable_17      ; load constant from data section
rvrt $r486
DIFF------------------------------
.program:
.44                                     ; --- start of function: test_generic_panic_with_error_type_enum_different_variant_same_revert_code ---
move $$locbase $sp                      ; [entry init: test_generic_panic_with_error_type_enum_different_variant_same_revert_code]: set locals base register
cfei i72                                ; [entry init: test_generic_panic_with_error_type_enum_different_variant_same_revert_code]: allocate: locals 72 byte(s), call args 0 slot(s)
.124
sw $$locbase $zero i2                   ; store word
addi $r481 $$locbase i16                ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
move $$arg0 $r481                       ; [call: encode_allow_alias_2]: pass argument 0
move $$arg1 $$locbase                   ; [call: encode_allow_alias_2]: pass argument 1
fncall .4                               ; [call: encode_allow_alias_2]: call function
load $r483 data_NonConfigurable_3       ; load constant from data section
lw $r484 $$locbase i0                   ; load slice pointer for logging data
lw $r485 $$locbase i1                   ; load slice size for logging data
logd $zero $r483 $r484 $r485            ; log slice
load $r486 data_NonConfigurable_17      ; load constant from data section
rvrt $r486
DIFF------------------------------
.program:
.44                                     ; --- start of function: test_generic_panic_with_error_type_enum_different_variant_same_revert_code ---
move $$locbase $sp                      ; [entry init: test_generic_panic_with_error_type_enum_different_variant_same_revert_code]: set locals base register
cfei i72                                ; [entry init: test_generic_panic_with_error_type_enum_different_variant_same_revert_code]: allocate: locals 72 byte(s), call args 0 slot(s)
.124
sw $$locbase $zero i2                   ; store word
addi $r481 $$locbase i16                ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
move $$arg0 $r481                       ; [call: encode_allow_alias_2]: pass argument 0
move $$arg1 $$locbase                   ; [call: encode_allow_alias_2]: pass argument 1
fncall .4                               ; [call: encode_allow_alias_2]: call function
load $r483 data_NonConfigurable_3       ; load constant from data section
lw $r484 $$locbase i0                   ; load slice pointer for logging data
lw $r485 $$locbase i1                   ; load slice size for logging data
logd $zero $r483 $r484 $r485            ; log slice
load $r486 data_NonConfigurable_17      ; load constant from data section
rvrt $r486
DIFF------------------------------
.program:
.46                                     ; --- start of function: test_panic_without_arg ---
move $$locbase $sp                      ; [entry init: test_panic_without_arg]: set locals base register
cfei i16                                ; [entry init: test_panic_without_arg]: allocate: locals 16 byte(s), call args 0 slot(s)
.125
move $$arg0 $$locbase                   ; [call: encode_allow_alias_34]: pass argument 0
move $$arg1 $$locbase                   ; [call: encode_allow_alias_34]: pass argument 1
fncall .32                              ; [call: encode_allow_alias_34]: call function
 move $r488 $zero                        ; [call: encode_allow_alias_34]: copy returned unit value
 movi $r488 i0                           ; [call: encode_allow_alias_34]: copy returned unit value
load $r489 data_NonConfigurable_11      ; load constant from data section
lw $r490 $$locbase i0                   ; load slice pointer for logging data
lw $r491 $$locbase i1                   ; load slice size for logging data
logd $zero $r489 $r490 $r491            ; log slice
load $r492 data_NonConfigurable_18      ; load constant from data section
rvrt $r492
DIFF------------------------------
.program:
.46                                     ; --- start of function: test_panic_without_arg ---
move $$locbase $sp                      ; [entry init: test_panic_without_arg]: set locals base register
cfei i16                                ; [entry init: test_panic_without_arg]: allocate: locals 16 byte(s), call args 0 slot(s)
.125
move $$arg0 $$locbase                   ; [call: encode_allow_alias_34]: pass argument 0
move $$arg1 $$locbase                   ; [call: encode_allow_alias_34]: pass argument 1
fncall .32                              ; [call: encode_allow_alias_34]: call function
load $r489 data_NonConfigurable_11      ; load constant from data section
lw $r490 $$locbase i0                   ; load slice pointer for logging data
lw $r491 $$locbase i1                   ; load slice size for logging data
logd $zero $r489 $r490 $r491            ; log slice
load $r492 data_NonConfigurable_18      ; load constant from data section
rvrt $r492
DIFF------------------------------
.program:
.46                                     ; --- start of function: test_panic_without_arg ---
move $$locbase $sp                      ; [entry init: test_panic_without_arg]: set locals base register
cfei i16                                ; [entry init: test_panic_without_arg]: allocate: locals 16 byte(s), call args 0 slot(s)
.125
move $$arg0 $$locbase                   ; [call: encode_allow_alias_34]: pass argument 0
move $$arg1 $$locbase                   ; [call: encode_allow_alias_34]: pass argument 1
fncall .32                              ; [call: encode_allow_alias_34]: call function
load $r489 data_NonConfigurable_11      ; load constant from data section
lw $r490 $$locbase i0                   ; load slice pointer for logging data
lw $r491 $$locbase i1                   ; load slice size for logging data
logd $zero $r489 $r490 $r491            ; log slice
load $r492 data_NonConfigurable_18      ; load constant from data section
rvrt $r492
DIFF------------------------------
.program:
.46                                     ; --- start of function: test_panic_without_arg ---
move $$locbase $sp                      ; [entry init: test_panic_without_arg]: set locals base register
cfei i16                                ; [entry init: test_panic_without_arg]: allocate: locals 16 byte(s), call args 0 slot(s)
.125
move $$arg0 $$locbase                   ; [call: encode_allow_alias_34]: pass argument 0
move $$arg1 $$locbase                   ; [call: encode_allow_alias_34]: pass argument 1
fncall .32                              ; [call: encode_allow_alias_34]: call function
load $r489 data_NonConfigurable_11      ; load constant from data section
lw $r490 $$locbase i0                   ; load slice pointer for logging data
lw $r491 $$locbase i1                   ; load slice size for logging data
logd $zero $r489 $r490 $r491            ; log slice
load $r492 data_NonConfigurable_18      ; load constant from data section
rvrt $r492
DIFF------------------------------
.program:
.48                                     ; --- start of function: test_panic_with_unit ---
move $$locbase $sp                      ; [entry init: test_panic_with_unit]: set locals base register
cfei i16                                ; [entry init: test_panic_with_unit]: allocate: locals 16 byte(s), call args 0 slot(s)
.126
move $$arg0 $$locbase                   ; [call: encode_allow_alias_34]: pass argument 0
move $$arg1 $$locbase                   ; [call: encode_allow_alias_34]: pass argument 1
fncall .32                              ; [call: encode_allow_alias_34]: call function
 move $r494 $zero                        ; [call: encode_allow_alias_34]: copy returned unit value
 movi $r494 i0                           ; [call: encode_allow_alias_34]: copy returned unit value
load $r495 data_NonConfigurable_11      ; load constant from data section
lw $r496 $$locbase i0                   ; load slice pointer for logging data
lw $r497 $$locbase i1                   ; load slice size for logging data
logd $zero $r495 $r496 $r497            ; log slice
load $r498 data_NonConfigurable_19      ; load constant from data section
rvrt $r498
DIFF------------------------------
.program:
.48                                     ; --- start of function: test_panic_with_unit ---
move $$locbase $sp                      ; [entry init: test_panic_with_unit]: set locals base register
cfei i16                                ; [entry init: test_panic_with_unit]: allocate: locals 16 byte(s), call args 0 slot(s)
.126
move $$arg0 $$locbase                   ; [call: encode_allow_alias_34]: pass argument 0
move $$arg1 $$locbase                   ; [call: encode_allow_alias_34]: pass argument 1
fncall .32                              ; [call: encode_allow_alias_34]: call function
load $r495 data_NonConfigurable_11      ; load constant from data section
lw $r496 $$locbase i0                   ; load slice pointer for logging data
lw $r497 $$locbase i1                   ; load slice size for logging data
logd $zero $r495 $r496 $r497            ; log slice
load $r498 data_NonConfigurable_19      ; load constant from data section
rvrt $r498
DIFF------------------------------
.program:
.48                                     ; --- start of function: test_panic_with_unit ---
move $$locbase $sp                      ; [entry init: test_panic_with_unit]: set locals base register
cfei i16                                ; [entry init: test_panic_with_unit]: allocate: locals 16 byte(s), call args 0 slot(s)
.126
move $$arg0 $$locbase                   ; [call: encode_allow_alias_34]: pass argument 0
move $$arg1 $$locbase                   ; [call: encode_allow_alias_34]: pass argument 1
fncall .32                              ; [call: encode_allow_alias_34]: call function
load $r495 data_NonConfigurable_11      ; load constant from data section
lw $r496 $$locbase i0                   ; load slice pointer for logging data
lw $r497 $$locbase i1                   ; load slice size for logging data
logd $zero $r495 $r496 $r497            ; log slice
load $r498 data_NonConfigurable_19      ; load constant from data section
rvrt $r498
DIFF------------------------------
.program:
.48                                     ; --- start of function: test_panic_with_unit ---
move $$locbase $sp                      ; [entry init: test_panic_with_unit]: set locals base register
cfei i16                                ; [entry init: test_panic_with_unit]: allocate: locals 16 byte(s), call args 0 slot(s)
.126
move $$arg0 $$locbase                   ; [call: encode_allow_alias_34]: pass argument 0
move $$arg1 $$locbase                   ; [call: encode_allow_alias_34]: pass argument 1
fncall .32                              ; [call: encode_allow_alias_34]: call function
load $r495 data_NonConfigurable_11      ; load constant from data section
lw $r496 $$locbase i0                   ; load slice pointer for logging data
lw $r497 $$locbase i1                   ; load slice size for logging data
logd $zero $r495 $r496 $r497            ; log slice
load $r498 data_NonConfigurable_19      ; load constant from data section
rvrt $r498
DIFF------------------------------
.program:
.50                                     ; --- start of function: test_panic_with_str ---
move $$locbase $sp                      ; [entry init: test_panic_with_str]: set locals base register
cfei i0                                 ; [entry init: test_panic_with_str]: allocate: locals 0 byte(s), call args 0 slot(s)
.127
load $r500 data_NonConfigurable_20      ; load constant from data section
rvrt $r500
DIFF------------------------------
.program:
.50                                     ; --- start of function: test_panic_with_str ---
move $$locbase $sp                      ; [entry init: test_panic_with_str]: set locals base register
cfei i0                                 ; [entry init: test_panic_with_str]: allocate: locals 0 byte(s), call args 0 slot(s)
.127
load $r500 data_NonConfigurable_20      ; load constant from data section
rvrt $r500
DIFF------------------------------
.program:
.52                                     ; --- start of function: test_panic_with_error_type_enum ---
move $$locbase $sp                      ; [entry init: test_panic_with_error_type_enum]: set locals base register
cfei i72                                ; [entry init: test_panic_with_error_type_enum]: allocate: locals 72 byte(s), call args 0 slot(s)
.128
movi $r502 i2                           ; initialize constant into register
sw $$locbase $r502 i0                   ; store word
addi $r503 $$locbase i55                ; get offset to aggregate element
sb $r503 $one i0                        ; store byte
addi $r504 $$locbase i56                ; get offset to local __ptr slice
move $$arg0 $$locbase                   ; [call: encode_allow_alias_2]: pass argument 0
move $$arg1 $r504                       ; [call: encode_allow_alias_2]: pass argument 1
fncall .4                               ; [call: encode_allow_alias_2]: call function
 move $r505 $zero                        ; [call: encode_allow_alias_2]: copy returned unit value
 movi $r505 i0                           ; [call: encode_allow_alias_2]: copy returned unit value
addi $r506 $$locbase i56                ; get offset to local __ptr slice
load $r507 data_NonConfigurable_3       ; load constant from data section
lw $r508 $$locbase i7                   ; load slice pointer for logging data
lw $r509 $$locbase i8                   ; load slice size for logging data
logd $zero $r507 $r508 $r509            ; log slice
load $r510 data_NonConfigurable_21      ; load constant from data section
rvrt $r510
DIFF------------------------------
.program:
.52                                     ; --- start of function: test_panic_with_error_type_enum ---
move $$locbase $sp                      ; [entry init: test_panic_with_error_type_enum]: set locals base register
cfei i72                                ; [entry init: test_panic_with_error_type_enum]: allocate: locals 72 byte(s), call args 0 slot(s)
.128
movi $r502 i2                           ; initialize constant into register
sw $$locbase $r502 i0                   ; store word
addi $r503 $$locbase i55                ; get offset to aggregate element
sb $r503 $one i0                        ; store byte
addi $r504 $$locbase i56                ; get offset to local __ptr slice
move $$arg0 $$locbase                   ; [call: encode_allow_alias_2]: pass argument 0
move $$arg1 $r504                       ; [call: encode_allow_alias_2]: pass argument 1
fncall .4                               ; [call: encode_allow_alias_2]: call function
load $r507 data_NonConfigurable_3       ; load constant from data section
lw $r508 $$locbase i7                   ; load slice pointer for logging data
lw $r509 $$locbase i8                   ; load slice size for logging data
logd $zero $r507 $r508 $r509            ; log slice
load $r510 data_NonConfigurable_21      ; load constant from data section
rvrt $r510
DIFF------------------------------
.program:
.52                                     ; --- start of function: test_panic_with_error_type_enum ---
move $$locbase $sp                      ; [entry init: test_panic_with_error_type_enum]: set locals base register
cfei i72                                ; [entry init: test_panic_with_error_type_enum]: allocate: locals 72 byte(s), call args 0 slot(s)
.128
movi $r502 i2                           ; initialize constant into register
sw $$locbase $r502 i0                   ; store word
addi $r503 $$locbase i55                ; get offset to aggregate element
sb $r503 $one i0                        ; store byte
addi $r504 $$locbase i56                ; get offset to local __ptr slice
move $$arg0 $$locbase                   ; [call: encode_allow_alias_2]: pass argument 0
move $$arg1 $r504                       ; [call: encode_allow_alias_2]: pass argument 1
fncall .4                               ; [call: encode_allow_alias_2]: call function
load $r507 data_NonConfigurable_3       ; load constant from data section
lw $r508 $$locbase i7                   ; load slice pointer for logging data
lw $r509 $$locbase i8                   ; load slice size for logging data
logd $zero $r507 $r508 $r509            ; log slice
load $r510 data_NonConfigurable_21      ; load constant from data section
rvrt $r510
DIFF------------------------------
.program:
.52                                     ; --- start of function: test_panic_with_error_type_enum ---
move $$locbase $sp                      ; [entry init: test_panic_with_error_type_enum]: set locals base register
cfei i72                                ; [entry init: test_panic_with_error_type_enum]: allocate: locals 72 byte(s), call args 0 slot(s)
.128
movi $r502 i2                           ; initialize constant into register
sw $$locbase $r502 i0                   ; store word
addi $r503 $$locbase i55                ; get offset to aggregate element
sb $r503 $one i0                        ; store byte
addi $r504 $$locbase i56                ; get offset to local __ptr slice
move $$arg0 $$locbase                   ; [call: encode_allow_alias_2]: pass argument 0
move $$arg1 $r504                       ; [call: encode_allow_alias_2]: pass argument 1
fncall .4                               ; [call: encode_allow_alias_2]: call function
load $r507 data_NonConfigurable_3       ; load constant from data section
lw $r508 $$locbase i7                   ; load slice pointer for logging data
lw $r509 $$locbase i8                   ; load slice size for logging data
logd $zero $r507 $r508 $r509            ; log slice
load $r510 data_NonConfigurable_21      ; load constant from data section
rvrt $r510
DIFF------------------------------
.program:
.54                                     ; --- start of function: test_panic_with_generic_error_type_enum ---
move $$locbase $sp                      ; [entry init: test_panic_with_generic_error_type_enum]: set locals base register
cfei i32                                ; [entry init: test_panic_with_generic_error_type_enum]: allocate: locals 32 byte(s), call args 0 slot(s)
.129
sw $$locbase $zero i0                   ; store word
addi $r512 $$locbase i8                 ; get offset to aggregate element
movi $r513 i42                          ; initialize constant into register
sw $$locbase $r513 i1                   ; store word
addi $r514 $$locbase i16                ; get offset to local __ptr slice
move $$arg0 $$locbase                   ; [call: encode_allow_alias_50]: pass argument 0
move $$arg1 $r514                       ; [call: encode_allow_alias_50]: pass argument 1
fncall .62                              ; [call: encode_allow_alias_50]: call function
 move $r515 $zero                        ; [call: encode_allow_alias_50]: copy returned unit value
 movi $r515 i0                           ; [call: encode_allow_alias_50]: copy returned unit value
addi $r516 $$locbase i16                ; get offset to local __ptr slice
load $r517 data_NonConfigurable_22      ; load constant from data section
lw $r518 $$locbase i2                   ; load slice pointer for logging data
lw $r519 $$locbase i3                   ; load slice size for logging data
logd $zero $r517 $r518 $r519            ; log slice
load $r520 data_NonConfigurable_23      ; load constant from data section
rvrt $r520
DIFF------------------------------
.program:
.54                                     ; --- start of function: test_panic_with_generic_error_type_enum ---
move $$locbase $sp                      ; [entry init: test_panic_with_generic_error_type_enum]: set locals base register
cfei i32                                ; [entry init: test_panic_with_generic_error_type_enum]: allocate: locals 32 byte(s), call args 0 slot(s)
.129
sw $$locbase $zero i0                   ; store word
movi $r513 i42                          ; initialize constant into register
sw $$locbase $r513 i1                   ; store word
addi $r514 $$locbase i16                ; get offset to local __ptr slice
move $$arg0 $$locbase                   ; [call: encode_allow_alias_50]: pass argument 0
move $$arg1 $r514                       ; [call: encode_allow_alias_50]: pass argument 1
fncall .62                              ; [call: encode_allow_alias_50]: call function
load $r517 data_NonConfigurable_22      ; load constant from data section
lw $r518 $$locbase i2                   ; load slice pointer for logging data
lw $r519 $$locbase i3                   ; load slice size for logging data
logd $zero $r517 $r518 $r519            ; log slice
load $r520 data_NonConfigurable_23      ; load constant from data section
rvrt $r520
DIFF------------------------------
.program:
.54                                     ; --- start of function: test_panic_with_generic_error_type_enum ---
move $$locbase $sp                      ; [entry init: test_panic_with_generic_error_type_enum]: set locals base register
cfei i32                                ; [entry init: test_panic_with_generic_error_type_enum]: allocate: locals 32 byte(s), call args 0 slot(s)
.129
sw $$locbase $zero i0                   ; store word
movi $r513 i42                          ; initialize constant into register
sw $$locbase $r513 i1                   ; store word
addi $r514 $$locbase i16                ; get offset to local __ptr slice
move $$arg0 $$locbase                   ; [call: encode_allow_alias_50]: pass argument 0
move $$arg1 $r514                       ; [call: encode_allow_alias_50]: pass argument 1
fncall .62                              ; [call: encode_allow_alias_50]: call function
load $r517 data_NonConfigurable_22      ; load constant from data section
lw $r518 $$locbase i2                   ; load slice pointer for logging data
lw $r519 $$locbase i3                   ; load slice size for logging data
logd $zero $r517 $r518 $r519            ; log slice
load $r520 data_NonConfigurable_23      ; load constant from data section
rvrt $r520
DIFF------------------------------
.program:
.54                                     ; --- start of function: test_panic_with_generic_error_type_enum ---
move $$locbase $sp                      ; [entry init: test_panic_with_generic_error_type_enum]: set locals base register
cfei i32                                ; [entry init: test_panic_with_generic_error_type_enum]: allocate: locals 32 byte(s), call args 0 slot(s)
.129
sw $$locbase $zero i0                   ; store word
movi $r513 i42                          ; initialize constant into register
sw $$locbase $r513 i1                   ; store word
addi $r514 $$locbase i16                ; get offset to local __ptr slice
move $$arg0 $$locbase                   ; [call: encode_allow_alias_50]: pass argument 0
move $$arg1 $r514                       ; [call: encode_allow_alias_50]: pass argument 1
fncall .62                              ; [call: encode_allow_alias_50]: call function
load $r517 data_NonConfigurable_22      ; load constant from data section
lw $r518 $$locbase i2                   ; load slice pointer for logging data
lw $r519 $$locbase i3                   ; load slice size for logging data
logd $zero $r517 $r518 $r519            ; log slice
load $r520 data_NonConfigurable_23      ; load constant from data section
rvrt $r520
DIFF------------------------------
.program:
.56                                     ; --- start of function: test_panic_with_nested_generic_error_type ---
move $$locbase $sp                      ; [entry init: test_panic_with_nested_generic_error_type]: set locals base register
cfei i208                               ; [entry init: test_panic_with_nested_generic_error_type]: allocate: locals 208 byte(s), call args 0 slot(s)
.130
sw $$locbase $one i0                    ; store word
addi $r522 $$locbase i72                ; get offset to local __ptr { u64, ( bool | { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) } ) }
sw $$locbase $one i9                    ; store word
addi $r523 $$locbase i136               ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
movi $r524 i2                           ; initialize constant into register
sw $$locbase $r524 i17                  ; store word
addi $r525 $r523 i55                    ; get offset to aggregate element
sb $r525 $one i0                        ; store byte
addi $r526 $r522 i8                     ; get offset to aggregate element
mcpi $r526 $r523 i56                    ; copy memory
addi $r527 $$locbase i8                 ; get offset to aggregate element
mcpi $r527 $r522 i64                    ; copy memory
addi $r528 $$locbase i192               ; get offset to local __ptr slice
move $$arg0 $$locbase                   ; [call: encode_allow_alias_43]: pass argument 0
move $$arg1 $r528                       ; [call: encode_allow_alias_43]: pass argument 1
fncall .58                              ; [call: encode_allow_alias_43]: call function
 move $r529 $zero                        ; [call: encode_allow_alias_43]: copy returned unit value
 movi $r529 i0                           ; [call: encode_allow_alias_43]: copy returned unit value
addi $r530 $$locbase i192               ; get offset to local __ptr slice
load $r531 data_NonConfigurable_24      ; load constant from data section
lw $r532 $$locbase i24                  ; load slice pointer for logging data
lw $r533 $$locbase i25                  ; load slice size for logging data
logd $zero $r531 $r532 $r533            ; log slice
load $r534 data_NonConfigurable_25      ; load constant from data section
rvrt $r534
DIFF------------------------------
.program:
.56                                     ; --- start of function: test_panic_with_nested_generic_error_type ---
move $$locbase $sp                      ; [entry init: test_panic_with_nested_generic_error_type]: set locals base register
cfei i208                               ; [entry init: test_panic_with_nested_generic_error_type]: allocate: locals 208 byte(s), call args 0 slot(s)
.130
sw $$locbase $one i0                    ; store word
addi $r522 $$locbase i72                ; get offset to local __ptr { u64, ( bool | { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) } ) }
sw $$locbase $one i9                    ; store word
addi $r523 $$locbase i136               ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
movi $r524 i2                           ; initialize constant into register
sw $$locbase $r524 i17                  ; store word
addi $r525 $r523 i55                    ; get offset to aggregate element
sb $r525 $one i0                        ; store byte
addi $r526 $r522 i8                     ; get offset to aggregate element
mcpi $r526 $r523 i56                    ; copy memory
addi $r527 $$locbase i8                 ; get offset to aggregate element
mcpi $r527 $r522 i64                    ; copy memory
addi $r528 $$locbase i192               ; get offset to local __ptr slice
move $$arg0 $$locbase                   ; [call: encode_allow_alias_43]: pass argument 0
move $$arg1 $r528                       ; [call: encode_allow_alias_43]: pass argument 1
fncall .58                              ; [call: encode_allow_alias_43]: call function
load $r531 data_NonConfigurable_24      ; load constant from data section
lw $r532 $$locbase i24                  ; load slice pointer for logging data
lw $r533 $$locbase i25                  ; load slice size for logging data
logd $zero $r531 $r532 $r533            ; log slice
load $r534 data_NonConfigurable_25      ; load constant from data section
rvrt $r534
DIFF------------------------------
.program:
.56                                     ; --- start of function: test_panic_with_nested_generic_error_type ---
move $$locbase $sp                      ; [entry init: test_panic_with_nested_generic_error_type]: set locals base register
cfei i208                               ; [entry init: test_panic_with_nested_generic_error_type]: allocate: locals 208 byte(s), call args 0 slot(s)
.130
sw $$locbase $one i0                    ; store word
addi $r522 $$locbase i72                ; get offset to local __ptr { u64, ( bool | { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) } ) }
sw $$locbase $one i9                    ; store word
addi $r523 $$locbase i136               ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
movi $r524 i2                           ; initialize constant into register
sw $$locbase $r524 i17                  ; store word
addi $r525 $r523 i55                    ; get offset to aggregate element
sb $r525 $one i0                        ; store byte
addi $r526 $r522 i8                     ; get offset to aggregate element
mcpi $r526 $r523 i56                    ; copy memory
addi $r527 $$locbase i8                 ; get offset to aggregate element
mcpi $r527 $r522 i64                    ; copy memory
addi $r528 $$locbase i192               ; get offset to local __ptr slice
move $$arg0 $$locbase                   ; [call: encode_allow_alias_43]: pass argument 0
move $$arg1 $r528                       ; [call: encode_allow_alias_43]: pass argument 1
fncall .58                              ; [call: encode_allow_alias_43]: call function
load $r531 data_NonConfigurable_24      ; load constant from data section
lw $r532 $$locbase i24                  ; load slice pointer for logging data
lw $r533 $$locbase i25                  ; load slice size for logging data
logd $zero $r531 $r532 $r533            ; log slice
load $r534 data_NonConfigurable_25      ; load constant from data section
rvrt $r534
DIFF------------------------------
.program:
.56                                     ; --- start of function: test_panic_with_nested_generic_error_type ---
move $$locbase $sp                      ; [entry init: test_panic_with_nested_generic_error_type]: set locals base register
cfei i208                               ; [entry init: test_panic_with_nested_generic_error_type]: allocate: locals 208 byte(s), call args 0 slot(s)
.130
sw $$locbase $one i0                    ; store word
addi $r522 $$locbase i72                ; get offset to local __ptr { u64, ( bool | { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) } ) }
sw $$locbase $one i9                    ; store word
addi $r523 $$locbase i136               ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
movi $r524 i2                           ; initialize constant into register
sw $$locbase $r524 i17                  ; store word
addi $r525 $r523 i55                    ; get offset to aggregate element
sb $r525 $one i0                        ; store byte
addi $r526 $r522 i8                     ; get offset to aggregate element
mcpi $r526 $r523 i56                    ; copy memory
addi $r527 $$locbase i8                 ; get offset to aggregate element
mcpi $r527 $r522 i64                    ; copy memory
addi $r528 $$locbase i192               ; get offset to local __ptr slice
move $$arg0 $$locbase                   ; [call: encode_allow_alias_43]: pass argument 0
move $$arg1 $r528                       ; [call: encode_allow_alias_43]: pass argument 1
fncall .58                              ; [call: encode_allow_alias_43]: call function
load $r531 data_NonConfigurable_24      ; load constant from data section
lw $r532 $$locbase i24                  ; load slice pointer for logging data
lw $r533 $$locbase i25                  ; load slice size for logging data
logd $zero $r531 $r532 $r533            ; log slice
load $r534 data_NonConfigurable_25      ; load constant from data section
rvrt $r534
DIFF------------------------------
.program:
.60                                     ; --- start of function: test_panic_with_generic_error_type_enum_with_abi_encode ---
move $$locbase $sp                      ; [entry init: test_panic_with_generic_error_type_enum_with_abi_encode]: set locals base register
cfei i32                                ; [entry init: test_panic_with_generic_error_type_enum_with_abi_encode]: allocate: locals 32 byte(s), call args 0 slot(s)
.145
sw $$locbase $zero i0                   ; store word
addi $r597 $$locbase i8                 ; get offset to aggregate element
movi $r598 i42                          ; initialize constant into register
sw $$locbase $r598 i1                   ; store word
addi $r599 $$locbase i16                ; get offset to local __ptr slice
move $$arg0 $$locbase                   ; [call: encode_allow_alias_50]: pass argument 0
move $$arg1 $r599                       ; [call: encode_allow_alias_50]: pass argument 1
fncall .62                              ; [call: encode_allow_alias_50]: call function
 move $r600 $zero                        ; [call: encode_allow_alias_50]: copy returned unit value
 movi $r600 i0                           ; [call: encode_allow_alias_50]: copy returned unit value
addi $r601 $$locbase i16                ; get offset to local __ptr slice
load $r602 data_NonConfigurable_26      ; load constant from data section
lw $r603 $$locbase i2                   ; load slice pointer for logging data
lw $r604 $$locbase i3                   ; load slice size for logging data
logd $zero $r602 $r603 $r604            ; log slice
load $r605 data_NonConfigurable_27      ; load constant from data section
rvrt $r605
DIFF------------------------------
.program:
.60                                     ; --- start of function: test_panic_with_generic_error_type_enum_with_abi_encode ---
move $$locbase $sp                      ; [entry init: test_panic_with_generic_error_type_enum_with_abi_encode]: set locals base register
cfei i32                                ; [entry init: test_panic_with_generic_error_type_enum_with_abi_encode]: allocate: locals 32 byte(s), call args 0 slot(s)
.145
sw $$locbase $zero i0                   ; store word
movi $r598 i42                          ; initialize constant into register
sw $$locbase $r598 i1                   ; store word
addi $r599 $$locbase i16                ; get offset to local __ptr slice
move $$arg0 $$locbase                   ; [call: encode_allow_alias_50]: pass argument 0
move $$arg1 $r599                       ; [call: encode_allow_alias_50]: pass argument 1
fncall .62                              ; [call: encode_allow_alias_50]: call function
load $r602 data_NonConfigurable_26      ; load constant from data section
lw $r603 $$locbase i2                   ; load slice pointer for logging data
lw $r604 $$locbase i3                   ; load slice size for logging data
logd $zero $r602 $r603 $r604            ; log slice
load $r605 data_NonConfigurable_27      ; load constant from data section
rvrt $r605
DIFF------------------------------
.program:
.60                                     ; --- start of function: test_panic_with_generic_error_type_enum_with_abi_encode ---
move $$locbase $sp                      ; [entry init: test_panic_with_generic_error_type_enum_with_abi_encode]: set locals base register
cfei i32                                ; [entry init: test_panic_with_generic_error_type_enum_with_abi_encode]: allocate: locals 32 byte(s), call args 0 slot(s)
.145
sw $$locbase $zero i0                   ; store word
movi $r598 i42                          ; initialize constant into register
sw $$locbase $r598 i1                   ; store word
addi $r599 $$locbase i16                ; get offset to local __ptr slice
move $$arg0 $$locbase                   ; [call: encode_allow_alias_50]: pass argument 0
move $$arg1 $r599                       ; [call: encode_allow_alias_50]: pass argument 1
fncall .62                              ; [call: encode_allow_alias_50]: call function
load $r602 data_NonConfigurable_26      ; load constant from data section
lw $r603 $$locbase i2                   ; load slice pointer for logging data
lw $r604 $$locbase i3                   ; load slice size for logging data
logd $zero $r602 $r603 $r604            ; log slice
load $r605 data_NonConfigurable_27      ; load constant from data section
rvrt $r605
DIFF------------------------------
.program:
.60                                     ; --- start of function: test_panic_with_generic_error_type_enum_with_abi_encode ---
move $$locbase $sp                      ; [entry init: test_panic_with_generic_error_type_enum_with_abi_encode]: set locals base register
cfei i32                                ; [entry init: test_panic_with_generic_error_type_enum_with_abi_encode]: allocate: locals 32 byte(s), call args 0 slot(s)
.145
sw $$locbase $zero i0                   ; store word
movi $r598 i42                          ; initialize constant into register
sw $$locbase $r598 i1                   ; store word
addi $r599 $$locbase i16                ; get offset to local __ptr slice
move $$arg0 $$locbase                   ; [call: encode_allow_alias_50]: pass argument 0
move $$arg1 $r599                       ; [call: encode_allow_alias_50]: pass argument 1
fncall .62                              ; [call: encode_allow_alias_50]: call function
load $r602 data_NonConfigurable_26      ; load constant from data section
lw $r603 $$locbase i2                   ; load slice pointer for logging data
lw $r604 $$locbase i3                   ; load slice size for logging data
logd $zero $r602 $r603 $r604            ; log slice
load $r605 data_NonConfigurable_27      ; load constant from data section
rvrt $r605
DIFF------------------------------
.program:
.64                                     ; --- start of function: test_panic_with_nested_generic_error_type_enum_with_abi_encode ---
move $$locbase $sp                      ; [entry init: test_panic_with_nested_generic_error_type_enum_with_abi_encode]: set locals base register
cfei i208                               ; [entry init: test_panic_with_nested_generic_error_type_enum_with_abi_encode]: allocate: locals 208 byte(s), call args 0 slot(s)
.155
sw $$locbase $one i0                    ; store word
addi $r647 $$locbase i72                ; get offset to local __ptr { u64, ( bool | { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) } ) }
sw $$locbase $one i9                    ; store word
addi $r648 $$locbase i136               ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
movi $r649 i2                           ; initialize constant into register
sw $$locbase $r649 i17                  ; store word
addi $r650 $r648 i55                    ; get offset to aggregate element
sb $r650 $one i0                        ; store byte
addi $r651 $r647 i8                     ; get offset to aggregate element
mcpi $r651 $r648 i56                    ; copy memory
addi $r652 $$locbase i8                 ; get offset to aggregate element
mcpi $r652 $r647 i64                    ; copy memory
addi $r653 $$locbase i192               ; get offset to local __ptr slice
move $$arg0 $$locbase                   ; [call: encode_allow_alias_43]: pass argument 0
move $$arg1 $r653                       ; [call: encode_allow_alias_43]: pass argument 1
fncall .58                              ; [call: encode_allow_alias_43]: call function
 move $r654 $zero                        ; [call: encode_allow_alias_43]: copy returned unit value
 movi $r654 i0                           ; [call: encode_allow_alias_43]: copy returned unit value
addi $r655 $$locbase i192               ; get offset to local __ptr slice
load $r656 data_NonConfigurable_28      ; load constant from data section
lw $r657 $$locbase i24                  ; load slice pointer for logging data
lw $r658 $$locbase i25                  ; load slice size for logging data
logd $zero $r656 $r657 $r658            ; log slice
load $r659 data_NonConfigurable_29      ; load constant from data section
rvrt $r659
DIFF------------------------------
.program:
.64                                     ; --- start of function: test_panic_with_nested_generic_error_type_enum_with_abi_encode ---
move $$locbase $sp                      ; [entry init: test_panic_with_nested_generic_error_type_enum_with_abi_encode]: set locals base register
cfei i208                               ; [entry init: test_panic_with_nested_generic_error_type_enum_with_abi_encode]: allocate: locals 208 byte(s), call args 0 slot(s)
.155
sw $$locbase $one i0                    ; store word
addi $r647 $$locbase i72                ; get offset to local __ptr { u64, ( bool | { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) } ) }
sw $$locbase $one i9                    ; store word
addi $r648 $$locbase i136               ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
movi $r649 i2                           ; initialize constant into register
sw $$locbase $r649 i17                  ; store word
addi $r650 $r648 i55                    ; get offset to aggregate element
sb $r650 $one i0                        ; store byte
addi $r651 $r647 i8                     ; get offset to aggregate element
mcpi $r651 $r648 i56                    ; copy memory
addi $r652 $$locbase i8                 ; get offset to aggregate element
mcpi $r652 $r647 i64                    ; copy memory
addi $r653 $$locbase i192               ; get offset to local __ptr slice
move $$arg0 $$locbase                   ; [call: encode_allow_alias_43]: pass argument 0
move $$arg1 $r653                       ; [call: encode_allow_alias_43]: pass argument 1
fncall .58                              ; [call: encode_allow_alias_43]: call function
load $r656 data_NonConfigurable_28      ; load constant from data section
lw $r657 $$locbase i24                  ; load slice pointer for logging data
lw $r658 $$locbase i25                  ; load slice size for logging data
logd $zero $r656 $r657 $r658            ; log slice
load $r659 data_NonConfigurable_29      ; load constant from data section
rvrt $r659
DIFF------------------------------
.program:
.64                                     ; --- start of function: test_panic_with_nested_generic_error_type_enum_with_abi_encode ---
move $$locbase $sp                      ; [entry init: test_panic_with_nested_generic_error_type_enum_with_abi_encode]: set locals base register
cfei i208                               ; [entry init: test_panic_with_nested_generic_error_type_enum_with_abi_encode]: allocate: locals 208 byte(s), call args 0 slot(s)
.155
sw $$locbase $one i0                    ; store word
addi $r647 $$locbase i72                ; get offset to local __ptr { u64, ( bool | { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) } ) }
sw $$locbase $one i9                    ; store word
addi $r648 $$locbase i136               ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
movi $r649 i2                           ; initialize constant into register
sw $$locbase $r649 i17                  ; store word
addi $r650 $r648 i55                    ; get offset to aggregate element
sb $r650 $one i0                        ; store byte
addi $r651 $r647 i8                     ; get offset to aggregate element
mcpi $r651 $r648 i56                    ; copy memory
addi $r652 $$locbase i8                 ; get offset to aggregate element
mcpi $r652 $r647 i64                    ; copy memory
addi $r653 $$locbase i192               ; get offset to local __ptr slice
move $$arg0 $$locbase                   ; [call: encode_allow_alias_43]: pass argument 0
move $$arg1 $r653                       ; [call: encode_allow_alias_43]: pass argument 1
fncall .58                              ; [call: encode_allow_alias_43]: call function
load $r656 data_NonConfigurable_28      ; load constant from data section
lw $r657 $$locbase i24                  ; load slice pointer for logging data
lw $r658 $$locbase i25                  ; load slice size for logging data
logd $zero $r656 $r657 $r658            ; log slice
load $r659 data_NonConfigurable_29      ; load constant from data section
rvrt $r659
DIFF------------------------------
.program:
.64                                     ; --- start of function: test_panic_with_nested_generic_error_type_enum_with_abi_encode ---
move $$locbase $sp                      ; [entry init: test_panic_with_nested_generic_error_type_enum_with_abi_encode]: set locals base register
cfei i208                               ; [entry init: test_panic_with_nested_generic_error_type_enum_with_abi_encode]: allocate: locals 208 byte(s), call args 0 slot(s)
.155
sw $$locbase $one i0                    ; store word
addi $r647 $$locbase i72                ; get offset to local __ptr { u64, ( bool | { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) } ) }
sw $$locbase $one i9                    ; store word
addi $r648 $$locbase i136               ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
movi $r649 i2                           ; initialize constant into register
sw $$locbase $r649 i17                  ; store word
addi $r650 $r648 i55                    ; get offset to aggregate element
sb $r650 $one i0                        ; store byte
addi $r651 $r647 i8                     ; get offset to aggregate element
mcpi $r651 $r648 i56                    ; copy memory
addi $r652 $$locbase i8                 ; get offset to aggregate element
mcpi $r652 $r647 i64                    ; copy memory
addi $r653 $$locbase i192               ; get offset to local __ptr slice
move $$arg0 $$locbase                   ; [call: encode_allow_alias_43]: pass argument 0
move $$arg1 $r653                       ; [call: encode_allow_alias_43]: pass argument 1
fncall .58                              ; [call: encode_allow_alias_43]: call function
load $r656 data_NonConfigurable_28      ; load constant from data section
lw $r657 $$locbase i24                  ; load slice pointer for logging data
lw $r658 $$locbase i25                  ; load slice size for logging data
logd $zero $r656 $r657 $r658            ; log slice
load $r659 data_NonConfigurable_29      ; load constant from data section
rvrt $r659
DIFF------------------------------
.program:
.2                                      ; --- start of function: call_nested_panic_inlined_0 ---
pusha .2                                ; [fn init: call_nested_panic_inlined_0]: push all used registers to stack
move $$locbase $sp                      ; [fn init: call_nested_panic_inlined_0]: set locals base register
cfei i216                               ; [fn init: call_nested_panic_inlined_0]: allocate: locals 216 byte(s), call args 0 slot(s)
move $r2 $$arg0                         ; [fn init: call_nested_panic_inlined_0]: copy argument 0 (__backtrace)
move $r3 $$reta                         ; [fn init: call_nested_panic_inlined_0]: save return address
.67
addi $r4 $$locbase i160                 ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
movi $r5 i4                             ; initialize constant into register
sw $$locbase $r5 i20                    ; store word
addi $r6 $$locbase i96                  ; get offset to local __ptr [slice; 3]
addr $r7 data_NonConfigurable_0         ; get __const_global's address in data section
sw $$locbase $r7 i0                     ; store word
addi $r8 $$locbase i8                   ; get offset to aggregate element
movi $r9 i7                             ; initialize constant into register
sw $$locbase $r9 i1                     ; store word
addi $r10 $$locbase i16                 ; get offset to local __ptr slice
mcpi $r10 $$locbase i16                 ; copy memory
addr $r11 data_NonConfigurable_1        ; get __const_global0's address in data section
addi $r12 $$locbase i32                 ; get offset to local __ptr { ptr, u64 }
sw $$locbase $r11 i4                    ; store word
addi $r13 $r12 i8                       ; get offset to aggregate element
movi $r14 i7                            ; initialize constant into register
sw $$locbase $r14 i5                    ; store word
addi $r15 $$locbase i48                 ; get offset to local __ptr slice
mcpi $r15 $r12 i16                      ; copy memory
addr $r16 data_NonConfigurable_2        ; get __const_global1's address in data section
addi $r17 $$locbase i64                 ; get offset to local __ptr { ptr, u64 }
sw $$locbase $r16 i8                    ; store word
addi $r18 $r17 i8                       ; get offset to aggregate element
movi $r19 i22                           ; initialize constant into register
sw $$locbase $r19 i9                    ; store word
addi $r20 $$locbase i80                 ; get offset to local __ptr slice
mcpi $r20 $r17 i16                      ; copy memory
movi $r21 i16                           ; get array element size
 mul $r22 $zero $r21                     ; get offset to array element
 add $r22 $r6 $r22                       ; add array element offset to array base
 mcpi $r22 $r10 i16                      ; copy memory
 movi $r22 i0                            ; get offset to array element
 move $r22 $r6                           ; add array element offset to array base
 mcpi $r6 $r10 i16                       ; copy memory
movi $r23 i16                           ; get array element size
 mul $r24 $one $r23                      ; get offset to array element
 add $r24 $r6 $r24                       ; add array element offset to array base
 movi $r24 i16                           ; get offset to array element
 addi $r24 $r6 i16                       ; add array element offset to array base
mcpi $r24 $r15 i16                      ; copy memory
movi $r25 i16                           ; get array element size
movi $r26 i2                            ; initialize constant into register
 mul $r27 $r26 $r25                      ; get offset to array element
 add $r27 $r6 $r27                       ; add array element offset to array base
 movi $r27 i32                           ; get offset to array element
 addi $r27 $r6 i32                       ; add array element offset to array base
mcpi $r27 $r20 i16                      ; copy memory
addi $r28 $r4 i8                        ; get offset to aggregate element
mcpi $r28 $r6 i48                       ; copy memory
addi $r29 $$locbase i160                ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
addi $r30 $$locbase i144                ; get offset to local __ptr slice
move $$arg0 $r29                        ; [call: encode_allow_alias_2]: pass argument 0
move $$arg1 $r30                        ; [call: encode_allow_alias_2]: pass argument 1
fncall .4                               ; [call: encode_allow_alias_2]: call function
 move $r31 $zero                         ; [call: encode_allow_alias_2]: copy returned unit value
 movi $r31 i0                            ; [call: encode_allow_alias_2]: copy returned unit value
addi $r32 $$locbase i144                ; get offset to local __ptr slice
load $r33 data_NonConfigurable_3        ; load constant from data section
lw $r34 $$locbase i18                   ; load slice pointer for logging data
lw $r35 $$locbase i19                   ; load slice size for logging data
logd $zero $r33 $r34 $r35               ; log slice
load $r36 data_NonConfigurable_4        ; load constant from data section
and $r37 $r2 $r36
load $r38 data_NonConfigurable_5        ; load constant from data section
or $r39 $r38 $r37
rvrt $r39
.3
cfsi i216                               ; [fn end: call_nested_panic_inlined_0] free: locals 216 byte(s), call args 0 slot(s)
move $$reta $r3                         ; [fn end: call_nested_panic_inlined_0] restore return address
popa .2                                 ; [fn end: call_nested_panic_inlined_0] restore all used registers
jal $zero $$reta i0                     ; [fn end: call_nested_panic_inlined_0] return from call
DIFF------------------------------
.program:
.2                                      ; --- start of function: call_nested_panic_inlined_0 ---
pusha .2                                ; [fn init: call_nested_panic_inlined_0]: push all used registers to stack
move $$locbase $sp                      ; [fn init: call_nested_panic_inlined_0]: set locals base register
cfei i216                               ; [fn init: call_nested_panic_inlined_0]: allocate: locals 216 byte(s), call args 0 slot(s)
move $r2 $$arg0                         ; [fn init: call_nested_panic_inlined_0]: copy argument 0 (__backtrace)
.67
addi $r4 $$locbase i160                 ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
movi $r5 i4                             ; initialize constant into register
sw $$locbase $r5 i20                    ; store word
addi $r6 $$locbase i96                  ; get offset to local __ptr [slice; 3]
addr $r7 data_NonConfigurable_0         ; get __const_global's address in data section
sw $$locbase $r7 i0                     ; store word
movi $r9 i7                             ; initialize constant into register
sw $$locbase $r9 i1                     ; store word
addi $r10 $$locbase i16                 ; get offset to local __ptr slice
mcpi $r10 $$locbase i16                 ; copy memory
addr $r11 data_NonConfigurable_1        ; get __const_global0's address in data section
addi $r12 $$locbase i32                 ; get offset to local __ptr { ptr, u64 }
sw $$locbase $r11 i4                    ; store word
movi $r14 i7                            ; initialize constant into register
sw $$locbase $r14 i5                    ; store word
addi $r15 $$locbase i48                 ; get offset to local __ptr slice
mcpi $r15 $r12 i16                      ; copy memory
addr $r16 data_NonConfigurable_2        ; get __const_global1's address in data section
addi $r17 $$locbase i64                 ; get offset to local __ptr { ptr, u64 }
sw $$locbase $r16 i8                    ; store word
movi $r19 i22                           ; initialize constant into register
sw $$locbase $r19 i9                    ; store word
addi $r20 $$locbase i80                 ; get offset to local __ptr slice
mcpi $r20 $r17 i16                      ; copy memory
mcpi $r6 $r10 i16                       ; copy memory
addi $r24 $r6 i16                       ; add array element offset to array base
mcpi $r24 $r15 i16                      ; copy memory
addi $r27 $r6 i32                       ; add array element offset to array base
mcpi $r27 $r20 i16                      ; copy memory
addi $r28 $r4 i8                        ; get offset to aggregate element
mcpi $r28 $r6 i48                       ; copy memory
addi $r29 $$locbase i160                ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
addi $r30 $$locbase i144                ; get offset to local __ptr slice
move $$arg0 $r29                        ; [call: encode_allow_alias_2]: pass argument 0
move $$arg1 $r30                        ; [call: encode_allow_alias_2]: pass argument 1
fncall .4                               ; [call: encode_allow_alias_2]: call function
load $r33 data_NonConfigurable_3        ; load constant from data section
lw $r34 $$locbase i18                   ; load slice pointer for logging data
lw $r35 $$locbase i19                   ; load slice size for logging data
logd $zero $r33 $r34 $r35               ; log slice
load $r36 data_NonConfigurable_4        ; load constant from data section
and $r37 $r2 $r36
load $r38 data_NonConfigurable_5        ; load constant from data section
or $r39 $r38 $r37
rvrt $r39
DIFF------------------------------
.program:
.2                                      ; --- start of function: call_nested_panic_inlined_0 ---
pusha .2                                ; [fn init: call_nested_panic_inlined_0]: push all used registers to stack
move $$locbase $sp                      ; [fn init: call_nested_panic_inlined_0]: set locals base register
cfei i216                               ; [fn init: call_nested_panic_inlined_0]: allocate: locals 216 byte(s), call args 0 slot(s)
move $r2 $$arg0                         ; [fn init: call_nested_panic_inlined_0]: copy argument 0 (__backtrace)
.67
addi $r4 $$locbase i160                 ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
movi $r5 i4                             ; initialize constant into register
sw $$locbase $r5 i20                    ; store word
addi $r6 $$locbase i96                  ; get offset to local __ptr [slice; 3]
addr $r7 data_NonConfigurable_0         ; get __const_global's address in data section
sw $$locbase $r7 i0                     ; store word
movi $r9 i7                             ; initialize constant into register
sw $$locbase $r9 i1                     ; store word
addi $r10 $$locbase i16                 ; get offset to local __ptr slice
mcpi $r10 $$locbase i16                 ; copy memory
addr $r11 data_NonConfigurable_1        ; get __const_global0's address in data section
addi $r12 $$locbase i32                 ; get offset to local __ptr { ptr, u64 }
sw $$locbase $r11 i4                    ; store word
movi $r14 i7                            ; initialize constant into register
sw $$locbase $r14 i5                    ; store word
addi $r15 $$locbase i48                 ; get offset to local __ptr slice
mcpi $r15 $r12 i16                      ; copy memory
addr $r16 data_NonConfigurable_2        ; get __const_global1's address in data section
addi $r17 $$locbase i64                 ; get offset to local __ptr { ptr, u64 }
sw $$locbase $r16 i8                    ; store word
movi $r19 i22                           ; initialize constant into register
sw $$locbase $r19 i9                    ; store word
addi $r20 $$locbase i80                 ; get offset to local __ptr slice
mcpi $r20 $r17 i16                      ; copy memory
mcpi $r6 $r10 i16                       ; copy memory
addi $r24 $r6 i16                       ; add array element offset to array base
mcpi $r24 $r15 i16                      ; copy memory
addi $r27 $r6 i32                       ; add array element offset to array base
mcpi $r27 $r20 i16                      ; copy memory
addi $r28 $r4 i8                        ; get offset to aggregate element
mcpi $r28 $r6 i48                       ; copy memory
addi $r29 $$locbase i160                ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
addi $r30 $$locbase i144                ; get offset to local __ptr slice
move $$arg0 $r29                        ; [call: encode_allow_alias_2]: pass argument 0
move $$arg1 $r30                        ; [call: encode_allow_alias_2]: pass argument 1
fncall .4                               ; [call: encode_allow_alias_2]: call function
load $r33 data_NonConfigurable_3        ; load constant from data section
lw $r34 $$locbase i18                   ; load slice pointer for logging data
lw $r35 $$locbase i19                   ; load slice size for logging data
logd $zero $r33 $r34 $r35               ; log slice
load $r36 data_NonConfigurable_4        ; load constant from data section
and $r37 $r2 $r36
load $r38 data_NonConfigurable_5        ; load constant from data section
or $r39 $r38 $r37
rvrt $r39
DIFF------------------------------
.program:
.2                                      ; --- start of function: call_nested_panic_inlined_0 ---
pusha .2                                ; [fn init: call_nested_panic_inlined_0]: push all used registers to stack
move $$locbase $sp                      ; [fn init: call_nested_panic_inlined_0]: set locals base register
cfei i216                               ; [fn init: call_nested_panic_inlined_0]: allocate: locals 216 byte(s), call args 0 slot(s)
move $r2 $$arg0                         ; [fn init: call_nested_panic_inlined_0]: copy argument 0 (__backtrace)
.67
addi $r4 $$locbase i160                 ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
movi $r5 i4                             ; initialize constant into register
sw $$locbase $r5 i20                    ; store word
addi $r6 $$locbase i96                  ; get offset to local __ptr [slice; 3]
addr $r7 data_NonConfigurable_0         ; get __const_global's address in data section
sw $$locbase $r7 i0                     ; store word
movi $r9 i7                             ; initialize constant into register
sw $$locbase $r9 i1                     ; store word
addi $r10 $$locbase i16                 ; get offset to local __ptr slice
mcpi $r10 $$locbase i16                 ; copy memory
addr $r11 data_NonConfigurable_1        ; get __const_global0's address in data section
addi $r12 $$locbase i32                 ; get offset to local __ptr { ptr, u64 }
sw $$locbase $r11 i4                    ; store word
movi $r14 i7                            ; initialize constant into register
sw $$locbase $r14 i5                    ; store word
addi $r15 $$locbase i48                 ; get offset to local __ptr slice
mcpi $r15 $r12 i16                      ; copy memory
addr $r16 data_NonConfigurable_2        ; get __const_global1's address in data section
addi $r17 $$locbase i64                 ; get offset to local __ptr { ptr, u64 }
sw $$locbase $r16 i8                    ; store word
movi $r19 i22                           ; initialize constant into register
sw $$locbase $r19 i9                    ; store word
addi $r20 $$locbase i80                 ; get offset to local __ptr slice
mcpi $r20 $r17 i16                      ; copy memory
mcpi $r6 $r10 i16                       ; copy memory
addi $r24 $r6 i16                       ; add array element offset to array base
mcpi $r24 $r15 i16                      ; copy memory
addi $r27 $r6 i32                       ; add array element offset to array base
mcpi $r27 $r20 i16                      ; copy memory
addi $r28 $r4 i8                        ; get offset to aggregate element
mcpi $r28 $r6 i48                       ; copy memory
addi $r29 $$locbase i160                ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
addi $r30 $$locbase i144                ; get offset to local __ptr slice
move $$arg0 $r29                        ; [call: encode_allow_alias_2]: pass argument 0
move $$arg1 $r30                        ; [call: encode_allow_alias_2]: pass argument 1
fncall .4                               ; [call: encode_allow_alias_2]: call function
load $r33 data_NonConfigurable_3        ; load constant from data section
lw $r34 $$locbase i18                   ; load slice pointer for logging data
lw $r35 $$locbase i19                   ; load slice size for logging data
logd $zero $r33 $r34 $r35               ; log slice
load $r36 data_NonConfigurable_4        ; load constant from data section
and $r37 $r2 $r36
load $r38 data_NonConfigurable_5        ; load constant from data section
or $r39 $r38 $r37
rvrt $r39
DIFF------------------------------
.program:
.4                                      ; --- start of function: encode_allow_alias_2 ---
pusha .4                                ; [fn init: encode_allow_alias_2]: push all used registers to stack
move $$locbase $sp                      ; [fn init: encode_allow_alias_2]: set locals base register
cfei i120                               ; [fn init: encode_allow_alias_2]: allocate: locals 120 byte(s), call args 0 slot(s)
move $r40 $$arg0                        ; [fn init: encode_allow_alias_2]: copy argument 0 (item)
move $r41 $$arg1                        ; [fn init: encode_allow_alias_2]: copy argument 1 (__ret_value)
move $r42 $$reta                        ; [fn init: encode_allow_alias_2]: save return address
.68
fncall .6                               ; [call: is_encode_trivial_3]: call function
move $r43 $$retv                        ; [call: is_encode_trivial_3]: copy returned value
 jnzi $r43 .69
 jnzi $$retv .69
ji  .70
.70
addi $r44 $$locbase i72                 ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r44                        ; [call: new_29]: pass argument 0
fncall .16                              ; [call: new_29]: call function
 move $r45 $zero                         ; [call: new_29]: copy returned unit value
 movi $r45 i0                            ; [call: new_29]: copy returned unit value
addi $r46 $$locbase i16                 ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
mcpi $r46 $r40 i56                      ; copy memory
addi $r47 $$locbase i72                 ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r48 $$locbase i96                 ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r46                        ; [call: abi_encode_20]: pass argument 0
move $$arg1 $r47                        ; [call: abi_encode_20]: pass argument 1
move $$arg2 $r48                        ; [call: abi_encode_20]: pass argument 2
fncall .8                               ; [call: abi_encode_20]: call function
 move $r49 $zero                         ; [call: abi_encode_20]: copy returned unit value
 movi $r49 i0                            ; [call: abi_encode_20]: copy returned unit value
addi $r50 $$locbase i96                 ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r50                        ; [call: as_raw_slice_30]: pass argument 0
move $$arg1 $r41                        ; [call: as_raw_slice_30]: pass argument 1
fncall .18                              ; [call: as_raw_slice_30]: call function
 move $r51 $zero                         ; [call: as_raw_slice_30]: copy returned unit value
 movi $r51 i0                            ; [call: as_raw_slice_30]: copy returned unit value
ji  .71
.69
sw $$locbase $r40 i0                    ; store word
addi $r52 $$locbase i8                  ; get offset to aggregate element
movi $r53 i56                           ; initialize constant into register
sw $$locbase $r53 i1                    ; store word
mcpi $r41 $$locbase i16                 ; copy memory
ji  .71
.71
ji  .5
.5
cfsi i120                               ; [fn end: encode_allow_alias_2] free: locals 120 byte(s), call args 0 slot(s)
move $$reta $r42                        ; [fn end: encode_allow_alias_2] restore return address
popa .4                                 ; [fn end: encode_allow_alias_2] restore all used registers
jal $zero $$reta i0                     ; [fn end: encode_allow_alias_2] return from call
DIFF------------------------------
.program:
.4                                      ; --- start of function: encode_allow_alias_2 ---
pusha .4                                ; [fn init: encode_allow_alias_2]: push all used registers to stack
move $$locbase $sp                      ; [fn init: encode_allow_alias_2]: set locals base register
cfei i120                               ; [fn init: encode_allow_alias_2]: allocate: locals 120 byte(s), call args 0 slot(s)
move $r40 $$arg0                        ; [fn init: encode_allow_alias_2]: copy argument 0 (item)
move $r41 $$arg1                        ; [fn init: encode_allow_alias_2]: copy argument 1 (__ret_value)
move $r42 $$reta                        ; [fn init: encode_allow_alias_2]: save return address
.68
fncall .6                               ; [call: is_encode_trivial_3]: call function
jnzi $$retv .69
.70
addi $r44 $$locbase i72                 ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r44                        ; [call: new_29]: pass argument 0
fncall .16                              ; [call: new_29]: call function
addi $r46 $$locbase i16                 ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
mcpi $r46 $r40 i56                      ; copy memory
addi $r47 $$locbase i72                 ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r48 $$locbase i96                 ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r46                        ; [call: abi_encode_20]: pass argument 0
move $$arg1 $r47                        ; [call: abi_encode_20]: pass argument 1
move $$arg2 $r48                        ; [call: abi_encode_20]: pass argument 2
fncall .8                               ; [call: abi_encode_20]: call function
addi $r50 $$locbase i96                 ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r50                        ; [call: as_raw_slice_30]: pass argument 0
move $$arg1 $r41                        ; [call: as_raw_slice_30]: pass argument 1
fncall .18                              ; [call: as_raw_slice_30]: call function
ji  .71
.69
sw $$locbase $r40 i0                    ; store word
movi $r53 i56                           ; initialize constant into register
sw $$locbase $r53 i1                    ; store word
mcpi $r41 $$locbase i16                 ; copy memory
.71
.5
cfsi i120                               ; [fn end: encode_allow_alias_2] free: locals 120 byte(s), call args 0 slot(s)
move $$reta $r42                        ; [fn end: encode_allow_alias_2] restore return address
popa .4                                 ; [fn end: encode_allow_alias_2] restore all used registers
jal $zero $$reta i0                     ; [fn end: encode_allow_alias_2] return from call
DIFF------------------------------
.program:
.4                                      ; --- start of function: encode_allow_alias_2 ---
pusha .4                                ; [fn init: encode_allow_alias_2]: push all used registers to stack
move $$locbase $sp                      ; [fn init: encode_allow_alias_2]: set locals base register
cfei i120                               ; [fn init: encode_allow_alias_2]: allocate: locals 120 byte(s), call args 0 slot(s)
move $r40 $$arg0                        ; [fn init: encode_allow_alias_2]: copy argument 0 (item)
move $r41 $$arg1                        ; [fn init: encode_allow_alias_2]: copy argument 1 (__ret_value)
move $r42 $$reta                        ; [fn init: encode_allow_alias_2]: save return address
.68
fncall .6                               ; [call: is_encode_trivial_3]: call function
jnzi $$retv .69
.70
addi $r44 $$locbase i72                 ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r44                        ; [call: new_29]: pass argument 0
fncall .16                              ; [call: new_29]: call function
addi $r46 $$locbase i16                 ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
mcpi $r46 $r40 i56                      ; copy memory
addi $r47 $$locbase i72                 ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r48 $$locbase i96                 ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r46                        ; [call: abi_encode_20]: pass argument 0
move $$arg1 $r47                        ; [call: abi_encode_20]: pass argument 1
move $$arg2 $r48                        ; [call: abi_encode_20]: pass argument 2
fncall .8                               ; [call: abi_encode_20]: call function
addi $r50 $$locbase i96                 ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r50                        ; [call: as_raw_slice_30]: pass argument 0
move $$arg1 $r41                        ; [call: as_raw_slice_30]: pass argument 1
fncall .18                              ; [call: as_raw_slice_30]: call function
ji  .71
.69
sw $$locbase $r40 i0                    ; store word
movi $r53 i56                           ; initialize constant into register
sw $$locbase $r53 i1                    ; store word
mcpi $r41 $$locbase i16                 ; copy memory
.71
.5
cfsi i120                               ; [fn end: encode_allow_alias_2] free: locals 120 byte(s), call args 0 slot(s)
move $$reta $r42                        ; [fn end: encode_allow_alias_2] restore return address
popa .4                                 ; [fn end: encode_allow_alias_2] restore all used registers
jal $zero $$reta i0                     ; [fn end: encode_allow_alias_2] return from call
DIFF------------------------------
.program:
.4                                      ; --- start of function: encode_allow_alias_2 ---
pusha .4                                ; [fn init: encode_allow_alias_2]: push all used registers to stack
move $$locbase $sp                      ; [fn init: encode_allow_alias_2]: set locals base register
cfei i120                               ; [fn init: encode_allow_alias_2]: allocate: locals 120 byte(s), call args 0 slot(s)
move $r40 $$arg0                        ; [fn init: encode_allow_alias_2]: copy argument 0 (item)
move $r41 $$arg1                        ; [fn init: encode_allow_alias_2]: copy argument 1 (__ret_value)
move $r42 $$reta                        ; [fn init: encode_allow_alias_2]: save return address
.68
fncall .6                               ; [call: is_encode_trivial_3]: call function
jnzi $$retv .69
.70
addi $r44 $$locbase i72                 ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r44                        ; [call: new_29]: pass argument 0
fncall .16                              ; [call: new_29]: call function
addi $r46 $$locbase i16                 ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
mcpi $r46 $r40 i56                      ; copy memory
addi $r47 $$locbase i72                 ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r48 $$locbase i96                 ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r46                        ; [call: abi_encode_20]: pass argument 0
move $$arg1 $r47                        ; [call: abi_encode_20]: pass argument 1
move $$arg2 $r48                        ; [call: abi_encode_20]: pass argument 2
fncall .8                               ; [call: abi_encode_20]: call function
addi $r50 $$locbase i96                 ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r50                        ; [call: as_raw_slice_30]: pass argument 0
move $$arg1 $r41                        ; [call: as_raw_slice_30]: pass argument 1
fncall .18                              ; [call: as_raw_slice_30]: call function
ji  .71
.69
sw $$locbase $r40 i0                    ; store word
movi $r53 i56                           ; initialize constant into register
sw $$locbase $r53 i1                    ; store word
mcpi $r41 $$locbase i16                 ; copy memory
.71
.5
cfsi i120                               ; [fn end: encode_allow_alias_2] free: locals 120 byte(s), call args 0 slot(s)
move $$reta $r42                        ; [fn end: encode_allow_alias_2] restore return address
popa .4                                 ; [fn end: encode_allow_alias_2] restore all used registers
jal $zero $$reta i0                     ; [fn end: encode_allow_alias_2] return from call
DIFF------------------------------
.program:
.6                                      ; --- start of function: is_encode_trivial_3 ---
pusha .6                                ; [fn init: is_encode_trivial_3]: push all used registers to stack
move $$locbase $sp                      ; [fn init: is_encode_trivial_3]: set locals base register
cfei i0                                 ; [fn init: is_encode_trivial_3]: allocate: locals 0 byte(s), call args 0 slot(s)
.72
 move $r55 $zero                         ; move parameter from branch to block argument
 jnzi $zero .73
 movi $r55 i0                            ; move parameter from branch to block argument
 
ji  .74
.73
 move $r55 $one                          ; move parameter from branch to block argument
 movi $r55 i1                            ; move parameter from branch to block argument
ji  .74
.74
move $r58 $r55                          ; move parameter from branch to block argument
 move $r59 $r58                          ; move parameter from branch to block argument
 jnzi $r58 .75
 move $r59 $r55                          ; move parameter from branch to block argument
 jnzi $r55 .75
ji  .76
.75
 move $r59 $one                          ; move parameter from branch to block argument
 movi $r59 i1                            ; move parameter from branch to block argument
ji  .76
.76
move $r62 $r59                          ; move parameter from branch to block argument
 move $r63 $r62                          ; move parameter from branch to block argument
 jnzi $r62 .77
 move $r63 $r59                          ; move parameter from branch to block argument
 jnzi $r59 .77
ji  .78
.77
 move $r63 $zero                         ; move parameter from branch to block argument
 movi $r63 i0                            ; move parameter from branch to block argument
ji  .78
.78
move $r66 $r63                          ; move parameter from branch to block argument
 move $$retv $r66                        ; [fn end: is_encode_trivial_3] set return value
 move $$retv $r63                        ; [fn end: is_encode_trivial_3] set return value
ji  .7
.7
cfsi i0                                 ; [fn end: is_encode_trivial_3] free: locals 0 byte(s), call args 0 slot(s)
popa .6                                 ; [fn end: is_encode_trivial_3] restore all used registers
jal $zero $$reta i0                     ; [fn end: is_encode_trivial_3] return from call
DIFF------------------------------
.program:
.6                                      ; --- start of function: is_encode_trivial_3 ---
pusha .6                                ; [fn init: is_encode_trivial_3]: push all used registers to stack
move $$locbase $sp                      ; [fn init: is_encode_trivial_3]: set locals base register
cfei i0                                 ; [fn init: is_encode_trivial_3]: allocate: locals 0 byte(s), call args 0 slot(s)
.72
movi $r55 i0                            ; move parameter from branch to block argument
.74
 move $r59 $r55                          ; move parameter from branch to block argument
 jnzi $r55 .75
 movi $r59 i0                            ; move parameter from branch to block argument
 
ji  .76
.75
movi $r59 i1                            ; move parameter from branch to block argument
.76
move $r63 $r59                          ; move parameter from branch to block argument
jnzi $r59 .77
ji  .78
.77
movi $r63 i0                            ; move parameter from branch to block argument
.78
move $$retv $r63                        ; [fn end: is_encode_trivial_3] set return value
.7
cfsi i0                                 ; [fn end: is_encode_trivial_3] free: locals 0 byte(s), call args 0 slot(s)
popa .6                                 ; [fn end: is_encode_trivial_3] restore all used registers
jal $zero $$reta i0                     ; [fn end: is_encode_trivial_3] return from call
DIFF------------------------------
.program:
.6                                      ; --- start of function: is_encode_trivial_3 ---
pusha .6                                ; [fn init: is_encode_trivial_3]: push all used registers to stack
move $$locbase $sp                      ; [fn init: is_encode_trivial_3]: set locals base register
cfei i0                                 ; [fn init: is_encode_trivial_3]: allocate: locals 0 byte(s), call args 0 slot(s)
.72
.74
movi $r59 i0                            ; move parameter from branch to block argument
.76
 move $r63 $r59                          ; move parameter from branch to block argument
 jnzi $r59 .77
 movi $r63 i0                            ; move parameter from branch to block argument
 
ji  .78
.77
 movi $r63 i0                            ; move parameter from branch to block argument
                                         ; move parameter from branch to block argument
.78
move $$retv $r63                        ; [fn end: is_encode_trivial_3] set return value
.7
cfsi i0                                 ; [fn end: is_encode_trivial_3] free: locals 0 byte(s), call args 0 slot(s)
popa .6                                 ; [fn end: is_encode_trivial_3] restore all used registers
jal $zero $$reta i0                     ; [fn end: is_encode_trivial_3] return from call
DIFF------------------------------
.program:
.6                                      ; --- start of function: is_encode_trivial_3 ---
pusha .6                                ; [fn init: is_encode_trivial_3]: push all used registers to stack
move $$locbase $sp                      ; [fn init: is_encode_trivial_3]: set locals base register
cfei i0                                 ; [fn init: is_encode_trivial_3]: allocate: locals 0 byte(s), call args 0 slot(s)
.72
.74
.76
movi $r63 i0                            ; move parameter from branch to block argument
.78
 move $$retv $r63                        ; [fn end: is_encode_trivial_3] set return value
 movi $$retv i0                          ; [fn end: is_encode_trivial_3] set return value
.7
cfsi i0                                 ; [fn end: is_encode_trivial_3] free: locals 0 byte(s), call args 0 slot(s)
popa .6                                 ; [fn end: is_encode_trivial_3] restore all used registers
jal $zero $$reta i0                     ; [fn end: is_encode_trivial_3] return from call
DIFF------------------------------
.program:
.6                                      ; --- start of function: is_encode_trivial_3 ---
pusha .6                                ; [fn init: is_encode_trivial_3]: push all used registers to stack
move $$locbase $sp                      ; [fn init: is_encode_trivial_3]: set locals base register
cfei i0                                 ; [fn init: is_encode_trivial_3]: allocate: locals 0 byte(s), call args 0 slot(s)
.72
.74
.76
.78
movi $$retv i0                          ; [fn end: is_encode_trivial_3] set return value
.7
cfsi i0                                 ; [fn end: is_encode_trivial_3] free: locals 0 byte(s), call args 0 slot(s)
popa .6                                 ; [fn end: is_encode_trivial_3] restore all used registers
jal $zero $$reta i0                     ; [fn end: is_encode_trivial_3] return from call
DIFF------------------------------
.program:
.6                                      ; --- start of function: is_encode_trivial_3 ---
pusha .6                                ; [fn init: is_encode_trivial_3]: push all used registers to stack
move $$locbase $sp                      ; [fn init: is_encode_trivial_3]: set locals base register
cfei i0                                 ; [fn init: is_encode_trivial_3]: allocate: locals 0 byte(s), call args 0 slot(s)
.72
.74
.76
.78
movi $$retv i0                          ; [fn end: is_encode_trivial_3] set return value
.7
cfsi i0                                 ; [fn end: is_encode_trivial_3] free: locals 0 byte(s), call args 0 slot(s)
popa .6                                 ; [fn end: is_encode_trivial_3] restore all used registers
jal $zero $$reta i0                     ; [fn end: is_encode_trivial_3] return from call
DIFF------------------------------
.program:
.8                                      ; --- start of function: abi_encode_20 ---
pusha .8                                ; [fn init: abi_encode_20]: push all used registers to stack
move $$locbase $sp                      ; [fn init: abi_encode_20]: set locals base register
cfei i1288                              ; [fn init: abi_encode_20]: allocate: locals 1288 byte(s), call args 0 slot(s)
move $r67 $$arg0                        ; [fn init: abi_encode_20]: copy argument 0 (self)
move $r68 $$arg1                        ; [fn init: abi_encode_20]: copy argument 1 (buffer)
move $r69 $$arg2                        ; [fn init: abi_encode_20]: copy argument 2 (__ret_value)
move $r70 $$reta                        ; [fn init: abi_encode_20]: save return address
.79
addi $r71 $$locbase i1104               ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
 mcpi $r71 $r67 i56                      ; copy memory
 mcpi $r71 $$arg0 i56                    ; copy memory
addi $r72 $$locbase i720                ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r72 $r68 i24                      ; copy memory
addi $r73 $$locbase i1104               ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
addi $r74 $$locbase i96                 ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
mcpi $r74 $r73 i56                      ; copy memory
addi $r75 $$locbase i96                 ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
lw $r76 $$locbase i12                   ; load word
eq $r77 $r76 $zero
jnzi $r77 .80
ji  .81
.81
addi $r78 $$locbase i96                 ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
lw $r79 $$locbase i12                   ; load word
eq $r80 $r79 $one
jnzi $r80 .82
ji  .83
.83
addi $r81 $$locbase i96                 ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
lw $r82 $$locbase i12                   ; load word
movi $r83 i2                            ; initialize constant into register
eq $r84 $r82 $r83
jnzi $r84 .84
ji  .85
.85
addi $r85 $$locbase i96                 ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
lw $r86 $$locbase i12                   ; load word
movi $r87 i3                            ; initialize constant into register
eq $r88 $r86 $r87
jnzi $r88 .86
ji  .87
.87
addi $r89 $$locbase i96                 ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
lw $r90 $$locbase i12                   ; load word
movi $r91 i4                            ; initialize constant into register
eq $r92 $r90 $r91
jnzi $r92 .88
ji  .89
.89
load $r93 data_NonConfigurable_6        ; load constant from data section
rvrt $r93
.88
addi $r94 $$locbase i96                 ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
addi $r95 $r94 i8                       ; get offset to aggregate element
addi $r96 $$locbase i1240               ; get offset to local __ptr [slice; 3]
mcpi $r96 $r95 i48                      ; copy memory
addi $r97 $$locbase i720                ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r98 $$locbase i536                ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r98 $r97 i24                      ; copy memory
addi $r99 $$locbase i296                ; get offset to local __ptr { { ptr, u64, u64 } }
movi $r100 i4                           ; initialize constant into register
 move $$arg0 $r100                       ; [call: abi_encode_21]: pass argument 0
 movi $$arg0 i4                          ; [call: abi_encode_21]: pass argument 0
move $$arg1 $r98                        ; [call: abi_encode_21]: pass argument 1
move $$arg2 $r99                        ; [call: abi_encode_21]: pass argument 2
fncall .10                              ; [call: abi_encode_21]: call function
 move $r101 $zero                        ; [call: abi_encode_21]: copy returned unit value
 movi $r101 i0                           ; [call: abi_encode_21]: copy returned unit value
addi $r102 $$locbase i1032              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r102 $r99 i24                     ; copy memory
addi $r103 $$locbase i1240              ; get offset to local __ptr [slice; 3]
addi $r104 $$locbase i1032              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r105 $$locbase i1176              ; get offset to local __ptr [slice; 3]
mcpi $r105 $r103 i48                    ; copy memory
addi $r106 $$locbase i792               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r106 $r104 i24                    ; copy memory
addi $r107 $$locbase i792               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r108 $$locbase i864               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r108 $r107 i24                    ; copy memory
 move $r109 $zero                        ; move parameter from branch to block argument
 movi $r109 i0                           ; move parameter from branch to block argument
ji  .90
.90
move $r111 $r109                        ; move parameter from branch to block argument
movi $r112 i3                           ; initialize constant into register
 lt $r113 $r111 $r112
 lt $r113 $r109 $r112
jnzi $r113 .91
ji  .92
.92
addi $r114 $$locbase i864               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r115 $$locbase i1056              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r115 $r114 i24                    ; copy memory
addi $r116 $$locbase i1056              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r117 $$locbase i624               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r117 $r116 i24                    ; copy memory
move $r118 $r117                        ; move parameter from branch to block argument
ji  .93
.91
addi $r119 $$locbase i1176              ; get offset to local __ptr [slice; 3]
movi $r120 i16                          ; get array element size
 mul $r121 $r111 $r120                   ; get offset to array element
 muli $r121 $r111 i16                    ; get offset to array element
add $r121 $r119 $r121                   ; add array element offset to array base
addi $r122 $$locbase i864               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r123 $$locbase i584               ; get offset to local __ptr slice
mcpi $r123 $r121 i16                    ; copy memory
addi $r124 $$locbase i600               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r124 $r122 i24                    ; copy memory
addi $r125 $$locbase i344               ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r123                       ; [call: abi_encode_27]: pass argument 0
move $$arg1 $r124                       ; [call: abi_encode_27]: pass argument 1
move $$arg2 $r125                       ; [call: abi_encode_27]: pass argument 2
fncall .14                              ; [call: abi_encode_27]: call function
 move $r126 $zero                        ; [call: abi_encode_27]: copy returned unit value
 movi $r126 i0                           ; [call: abi_encode_27]: copy returned unit value
addi $r127 $$locbase i864               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r127 $r125 i24                    ; copy memory
 add $r128 $r111 $one
 addi $r128 $r111 i1
move $r109 $r128                        ; move parameter from branch to block argument
ji  .90
.86
addi $r130 $$locbase i96                ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
addi $r131 $r130 i40                    ; get offset to aggregate element
addi $r132 $$locbase i1224              ; get offset to local __ptr { u64, u64 }
mcpi $r132 $r131 i16                    ; copy memory
addi $r133 $$locbase i720               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r134 $$locbase i464               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r134 $r133 i24                    ; copy memory
addi $r135 $$locbase i224               ; get offset to local __ptr { { ptr, u64, u64 } }
movi $r136 i3                           ; initialize constant into register
 move $$arg0 $r136                       ; [call: abi_encode_21]: pass argument 0
 movi $$arg0 i3                          ; [call: abi_encode_21]: pass argument 0
move $$arg1 $r134                       ; [call: abi_encode_21]: pass argument 1
move $$arg2 $r135                       ; [call: abi_encode_21]: pass argument 2
fncall .10                              ; [call: abi_encode_21]: call function
 move $r137 $zero                        ; [call: abi_encode_21]: copy returned unit value
 movi $r137 i0                           ; [call: abi_encode_21]: copy returned unit value
addi $r138 $$locbase i984               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r138 $r135 i24                    ; copy memory
addi $r139 $$locbase i1224              ; get offset to local __ptr { u64, u64 }
addi $r140 $$locbase i984               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r141 $$locbase i1160              ; get offset to local __ptr { u64, u64 }
mcpi $r141 $r139 i16                    ; copy memory
addi $r142 $$locbase i768               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r142 $r140 i24                    ; copy memory
addi $r143 $$locbase i1160              ; get offset to local __ptr { u64, u64 }
lw $r144 $$locbase i145                 ; load word
addi $r145 $$locbase i768               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r146 $$locbase i488               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r146 $r145 i24                    ; copy memory
addi $r147 $$locbase i248               ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r144                       ; [call: abi_encode_21]: pass argument 0
move $$arg1 $r146                       ; [call: abi_encode_21]: pass argument 1
move $$arg2 $r147                       ; [call: abi_encode_21]: pass argument 2
fncall .10                              ; [call: abi_encode_21]: call function
 move $r148 $zero                        ; [call: abi_encode_21]: copy returned unit value
 movi $r148 i0                           ; [call: abi_encode_21]: copy returned unit value
addi $r149 $$locbase i840               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r149 $r147 i24                    ; copy memory
addi $r150 $$locbase i1160              ; get offset to local __ptr { u64, u64 }
addi $r151 $r150 i8                     ; get offset to aggregate element
lw $r152 $$locbase i146                 ; load word
addi $r153 $$locbase i840               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r154 $$locbase i512               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r154 $r153 i24                    ; copy memory
addi $r155 $$locbase i272               ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r152                       ; [call: abi_encode_21]: pass argument 0
move $$arg1 $r154                       ; [call: abi_encode_21]: pass argument 1
move $$arg2 $r155                       ; [call: abi_encode_21]: pass argument 2
fncall .10                              ; [call: abi_encode_21]: call function
 move $r156 $zero                        ; [call: abi_encode_21]: copy returned unit value
 movi $r156 i0                           ; [call: abi_encode_21]: copy returned unit value
addi $r157 $$locbase i912               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r157 $r155 i24                    ; copy memory
addi $r158 $$locbase i912               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r159 $$locbase i1008              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r159 $r158 i24                    ; copy memory
addi $r160 $$locbase i1008              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r161 $$locbase i624               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r161 $r160 i24                    ; copy memory
move $r118 $r161                        ; move parameter from branch to block argument
ji  .93
.93
move $r164 $r118                        ; move parameter from branch to block argument
addi $r165 $$locbase i648               ; get offset to local __ptr { { ptr, u64, u64 } }
 mcpi $r165 $r164 i24                    ; copy memory
 mcpi $r165 $r118 i24                    ; copy memory
move $r166 $r165                        ; move parameter from branch to block argument
ji  .94
.84
addi $r167 $$locbase i96                ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
addi $r168 $r167 i55                    ; get offset to aggregate element
lb $r169 $r168 i0                       ; load byte
addi $r170 $$locbase i720               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r171 $$locbase i440               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r171 $r170 i24                    ; copy memory
addi $r172 $$locbase i200               ; get offset to local __ptr { { ptr, u64, u64 } }
movi $r173 i2                           ; initialize constant into register
 move $$arg0 $r173                       ; [call: abi_encode_21]: pass argument 0
 movi $$arg0 i2                          ; [call: abi_encode_21]: pass argument 0
move $$arg1 $r171                       ; [call: abi_encode_21]: pass argument 1
move $$arg2 $r172                       ; [call: abi_encode_21]: pass argument 2
fncall .10                              ; [call: abi_encode_21]: call function
 move $r174 $zero                        ; [call: abi_encode_21]: copy returned unit value
 movi $r174 i0                           ; [call: abi_encode_21]: copy returned unit value
addi $r175 $$locbase i936               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r175 $r172 i24                    ; copy memory
addi $r176 $$locbase i936               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r177 $$locbase i560               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r177 $r176 i24                    ; copy memory
addi $r178 $$locbase i320               ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r169                       ; [call: abi_encode_23]: pass argument 0
move $$arg1 $r177                       ; [call: abi_encode_23]: pass argument 1
move $$arg2 $r178                       ; [call: abi_encode_23]: pass argument 2
fncall .12                              ; [call: abi_encode_23]: call function
 move $r179 $zero                        ; [call: abi_encode_23]: copy returned unit value
 movi $r179 i0                           ; [call: abi_encode_23]: copy returned unit value
addi $r180 $$locbase i960               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r180 $r178 i24                    ; copy memory
addi $r181 $$locbase i960               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r182 $$locbase i648               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r182 $r181 i24                    ; copy memory
move $r166 $r182                        ; move parameter from branch to block argument
ji  .94
.94
move $r185 $r166                        ; move parameter from branch to block argument
addi $r186 $$locbase i672               ; get offset to local __ptr { { ptr, u64, u64 } }
 mcpi $r186 $r185 i24                    ; copy memory
 mcpi $r186 $r166 i24                    ; copy memory
move $r187 $r186                        ; move parameter from branch to block argument
ji  .95
.82
addi $r188 $$locbase i96                ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
addi $r189 $r188 i55                    ; get offset to aggregate element
lb $r190 $r189 i0                       ; load byte
addi $r191 $$locbase i720               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r192 $$locbase i416               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r192 $r191 i24                    ; copy memory
addi $r193 $$locbase i176               ; get offset to local __ptr { { ptr, u64, u64 } }
 move $$arg0 $one                        ; [call: abi_encode_21]: pass argument 0
 movi $$arg0 i1                          ; [call: abi_encode_21]: pass argument 0
move $$arg1 $r192                       ; [call: abi_encode_21]: pass argument 1
move $$arg2 $r193                       ; [call: abi_encode_21]: pass argument 2
fncall .10                              ; [call: abi_encode_21]: call function
 move $r194 $zero                        ; [call: abi_encode_21]: copy returned unit value
 movi $r194 i0                           ; [call: abi_encode_21]: copy returned unit value
addi $r195 $$locbase i816               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r195 $r193 i24                    ; copy memory
addi $r196 $$locbase i816               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r197 $$locbase i744               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r197 $r196 i24                    ; copy memory
addi $r198 $$locbase i368               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r199 $$locbase i744               ; get offset to local __ptr { { ptr, u64, u64 } }
move $r200 $r199                        ; return value from ASM block with return register buffer
 mcpi $$locbase $r200 i24                ; copy memory
 mcpi $$locbase $r199 i24                ; copy memory
addi $r201 $$locbase i48                ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r201 $$locbase i24                ; copy memory
lw $r202 $$locbase i6                   ; load word
addi $r203 $r201 i8                     ; get offset to aggregate element
lw $r204 $$locbase i7                   ; load word
addi $r205 $r201 i16                    ; get offset to aggregate element
lw $r206 $$locbase i8                   ; load word
 add $r207 $r206 $one
 addi $r207 $r206 i1
gt $r208 $r207 $r204
move $r209 $r202                        ; move parameter from branch to block argument
move $r210 $r204                        ; move parameter from branch to block argument
jnzi $r208 .96
ji  .97
.96
movi $r211 i2                           ; initialize constant into register
 mul $r212 $r204 $r211
 add $r213 $r212 $one
 muli $r212 $r204 i2
 addi $r213 $r212 i1
aloc $r213
mcp $hp $r202 $r206
move $r214 $hp                          ; return value from ASM block with return register hp
 move $r209 $r214                        ; move parameter from branch to block argument
 move $r209 $hp                          ; move parameter from branch to block argument
move $r210 $r213                        ; move parameter from branch to block argument
ji  .97
.97
move $r218 $r209                        ; move parameter from branch to block argument
move $r220 $r210                        ; move parameter from branch to block argument
 add $r221 $r218 $r206
 add $r221 $r209 $r206
sb $r221 $r190 i0                       ; store byte
addi $r222 $$locbase i72                ; get offset to local __ptr { ptr, u64, u64 }
sw $$locbase $r218 i9                   ; store word
addi $r223 $r222 i8                     ; get offset to aggregate element
sw $$locbase $r220 i10                  ; store word
addi $r224 $r222 i16                    ; get offset to aggregate element
sw $$locbase $r207 i11                  ; store word
move $r225 $r222                        ; return value from ASM block with return register buffer
addi $r226 $$locbase i24                ; get offset to local __ptr { ptr, u64, u64 }
 mcpi $r226 $r225 i24                    ; copy memory
 mcpi $r226 $r222 i24                    ; copy memory
mcpi $r198 $r226 i24                    ; copy memory
addi $r227 $$locbase i888               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r227 $r198 i24                    ; copy memory
addi $r228 $$locbase i888               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r229 $$locbase i672               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r229 $r228 i24                    ; copy memory
move $r187 $r229                        ; move parameter from branch to block argument
ji  .95
.95
move $r232 $r187                        ; move parameter from branch to block argument
addi $r233 $$locbase i696               ; get offset to local __ptr { { ptr, u64, u64 } }
 mcpi $r233 $r232 i24                    ; copy memory
 mcpi $r233 $r187 i24                    ; copy memory
move $r234 $r233                        ; move parameter from branch to block argument
ji  .98
.80
addi $r235 $$locbase i720               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r236 $$locbase i392               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r236 $r235 i24                    ; copy memory
addi $r237 $$locbase i152               ; get offset to local __ptr { { ptr, u64, u64 } }
 move $$arg0 $zero                       ; [call: abi_encode_21]: pass argument 0
 movi $$arg0 i0                          ; [call: abi_encode_21]: pass argument 0
move $$arg1 $r236                       ; [call: abi_encode_21]: pass argument 1
move $$arg2 $r237                       ; [call: abi_encode_21]: pass argument 2
fncall .10                              ; [call: abi_encode_21]: call function
 move $r238 $zero                        ; [call: abi_encode_21]: copy returned unit value
 movi $r238 i0                           ; [call: abi_encode_21]: copy returned unit value
addi $r239 $$locbase i696               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r239 $r237 i24                    ; copy memory
move $r234 $r239                        ; move parameter from branch to block argument
ji  .98
.98
move $r242 $r234                        ; move parameter from branch to block argument
addi $r243 $$locbase i1080              ; get offset to local __ptr { { ptr, u64, u64 } }
 mcpi $r243 $r242 i24                    ; copy memory
 mcpi $r243 $r234 i24                    ; copy memory
addi $r244 $$locbase i1080              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r69 $r244 i24                     ; copy memory
ji  .9
.9
cfsi i1288                              ; [fn end: abi_encode_20] free: locals 1288 byte(s), call args 0 slot(s)
move $$reta $r70                        ; [fn end: abi_encode_20] restore return address
popa .8                                 ; [fn end: abi_encode_20] restore all used registers
jal $zero $$reta i0                     ; [fn end: abi_encode_20] return from call
DIFF------------------------------
.program:
.8                                      ; --- start of function: abi_encode_20 ---
pusha .8                                ; [fn init: abi_encode_20]: push all used registers to stack
move $$locbase $sp                      ; [fn init: abi_encode_20]: set locals base register
cfei i1288                              ; [fn init: abi_encode_20]: allocate: locals 1288 byte(s), call args 0 slot(s)
move $r68 $$arg1                        ; [fn init: abi_encode_20]: copy argument 1 (buffer)
move $r69 $$arg2                        ; [fn init: abi_encode_20]: copy argument 2 (__ret_value)
move $r70 $$reta                        ; [fn init: abi_encode_20]: save return address
.79
addi $r71 $$locbase i1104               ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
mcpi $r71 $$arg0 i56                    ; copy memory
addi $r72 $$locbase i720                ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r72 $r68 i24                      ; copy memory
addi $r73 $$locbase i1104               ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
addi $r74 $$locbase i96                 ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
mcpi $r74 $r73 i56                      ; copy memory
lw $r76 $$locbase i12                   ; load word
eq $r77 $r76 $zero
jnzi $r77 .80
.81
lw $r79 $$locbase i12                   ; load word
eq $r80 $r79 $one
jnzi $r80 .82
.83
lw $r82 $$locbase i12                   ; load word
movi $r83 i2                            ; initialize constant into register
eq $r84 $r82 $r83
jnzi $r84 .84
.85
lw $r86 $$locbase i12                   ; load word
movi $r87 i3                            ; initialize constant into register
eq $r88 $r86 $r87
jnzi $r88 .86
.87
lw $r90 $$locbase i12                   ; load word
movi $r91 i4                            ; initialize constant into register
eq $r92 $r90 $r91
jnzi $r92 .88
.89
load $r93 data_NonConfigurable_6        ; load constant from data section
rvrt $r93
.88
addi $r94 $$locbase i96                 ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
addi $r95 $r94 i8                       ; get offset to aggregate element
addi $r96 $$locbase i1240               ; get offset to local __ptr [slice; 3]
mcpi $r96 $r95 i48                      ; copy memory
addi $r97 $$locbase i720                ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r98 $$locbase i536                ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r98 $r97 i24                      ; copy memory
addi $r99 $$locbase i296                ; get offset to local __ptr { { ptr, u64, u64 } }
movi $$arg0 i4                          ; [call: abi_encode_21]: pass argument 0
move $$arg1 $r98                        ; [call: abi_encode_21]: pass argument 1
move $$arg2 $r99                        ; [call: abi_encode_21]: pass argument 2
fncall .10                              ; [call: abi_encode_21]: call function
addi $r102 $$locbase i1032              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r102 $r99 i24                     ; copy memory
addi $r103 $$locbase i1240              ; get offset to local __ptr [slice; 3]
addi $r104 $$locbase i1032              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r105 $$locbase i1176              ; get offset to local __ptr [slice; 3]
mcpi $r105 $r103 i48                    ; copy memory
addi $r106 $$locbase i792               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r106 $r104 i24                    ; copy memory
addi $r107 $$locbase i792               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r108 $$locbase i864               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r108 $r107 i24                    ; copy memory
movi $r109 i0                           ; move parameter from branch to block argument
.90
move $r111 $r109                        ; move parameter from branch to block argument
movi $r112 i3                           ; initialize constant into register
lt $r113 $r109 $r112
jnzi $r113 .91
.92
addi $r114 $$locbase i864               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r115 $$locbase i1056              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r115 $r114 i24                    ; copy memory
addi $r116 $$locbase i1056              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r117 $$locbase i624               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r117 $r116 i24                    ; copy memory
move $r118 $r117                        ; move parameter from branch to block argument
ji  .93
.91
addi $r119 $$locbase i1176              ; get offset to local __ptr [slice; 3]
muli $r121 $r111 i16                    ; get offset to array element
add $r121 $r119 $r121                   ; add array element offset to array base
addi $r122 $$locbase i864               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r123 $$locbase i584               ; get offset to local __ptr slice
mcpi $r123 $r121 i16                    ; copy memory
addi $r124 $$locbase i600               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r124 $r122 i24                    ; copy memory
addi $r125 $$locbase i344               ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r123                       ; [call: abi_encode_27]: pass argument 0
move $$arg1 $r124                       ; [call: abi_encode_27]: pass argument 1
move $$arg2 $r125                       ; [call: abi_encode_27]: pass argument 2
fncall .14                              ; [call: abi_encode_27]: call function
addi $r127 $$locbase i864               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r127 $r125 i24                    ; copy memory
addi $r128 $r111 i1
move $r109 $r128                        ; move parameter from branch to block argument
ji  .90
.86
addi $r130 $$locbase i96                ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
addi $r131 $r130 i40                    ; get offset to aggregate element
addi $r132 $$locbase i1224              ; get offset to local __ptr { u64, u64 }
mcpi $r132 $r131 i16                    ; copy memory
addi $r133 $$locbase i720               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r134 $$locbase i464               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r134 $r133 i24                    ; copy memory
addi $r135 $$locbase i224               ; get offset to local __ptr { { ptr, u64, u64 } }
movi $$arg0 i3                          ; [call: abi_encode_21]: pass argument 0
move $$arg1 $r134                       ; [call: abi_encode_21]: pass argument 1
move $$arg2 $r135                       ; [call: abi_encode_21]: pass argument 2
fncall .10                              ; [call: abi_encode_21]: call function
addi $r138 $$locbase i984               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r138 $r135 i24                    ; copy memory
addi $r139 $$locbase i1224              ; get offset to local __ptr { u64, u64 }
addi $r140 $$locbase i984               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r141 $$locbase i1160              ; get offset to local __ptr { u64, u64 }
mcpi $r141 $r139 i16                    ; copy memory
addi $r142 $$locbase i768               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r142 $r140 i24                    ; copy memory
lw $r144 $$locbase i145                 ; load word
addi $r145 $$locbase i768               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r146 $$locbase i488               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r146 $r145 i24                    ; copy memory
addi $r147 $$locbase i248               ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r144                       ; [call: abi_encode_21]: pass argument 0
move $$arg1 $r146                       ; [call: abi_encode_21]: pass argument 1
move $$arg2 $r147                       ; [call: abi_encode_21]: pass argument 2
fncall .10                              ; [call: abi_encode_21]: call function
addi $r149 $$locbase i840               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r149 $r147 i24                    ; copy memory
lw $r152 $$locbase i146                 ; load word
addi $r153 $$locbase i840               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r154 $$locbase i512               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r154 $r153 i24                    ; copy memory
addi $r155 $$locbase i272               ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r152                       ; [call: abi_encode_21]: pass argument 0
move $$arg1 $r154                       ; [call: abi_encode_21]: pass argument 1
move $$arg2 $r155                       ; [call: abi_encode_21]: pass argument 2
fncall .10                              ; [call: abi_encode_21]: call function
addi $r157 $$locbase i912               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r157 $r155 i24                    ; copy memory
addi $r158 $$locbase i912               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r159 $$locbase i1008              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r159 $r158 i24                    ; copy memory
addi $r160 $$locbase i1008              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r161 $$locbase i624               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r161 $r160 i24                    ; copy memory
move $r118 $r161                        ; move parameter from branch to block argument
.93
addi $r165 $$locbase i648               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r165 $r118 i24                    ; copy memory
move $r166 $r165                        ; move parameter from branch to block argument
ji  .94
.84
addi $r167 $$locbase i96                ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
addi $r168 $r167 i55                    ; get offset to aggregate element
lb $r169 $r168 i0                       ; load byte
addi $r170 $$locbase i720               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r171 $$locbase i440               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r171 $r170 i24                    ; copy memory
addi $r172 $$locbase i200               ; get offset to local __ptr { { ptr, u64, u64 } }
movi $$arg0 i2                          ; [call: abi_encode_21]: pass argument 0
move $$arg1 $r171                       ; [call: abi_encode_21]: pass argument 1
move $$arg2 $r172                       ; [call: abi_encode_21]: pass argument 2
fncall .10                              ; [call: abi_encode_21]: call function
addi $r175 $$locbase i936               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r175 $r172 i24                    ; copy memory
addi $r176 $$locbase i936               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r177 $$locbase i560               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r177 $r176 i24                    ; copy memory
addi $r178 $$locbase i320               ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r169                       ; [call: abi_encode_23]: pass argument 0
move $$arg1 $r177                       ; [call: abi_encode_23]: pass argument 1
move $$arg2 $r178                       ; [call: abi_encode_23]: pass argument 2
fncall .12                              ; [call: abi_encode_23]: call function
addi $r180 $$locbase i960               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r180 $r178 i24                    ; copy memory
addi $r181 $$locbase i960               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r182 $$locbase i648               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r182 $r181 i24                    ; copy memory
move $r166 $r182                        ; move parameter from branch to block argument
.94
addi $r186 $$locbase i672               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r186 $r166 i24                    ; copy memory
move $r187 $r186                        ; move parameter from branch to block argument
ji  .95
.82
addi $r188 $$locbase i96                ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
addi $r189 $r188 i55                    ; get offset to aggregate element
lb $r190 $r189 i0                       ; load byte
addi $r191 $$locbase i720               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r192 $$locbase i416               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r192 $r191 i24                    ; copy memory
addi $r193 $$locbase i176               ; get offset to local __ptr { { ptr, u64, u64 } }
movi $$arg0 i1                          ; [call: abi_encode_21]: pass argument 0
move $$arg1 $r192                       ; [call: abi_encode_21]: pass argument 1
move $$arg2 $r193                       ; [call: abi_encode_21]: pass argument 2
fncall .10                              ; [call: abi_encode_21]: call function
addi $r195 $$locbase i816               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r195 $r193 i24                    ; copy memory
addi $r196 $$locbase i816               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r197 $$locbase i744               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r197 $r196 i24                    ; copy memory
addi $r198 $$locbase i368               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r199 $$locbase i744               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $$locbase $r199 i24                ; copy memory
addi $r201 $$locbase i48                ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r201 $$locbase i24                ; copy memory
lw $r202 $$locbase i6                   ; load word
lw $r204 $$locbase i7                   ; load word
lw $r206 $$locbase i8                   ; load word
addi $r207 $r206 i1
gt $r208 $r207 $r204
move $r209 $r202                        ; move parameter from branch to block argument
move $r210 $r204                        ; move parameter from branch to block argument
jnzi $r208 .96
ji  .97
.96
muli $r212 $r204 i2
addi $r213 $r212 i1
aloc $r213
mcp $hp $r202 $r206
move $r209 $hp                          ; move parameter from branch to block argument
move $r210 $r213                        ; move parameter from branch to block argument
.97
move $r218 $r209                        ; move parameter from branch to block argument
move $r220 $r210                        ; move parameter from branch to block argument
add $r221 $r209 $r206
sb $r221 $r190 i0                       ; store byte
addi $r222 $$locbase i72                ; get offset to local __ptr { ptr, u64, u64 }
sw $$locbase $r218 i9                   ; store word
sw $$locbase $r220 i10                  ; store word
sw $$locbase $r207 i11                  ; store word
addi $r226 $$locbase i24                ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r226 $r222 i24                    ; copy memory
mcpi $r198 $r226 i24                    ; copy memory
addi $r227 $$locbase i888               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r227 $r198 i24                    ; copy memory
addi $r228 $$locbase i888               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r229 $$locbase i672               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r229 $r228 i24                    ; copy memory
move $r187 $r229                        ; move parameter from branch to block argument
.95
addi $r233 $$locbase i696               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r233 $r187 i24                    ; copy memory
move $r234 $r233                        ; move parameter from branch to block argument
ji  .98
.80
addi $r235 $$locbase i720               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r236 $$locbase i392               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r236 $r235 i24                    ; copy memory
addi $r237 $$locbase i152               ; get offset to local __ptr { { ptr, u64, u64 } }
movi $$arg0 i0                          ; [call: abi_encode_21]: pass argument 0
move $$arg1 $r236                       ; [call: abi_encode_21]: pass argument 1
move $$arg2 $r237                       ; [call: abi_encode_21]: pass argument 2
fncall .10                              ; [call: abi_encode_21]: call function
addi $r239 $$locbase i696               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r239 $r237 i24                    ; copy memory
move $r234 $r239                        ; move parameter from branch to block argument
.98
addi $r243 $$locbase i1080              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r243 $r234 i24                    ; copy memory
addi $r244 $$locbase i1080              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r69 $r244 i24                     ; copy memory
.9
cfsi i1288                              ; [fn end: abi_encode_20] free: locals 1288 byte(s), call args 0 slot(s)
move $$reta $r70                        ; [fn end: abi_encode_20] restore return address
popa .8                                 ; [fn end: abi_encode_20] restore all used registers
jal $zero $$reta i0                     ; [fn end: abi_encode_20] return from call
DIFF------------------------------
.program:
.8                                      ; --- start of function: abi_encode_20 ---
pusha .8                                ; [fn init: abi_encode_20]: push all used registers to stack
move $$locbase $sp                      ; [fn init: abi_encode_20]: set locals base register
cfei i1288                              ; [fn init: abi_encode_20]: allocate: locals 1288 byte(s), call args 0 slot(s)
move $r68 $$arg1                        ; [fn init: abi_encode_20]: copy argument 1 (buffer)
move $r69 $$arg2                        ; [fn init: abi_encode_20]: copy argument 2 (__ret_value)
move $r70 $$reta                        ; [fn init: abi_encode_20]: save return address
.79
addi $r71 $$locbase i1104               ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
mcpi $r71 $$arg0 i56                    ; copy memory
addi $r72 $$locbase i720                ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r72 $r68 i24                      ; copy memory
addi $r73 $$locbase i1104               ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
addi $r74 $$locbase i96                 ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
mcpi $r74 $r73 i56                      ; copy memory
lw $r76 $$locbase i12                   ; load word
eq $r77 $r76 $zero
jnzi $r77 .80
.81
lw $r79 $$locbase i12                   ; load word
eq $r80 $r79 $one
jnzi $r80 .82
.83
lw $r82 $$locbase i12                   ; load word
movi $r83 i2                            ; initialize constant into register
eq $r84 $r82 $r83
jnzi $r84 .84
.85
lw $r86 $$locbase i12                   ; load word
movi $r87 i3                            ; initialize constant into register
eq $r88 $r86 $r87
jnzi $r88 .86
.87
lw $r90 $$locbase i12                   ; load word
movi $r91 i4                            ; initialize constant into register
eq $r92 $r90 $r91
jnzi $r92 .88
.89
load $r93 data_NonConfigurable_6        ; load constant from data section
rvrt $r93
.88
addi $r94 $$locbase i96                 ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
addi $r95 $r94 i8                       ; get offset to aggregate element
addi $r96 $$locbase i1240               ; get offset to local __ptr [slice; 3]
mcpi $r96 $r95 i48                      ; copy memory
addi $r97 $$locbase i720                ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r98 $$locbase i536                ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r98 $r97 i24                      ; copy memory
addi $r99 $$locbase i296                ; get offset to local __ptr { { ptr, u64, u64 } }
movi $$arg0 i4                          ; [call: abi_encode_21]: pass argument 0
move $$arg1 $r98                        ; [call: abi_encode_21]: pass argument 1
move $$arg2 $r99                        ; [call: abi_encode_21]: pass argument 2
fncall .10                              ; [call: abi_encode_21]: call function
addi $r102 $$locbase i1032              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r102 $r99 i24                     ; copy memory
addi $r103 $$locbase i1240              ; get offset to local __ptr [slice; 3]
addi $r104 $$locbase i1032              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r105 $$locbase i1176              ; get offset to local __ptr [slice; 3]
mcpi $r105 $r103 i48                    ; copy memory
addi $r106 $$locbase i792               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r106 $r104 i24                    ; copy memory
addi $r107 $$locbase i792               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r108 $$locbase i864               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r108 $r107 i24                    ; copy memory
movi $r109 i0                           ; move parameter from branch to block argument
.90
move $r111 $r109                        ; move parameter from branch to block argument
movi $r112 i3                           ; initialize constant into register
lt $r113 $r109 $r112
jnzi $r113 .91
.92
addi $r114 $$locbase i864               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r115 $$locbase i1056              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r115 $r114 i24                    ; copy memory
addi $r116 $$locbase i1056              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r117 $$locbase i624               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r117 $r116 i24                    ; copy memory
move $r118 $r117                        ; move parameter from branch to block argument
ji  .93
.91
addi $r119 $$locbase i1176              ; get offset to local __ptr [slice; 3]
muli $r121 $r111 i16                    ; get offset to array element
add $r121 $r119 $r121                   ; add array element offset to array base
addi $r122 $$locbase i864               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r123 $$locbase i584               ; get offset to local __ptr slice
mcpi $r123 $r121 i16                    ; copy memory
addi $r124 $$locbase i600               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r124 $r122 i24                    ; copy memory
addi $r125 $$locbase i344               ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r123                       ; [call: abi_encode_27]: pass argument 0
move $$arg1 $r124                       ; [call: abi_encode_27]: pass argument 1
move $$arg2 $r125                       ; [call: abi_encode_27]: pass argument 2
fncall .14                              ; [call: abi_encode_27]: call function
addi $r127 $$locbase i864               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r127 $r125 i24                    ; copy memory
addi $r128 $r111 i1
move $r109 $r128                        ; move parameter from branch to block argument
ji  .90
.86
addi $r130 $$locbase i96                ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
addi $r131 $r130 i40                    ; get offset to aggregate element
addi $r132 $$locbase i1224              ; get offset to local __ptr { u64, u64 }
mcpi $r132 $r131 i16                    ; copy memory
addi $r133 $$locbase i720               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r134 $$locbase i464               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r134 $r133 i24                    ; copy memory
addi $r135 $$locbase i224               ; get offset to local __ptr { { ptr, u64, u64 } }
movi $$arg0 i3                          ; [call: abi_encode_21]: pass argument 0
move $$arg1 $r134                       ; [call: abi_encode_21]: pass argument 1
move $$arg2 $r135                       ; [call: abi_encode_21]: pass argument 2
fncall .10                              ; [call: abi_encode_21]: call function
addi $r138 $$locbase i984               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r138 $r135 i24                    ; copy memory
addi $r139 $$locbase i1224              ; get offset to local __ptr { u64, u64 }
addi $r140 $$locbase i984               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r141 $$locbase i1160              ; get offset to local __ptr { u64, u64 }
mcpi $r141 $r139 i16                    ; copy memory
addi $r142 $$locbase i768               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r142 $r140 i24                    ; copy memory
lw $r144 $$locbase i145                 ; load word
addi $r145 $$locbase i768               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r146 $$locbase i488               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r146 $r145 i24                    ; copy memory
addi $r147 $$locbase i248               ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r144                       ; [call: abi_encode_21]: pass argument 0
move $$arg1 $r146                       ; [call: abi_encode_21]: pass argument 1
move $$arg2 $r147                       ; [call: abi_encode_21]: pass argument 2
fncall .10                              ; [call: abi_encode_21]: call function
addi $r149 $$locbase i840               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r149 $r147 i24                    ; copy memory
lw $r152 $$locbase i146                 ; load word
addi $r153 $$locbase i840               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r154 $$locbase i512               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r154 $r153 i24                    ; copy memory
addi $r155 $$locbase i272               ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r152                       ; [call: abi_encode_21]: pass argument 0
move $$arg1 $r154                       ; [call: abi_encode_21]: pass argument 1
move $$arg2 $r155                       ; [call: abi_encode_21]: pass argument 2
fncall .10                              ; [call: abi_encode_21]: call function
addi $r157 $$locbase i912               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r157 $r155 i24                    ; copy memory
addi $r158 $$locbase i912               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r159 $$locbase i1008              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r159 $r158 i24                    ; copy memory
addi $r160 $$locbase i1008              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r161 $$locbase i624               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r161 $r160 i24                    ; copy memory
move $r118 $r161                        ; move parameter from branch to block argument
.93
addi $r165 $$locbase i648               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r165 $r118 i24                    ; copy memory
move $r166 $r165                        ; move parameter from branch to block argument
ji  .94
.84
addi $r167 $$locbase i96                ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
addi $r168 $r167 i55                    ; get offset to aggregate element
lb $r169 $r168 i0                       ; load byte
addi $r170 $$locbase i720               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r171 $$locbase i440               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r171 $r170 i24                    ; copy memory
addi $r172 $$locbase i200               ; get offset to local __ptr { { ptr, u64, u64 } }
movi $$arg0 i2                          ; [call: abi_encode_21]: pass argument 0
move $$arg1 $r171                       ; [call: abi_encode_21]: pass argument 1
move $$arg2 $r172                       ; [call: abi_encode_21]: pass argument 2
fncall .10                              ; [call: abi_encode_21]: call function
addi $r175 $$locbase i936               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r175 $r172 i24                    ; copy memory
addi $r176 $$locbase i936               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r177 $$locbase i560               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r177 $r176 i24                    ; copy memory
addi $r178 $$locbase i320               ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r169                       ; [call: abi_encode_23]: pass argument 0
move $$arg1 $r177                       ; [call: abi_encode_23]: pass argument 1
move $$arg2 $r178                       ; [call: abi_encode_23]: pass argument 2
fncall .12                              ; [call: abi_encode_23]: call function
addi $r180 $$locbase i960               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r180 $r178 i24                    ; copy memory
addi $r181 $$locbase i960               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r182 $$locbase i648               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r182 $r181 i24                    ; copy memory
move $r166 $r182                        ; move parameter from branch to block argument
.94
addi $r186 $$locbase i672               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r186 $r166 i24                    ; copy memory
move $r187 $r186                        ; move parameter from branch to block argument
ji  .95
.82
addi $r188 $$locbase i96                ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
addi $r189 $r188 i55                    ; get offset to aggregate element
lb $r190 $r189 i0                       ; load byte
addi $r191 $$locbase i720               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r192 $$locbase i416               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r192 $r191 i24                    ; copy memory
addi $r193 $$locbase i176               ; get offset to local __ptr { { ptr, u64, u64 } }
movi $$arg0 i1                          ; [call: abi_encode_21]: pass argument 0
move $$arg1 $r192                       ; [call: abi_encode_21]: pass argument 1
move $$arg2 $r193                       ; [call: abi_encode_21]: pass argument 2
fncall .10                              ; [call: abi_encode_21]: call function
addi $r195 $$locbase i816               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r195 $r193 i24                    ; copy memory
addi $r196 $$locbase i816               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r197 $$locbase i744               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r197 $r196 i24                    ; copy memory
addi $r198 $$locbase i368               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r199 $$locbase i744               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $$locbase $r199 i24                ; copy memory
addi $r201 $$locbase i48                ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r201 $$locbase i24                ; copy memory
lw $r202 $$locbase i6                   ; load word
lw $r204 $$locbase i7                   ; load word
lw $r206 $$locbase i8                   ; load word
addi $r207 $r206 i1
gt $r208 $r207 $r204
move $r209 $r202                        ; move parameter from branch to block argument
move $r210 $r204                        ; move parameter from branch to block argument
jnzi $r208 .96
ji  .97
.96
muli $r212 $r204 i2
addi $r213 $r212 i1
aloc $r213
mcp $hp $r202 $r206
move $r209 $hp                          ; move parameter from branch to block argument
move $r210 $r213                        ; move parameter from branch to block argument
.97
move $r218 $r209                        ; move parameter from branch to block argument
move $r220 $r210                        ; move parameter from branch to block argument
add $r221 $r209 $r206
sb $r221 $r190 i0                       ; store byte
addi $r222 $$locbase i72                ; get offset to local __ptr { ptr, u64, u64 }
sw $$locbase $r218 i9                   ; store word
sw $$locbase $r220 i10                  ; store word
sw $$locbase $r207 i11                  ; store word
addi $r226 $$locbase i24                ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r226 $r222 i24                    ; copy memory
mcpi $r198 $r226 i24                    ; copy memory
addi $r227 $$locbase i888               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r227 $r198 i24                    ; copy memory
addi $r228 $$locbase i888               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r229 $$locbase i672               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r229 $r228 i24                    ; copy memory
move $r187 $r229                        ; move parameter from branch to block argument
.95
addi $r233 $$locbase i696               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r233 $r187 i24                    ; copy memory
move $r234 $r233                        ; move parameter from branch to block argument
ji  .98
.80
addi $r235 $$locbase i720               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r236 $$locbase i392               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r236 $r235 i24                    ; copy memory
addi $r237 $$locbase i152               ; get offset to local __ptr { { ptr, u64, u64 } }
movi $$arg0 i0                          ; [call: abi_encode_21]: pass argument 0
move $$arg1 $r236                       ; [call: abi_encode_21]: pass argument 1
move $$arg2 $r237                       ; [call: abi_encode_21]: pass argument 2
fncall .10                              ; [call: abi_encode_21]: call function
addi $r239 $$locbase i696               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r239 $r237 i24                    ; copy memory
move $r234 $r239                        ; move parameter from branch to block argument
.98
addi $r243 $$locbase i1080              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r243 $r234 i24                    ; copy memory
addi $r244 $$locbase i1080              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r69 $r244 i24                     ; copy memory
.9
cfsi i1288                              ; [fn end: abi_encode_20] free: locals 1288 byte(s), call args 0 slot(s)
move $$reta $r70                        ; [fn end: abi_encode_20] restore return address
popa .8                                 ; [fn end: abi_encode_20] restore all used registers
jal $zero $$reta i0                     ; [fn end: abi_encode_20] return from call
DIFF------------------------------
.program:
.8                                      ; --- start of function: abi_encode_20 ---
pusha .8                                ; [fn init: abi_encode_20]: push all used registers to stack
move $$locbase $sp                      ; [fn init: abi_encode_20]: set locals base register
cfei i1288                              ; [fn init: abi_encode_20]: allocate: locals 1288 byte(s), call args 0 slot(s)
move $r68 $$arg1                        ; [fn init: abi_encode_20]: copy argument 1 (buffer)
move $r69 $$arg2                        ; [fn init: abi_encode_20]: copy argument 2 (__ret_value)
move $r70 $$reta                        ; [fn init: abi_encode_20]: save return address
.79
addi $r71 $$locbase i1104               ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
mcpi $r71 $$arg0 i56                    ; copy memory
addi $r72 $$locbase i720                ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r72 $r68 i24                      ; copy memory
addi $r73 $$locbase i1104               ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
addi $r74 $$locbase i96                 ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
mcpi $r74 $r73 i56                      ; copy memory
lw $r76 $$locbase i12                   ; load word
eq $r77 $r76 $zero
jnzi $r77 .80
.81
lw $r79 $$locbase i12                   ; load word
eq $r80 $r79 $one
jnzi $r80 .82
.83
lw $r82 $$locbase i12                   ; load word
movi $r83 i2                            ; initialize constant into register
eq $r84 $r82 $r83
jnzi $r84 .84
.85
lw $r86 $$locbase i12                   ; load word
movi $r87 i3                            ; initialize constant into register
eq $r88 $r86 $r87
jnzi $r88 .86
.87
lw $r90 $$locbase i12                   ; load word
movi $r91 i4                            ; initialize constant into register
eq $r92 $r90 $r91
jnzi $r92 .88
.89
load $r93 data_NonConfigurable_6        ; load constant from data section
rvrt $r93
.88
addi $r94 $$locbase i96                 ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
addi $r95 $r94 i8                       ; get offset to aggregate element
addi $r96 $$locbase i1240               ; get offset to local __ptr [slice; 3]
mcpi $r96 $r95 i48                      ; copy memory
addi $r97 $$locbase i720                ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r98 $$locbase i536                ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r98 $r97 i24                      ; copy memory
addi $r99 $$locbase i296                ; get offset to local __ptr { { ptr, u64, u64 } }
movi $$arg0 i4                          ; [call: abi_encode_21]: pass argument 0
move $$arg1 $r98                        ; [call: abi_encode_21]: pass argument 1
move $$arg2 $r99                        ; [call: abi_encode_21]: pass argument 2
fncall .10                              ; [call: abi_encode_21]: call function
addi $r102 $$locbase i1032              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r102 $r99 i24                     ; copy memory
addi $r103 $$locbase i1240              ; get offset to local __ptr [slice; 3]
addi $r104 $$locbase i1032              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r105 $$locbase i1176              ; get offset to local __ptr [slice; 3]
mcpi $r105 $r103 i48                    ; copy memory
addi $r106 $$locbase i792               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r106 $r104 i24                    ; copy memory
addi $r107 $$locbase i792               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r108 $$locbase i864               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r108 $r107 i24                    ; copy memory
movi $r109 i0                           ; move parameter from branch to block argument
.90
move $r111 $r109                        ; move parameter from branch to block argument
movi $r112 i3                           ; initialize constant into register
lt $r113 $r109 $r112
jnzi $r113 .91
.92
addi $r114 $$locbase i864               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r115 $$locbase i1056              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r115 $r114 i24                    ; copy memory
addi $r116 $$locbase i1056              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r117 $$locbase i624               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r117 $r116 i24                    ; copy memory
move $r118 $r117                        ; move parameter from branch to block argument
ji  .93
.91
addi $r119 $$locbase i1176              ; get offset to local __ptr [slice; 3]
muli $r121 $r111 i16                    ; get offset to array element
add $r121 $r119 $r121                   ; add array element offset to array base
addi $r122 $$locbase i864               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r123 $$locbase i584               ; get offset to local __ptr slice
mcpi $r123 $r121 i16                    ; copy memory
addi $r124 $$locbase i600               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r124 $r122 i24                    ; copy memory
addi $r125 $$locbase i344               ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r123                       ; [call: abi_encode_27]: pass argument 0
move $$arg1 $r124                       ; [call: abi_encode_27]: pass argument 1
move $$arg2 $r125                       ; [call: abi_encode_27]: pass argument 2
fncall .14                              ; [call: abi_encode_27]: call function
addi $r127 $$locbase i864               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r127 $r125 i24                    ; copy memory
addi $r128 $r111 i1
move $r109 $r128                        ; move parameter from branch to block argument
ji  .90
.86
addi $r130 $$locbase i96                ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
addi $r131 $r130 i40                    ; get offset to aggregate element
addi $r132 $$locbase i1224              ; get offset to local __ptr { u64, u64 }
mcpi $r132 $r131 i16                    ; copy memory
addi $r133 $$locbase i720               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r134 $$locbase i464               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r134 $r133 i24                    ; copy memory
addi $r135 $$locbase i224               ; get offset to local __ptr { { ptr, u64, u64 } }
movi $$arg0 i3                          ; [call: abi_encode_21]: pass argument 0
move $$arg1 $r134                       ; [call: abi_encode_21]: pass argument 1
move $$arg2 $r135                       ; [call: abi_encode_21]: pass argument 2
fncall .10                              ; [call: abi_encode_21]: call function
addi $r138 $$locbase i984               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r138 $r135 i24                    ; copy memory
addi $r139 $$locbase i1224              ; get offset to local __ptr { u64, u64 }
addi $r140 $$locbase i984               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r141 $$locbase i1160              ; get offset to local __ptr { u64, u64 }
mcpi $r141 $r139 i16                    ; copy memory
addi $r142 $$locbase i768               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r142 $r140 i24                    ; copy memory
lw $r144 $$locbase i145                 ; load word
addi $r145 $$locbase i768               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r146 $$locbase i488               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r146 $r145 i24                    ; copy memory
addi $r147 $$locbase i248               ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r144                       ; [call: abi_encode_21]: pass argument 0
move $$arg1 $r146                       ; [call: abi_encode_21]: pass argument 1
move $$arg2 $r147                       ; [call: abi_encode_21]: pass argument 2
fncall .10                              ; [call: abi_encode_21]: call function
addi $r149 $$locbase i840               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r149 $r147 i24                    ; copy memory
lw $r152 $$locbase i146                 ; load word
addi $r153 $$locbase i840               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r154 $$locbase i512               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r154 $r153 i24                    ; copy memory
addi $r155 $$locbase i272               ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r152                       ; [call: abi_encode_21]: pass argument 0
move $$arg1 $r154                       ; [call: abi_encode_21]: pass argument 1
move $$arg2 $r155                       ; [call: abi_encode_21]: pass argument 2
fncall .10                              ; [call: abi_encode_21]: call function
addi $r157 $$locbase i912               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r157 $r155 i24                    ; copy memory
addi $r158 $$locbase i912               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r159 $$locbase i1008              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r159 $r158 i24                    ; copy memory
addi $r160 $$locbase i1008              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r161 $$locbase i624               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r161 $r160 i24                    ; copy memory
move $r118 $r161                        ; move parameter from branch to block argument
.93
addi $r165 $$locbase i648               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r165 $r118 i24                    ; copy memory
move $r166 $r165                        ; move parameter from branch to block argument
ji  .94
.84
addi $r167 $$locbase i96                ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
addi $r168 $r167 i55                    ; get offset to aggregate element
lb $r169 $r168 i0                       ; load byte
addi $r170 $$locbase i720               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r171 $$locbase i440               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r171 $r170 i24                    ; copy memory
addi $r172 $$locbase i200               ; get offset to local __ptr { { ptr, u64, u64 } }
movi $$arg0 i2                          ; [call: abi_encode_21]: pass argument 0
move $$arg1 $r171                       ; [call: abi_encode_21]: pass argument 1
move $$arg2 $r172                       ; [call: abi_encode_21]: pass argument 2
fncall .10                              ; [call: abi_encode_21]: call function
addi $r175 $$locbase i936               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r175 $r172 i24                    ; copy memory
addi $r176 $$locbase i936               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r177 $$locbase i560               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r177 $r176 i24                    ; copy memory
addi $r178 $$locbase i320               ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r169                       ; [call: abi_encode_23]: pass argument 0
move $$arg1 $r177                       ; [call: abi_encode_23]: pass argument 1
move $$arg2 $r178                       ; [call: abi_encode_23]: pass argument 2
fncall .12                              ; [call: abi_encode_23]: call function
addi $r180 $$locbase i960               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r180 $r178 i24                    ; copy memory
addi $r181 $$locbase i960               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r182 $$locbase i648               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r182 $r181 i24                    ; copy memory
move $r166 $r182                        ; move parameter from branch to block argument
.94
addi $r186 $$locbase i672               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r186 $r166 i24                    ; copy memory
move $r187 $r186                        ; move parameter from branch to block argument
ji  .95
.82
addi $r188 $$locbase i96                ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
addi $r189 $r188 i55                    ; get offset to aggregate element
lb $r190 $r189 i0                       ; load byte
addi $r191 $$locbase i720               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r192 $$locbase i416               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r192 $r191 i24                    ; copy memory
addi $r193 $$locbase i176               ; get offset to local __ptr { { ptr, u64, u64 } }
movi $$arg0 i1                          ; [call: abi_encode_21]: pass argument 0
move $$arg1 $r192                       ; [call: abi_encode_21]: pass argument 1
move $$arg2 $r193                       ; [call: abi_encode_21]: pass argument 2
fncall .10                              ; [call: abi_encode_21]: call function
addi $r195 $$locbase i816               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r195 $r193 i24                    ; copy memory
addi $r196 $$locbase i816               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r197 $$locbase i744               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r197 $r196 i24                    ; copy memory
addi $r198 $$locbase i368               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r199 $$locbase i744               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $$locbase $r199 i24                ; copy memory
addi $r201 $$locbase i48                ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r201 $$locbase i24                ; copy memory
lw $r202 $$locbase i6                   ; load word
lw $r204 $$locbase i7                   ; load word
lw $r206 $$locbase i8                   ; load word
addi $r207 $r206 i1
gt $r208 $r207 $r204
move $r209 $r202                        ; move parameter from branch to block argument
move $r210 $r204                        ; move parameter from branch to block argument
jnzi $r208 .96
ji  .97
.96
muli $r212 $r204 i2
addi $r213 $r212 i1
aloc $r213
mcp $hp $r202 $r206
move $r209 $hp                          ; move parameter from branch to block argument
move $r210 $r213                        ; move parameter from branch to block argument
.97
move $r218 $r209                        ; move parameter from branch to block argument
move $r220 $r210                        ; move parameter from branch to block argument
add $r221 $r209 $r206
sb $r221 $r190 i0                       ; store byte
addi $r222 $$locbase i72                ; get offset to local __ptr { ptr, u64, u64 }
sw $$locbase $r218 i9                   ; store word
sw $$locbase $r220 i10                  ; store word
sw $$locbase $r207 i11                  ; store word
addi $r226 $$locbase i24                ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r226 $r222 i24                    ; copy memory
mcpi $r198 $r226 i24                    ; copy memory
addi $r227 $$locbase i888               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r227 $r198 i24                    ; copy memory
addi $r228 $$locbase i888               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r229 $$locbase i672               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r229 $r228 i24                    ; copy memory
move $r187 $r229                        ; move parameter from branch to block argument
.95
addi $r233 $$locbase i696               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r233 $r187 i24                    ; copy memory
move $r234 $r233                        ; move parameter from branch to block argument
ji  .98
.80
addi $r235 $$locbase i720               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r236 $$locbase i392               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r236 $r235 i24                    ; copy memory
addi $r237 $$locbase i152               ; get offset to local __ptr { { ptr, u64, u64 } }
movi $$arg0 i0                          ; [call: abi_encode_21]: pass argument 0
move $$arg1 $r236                       ; [call: abi_encode_21]: pass argument 1
move $$arg2 $r237                       ; [call: abi_encode_21]: pass argument 2
fncall .10                              ; [call: abi_encode_21]: call function
addi $r239 $$locbase i696               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r239 $r237 i24                    ; copy memory
move $r234 $r239                        ; move parameter from branch to block argument
.98
addi $r243 $$locbase i1080              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r243 $r234 i24                    ; copy memory
addi $r244 $$locbase i1080              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r69 $r244 i24                     ; copy memory
.9
cfsi i1288                              ; [fn end: abi_encode_20] free: locals 1288 byte(s), call args 0 slot(s)
move $$reta $r70                        ; [fn end: abi_encode_20] restore return address
popa .8                                 ; [fn end: abi_encode_20] restore all used registers
jal $zero $$reta i0                     ; [fn end: abi_encode_20] return from call
DIFF------------------------------
.program:
.10                                     ; --- start of function: abi_encode_21 ---
pusha .10                               ; [fn init: abi_encode_21]: push all used registers to stack
move $$locbase $sp                      ; [fn init: abi_encode_21]: set locals base register
cfei i144                               ; [fn init: abi_encode_21]: allocate: locals 144 byte(s), call args 0 slot(s)
.99
addi $r246 $$locbase i120               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r246 $$arg1 i24                   ; copy memory
addi $r247 $$locbase i96                ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r248 $$locbase i120               ; get offset to local __ptr { { ptr, u64, u64 } }
move $r249 $r248                        ; return value from ASM block with return register buffer
 mcpi $$locbase $r249 i24                ; copy memory
 mcpi $$locbase $r248 i24                ; copy memory
addi $r250 $$locbase i48                ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r250 $$locbase i24                ; copy memory
lw $r251 $$locbase i6                   ; load word
addi $r252 $r250 i8                     ; get offset to aggregate element
lw $r253 $$locbase i7                   ; load word
addi $r254 $r250 i16                    ; get offset to aggregate element
lw $r255 $$locbase i8                   ; load word
movi $r256 i8                           ; initialize constant into register
 add $r257 $r255 $r256
 addi $r257 $r255 i8
gt $r258 $r257 $r253
move $r259 $r251                        ; move parameter from branch to block argument
move $r260 $r253                        ; move parameter from branch to block argument
jnzi $r258 .100
ji  .101
.100
movi $r261 i2                           ; initialize constant into register
 mul $r262 $r253 $r261
 muli $r262 $r253 i2
movi $r263 i8                           ; initialize constant into register
 add $r264 $r262 $r263
 addi $r264 $r262 i8
aloc $r264
mcp $hp $r251 $r255
move $r265 $hp                          ; return value from ASM block with return register hp
 move $r259 $r265                        ; move parameter from branch to block argument
 move $r259 $hp                          ; move parameter from branch to block argument
move $r260 $r264                        ; move parameter from branch to block argument
ji  .101
.101
move $r269 $r259                        ; move parameter from branch to block argument
move $r271 $r260                        ; move parameter from branch to block argument
 add $r272 $r269 $r255
 add $r272 $r259 $r255
sw $r272 $$arg0 i0                      ; store word
addi $r273 $$locbase i72                ; get offset to local __ptr { ptr, u64, u64 }
sw $$locbase $r269 i9                   ; store word
addi $r274 $r273 i8                     ; get offset to aggregate element
sw $$locbase $r271 i10                  ; store word
addi $r275 $r273 i16                    ; get offset to aggregate element
sw $$locbase $r257 i11                  ; store word
move $r276 $r273                        ; return value from ASM block with return register buffer
addi $r277 $$locbase i24                ; get offset to local __ptr { ptr, u64, u64 }
 mcpi $r277 $r276 i24                    ; copy memory
 mcpi $r277 $r273 i24                    ; copy memory
mcpi $r247 $r277 i24                    ; copy memory
mcpi $$arg2 $r247 i24                   ; copy memory
ji  .11
.11
cfsi i144                               ; [fn end: abi_encode_21] free: locals 144 byte(s), call args 0 slot(s)
popa .10                                ; [fn end: abi_encode_21] restore all used registers
jal $zero $$reta i0                     ; [fn end: abi_encode_21] return from call
DIFF------------------------------
.program:
.10                                     ; --- start of function: abi_encode_21 ---
pusha .10                               ; [fn init: abi_encode_21]: push all used registers to stack
move $$locbase $sp                      ; [fn init: abi_encode_21]: set locals base register
cfei i144                               ; [fn init: abi_encode_21]: allocate: locals 144 byte(s), call args 0 slot(s)
.99
addi $r246 $$locbase i120               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r246 $$arg1 i24                   ; copy memory
addi $r247 $$locbase i96                ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r248 $$locbase i120               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $$locbase $r248 i24                ; copy memory
addi $r250 $$locbase i48                ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r250 $$locbase i24                ; copy memory
lw $r251 $$locbase i6                   ; load word
lw $r253 $$locbase i7                   ; load word
lw $r255 $$locbase i8                   ; load word
addi $r257 $r255 i8
gt $r258 $r257 $r253
move $r259 $r251                        ; move parameter from branch to block argument
move $r260 $r253                        ; move parameter from branch to block argument
jnzi $r258 .100
ji  .101
.100
muli $r262 $r253 i2
addi $r264 $r262 i8
aloc $r264
mcp $hp $r251 $r255
move $r259 $hp                          ; move parameter from branch to block argument
move $r260 $r264                        ; move parameter from branch to block argument
.101
move $r269 $r259                        ; move parameter from branch to block argument
move $r271 $r260                        ; move parameter from branch to block argument
add $r272 $r259 $r255
sw $r272 $$arg0 i0                      ; store word
addi $r273 $$locbase i72                ; get offset to local __ptr { ptr, u64, u64 }
sw $$locbase $r269 i9                   ; store word
sw $$locbase $r271 i10                  ; store word
sw $$locbase $r257 i11                  ; store word
addi $r277 $$locbase i24                ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r277 $r273 i24                    ; copy memory
mcpi $r247 $r277 i24                    ; copy memory
mcpi $$arg2 $r247 i24                   ; copy memory
.11
cfsi i144                               ; [fn end: abi_encode_21] free: locals 144 byte(s), call args 0 slot(s)
popa .10                                ; [fn end: abi_encode_21] restore all used registers
jal $zero $$reta i0                     ; [fn end: abi_encode_21] return from call
DIFF------------------------------
.program:
.10                                     ; --- start of function: abi_encode_21 ---
pusha .10                               ; [fn init: abi_encode_21]: push all used registers to stack
move $$locbase $sp                      ; [fn init: abi_encode_21]: set locals base register
cfei i144                               ; [fn init: abi_encode_21]: allocate: locals 144 byte(s), call args 0 slot(s)
.99
addi $r246 $$locbase i120               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r246 $$arg1 i24                   ; copy memory
addi $r247 $$locbase i96                ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r248 $$locbase i120               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $$locbase $r248 i24                ; copy memory
addi $r250 $$locbase i48                ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r250 $$locbase i24                ; copy memory
lw $r251 $$locbase i6                   ; load word
lw $r253 $$locbase i7                   ; load word
lw $r255 $$locbase i8                   ; load word
addi $r257 $r255 i8
gt $r258 $r257 $r253
move $r259 $r251                        ; move parameter from branch to block argument
move $r260 $r253                        ; move parameter from branch to block argument
jnzi $r258 .100
ji  .101
.100
muli $r262 $r253 i2
addi $r264 $r262 i8
aloc $r264
mcp $hp $r251 $r255
move $r259 $hp                          ; move parameter from branch to block argument
move $r260 $r264                        ; move parameter from branch to block argument
.101
move $r269 $r259                        ; move parameter from branch to block argument
move $r271 $r260                        ; move parameter from branch to block argument
add $r272 $r259 $r255
sw $r272 $$arg0 i0                      ; store word
addi $r273 $$locbase i72                ; get offset to local __ptr { ptr, u64, u64 }
sw $$locbase $r269 i9                   ; store word
sw $$locbase $r271 i10                  ; store word
sw $$locbase $r257 i11                  ; store word
addi $r277 $$locbase i24                ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r277 $r273 i24                    ; copy memory
mcpi $r247 $r277 i24                    ; copy memory
mcpi $$arg2 $r247 i24                   ; copy memory
.11
cfsi i144                               ; [fn end: abi_encode_21] free: locals 144 byte(s), call args 0 slot(s)
popa .10                                ; [fn end: abi_encode_21] restore all used registers
jal $zero $$reta i0                     ; [fn end: abi_encode_21] return from call
DIFF------------------------------
.program:
.10                                     ; --- start of function: abi_encode_21 ---
pusha .10                               ; [fn init: abi_encode_21]: push all used registers to stack
move $$locbase $sp                      ; [fn init: abi_encode_21]: set locals base register
cfei i144                               ; [fn init: abi_encode_21]: allocate: locals 144 byte(s), call args 0 slot(s)
.99
addi $r246 $$locbase i120               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r246 $$arg1 i24                   ; copy memory
addi $r247 $$locbase i96                ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r248 $$locbase i120               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $$locbase $r248 i24                ; copy memory
addi $r250 $$locbase i48                ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r250 $$locbase i24                ; copy memory
lw $r251 $$locbase i6                   ; load word
lw $r253 $$locbase i7                   ; load word
lw $r255 $$locbase i8                   ; load word
addi $r257 $r255 i8
gt $r258 $r257 $r253
move $r259 $r251                        ; move parameter from branch to block argument
move $r260 $r253                        ; move parameter from branch to block argument
jnzi $r258 .100
ji  .101
.100
muli $r262 $r253 i2
addi $r264 $r262 i8
aloc $r264
mcp $hp $r251 $r255
move $r259 $hp                          ; move parameter from branch to block argument
move $r260 $r264                        ; move parameter from branch to block argument
.101
move $r269 $r259                        ; move parameter from branch to block argument
move $r271 $r260                        ; move parameter from branch to block argument
add $r272 $r259 $r255
sw $r272 $$arg0 i0                      ; store word
addi $r273 $$locbase i72                ; get offset to local __ptr { ptr, u64, u64 }
sw $$locbase $r269 i9                   ; store word
sw $$locbase $r271 i10                  ; store word
sw $$locbase $r257 i11                  ; store word
addi $r277 $$locbase i24                ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r277 $r273 i24                    ; copy memory
mcpi $r247 $r277 i24                    ; copy memory
mcpi $$arg2 $r247 i24                   ; copy memory
.11
cfsi i144                               ; [fn end: abi_encode_21] free: locals 144 byte(s), call args 0 slot(s)
popa .10                                ; [fn end: abi_encode_21] restore all used registers
jal $zero $$reta i0                     ; [fn end: abi_encode_21] return from call
DIFF------------------------------
.program:
.12                                     ; --- start of function: abi_encode_23 ---
pusha .12                               ; [fn init: abi_encode_23]: push all used registers to stack
move $$locbase $sp                      ; [fn init: abi_encode_23]: set locals base register
cfei i144                               ; [fn init: abi_encode_23]: allocate: locals 144 byte(s), call args 0 slot(s)
.102
addi $r279 $$locbase i120               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r279 $$arg1 i24                   ; copy memory
addi $r280 $$locbase i96                ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r281 $$locbase i120               ; get offset to local __ptr { { ptr, u64, u64 } }
move $r282 $r281                        ; return value from ASM block with return register buffer
 mcpi $$locbase $r282 i24                ; copy memory
 mcpi $$locbase $r281 i24                ; copy memory
addi $r283 $$locbase i48                ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r283 $$locbase i24                ; copy memory
lw $r284 $$locbase i6                   ; load word
addi $r285 $r283 i8                     ; get offset to aggregate element
lw $r286 $$locbase i7                   ; load word
addi $r287 $r283 i16                    ; get offset to aggregate element
lw $r288 $$locbase i8                   ; load word
 add $r289 $r288 $one
 addi $r289 $r288 i1
gt $r290 $r289 $r286
move $r291 $r284                        ; move parameter from branch to block argument
move $r292 $r286                        ; move parameter from branch to block argument
jnzi $r290 .103
ji  .104
.103
movi $r293 i2                           ; initialize constant into register
 mul $r294 $r286 $r293
 add $r295 $r294 $one
 muli $r294 $r286 i2
 addi $r295 $r294 i1
aloc $r295
mcp $hp $r284 $r288
move $r296 $hp                          ; return value from ASM block with return register hp
 move $r291 $r296                        ; move parameter from branch to block argument
 move $r291 $hp                          ; move parameter from branch to block argument
move $r292 $r295                        ; move parameter from branch to block argument
ji  .104
.104
move $r300 $r291                        ; move parameter from branch to block argument
move $r302 $r292                        ; move parameter from branch to block argument
 add $r303 $r300 $r288
 add $r303 $r291 $r288
sb $r303 $$arg0 i0                      ; store byte
addi $r304 $$locbase i72                ; get offset to local __ptr { ptr, u64, u64 }
sw $$locbase $r300 i9                   ; store word
addi $r305 $r304 i8                     ; get offset to aggregate element
sw $$locbase $r302 i10                  ; store word
addi $r306 $r304 i16                    ; get offset to aggregate element
sw $$locbase $r289 i11                  ; store word
move $r307 $r304                        ; return value from ASM block with return register buffer
addi $r308 $$locbase i24                ; get offset to local __ptr { ptr, u64, u64 }
 mcpi $r308 $r307 i24                    ; copy memory
 mcpi $r308 $r304 i24                    ; copy memory
mcpi $r280 $r308 i24                    ; copy memory
mcpi $$arg2 $r280 i24                   ; copy memory
ji  .13
.13
cfsi i144                               ; [fn end: abi_encode_23] free: locals 144 byte(s), call args 0 slot(s)
popa .12                                ; [fn end: abi_encode_23] restore all used registers
jal $zero $$reta i0                     ; [fn end: abi_encode_23] return from call
DIFF------------------------------
.program:
.12                                     ; --- start of function: abi_encode_23 ---
pusha .12                               ; [fn init: abi_encode_23]: push all used registers to stack
move $$locbase $sp                      ; [fn init: abi_encode_23]: set locals base register
cfei i144                               ; [fn init: abi_encode_23]: allocate: locals 144 byte(s), call args 0 slot(s)
.102
addi $r279 $$locbase i120               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r279 $$arg1 i24                   ; copy memory
addi $r280 $$locbase i96                ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r281 $$locbase i120               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $$locbase $r281 i24                ; copy memory
addi $r283 $$locbase i48                ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r283 $$locbase i24                ; copy memory
lw $r284 $$locbase i6                   ; load word
lw $r286 $$locbase i7                   ; load word
lw $r288 $$locbase i8                   ; load word
addi $r289 $r288 i1
gt $r290 $r289 $r286
move $r291 $r284                        ; move parameter from branch to block argument
move $r292 $r286                        ; move parameter from branch to block argument
jnzi $r290 .103
ji  .104
.103
muli $r294 $r286 i2
addi $r295 $r294 i1
aloc $r295
mcp $hp $r284 $r288
move $r291 $hp                          ; move parameter from branch to block argument
move $r292 $r295                        ; move parameter from branch to block argument
.104
move $r300 $r291                        ; move parameter from branch to block argument
move $r302 $r292                        ; move parameter from branch to block argument
add $r303 $r291 $r288
sb $r303 $$arg0 i0                      ; store byte
addi $r304 $$locbase i72                ; get offset to local __ptr { ptr, u64, u64 }
sw $$locbase $r300 i9                   ; store word
sw $$locbase $r302 i10                  ; store word
sw $$locbase $r289 i11                  ; store word
addi $r308 $$locbase i24                ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r308 $r304 i24                    ; copy memory
mcpi $r280 $r308 i24                    ; copy memory
mcpi $$arg2 $r280 i24                   ; copy memory
.13
cfsi i144                               ; [fn end: abi_encode_23] free: locals 144 byte(s), call args 0 slot(s)
popa .12                                ; [fn end: abi_encode_23] restore all used registers
jal $zero $$reta i0                     ; [fn end: abi_encode_23] return from call
DIFF------------------------------
.program:
.12                                     ; --- start of function: abi_encode_23 ---
pusha .12                               ; [fn init: abi_encode_23]: push all used registers to stack
move $$locbase $sp                      ; [fn init: abi_encode_23]: set locals base register
cfei i144                               ; [fn init: abi_encode_23]: allocate: locals 144 byte(s), call args 0 slot(s)
.102
addi $r279 $$locbase i120               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r279 $$arg1 i24                   ; copy memory
addi $r280 $$locbase i96                ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r281 $$locbase i120               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $$locbase $r281 i24                ; copy memory
addi $r283 $$locbase i48                ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r283 $$locbase i24                ; copy memory
lw $r284 $$locbase i6                   ; load word
lw $r286 $$locbase i7                   ; load word
lw $r288 $$locbase i8                   ; load word
addi $r289 $r288 i1
gt $r290 $r289 $r286
move $r291 $r284                        ; move parameter from branch to block argument
move $r292 $r286                        ; move parameter from branch to block argument
jnzi $r290 .103
ji  .104
.103
muli $r294 $r286 i2
addi $r295 $r294 i1
aloc $r295
mcp $hp $r284 $r288
move $r291 $hp                          ; move parameter from branch to block argument
move $r292 $r295                        ; move parameter from branch to block argument
.104
move $r300 $r291                        ; move parameter from branch to block argument
move $r302 $r292                        ; move parameter from branch to block argument
add $r303 $r291 $r288
sb $r303 $$arg0 i0                      ; store byte
addi $r304 $$locbase i72                ; get offset to local __ptr { ptr, u64, u64 }
sw $$locbase $r300 i9                   ; store word
sw $$locbase $r302 i10                  ; store word
sw $$locbase $r289 i11                  ; store word
addi $r308 $$locbase i24                ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r308 $r304 i24                    ; copy memory
mcpi $r280 $r308 i24                    ; copy memory
mcpi $$arg2 $r280 i24                   ; copy memory
.13
cfsi i144                               ; [fn end: abi_encode_23] free: locals 144 byte(s), call args 0 slot(s)
popa .12                                ; [fn end: abi_encode_23] restore all used registers
jal $zero $$reta i0                     ; [fn end: abi_encode_23] return from call
DIFF------------------------------
.program:
.12                                     ; --- start of function: abi_encode_23 ---
pusha .12                               ; [fn init: abi_encode_23]: push all used registers to stack
move $$locbase $sp                      ; [fn init: abi_encode_23]: set locals base register
cfei i144                               ; [fn init: abi_encode_23]: allocate: locals 144 byte(s), call args 0 slot(s)
.102
addi $r279 $$locbase i120               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r279 $$arg1 i24                   ; copy memory
addi $r280 $$locbase i96                ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r281 $$locbase i120               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $$locbase $r281 i24                ; copy memory
addi $r283 $$locbase i48                ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r283 $$locbase i24                ; copy memory
lw $r284 $$locbase i6                   ; load word
lw $r286 $$locbase i7                   ; load word
lw $r288 $$locbase i8                   ; load word
addi $r289 $r288 i1
gt $r290 $r289 $r286
move $r291 $r284                        ; move parameter from branch to block argument
move $r292 $r286                        ; move parameter from branch to block argument
jnzi $r290 .103
ji  .104
.103
muli $r294 $r286 i2
addi $r295 $r294 i1
aloc $r295
mcp $hp $r284 $r288
move $r291 $hp                          ; move parameter from branch to block argument
move $r292 $r295                        ; move parameter from branch to block argument
.104
move $r300 $r291                        ; move parameter from branch to block argument
move $r302 $r292                        ; move parameter from branch to block argument
add $r303 $r291 $r288
sb $r303 $$arg0 i0                      ; store byte
addi $r304 $$locbase i72                ; get offset to local __ptr { ptr, u64, u64 }
sw $$locbase $r300 i9                   ; store word
sw $$locbase $r302 i10                  ; store word
sw $$locbase $r289 i11                  ; store word
addi $r308 $$locbase i24                ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r308 $r304 i24                    ; copy memory
mcpi $r280 $r308 i24                    ; copy memory
mcpi $$arg2 $r280 i24                   ; copy memory
.13
cfsi i144                               ; [fn end: abi_encode_23] free: locals 144 byte(s), call args 0 slot(s)
popa .12                                ; [fn end: abi_encode_23] restore all used registers
jal $zero $$reta i0                     ; [fn end: abi_encode_23] return from call
DIFF------------------------------
.program:
.14                                     ; --- start of function: abi_encode_27 ---
pusha .14                               ; [fn init: abi_encode_27]: push all used registers to stack
move $$locbase $sp                      ; [fn init: abi_encode_27]: set locals base register
cfei i224                               ; [fn init: abi_encode_27]: allocate: locals 224 byte(s), call args 0 slot(s)
.105
addi $r310 $$locbase i208               ; get offset to local __ptr slice
mcpi $r310 $$arg0 i16                   ; copy memory
addi $r311 $$locbase i184               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r311 $$arg1 i24                   ; copy memory
addi $r312 $$locbase i160               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r313 $$locbase i184               ; get offset to local __ptr { { ptr, u64, u64 } }
move $r314 $r313                        ; return value from ASM block with return register buffer
 mcpi $$locbase $r314 i24                ; copy memory
 mcpi $$locbase $r313 i24                ; copy memory
addi $r315 $$locbase i80                ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r315 $$locbase i24                ; copy memory
lw $r316 $$locbase i10                  ; load word
addi $r317 $r315 i8                     ; get offset to aggregate element
lw $r318 $$locbase i11                  ; load word
addi $r319 $r315 i16                    ; get offset to aggregate element
lw $r320 $$locbase i12                  ; load word
addi $r321 $$locbase i208               ; get offset to local __ptr slice
addi $r322 $$locbase i40                ; get offset to local __ptr slice
mcpi $r322 $r321 i16                    ; copy memory
move $r323 $r321                        ; return value from ASM block with return register item
addi $r324 $$locbase i24                ; get offset to local __ptr { u64, u64 }
 mcpi $r324 $r323 i16                    ; copy memory
 mcpi $r324 $r321 i16                    ; copy memory
addi $r325 $$locbase i104               ; get offset to local __ptr { u64, u64 }
mcpi $r325 $r324 i16                    ; copy memory
addi $r326 $r325 i8                     ; get offset to aggregate element
lw $r327 $$locbase i14                  ; load word
movi $r328 i8                           ; initialize constant into register
 add $r329 $r327 $r328
 addi $r329 $r327 i8
add $r330 $r320 $r329
gt $r331 $r330 $r318
move $r332 $r316                        ; move parameter from branch to block argument
move $r333 $r318                        ; move parameter from branch to block argument
jnzi $r331 .106
ji  .107
.106
movi $r334 i2                           ; initialize constant into register
 mul $r335 $r318 $r334
 muli $r335 $r318 i2
add $r336 $r335 $r329
aloc $r336
mcp $hp $r316 $r320
move $r337 $hp                          ; return value from ASM block with return register hp
 move $r332 $r337                        ; move parameter from branch to block argument
 move $r332 $hp                          ; move parameter from branch to block argument
move $r333 $r336                        ; move parameter from branch to block argument
ji  .107
.107
move $r341 $r332                        ; move parameter from branch to block argument
move $r343 $r333                        ; move parameter from branch to block argument
addi $r344 $$locbase i120               ; get offset to local __ptr slice
mcpi $r344 $r322 i16                    ; copy memory
add $r345 $r341 $r320
lw $r347 $$locbase i16
sw $r345 $r347 i0
addi $r345 $r345 i8
lw $r346 $$locbase i15
mcp $r345 $r346 $r347
addi $r348 $r320 i8
add $r348 $r348 $r347
move $r349 $r348                        ; return value from ASM block with return register new_len
addi $r350 $$locbase i136               ; get offset to local __ptr { ptr, u64, u64 }
sw $$locbase $r341 i17                  ; store word
addi $r351 $r350 i8                     ; get offset to aggregate element
sw $$locbase $r343 i18                  ; store word
addi $r352 $r350 i16                    ; get offset to aggregate element
sw $$locbase $r349 i19                  ; store word
move $r353 $r350                        ; return value from ASM block with return register buffer
addi $r354 $$locbase i56                ; get offset to local __ptr { ptr, u64, u64 }
 mcpi $r354 $r353 i24                    ; copy memory
 mcpi $r354 $r350 i24                    ; copy memory
mcpi $r312 $r354 i24                    ; copy memory
mcpi $$arg2 $r312 i24                   ; copy memory
ji  .15
.15
cfsi i224                               ; [fn end: abi_encode_27] free: locals 224 byte(s), call args 0 slot(s)
popa .14                                ; [fn end: abi_encode_27] restore all used registers
jal $zero $$reta i0                     ; [fn end: abi_encode_27] return from call
DIFF------------------------------
.program:
.14                                     ; --- start of function: abi_encode_27 ---
pusha .14                               ; [fn init: abi_encode_27]: push all used registers to stack
move $$locbase $sp                      ; [fn init: abi_encode_27]: set locals base register
cfei i224                               ; [fn init: abi_encode_27]: allocate: locals 224 byte(s), call args 0 slot(s)
.105
addi $r310 $$locbase i208               ; get offset to local __ptr slice
mcpi $r310 $$arg0 i16                   ; copy memory
addi $r311 $$locbase i184               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r311 $$arg1 i24                   ; copy memory
addi $r312 $$locbase i160               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r313 $$locbase i184               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $$locbase $r313 i24                ; copy memory
addi $r315 $$locbase i80                ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r315 $$locbase i24                ; copy memory
lw $r316 $$locbase i10                  ; load word
lw $r318 $$locbase i11                  ; load word
lw $r320 $$locbase i12                  ; load word
addi $r321 $$locbase i208               ; get offset to local __ptr slice
addi $r322 $$locbase i40                ; get offset to local __ptr slice
mcpi $r322 $r321 i16                    ; copy memory
addi $r324 $$locbase i24                ; get offset to local __ptr { u64, u64 }
mcpi $r324 $r321 i16                    ; copy memory
addi $r325 $$locbase i104               ; get offset to local __ptr { u64, u64 }
mcpi $r325 $r324 i16                    ; copy memory
lw $r327 $$locbase i14                  ; load word
addi $r329 $r327 i8
add $r330 $r320 $r329
gt $r331 $r330 $r318
move $r332 $r316                        ; move parameter from branch to block argument
move $r333 $r318                        ; move parameter from branch to block argument
jnzi $r331 .106
ji  .107
.106
muli $r335 $r318 i2
add $r336 $r335 $r329
aloc $r336
mcp $hp $r316 $r320
move $r332 $hp                          ; move parameter from branch to block argument
move $r333 $r336                        ; move parameter from branch to block argument
.107
move $r341 $r332                        ; move parameter from branch to block argument
move $r343 $r333                        ; move parameter from branch to block argument
addi $r344 $$locbase i120               ; get offset to local __ptr slice
mcpi $r344 $r322 i16                    ; copy memory
add $r345 $r341 $r320
lw $r347 $$locbase i16
sw $r345 $r347 i0
addi $r345 $r345 i8
lw $r346 $$locbase i15
mcp $r345 $r346 $r347
addi $r348 $r320 i8
add $r348 $r348 $r347
move $r349 $r348                        ; return value from ASM block with return register new_len
addi $r350 $$locbase i136               ; get offset to local __ptr { ptr, u64, u64 }
sw $$locbase $r341 i17                  ; store word
sw $$locbase $r343 i18                  ; store word
sw $$locbase $r349 i19                  ; store word
addi $r354 $$locbase i56                ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r354 $r350 i24                    ; copy memory
mcpi $r312 $r354 i24                    ; copy memory
mcpi $$arg2 $r312 i24                   ; copy memory
.15
cfsi i224                               ; [fn end: abi_encode_27] free: locals 224 byte(s), call args 0 slot(s)
popa .14                                ; [fn end: abi_encode_27] restore all used registers
jal $zero $$reta i0                     ; [fn end: abi_encode_27] return from call
DIFF------------------------------
.program:
.14                                     ; --- start of function: abi_encode_27 ---
pusha .14                               ; [fn init: abi_encode_27]: push all used registers to stack
move $$locbase $sp                      ; [fn init: abi_encode_27]: set locals base register
cfei i224                               ; [fn init: abi_encode_27]: allocate: locals 224 byte(s), call args 0 slot(s)
.105
addi $r310 $$locbase i208               ; get offset to local __ptr slice
mcpi $r310 $$arg0 i16                   ; copy memory
addi $r311 $$locbase i184               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r311 $$arg1 i24                   ; copy memory
addi $r312 $$locbase i160               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r313 $$locbase i184               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $$locbase $r313 i24                ; copy memory
addi $r315 $$locbase i80                ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r315 $$locbase i24                ; copy memory
lw $r316 $$locbase i10                  ; load word
lw $r318 $$locbase i11                  ; load word
lw $r320 $$locbase i12                  ; load word
addi $r321 $$locbase i208               ; get offset to local __ptr slice
addi $r322 $$locbase i40                ; get offset to local __ptr slice
mcpi $r322 $r321 i16                    ; copy memory
addi $r324 $$locbase i24                ; get offset to local __ptr { u64, u64 }
mcpi $r324 $r321 i16                    ; copy memory
addi $r325 $$locbase i104               ; get offset to local __ptr { u64, u64 }
mcpi $r325 $r324 i16                    ; copy memory
lw $r327 $$locbase i14                  ; load word
addi $r329 $r327 i8
add $r330 $r320 $r329
gt $r331 $r330 $r318
move $r332 $r316                        ; move parameter from branch to block argument
move $r333 $r318                        ; move parameter from branch to block argument
jnzi $r331 .106
ji  .107
.106
muli $r335 $r318 i2
add $r336 $r335 $r329
aloc $r336
mcp $hp $r316 $r320
move $r332 $hp                          ; move parameter from branch to block argument
move $r333 $r336                        ; move parameter from branch to block argument
.107
move $r341 $r332                        ; move parameter from branch to block argument
move $r343 $r333                        ; move parameter from branch to block argument
addi $r344 $$locbase i120               ; get offset to local __ptr slice
mcpi $r344 $r322 i16                    ; copy memory
add $r345 $r341 $r320
lw $r347 $$locbase i16
sw $r345 $r347 i0
addi $r345 $r345 i8
lw $r346 $$locbase i15
mcp $r345 $r346 $r347
addi $r348 $r320 i8
add $r348 $r348 $r347
move $r349 $r348                        ; return value from ASM block with return register new_len
addi $r350 $$locbase i136               ; get offset to local __ptr { ptr, u64, u64 }
sw $$locbase $r341 i17                  ; store word
sw $$locbase $r343 i18                  ; store word
sw $$locbase $r349 i19                  ; store word
addi $r354 $$locbase i56                ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r354 $r350 i24                    ; copy memory
mcpi $r312 $r354 i24                    ; copy memory
mcpi $$arg2 $r312 i24                   ; copy memory
.15
cfsi i224                               ; [fn end: abi_encode_27] free: locals 224 byte(s), call args 0 slot(s)
popa .14                                ; [fn end: abi_encode_27] restore all used registers
jal $zero $$reta i0                     ; [fn end: abi_encode_27] return from call
DIFF------------------------------
.program:
.14                                     ; --- start of function: abi_encode_27 ---
pusha .14                               ; [fn init: abi_encode_27]: push all used registers to stack
move $$locbase $sp                      ; [fn init: abi_encode_27]: set locals base register
cfei i224                               ; [fn init: abi_encode_27]: allocate: locals 224 byte(s), call args 0 slot(s)
.105
addi $r310 $$locbase i208               ; get offset to local __ptr slice
mcpi $r310 $$arg0 i16                   ; copy memory
addi $r311 $$locbase i184               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r311 $$arg1 i24                   ; copy memory
addi $r312 $$locbase i160               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r313 $$locbase i184               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $$locbase $r313 i24                ; copy memory
addi $r315 $$locbase i80                ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r315 $$locbase i24                ; copy memory
lw $r316 $$locbase i10                  ; load word
lw $r318 $$locbase i11                  ; load word
lw $r320 $$locbase i12                  ; load word
addi $r321 $$locbase i208               ; get offset to local __ptr slice
addi $r322 $$locbase i40                ; get offset to local __ptr slice
mcpi $r322 $r321 i16                    ; copy memory
addi $r324 $$locbase i24                ; get offset to local __ptr { u64, u64 }
mcpi $r324 $r321 i16                    ; copy memory
addi $r325 $$locbase i104               ; get offset to local __ptr { u64, u64 }
mcpi $r325 $r324 i16                    ; copy memory
lw $r327 $$locbase i14                  ; load word
addi $r329 $r327 i8
add $r330 $r320 $r329
gt $r331 $r330 $r318
move $r332 $r316                        ; move parameter from branch to block argument
move $r333 $r318                        ; move parameter from branch to block argument
jnzi $r331 .106
ji  .107
.106
muli $r335 $r318 i2
add $r336 $r335 $r329
aloc $r336
mcp $hp $r316 $r320
move $r332 $hp                          ; move parameter from branch to block argument
move $r333 $r336                        ; move parameter from branch to block argument
.107
move $r341 $r332                        ; move parameter from branch to block argument
move $r343 $r333                        ; move parameter from branch to block argument
addi $r344 $$locbase i120               ; get offset to local __ptr slice
mcpi $r344 $r322 i16                    ; copy memory
add $r345 $r341 $r320
lw $r347 $$locbase i16
sw $r345 $r347 i0
addi $r345 $r345 i8
lw $r346 $$locbase i15
mcp $r345 $r346 $r347
addi $r348 $r320 i8
add $r348 $r348 $r347
move $r349 $r348                        ; return value from ASM block with return register new_len
addi $r350 $$locbase i136               ; get offset to local __ptr { ptr, u64, u64 }
sw $$locbase $r341 i17                  ; store word
sw $$locbase $r343 i18                  ; store word
sw $$locbase $r349 i19                  ; store word
addi $r354 $$locbase i56                ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r354 $r350 i24                    ; copy memory
mcpi $r312 $r354 i24                    ; copy memory
mcpi $$arg2 $r312 i24                   ; copy memory
.15
cfsi i224                               ; [fn end: abi_encode_27] free: locals 224 byte(s), call args 0 slot(s)
popa .14                                ; [fn end: abi_encode_27] restore all used registers
jal $zero $$reta i0                     ; [fn end: abi_encode_27] return from call
DIFF------------------------------
.program:
.16                                     ; --- start of function: new_29 ---
pusha .16                               ; [fn init: new_29]: push all used registers to stack
move $$locbase $sp                      ; [fn init: new_29]: set locals base register
cfei i72                                ; [fn init: new_29]: allocate: locals 72 byte(s), call args 0 slot(s)
.108
addi $r356 $$locbase i48                ; get offset to local __ptr { { ptr, u64, u64 } }
movi $r357 i1024                        ; initialize constant into register
aloc $r357
move $r358 $hp                          ; return value from ASM block with return register hp
addi $r359 $$locbase i24                ; get offset to local __ptr { ptr, u64, u64 }
 sw $$locbase $r358 i3                   ; store word
 sw $$locbase $hp i3                     ; store word
addi $r360 $r359 i8                     ; get offset to aggregate element
movi $r361 i1024                        ; initialize constant into register
sw $$locbase $r361 i4                   ; store word
addi $r362 $r359 i16                    ; get offset to aggregate element
sw $$locbase $zero i5                   ; store word
move $r363 $r359                        ; return value from ASM block with return register buffer
 mcpi $$locbase $r363 i24                ; copy memory
 mcpi $$locbase $r359 i24                ; copy memory
mcpi $r356 $$locbase i24                ; copy memory
mcpi $$arg0 $r356 i24                   ; copy memory
ji  .17
.17
cfsi i72                                ; [fn end: new_29] free: locals 72 byte(s), call args 0 slot(s)
popa .16                                ; [fn end: new_29] restore all used registers
jal $zero $$reta i0                     ; [fn end: new_29] return from call
DIFF------------------------------
.program:
.16                                     ; --- start of function: new_29 ---
pusha .16                               ; [fn init: new_29]: push all used registers to stack
move $$locbase $sp                      ; [fn init: new_29]: set locals base register
cfei i72                                ; [fn init: new_29]: allocate: locals 72 byte(s), call args 0 slot(s)
.108
addi $r356 $$locbase i48                ; get offset to local __ptr { { ptr, u64, u64 } }
movi $r357 i1024                        ; initialize constant into register
aloc $r357
addi $r359 $$locbase i24                ; get offset to local __ptr { ptr, u64, u64 }
sw $$locbase $hp i3                     ; store word
movi $r361 i1024                        ; initialize constant into register
sw $$locbase $r361 i4                   ; store word
sw $$locbase $zero i5                   ; store word
mcpi $$locbase $r359 i24                ; copy memory
mcpi $r356 $$locbase i24                ; copy memory
mcpi $$arg0 $r356 i24                   ; copy memory
.17
cfsi i72                                ; [fn end: new_29] free: locals 72 byte(s), call args 0 slot(s)
popa .16                                ; [fn end: new_29] restore all used registers
jal $zero $$reta i0                     ; [fn end: new_29] return from call
DIFF------------------------------
.program:
.16                                     ; --- start of function: new_29 ---
pusha .16                               ; [fn init: new_29]: push all used registers to stack
move $$locbase $sp                      ; [fn init: new_29]: set locals base register
cfei i72                                ; [fn init: new_29]: allocate: locals 72 byte(s), call args 0 slot(s)
.108
addi $r356 $$locbase i48                ; get offset to local __ptr { { ptr, u64, u64 } }
movi $r357 i1024                        ; initialize constant into register
aloc $r357
addi $r359 $$locbase i24                ; get offset to local __ptr { ptr, u64, u64 }
sw $$locbase $hp i3                     ; store word
movi $r361 i1024                        ; initialize constant into register
sw $$locbase $r361 i4                   ; store word
sw $$locbase $zero i5                   ; store word
mcpi $$locbase $r359 i24                ; copy memory
mcpi $r356 $$locbase i24                ; copy memory
mcpi $$arg0 $r356 i24                   ; copy memory
.17
cfsi i72                                ; [fn end: new_29] free: locals 72 byte(s), call args 0 slot(s)
popa .16                                ; [fn end: new_29] restore all used registers
jal $zero $$reta i0                     ; [fn end: new_29] return from call
DIFF------------------------------
.program:
.16                                     ; --- start of function: new_29 ---
pusha .16                               ; [fn init: new_29]: push all used registers to stack
move $$locbase $sp                      ; [fn init: new_29]: set locals base register
cfei i72                                ; [fn init: new_29]: allocate: locals 72 byte(s), call args 0 slot(s)
.108
addi $r356 $$locbase i48                ; get offset to local __ptr { { ptr, u64, u64 } }
movi $r357 i1024                        ; initialize constant into register
aloc $r357
addi $r359 $$locbase i24                ; get offset to local __ptr { ptr, u64, u64 }
sw $$locbase $hp i3                     ; store word
movi $r361 i1024                        ; initialize constant into register
sw $$locbase $r361 i4                   ; store word
sw $$locbase $zero i5                   ; store word
mcpi $$locbase $r359 i24                ; copy memory
mcpi $r356 $$locbase i24                ; copy memory
mcpi $$arg0 $r356 i24                   ; copy memory
.17
cfsi i72                                ; [fn end: new_29] free: locals 72 byte(s), call args 0 slot(s)
popa .16                                ; [fn end: new_29] restore all used registers
jal $zero $$reta i0                     ; [fn end: new_29] return from call
DIFF------------------------------
.program:
.18                                     ; --- start of function: as_raw_slice_30 ---
pusha .18                               ; [fn init: as_raw_slice_30]: push all used registers to stack
move $$locbase $sp                      ; [fn init: as_raw_slice_30]: set locals base register
cfei i56                                ; [fn init: as_raw_slice_30]: allocate: locals 56 byte(s), call args 0 slot(s)
.109
addi $r365 $$locbase i32                ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r365 $$arg0 i24                   ; copy memory
addi $r366 $$locbase i32                ; get offset to local __ptr { { ptr, u64, u64 } }
move $r367 $r366                        ; return value from ASM block with return register buffer
lw $r368 $r366 i0                       ; load word
 addi $r369 $r367 i16                    ; get offset to aggregate element
 addi $r369 $r366 i16                    ; get offset to aggregate element
lw $r370 $r366 i2                       ; load word
addi $r371 $$locbase i16                ; get offset to local __ptr { ptr, u64 }
sw $$locbase $r368 i2                   ; store word
addi $r372 $r371 i8                     ; get offset to aggregate element
sw $$locbase $r370 i3                   ; store word
move $r373 $r371                        ; return value from ASM block with return register s
 mcpi $$locbase $r373 i16                ; copy memory
 mcpi $$locbase $r371 i16                ; copy memory
mcpi $$arg1 $$locbase i16               ; copy memory
ji  .19
.19
cfsi i56                                ; [fn end: as_raw_slice_30] free: locals 56 byte(s), call args 0 slot(s)
popa .18                                ; [fn end: as_raw_slice_30] restore all used registers
jal $zero $$reta i0                     ; [fn end: as_raw_slice_30] return from call
DIFF------------------------------
.program:
.18                                     ; --- start of function: as_raw_slice_30 ---
pusha .18                               ; [fn init: as_raw_slice_30]: push all used registers to stack
move $$locbase $sp                      ; [fn init: as_raw_slice_30]: set locals base register
cfei i56                                ; [fn init: as_raw_slice_30]: allocate: locals 56 byte(s), call args 0 slot(s)
.109
addi $r365 $$locbase i32                ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r365 $$arg0 i24                   ; copy memory
addi $r366 $$locbase i32                ; get offset to local __ptr { { ptr, u64, u64 } }
lw $r368 $$locbase i4                   ; load word
lw $r370 $$locbase i6                   ; load word
addi $r371 $$locbase i16                ; get offset to local __ptr { ptr, u64 }
sw $$locbase $r368 i2                   ; store word
sw $$locbase $r370 i3                   ; store word
mcpi $$locbase $r371 i16                ; copy memory
mcpi $$arg1 $$locbase i16               ; copy memory
.19
cfsi i56                                ; [fn end: as_raw_slice_30] free: locals 56 byte(s), call args 0 slot(s)
popa .18                                ; [fn end: as_raw_slice_30] restore all used registers
jal $zero $$reta i0                     ; [fn end: as_raw_slice_30] return from call
DIFF------------------------------
.program:
.18                                     ; --- start of function: as_raw_slice_30 ---
pusha .18                               ; [fn init: as_raw_slice_30]: push all used registers to stack
move $$locbase $sp                      ; [fn init: as_raw_slice_30]: set locals base register
cfei i56                                ; [fn init: as_raw_slice_30]: allocate: locals 56 byte(s), call args 0 slot(s)
.109
addi $r365 $$locbase i32                ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r365 $$arg0 i24                   ; copy memory
lw $r368 $$locbase i4                   ; load word
lw $r370 $$locbase i6                   ; load word
addi $r371 $$locbase i16                ; get offset to local __ptr { ptr, u64 }
sw $$locbase $r368 i2                   ; store word
sw $$locbase $r370 i3                   ; store word
mcpi $$locbase $r371 i16                ; copy memory
mcpi $$arg1 $$locbase i16               ; copy memory
.19
cfsi i56                                ; [fn end: as_raw_slice_30] free: locals 56 byte(s), call args 0 slot(s)
popa .18                                ; [fn end: as_raw_slice_30] restore all used registers
jal $zero $$reta i0                     ; [fn end: as_raw_slice_30] return from call
DIFF------------------------------
.program:
.18                                     ; --- start of function: as_raw_slice_30 ---
pusha .18                               ; [fn init: as_raw_slice_30]: push all used registers to stack
move $$locbase $sp                      ; [fn init: as_raw_slice_30]: set locals base register
cfei i56                                ; [fn init: as_raw_slice_30]: allocate: locals 56 byte(s), call args 0 slot(s)
.109
addi $r365 $$locbase i32                ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r365 $$arg0 i24                   ; copy memory
lw $r368 $$locbase i4                   ; load word
lw $r370 $$locbase i6                   ; load word
addi $r371 $$locbase i16                ; get offset to local __ptr { ptr, u64 }
sw $$locbase $r368 i2                   ; store word
sw $$locbase $r370 i3                   ; store word
mcpi $$locbase $r371 i16                ; copy memory
mcpi $$arg1 $$locbase i16               ; copy memory
.19
cfsi i56                                ; [fn end: as_raw_slice_30] free: locals 56 byte(s), call args 0 slot(s)
popa .18                                ; [fn end: as_raw_slice_30] restore all used registers
jal $zero $$reta i0                     ; [fn end: as_raw_slice_30] return from call
DIFF------------------------------
.program:
.24                                     ; --- start of function: call_nested_panic_non_inlined_31 ---
pusha .24                               ; [fn init: call_nested_panic_non_inlined_31]: push all used registers to stack
move $$locbase $sp                      ; [fn init: call_nested_panic_non_inlined_31]: set locals base register
cfei i200                               ; [fn init: call_nested_panic_non_inlined_31]: allocate: locals 200 byte(s), call args 0 slot(s)
move $r378 $$arg0                       ; [fn init: call_nested_panic_non_inlined_31]: copy argument 0 (__backtrace)
move $r379 $$reta                       ; [fn init: call_nested_panic_non_inlined_31]: save return address
.112
movi $r380 i4                           ; initialize constant into register
sw $$locbase $r380 i0                   ; store word
addi $r381 $$locbase i152               ; get offset to local __ptr [slice; 3]
addr $r382 data_NonConfigurable_7       ; get __const_global2's address in data section
addi $r383 $$locbase i56                ; get offset to local __ptr { ptr, u64 }
sw $$locbase $r382 i7                   ; store word
addi $r384 $r383 i8                     ; get offset to aggregate element
movi $r385 i4                           ; initialize constant into register
sw $$locbase $r385 i8                   ; store word
addi $r386 $$locbase i72                ; get offset to local __ptr slice
mcpi $r386 $r383 i16                    ; copy memory
addr $r387 data_NonConfigurable_8       ; get __const_global3's address in data section
addi $r388 $$locbase i88                ; get offset to local __ptr { ptr, u64 }
sw $$locbase $r387 i11                  ; store word
addi $r389 $r388 i8                     ; get offset to aggregate element
movi $r390 i6                           ; initialize constant into register
sw $$locbase $r390 i12                  ; store word
addi $r391 $$locbase i104               ; get offset to local __ptr slice
mcpi $r391 $r388 i16                    ; copy memory
addr $r392 data_NonConfigurable_9       ; get __const_global4's address in data section
addi $r393 $$locbase i120               ; get offset to local __ptr { ptr, u64 }
sw $$locbase $r392 i15                  ; store word
addi $r394 $r393 i8                     ; get offset to aggregate element
movi $r395 i17                          ; initialize constant into register
sw $$locbase $r395 i16                  ; store word
addi $r396 $$locbase i136               ; get offset to local __ptr slice
mcpi $r396 $r393 i16                    ; copy memory
movi $r397 i16                          ; get array element size
 mul $r398 $zero $r397                   ; get offset to array element
 add $r398 $r381 $r398                   ; add array element offset to array base
 mcpi $r398 $r386 i16                    ; copy memory
 movi $r398 i0                           ; get offset to array element
 move $r398 $r381                        ; add array element offset to array base
 mcpi $r381 $r386 i16                    ; copy memory
movi $r399 i16                          ; get array element size
 mul $r400 $one $r399                    ; get offset to array element
 add $r400 $r381 $r400                   ; add array element offset to array base
 movi $r400 i16                          ; get offset to array element
 addi $r400 $r381 i16                    ; add array element offset to array base
mcpi $r400 $r391 i16                    ; copy memory
movi $r401 i16                          ; get array element size
movi $r402 i2                           ; initialize constant into register
 mul $r403 $r402 $r401                   ; get offset to array element
 add $r403 $r381 $r403                   ; add array element offset to array base
 movi $r403 i32                          ; get offset to array element
 addi $r403 $r381 i32                    ; add array element offset to array base
mcpi $r403 $r396 i16                    ; copy memory
addi $r404 $$locbase i8                 ; get offset to aggregate element
mcpi $r404 $r381 i48                    ; copy memory
 move $$arg0 $one                        ; [call: nested_panic_non_inlined_32]: pass argument 0
 movi $$arg0 i1                          ; [call: nested_panic_non_inlined_32]: pass argument 0
move $$arg1 $$locbase                   ; [call: nested_panic_non_inlined_32]: pass argument 1
move $$arg2 $r378                       ; [call: nested_panic_non_inlined_32]: pass argument 2
fncall .26                              ; [call: nested_panic_non_inlined_32]: call function
 move $r405 $zero                        ; [call: nested_panic_non_inlined_32]: copy returned unit value
 movi $r405 i0                           ; [call: nested_panic_non_inlined_32]: copy returned unit value
ji  .25
.25
cfsi i200                               ; [fn end: call_nested_panic_non_inlined_31] free: locals 200 byte(s), call args 0 slot(s)
move $$reta $r379                       ; [fn end: call_nested_panic_non_inlined_31] restore return address
popa .24                                ; [fn end: call_nested_panic_non_inlined_31] restore all used registers
jal $zero $$reta i0                     ; [fn end: call_nested_panic_non_inlined_31] return from call
DIFF------------------------------
.program:
.24                                     ; --- start of function: call_nested_panic_non_inlined_31 ---
pusha .24                               ; [fn init: call_nested_panic_non_inlined_31]: push all used registers to stack
move $$locbase $sp                      ; [fn init: call_nested_panic_non_inlined_31]: set locals base register
cfei i200                               ; [fn init: call_nested_panic_non_inlined_31]: allocate: locals 200 byte(s), call args 0 slot(s)
move $r378 $$arg0                       ; [fn init: call_nested_panic_non_inlined_31]: copy argument 0 (__backtrace)
move $r379 $$reta                       ; [fn init: call_nested_panic_non_inlined_31]: save return address
.112
movi $r380 i4                           ; initialize constant into register
sw $$locbase $r380 i0                   ; store word
addi $r381 $$locbase i152               ; get offset to local __ptr [slice; 3]
addr $r382 data_NonConfigurable_7       ; get __const_global2's address in data section
addi $r383 $$locbase i56                ; get offset to local __ptr { ptr, u64 }
sw $$locbase $r382 i7                   ; store word
movi $r385 i4                           ; initialize constant into register
sw $$locbase $r385 i8                   ; store word
addi $r386 $$locbase i72                ; get offset to local __ptr slice
mcpi $r386 $r383 i16                    ; copy memory
addr $r387 data_NonConfigurable_8       ; get __const_global3's address in data section
addi $r388 $$locbase i88                ; get offset to local __ptr { ptr, u64 }
sw $$locbase $r387 i11                  ; store word
movi $r390 i6                           ; initialize constant into register
sw $$locbase $r390 i12                  ; store word
addi $r391 $$locbase i104               ; get offset to local __ptr slice
mcpi $r391 $r388 i16                    ; copy memory
addr $r392 data_NonConfigurable_9       ; get __const_global4's address in data section
addi $r393 $$locbase i120               ; get offset to local __ptr { ptr, u64 }
sw $$locbase $r392 i15                  ; store word
movi $r395 i17                          ; initialize constant into register
sw $$locbase $r395 i16                  ; store word
addi $r396 $$locbase i136               ; get offset to local __ptr slice
mcpi $r396 $r393 i16                    ; copy memory
mcpi $r381 $r386 i16                    ; copy memory
addi $r400 $r381 i16                    ; add array element offset to array base
mcpi $r400 $r391 i16                    ; copy memory
addi $r403 $r381 i32                    ; add array element offset to array base
mcpi $r403 $r396 i16                    ; copy memory
addi $r404 $$locbase i8                 ; get offset to aggregate element
mcpi $r404 $r381 i48                    ; copy memory
movi $$arg0 i1                          ; [call: nested_panic_non_inlined_32]: pass argument 0
move $$arg1 $$locbase                   ; [call: nested_panic_non_inlined_32]: pass argument 1
move $$arg2 $r378                       ; [call: nested_panic_non_inlined_32]: pass argument 2
fncall .26                              ; [call: nested_panic_non_inlined_32]: call function
.25
cfsi i200                               ; [fn end: call_nested_panic_non_inlined_31] free: locals 200 byte(s), call args 0 slot(s)
move $$reta $r379                       ; [fn end: call_nested_panic_non_inlined_31] restore return address
popa .24                                ; [fn end: call_nested_panic_non_inlined_31] restore all used registers
jal $zero $$reta i0                     ; [fn end: call_nested_panic_non_inlined_31] return from call
DIFF------------------------------
.program:
.24                                     ; --- start of function: call_nested_panic_non_inlined_31 ---
pusha .24                               ; [fn init: call_nested_panic_non_inlined_31]: push all used registers to stack
move $$locbase $sp                      ; [fn init: call_nested_panic_non_inlined_31]: set locals base register
cfei i200                               ; [fn init: call_nested_panic_non_inlined_31]: allocate: locals 200 byte(s), call args 0 slot(s)
move $r378 $$arg0                       ; [fn init: call_nested_panic_non_inlined_31]: copy argument 0 (__backtrace)
move $r379 $$reta                       ; [fn init: call_nested_panic_non_inlined_31]: save return address
.112
movi $r380 i4                           ; initialize constant into register
sw $$locbase $r380 i0                   ; store word
addi $r381 $$locbase i152               ; get offset to local __ptr [slice; 3]
addr $r382 data_NonConfigurable_7       ; get __const_global2's address in data section
addi $r383 $$locbase i56                ; get offset to local __ptr { ptr, u64 }
sw $$locbase $r382 i7                   ; store word
movi $r385 i4                           ; initialize constant into register
sw $$locbase $r385 i8                   ; store word
addi $r386 $$locbase i72                ; get offset to local __ptr slice
mcpi $r386 $r383 i16                    ; copy memory
addr $r387 data_NonConfigurable_8       ; get __const_global3's address in data section
addi $r388 $$locbase i88                ; get offset to local __ptr { ptr, u64 }
sw $$locbase $r387 i11                  ; store word
movi $r390 i6                           ; initialize constant into register
sw $$locbase $r390 i12                  ; store word
addi $r391 $$locbase i104               ; get offset to local __ptr slice
mcpi $r391 $r388 i16                    ; copy memory
addr $r392 data_NonConfigurable_9       ; get __const_global4's address in data section
addi $r393 $$locbase i120               ; get offset to local __ptr { ptr, u64 }
sw $$locbase $r392 i15                  ; store word
movi $r395 i17                          ; initialize constant into register
sw $$locbase $r395 i16                  ; store word
addi $r396 $$locbase i136               ; get offset to local __ptr slice
mcpi $r396 $r393 i16                    ; copy memory
mcpi $r381 $r386 i16                    ; copy memory
addi $r400 $r381 i16                    ; add array element offset to array base
mcpi $r400 $r391 i16                    ; copy memory
addi $r403 $r381 i32                    ; add array element offset to array base
mcpi $r403 $r396 i16                    ; copy memory
addi $r404 $$locbase i8                 ; get offset to aggregate element
mcpi $r404 $r381 i48                    ; copy memory
movi $$arg0 i1                          ; [call: nested_panic_non_inlined_32]: pass argument 0
move $$arg1 $$locbase                   ; [call: nested_panic_non_inlined_32]: pass argument 1
move $$arg2 $r378                       ; [call: nested_panic_non_inlined_32]: pass argument 2
fncall .26                              ; [call: nested_panic_non_inlined_32]: call function
.25
cfsi i200                               ; [fn end: call_nested_panic_non_inlined_31] free: locals 200 byte(s), call args 0 slot(s)
move $$reta $r379                       ; [fn end: call_nested_panic_non_inlined_31] restore return address
popa .24                                ; [fn end: call_nested_panic_non_inlined_31] restore all used registers
jal $zero $$reta i0                     ; [fn end: call_nested_panic_non_inlined_31] return from call
DIFF------------------------------
.program:
.24                                     ; --- start of function: call_nested_panic_non_inlined_31 ---
pusha .24                               ; [fn init: call_nested_panic_non_inlined_31]: push all used registers to stack
move $$locbase $sp                      ; [fn init: call_nested_panic_non_inlined_31]: set locals base register
cfei i200                               ; [fn init: call_nested_panic_non_inlined_31]: allocate: locals 200 byte(s), call args 0 slot(s)
move $r378 $$arg0                       ; [fn init: call_nested_panic_non_inlined_31]: copy argument 0 (__backtrace)
move $r379 $$reta                       ; [fn init: call_nested_panic_non_inlined_31]: save return address
.112
movi $r380 i4                           ; initialize constant into register
sw $$locbase $r380 i0                   ; store word
addi $r381 $$locbase i152               ; get offset to local __ptr [slice; 3]
addr $r382 data_NonConfigurable_7       ; get __const_global2's address in data section
addi $r383 $$locbase i56                ; get offset to local __ptr { ptr, u64 }
sw $$locbase $r382 i7                   ; store word
movi $r385 i4                           ; initialize constant into register
sw $$locbase $r385 i8                   ; store word
addi $r386 $$locbase i72                ; get offset to local __ptr slice
mcpi $r386 $r383 i16                    ; copy memory
addr $r387 data_NonConfigurable_8       ; get __const_global3's address in data section
addi $r388 $$locbase i88                ; get offset to local __ptr { ptr, u64 }
sw $$locbase $r387 i11                  ; store word
movi $r390 i6                           ; initialize constant into register
sw $$locbase $r390 i12                  ; store word
addi $r391 $$locbase i104               ; get offset to local __ptr slice
mcpi $r391 $r388 i16                    ; copy memory
addr $r392 data_NonConfigurable_9       ; get __const_global4's address in data section
addi $r393 $$locbase i120               ; get offset to local __ptr { ptr, u64 }
sw $$locbase $r392 i15                  ; store word
movi $r395 i17                          ; initialize constant into register
sw $$locbase $r395 i16                  ; store word
addi $r396 $$locbase i136               ; get offset to local __ptr slice
mcpi $r396 $r393 i16                    ; copy memory
mcpi $r381 $r386 i16                    ; copy memory
addi $r400 $r381 i16                    ; add array element offset to array base
mcpi $r400 $r391 i16                    ; copy memory
addi $r403 $r381 i32                    ; add array element offset to array base
mcpi $r403 $r396 i16                    ; copy memory
addi $r404 $$locbase i8                 ; get offset to aggregate element
mcpi $r404 $r381 i48                    ; copy memory
movi $$arg0 i1                          ; [call: nested_panic_non_inlined_32]: pass argument 0
move $$arg1 $$locbase                   ; [call: nested_panic_non_inlined_32]: pass argument 1
move $$arg2 $r378                       ; [call: nested_panic_non_inlined_32]: pass argument 2
fncall .26                              ; [call: nested_panic_non_inlined_32]: call function
.25
cfsi i200                               ; [fn end: call_nested_panic_non_inlined_31] free: locals 200 byte(s), call args 0 slot(s)
move $$reta $r379                       ; [fn end: call_nested_panic_non_inlined_31] restore return address
popa .24                                ; [fn end: call_nested_panic_non_inlined_31] restore all used registers
jal $zero $$reta i0                     ; [fn end: call_nested_panic_non_inlined_31] return from call
DIFF------------------------------
.program:
.26                                     ; --- start of function: nested_panic_non_inlined_32 ---
pusha .26                               ; [fn init: nested_panic_non_inlined_32]: push all used registers to stack
move $$locbase $sp                      ; [fn init: nested_panic_non_inlined_32]: set locals base register
cfei i72                                ; [fn init: nested_panic_non_inlined_32]: allocate: locals 72 byte(s), call args 0 slot(s)
move $r406 $$arg0                       ; [fn init: nested_panic_non_inlined_32]: copy argument 0 (to_panic)
move $r407 $$arg1                       ; [fn init: nested_panic_non_inlined_32]: copy argument 1 (err)
move $r408 $$arg2                       ; [fn init: nested_panic_non_inlined_32]: copy argument 2 (__backtrace)
move $r409 $$reta                       ; [fn init: nested_panic_non_inlined_32]: save return address
.113
addi $r410 $$locbase i16                ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
 mcpi $r410 $r407 i56                    ; copy memory
 mcpi $r410 $$arg1 i56                   ; copy memory
jnzi $r406 .114
ji  .115
.115
ji  .27
.114
addi $r411 $$locbase i16                ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
move $$arg0 $r411                       ; [call: encode_allow_alias_2]: pass argument 0
move $$arg1 $$locbase                   ; [call: encode_allow_alias_2]: pass argument 1
fncall .4                               ; [call: encode_allow_alias_2]: call function
 move $r412 $zero                        ; [call: encode_allow_alias_2]: copy returned unit value
 movi $r412 i0                           ; [call: encode_allow_alias_2]: copy returned unit value
load $r413 data_NonConfigurable_3       ; load constant from data section
lw $r414 $$locbase i0                   ; load slice pointer for logging data
lw $r415 $$locbase i1                   ; load slice size for logging data
logd $zero $r413 $r414 $r415            ; log slice
load $r416 data_NonConfigurable_4       ; load constant from data section
and $r417 $r408 $r416
load $r418 data_NonConfigurable_10      ; load constant from data section
or $r419 $r418 $r417
rvrt $r419
.27
cfsi i72                                ; [fn end: nested_panic_non_inlined_32] free: locals 72 byte(s), call args 0 slot(s)
move $$reta $r409                       ; [fn end: nested_panic_non_inlined_32] restore return address
popa .26                                ; [fn end: nested_panic_non_inlined_32] restore all used registers
jal $zero $$reta i0                     ; [fn end: nested_panic_non_inlined_32] return from call
DIFF------------------------------
.program:
.26                                     ; --- start of function: nested_panic_non_inlined_32 ---
pusha .26                               ; [fn init: nested_panic_non_inlined_32]: push all used registers to stack
move $$locbase $sp                      ; [fn init: nested_panic_non_inlined_32]: set locals base register
cfei i72                                ; [fn init: nested_panic_non_inlined_32]: allocate: locals 72 byte(s), call args 0 slot(s)
move $r406 $$arg0                       ; [fn init: nested_panic_non_inlined_32]: copy argument 0 (to_panic)
move $r408 $$arg2                       ; [fn init: nested_panic_non_inlined_32]: copy argument 2 (__backtrace)
move $r409 $$reta                       ; [fn init: nested_panic_non_inlined_32]: save return address
.113
addi $r410 $$locbase i16                ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
mcpi $r410 $$arg1 i56                   ; copy memory
jnzi $r406 .114
.115
ji  .27
.114
addi $r411 $$locbase i16                ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
move $$arg0 $r411                       ; [call: encode_allow_alias_2]: pass argument 0
move $$arg1 $$locbase                   ; [call: encode_allow_alias_2]: pass argument 1
fncall .4                               ; [call: encode_allow_alias_2]: call function
load $r413 data_NonConfigurable_3       ; load constant from data section
lw $r414 $$locbase i0                   ; load slice pointer for logging data
lw $r415 $$locbase i1                   ; load slice size for logging data
logd $zero $r413 $r414 $r415            ; log slice
load $r416 data_NonConfigurable_4       ; load constant from data section
and $r417 $r408 $r416
load $r418 data_NonConfigurable_10      ; load constant from data section
or $r419 $r418 $r417
rvrt $r419
.27
cfsi i72                                ; [fn end: nested_panic_non_inlined_32] free: locals 72 byte(s), call args 0 slot(s)
move $$reta $r409                       ; [fn end: nested_panic_non_inlined_32] restore return address
popa .26                                ; [fn end: nested_panic_non_inlined_32] restore all used registers
jal $zero $$reta i0                     ; [fn end: nested_panic_non_inlined_32] return from call
DIFF------------------------------
.program:
.26                                     ; --- start of function: nested_panic_non_inlined_32 ---
pusha .26                               ; [fn init: nested_panic_non_inlined_32]: push all used registers to stack
move $$locbase $sp                      ; [fn init: nested_panic_non_inlined_32]: set locals base register
cfei i72                                ; [fn init: nested_panic_non_inlined_32]: allocate: locals 72 byte(s), call args 0 slot(s)
move $r406 $$arg0                       ; [fn init: nested_panic_non_inlined_32]: copy argument 0 (to_panic)
move $r408 $$arg2                       ; [fn init: nested_panic_non_inlined_32]: copy argument 2 (__backtrace)
move $r409 $$reta                       ; [fn init: nested_panic_non_inlined_32]: save return address
.113
addi $r410 $$locbase i16                ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
mcpi $r410 $$arg1 i56                   ; copy memory
jnzi $r406 .114
.115
ji  .27
.114
addi $r411 $$locbase i16                ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
move $$arg0 $r411                       ; [call: encode_allow_alias_2]: pass argument 0
move $$arg1 $$locbase                   ; [call: encode_allow_alias_2]: pass argument 1
fncall .4                               ; [call: encode_allow_alias_2]: call function
load $r413 data_NonConfigurable_3       ; load constant from data section
lw $r414 $$locbase i0                   ; load slice pointer for logging data
lw $r415 $$locbase i1                   ; load slice size for logging data
logd $zero $r413 $r414 $r415            ; log slice
load $r416 data_NonConfigurable_4       ; load constant from data section
and $r417 $r408 $r416
load $r418 data_NonConfigurable_10      ; load constant from data section
or $r419 $r418 $r417
rvrt $r419
.27
cfsi i72                                ; [fn end: nested_panic_non_inlined_32] free: locals 72 byte(s), call args 0 slot(s)
move $$reta $r409                       ; [fn end: nested_panic_non_inlined_32] restore return address
popa .26                                ; [fn end: nested_panic_non_inlined_32] restore all used registers
jal $zero $$reta i0                     ; [fn end: nested_panic_non_inlined_32] return from call
DIFF------------------------------
.program:
.26                                     ; --- start of function: nested_panic_non_inlined_32 ---
pusha .26                               ; [fn init: nested_panic_non_inlined_32]: push all used registers to stack
move $$locbase $sp                      ; [fn init: nested_panic_non_inlined_32]: set locals base register
cfei i72                                ; [fn init: nested_panic_non_inlined_32]: allocate: locals 72 byte(s), call args 0 slot(s)
move $r406 $$arg0                       ; [fn init: nested_panic_non_inlined_32]: copy argument 0 (to_panic)
move $r408 $$arg2                       ; [fn init: nested_panic_non_inlined_32]: copy argument 2 (__backtrace)
move $r409 $$reta                       ; [fn init: nested_panic_non_inlined_32]: save return address
.113
addi $r410 $$locbase i16                ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
mcpi $r410 $$arg1 i56                   ; copy memory
jnzi $r406 .114
.115
ji  .27
.114
addi $r411 $$locbase i16                ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
move $$arg0 $r411                       ; [call: encode_allow_alias_2]: pass argument 0
move $$arg1 $$locbase                   ; [call: encode_allow_alias_2]: pass argument 1
fncall .4                               ; [call: encode_allow_alias_2]: call function
load $r413 data_NonConfigurable_3       ; load constant from data section
lw $r414 $$locbase i0                   ; load slice pointer for logging data
lw $r415 $$locbase i1                   ; load slice size for logging data
logd $zero $r413 $r414 $r415            ; log slice
load $r416 data_NonConfigurable_4       ; load constant from data section
and $r417 $r408 $r416
load $r418 data_NonConfigurable_10      ; load constant from data section
or $r419 $r418 $r417
rvrt $r419
.27
cfsi i72                                ; [fn end: nested_panic_non_inlined_32] free: locals 72 byte(s), call args 0 slot(s)
move $$reta $r409                       ; [fn end: nested_panic_non_inlined_32] restore return address
popa .26                                ; [fn end: nested_panic_non_inlined_32] restore all used registers
jal $zero $$reta i0                     ; [fn end: nested_panic_non_inlined_32] return from call
DIFF------------------------------
.program:
.32                                     ; --- start of function: encode_allow_alias_34 ---
pusha .32                               ; [fn init: encode_allow_alias_34]: push all used registers to stack
move $$locbase $sp                      ; [fn init: encode_allow_alias_34]: set locals base register
cfei i16                                ; [fn init: encode_allow_alias_34]: allocate: locals 16 byte(s), call args 0 slot(s)
.118
sw $$locbase $$arg0 i0                  ; store word
addi $r431 $$locbase i8                 ; get offset to aggregate element
sw $$locbase $zero i1                   ; store word
mcpi $$arg1 $$locbase i16               ; copy memory
ji  .33
.33
cfsi i16                                ; [fn end: encode_allow_alias_34] free: locals 16 byte(s), call args 0 slot(s)
popa .32                                ; [fn end: encode_allow_alias_34] restore all used registers
jal $zero $$reta i0                     ; [fn end: encode_allow_alias_34] return from call
DIFF------------------------------
.program:
.32                                     ; --- start of function: encode_allow_alias_34 ---
pusha .32                               ; [fn init: encode_allow_alias_34]: push all used registers to stack
move $$locbase $sp                      ; [fn init: encode_allow_alias_34]: set locals base register
cfei i16                                ; [fn init: encode_allow_alias_34]: allocate: locals 16 byte(s), call args 0 slot(s)
.118
sw $$locbase $$arg0 i0                  ; store word
sw $$locbase $zero i1                   ; store word
mcpi $$arg1 $$locbase i16               ; copy memory
.33
cfsi i16                                ; [fn end: encode_allow_alias_34] free: locals 16 byte(s), call args 0 slot(s)
popa .32                                ; [fn end: encode_allow_alias_34] restore all used registers
jal $zero $$reta i0                     ; [fn end: encode_allow_alias_34] return from call
DIFF------------------------------
.program:
.32                                     ; --- start of function: encode_allow_alias_34 ---
pusha .32                               ; [fn init: encode_allow_alias_34]: push all used registers to stack
move $$locbase $sp                      ; [fn init: encode_allow_alias_34]: set locals base register
cfei i16                                ; [fn init: encode_allow_alias_34]: allocate: locals 16 byte(s), call args 0 slot(s)
.118
sw $$locbase $$arg0 i0                  ; store word
sw $$locbase $zero i1                   ; store word
mcpi $$arg1 $$locbase i16               ; copy memory
.33
cfsi i16                                ; [fn end: encode_allow_alias_34] free: locals 16 byte(s), call args 0 slot(s)
popa .32                                ; [fn end: encode_allow_alias_34] restore all used registers
jal $zero $$reta i0                     ; [fn end: encode_allow_alias_34] return from call
DIFF------------------------------
.program:
.32                                     ; --- start of function: encode_allow_alias_34 ---
pusha .32                               ; [fn init: encode_allow_alias_34]: push all used registers to stack
move $$locbase $sp                      ; [fn init: encode_allow_alias_34]: set locals base register
cfei i16                                ; [fn init: encode_allow_alias_34]: allocate: locals 16 byte(s), call args 0 slot(s)
.118
sw $$locbase $$arg0 i0                  ; store word
sw $$locbase $zero i1                   ; store word
mcpi $$arg1 $$locbase i16               ; copy memory
.33
cfsi i16                                ; [fn end: encode_allow_alias_34] free: locals 16 byte(s), call args 0 slot(s)
popa .32                                ; [fn end: encode_allow_alias_34] restore all used registers
jal $zero $$reta i0                     ; [fn end: encode_allow_alias_34] return from call
DIFF------------------------------
.program:
.38                                     ; --- start of function: generic_panic_36 ---
pusha .38                               ; [fn init: generic_panic_36]: push all used registers to stack
move $$locbase $sp                      ; [fn init: generic_panic_36]: set locals base register
cfei i64                                ; [fn init: generic_panic_36]: allocate: locals 64 byte(s), call args 0 slot(s)
move $r447 $$arg0                       ; [fn init: generic_panic_36]: copy argument 0 (t)
move $r448 $$arg1                       ; [fn init: generic_panic_36]: copy argument 1 (__backtrace)
move $r449 $$reta                       ; [fn init: generic_panic_36]: save return address
.121
addi $r450 $$locbase i16                ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r450                       ; [call: new_29]: pass argument 0
fncall .16                              ; [call: new_29]: call function
 move $r451 $zero                        ; [call: new_29]: copy returned unit value
 movi $r451 i0                           ; [call: new_29]: copy returned unit value
addi $r452 $$locbase i16                ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r453 $$locbase i40                ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r447                       ; [call: abi_encode_27]: pass argument 0
move $$arg1 $r452                       ; [call: abi_encode_27]: pass argument 1
move $$arg2 $r453                       ; [call: abi_encode_27]: pass argument 2
fncall .14                              ; [call: abi_encode_27]: call function
 move $r454 $zero                        ; [call: abi_encode_27]: copy returned unit value
 movi $r454 i0                           ; [call: abi_encode_27]: copy returned unit value
addi $r455 $$locbase i40                ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r455                       ; [call: as_raw_slice_30]: pass argument 0
move $$arg1 $$locbase                   ; [call: as_raw_slice_30]: pass argument 1
fncall .18                              ; [call: as_raw_slice_30]: call function
 move $r456 $zero                        ; [call: as_raw_slice_30]: copy returned unit value
 movi $r456 i0                           ; [call: as_raw_slice_30]: copy returned unit value
load $r457 data_NonConfigurable_14      ; load constant from data section
lw $r458 $$locbase i0                   ; load slice pointer for logging data
lw $r459 $$locbase i1                   ; load slice size for logging data
logd $zero $r457 $r458 $r459            ; log slice
load $r460 data_NonConfigurable_4       ; load constant from data section
and $r461 $r448 $r460
load $r462 data_NonConfigurable_15      ; load constant from data section
or $r463 $r462 $r461
rvrt $r463
.39
cfsi i64                                ; [fn end: generic_panic_36] free: locals 64 byte(s), call args 0 slot(s)
move $$reta $r449                       ; [fn end: generic_panic_36] restore return address
popa .38                                ; [fn end: generic_panic_36] restore all used registers
jal $zero $$reta i0                     ; [fn end: generic_panic_36] return from call
DIFF------------------------------
.program:
.38                                     ; --- start of function: generic_panic_36 ---
pusha .38                               ; [fn init: generic_panic_36]: push all used registers to stack
move $$locbase $sp                      ; [fn init: generic_panic_36]: set locals base register
cfei i64                                ; [fn init: generic_panic_36]: allocate: locals 64 byte(s), call args 0 slot(s)
move $r447 $$arg0                       ; [fn init: generic_panic_36]: copy argument 0 (t)
move $r448 $$arg1                       ; [fn init: generic_panic_36]: copy argument 1 (__backtrace)
.121
addi $r450 $$locbase i16                ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r450                       ; [call: new_29]: pass argument 0
fncall .16                              ; [call: new_29]: call function
addi $r452 $$locbase i16                ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r453 $$locbase i40                ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r447                       ; [call: abi_encode_27]: pass argument 0
move $$arg1 $r452                       ; [call: abi_encode_27]: pass argument 1
move $$arg2 $r453                       ; [call: abi_encode_27]: pass argument 2
fncall .14                              ; [call: abi_encode_27]: call function
addi $r455 $$locbase i40                ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r455                       ; [call: as_raw_slice_30]: pass argument 0
move $$arg1 $$locbase                   ; [call: as_raw_slice_30]: pass argument 1
fncall .18                              ; [call: as_raw_slice_30]: call function
load $r457 data_NonConfigurable_14      ; load constant from data section
lw $r458 $$locbase i0                   ; load slice pointer for logging data
lw $r459 $$locbase i1                   ; load slice size for logging data
logd $zero $r457 $r458 $r459            ; log slice
load $r460 data_NonConfigurable_4       ; load constant from data section
and $r461 $r448 $r460
load $r462 data_NonConfigurable_15      ; load constant from data section
or $r463 $r462 $r461
rvrt $r463
DIFF------------------------------
.program:
.38                                     ; --- start of function: generic_panic_36 ---
pusha .38                               ; [fn init: generic_panic_36]: push all used registers to stack
move $$locbase $sp                      ; [fn init: generic_panic_36]: set locals base register
cfei i64                                ; [fn init: generic_panic_36]: allocate: locals 64 byte(s), call args 0 slot(s)
move $r447 $$arg0                       ; [fn init: generic_panic_36]: copy argument 0 (t)
move $r448 $$arg1                       ; [fn init: generic_panic_36]: copy argument 1 (__backtrace)
.121
addi $r450 $$locbase i16                ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r450                       ; [call: new_29]: pass argument 0
fncall .16                              ; [call: new_29]: call function
addi $r452 $$locbase i16                ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r453 $$locbase i40                ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r447                       ; [call: abi_encode_27]: pass argument 0
move $$arg1 $r452                       ; [call: abi_encode_27]: pass argument 1
move $$arg2 $r453                       ; [call: abi_encode_27]: pass argument 2
fncall .14                              ; [call: abi_encode_27]: call function
addi $r455 $$locbase i40                ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r455                       ; [call: as_raw_slice_30]: pass argument 0
move $$arg1 $$locbase                   ; [call: as_raw_slice_30]: pass argument 1
fncall .18                              ; [call: as_raw_slice_30]: call function
load $r457 data_NonConfigurable_14      ; load constant from data section
lw $r458 $$locbase i0                   ; load slice pointer for logging data
lw $r459 $$locbase i1                   ; load slice size for logging data
logd $zero $r457 $r458 $r459            ; log slice
load $r460 data_NonConfigurable_4       ; load constant from data section
and $r461 $r448 $r460
load $r462 data_NonConfigurable_15      ; load constant from data section
or $r463 $r462 $r461
rvrt $r463
DIFF------------------------------
.program:
.38                                     ; --- start of function: generic_panic_36 ---
pusha .38                               ; [fn init: generic_panic_36]: push all used registers to stack
move $$locbase $sp                      ; [fn init: generic_panic_36]: set locals base register
cfei i64                                ; [fn init: generic_panic_36]: allocate: locals 64 byte(s), call args 0 slot(s)
move $r447 $$arg0                       ; [fn init: generic_panic_36]: copy argument 0 (t)
move $r448 $$arg1                       ; [fn init: generic_panic_36]: copy argument 1 (__backtrace)
.121
addi $r450 $$locbase i16                ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r450                       ; [call: new_29]: pass argument 0
fncall .16                              ; [call: new_29]: call function
addi $r452 $$locbase i16                ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r453 $$locbase i40                ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r447                       ; [call: abi_encode_27]: pass argument 0
move $$arg1 $r452                       ; [call: abi_encode_27]: pass argument 1
move $$arg2 $r453                       ; [call: abi_encode_27]: pass argument 2
fncall .14                              ; [call: abi_encode_27]: call function
addi $r455 $$locbase i40                ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r455                       ; [call: as_raw_slice_30]: pass argument 0
move $$arg1 $$locbase                   ; [call: as_raw_slice_30]: pass argument 1
fncall .18                              ; [call: as_raw_slice_30]: call function
load $r457 data_NonConfigurable_14      ; load constant from data section
lw $r458 $$locbase i0                   ; load slice pointer for logging data
lw $r459 $$locbase i1                   ; load slice size for logging data
logd $zero $r457 $r458 $r459            ; log slice
load $r460 data_NonConfigurable_4       ; load constant from data section
and $r461 $r448 $r460
load $r462 data_NonConfigurable_15      ; load constant from data section
or $r463 $r462 $r461
rvrt $r463
DIFF------------------------------
.program:
.58                                     ; --- start of function: encode_allow_alias_43 ---
pusha .58                               ; [fn init: encode_allow_alias_43]: push all used registers to stack
move $$locbase $sp                      ; [fn init: encode_allow_alias_43]: set locals base register
cfei i296                               ; [fn init: encode_allow_alias_43]: allocate: locals 296 byte(s), call args 0 slot(s)
move $r535 $$arg0                       ; [fn init: encode_allow_alias_43]: copy argument 0 (item)
move $r536 $$arg1                       ; [fn init: encode_allow_alias_43]: copy argument 1 (__ret_value)
move $r537 $$reta                       ; [fn init: encode_allow_alias_43]: save return address
.131
 jnzi $zero .132
 
ji  .133
.133
addi $r538 $$locbase i176               ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r538                       ; [call: new_29]: pass argument 0
fncall .16                              ; [call: new_29]: call function
 move $r539 $zero                        ; [call: new_29]: copy returned unit value
 movi $r539 i0                           ; [call: new_29]: copy returned unit value
addi $r540 $$locbase i16                ; get offset to local __ptr { u64, ( u64 | { u64, ( bool | { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) } ) } ) }
mcpi $r540 $r535 i72                    ; copy memory
addi $r541 $$locbase i16                ; get offset to local __ptr { u64, ( u64 | { u64, ( bool | { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) } ) } ) }
lw $r542 $$locbase i2                   ; load word
eq $r543 $r542 $zero
jnzi $r543 .134
ji  .135
.135
addi $r544 $$locbase i16                ; get offset to local __ptr { u64, ( u64 | { u64, ( bool | { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) } ) } ) }
lw $r545 $$locbase i2                   ; load word
eq $r546 $r545 $one
jnzi $r546 .136
ji  .137
.137
load $r547 data_NonConfigurable_6       ; load constant from data section
rvrt $r547
.136
addi $r548 $$locbase i16                ; get offset to local __ptr { u64, ( u64 | { u64, ( bool | { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) } ) } ) }
addi $r549 $r548 i8                     ; get offset to aggregate element
addi $r550 $$locbase i176               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r551 $$locbase i200               ; get offset to local __ptr { { ptr, u64, u64 } }
 move $$arg0 $one                        ; [call: abi_encode_21]: pass argument 0
 movi $$arg0 i1                          ; [call: abi_encode_21]: pass argument 0
move $$arg1 $r550                       ; [call: abi_encode_21]: pass argument 1
move $$arg2 $r551                       ; [call: abi_encode_21]: pass argument 2
fncall .10                              ; [call: abi_encode_21]: call function
 move $r552 $zero                        ; [call: abi_encode_21]: copy returned unit value
 movi $r552 i0                           ; [call: abi_encode_21]: copy returned unit value
addi $r553 $$locbase i88                ; get offset to local __ptr { u64, ( bool | { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) } ) }
mcpi $r553 $r549 i64                    ; copy memory
addi $r554 $$locbase i88                ; get offset to local __ptr { u64, ( bool | { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) } ) }
lw $r555 $$locbase i11                  ; load word
eq $r556 $r555 $zero
jnzi $r556 .138
ji  .139
.139
addi $r557 $$locbase i88                ; get offset to local __ptr { u64, ( bool | { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) } ) }
lw $r558 $$locbase i11                  ; load word
eq $r559 $r558 $one
jnzi $r559 .140
ji  .141
.141
load $r560 data_NonConfigurable_6       ; load constant from data section
rvrt $r560
.140
addi $r561 $$locbase i88                ; get offset to local __ptr { u64, ( bool | { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) } ) }
addi $r562 $r561 i8                     ; get offset to aggregate element
addi $r563 $$locbase i200               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r564 $$locbase i272               ; get offset to local __ptr { { ptr, u64, u64 } }
 move $$arg0 $one                        ; [call: abi_encode_21]: pass argument 0
 movi $$arg0 i1                          ; [call: abi_encode_21]: pass argument 0
move $$arg1 $r563                       ; [call: abi_encode_21]: pass argument 1
move $$arg2 $r564                       ; [call: abi_encode_21]: pass argument 2
fncall .10                              ; [call: abi_encode_21]: call function
 move $r565 $zero                        ; [call: abi_encode_21]: copy returned unit value
 movi $r565 i0                           ; [call: abi_encode_21]: copy returned unit value
addi $r566 $$locbase i272               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r567 $$locbase i152               ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r562                       ; [call: abi_encode_20]: pass argument 0
move $$arg1 $r566                       ; [call: abi_encode_20]: pass argument 1
move $$arg2 $r567                       ; [call: abi_encode_20]: pass argument 2
fncall .8                               ; [call: abi_encode_20]: call function
 move $r568 $zero                        ; [call: abi_encode_20]: copy returned unit value
 movi $r568 i0                           ; [call: abi_encode_20]: copy returned unit value
ji  .142
.138
addi $r569 $$locbase i88                ; get offset to local __ptr { u64, ( bool | { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) } ) }
addi $r570 $r569 i63                    ; get offset to aggregate element
lb $r571 $r570 i0                       ; load byte
addi $r572 $$locbase i200               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r573 $$locbase i248               ; get offset to local __ptr { { ptr, u64, u64 } }
 move $$arg0 $zero                       ; [call: abi_encode_21]: pass argument 0
 movi $$arg0 i0                          ; [call: abi_encode_21]: pass argument 0
move $$arg1 $r572                       ; [call: abi_encode_21]: pass argument 1
move $$arg2 $r573                       ; [call: abi_encode_21]: pass argument 2
fncall .10                              ; [call: abi_encode_21]: call function
 move $r574 $zero                        ; [call: abi_encode_21]: copy returned unit value
 movi $r574 i0                           ; [call: abi_encode_21]: copy returned unit value
addi $r575 $$locbase i248               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r576 $$locbase i152               ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r571                       ; [call: abi_encode_23]: pass argument 0
move $$arg1 $r575                       ; [call: abi_encode_23]: pass argument 1
move $$arg2 $r576                       ; [call: abi_encode_23]: pass argument 2
fncall .12                              ; [call: abi_encode_23]: call function
 move $r577 $zero                        ; [call: abi_encode_23]: copy returned unit value
 movi $r577 i0                           ; [call: abi_encode_23]: copy returned unit value
ji  .142
.142
addi $r578 $$locbase i152               ; get offset to local __ptr { { ptr, u64, u64 } }
move $r579 $r578                        ; move parameter from branch to block argument
ji  .143
.134
addi $r580 $$locbase i16                ; get offset to local __ptr { u64, ( u64 | { u64, ( bool | { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) } ) } ) }
addi $r581 $r580 i64                    ; get offset to aggregate element
lw $r582 $$locbase i10                  ; load word
addi $r583 $$locbase i176               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r584 $$locbase i224               ; get offset to local __ptr { { ptr, u64, u64 } }
 move $$arg0 $zero                       ; [call: abi_encode_21]: pass argument 0
 movi $$arg0 i0                          ; [call: abi_encode_21]: pass argument 0
move $$arg1 $r583                       ; [call: abi_encode_21]: pass argument 1
move $$arg2 $r584                       ; [call: abi_encode_21]: pass argument 2
fncall .10                              ; [call: abi_encode_21]: call function
 move $r585 $zero                        ; [call: abi_encode_21]: copy returned unit value
 movi $r585 i0                           ; [call: abi_encode_21]: copy returned unit value
addi $r586 $$locbase i224               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r587 $$locbase i152               ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r582                       ; [call: abi_encode_21]: pass argument 0
move $$arg1 $r586                       ; [call: abi_encode_21]: pass argument 1
move $$arg2 $r587                       ; [call: abi_encode_21]: pass argument 2
fncall .10                              ; [call: abi_encode_21]: call function
 move $r588 $zero                        ; [call: abi_encode_21]: copy returned unit value
 movi $r588 i0                           ; [call: abi_encode_21]: copy returned unit value
addi $r589 $$locbase i152               ; get offset to local __ptr { { ptr, u64, u64 } }
move $r579 $r589                        ; move parameter from branch to block argument
ji  .143
.143
move $r592 $r579                        ; move parameter from branch to block argument
 move $$arg0 $r592                       ; [call: as_raw_slice_30]: pass argument 0
 move $$arg0 $r579                       ; [call: as_raw_slice_30]: pass argument 0
move $$arg1 $r536                       ; [call: as_raw_slice_30]: pass argument 1
fncall .18                              ; [call: as_raw_slice_30]: call function
 move $r593 $zero                        ; [call: as_raw_slice_30]: copy returned unit value
 movi $r593 i0                           ; [call: as_raw_slice_30]: copy returned unit value
ji  .144
.132
sw $$locbase $r535 i0                   ; store word
addi $r594 $$locbase i8                 ; get offset to aggregate element
movi $r595 i72                          ; initialize constant into register
sw $$locbase $r595 i1                   ; store word
mcpi $r536 $$locbase i16                ; copy memory
ji  .144
.144
ji  .59
.59
cfsi i296                               ; [fn end: encode_allow_alias_43] free: locals 296 byte(s), call args 0 slot(s)
move $$reta $r537                       ; [fn end: encode_allow_alias_43] restore return address
popa .58                                ; [fn end: encode_allow_alias_43] restore all used registers
jal $zero $$reta i0                     ; [fn end: encode_allow_alias_43] return from call
DIFF------------------------------
.program:
.58                                     ; --- start of function: encode_allow_alias_43 ---
pusha .58                               ; [fn init: encode_allow_alias_43]: push all used registers to stack
move $$locbase $sp                      ; [fn init: encode_allow_alias_43]: set locals base register
cfei i296                               ; [fn init: encode_allow_alias_43]: allocate: locals 296 byte(s), call args 0 slot(s)
move $r535 $$arg0                       ; [fn init: encode_allow_alias_43]: copy argument 0 (item)
move $r536 $$arg1                       ; [fn init: encode_allow_alias_43]: copy argument 1 (__ret_value)
move $r537 $$reta                       ; [fn init: encode_allow_alias_43]: save return address
.131
.133
addi $r538 $$locbase i176               ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r538                       ; [call: new_29]: pass argument 0
fncall .16                              ; [call: new_29]: call function
addi $r540 $$locbase i16                ; get offset to local __ptr { u64, ( u64 | { u64, ( bool | { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) } ) } ) }
mcpi $r540 $r535 i72                    ; copy memory
lw $r542 $$locbase i2                   ; load word
eq $r543 $r542 $zero
jnzi $r543 .134
.135
lw $r545 $$locbase i2                   ; load word
eq $r546 $r545 $one
jnzi $r546 .136
.137
load $r547 data_NonConfigurable_6       ; load constant from data section
rvrt $r547
.136
addi $r548 $$locbase i16                ; get offset to local __ptr { u64, ( u64 | { u64, ( bool | { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) } ) } ) }
addi $r549 $r548 i8                     ; get offset to aggregate element
addi $r550 $$locbase i176               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r551 $$locbase i200               ; get offset to local __ptr { { ptr, u64, u64 } }
movi $$arg0 i1                          ; [call: abi_encode_21]: pass argument 0
move $$arg1 $r550                       ; [call: abi_encode_21]: pass argument 1
move $$arg2 $r551                       ; [call: abi_encode_21]: pass argument 2
fncall .10                              ; [call: abi_encode_21]: call function
addi $r553 $$locbase i88                ; get offset to local __ptr { u64, ( bool | { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) } ) }
mcpi $r553 $r549 i64                    ; copy memory
lw $r555 $$locbase i11                  ; load word
eq $r556 $r555 $zero
jnzi $r556 .138
.139
lw $r558 $$locbase i11                  ; load word
eq $r559 $r558 $one
jnzi $r559 .140
.141
load $r560 data_NonConfigurable_6       ; load constant from data section
rvrt $r560
.140
addi $r561 $$locbase i88                ; get offset to local __ptr { u64, ( bool | { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) } ) }
addi $r562 $r561 i8                     ; get offset to aggregate element
addi $r563 $$locbase i200               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r564 $$locbase i272               ; get offset to local __ptr { { ptr, u64, u64 } }
movi $$arg0 i1                          ; [call: abi_encode_21]: pass argument 0
move $$arg1 $r563                       ; [call: abi_encode_21]: pass argument 1
move $$arg2 $r564                       ; [call: abi_encode_21]: pass argument 2
fncall .10                              ; [call: abi_encode_21]: call function
addi $r566 $$locbase i272               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r567 $$locbase i152               ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r562                       ; [call: abi_encode_20]: pass argument 0
move $$arg1 $r566                       ; [call: abi_encode_20]: pass argument 1
move $$arg2 $r567                       ; [call: abi_encode_20]: pass argument 2
fncall .8                               ; [call: abi_encode_20]: call function
ji  .142
.138
addi $r569 $$locbase i88                ; get offset to local __ptr { u64, ( bool | { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) } ) }
addi $r570 $r569 i63                    ; get offset to aggregate element
lb $r571 $r570 i0                       ; load byte
addi $r572 $$locbase i200               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r573 $$locbase i248               ; get offset to local __ptr { { ptr, u64, u64 } }
movi $$arg0 i0                          ; [call: abi_encode_21]: pass argument 0
move $$arg1 $r572                       ; [call: abi_encode_21]: pass argument 1
move $$arg2 $r573                       ; [call: abi_encode_21]: pass argument 2
fncall .10                              ; [call: abi_encode_21]: call function
addi $r575 $$locbase i248               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r576 $$locbase i152               ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r571                       ; [call: abi_encode_23]: pass argument 0
move $$arg1 $r575                       ; [call: abi_encode_23]: pass argument 1
move $$arg2 $r576                       ; [call: abi_encode_23]: pass argument 2
fncall .12                              ; [call: abi_encode_23]: call function
.142
addi $r578 $$locbase i152               ; get offset to local __ptr { { ptr, u64, u64 } }
move $r579 $r578                        ; move parameter from branch to block argument
ji  .143
.134
lw $r582 $$locbase i10                  ; load word
addi $r583 $$locbase i176               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r584 $$locbase i224               ; get offset to local __ptr { { ptr, u64, u64 } }
movi $$arg0 i0                          ; [call: abi_encode_21]: pass argument 0
move $$arg1 $r583                       ; [call: abi_encode_21]: pass argument 1
move $$arg2 $r584                       ; [call: abi_encode_21]: pass argument 2
fncall .10                              ; [call: abi_encode_21]: call function
addi $r586 $$locbase i224               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r587 $$locbase i152               ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r582                       ; [call: abi_encode_21]: pass argument 0
move $$arg1 $r586                       ; [call: abi_encode_21]: pass argument 1
move $$arg2 $r587                       ; [call: abi_encode_21]: pass argument 2
fncall .10                              ; [call: abi_encode_21]: call function
addi $r589 $$locbase i152               ; get offset to local __ptr { { ptr, u64, u64 } }
move $r579 $r589                        ; move parameter from branch to block argument
.143
move $$arg0 $r579                       ; [call: as_raw_slice_30]: pass argument 0
move $$arg1 $r536                       ; [call: as_raw_slice_30]: pass argument 1
fncall .18                              ; [call: as_raw_slice_30]: call function
.144
.59
cfsi i296                               ; [fn end: encode_allow_alias_43] free: locals 296 byte(s), call args 0 slot(s)
move $$reta $r537                       ; [fn end: encode_allow_alias_43] restore return address
popa .58                                ; [fn end: encode_allow_alias_43] restore all used registers
jal $zero $$reta i0                     ; [fn end: encode_allow_alias_43] return from call
DIFF------------------------------
.program:
.58                                     ; --- start of function: encode_allow_alias_43 ---
pusha .58                               ; [fn init: encode_allow_alias_43]: push all used registers to stack
move $$locbase $sp                      ; [fn init: encode_allow_alias_43]: set locals base register
cfei i296                               ; [fn init: encode_allow_alias_43]: allocate: locals 296 byte(s), call args 0 slot(s)
move $r535 $$arg0                       ; [fn init: encode_allow_alias_43]: copy argument 0 (item)
move $r536 $$arg1                       ; [fn init: encode_allow_alias_43]: copy argument 1 (__ret_value)
move $r537 $$reta                       ; [fn init: encode_allow_alias_43]: save return address
.131
.133
addi $r538 $$locbase i176               ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r538                       ; [call: new_29]: pass argument 0
fncall .16                              ; [call: new_29]: call function
addi $r540 $$locbase i16                ; get offset to local __ptr { u64, ( u64 | { u64, ( bool | { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) } ) } ) }
mcpi $r540 $r535 i72                    ; copy memory
lw $r542 $$locbase i2                   ; load word
eq $r543 $r542 $zero
jnzi $r543 .134
.135
lw $r545 $$locbase i2                   ; load word
eq $r546 $r545 $one
jnzi $r546 .136
.137
load $r547 data_NonConfigurable_6       ; load constant from data section
rvrt $r547
.136
addi $r548 $$locbase i16                ; get offset to local __ptr { u64, ( u64 | { u64, ( bool | { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) } ) } ) }
addi $r549 $r548 i8                     ; get offset to aggregate element
addi $r550 $$locbase i176               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r551 $$locbase i200               ; get offset to local __ptr { { ptr, u64, u64 } }
movi $$arg0 i1                          ; [call: abi_encode_21]: pass argument 0
move $$arg1 $r550                       ; [call: abi_encode_21]: pass argument 1
move $$arg2 $r551                       ; [call: abi_encode_21]: pass argument 2
fncall .10                              ; [call: abi_encode_21]: call function
addi $r553 $$locbase i88                ; get offset to local __ptr { u64, ( bool | { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) } ) }
mcpi $r553 $r549 i64                    ; copy memory
lw $r555 $$locbase i11                  ; load word
eq $r556 $r555 $zero
jnzi $r556 .138
.139
lw $r558 $$locbase i11                  ; load word
eq $r559 $r558 $one
jnzi $r559 .140
.141
load $r560 data_NonConfigurable_6       ; load constant from data section
rvrt $r560
.140
addi $r561 $$locbase i88                ; get offset to local __ptr { u64, ( bool | { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) } ) }
addi $r562 $r561 i8                     ; get offset to aggregate element
addi $r563 $$locbase i200               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r564 $$locbase i272               ; get offset to local __ptr { { ptr, u64, u64 } }
movi $$arg0 i1                          ; [call: abi_encode_21]: pass argument 0
move $$arg1 $r563                       ; [call: abi_encode_21]: pass argument 1
move $$arg2 $r564                       ; [call: abi_encode_21]: pass argument 2
fncall .10                              ; [call: abi_encode_21]: call function
addi $r566 $$locbase i272               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r567 $$locbase i152               ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r562                       ; [call: abi_encode_20]: pass argument 0
move $$arg1 $r566                       ; [call: abi_encode_20]: pass argument 1
move $$arg2 $r567                       ; [call: abi_encode_20]: pass argument 2
fncall .8                               ; [call: abi_encode_20]: call function
ji  .142
.138
addi $r569 $$locbase i88                ; get offset to local __ptr { u64, ( bool | { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) } ) }
addi $r570 $r569 i63                    ; get offset to aggregate element
lb $r571 $r570 i0                       ; load byte
addi $r572 $$locbase i200               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r573 $$locbase i248               ; get offset to local __ptr { { ptr, u64, u64 } }
movi $$arg0 i0                          ; [call: abi_encode_21]: pass argument 0
move $$arg1 $r572                       ; [call: abi_encode_21]: pass argument 1
move $$arg2 $r573                       ; [call: abi_encode_21]: pass argument 2
fncall .10                              ; [call: abi_encode_21]: call function
addi $r575 $$locbase i248               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r576 $$locbase i152               ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r571                       ; [call: abi_encode_23]: pass argument 0
move $$arg1 $r575                       ; [call: abi_encode_23]: pass argument 1
move $$arg2 $r576                       ; [call: abi_encode_23]: pass argument 2
fncall .12                              ; [call: abi_encode_23]: call function
.142
addi $r578 $$locbase i152               ; get offset to local __ptr { { ptr, u64, u64 } }
move $r579 $r578                        ; move parameter from branch to block argument
ji  .143
.134
lw $r582 $$locbase i10                  ; load word
addi $r583 $$locbase i176               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r584 $$locbase i224               ; get offset to local __ptr { { ptr, u64, u64 } }
movi $$arg0 i0                          ; [call: abi_encode_21]: pass argument 0
move $$arg1 $r583                       ; [call: abi_encode_21]: pass argument 1
move $$arg2 $r584                       ; [call: abi_encode_21]: pass argument 2
fncall .10                              ; [call: abi_encode_21]: call function
addi $r586 $$locbase i224               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r587 $$locbase i152               ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r582                       ; [call: abi_encode_21]: pass argument 0
move $$arg1 $r586                       ; [call: abi_encode_21]: pass argument 1
move $$arg2 $r587                       ; [call: abi_encode_21]: pass argument 2
fncall .10                              ; [call: abi_encode_21]: call function
addi $r589 $$locbase i152               ; get offset to local __ptr { { ptr, u64, u64 } }
move $r579 $r589                        ; move parameter from branch to block argument
.143
move $$arg0 $r579                       ; [call: as_raw_slice_30]: pass argument 0
move $$arg1 $r536                       ; [call: as_raw_slice_30]: pass argument 1
fncall .18                              ; [call: as_raw_slice_30]: call function
.144
.59
cfsi i296                               ; [fn end: encode_allow_alias_43] free: locals 296 byte(s), call args 0 slot(s)
move $$reta $r537                       ; [fn end: encode_allow_alias_43] restore return address
popa .58                                ; [fn end: encode_allow_alias_43] restore all used registers
jal $zero $$reta i0                     ; [fn end: encode_allow_alias_43] return from call
DIFF------------------------------
.program:
.58                                     ; --- start of function: encode_allow_alias_43 ---
pusha .58                               ; [fn init: encode_allow_alias_43]: push all used registers to stack
move $$locbase $sp                      ; [fn init: encode_allow_alias_43]: set locals base register
cfei i296                               ; [fn init: encode_allow_alias_43]: allocate: locals 296 byte(s), call args 0 slot(s)
move $r535 $$arg0                       ; [fn init: encode_allow_alias_43]: copy argument 0 (item)
move $r536 $$arg1                       ; [fn init: encode_allow_alias_43]: copy argument 1 (__ret_value)
move $r537 $$reta                       ; [fn init: encode_allow_alias_43]: save return address
.131
.133
addi $r538 $$locbase i176               ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r538                       ; [call: new_29]: pass argument 0
fncall .16                              ; [call: new_29]: call function
addi $r540 $$locbase i16                ; get offset to local __ptr { u64, ( u64 | { u64, ( bool | { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) } ) } ) }
mcpi $r540 $r535 i72                    ; copy memory
lw $r542 $$locbase i2                   ; load word
eq $r543 $r542 $zero
jnzi $r543 .134
.135
lw $r545 $$locbase i2                   ; load word
eq $r546 $r545 $one
jnzi $r546 .136
.137
load $r547 data_NonConfigurable_6       ; load constant from data section
rvrt $r547
.136
addi $r548 $$locbase i16                ; get offset to local __ptr { u64, ( u64 | { u64, ( bool | { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) } ) } ) }
addi $r549 $r548 i8                     ; get offset to aggregate element
addi $r550 $$locbase i176               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r551 $$locbase i200               ; get offset to local __ptr { { ptr, u64, u64 } }
movi $$arg0 i1                          ; [call: abi_encode_21]: pass argument 0
move $$arg1 $r550                       ; [call: abi_encode_21]: pass argument 1
move $$arg2 $r551                       ; [call: abi_encode_21]: pass argument 2
fncall .10                              ; [call: abi_encode_21]: call function
addi $r553 $$locbase i88                ; get offset to local __ptr { u64, ( bool | { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) } ) }
mcpi $r553 $r549 i64                    ; copy memory
lw $r555 $$locbase i11                  ; load word
eq $r556 $r555 $zero
jnzi $r556 .138
.139
lw $r558 $$locbase i11                  ; load word
eq $r559 $r558 $one
jnzi $r559 .140
.141
load $r560 data_NonConfigurable_6       ; load constant from data section
rvrt $r560
.140
addi $r561 $$locbase i88                ; get offset to local __ptr { u64, ( bool | { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) } ) }
addi $r562 $r561 i8                     ; get offset to aggregate element
addi $r563 $$locbase i200               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r564 $$locbase i272               ; get offset to local __ptr { { ptr, u64, u64 } }
movi $$arg0 i1                          ; [call: abi_encode_21]: pass argument 0
move $$arg1 $r563                       ; [call: abi_encode_21]: pass argument 1
move $$arg2 $r564                       ; [call: abi_encode_21]: pass argument 2
fncall .10                              ; [call: abi_encode_21]: call function
addi $r566 $$locbase i272               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r567 $$locbase i152               ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r562                       ; [call: abi_encode_20]: pass argument 0
move $$arg1 $r566                       ; [call: abi_encode_20]: pass argument 1
move $$arg2 $r567                       ; [call: abi_encode_20]: pass argument 2
fncall .8                               ; [call: abi_encode_20]: call function
ji  .142
.138
addi $r569 $$locbase i88                ; get offset to local __ptr { u64, ( bool | { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) } ) }
addi $r570 $r569 i63                    ; get offset to aggregate element
lb $r571 $r570 i0                       ; load byte
addi $r572 $$locbase i200               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r573 $$locbase i248               ; get offset to local __ptr { { ptr, u64, u64 } }
movi $$arg0 i0                          ; [call: abi_encode_21]: pass argument 0
move $$arg1 $r572                       ; [call: abi_encode_21]: pass argument 1
move $$arg2 $r573                       ; [call: abi_encode_21]: pass argument 2
fncall .10                              ; [call: abi_encode_21]: call function
addi $r575 $$locbase i248               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r576 $$locbase i152               ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r571                       ; [call: abi_encode_23]: pass argument 0
move $$arg1 $r575                       ; [call: abi_encode_23]: pass argument 1
move $$arg2 $r576                       ; [call: abi_encode_23]: pass argument 2
fncall .12                              ; [call: abi_encode_23]: call function
.142
addi $r578 $$locbase i152               ; get offset to local __ptr { { ptr, u64, u64 } }
move $r579 $r578                        ; move parameter from branch to block argument
ji  .143
.134
lw $r582 $$locbase i10                  ; load word
addi $r583 $$locbase i176               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r584 $$locbase i224               ; get offset to local __ptr { { ptr, u64, u64 } }
movi $$arg0 i0                          ; [call: abi_encode_21]: pass argument 0
move $$arg1 $r583                       ; [call: abi_encode_21]: pass argument 1
move $$arg2 $r584                       ; [call: abi_encode_21]: pass argument 2
fncall .10                              ; [call: abi_encode_21]: call function
addi $r586 $$locbase i224               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r587 $$locbase i152               ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r582                       ; [call: abi_encode_21]: pass argument 0
move $$arg1 $r586                       ; [call: abi_encode_21]: pass argument 1
move $$arg2 $r587                       ; [call: abi_encode_21]: pass argument 2
fncall .10                              ; [call: abi_encode_21]: call function
addi $r589 $$locbase i152               ; get offset to local __ptr { { ptr, u64, u64 } }
move $r579 $r589                        ; move parameter from branch to block argument
.143
move $$arg0 $r579                       ; [call: as_raw_slice_30]: pass argument 0
move $$arg1 $r536                       ; [call: as_raw_slice_30]: pass argument 1
fncall .18                              ; [call: as_raw_slice_30]: call function
.144
.59
cfsi i296                               ; [fn end: encode_allow_alias_43] free: locals 296 byte(s), call args 0 slot(s)
move $$reta $r537                       ; [fn end: encode_allow_alias_43] restore return address
popa .58                                ; [fn end: encode_allow_alias_43] restore all used registers
jal $zero $$reta i0                     ; [fn end: encode_allow_alias_43] return from call
DIFF------------------------------
.program:
.62                                     ; --- start of function: encode_allow_alias_50 ---
pusha .62                               ; [fn init: encode_allow_alias_50]: push all used registers to stack
move $$locbase $sp                      ; [fn init: encode_allow_alias_50]: set locals base register
cfei i128                               ; [fn init: encode_allow_alias_50]: allocate: locals 128 byte(s), call args 0 slot(s)
move $r606 $$arg0                       ; [fn init: encode_allow_alias_50]: copy argument 0 (item)
move $r607 $$arg1                       ; [fn init: encode_allow_alias_50]: copy argument 1 (__ret_value)
move $r608 $$reta                       ; [fn init: encode_allow_alias_50]: save return address
.146
 jnzi $zero .147
 
ji  .148
.148
addi $r609 $$locbase i56                ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r609                       ; [call: new_29]: pass argument 0
fncall .16                              ; [call: new_29]: call function
 move $r610 $zero                        ; [call: new_29]: copy returned unit value
 movi $r610 i0                           ; [call: new_29]: copy returned unit value
addi $r611 $$locbase i16                ; get offset to local __ptr { u64, ( u64 | bool ) }
mcpi $r611 $r606 i16                    ; copy memory
addi $r612 $$locbase i16                ; get offset to local __ptr { u64, ( u64 | bool ) }
lw $r613 $$locbase i2                   ; load word
eq $r614 $r613 $zero
jnzi $r614 .149
ji  .150
.150
addi $r615 $$locbase i16                ; get offset to local __ptr { u64, ( u64 | bool ) }
lw $r616 $$locbase i2                   ; load word
eq $r617 $r616 $one
jnzi $r617 .151
ji  .152
.152
load $r618 data_NonConfigurable_6       ; load constant from data section
rvrt $r618
.151
addi $r619 $$locbase i16                ; get offset to local __ptr { u64, ( u64 | bool ) }
addi $r620 $r619 i15                    ; get offset to aggregate element
lb $r621 $r620 i0                       ; load byte
addi $r622 $$locbase i56                ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r623 $$locbase i104               ; get offset to local __ptr { { ptr, u64, u64 } }
 move $$arg0 $one                        ; [call: abi_encode_21]: pass argument 0
 movi $$arg0 i1                          ; [call: abi_encode_21]: pass argument 0
move $$arg1 $r622                       ; [call: abi_encode_21]: pass argument 1
move $$arg2 $r623                       ; [call: abi_encode_21]: pass argument 2
fncall .10                              ; [call: abi_encode_21]: call function
 move $r624 $zero                        ; [call: abi_encode_21]: copy returned unit value
 movi $r624 i0                           ; [call: abi_encode_21]: copy returned unit value
addi $r625 $$locbase i104               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r626 $$locbase i32                ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r621                       ; [call: abi_encode_23]: pass argument 0
move $$arg1 $r625                       ; [call: abi_encode_23]: pass argument 1
move $$arg2 $r626                       ; [call: abi_encode_23]: pass argument 2
fncall .12                              ; [call: abi_encode_23]: call function
 move $r627 $zero                        ; [call: abi_encode_23]: copy returned unit value
 movi $r627 i0                           ; [call: abi_encode_23]: copy returned unit value
addi $r628 $$locbase i32                ; get offset to local __ptr { { ptr, u64, u64 } }
move $r629 $r628                        ; move parameter from branch to block argument
ji  .153
.149
addi $r630 $$locbase i16                ; get offset to local __ptr { u64, ( u64 | bool ) }
addi $r631 $r630 i8                     ; get offset to aggregate element
lw $r632 $$locbase i3                   ; load word
addi $r633 $$locbase i56                ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r634 $$locbase i80                ; get offset to local __ptr { { ptr, u64, u64 } }
 move $$arg0 $zero                       ; [call: abi_encode_21]: pass argument 0
 movi $$arg0 i0                          ; [call: abi_encode_21]: pass argument 0
move $$arg1 $r633                       ; [call: abi_encode_21]: pass argument 1
move $$arg2 $r634                       ; [call: abi_encode_21]: pass argument 2
fncall .10                              ; [call: abi_encode_21]: call function
 move $r635 $zero                        ; [call: abi_encode_21]: copy returned unit value
 movi $r635 i0                           ; [call: abi_encode_21]: copy returned unit value
addi $r636 $$locbase i80                ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r637 $$locbase i32                ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r632                       ; [call: abi_encode_21]: pass argument 0
move $$arg1 $r636                       ; [call: abi_encode_21]: pass argument 1
move $$arg2 $r637                       ; [call: abi_encode_21]: pass argument 2
fncall .10                              ; [call: abi_encode_21]: call function
 move $r638 $zero                        ; [call: abi_encode_21]: copy returned unit value
 movi $r638 i0                           ; [call: abi_encode_21]: copy returned unit value
addi $r639 $$locbase i32                ; get offset to local __ptr { { ptr, u64, u64 } }
move $r629 $r639                        ; move parameter from branch to block argument
ji  .153
.153
move $r642 $r629                        ; move parameter from branch to block argument
 move $$arg0 $r642                       ; [call: as_raw_slice_30]: pass argument 0
 move $$arg0 $r629                       ; [call: as_raw_slice_30]: pass argument 0
move $$arg1 $r607                       ; [call: as_raw_slice_30]: pass argument 1
fncall .18                              ; [call: as_raw_slice_30]: call function
 move $r643 $zero                        ; [call: as_raw_slice_30]: copy returned unit value
 movi $r643 i0                           ; [call: as_raw_slice_30]: copy returned unit value
ji  .154
.147
sw $$locbase $r606 i0                   ; store word
addi $r644 $$locbase i8                 ; get offset to aggregate element
movi $r645 i16                          ; initialize constant into register
sw $$locbase $r645 i1                   ; store word
mcpi $r607 $$locbase i16                ; copy memory
ji  .154
.154
ji  .63
.63
cfsi i128                               ; [fn end: encode_allow_alias_50] free: locals 128 byte(s), call args 0 slot(s)
move $$reta $r608                       ; [fn end: encode_allow_alias_50] restore return address
popa .62                                ; [fn end: encode_allow_alias_50] restore all used registers
jal $zero $$reta i0                     ; [fn end: encode_allow_alias_50] return from call
DIFF------------------------------
.program:
.62                                     ; --- start of function: encode_allow_alias_50 ---
pusha .62                               ; [fn init: encode_allow_alias_50]: push all used registers to stack
move $$locbase $sp                      ; [fn init: encode_allow_alias_50]: set locals base register
cfei i128                               ; [fn init: encode_allow_alias_50]: allocate: locals 128 byte(s), call args 0 slot(s)
move $r606 $$arg0                       ; [fn init: encode_allow_alias_50]: copy argument 0 (item)
move $r607 $$arg1                       ; [fn init: encode_allow_alias_50]: copy argument 1 (__ret_value)
move $r608 $$reta                       ; [fn init: encode_allow_alias_50]: save return address
.146
.148
addi $r609 $$locbase i56                ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r609                       ; [call: new_29]: pass argument 0
fncall .16                              ; [call: new_29]: call function
addi $r611 $$locbase i16                ; get offset to local __ptr { u64, ( u64 | bool ) }
mcpi $r611 $r606 i16                    ; copy memory
lw $r613 $$locbase i2                   ; load word
eq $r614 $r613 $zero
jnzi $r614 .149
.150
lw $r616 $$locbase i2                   ; load word
eq $r617 $r616 $one
jnzi $r617 .151
.152
load $r618 data_NonConfigurable_6       ; load constant from data section
rvrt $r618
.151
addi $r619 $$locbase i16                ; get offset to local __ptr { u64, ( u64 | bool ) }
addi $r620 $r619 i15                    ; get offset to aggregate element
lb $r621 $r620 i0                       ; load byte
addi $r622 $$locbase i56                ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r623 $$locbase i104               ; get offset to local __ptr { { ptr, u64, u64 } }
movi $$arg0 i1                          ; [call: abi_encode_21]: pass argument 0
move $$arg1 $r622                       ; [call: abi_encode_21]: pass argument 1
move $$arg2 $r623                       ; [call: abi_encode_21]: pass argument 2
fncall .10                              ; [call: abi_encode_21]: call function
addi $r625 $$locbase i104               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r626 $$locbase i32                ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r621                       ; [call: abi_encode_23]: pass argument 0
move $$arg1 $r625                       ; [call: abi_encode_23]: pass argument 1
move $$arg2 $r626                       ; [call: abi_encode_23]: pass argument 2
fncall .12                              ; [call: abi_encode_23]: call function
addi $r628 $$locbase i32                ; get offset to local __ptr { { ptr, u64, u64 } }
move $r629 $r628                        ; move parameter from branch to block argument
ji  .153
.149
lw $r632 $$locbase i3                   ; load word
addi $r633 $$locbase i56                ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r634 $$locbase i80                ; get offset to local __ptr { { ptr, u64, u64 } }
movi $$arg0 i0                          ; [call: abi_encode_21]: pass argument 0
move $$arg1 $r633                       ; [call: abi_encode_21]: pass argument 1
move $$arg2 $r634                       ; [call: abi_encode_21]: pass argument 2
fncall .10                              ; [call: abi_encode_21]: call function
addi $r636 $$locbase i80                ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r637 $$locbase i32                ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r632                       ; [call: abi_encode_21]: pass argument 0
move $$arg1 $r636                       ; [call: abi_encode_21]: pass argument 1
move $$arg2 $r637                       ; [call: abi_encode_21]: pass argument 2
fncall .10                              ; [call: abi_encode_21]: call function
addi $r639 $$locbase i32                ; get offset to local __ptr { { ptr, u64, u64 } }
move $r629 $r639                        ; move parameter from branch to block argument
.153
move $$arg0 $r629                       ; [call: as_raw_slice_30]: pass argument 0
move $$arg1 $r607                       ; [call: as_raw_slice_30]: pass argument 1
fncall .18                              ; [call: as_raw_slice_30]: call function
.154
.63
cfsi i128                               ; [fn end: encode_allow_alias_50] free: locals 128 byte(s), call args 0 slot(s)
move $$reta $r608                       ; [fn end: encode_allow_alias_50] restore return address
popa .62                                ; [fn end: encode_allow_alias_50] restore all used registers
jal $zero $$reta i0                     ; [fn end: encode_allow_alias_50] return from call
DIFF------------------------------
.program:
.62                                     ; --- start of function: encode_allow_alias_50 ---
pusha .62                               ; [fn init: encode_allow_alias_50]: push all used registers to stack
move $$locbase $sp                      ; [fn init: encode_allow_alias_50]: set locals base register
cfei i128                               ; [fn init: encode_allow_alias_50]: allocate: locals 128 byte(s), call args 0 slot(s)
move $r606 $$arg0                       ; [fn init: encode_allow_alias_50]: copy argument 0 (item)
move $r607 $$arg1                       ; [fn init: encode_allow_alias_50]: copy argument 1 (__ret_value)
move $r608 $$reta                       ; [fn init: encode_allow_alias_50]: save return address
.146
.148
addi $r609 $$locbase i56                ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r609                       ; [call: new_29]: pass argument 0
fncall .16                              ; [call: new_29]: call function
addi $r611 $$locbase i16                ; get offset to local __ptr { u64, ( u64 | bool ) }
mcpi $r611 $r606 i16                    ; copy memory
lw $r613 $$locbase i2                   ; load word
eq $r614 $r613 $zero
jnzi $r614 .149
.150
lw $r616 $$locbase i2                   ; load word
eq $r617 $r616 $one
jnzi $r617 .151
.152
load $r618 data_NonConfigurable_6       ; load constant from data section
rvrt $r618
.151
addi $r619 $$locbase i16                ; get offset to local __ptr { u64, ( u64 | bool ) }
addi $r620 $r619 i15                    ; get offset to aggregate element
lb $r621 $r620 i0                       ; load byte
addi $r622 $$locbase i56                ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r623 $$locbase i104               ; get offset to local __ptr { { ptr, u64, u64 } }
movi $$arg0 i1                          ; [call: abi_encode_21]: pass argument 0
move $$arg1 $r622                       ; [call: abi_encode_21]: pass argument 1
move $$arg2 $r623                       ; [call: abi_encode_21]: pass argument 2
fncall .10                              ; [call: abi_encode_21]: call function
addi $r625 $$locbase i104               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r626 $$locbase i32                ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r621                       ; [call: abi_encode_23]: pass argument 0
move $$arg1 $r625                       ; [call: abi_encode_23]: pass argument 1
move $$arg2 $r626                       ; [call: abi_encode_23]: pass argument 2
fncall .12                              ; [call: abi_encode_23]: call function
addi $r628 $$locbase i32                ; get offset to local __ptr { { ptr, u64, u64 } }
move $r629 $r628                        ; move parameter from branch to block argument
ji  .153
.149
lw $r632 $$locbase i3                   ; load word
addi $r633 $$locbase i56                ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r634 $$locbase i80                ; get offset to local __ptr { { ptr, u64, u64 } }
movi $$arg0 i0                          ; [call: abi_encode_21]: pass argument 0
move $$arg1 $r633                       ; [call: abi_encode_21]: pass argument 1
move $$arg2 $r634                       ; [call: abi_encode_21]: pass argument 2
fncall .10                              ; [call: abi_encode_21]: call function
addi $r636 $$locbase i80                ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r637 $$locbase i32                ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r632                       ; [call: abi_encode_21]: pass argument 0
move $$arg1 $r636                       ; [call: abi_encode_21]: pass argument 1
move $$arg2 $r637                       ; [call: abi_encode_21]: pass argument 2
fncall .10                              ; [call: abi_encode_21]: call function
addi $r639 $$locbase i32                ; get offset to local __ptr { { ptr, u64, u64 } }
move $r629 $r639                        ; move parameter from branch to block argument
.153
move $$arg0 $r629                       ; [call: as_raw_slice_30]: pass argument 0
move $$arg1 $r607                       ; [call: as_raw_slice_30]: pass argument 1
fncall .18                              ; [call: as_raw_slice_30]: call function
.154
.63
cfsi i128                               ; [fn end: encode_allow_alias_50] free: locals 128 byte(s), call args 0 slot(s)
move $$reta $r608                       ; [fn end: encode_allow_alias_50] restore return address
popa .62                                ; [fn end: encode_allow_alias_50] restore all used registers
jal $zero $$reta i0                     ; [fn end: encode_allow_alias_50] return from call
DIFF------------------------------
.program:
.62                                     ; --- start of function: encode_allow_alias_50 ---
pusha .62                               ; [fn init: encode_allow_alias_50]: push all used registers to stack
move $$locbase $sp                      ; [fn init: encode_allow_alias_50]: set locals base register
cfei i128                               ; [fn init: encode_allow_alias_50]: allocate: locals 128 byte(s), call args 0 slot(s)
move $r606 $$arg0                       ; [fn init: encode_allow_alias_50]: copy argument 0 (item)
move $r607 $$arg1                       ; [fn init: encode_allow_alias_50]: copy argument 1 (__ret_value)
move $r608 $$reta                       ; [fn init: encode_allow_alias_50]: save return address
.146
.148
addi $r609 $$locbase i56                ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r609                       ; [call: new_29]: pass argument 0
fncall .16                              ; [call: new_29]: call function
addi $r611 $$locbase i16                ; get offset to local __ptr { u64, ( u64 | bool ) }
mcpi $r611 $r606 i16                    ; copy memory
lw $r613 $$locbase i2                   ; load word
eq $r614 $r613 $zero
jnzi $r614 .149
.150
lw $r616 $$locbase i2                   ; load word
eq $r617 $r616 $one
jnzi $r617 .151
.152
load $r618 data_NonConfigurable_6       ; load constant from data section
rvrt $r618
.151
addi $r619 $$locbase i16                ; get offset to local __ptr { u64, ( u64 | bool ) }
addi $r620 $r619 i15                    ; get offset to aggregate element
lb $r621 $r620 i0                       ; load byte
addi $r622 $$locbase i56                ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r623 $$locbase i104               ; get offset to local __ptr { { ptr, u64, u64 } }
movi $$arg0 i1                          ; [call: abi_encode_21]: pass argument 0
move $$arg1 $r622                       ; [call: abi_encode_21]: pass argument 1
move $$arg2 $r623                       ; [call: abi_encode_21]: pass argument 2
fncall .10                              ; [call: abi_encode_21]: call function
addi $r625 $$locbase i104               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r626 $$locbase i32                ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r621                       ; [call: abi_encode_23]: pass argument 0
move $$arg1 $r625                       ; [call: abi_encode_23]: pass argument 1
move $$arg2 $r626                       ; [call: abi_encode_23]: pass argument 2
fncall .12                              ; [call: abi_encode_23]: call function
addi $r628 $$locbase i32                ; get offset to local __ptr { { ptr, u64, u64 } }
move $r629 $r628                        ; move parameter from branch to block argument
ji  .153
.149
lw $r632 $$locbase i3                   ; load word
addi $r633 $$locbase i56                ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r634 $$locbase i80                ; get offset to local __ptr { { ptr, u64, u64 } }
movi $$arg0 i0                          ; [call: abi_encode_21]: pass argument 0
move $$arg1 $r633                       ; [call: abi_encode_21]: pass argument 1
move $$arg2 $r634                       ; [call: abi_encode_21]: pass argument 2
fncall .10                              ; [call: abi_encode_21]: call function
addi $r636 $$locbase i80                ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r637 $$locbase i32                ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r632                       ; [call: abi_encode_21]: pass argument 0
move $$arg1 $r636                       ; [call: abi_encode_21]: pass argument 1
move $$arg2 $r637                       ; [call: abi_encode_21]: pass argument 2
fncall .10                              ; [call: abi_encode_21]: call function
addi $r639 $$locbase i32                ; get offset to local __ptr { { ptr, u64, u64 } }
move $r629 $r639                        ; move parameter from branch to block argument
.153
move $$arg0 $r629                       ; [call: as_raw_slice_30]: pass argument 0
move $$arg1 $r607                       ; [call: as_raw_slice_30]: pass argument 1
fncall .18                              ; [call: as_raw_slice_30]: call function
.154
.63
cfsi i128                               ; [fn end: encode_allow_alias_50] free: locals 128 byte(s), call args 0 slot(s)
move $$reta $r608                       ; [fn end: encode_allow_alias_50] restore return address
popa .62                                ; [fn end: encode_allow_alias_50] restore all used registers
jal $zero $$reta i0                     ; [fn end: encode_allow_alias_50] return from call
    Finished release [optimized + fuel] target(s) [4.312 KB] in ???
     Running 18 tests, filtered 0 tests

tested -- panicking_lib

      test test_nested_panic_inlined ... ok (???, 1663 gas)
           revert code: 8000000000000000
             panic message: Error E.
             panic value:   E([AsciiString { data: "to have" }, AsciiString { data: "strings" }, AsciiString { data: "in error enum variants" }])
             panicked:      in panicking_lib::nested_panic_inlined
                                at panicking_lib, src/lib.sw:35:5
           decoded log values:
E([AsciiString { data: "to have" }, AsciiString { data: "strings" }, AsciiString { data: "in error enum variants" }]), log rb: 2721958641300806892
      test test_nested_panic_inlined_same_revert_code ... ok (???, 1663 gas)
           revert code: 8000000000000000
             panic message: Error E.
             panic value:   E([AsciiString { data: "to have" }, AsciiString { data: "strings" }, AsciiString { data: "in error enum variants" }])
             panicked:      in panicking_lib::nested_panic_inlined
                                at panicking_lib, src/lib.sw:35:5
           decoded log values:
E([AsciiString { data: "to have" }, AsciiString { data: "strings" }, AsciiString { data: "in error enum variants" }]), log rb: 2721958641300806892
      test test_nested_panic_non_inlined ... ok (???, 1695 gas)
           revert code: 8080000000000000
             panic message: Error E.
             panic value:   E([AsciiString { data: "this" }, AsciiString { data: "is not" }, AsciiString { data: "the best practice" }])
             panicked:      in panicking_lib::nested_panic_non_inlined
                                at panicking_lib, src/lib.sw:41:9
           decoded log values:
E([AsciiString { data: "this" }, AsciiString { data: "is not" }, AsciiString { data: "the best practice" }]), log rb: 2721958641300806892
      test test_nested_panic_non_inlined_same_revert_code ... ok (???, 1695 gas)
           revert code: 8080000000000000
             panic message: Error E.
             panic value:   E([AsciiString { data: "this" }, AsciiString { data: "is not" }, AsciiString { data: "the best practice" }])
             panicked:      in panicking_lib::nested_panic_non_inlined
                                at panicking_lib, src/lib.sw:41:9
           decoded log values:
E([AsciiString { data: "this" }, AsciiString { data: "is not" }, AsciiString { data: "the best practice" }]), log rb: 2721958641300806892
      test test_generic_panic_with_unit ... ok (???, 569 gas)
           revert code: 8100000000000000
             panic value:   ()
             panicked:      in panicking_lib::generic_panic
                                at panicking_lib, src/lib.sw:74:5
           decoded log values:
(), log rb: 3330666440490685604
      test test_generic_panic_with_unit_same_revert_code ... ok (???, 569 gas)
           revert code: 8100000000000000
             panic value:   ()
             panicked:      in panicking_lib::generic_panic
                                at panicking_lib, src/lib.sw:74:5
           decoded log values:
(), log rb: 3330666440490685604
      test test_generic_panic_with_str ... ok (???, 852 gas)
           revert code: 8180000000000000
             panic message: generic panic with string
             panicked:      in panicking_lib::generic_panic
                                at panicking_lib, src/lib.sw:74:5
           decoded log values:
AsciiString { data: "generic panic with string" }, log rb: 10098701174489624218
      test test_generic_panic_with_different_str_same_revert_code ... ok (???, 853 gas)
           revert code: 8180000000000000
             panic message: generic panic different string
             panicked:      in panicking_lib::generic_panic
                                at panicking_lib, src/lib.sw:74:5
           decoded log values:
AsciiString { data: "generic panic different string" }, log rb: 10098701174489624218
      test test_generic_panic_with_error_type_enum_variant ... ok (???, 898 gas)
           revert code: 8200000000000000
             panic message: Error A.
             panic value:   A
             panicked:      in panicking_lib::generic_panic
                                at panicking_lib, src/lib.sw:74:5
           decoded log values:
A, log rb: 2721958641300806892
      test test_generic_panic_with_error_type_enum_different_variant_same_revert_code ... ok (???, 898 gas)
           revert code: 8200000000000000
             panic message: Error A.
             panic value:   A
             panicked:      in panicking_lib::generic_panic
                                at panicking_lib, src/lib.sw:74:5
           decoded log values:
A, log rb: 2721958641300806892
      test test_panic_without_arg ... ok (???, 567 gas)
           revert code: 8280000000000000
             panic value:   ()
             panicked:      in panicking_lib::test_panic_without_arg
                                at panicking_lib, src/lib.sw:113:5
           decoded log values:
(), log rb: 3330666440490685604
      test test_panic_with_unit ... ok (???, 567 gas)
           revert code: 8300000000000000
             panic value:   ()
             panicked:      in panicking_lib::test_panic_with_unit
                                at panicking_lib, src/lib.sw:118:5
           decoded log values:
(), log rb: 3330666440490685604
      test test_panic_with_str ... ok (???, 79 gas)
           revert code: 8380000000000000
             panic message: panic with string
             panicked:      in panicking_lib::test_panic_with_str
                                at panicking_lib, src/lib.sw:123:5
      test test_panic_with_error_type_enum ... ok (???, 1054 gas)
           revert code: 8400000000000000
             panic message: Error C.
             panic value:   C(true)
             panicked:      in panicking_lib::test_panic_with_error_type_enum
                                at panicking_lib, src/lib.sw:128:5
           decoded log values:
C(true), log rb: 2721958641300806892
      test test_panic_with_generic_error_type_enum ... ok (???, 904 gas)
           revert code: 8480000000000000
             panic value:   A(42)
             panicked:      in panicking_lib::test_panic_with_generic_error_type_enum
                                at panicking_lib, src/lib.sw:133:5
           decoded log values:
A(42), log rb: 12408470889216862137
      test test_panic_with_nested_generic_error_type ... ok (???, 1300 gas)
           revert code: 8500000000000000
             panic value:   B(B(C(true)))
             panicked:      in panicking_lib::test_panic_with_nested_generic_error_type
                                at panicking_lib, src/lib.sw:138:5
           decoded log values:
B(B(C(true))), log rb: 14988555917426256081
      test test_panic_with_generic_error_type_enum_with_abi_encode ... ok (???, 904 gas)
           revert code: 8580000000000000
             panic value:   A(42)
             panicked:      in panicking_lib::test_panic_with_generic_error_type_enum_with_abi_encode
                                at panicking_lib, src/lib.sw:143:5
           decoded log values:
A(42), log rb: 17388243649088655852
      test test_panic_with_nested_generic_error_type_enum_with_abi_encode ... ok (???, 1300 gas)
           revert code: 8600000000000000
             panic value:   B(B(C(true)))
             panicked:      in panicking_lib::test_panic_with_nested_generic_error_type_enum_with_abi_encode
                                at panicking_lib, src/lib.sw:148:5
           decoded log values:
B(B(C(true))), log rb: 3755100321495500961

test result: OK. 18 passed; 0 failed; finished in ???

    Finished in ???
