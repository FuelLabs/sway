---
source: test/src/snapshot/mod.rs
---
> forc test --path test/src/e2e_vm_tests/test_programs/should_pass/language/panic_expression/panicking_script --test-threads 1 --logs --reverts
exit status: 0
output:
    Building test/src/e2e_vm_tests/test_programs/should_pass/language/panic_expression/panicking_script
   Compiling library std (test/src/e2e_vm_tests/reduced_std_libs/sway-lib-std-core)
DIFF------------------------------
.program:
   Compiling library panicking_lib (test/src/e2e_vm_tests/test_programs/should_pass/language/panic_expression/panicking_lib)
DIFF------------------------------
.program:
   Compiling script panicking_script (test/src/e2e_vm_tests/test_programs/should_pass/language/panic_expression/panicking_script)
DIFF------------------------------
.program:
DIFF------------------------------
.program:
.0                                      ; --- start of function: __entry ---
move $$locbase $sp                      ; [entry init: __entry]: set locals base register
cfei i0                                 ; [entry init: __entry]: allocate: locals 0 byte(s), call args 0 slot(s)
.46
fncall .2                               ; [call: main_0]: call function
 move $r1 $zero                          ; [call: main_0]: copy returned unit value
 movi $r1 i0                             ; [call: main_0]: copy returned unit value
retd $zero $zero                        ; [entry end: __entry] return slice
DIFF------------------------------
.program:
.14                                     ; --- start of function: test_panic_in_main ---
move $$locbase $sp                      ; [entry init: test_panic_in_main]: set locals base register
cfei i0                                 ; [entry init: test_panic_in_main]: allocate: locals 0 byte(s), call args 0 slot(s)
.95
fncall .2                               ; [call: main_0]: call function
 move $r444 $zero                        ; [call: main_0]: copy returned unit value
 movi $r444 i0                           ; [call: main_0]: copy returned unit value
ret $zero                               ; [entry end: test_panic_in_main] return unit as zero
DIFF------------------------------
.program:
.16                                     ; --- start of function: test_nested_panic_inlined ---
move $$locbase $sp                      ; [entry init: test_nested_panic_inlined]: set locals base register
cfei i0                                 ; [entry init: test_nested_panic_inlined]: allocate: locals 0 byte(s), call args 0 slot(s)
.96
movi $r446 i2                           ; initialize constant into register
 move $$arg0 $r446                       ; [call: call_nested_panic_inlined_30]: pass argument 0
 movi $$arg0 i2                          ; [call: call_nested_panic_inlined_30]: pass argument 0
fncall .18                              ; [call: call_nested_panic_inlined_30]: call function
 move $r447 $zero                        ; [call: call_nested_panic_inlined_30]: copy returned unit value
 movi $r447 i0                           ; [call: call_nested_panic_inlined_30]: copy returned unit value
ret $zero                               ; [entry end: test_nested_panic_inlined] return unit as zero
DIFF------------------------------
.program:
.20                                     ; --- start of function: test_nested_panic_inlined_same_revert_code ---
move $$locbase $sp                      ; [entry init: test_nested_panic_inlined_same_revert_code]: set locals base register
cfei i0                                 ; [entry init: test_nested_panic_inlined_same_revert_code]: allocate: locals 0 byte(s), call args 0 slot(s)
.98
movi $r491 i3                           ; initialize constant into register
 move $$arg0 $r491                       ; [call: call_nested_panic_inlined_30]: pass argument 0
 movi $$arg0 i3                          ; [call: call_nested_panic_inlined_30]: pass argument 0
fncall .18                              ; [call: call_nested_panic_inlined_30]: call function
 move $r492 $zero                        ; [call: call_nested_panic_inlined_30]: copy returned unit value
 movi $r492 i0                           ; [call: call_nested_panic_inlined_30]: copy returned unit value
ret $zero                               ; [entry end: test_nested_panic_inlined_same_revert_code] return unit as zero
DIFF------------------------------
.program:
.22                                     ; --- start of function: test_nested_panic_non_inlined ---
move $$locbase $sp                      ; [entry init: test_nested_panic_non_inlined]: set locals base register
cfei i0                                 ; [entry init: test_nested_panic_non_inlined]: allocate: locals 0 byte(s), call args 0 slot(s)
.99
movi $r494 i5                           ; initialize constant into register
 move $$arg0 $r494                       ; [call: call_nested_panic_non_inlined_32]: pass argument 0
 movi $$arg0 i5                          ; [call: call_nested_panic_non_inlined_32]: pass argument 0
fncall .24                              ; [call: call_nested_panic_non_inlined_32]: call function
 move $r495 $zero                        ; [call: call_nested_panic_non_inlined_32]: copy returned unit value
 movi $r495 i0                           ; [call: call_nested_panic_non_inlined_32]: copy returned unit value
ret $zero                               ; [entry end: test_nested_panic_non_inlined] return unit as zero
DIFF------------------------------
.program:
.28                                     ; --- start of function: test_nested_panic_non_inlined_same_revert_code ---
move $$locbase $sp                      ; [entry init: test_nested_panic_non_inlined_same_revert_code]: set locals base register
cfei i0                                 ; [entry init: test_nested_panic_non_inlined_same_revert_code]: allocate: locals 0 byte(s), call args 0 slot(s)
.104
movi $r547 i6                           ; initialize constant into register
 move $$arg0 $r547                       ; [call: call_nested_panic_non_inlined_32]: pass argument 0
 movi $$arg0 i6                          ; [call: call_nested_panic_non_inlined_32]: pass argument 0
fncall .24                              ; [call: call_nested_panic_non_inlined_32]: call function
 move $r548 $zero                        ; [call: call_nested_panic_non_inlined_32]: copy returned unit value
 movi $r548 i0                           ; [call: call_nested_panic_non_inlined_32]: copy returned unit value
ret $zero                               ; [entry end: test_nested_panic_non_inlined_same_revert_code] return unit as zero
DIFF------------------------------
.program:
.30                                     ; --- start of function: test_generic_panic_with_unit ---
move $$locbase $sp                      ; [entry init: test_generic_panic_with_unit]: set locals base register
cfei i0                                 ; [entry init: test_generic_panic_with_unit]: allocate: locals 0 byte(s), call args 0 slot(s)
.105
 move $$arg0 $zero                       ; [call: generic_panic_34]: pass argument 0
 movi $$arg0 i0                          ; [call: generic_panic_34]: pass argument 0
movi $r550 i7                           ; initialize constant into register
 move $$arg1 $r550                       ; [call: generic_panic_34]: pass argument 1
 movi $$arg1 i7                          ; [call: generic_panic_34]: pass argument 1
fncall .32                              ; [call: generic_panic_34]: call function
 move $r551 $zero                        ; [call: generic_panic_34]: copy returned unit value
 movi $r551 i0                           ; [call: generic_panic_34]: copy returned unit value
ret $zero                               ; [entry end: test_generic_panic_with_unit] return unit as zero
DIFF------------------------------
.program:
.34                                     ; --- start of function: test_generic_panic_with_unit_same_revert_code ---
move $$locbase $sp                      ; [entry init: test_generic_panic_with_unit_same_revert_code]: set locals base register
cfei i0                                 ; [entry init: test_generic_panic_with_unit_same_revert_code]: allocate: locals 0 byte(s), call args 0 slot(s)
.110
 move $$arg0 $zero                       ; [call: generic_panic_34]: pass argument 0
 movi $$arg0 i0                          ; [call: generic_panic_34]: pass argument 0
movi $r586 i8                           ; initialize constant into register
 move $$arg1 $r586                       ; [call: generic_panic_34]: pass argument 1
 movi $$arg1 i8                          ; [call: generic_panic_34]: pass argument 1
fncall .32                              ; [call: generic_panic_34]: call function
 move $r587 $zero                        ; [call: generic_panic_34]: copy returned unit value
 movi $r587 i0                           ; [call: generic_panic_34]: copy returned unit value
ret $zero                               ; [entry end: test_generic_panic_with_unit_same_revert_code] return unit as zero
DIFF------------------------------
.program:
.36                                     ; --- start of function: test_generic_panic_with_str ---
move $$locbase $sp                      ; [entry init: test_generic_panic_with_str]: set locals base register
cfei i32                                ; [entry init: test_generic_panic_with_str]: allocate: locals 32 byte(s), call args 0 slot(s)
.111
addr $r589 data_NonConfigurable_16      ; get __const_global5's address in data section
sw $$locbase $r589 i0                   ; store word
addi $r590 $$locbase i8                 ; get offset to aggregate element
movi $r591 i25                          ; initialize constant into register
sw $$locbase $r591 i1                   ; store word
addi $r592 $$locbase i16                ; get offset to local __ptr slice
mcpi $r592 $$locbase i16                ; copy memory
addi $r593 $$locbase i16                ; get offset to local __ptr slice
move $$arg0 $r593                       ; [call: generic_panic_37]: pass argument 0
movi $r594 i9                           ; initialize constant into register
 move $$arg1 $r594                       ; [call: generic_panic_37]: pass argument 1
 movi $$arg1 i9                          ; [call: generic_panic_37]: pass argument 1
fncall .38                              ; [call: generic_panic_37]: call function
 move $r595 $zero                        ; [call: generic_panic_37]: copy returned unit value
 movi $r595 i0                           ; [call: generic_panic_37]: copy returned unit value
ret $zero                               ; [entry end: test_generic_panic_with_str] return unit as zero
DIFF------------------------------
.program:
.40                                     ; --- start of function: test_generic_panic_with_different_str_same_revert_code ---
move $$locbase $sp                      ; [entry init: test_generic_panic_with_different_str_same_revert_code]: set locals base register
cfei i32                                ; [entry init: test_generic_panic_with_different_str_same_revert_code]: allocate: locals 32 byte(s), call args 0 slot(s)
.116
addr $r636 data_NonConfigurable_19      ; get __const_global6's address in data section
sw $$locbase $r636 i0                   ; store word
addi $r637 $$locbase i8                 ; get offset to aggregate element
movi $r638 i35                          ; initialize constant into register
sw $$locbase $r638 i1                   ; store word
addi $r639 $$locbase i16                ; get offset to local __ptr slice
mcpi $r639 $$locbase i16                ; copy memory
addi $r640 $$locbase i16                ; get offset to local __ptr slice
move $$arg0 $r640                       ; [call: generic_panic_37]: pass argument 0
movi $r641 i10                          ; initialize constant into register
 move $$arg1 $r641                       ; [call: generic_panic_37]: pass argument 1
 movi $$arg1 i10                         ; [call: generic_panic_37]: pass argument 1
fncall .38                              ; [call: generic_panic_37]: call function
 move $r642 $zero                        ; [call: generic_panic_37]: copy returned unit value
 movi $r642 i0                           ; [call: generic_panic_37]: copy returned unit value
ret $zero                               ; [entry end: test_generic_panic_with_different_str_same_revert_code] return unit as zero
DIFF------------------------------
.program:
.42                                     ; --- start of function: test_generic_panic_with_error_type_enum ---
move $$locbase $sp                      ; [entry init: test_generic_panic_with_error_type_enum]: set locals base register
cfei i144                               ; [entry init: test_generic_panic_with_error_type_enum]: allocate: locals 144 byte(s), call args 0 slot(s)
.117
sw $$locbase $zero i0                   ; store word
addi $r644 $$locbase i88                ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
mcpi $r644 $$locbase i56                ; copy memory
addi $r645 $$locbase i88                ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
addi $r646 $$locbase i72                ; get offset to local __ptr slice
move $$arg0 $r645                       ; [call: encode_allow_alias_1]: pass argument 0
move $$arg1 $r646                       ; [call: encode_allow_alias_1]: pass argument 1
fncall .4                               ; [call: encode_allow_alias_1]: call function
 move $r647 $zero                        ; [call: encode_allow_alias_1]: copy returned unit value
 movi $r647 i0                           ; [call: encode_allow_alias_1]: copy returned unit value
addi $r648 $$locbase i56                ; get offset to local __ptr slice
mcpi $r648 $r646 i16                    ; copy memory
load $r649 data_NonConfigurable_0       ; load constant from data section
lw $r650 $$locbase i7                   ; load slice pointer for logging data
lw $r651 $$locbase i8                   ; load slice size for logging data
logd $zero $r649 $r650 $r651            ; log slice
movi $r652 i11                          ; initialize constant into register
load $r653 data_NonConfigurable_8       ; load constant from data section
 and $r654 $r652 $r653
 andi $r654 $r653 i11
load $r655 data_NonConfigurable_20      ; load constant from data section
or $r656 $r655 $r654
rvrt $r656
DIFF------------------------------
.program:
.44                                     ; --- start of function: test_generic_panic_with_error_type_enum_different_variant_same_revert_code ---
move $$locbase $sp                      ; [entry init: test_generic_panic_with_error_type_enum_different_variant_same_revert_code]: set locals base register
cfei i144                               ; [entry init: test_generic_panic_with_error_type_enum_different_variant_same_revert_code]: allocate: locals 144 byte(s), call args 0 slot(s)
.118
sw $$locbase $one i0                    ; store word
addi $r658 $$locbase i55                ; get offset to aggregate element
movi $r659 i42                          ; initialize constant into register
sb $r658 $r659 i0                       ; store byte
addi $r660 $$locbase i88                ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
mcpi $r660 $$locbase i56                ; copy memory
addi $r661 $$locbase i88                ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
addi $r662 $$locbase i72                ; get offset to local __ptr slice
move $$arg0 $r661                       ; [call: encode_allow_alias_1]: pass argument 0
move $$arg1 $r662                       ; [call: encode_allow_alias_1]: pass argument 1
fncall .4                               ; [call: encode_allow_alias_1]: call function
 move $r663 $zero                        ; [call: encode_allow_alias_1]: copy returned unit value
 movi $r663 i0                           ; [call: encode_allow_alias_1]: copy returned unit value
addi $r664 $$locbase i56                ; get offset to local __ptr slice
mcpi $r664 $r662 i16                    ; copy memory
load $r665 data_NonConfigurable_0       ; load constant from data section
lw $r666 $$locbase i7                   ; load slice pointer for logging data
lw $r667 $$locbase i8                   ; load slice size for logging data
logd $zero $r665 $r666 $r667            ; log slice
movi $r668 i12                          ; initialize constant into register
load $r669 data_NonConfigurable_8       ; load constant from data section
 and $r670 $r668 $r669
 andi $r670 $r669 i12
load $r671 data_NonConfigurable_20      ; load constant from data section
or $r672 $r671 $r670
rvrt $r672
DIFF------------------------------
.program:
.2                                      ; --- start of function: main_0 ---
pusha .2                                ; [fn init: main_0]: push all used registers to stack
move $$locbase $sp                      ; [fn init: main_0]: set locals base register
cfei i88                                ; [fn init: main_0]: allocate: locals 88 byte(s), call args 0 slot(s)
move $r2 $$reta                         ; [fn init: main_0]: save return address
.47
movi $r3 i2                             ; initialize constant into register
sw $$locbase $r3 i0                     ; store word
addi $r4 $$locbase i55                  ; get offset to aggregate element
sb $r4 $one i0                          ; store byte
addi $r5 $$locbase i72                  ; get offset to local __ptr slice
move $$arg0 $$locbase                   ; [call: encode_allow_alias_1]: pass argument 0
move $$arg1 $r5                         ; [call: encode_allow_alias_1]: pass argument 1
fncall .4                               ; [call: encode_allow_alias_1]: call function
 move $r6 $zero                          ; [call: encode_allow_alias_1]: copy returned unit value
 movi $r6 i0                             ; [call: encode_allow_alias_1]: copy returned unit value
addi $r7 $$locbase i56                  ; get offset to local __ptr slice
mcpi $r7 $r5 i16                        ; copy memory
load $r8 data_NonConfigurable_0         ; load constant from data section
lw $r9 $$locbase i7                     ; load slice pointer for logging data
lw $r10 $$locbase i8                    ; load slice size for logging data
logd $zero $r8 $r9 $r10                 ; log slice
load $r11 data_NonConfigurable_1        ; load constant from data section
rvrt $r11
.3
cfsi i88                                ; [fn end: main_0] free: locals 88 byte(s), call args 0 slot(s)
move $$reta $r2                         ; [fn end: main_0] restore return address
popa .2                                 ; [fn end: main_0] restore all used registers
jal $zero $$reta i0                     ; [fn end: main_0] return from call
DIFF------------------------------
.program:
.4                                      ; --- start of function: encode_allow_alias_1 ---
pusha .4                                ; [fn init: encode_allow_alias_1]: push all used registers to stack
move $$locbase $sp                      ; [fn init: encode_allow_alias_1]: set locals base register
cfei i1864                              ; [fn init: encode_allow_alias_1]: allocate: locals 1864 byte(s), call args 0 slot(s)
move $r12 $$arg0                        ; [fn init: encode_allow_alias_1]: copy argument 0 (item)
move $r13 $$arg1                        ; [fn init: encode_allow_alias_1]: copy argument 1 (__ret_value)
move $r14 $$reta                        ; [fn init: encode_allow_alias_1]: save return address
.48
addi $r15 $$locbase i1488               ; get offset to local __ptr __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
 sw $$locbase $r12 i186                  ; store word
 sw $$locbase $$arg0 i186                ; store word
addi $r16 $$locbase i1568               ; get offset to local __ptr u64
load $r17 data_NonConfigurable_2        ; load constant from data section
sw $$locbase $r17 i196                  ; store word
addi $r18 $$locbase i1496               ; get offset to local __ptr u64
sw $$locbase $zero i187                 ; store word
addi $r19 $$locbase i1568               ; get offset to local __ptr u64
lw $r20 $$locbase i196                  ; load word
addi $r21 $$locbase i1496               ; get offset to local __ptr u64
lw $r22 $$locbase i187                  ; load word
eq $r23 $r20 $r22
move $r24 $r23                          ; move parameter from branch to block argument
jnzi $r23 .49
ji  .50
.49
 move $r24 $one                          ; move parameter from branch to block argument
 movi $r24 i1                            ; move parameter from branch to block argument
ji  .50
.50
move $r27 $r24                          ; move parameter from branch to block argument
 move $r28 $r27                          ; move parameter from branch to block argument
 jnzi $r27 .51
 move $r28 $r24                          ; move parameter from branch to block argument
 jnzi $r24 .51
ji  .52
.51
 move $r28 $one                          ; move parameter from branch to block argument
 movi $r28 i1                            ; move parameter from branch to block argument
ji  .52
.52
move $r31 $r28                          ; move parameter from branch to block argument
 move $r32 $r31                          ; move parameter from branch to block argument
 jnzi $r31 .53
 move $r32 $r28                          ; move parameter from branch to block argument
 jnzi $r28 .53
ji  .54
.53
 move $r32 $one                          ; move parameter from branch to block argument
 movi $r32 i1                            ; move parameter from branch to block argument
ji  .54
.54
move $r35 $r32                          ; move parameter from branch to block argument
 move $r36 $r35                          ; move parameter from branch to block argument
 jnzi $r35 .55
 move $r36 $r32                          ; move parameter from branch to block argument
 jnzi $r32 .55
ji  .56
.55
addi $r37 $$locbase i1576               ; get offset to local __ptr u64
load $r38 data_NonConfigurable_3        ; load constant from data section
sw $$locbase $r38 i197                  ; store word
addi $r39 $$locbase i1504               ; get offset to local __ptr u64
load $r40 data_NonConfigurable_3        ; load constant from data section
sw $$locbase $r40 i188                  ; store word
addi $r41 $$locbase i1576               ; get offset to local __ptr u64
lw $r42 $$locbase i197                  ; load word
addi $r43 $$locbase i1504               ; get offset to local __ptr u64
lw $r44 $$locbase i188                  ; load word
eq $r45 $r42 $r44
move $r46 $r45                          ; move parameter from branch to block argument
jnzi $r45 .57
ji  .58
.57
 move $r46 $one                          ; move parameter from branch to block argument
 movi $r46 i1                            ; move parameter from branch to block argument
ji  .58
.58
move $r49 $r46                          ; move parameter from branch to block argument
 move $r50 $r49                          ; move parameter from branch to block argument
 jnzi $r49 .59
 move $r50 $r46                          ; move parameter from branch to block argument
 jnzi $r46 .59
ji  .60
.59
 move $r50 $one                          ; move parameter from branch to block argument
 movi $r50 i1                            ; move parameter from branch to block argument
ji  .60
.60
move $r53 $r50                          ; move parameter from branch to block argument
 move $r36 $r53                          ; move parameter from branch to block argument
 move $r36 $r50                          ; move parameter from branch to block argument
ji  .56
.56
move $r56 $r36                          ; move parameter from branch to block argument
 move $r57 $r56                          ; move parameter from branch to block argument
 jnzi $r56 .61
 move $r57 $r36                          ; move parameter from branch to block argument
 jnzi $r36 .61
ji  .62
.61
 move $r57 $zero                         ; move parameter from branch to block argument
 movi $r57 i0                            ; move parameter from branch to block argument
ji  .62
.62
move $r60 $r57                          ; move parameter from branch to block argument
 jnzi $r60 .63
 jnzi $r57 .63
ji  .64
.64
addi $r61 $$locbase i1488               ; get offset to local __ptr __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
lw $r62 $$locbase i186                  ; load word
addi $r63 $$locbase i456                ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r63                        ; [call: new_28]: pass argument 0
fncall .10                              ; [call: new_28]: call function
 move $r64 $zero                         ; [call: new_28]: copy returned unit value
 movi $r64 i0                            ; [call: new_28]: copy returned unit value
addi $r65 $$locbase i1600               ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
mcpi $r65 $r62 i56                      ; copy memory
addi $r66 $$locbase i1072               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r66 $r63 i24                      ; copy memory
addi $r67 $$locbase i1600               ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
addi $r68 $$locbase i208                ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
mcpi $r68 $r67 i56                      ; copy memory
addi $r69 $$locbase i208                ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
addi $r70 $$locbase i1584               ; get offset to local __ptr u64
mcpi $r70 $r69 i8                       ; copy memory
addi $r71 $$locbase i1528               ; get offset to local __ptr u64
sw $$locbase $zero i191                 ; store word
addi $r72 $$locbase i1584               ; get offset to local __ptr u64
lw $r73 $$locbase i198                  ; load word
addi $r74 $$locbase i1528               ; get offset to local __ptr u64
lw $r75 $$locbase i191                  ; load word
eq $r76 $r73 $r75
jnzi $r76 .65
ji  .66
.66
addi $r77 $$locbase i208                ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
addi $r78 $$locbase i1656               ; get offset to local __ptr u64
mcpi $r78 $r77 i8                       ; copy memory
addi $r79 $$locbase i1512               ; get offset to local __ptr u64
sw $$locbase $one i189                  ; store word
addi $r80 $$locbase i1656               ; get offset to local __ptr u64
lw $r81 $$locbase i207                  ; load word
addi $r82 $$locbase i1512               ; get offset to local __ptr u64
lw $r83 $$locbase i189                  ; load word
eq $r84 $r81 $r83
jnzi $r84 .67
ji  .68
.68
addi $r85 $$locbase i208                ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
addi $r86 $$locbase i1680               ; get offset to local __ptr u64
mcpi $r86 $r85 i8                       ; copy memory
addi $r87 $$locbase i1536               ; get offset to local __ptr u64
movi $r88 i2                            ; initialize constant into register
sw $$locbase $r88 i192                  ; store word
addi $r89 $$locbase i1680               ; get offset to local __ptr u64
lw $r90 $$locbase i210                  ; load word
addi $r91 $$locbase i1536               ; get offset to local __ptr u64
lw $r92 $$locbase i192                  ; load word
eq $r93 $r90 $r92
jnzi $r93 .69
ji  .70
.70
addi $r94 $$locbase i208                ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
addi $r95 $$locbase i1696               ; get offset to local __ptr u64
mcpi $r95 $r94 i8                       ; copy memory
addi $r96 $$locbase i1544               ; get offset to local __ptr u64
movi $r97 i3                            ; initialize constant into register
sw $$locbase $r97 i193                  ; store word
addi $r98 $$locbase i1696               ; get offset to local __ptr u64
lw $r99 $$locbase i212                  ; load word
addi $r100 $$locbase i1544              ; get offset to local __ptr u64
lw $r101 $$locbase i193                 ; load word
eq $r102 $r99 $r101
jnzi $r102 .71
ji  .72
.72
addi $r103 $$locbase i208               ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
addi $r104 $$locbase i1720              ; get offset to local __ptr u64
mcpi $r104 $r103 i8                     ; copy memory
addi $r105 $$locbase i1552              ; get offset to local __ptr u64
movi $r106 i4                           ; initialize constant into register
sw $$locbase $r106 i194                 ; store word
addi $r107 $$locbase i1720              ; get offset to local __ptr u64
lw $r108 $$locbase i215                 ; load word
addi $r109 $$locbase i1552              ; get offset to local __ptr u64
lw $r110 $$locbase i194                 ; load word
eq $r111 $r108 $r110
jnzi $r111 .73
ji  .74
.74
load $r112 data_NonConfigurable_4       ; load constant from data section
rvrt $r112
.73
addi $r113 $$locbase i208               ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
addi $r114 $r113 i8                     ; get offset to aggregate element
addi $r115 $$locbase i1816              ; get offset to local __ptr [slice; 3]
mcpi $r115 $r114 i48                    ; copy memory
addi $r116 $$locbase i1072              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r117 $$locbase i688               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r117 $r116 i24                    ; copy memory
addi $r118 $$locbase i408               ; get offset to local __ptr { { ptr, u64, u64 } }
movi $r119 i4                           ; initialize constant into register
 move $$arg0 $r119                       ; [call: abi_encode_20]: pass argument 0
 movi $$arg0 i4                          ; [call: abi_encode_20]: pass argument 0
move $$arg1 $r117                       ; [call: abi_encode_20]: pass argument 1
move $$arg2 $r118                       ; [call: abi_encode_20]: pass argument 2
fncall .6                               ; [call: abi_encode_20]: call function
 move $r120 $zero                        ; [call: abi_encode_20]: copy returned unit value
 movi $r120 i0                           ; [call: abi_encode_20]: copy returned unit value
addi $r121 $$locbase i1408              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r121 $r118 i24                    ; copy memory
addi $r122 $$locbase i1816              ; get offset to local __ptr [slice; 3]
addi $r123 $$locbase i1408              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r124 $$locbase i1728              ; get offset to local __ptr [slice; 3]
mcpi $r124 $r122 i48                    ; copy memory
addi $r125 $$locbase i1168              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r125 $r123 i24                    ; copy memory
addi $r126 $$locbase i1168              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r127 $$locbase i1240              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r127 $r126 i24                    ; copy memory
addi $r128 $$locbase i1480              ; get offset to local __ptr u64
sw $$locbase $zero i185                 ; store word
ji  .75
.75
addi $r129 $$locbase i1480              ; get offset to local __ptr u64
addi $r130 $$locbase i1592              ; get offset to local __ptr u64
mcpi $r130 $r129 i8                     ; copy memory
addi $r131 $$locbase i1560              ; get offset to local __ptr u64
movi $r132 i3                           ; initialize constant into register
sw $$locbase $r132 i195                 ; store word
addi $r133 $$locbase i1592              ; get offset to local __ptr u64
lw $r134 $$locbase i199                 ; load word
addi $r135 $$locbase i1560              ; get offset to local __ptr u64
lw $r136 $$locbase i195                 ; load word
lt $r137 $r134 $r136
jnzi $r137 .76
ji  .77
.77
addi $r138 $$locbase i1240              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r139 $$locbase i848               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r139 $r138 i24                    ; copy memory
addi $r140 $$locbase i1432              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r140 $r139 i24                    ; copy memory
addi $r141 $$locbase i1432              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r142 $$locbase i872               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r142 $r141 i24                    ; copy memory
addi $r143 $$locbase i896               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r143 $r142 i24                    ; copy memory
move $r144 $r143                        ; move parameter from branch to block argument
ji  .78
.76
addi $r145 $$locbase i1728              ; get offset to local __ptr [slice; 3]
addi $r146 $$locbase i1480              ; get offset to local __ptr u64
lw $r147 $$locbase i185                 ; load word
movi $r148 i16                          ; get array element size
 mul $r149 $r147 $r148                   ; get offset to array element
 muli $r149 $r147 i16                    ; get offset to array element
add $r149 $r145 $r149                   ; add array element offset to array base
addi $r150 $$locbase i1240              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r151 $$locbase i712               ; get offset to local __ptr slice
mcpi $r151 $r149 i16                    ; copy memory
addi $r152 $$locbase i728               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r152 $r150 i24                    ; copy memory
addi $r153 $$locbase i432               ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r151                       ; [call: abi_encode_26]: pass argument 0
move $$arg1 $r152                       ; [call: abi_encode_26]: pass argument 1
move $$arg2 $r153                       ; [call: abi_encode_26]: pass argument 2
fncall .8                               ; [call: abi_encode_26]: call function
 move $r154 $zero                        ; [call: abi_encode_26]: copy returned unit value
 movi $r154 i0                           ; [call: abi_encode_26]: copy returned unit value
addi $r155 $$locbase i1240              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r155 $r153 i24                    ; copy memory
addi $r156 $$locbase i1480              ; get offset to local __ptr u64
addi $r157 $$locbase i1664              ; get offset to local __ptr u64
mcpi $r157 $r156 i8                     ; copy memory
addi $r158 $$locbase i1520              ; get offset to local __ptr u64
sw $$locbase $one i190                  ; store word
addi $r159 $$locbase i1664              ; get offset to local __ptr u64
lw $r160 $$locbase i208                 ; load word
addi $r161 $$locbase i1520              ; get offset to local __ptr u64
lw $r162 $$locbase i190                 ; load word
add $r163 $r160 $r162
addi $r164 $$locbase i1480              ; get offset to local __ptr u64
sw $$locbase $r163 i185                 ; store word
ji  .75
.71
addi $r165 $$locbase i208               ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
addi $r166 $r165 i40                    ; get offset to aggregate element
addi $r167 $$locbase i1800              ; get offset to local __ptr { u64, u64 }
mcpi $r167 $r166 i16                    ; copy memory
addi $r168 $$locbase i1072              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r169 $$locbase i616               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r169 $r168 i24                    ; copy memory
addi $r170 $$locbase i336               ; get offset to local __ptr { { ptr, u64, u64 } }
movi $r171 i3                           ; initialize constant into register
 move $$arg0 $r171                       ; [call: abi_encode_20]: pass argument 0
 movi $$arg0 i3                          ; [call: abi_encode_20]: pass argument 0
move $$arg1 $r169                       ; [call: abi_encode_20]: pass argument 1
move $$arg2 $r170                       ; [call: abi_encode_20]: pass argument 2
fncall .6                               ; [call: abi_encode_20]: call function
 move $r172 $zero                        ; [call: abi_encode_20]: copy returned unit value
 movi $r172 i0                           ; [call: abi_encode_20]: copy returned unit value
addi $r173 $$locbase i1360              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r173 $r170 i24                    ; copy memory
addi $r174 $$locbase i1800              ; get offset to local __ptr { u64, u64 }
addi $r175 $$locbase i1360              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r176 $$locbase i1704              ; get offset to local __ptr { u64, u64 }
mcpi $r176 $r174 i16                    ; copy memory
addi $r177 $$locbase i1144              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r177 $r175 i24                    ; copy memory
addi $r178 $$locbase i1704              ; get offset to local __ptr { u64, u64 }
lw $r179 $$locbase i213                 ; load word
addi $r180 $$locbase i1144              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r181 $$locbase i640               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r181 $r180 i24                    ; copy memory
addi $r182 $$locbase i360               ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r179                       ; [call: abi_encode_20]: pass argument 0
move $$arg1 $r181                       ; [call: abi_encode_20]: pass argument 1
move $$arg2 $r182                       ; [call: abi_encode_20]: pass argument 2
fncall .6                               ; [call: abi_encode_20]: call function
 move $r183 $zero                        ; [call: abi_encode_20]: copy returned unit value
 movi $r183 i0                           ; [call: abi_encode_20]: copy returned unit value
addi $r184 $$locbase i1216              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r184 $r182 i24                    ; copy memory
addi $r185 $$locbase i1704              ; get offset to local __ptr { u64, u64 }
addi $r186 $r185 i8                     ; get offset to aggregate element
lw $r187 $$locbase i214                 ; load word
addi $r188 $$locbase i1216              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r189 $$locbase i664               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r189 $r188 i24                    ; copy memory
addi $r190 $$locbase i384               ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r187                       ; [call: abi_encode_20]: pass argument 0
move $$arg1 $r189                       ; [call: abi_encode_20]: pass argument 1
move $$arg2 $r190                       ; [call: abi_encode_20]: pass argument 2
fncall .6                               ; [call: abi_encode_20]: call function
 move $r191 $zero                        ; [call: abi_encode_20]: copy returned unit value
 movi $r191 i0                           ; [call: abi_encode_20]: copy returned unit value
addi $r192 $$locbase i1288              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r192 $r190 i24                    ; copy memory
addi $r193 $$locbase i1288              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r194 $$locbase i824               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r194 $r193 i24                    ; copy memory
addi $r195 $$locbase i1384              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r195 $r194 i24                    ; copy memory
addi $r196 $$locbase i1384              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r197 $$locbase i896               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r197 $r196 i24                    ; copy memory
move $r144 $r197                        ; move parameter from branch to block argument
ji  .78
.78
move $r200 $r144                        ; move parameter from branch to block argument
addi $r201 $$locbase i920               ; get offset to local __ptr { { ptr, u64, u64 } }
 mcpi $r201 $r200 i24                    ; copy memory
 mcpi $r201 $r144 i24                    ; copy memory
move $r202 $r201                        ; move parameter from branch to block argument
ji  .79
.69
addi $r203 $$locbase i208               ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
addi $r204 $r203 i55                    ; get offset to aggregate element
addi $r205 $$locbase i1792              ; get offset to local __ptr bool
mcpi $r205 $r204 i1                     ; copy memory
addi $r206 $$locbase i1072              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r207 $$locbase i592               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r207 $r206 i24                    ; copy memory
addi $r208 $$locbase i312               ; get offset to local __ptr { { ptr, u64, u64 } }
movi $r209 i2                           ; initialize constant into register
 move $$arg0 $r209                       ; [call: abi_encode_20]: pass argument 0
 movi $$arg0 i2                          ; [call: abi_encode_20]: pass argument 0
move $$arg1 $r207                       ; [call: abi_encode_20]: pass argument 1
move $$arg2 $r208                       ; [call: abi_encode_20]: pass argument 2
fncall .6                               ; [call: abi_encode_20]: call function
 move $r210 $zero                        ; [call: abi_encode_20]: copy returned unit value
 movi $r210 i0                           ; [call: abi_encode_20]: copy returned unit value
addi $r211 $$locbase i1312              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r211 $r208 i24                    ; copy memory
addi $r212 $$locbase i1792              ; get offset to local __ptr bool
addi $r213 $$locbase i1312              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r214 $$locbase i1688              ; get offset to local __ptr bool
mcpi $r214 $r212 i1                     ; copy memory
addi $r215 $$locbase i1120              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r215 $r213 i24                    ; copy memory
addi $r216 $$locbase i520               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r217 $$locbase i1120              ; get offset to local __ptr { { ptr, u64, u64 } }
move $r218 $r217                        ; return value from ASM block with return register buffer
addi $r219 $$locbase i48                ; get offset to local __ptr { ptr, u64, u64 }
 mcpi $r219 $r218 i24                    ; copy memory
 mcpi $r219 $r217 i24                    ; copy memory
addi $r220 $$locbase i136               ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r220 $r219 i24                    ; copy memory
lw $r221 $$locbase i17                  ; load word
addi $r222 $r220 i8                     ; get offset to aggregate element
lw $r223 $$locbase i18                  ; load word
addi $r224 $r220 i16                    ; get offset to aggregate element
lw $r225 $$locbase i19                  ; load word
addi $r226 $$locbase i1688              ; get offset to local __ptr bool
lb $r227 $r226 i0                       ; load byte
 add $r228 $r225 $one
 addi $r228 $r225 i1
gt $r229 $r228 $r223
move $r230 $r221                        ; move parameter from branch to block argument
move $r231 $r223                        ; move parameter from branch to block argument
jnzi $r229 .80
ji  .81
.80
movi $r232 i2                           ; initialize constant into register
 mul $r233 $r223 $r232
 add $r234 $r233 $one
 muli $r233 $r223 i2
 addi $r234 $r233 i1
aloc $r234
mcp $hp $r221 $r225
move $r235 $hp                          ; return value from ASM block with return register hp
 move $r230 $r235                        ; move parameter from branch to block argument
 move $r230 $hp                          ; move parameter from branch to block argument
move $r231 $r234                        ; move parameter from branch to block argument
ji  .81
.81
move $r239 $r230                        ; move parameter from branch to block argument
move $r241 $r231                        ; move parameter from branch to block argument
 add $r242 $r239 $r225
 add $r242 $r230 $r225
sb $r242 $r227 i0                       ; store byte
 add $r243 $r225 $one
 addi $r243 $r225 i1
addi $r244 $$locbase i184               ; get offset to local __ptr { ptr, u64, u64 }
sw $$locbase $r239 i23                  ; store word
addi $r245 $r244 i8                     ; get offset to aggregate element
sw $$locbase $r241 i24                  ; store word
addi $r246 $r244 i16                    ; get offset to aggregate element
sw $$locbase $r243 i25                  ; store word
move $r247 $r244                        ; return value from ASM block with return register buffer
addi $r248 $$locbase i72                ; get offset to local __ptr { ptr, u64, u64 }
 mcpi $r248 $r247 i24                    ; copy memory
 mcpi $r248 $r244 i24                    ; copy memory
mcpi $r216 $r248 i24                    ; copy memory
addi $r249 $$locbase i800               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r249 $r216 i24                    ; copy memory
addi $r250 $$locbase i1336              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r250 $r249 i24                    ; copy memory
addi $r251 $$locbase i1336              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r252 $$locbase i920               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r252 $r251 i24                    ; copy memory
move $r202 $r252                        ; move parameter from branch to block argument
ji  .79
.79
move $r255 $r202                        ; move parameter from branch to block argument
addi $r256 $$locbase i944               ; get offset to local __ptr { { ptr, u64, u64 } }
 mcpi $r256 $r255 i24                    ; copy memory
 mcpi $r256 $r202 i24                    ; copy memory
move $r257 $r256                        ; move parameter from branch to block argument
ji  .82
.67
addi $r258 $$locbase i208               ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
addi $r259 $r258 i55                    ; get offset to aggregate element
addi $r260 $$locbase i1784              ; get offset to local __ptr u8
mcpi $r260 $r259 i1                     ; copy memory
addi $r261 $$locbase i1072              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r262 $$locbase i568               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r262 $r261 i24                    ; copy memory
addi $r263 $$locbase i288               ; get offset to local __ptr { { ptr, u64, u64 } }
 move $$arg0 $one                        ; [call: abi_encode_20]: pass argument 0
 movi $$arg0 i1                          ; [call: abi_encode_20]: pass argument 0
move $$arg1 $r262                       ; [call: abi_encode_20]: pass argument 1
move $$arg2 $r263                       ; [call: abi_encode_20]: pass argument 2
fncall .6                               ; [call: abi_encode_20]: call function
 move $r264 $zero                        ; [call: abi_encode_20]: copy returned unit value
 movi $r264 i0                           ; [call: abi_encode_20]: copy returned unit value
addi $r265 $$locbase i1192              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r265 $r263 i24                    ; copy memory
addi $r266 $$locbase i1784              ; get offset to local __ptr u8
addi $r267 $$locbase i1192              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r268 $$locbase i1672              ; get offset to local __ptr u8
mcpi $r268 $r266 i1                     ; copy memory
addi $r269 $$locbase i1096              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r269 $r267 i24                    ; copy memory
addi $r270 $$locbase i496               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r271 $$locbase i1096              ; get offset to local __ptr { { ptr, u64, u64 } }
move $r272 $r271                        ; return value from ASM block with return register buffer
 mcpi $$locbase $r272 i24                ; copy memory
 mcpi $$locbase $r271 i24                ; copy memory
addi $r273 $$locbase i112               ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r273 $$locbase i24                ; copy memory
lw $r274 $$locbase i14                  ; load word
addi $r275 $r273 i8                     ; get offset to aggregate element
lw $r276 $$locbase i15                  ; load word
addi $r277 $r273 i16                    ; get offset to aggregate element
lw $r278 $$locbase i16                  ; load word
addi $r279 $$locbase i1672              ; get offset to local __ptr u8
lb $r280 $r279 i0                       ; load byte
 add $r281 $r278 $one
 addi $r281 $r278 i1
gt $r282 $r281 $r276
move $r283 $r274                        ; move parameter from branch to block argument
move $r284 $r276                        ; move parameter from branch to block argument
jnzi $r282 .83
ji  .84
.83
movi $r285 i2                           ; initialize constant into register
 mul $r286 $r276 $r285
 add $r287 $r286 $one
 muli $r286 $r276 i2
 addi $r287 $r286 i1
aloc $r287
mcp $hp $r274 $r278
move $r288 $hp                          ; return value from ASM block with return register hp
 move $r283 $r288                        ; move parameter from branch to block argument
 move $r283 $hp                          ; move parameter from branch to block argument
move $r284 $r287                        ; move parameter from branch to block argument
ji  .84
.84
move $r292 $r283                        ; move parameter from branch to block argument
move $r294 $r284                        ; move parameter from branch to block argument
 add $r295 $r292 $r278
 add $r295 $r283 $r278
sb $r295 $r280 i0                       ; store byte
 add $r296 $r278 $one
 addi $r296 $r278 i1
addi $r297 $$locbase i160               ; get offset to local __ptr { ptr, u64, u64 }
sw $$locbase $r292 i20                  ; store word
addi $r298 $r297 i8                     ; get offset to aggregate element
sw $$locbase $r294 i21                  ; store word
addi $r299 $r297 i16                    ; get offset to aggregate element
sw $$locbase $r296 i22                  ; store word
move $r300 $r297                        ; return value from ASM block with return register buffer
addi $r301 $$locbase i24                ; get offset to local __ptr { ptr, u64, u64 }
 mcpi $r301 $r300 i24                    ; copy memory
 mcpi $r301 $r297 i24                    ; copy memory
mcpi $r270 $r301 i24                    ; copy memory
addi $r302 $$locbase i776               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r302 $r270 i24                    ; copy memory
addi $r303 $$locbase i1264              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r303 $r302 i24                    ; copy memory
addi $r304 $$locbase i1264              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r305 $$locbase i944               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r305 $r304 i24                    ; copy memory
move $r257 $r305                        ; move parameter from branch to block argument
ji  .82
.82
move $r308 $r257                        ; move parameter from branch to block argument
addi $r309 $$locbase i968               ; get offset to local __ptr { { ptr, u64, u64 } }
 mcpi $r309 $r308 i24                    ; copy memory
 mcpi $r309 $r257 i24                    ; copy memory
move $r310 $r309                        ; move parameter from branch to block argument
ji  .85
.65
addi $r311 $$locbase i1072              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r312 $$locbase i544               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r312 $r311 i24                    ; copy memory
addi $r313 $$locbase i264               ; get offset to local __ptr { { ptr, u64, u64 } }
 move $$arg0 $zero                       ; [call: abi_encode_20]: pass argument 0
 movi $$arg0 i0                          ; [call: abi_encode_20]: pass argument 0
move $$arg1 $r312                       ; [call: abi_encode_20]: pass argument 1
move $$arg2 $r313                       ; [call: abi_encode_20]: pass argument 2
fncall .6                               ; [call: abi_encode_20]: call function
 move $r314 $zero                        ; [call: abi_encode_20]: copy returned unit value
 movi $r314 i0                           ; [call: abi_encode_20]: copy returned unit value
addi $r315 $$locbase i968               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r315 $r313 i24                    ; copy memory
move $r310 $r315                        ; move parameter from branch to block argument
ji  .85
.85
move $r318 $r310                        ; move parameter from branch to block argument
addi $r319 $$locbase i1456              ; get offset to local __ptr { { ptr, u64, u64 } }
 mcpi $r319 $r318 i24                    ; copy memory
 mcpi $r319 $r310 i24                    ; copy memory
addi $r320 $$locbase i1456              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r321 $$locbase i992               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r321 $r320 i24                    ; copy memory
addi $r322 $$locbase i1048              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r322 $r321 i24                    ; copy memory
addi $r323 $$locbase i1048              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r324 $$locbase i752               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r324 $r323 i24                    ; copy memory
addi $r325 $$locbase i480               ; get offset to local __ptr slice
move $$arg0 $r324                       ; [call: as_raw_slice_29]: pass argument 0
move $$arg1 $r325                       ; [call: as_raw_slice_29]: pass argument 1
fncall .12                              ; [call: as_raw_slice_29]: call function
 move $r326 $zero                        ; [call: as_raw_slice_29]: copy returned unit value
 movi $r326 i0                           ; [call: as_raw_slice_29]: copy returned unit value
addi $r327 $$locbase i1016              ; get offset to local __ptr slice
mcpi $r327 $r325 i16                    ; copy memory
move $r328 $r327                        ; move parameter from branch to block argument
ji  .86
.63
addi $r329 $$locbase i1776              ; get offset to local __ptr u64
movi $r330 i56                          ; initialize constant into register
sw $$locbase $r330 i222                 ; store word
addi $r331 $$locbase i1032              ; get offset to local __ptr { __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }, u64 }
addi $r332 $$locbase i1488              ; get offset to local __ptr __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
addi $r333 $$locbase i1776              ; get offset to local __ptr u64
mcpi $r331 $r332 i8                     ; copy memory
addi $r334 $r331 i8                     ; get offset to aggregate element
mcpi $r334 $r333 i8                     ; copy memory
addi $r335 $$locbase i96                ; get offset to local __ptr { __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }, u64 }
mcpi $r335 $r331 i16                    ; copy memory
addi $r336 $$locbase i1016              ; get offset to local __ptr slice
mcpi $r336 $r335 i16                    ; copy memory
move $r328 $r336                        ; move parameter from branch to block argument
ji  .86
.86
move $r339 $r328                        ; move parameter from branch to block argument
 mcpi $r13 $r339 i16                     ; copy memory
 mcpi $r13 $r328 i16                     ; copy memory
ji  .5
.5
cfsi i1864                              ; [fn end: encode_allow_alias_1] free: locals 1864 byte(s), call args 0 slot(s)
move $$reta $r14                        ; [fn end: encode_allow_alias_1] restore return address
popa .4                                 ; [fn end: encode_allow_alias_1] restore all used registers
jal $zero $$reta i0                     ; [fn end: encode_allow_alias_1] return from call
DIFF------------------------------
.program:
.6                                      ; --- start of function: abi_encode_20 ---
pusha .6                                ; [fn init: abi_encode_20]: push all used registers to stack
move $$locbase $sp                      ; [fn init: abi_encode_20]: set locals base register
cfei i152                               ; [fn init: abi_encode_20]: allocate: locals 152 byte(s), call args 0 slot(s)
.87
addi $r341 $$locbase i144               ; get offset to local __ptr u64
sw $$locbase $$arg0 i18                 ; store word
addi $r342 $$locbase i120               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r342 $$arg1 i24                   ; copy memory
addi $r343 $$locbase i96                ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r344 $$locbase i120               ; get offset to local __ptr { { ptr, u64, u64 } }
move $r345 $r344                        ; return value from ASM block with return register buffer
 mcpi $$locbase $r345 i24                ; copy memory
 mcpi $$locbase $r344 i24                ; copy memory
addi $r346 $$locbase i48                ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r346 $$locbase i24                ; copy memory
lw $r347 $$locbase i6                   ; load word
addi $r348 $r346 i8                     ; get offset to aggregate element
lw $r349 $$locbase i7                   ; load word
addi $r350 $r346 i16                    ; get offset to aggregate element
lw $r351 $$locbase i8                   ; load word
addi $r352 $$locbase i144               ; get offset to local __ptr u64
lw $r353 $$locbase i18                  ; load word
movi $r354 i8                           ; initialize constant into register
 add $r355 $r351 $r354
 addi $r355 $r351 i8
gt $r356 $r355 $r349
move $r357 $r347                        ; move parameter from branch to block argument
move $r358 $r349                        ; move parameter from branch to block argument
jnzi $r356 .88
ji  .89
.88
movi $r359 i2                           ; initialize constant into register
 mul $r360 $r349 $r359
 muli $r360 $r349 i2
movi $r361 i8                           ; initialize constant into register
 add $r362 $r360 $r361
 addi $r362 $r360 i8
aloc $r362
mcp $hp $r347 $r351
move $r363 $hp                          ; return value from ASM block with return register hp
 move $r357 $r363                        ; move parameter from branch to block argument
 move $r357 $hp                          ; move parameter from branch to block argument
move $r358 $r362                        ; move parameter from branch to block argument
ji  .89
.89
move $r367 $r357                        ; move parameter from branch to block argument
move $r369 $r358                        ; move parameter from branch to block argument
 add $r370 $r367 $r351
 add $r370 $r357 $r351
sw $r370 $r353 i0                       ; store word
movi $r371 i8                           ; initialize constant into register
 add $r372 $r351 $r371
 addi $r372 $r351 i8
addi $r373 $$locbase i72                ; get offset to local __ptr { ptr, u64, u64 }
sw $$locbase $r367 i9                   ; store word
addi $r374 $r373 i8                     ; get offset to aggregate element
sw $$locbase $r369 i10                  ; store word
addi $r375 $r373 i16                    ; get offset to aggregate element
sw $$locbase $r372 i11                  ; store word
move $r376 $r373                        ; return value from ASM block with return register buffer
addi $r377 $$locbase i24                ; get offset to local __ptr { ptr, u64, u64 }
 mcpi $r377 $r376 i24                    ; copy memory
 mcpi $r377 $r373 i24                    ; copy memory
mcpi $r343 $r377 i24                    ; copy memory
mcpi $$arg2 $r343 i24                   ; copy memory
ji  .7
.7
cfsi i152                               ; [fn end: abi_encode_20] free: locals 152 byte(s), call args 0 slot(s)
popa .6                                 ; [fn end: abi_encode_20] restore all used registers
jal $zero $$reta i0                     ; [fn end: abi_encode_20] return from call
DIFF------------------------------
.program:
.8                                      ; --- start of function: abi_encode_26 ---
pusha .8                                ; [fn init: abi_encode_26]: push all used registers to stack
move $$locbase $sp                      ; [fn init: abi_encode_26]: set locals base register
cfei i224                               ; [fn init: abi_encode_26]: allocate: locals 224 byte(s), call args 0 slot(s)
.90
addi $r379 $$locbase i208               ; get offset to local __ptr slice
mcpi $r379 $$arg0 i16                   ; copy memory
addi $r380 $$locbase i184               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r380 $$arg1 i24                   ; copy memory
addi $r381 $$locbase i160               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r382 $$locbase i184               ; get offset to local __ptr { { ptr, u64, u64 } }
move $r383 $r382                        ; return value from ASM block with return register buffer
 mcpi $$locbase $r383 i24                ; copy memory
 mcpi $$locbase $r382 i24                ; copy memory
addi $r384 $$locbase i80                ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r384 $$locbase i24                ; copy memory
lw $r385 $$locbase i10                  ; load word
addi $r386 $r384 i8                     ; get offset to aggregate element
lw $r387 $$locbase i11                  ; load word
addi $r388 $r384 i16                    ; get offset to aggregate element
lw $r389 $$locbase i12                  ; load word
addi $r390 $$locbase i208               ; get offset to local __ptr slice
addi $r391 $$locbase i40                ; get offset to local __ptr slice
mcpi $r391 $r390 i16                    ; copy memory
move $r392 $r390                        ; return value from ASM block with return register item
addi $r393 $$locbase i24                ; get offset to local __ptr { u64, u64 }
 mcpi $r393 $r392 i16                    ; copy memory
 mcpi $r393 $r390 i16                    ; copy memory
addi $r394 $$locbase i104               ; get offset to local __ptr { u64, u64 }
mcpi $r394 $r393 i16                    ; copy memory
addi $r395 $r394 i8                     ; get offset to aggregate element
lw $r396 $$locbase i14                  ; load word
movi $r397 i8                           ; initialize constant into register
 add $r398 $r396 $r397
 addi $r398 $r396 i8
add $r399 $r389 $r398
gt $r400 $r399 $r387
move $r401 $r385                        ; move parameter from branch to block argument
move $r402 $r387                        ; move parameter from branch to block argument
jnzi $r400 .91
ji  .92
.91
movi $r403 i2                           ; initialize constant into register
 mul $r404 $r387 $r403
 muli $r404 $r387 i2
add $r405 $r404 $r398
aloc $r405
mcp $hp $r385 $r389
move $r406 $hp                          ; return value from ASM block with return register hp
 move $r401 $r406                        ; move parameter from branch to block argument
 move $r401 $hp                          ; move parameter from branch to block argument
move $r402 $r405                        ; move parameter from branch to block argument
ji  .92
.92
move $r410 $r401                        ; move parameter from branch to block argument
move $r412 $r402                        ; move parameter from branch to block argument
addi $r413 $$locbase i120               ; get offset to local __ptr slice
mcpi $r413 $r391 i16                    ; copy memory
add $r414 $r410 $r389
lw $r416 $$locbase i16
sw $r414 $r416 i0
addi $r414 $r414 i8
lw $r415 $$locbase i15
mcp $r414 $r415 $r416
addi $r417 $r389 i8
add $r417 $r417 $r416
move $r418 $r417                        ; return value from ASM block with return register new_len
addi $r419 $$locbase i136               ; get offset to local __ptr { ptr, u64, u64 }
sw $$locbase $r410 i17                  ; store word
addi $r420 $r419 i8                     ; get offset to aggregate element
sw $$locbase $r412 i18                  ; store word
addi $r421 $r419 i16                    ; get offset to aggregate element
sw $$locbase $r418 i19                  ; store word
move $r422 $r419                        ; return value from ASM block with return register buffer
addi $r423 $$locbase i56                ; get offset to local __ptr { ptr, u64, u64 }
 mcpi $r423 $r422 i24                    ; copy memory
 mcpi $r423 $r419 i24                    ; copy memory
mcpi $r381 $r423 i24                    ; copy memory
mcpi $$arg2 $r381 i24                   ; copy memory
ji  .9
.9
cfsi i224                               ; [fn end: abi_encode_26] free: locals 224 byte(s), call args 0 slot(s)
popa .8                                 ; [fn end: abi_encode_26] restore all used registers
jal $zero $$reta i0                     ; [fn end: abi_encode_26] return from call
DIFF------------------------------
.program:
.10                                     ; --- start of function: new_28 ---
pusha .10                               ; [fn init: new_28]: push all used registers to stack
move $$locbase $sp                      ; [fn init: new_28]: set locals base register
cfei i72                                ; [fn init: new_28]: allocate: locals 72 byte(s), call args 0 slot(s)
.93
addi $r425 $$locbase i48                ; get offset to local __ptr { { ptr, u64, u64 } }
movi $r426 i1024                        ; initialize constant into register
aloc $r426
move $r427 $hp                          ; return value from ASM block with return register hp
addi $r428 $$locbase i24                ; get offset to local __ptr { ptr, u64, u64 }
 sw $$locbase $r427 i3                   ; store word
 sw $$locbase $hp i3                     ; store word
addi $r429 $r428 i8                     ; get offset to aggregate element
movi $r430 i1024                        ; initialize constant into register
sw $$locbase $r430 i4                   ; store word
addi $r431 $r428 i16                    ; get offset to aggregate element
sw $$locbase $zero i5                   ; store word
move $r432 $r428                        ; return value from ASM block with return register buffer
 mcpi $$locbase $r432 i24                ; copy memory
 mcpi $$locbase $r428 i24                ; copy memory
mcpi $r425 $$locbase i24                ; copy memory
mcpi $$arg0 $r425 i24                   ; copy memory
ji  .11
.11
cfsi i72                                ; [fn end: new_28] free: locals 72 byte(s), call args 0 slot(s)
popa .10                                ; [fn end: new_28] restore all used registers
jal $zero $$reta i0                     ; [fn end: new_28] return from call
DIFF------------------------------
.program:
.12                                     ; --- start of function: as_raw_slice_29 ---
pusha .12                               ; [fn init: as_raw_slice_29]: push all used registers to stack
move $$locbase $sp                      ; [fn init: as_raw_slice_29]: set locals base register
cfei i104                               ; [fn init: as_raw_slice_29]: allocate: locals 104 byte(s), call args 0 slot(s)
.94
addi $r434 $$locbase i80                ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r434 $$arg0 i24                   ; copy memory
addi $r435 $$locbase i80                ; get offset to local __ptr { { ptr, u64, u64 } }
move $r436 $r435                        ; return value from ASM block with return register buffer
 mcpi $$locbase $r436 i24                ; copy memory
 mcpi $$locbase $r435 i24                ; copy memory
addi $r437 $$locbase i40                ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r437 $$locbase i24                ; copy memory
addi $r438 $r437 i16                    ; get offset to aggregate element
addi $r439 $$locbase i64                ; get offset to local __ptr { ptr, u64 }
mcpi $r439 $r437 i8                     ; copy memory
addi $r440 $r439 i8                     ; get offset to aggregate element
mcpi $r440 $r438 i8                     ; copy memory
move $r441 $r439                        ; return value from ASM block with return register s
addi $r442 $$locbase i24                ; get offset to local __ptr slice
 mcpi $r442 $r441 i16                    ; copy memory
 mcpi $r442 $r439 i16                    ; copy memory
mcpi $$arg1 $r442 i16                   ; copy memory
ji  .13
.13
cfsi i104                               ; [fn end: as_raw_slice_29] free: locals 104 byte(s), call args 0 slot(s)
popa .12                                ; [fn end: as_raw_slice_29] restore all used registers
jal $zero $$reta i0                     ; [fn end: as_raw_slice_29] return from call
DIFF------------------------------
.program:
.18                                     ; --- start of function: call_nested_panic_inlined_30 ---
pusha .18                               ; [fn init: call_nested_panic_inlined_30]: push all used registers to stack
move $$locbase $sp                      ; [fn init: call_nested_panic_inlined_30]: set locals base register
cfei i288                               ; [fn init: call_nested_panic_inlined_30]: allocate: locals 288 byte(s), call args 0 slot(s)
move $r448 $$arg0                       ; [fn init: call_nested_panic_inlined_30]: copy argument 0 (__backtrace)
move $r449 $$reta                       ; [fn init: call_nested_panic_inlined_30]: save return address
.97
movi $r450 i4                           ; initialize constant into register
sw $$locbase $r450 i0                   ; store word
addi $r451 $$locbase i152               ; get offset to local __ptr [slice; 3]
addr $r452 data_NonConfigurable_5       ; get __const_global's address in data section
addi $r453 $$locbase i56                ; get offset to local __ptr { ptr, u64 }
sw $$locbase $r452 i7                   ; store word
addi $r454 $r453 i8                     ; get offset to aggregate element
movi $r455 i7                           ; initialize constant into register
sw $$locbase $r455 i8                   ; store word
addi $r456 $$locbase i72                ; get offset to local __ptr slice
mcpi $r456 $r453 i16                    ; copy memory
addr $r457 data_NonConfigurable_6       ; get __const_global0's address in data section
addi $r458 $$locbase i88                ; get offset to local __ptr { ptr, u64 }
sw $$locbase $r457 i11                  ; store word
addi $r459 $r458 i8                     ; get offset to aggregate element
movi $r460 i7                           ; initialize constant into register
sw $$locbase $r460 i12                  ; store word
addi $r461 $$locbase i104               ; get offset to local __ptr slice
mcpi $r461 $r458 i16                    ; copy memory
addr $r462 data_NonConfigurable_7       ; get __const_global1's address in data section
addi $r463 $$locbase i120               ; get offset to local __ptr { ptr, u64 }
sw $$locbase $r462 i15                  ; store word
addi $r464 $r463 i8                     ; get offset to aggregate element
movi $r465 i22                          ; initialize constant into register
sw $$locbase $r465 i16                  ; store word
addi $r466 $$locbase i136               ; get offset to local __ptr slice
mcpi $r466 $r463 i16                    ; copy memory
movi $r467 i16                          ; get array element size
 mul $r468 $zero $r467                   ; get offset to array element
 add $r468 $r451 $r468                   ; add array element offset to array base
 mcpi $r468 $r456 i16                    ; copy memory
 movi $r468 i0                           ; get offset to array element
 move $r468 $r451                        ; add array element offset to array base
 mcpi $r451 $r456 i16                    ; copy memory
movi $r469 i16                          ; get array element size
 mul $r470 $one $r469                    ; get offset to array element
 add $r470 $r451 $r470                   ; add array element offset to array base
 movi $r470 i16                          ; get offset to array element
 addi $r470 $r451 i16                    ; add array element offset to array base
mcpi $r470 $r461 i16                    ; copy memory
movi $r471 i16                          ; get array element size
movi $r472 i2                           ; initialize constant into register
 mul $r473 $r472 $r471                   ; get offset to array element
 add $r473 $r451 $r473                   ; add array element offset to array base
 movi $r473 i32                          ; get offset to array element
 addi $r473 $r451 i32                    ; add array element offset to array base
mcpi $r473 $r466 i16                    ; copy memory
addi $r474 $$locbase i8                 ; get offset to aggregate element
mcpi $r474 $r451 i48                    ; copy memory
movi $r475 i11                          ; initialize constant into register
 sll $r476 $r448 $r475
 or $r477 $r476 $one
 slli $r476 $r448 i11
 ori $r477 $r476 i1
addi $r478 $$locbase i232               ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
mcpi $r478 $$locbase i56                ; copy memory
addi $r479 $$locbase i232               ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
addi $r480 $$locbase i216               ; get offset to local __ptr slice
move $$arg0 $r479                       ; [call: encode_allow_alias_1]: pass argument 0
move $$arg1 $r480                       ; [call: encode_allow_alias_1]: pass argument 1
fncall .4                               ; [call: encode_allow_alias_1]: call function
 move $r481 $zero                        ; [call: encode_allow_alias_1]: copy returned unit value
 movi $r481 i0                           ; [call: encode_allow_alias_1]: copy returned unit value
addi $r482 $$locbase i200               ; get offset to local __ptr slice
mcpi $r482 $r480 i16                    ; copy memory
load $r483 data_NonConfigurable_0       ; load constant from data section
lw $r484 $$locbase i25                  ; load slice pointer for logging data
lw $r485 $$locbase i26                  ; load slice size for logging data
logd $zero $r483 $r484 $r485            ; log slice
load $r486 data_NonConfigurable_8       ; load constant from data section
and $r487 $r477 $r486
load $r488 data_NonConfigurable_9       ; load constant from data section
or $r489 $r488 $r487
rvrt $r489
.19
cfsi i288                               ; [fn end: call_nested_panic_inlined_30] free: locals 288 byte(s), call args 0 slot(s)
move $$reta $r449                       ; [fn end: call_nested_panic_inlined_30] restore return address
popa .18                                ; [fn end: call_nested_panic_inlined_30] restore all used registers
jal $zero $$reta i0                     ; [fn end: call_nested_panic_inlined_30] return from call
DIFF------------------------------
.program:
.24                                     ; --- start of function: call_nested_panic_non_inlined_32 ---
pusha .24                               ; [fn init: call_nested_panic_non_inlined_32]: push all used registers to stack
move $$locbase $sp                      ; [fn init: call_nested_panic_non_inlined_32]: set locals base register
cfei i200                               ; [fn init: call_nested_panic_non_inlined_32]: allocate: locals 200 byte(s), call args 0 slot(s)
move $r496 $$arg0                       ; [fn init: call_nested_panic_non_inlined_32]: copy argument 0 (__backtrace)
move $r497 $$reta                       ; [fn init: call_nested_panic_non_inlined_32]: save return address
.100
movi $r498 i4                           ; initialize constant into register
sw $$locbase $r498 i0                   ; store word
addi $r499 $$locbase i152               ; get offset to local __ptr [slice; 3]
addr $r500 data_NonConfigurable_10      ; get __const_global2's address in data section
addi $r501 $$locbase i56                ; get offset to local __ptr { ptr, u64 }
sw $$locbase $r500 i7                   ; store word
addi $r502 $r501 i8                     ; get offset to aggregate element
movi $r503 i4                           ; initialize constant into register
sw $$locbase $r503 i8                   ; store word
addi $r504 $$locbase i72                ; get offset to local __ptr slice
mcpi $r504 $r501 i16                    ; copy memory
addr $r505 data_NonConfigurable_11      ; get __const_global3's address in data section
addi $r506 $$locbase i88                ; get offset to local __ptr { ptr, u64 }
sw $$locbase $r505 i11                  ; store word
addi $r507 $r506 i8                     ; get offset to aggregate element
movi $r508 i6                           ; initialize constant into register
sw $$locbase $r508 i12                  ; store word
addi $r509 $$locbase i104               ; get offset to local __ptr slice
mcpi $r509 $r506 i16                    ; copy memory
addr $r510 data_NonConfigurable_12      ; get __const_global4's address in data section
addi $r511 $$locbase i120               ; get offset to local __ptr { ptr, u64 }
sw $$locbase $r510 i15                  ; store word
addi $r512 $r511 i8                     ; get offset to aggregate element
movi $r513 i17                          ; initialize constant into register
sw $$locbase $r513 i16                  ; store word
addi $r514 $$locbase i136               ; get offset to local __ptr slice
mcpi $r514 $r511 i16                    ; copy memory
movi $r515 i16                          ; get array element size
 mul $r516 $zero $r515                   ; get offset to array element
 add $r516 $r499 $r516                   ; add array element offset to array base
 mcpi $r516 $r504 i16                    ; copy memory
 movi $r516 i0                           ; get offset to array element
 move $r516 $r499                        ; add array element offset to array base
 mcpi $r499 $r504 i16                    ; copy memory
movi $r517 i16                          ; get array element size
 mul $r518 $one $r517                    ; get offset to array element
 add $r518 $r499 $r518                   ; add array element offset to array base
 movi $r518 i16                          ; get offset to array element
 addi $r518 $r499 i16                    ; add array element offset to array base
mcpi $r518 $r509 i16                    ; copy memory
movi $r519 i16                          ; get array element size
movi $r520 i2                           ; initialize constant into register
 mul $r521 $r520 $r519                   ; get offset to array element
 add $r521 $r499 $r521                   ; add array element offset to array base
 movi $r521 i32                          ; get offset to array element
 addi $r521 $r499 i32                    ; add array element offset to array base
mcpi $r521 $r514 i16                    ; copy memory
addi $r522 $$locbase i8                 ; get offset to aggregate element
mcpi $r522 $r499 i48                    ; copy memory
movi $r523 i11                          ; initialize constant into register
 sll $r524 $r496 $r523
 slli $r524 $r496 i11
movi $r525 i4                           ; initialize constant into register
 or $r526 $r524 $r525
 move $$arg0 $one                        ; [call: nested_panic_non_inlined_33]: pass argument 0
 ori $r526 $r524 i4
 movi $$arg0 i1                          ; [call: nested_panic_non_inlined_33]: pass argument 0
move $$arg1 $$locbase                   ; [call: nested_panic_non_inlined_33]: pass argument 1
move $$arg2 $r526                       ; [call: nested_panic_non_inlined_33]: pass argument 2
fncall .26                              ; [call: nested_panic_non_inlined_33]: call function
 move $r527 $zero                        ; [call: nested_panic_non_inlined_33]: copy returned unit value
 movi $r527 i0                           ; [call: nested_panic_non_inlined_33]: copy returned unit value
ji  .25
.25
cfsi i200                               ; [fn end: call_nested_panic_non_inlined_32] free: locals 200 byte(s), call args 0 slot(s)
move $$reta $r497                       ; [fn end: call_nested_panic_non_inlined_32] restore return address
popa .24                                ; [fn end: call_nested_panic_non_inlined_32] restore all used registers
jal $zero $$reta i0                     ; [fn end: call_nested_panic_non_inlined_32] return from call
DIFF------------------------------
.program:
.26                                     ; --- start of function: nested_panic_non_inlined_33 ---
pusha .26                               ; [fn init: nested_panic_non_inlined_33]: push all used registers to stack
move $$locbase $sp                      ; [fn init: nested_panic_non_inlined_33]: set locals base register
cfei i96                                ; [fn init: nested_panic_non_inlined_33]: allocate: locals 96 byte(s), call args 0 slot(s)
move $r528 $$arg0                       ; [fn init: nested_panic_non_inlined_33]: copy argument 0 (to_panic)
move $r529 $$arg1                       ; [fn init: nested_panic_non_inlined_33]: copy argument 1 (err)
move $r530 $$arg2                       ; [fn init: nested_panic_non_inlined_33]: copy argument 2 (__backtrace)
move $r531 $$reta                       ; [fn init: nested_panic_non_inlined_33]: save return address
.101
addi $r532 $$locbase i88                ; get offset to local __ptr bool
 sb $r532 $r528 i0                       ; store byte
 sb $r532 $$arg0 i0                      ; store byte
addi $r533 $$locbase i32                ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
mcpi $r533 $r529 i56                    ; copy memory
addi $r534 $$locbase i88                ; get offset to local __ptr bool
lb $r535 $r534 i0                       ; load byte
jnzi $r535 .102
ji  .103
.103
ji  .27
.102
addi $r536 $$locbase i32                ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
addi $r537 $$locbase i16                ; get offset to local __ptr slice
move $$arg0 $r536                       ; [call: encode_allow_alias_1]: pass argument 0
move $$arg1 $r537                       ; [call: encode_allow_alias_1]: pass argument 1
fncall .4                               ; [call: encode_allow_alias_1]: call function
 move $r538 $zero                        ; [call: encode_allow_alias_1]: copy returned unit value
 movi $r538 i0                           ; [call: encode_allow_alias_1]: copy returned unit value
mcpi $$locbase $r537 i16                ; copy memory
load $r539 data_NonConfigurable_0       ; load constant from data section
lw $r540 $$locbase i0                   ; load slice pointer for logging data
lw $r541 $$locbase i1                   ; load slice size for logging data
logd $zero $r539 $r540 $r541            ; log slice
load $r542 data_NonConfigurable_8       ; load constant from data section
and $r543 $r530 $r542
load $r544 data_NonConfigurable_13      ; load constant from data section
or $r545 $r544 $r543
rvrt $r545
.27
cfsi i96                                ; [fn end: nested_panic_non_inlined_33] free: locals 96 byte(s), call args 0 slot(s)
move $$reta $r531                       ; [fn end: nested_panic_non_inlined_33] restore return address
popa .26                                ; [fn end: nested_panic_non_inlined_33] restore all used registers
jal $zero $$reta i0                     ; [fn end: nested_panic_non_inlined_33] return from call
DIFF------------------------------
.program:
.32                                     ; --- start of function: generic_panic_34 ---
pusha .32                               ; [fn init: generic_panic_34]: push all used registers to stack
move $$locbase $sp                      ; [fn init: generic_panic_34]: set locals base register
cfei i184                               ; [fn init: generic_panic_34]: allocate: locals 184 byte(s), call args 0 slot(s)
move $r552 $$arg0                       ; [fn init: generic_panic_34]: copy argument 0 (t)
move $r553 $$arg1                       ; [fn init: generic_panic_34]: copy argument 1 (__backtrace)
move $r554 $$reta                       ; [fn init: generic_panic_34]: save return address
.106
addi $r555 $$locbase i184               ; get offset to local __ptr ()
addi $r556 $$locbase i184               ; get offset to local __ptr ()
addi $r557 $$locbase i168               ; get offset to local __ptr __ptr ()
sw $$locbase $r556 i21                  ; store word
 jnzi $one .107
 ji  .107
ji  .108
.108
addi $r558 $$locbase i32                ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r558                       ; [call: new_28]: pass argument 0
fncall .10                              ; [call: new_28]: call function
 move $r559 $zero                        ; [call: new_28]: copy returned unit value
 movi $r559 i0                           ; [call: new_28]: copy returned unit value
addi $r560 $$locbase i144               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r560 $r558 i24                    ; copy memory
addi $r561 $$locbase i144               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r562 $$locbase i72                ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r562 $r561 i24                    ; copy memory
addi $r563 $$locbase i56                ; get offset to local __ptr slice
move $$arg0 $r562                       ; [call: as_raw_slice_29]: pass argument 0
move $$arg1 $r563                       ; [call: as_raw_slice_29]: pass argument 1
fncall .12                              ; [call: as_raw_slice_29]: call function
 move $r564 $zero                        ; [call: as_raw_slice_29]: copy returned unit value
 movi $r564 i0                           ; [call: as_raw_slice_29]: copy returned unit value
addi $r565 $$locbase i96                ; get offset to local __ptr slice
mcpi $r565 $r563 i16                    ; copy memory
move $r566 $r565                        ; move parameter from branch to block argument
ji  .109
.107
addi $r567 $$locbase i176               ; get offset to local __ptr u64
sw $$locbase $zero i22                  ; store word
addi $r568 $$locbase i128               ; get offset to local __ptr { __ptr (), u64 }
addi $r569 $$locbase i168               ; get offset to local __ptr __ptr ()
addi $r570 $$locbase i176               ; get offset to local __ptr u64
mcpi $r568 $r569 i8                     ; copy memory
addi $r571 $r568 i8                     ; get offset to aggregate element
mcpi $r571 $r570 i8                     ; copy memory
mcpi $$locbase $r568 i16                ; copy memory
addi $r572 $$locbase i96                ; get offset to local __ptr slice
mcpi $r572 $$locbase i16                ; copy memory
move $r566 $r572                        ; move parameter from branch to block argument
ji  .109
.109
move $r575 $r566                        ; move parameter from branch to block argument
addi $r576 $$locbase i112               ; get offset to local __ptr slice
 mcpi $r576 $r575 i16                    ; copy memory
 mcpi $r576 $r566 i16                    ; copy memory
addi $r577 $$locbase i16                ; get offset to local __ptr slice
mcpi $r577 $r576 i16                    ; copy memory
load $r578 data_NonConfigurable_14      ; load constant from data section
lw $r579 $$locbase i2                   ; load slice pointer for logging data
lw $r580 $$locbase i3                   ; load slice size for logging data
logd $zero $r578 $r579 $r580            ; log slice
load $r581 data_NonConfigurable_8       ; load constant from data section
and $r582 $r553 $r581
load $r583 data_NonConfigurable_15      ; load constant from data section
or $r584 $r583 $r582
rvrt $r584
.33
cfsi i184                               ; [fn end: generic_panic_34] free: locals 184 byte(s), call args 0 slot(s)
move $$reta $r554                       ; [fn end: generic_panic_34] restore return address
popa .32                                ; [fn end: generic_panic_34] restore all used registers
jal $zero $$reta i0                     ; [fn end: generic_panic_34] return from call
DIFF------------------------------
.program:
.38                                     ; --- start of function: generic_panic_37 ---
pusha .38                               ; [fn init: generic_panic_37]: push all used registers to stack
move $$locbase $sp                      ; [fn init: generic_panic_37]: set locals base register
cfei i240                               ; [fn init: generic_panic_37]: allocate: locals 240 byte(s), call args 0 slot(s)
move $r596 $$arg0                       ; [fn init: generic_panic_37]: copy argument 0 (t)
move $r597 $$arg1                       ; [fn init: generic_panic_37]: copy argument 1 (__backtrace)
move $r598 $$reta                       ; [fn init: generic_panic_37]: save return address
.112
addi $r599 $$locbase i224               ; get offset to local __ptr slice
 mcpi $r599 $r596 i16                    ; copy memory
 mcpi $r599 $$arg0 i16                   ; copy memory
addi $r600 $$locbase i224               ; get offset to local __ptr slice
addi $r601 $$locbase i208               ; get offset to local __ptr __ptr slice
sw $$locbase $r600 i26                  ; store word
 jnzi $zero .113
 
ji  .114
.114
addi $r602 $$locbase i208               ; get offset to local __ptr __ptr slice
lw $r603 $$locbase i26                  ; load word
addi $r604 $$locbase i56                ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r604                       ; [call: new_28]: pass argument 0
fncall .10                              ; [call: new_28]: call function
 move $r605 $zero                        ; [call: new_28]: copy returned unit value
 movi $r605 i0                           ; [call: new_28]: copy returned unit value
addi $r606 $$locbase i96                ; get offset to local __ptr slice
mcpi $r606 $r603 i16                    ; copy memory
addi $r607 $$locbase i112               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r607 $r604 i24                    ; copy memory
addi $r608 $$locbase i32                ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r606                       ; [call: abi_encode_26]: pass argument 0
move $$arg1 $r607                       ; [call: abi_encode_26]: pass argument 1
move $$arg2 $r608                       ; [call: abi_encode_26]: pass argument 2
fncall .8                               ; [call: abi_encode_26]: call function
 move $r609 $zero                        ; [call: abi_encode_26]: copy returned unit value
 movi $r609 i0                           ; [call: abi_encode_26]: copy returned unit value
addi $r610 $$locbase i184               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r610 $r608 i24                    ; copy memory
addi $r611 $$locbase i184               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r612 $$locbase i80                ; get offset to local __ptr slice
move $$arg0 $r611                       ; [call: as_raw_slice_29]: pass argument 0
move $$arg1 $r612                       ; [call: as_raw_slice_29]: pass argument 1
fncall .12                              ; [call: as_raw_slice_29]: call function
 move $r613 $zero                        ; [call: as_raw_slice_29]: copy returned unit value
 movi $r613 i0                           ; [call: as_raw_slice_29]: copy returned unit value
addi $r614 $$locbase i136               ; get offset to local __ptr slice
mcpi $r614 $r612 i16                    ; copy memory
move $r615 $r614                        ; move parameter from branch to block argument
ji  .115
.113
addi $r616 $$locbase i216               ; get offset to local __ptr u64
movi $r617 i16                          ; initialize constant into register
sw $$locbase $r617 i27                  ; store word
addi $r618 $$locbase i168               ; get offset to local __ptr { __ptr slice, u64 }
addi $r619 $$locbase i208               ; get offset to local __ptr __ptr slice
addi $r620 $$locbase i216               ; get offset to local __ptr u64
mcpi $r618 $r619 i8                     ; copy memory
addi $r621 $r618 i8                     ; get offset to aggregate element
mcpi $r621 $r620 i8                     ; copy memory
mcpi $$locbase $r618 i16                ; copy memory
addi $r622 $$locbase i136               ; get offset to local __ptr slice
mcpi $r622 $$locbase i16                ; copy memory
move $r615 $r622                        ; move parameter from branch to block argument
ji  .115
.115
move $r625 $r615                        ; move parameter from branch to block argument
addi $r626 $$locbase i152               ; get offset to local __ptr slice
 mcpi $r626 $r625 i16                    ; copy memory
 mcpi $r626 $r615 i16                    ; copy memory
addi $r627 $$locbase i16                ; get offset to local __ptr slice
mcpi $r627 $r626 i16                    ; copy memory
load $r628 data_NonConfigurable_17      ; load constant from data section
lw $r629 $$locbase i2                   ; load slice pointer for logging data
lw $r630 $$locbase i3                   ; load slice size for logging data
logd $zero $r628 $r629 $r630            ; log slice
load $r631 data_NonConfigurable_8       ; load constant from data section
and $r632 $r597 $r631
load $r633 data_NonConfigurable_18      ; load constant from data section
or $r634 $r633 $r632
rvrt $r634
.39
cfsi i240                               ; [fn end: generic_panic_37] free: locals 240 byte(s), call args 0 slot(s)
move $$reta $r598                       ; [fn end: generic_panic_37] restore return address
popa .38                                ; [fn end: generic_panic_37] restore all used registers
jal $zero $$reta i0                     ; [fn end: generic_panic_37] return from call
    Finished debug [unoptimized + fuel] target(s) [3.768 KB] in ???
     Running 11 tests, filtered 0 tests

tested -- panicking_script

      test test_panic_in_main ... ok (???, 1117 gas)
           revert code: 8000000000000000
             panic message: Error C.
             panic value:   C(true)
             panicked:      in panicking_script::main
                                at panicking_script, src/main.sw:6:5
           decoded log values:
C(true), log rb: 5503570629422409978
      test test_nested_panic_inlined ... ok (???, 1888 gas)
           revert code: 8080000000001001
             panic message: Error E.
             panic value:   E([AsciiString { data: "to have" }, AsciiString { data: "strings" }, AsciiString { data: "in error enum variants" }])
             panicked:      in panicking_lib::nested_panic_inlined
                               at panicking_lib, src/lib.sw:35:5
             backtrace:     called in panicking_lib::call_nested_panic_inlined
                                at panicking_lib, src/lib.sw:46:5
                              called in panicking_script::test_nested_panic_inlined
                                at panicking_script, src/main.sw:16:5
           decoded log values:
E([AsciiString { data: "to have" }, AsciiString { data: "strings" }, AsciiString { data: "in error enum variants" }]), log rb: 5503570629422409978
      test test_nested_panic_inlined_same_revert_code ... ok (???, 1888 gas)
           revert code: 8080000000001801
             panic message: Error E.
             panic value:   E([AsciiString { data: "to have" }, AsciiString { data: "strings" }, AsciiString { data: "in error enum variants" }])
             panicked:      in panicking_lib::nested_panic_inlined
                               at panicking_lib, src/lib.sw:35:5
             backtrace:     called in panicking_lib::call_nested_panic_inlined
                                at panicking_lib, src/lib.sw:46:5
                              called in panicking_script::test_nested_panic_inlined_same_revert_code
                                at panicking_script, src/main.sw:21:5
           decoded log values:
E([AsciiString { data: "to have" }, AsciiString { data: "strings" }, AsciiString { data: "in error enum variants" }]), log rb: 5503570629422409978
      test test_nested_panic_non_inlined ... ok (???, 1920 gas)
           revert code: 8100000000002804
             panic message: Error E.
             panic value:   E([AsciiString { data: "this" }, AsciiString { data: "is not" }, AsciiString { data: "the best practice" }])
             panicked:      in panicking_lib::nested_panic_non_inlined
                               at panicking_lib, src/lib.sw:41:9
             backtrace:     called in panicking_lib::call_nested_panic_non_inlined
                                at panicking_lib, src/lib.sw:50:5
                              called in panicking_script::test_nested_panic_non_inlined
                                at panicking_script, src/main.sw:26:5
           decoded log values:
E([AsciiString { data: "this" }, AsciiString { data: "is not" }, AsciiString { data: "the best practice" }]), log rb: 5503570629422409978
      test test_nested_panic_non_inlined_same_revert_code ... ok (???, 1920 gas)
           revert code: 8100000000003004
             panic message: Error E.
             panic value:   E([AsciiString { data: "this" }, AsciiString { data: "is not" }, AsciiString { data: "the best practice" }])
             panicked:      in panicking_lib::nested_panic_non_inlined
                               at panicking_lib, src/lib.sw:41:9
             backtrace:     called in panicking_lib::call_nested_panic_non_inlined
                                at panicking_lib, src/lib.sw:50:5
                              called in panicking_script::test_nested_panic_non_inlined_same_revert_code
                                at panicking_script, src/main.sw:31:5
           decoded log values:
E([AsciiString { data: "this" }, AsciiString { data: "is not" }, AsciiString { data: "the best practice" }]), log rb: 5503570629422409978
      test test_generic_panic_with_unit ... ok (???, 605 gas)
           revert code: 8180000000000007
             panic value:   ()
             panicked:      in panicking_lib::generic_panic
                               at panicking_lib, src/lib.sw:74:5
             backtrace:     called in panicking_script::test_generic_panic_with_unit
                                at panicking_script, src/main.sw:36:5
           decoded log values:
(), log rb: 3330666440490685604
      test test_generic_panic_with_unit_same_revert_code ... ok (???, 605 gas)
           revert code: 8180000000000008
             panic value:   ()
             panicked:      in panicking_lib::generic_panic
                               at panicking_lib, src/lib.sw:74:5
             backtrace:     called in panicking_script::test_generic_panic_with_unit_same_revert_code
                                at panicking_script, src/main.sw:41:5
           decoded log values:
(), log rb: 3330666440490685604
      test test_generic_panic_with_str ... ok (???, 916 gas)
           revert code: 8200000000000009
             panic message: generic panic with string
             panicked:      in panicking_lib::generic_panic
                               at panicking_lib, src/lib.sw:74:5
             backtrace:     called in panicking_script::test_generic_panic_with_str
                                at panicking_script, src/main.sw:46:5
           decoded log values:
AsciiString { data: "generic panic with string" }, log rb: 10098701174489624218
      test test_generic_panic_with_different_str_same_revert_code ... ok (???, 919 gas)
           revert code: 820000000000000a
             panic message: generic panic with different string
             panicked:      in panicking_lib::generic_panic
                               at panicking_lib, src/lib.sw:74:5
             backtrace:     called in panicking_script::test_generic_panic_with_different_str_same_revert_code
                                at panicking_script, src/main.sw:51:5
           decoded log values:
AsciiString { data: "generic panic with different string" }, log rb: 10098701174489624218
      test test_generic_panic_with_error_type_enum ... ok (???, 955 gas)
           revert code: 828000000000000b
             panic message: Error A.
             panic value:   A
             panicked:      in panicking_lib::generic_panic
                               at panicking_lib, src/lib.sw:74:5
             backtrace:     called in panicking_script::test_generic_panic_with_error_type_enum
                                at panicking_script, src/main.sw:56:5
           decoded log values:
A, log rb: 5503570629422409978
      test test_generic_panic_with_error_type_enum_different_variant_same_revert_code ... ok (???, 1090 gas)
           revert code: 828000000000000c
             panic message: Error B.
             panic value:   B(42)
             panicked:      in panicking_lib::generic_panic
                               at panicking_lib, src/lib.sw:74:5
             backtrace:     called in panicking_script::test_generic_panic_with_error_type_enum_different_variant_same_revert_code
                                at panicking_script, src/main.sw:61:5
           decoded log values:
B(42), log rb: 5503570629422409978

test result: OK. 11 passed; 0 failed; finished in ???

    Finished in ???

> forc test --path test/src/e2e_vm_tests/test_programs/should_pass/language/panic_expression/panicking_script --release --test-threads 1 --logs --reverts
exit status: 0
output:
    Building test/src/e2e_vm_tests/test_programs/should_pass/language/panic_expression/panicking_script
   Compiling library std (test/src/e2e_vm_tests/reduced_std_libs/sway-lib-std-core)
DIFF------------------------------
.program:
DIFF------------------------------
.program:
   Compiling library panicking_lib (test/src/e2e_vm_tests/test_programs/should_pass/language/panic_expression/panicking_lib)
DIFF------------------------------
.program:
DIFF------------------------------
.program:
   Compiling script panicking_script (test/src/e2e_vm_tests/test_programs/should_pass/language/panic_expression/panicking_script)
DIFF------------------------------
.program:
DIFF------------------------------
.program:
DIFF------------------------------
.program:
.0                                      ; --- start of function: __entry ---
move $$locbase $sp                      ; [entry init: __entry]: set locals base register
cfei i0                                 ; [entry init: __entry]: allocate: locals 0 byte(s), call args 0 slot(s)
.46
fncall .2                               ; [call: main_0]: call function
 move $r1 $zero                          ; [call: main_0]: copy returned unit value
 movi $r1 i0                             ; [call: main_0]: copy returned unit value
retd $zero $zero                        ; [entry end: __entry] return slice
DIFF------------------------------
.program:
.0                                      ; --- start of function: __entry ---
move $$locbase $sp                      ; [entry init: __entry]: set locals base register
cfei i0                                 ; [entry init: __entry]: allocate: locals 0 byte(s), call args 0 slot(s)
.46
fncall .2                               ; [call: main_0]: call function
retd $zero $zero                        ; [entry end: __entry] return slice
DIFF------------------------------
.program:
.0                                      ; --- start of function: __entry ---
move $$locbase $sp                      ; [entry init: __entry]: set locals base register
cfei i0                                 ; [entry init: __entry]: allocate: locals 0 byte(s), call args 0 slot(s)
.46
fncall .2                               ; [call: main_0]: call function
retd $zero $zero                        ; [entry end: __entry] return slice
DIFF------------------------------
.program:
.0                                      ; --- start of function: __entry ---
move $$locbase $sp                      ; [entry init: __entry]: set locals base register
cfei i0                                 ; [entry init: __entry]: allocate: locals 0 byte(s), call args 0 slot(s)
.46
fncall .2                               ; [call: main_0]: call function
retd $zero $zero                        ; [entry end: __entry] return slice
DIFF------------------------------
.program:
.14                                     ; --- start of function: test_panic_in_main ---
move $$locbase $sp                      ; [entry init: test_panic_in_main]: set locals base register
cfei i0                                 ; [entry init: test_panic_in_main]: allocate: locals 0 byte(s), call args 0 slot(s)
.87
fncall .2                               ; [call: main_0]: call function
 move $r345 $zero                        ; [call: main_0]: copy returned unit value
 movi $r345 i0                           ; [call: main_0]: copy returned unit value
ret $zero                               ; [entry end: test_panic_in_main] return unit as zero
DIFF------------------------------
.program:
.14                                     ; --- start of function: test_panic_in_main ---
move $$locbase $sp                      ; [entry init: test_panic_in_main]: set locals base register
cfei i0                                 ; [entry init: test_panic_in_main]: allocate: locals 0 byte(s), call args 0 slot(s)
.87
fncall .2                               ; [call: main_0]: call function
ret $zero                               ; [entry end: test_panic_in_main] return unit as zero
DIFF------------------------------
.program:
.14                                     ; --- start of function: test_panic_in_main ---
move $$locbase $sp                      ; [entry init: test_panic_in_main]: set locals base register
cfei i0                                 ; [entry init: test_panic_in_main]: allocate: locals 0 byte(s), call args 0 slot(s)
.87
fncall .2                               ; [call: main_0]: call function
ret $zero                               ; [entry end: test_panic_in_main] return unit as zero
DIFF------------------------------
.program:
.14                                     ; --- start of function: test_panic_in_main ---
move $$locbase $sp                      ; [entry init: test_panic_in_main]: set locals base register
cfei i0                                 ; [entry init: test_panic_in_main]: allocate: locals 0 byte(s), call args 0 slot(s)
.87
fncall .2                               ; [call: main_0]: call function
ret $zero                               ; [entry end: test_panic_in_main] return unit as zero
DIFF------------------------------
.program:
.16                                     ; --- start of function: test_nested_panic_inlined ---
move $$locbase $sp                      ; [entry init: test_nested_panic_inlined]: set locals base register
cfei i0                                 ; [entry init: test_nested_panic_inlined]: allocate: locals 0 byte(s), call args 0 slot(s)
.88
 move $$arg0 $zero                       ; [call: call_nested_panic_inlined_30]: pass argument 0
 movi $$arg0 i0                          ; [call: call_nested_panic_inlined_30]: pass argument 0
fncall .18                              ; [call: call_nested_panic_inlined_30]: call function
 move $r347 $zero                        ; [call: call_nested_panic_inlined_30]: copy returned unit value
 movi $r347 i0                           ; [call: call_nested_panic_inlined_30]: copy returned unit value
ret $zero                               ; [entry end: test_nested_panic_inlined] return unit as zero
DIFF------------------------------
.program:
.16                                     ; --- start of function: test_nested_panic_inlined ---
move $$locbase $sp                      ; [entry init: test_nested_panic_inlined]: set locals base register
cfei i0                                 ; [entry init: test_nested_panic_inlined]: allocate: locals 0 byte(s), call args 0 slot(s)
.88
movi $$arg0 i0                          ; [call: call_nested_panic_inlined_30]: pass argument 0
fncall .18                              ; [call: call_nested_panic_inlined_30]: call function
ret $zero                               ; [entry end: test_nested_panic_inlined] return unit as zero
DIFF------------------------------
.program:
.16                                     ; --- start of function: test_nested_panic_inlined ---
move $$locbase $sp                      ; [entry init: test_nested_panic_inlined]: set locals base register
cfei i0                                 ; [entry init: test_nested_panic_inlined]: allocate: locals 0 byte(s), call args 0 slot(s)
.88
movi $$arg0 i0                          ; [call: call_nested_panic_inlined_30]: pass argument 0
fncall .18                              ; [call: call_nested_panic_inlined_30]: call function
ret $zero                               ; [entry end: test_nested_panic_inlined] return unit as zero
DIFF------------------------------
.program:
.16                                     ; --- start of function: test_nested_panic_inlined ---
move $$locbase $sp                      ; [entry init: test_nested_panic_inlined]: set locals base register
cfei i0                                 ; [entry init: test_nested_panic_inlined]: allocate: locals 0 byte(s), call args 0 slot(s)
.88
movi $$arg0 i0                          ; [call: call_nested_panic_inlined_30]: pass argument 0
fncall .18                              ; [call: call_nested_panic_inlined_30]: call function
ret $zero                               ; [entry end: test_nested_panic_inlined] return unit as zero
DIFF------------------------------
.program:
.20                                     ; --- start of function: test_nested_panic_inlined_same_revert_code ---
move $$locbase $sp                      ; [entry init: test_nested_panic_inlined_same_revert_code]: set locals base register
cfei i0                                 ; [entry init: test_nested_panic_inlined_same_revert_code]: allocate: locals 0 byte(s), call args 0 slot(s)
.90
 move $$arg0 $zero                       ; [call: call_nested_panic_inlined_30]: pass argument 0
 movi $$arg0 i0                          ; [call: call_nested_panic_inlined_30]: pass argument 0
fncall .18                              ; [call: call_nested_panic_inlined_30]: call function
 move $r387 $zero                        ; [call: call_nested_panic_inlined_30]: copy returned unit value
 movi $r387 i0                           ; [call: call_nested_panic_inlined_30]: copy returned unit value
ret $zero                               ; [entry end: test_nested_panic_inlined_same_revert_code] return unit as zero
DIFF------------------------------
.program:
.20                                     ; --- start of function: test_nested_panic_inlined_same_revert_code ---
move $$locbase $sp                      ; [entry init: test_nested_panic_inlined_same_revert_code]: set locals base register
cfei i0                                 ; [entry init: test_nested_panic_inlined_same_revert_code]: allocate: locals 0 byte(s), call args 0 slot(s)
.90
movi $$arg0 i0                          ; [call: call_nested_panic_inlined_30]: pass argument 0
fncall .18                              ; [call: call_nested_panic_inlined_30]: call function
ret $zero                               ; [entry end: test_nested_panic_inlined_same_revert_code] return unit as zero
DIFF------------------------------
.program:
.20                                     ; --- start of function: test_nested_panic_inlined_same_revert_code ---
move $$locbase $sp                      ; [entry init: test_nested_panic_inlined_same_revert_code]: set locals base register
cfei i0                                 ; [entry init: test_nested_panic_inlined_same_revert_code]: allocate: locals 0 byte(s), call args 0 slot(s)
.90
movi $$arg0 i0                          ; [call: call_nested_panic_inlined_30]: pass argument 0
fncall .18                              ; [call: call_nested_panic_inlined_30]: call function
ret $zero                               ; [entry end: test_nested_panic_inlined_same_revert_code] return unit as zero
DIFF------------------------------
.program:
.20                                     ; --- start of function: test_nested_panic_inlined_same_revert_code ---
move $$locbase $sp                      ; [entry init: test_nested_panic_inlined_same_revert_code]: set locals base register
cfei i0                                 ; [entry init: test_nested_panic_inlined_same_revert_code]: allocate: locals 0 byte(s), call args 0 slot(s)
.90
movi $$arg0 i0                          ; [call: call_nested_panic_inlined_30]: pass argument 0
fncall .18                              ; [call: call_nested_panic_inlined_30]: call function
ret $zero                               ; [entry end: test_nested_panic_inlined_same_revert_code] return unit as zero
DIFF------------------------------
.program:
.22                                     ; --- start of function: test_nested_panic_non_inlined ---
move $$locbase $sp                      ; [entry init: test_nested_panic_non_inlined]: set locals base register
cfei i0                                 ; [entry init: test_nested_panic_non_inlined]: allocate: locals 0 byte(s), call args 0 slot(s)
.91
 move $$arg0 $zero                       ; [call: call_nested_panic_non_inlined_32]: pass argument 0
 movi $$arg0 i0                          ; [call: call_nested_panic_non_inlined_32]: pass argument 0
fncall .24                              ; [call: call_nested_panic_non_inlined_32]: call function
 move $r389 $zero                        ; [call: call_nested_panic_non_inlined_32]: copy returned unit value
 movi $r389 i0                           ; [call: call_nested_panic_non_inlined_32]: copy returned unit value
ret $zero                               ; [entry end: test_nested_panic_non_inlined] return unit as zero
DIFF------------------------------
.program:
.22                                     ; --- start of function: test_nested_panic_non_inlined ---
move $$locbase $sp                      ; [entry init: test_nested_panic_non_inlined]: set locals base register
cfei i0                                 ; [entry init: test_nested_panic_non_inlined]: allocate: locals 0 byte(s), call args 0 slot(s)
.91
movi $$arg0 i0                          ; [call: call_nested_panic_non_inlined_32]: pass argument 0
fncall .24                              ; [call: call_nested_panic_non_inlined_32]: call function
ret $zero                               ; [entry end: test_nested_panic_non_inlined] return unit as zero
DIFF------------------------------
.program:
.22                                     ; --- start of function: test_nested_panic_non_inlined ---
move $$locbase $sp                      ; [entry init: test_nested_panic_non_inlined]: set locals base register
cfei i0                                 ; [entry init: test_nested_panic_non_inlined]: allocate: locals 0 byte(s), call args 0 slot(s)
.91
movi $$arg0 i0                          ; [call: call_nested_panic_non_inlined_32]: pass argument 0
fncall .24                              ; [call: call_nested_panic_non_inlined_32]: call function
ret $zero                               ; [entry end: test_nested_panic_non_inlined] return unit as zero
DIFF------------------------------
.program:
.22                                     ; --- start of function: test_nested_panic_non_inlined ---
move $$locbase $sp                      ; [entry init: test_nested_panic_non_inlined]: set locals base register
cfei i0                                 ; [entry init: test_nested_panic_non_inlined]: allocate: locals 0 byte(s), call args 0 slot(s)
.91
movi $$arg0 i0                          ; [call: call_nested_panic_non_inlined_32]: pass argument 0
fncall .24                              ; [call: call_nested_panic_non_inlined_32]: call function
ret $zero                               ; [entry end: test_nested_panic_non_inlined] return unit as zero
DIFF------------------------------
.program:
.28                                     ; --- start of function: test_nested_panic_non_inlined_same_revert_code ---
move $$locbase $sp                      ; [entry init: test_nested_panic_non_inlined_same_revert_code]: set locals base register
cfei i0                                 ; [entry init: test_nested_panic_non_inlined_same_revert_code]: allocate: locals 0 byte(s), call args 0 slot(s)
.96
 move $$arg0 $zero                       ; [call: call_nested_panic_non_inlined_32]: pass argument 0
 movi $$arg0 i0                          ; [call: call_nested_panic_non_inlined_32]: pass argument 0
fncall .24                              ; [call: call_nested_panic_non_inlined_32]: call function
 move $r433 $zero                        ; [call: call_nested_panic_non_inlined_32]: copy returned unit value
 movi $r433 i0                           ; [call: call_nested_panic_non_inlined_32]: copy returned unit value
ret $zero                               ; [entry end: test_nested_panic_non_inlined_same_revert_code] return unit as zero
DIFF------------------------------
.program:
.28                                     ; --- start of function: test_nested_panic_non_inlined_same_revert_code ---
move $$locbase $sp                      ; [entry init: test_nested_panic_non_inlined_same_revert_code]: set locals base register
cfei i0                                 ; [entry init: test_nested_panic_non_inlined_same_revert_code]: allocate: locals 0 byte(s), call args 0 slot(s)
.96
movi $$arg0 i0                          ; [call: call_nested_panic_non_inlined_32]: pass argument 0
fncall .24                              ; [call: call_nested_panic_non_inlined_32]: call function
ret $zero                               ; [entry end: test_nested_panic_non_inlined_same_revert_code] return unit as zero
DIFF------------------------------
.program:
.28                                     ; --- start of function: test_nested_panic_non_inlined_same_revert_code ---
move $$locbase $sp                      ; [entry init: test_nested_panic_non_inlined_same_revert_code]: set locals base register
cfei i0                                 ; [entry init: test_nested_panic_non_inlined_same_revert_code]: allocate: locals 0 byte(s), call args 0 slot(s)
.96
movi $$arg0 i0                          ; [call: call_nested_panic_non_inlined_32]: pass argument 0
fncall .24                              ; [call: call_nested_panic_non_inlined_32]: call function
ret $zero                               ; [entry end: test_nested_panic_non_inlined_same_revert_code] return unit as zero
DIFF------------------------------
.program:
.28                                     ; --- start of function: test_nested_panic_non_inlined_same_revert_code ---
move $$locbase $sp                      ; [entry init: test_nested_panic_non_inlined_same_revert_code]: set locals base register
cfei i0                                 ; [entry init: test_nested_panic_non_inlined_same_revert_code]: allocate: locals 0 byte(s), call args 0 slot(s)
.96
movi $$arg0 i0                          ; [call: call_nested_panic_non_inlined_32]: pass argument 0
fncall .24                              ; [call: call_nested_panic_non_inlined_32]: call function
ret $zero                               ; [entry end: test_nested_panic_non_inlined_same_revert_code] return unit as zero
DIFF------------------------------
.program:
.30                                     ; --- start of function: test_generic_panic_with_unit ---
move $$locbase $sp                      ; [entry init: test_generic_panic_with_unit]: set locals base register
cfei i0                                 ; [entry init: test_generic_panic_with_unit]: allocate: locals 0 byte(s), call args 0 slot(s)
.97
 move $$arg0 $zero                       ; [call: generic_panic_34]: pass argument 0
 move $$arg1 $zero                       ; [call: generic_panic_34]: pass argument 1
 movi $$arg0 i0                          ; [call: generic_panic_34]: pass argument 0
 movi $$arg1 i0                          ; [call: generic_panic_34]: pass argument 1
fncall .32                              ; [call: generic_panic_34]: call function
 move $r435 $zero                        ; [call: generic_panic_34]: copy returned unit value
 movi $r435 i0                           ; [call: generic_panic_34]: copy returned unit value
ret $zero                               ; [entry end: test_generic_panic_with_unit] return unit as zero
DIFF------------------------------
.program:
.30                                     ; --- start of function: test_generic_panic_with_unit ---
move $$locbase $sp                      ; [entry init: test_generic_panic_with_unit]: set locals base register
cfei i0                                 ; [entry init: test_generic_panic_with_unit]: allocate: locals 0 byte(s), call args 0 slot(s)
.97
movi $$arg0 i0                          ; [call: generic_panic_34]: pass argument 0
movi $$arg1 i0                          ; [call: generic_panic_34]: pass argument 1
fncall .32                              ; [call: generic_panic_34]: call function
ret $zero                               ; [entry end: test_generic_panic_with_unit] return unit as zero
DIFF------------------------------
.program:
.30                                     ; --- start of function: test_generic_panic_with_unit ---
move $$locbase $sp                      ; [entry init: test_generic_panic_with_unit]: set locals base register
cfei i0                                 ; [entry init: test_generic_panic_with_unit]: allocate: locals 0 byte(s), call args 0 slot(s)
.97
movi $$arg0 i0                          ; [call: generic_panic_34]: pass argument 0
movi $$arg1 i0                          ; [call: generic_panic_34]: pass argument 1
fncall .32                              ; [call: generic_panic_34]: call function
ret $zero                               ; [entry end: test_generic_panic_with_unit] return unit as zero
DIFF------------------------------
.program:
.30                                     ; --- start of function: test_generic_panic_with_unit ---
move $$locbase $sp                      ; [entry init: test_generic_panic_with_unit]: set locals base register
cfei i0                                 ; [entry init: test_generic_panic_with_unit]: allocate: locals 0 byte(s), call args 0 slot(s)
.97
movi $$arg0 i0                          ; [call: generic_panic_34]: pass argument 0
movi $$arg1 i0                          ; [call: generic_panic_34]: pass argument 1
fncall .32                              ; [call: generic_panic_34]: call function
ret $zero                               ; [entry end: test_generic_panic_with_unit] return unit as zero
DIFF------------------------------
.program:
.34                                     ; --- start of function: test_generic_panic_with_unit_same_revert_code ---
move $$locbase $sp                      ; [entry init: test_generic_panic_with_unit_same_revert_code]: set locals base register
cfei i0                                 ; [entry init: test_generic_panic_with_unit_same_revert_code]: allocate: locals 0 byte(s), call args 0 slot(s)
.99
 move $$arg0 $zero                       ; [call: generic_panic_34]: pass argument 0
 move $$arg1 $zero                       ; [call: generic_panic_34]: pass argument 1
 movi $$arg0 i0                          ; [call: generic_panic_34]: pass argument 0
 movi $$arg1 i0                          ; [call: generic_panic_34]: pass argument 1
fncall .32                              ; [call: generic_panic_34]: call function
 move $r449 $zero                        ; [call: generic_panic_34]: copy returned unit value
 movi $r449 i0                           ; [call: generic_panic_34]: copy returned unit value
ret $zero                               ; [entry end: test_generic_panic_with_unit_same_revert_code] return unit as zero
DIFF------------------------------
.program:
.34                                     ; --- start of function: test_generic_panic_with_unit_same_revert_code ---
move $$locbase $sp                      ; [entry init: test_generic_panic_with_unit_same_revert_code]: set locals base register
cfei i0                                 ; [entry init: test_generic_panic_with_unit_same_revert_code]: allocate: locals 0 byte(s), call args 0 slot(s)
.99
movi $$arg0 i0                          ; [call: generic_panic_34]: pass argument 0
movi $$arg1 i0                          ; [call: generic_panic_34]: pass argument 1
fncall .32                              ; [call: generic_panic_34]: call function
ret $zero                               ; [entry end: test_generic_panic_with_unit_same_revert_code] return unit as zero
DIFF------------------------------
.program:
.34                                     ; --- start of function: test_generic_panic_with_unit_same_revert_code ---
move $$locbase $sp                      ; [entry init: test_generic_panic_with_unit_same_revert_code]: set locals base register
cfei i0                                 ; [entry init: test_generic_panic_with_unit_same_revert_code]: allocate: locals 0 byte(s), call args 0 slot(s)
.99
movi $$arg0 i0                          ; [call: generic_panic_34]: pass argument 0
movi $$arg1 i0                          ; [call: generic_panic_34]: pass argument 1
fncall .32                              ; [call: generic_panic_34]: call function
ret $zero                               ; [entry end: test_generic_panic_with_unit_same_revert_code] return unit as zero
DIFF------------------------------
.program:
.34                                     ; --- start of function: test_generic_panic_with_unit_same_revert_code ---
move $$locbase $sp                      ; [entry init: test_generic_panic_with_unit_same_revert_code]: set locals base register
cfei i0                                 ; [entry init: test_generic_panic_with_unit_same_revert_code]: allocate: locals 0 byte(s), call args 0 slot(s)
.99
movi $$arg0 i0                          ; [call: generic_panic_34]: pass argument 0
movi $$arg1 i0                          ; [call: generic_panic_34]: pass argument 1
fncall .32                              ; [call: generic_panic_34]: call function
ret $zero                               ; [entry end: test_generic_panic_with_unit_same_revert_code] return unit as zero
DIFF------------------------------
.program:
.36                                     ; --- start of function: test_generic_panic_with_str ---
move $$locbase $sp                      ; [entry init: test_generic_panic_with_str]: set locals base register
cfei i32                                ; [entry init: test_generic_panic_with_str]: allocate: locals 32 byte(s), call args 0 slot(s)
.100
addr $r451 data_NonConfigurable_14      ; get __const_global5's address in data section
sw $$locbase $r451 i0                   ; store word
addi $r452 $$locbase i8                 ; get offset to aggregate element
movi $r453 i25                          ; initialize constant into register
sw $$locbase $r453 i1                   ; store word
addi $r454 $$locbase i16                ; get offset to local __ptr slice
mcpi $r454 $$locbase i16                ; copy memory
addi $r455 $$locbase i16                ; get offset to local __ptr slice
move $$arg0 $r455                       ; [call: generic_panic_37]: pass argument 0
 move $$arg1 $zero                       ; [call: generic_panic_37]: pass argument 1
 movi $$arg1 i0                          ; [call: generic_panic_37]: pass argument 1
fncall .38                              ; [call: generic_panic_37]: call function
 move $r456 $zero                        ; [call: generic_panic_37]: copy returned unit value
 movi $r456 i0                           ; [call: generic_panic_37]: copy returned unit value
ret $zero                               ; [entry end: test_generic_panic_with_str] return unit as zero
DIFF------------------------------
.program:
.36                                     ; --- start of function: test_generic_panic_with_str ---
move $$locbase $sp                      ; [entry init: test_generic_panic_with_str]: set locals base register
cfei i32                                ; [entry init: test_generic_panic_with_str]: allocate: locals 32 byte(s), call args 0 slot(s)
.100
addr $r451 data_NonConfigurable_14      ; get __const_global5's address in data section
sw $$locbase $r451 i0                   ; store word
movi $r453 i25                          ; initialize constant into register
sw $$locbase $r453 i1                   ; store word
addi $r454 $$locbase i16                ; get offset to local __ptr slice
mcpi $r454 $$locbase i16                ; copy memory
addi $r455 $$locbase i16                ; get offset to local __ptr slice
move $$arg0 $r455                       ; [call: generic_panic_37]: pass argument 0
movi $$arg1 i0                          ; [call: generic_panic_37]: pass argument 1
fncall .38                              ; [call: generic_panic_37]: call function
ret $zero                               ; [entry end: test_generic_panic_with_str] return unit as zero
DIFF------------------------------
.program:
.36                                     ; --- start of function: test_generic_panic_with_str ---
move $$locbase $sp                      ; [entry init: test_generic_panic_with_str]: set locals base register
cfei i32                                ; [entry init: test_generic_panic_with_str]: allocate: locals 32 byte(s), call args 0 slot(s)
.100
addr $r451 data_NonConfigurable_14      ; get __const_global5's address in data section
sw $$locbase $r451 i0                   ; store word
movi $r453 i25                          ; initialize constant into register
sw $$locbase $r453 i1                   ; store word
addi $r454 $$locbase i16                ; get offset to local __ptr slice
mcpi $r454 $$locbase i16                ; copy memory
addi $r455 $$locbase i16                ; get offset to local __ptr slice
move $$arg0 $r455                       ; [call: generic_panic_37]: pass argument 0
movi $$arg1 i0                          ; [call: generic_panic_37]: pass argument 1
fncall .38                              ; [call: generic_panic_37]: call function
ret $zero                               ; [entry end: test_generic_panic_with_str] return unit as zero
DIFF------------------------------
.program:
.36                                     ; --- start of function: test_generic_panic_with_str ---
move $$locbase $sp                      ; [entry init: test_generic_panic_with_str]: set locals base register
cfei i32                                ; [entry init: test_generic_panic_with_str]: allocate: locals 32 byte(s), call args 0 slot(s)
.100
addr $r451 data_NonConfigurable_14      ; get __const_global5's address in data section
sw $$locbase $r451 i0                   ; store word
movi $r453 i25                          ; initialize constant into register
sw $$locbase $r453 i1                   ; store word
addi $r454 $$locbase i16                ; get offset to local __ptr slice
mcpi $r454 $$locbase i16                ; copy memory
addi $r455 $$locbase i16                ; get offset to local __ptr slice
move $$arg0 $r455                       ; [call: generic_panic_37]: pass argument 0
movi $$arg1 i0                          ; [call: generic_panic_37]: pass argument 1
fncall .38                              ; [call: generic_panic_37]: call function
ret $zero                               ; [entry end: test_generic_panic_with_str] return unit as zero
DIFF------------------------------
.program:
.40                                     ; --- start of function: test_generic_panic_with_different_str_same_revert_code ---
move $$locbase $sp                      ; [entry init: test_generic_panic_with_different_str_same_revert_code]: set locals base register
cfei i32                                ; [entry init: test_generic_panic_with_different_str_same_revert_code]: allocate: locals 32 byte(s), call args 0 slot(s)
.102
addr $r475 data_NonConfigurable_17      ; get __const_global6's address in data section
sw $$locbase $r475 i0                   ; store word
addi $r476 $$locbase i8                 ; get offset to aggregate element
movi $r477 i35                          ; initialize constant into register
sw $$locbase $r477 i1                   ; store word
addi $r478 $$locbase i16                ; get offset to local __ptr slice
mcpi $r478 $$locbase i16                ; copy memory
addi $r479 $$locbase i16                ; get offset to local __ptr slice
move $$arg0 $r479                       ; [call: generic_panic_37]: pass argument 0
 move $$arg1 $zero                       ; [call: generic_panic_37]: pass argument 1
 movi $$arg1 i0                          ; [call: generic_panic_37]: pass argument 1
fncall .38                              ; [call: generic_panic_37]: call function
 move $r480 $zero                        ; [call: generic_panic_37]: copy returned unit value
 movi $r480 i0                           ; [call: generic_panic_37]: copy returned unit value
ret $zero                               ; [entry end: test_generic_panic_with_different_str_same_revert_code] return unit as zero
DIFF------------------------------
.program:
.40                                     ; --- start of function: test_generic_panic_with_different_str_same_revert_code ---
move $$locbase $sp                      ; [entry init: test_generic_panic_with_different_str_same_revert_code]: set locals base register
cfei i32                                ; [entry init: test_generic_panic_with_different_str_same_revert_code]: allocate: locals 32 byte(s), call args 0 slot(s)
.102
addr $r475 data_NonConfigurable_17      ; get __const_global6's address in data section
sw $$locbase $r475 i0                   ; store word
movi $r477 i35                          ; initialize constant into register
sw $$locbase $r477 i1                   ; store word
addi $r478 $$locbase i16                ; get offset to local __ptr slice
mcpi $r478 $$locbase i16                ; copy memory
addi $r479 $$locbase i16                ; get offset to local __ptr slice
move $$arg0 $r479                       ; [call: generic_panic_37]: pass argument 0
movi $$arg1 i0                          ; [call: generic_panic_37]: pass argument 1
fncall .38                              ; [call: generic_panic_37]: call function
ret $zero                               ; [entry end: test_generic_panic_with_different_str_same_revert_code] return unit as zero
DIFF------------------------------
.program:
.40                                     ; --- start of function: test_generic_panic_with_different_str_same_revert_code ---
move $$locbase $sp                      ; [entry init: test_generic_panic_with_different_str_same_revert_code]: set locals base register
cfei i32                                ; [entry init: test_generic_panic_with_different_str_same_revert_code]: allocate: locals 32 byte(s), call args 0 slot(s)
.102
addr $r475 data_NonConfigurable_17      ; get __const_global6's address in data section
sw $$locbase $r475 i0                   ; store word
movi $r477 i35                          ; initialize constant into register
sw $$locbase $r477 i1                   ; store word
addi $r478 $$locbase i16                ; get offset to local __ptr slice
mcpi $r478 $$locbase i16                ; copy memory
addi $r479 $$locbase i16                ; get offset to local __ptr slice
move $$arg0 $r479                       ; [call: generic_panic_37]: pass argument 0
movi $$arg1 i0                          ; [call: generic_panic_37]: pass argument 1
fncall .38                              ; [call: generic_panic_37]: call function
ret $zero                               ; [entry end: test_generic_panic_with_different_str_same_revert_code] return unit as zero
DIFF------------------------------
.program:
.40                                     ; --- start of function: test_generic_panic_with_different_str_same_revert_code ---
move $$locbase $sp                      ; [entry init: test_generic_panic_with_different_str_same_revert_code]: set locals base register
cfei i32                                ; [entry init: test_generic_panic_with_different_str_same_revert_code]: allocate: locals 32 byte(s), call args 0 slot(s)
.102
addr $r475 data_NonConfigurable_17      ; get __const_global6's address in data section
sw $$locbase $r475 i0                   ; store word
movi $r477 i35                          ; initialize constant into register
sw $$locbase $r477 i1                   ; store word
addi $r478 $$locbase i16                ; get offset to local __ptr slice
mcpi $r478 $$locbase i16                ; copy memory
addi $r479 $$locbase i16                ; get offset to local __ptr slice
move $$arg0 $r479                       ; [call: generic_panic_37]: pass argument 0
movi $$arg1 i0                          ; [call: generic_panic_37]: pass argument 1
fncall .38                              ; [call: generic_panic_37]: call function
ret $zero                               ; [entry end: test_generic_panic_with_different_str_same_revert_code] return unit as zero
DIFF------------------------------
.program:
.42                                     ; --- start of function: test_generic_panic_with_error_type_enum ---
move $$locbase $sp                      ; [entry init: test_generic_panic_with_error_type_enum]: set locals base register
cfei i72                                ; [entry init: test_generic_panic_with_error_type_enum]: allocate: locals 72 byte(s), call args 0 slot(s)
.103
addi $r482 $$locbase i16                ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
sw $$locbase $zero i2                   ; store word
addi $r483 $$locbase i16                ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
move $$arg0 $r483                       ; [call: encode_allow_alias_1]: pass argument 0
move $$arg1 $$locbase                   ; [call: encode_allow_alias_1]: pass argument 1
fncall .4                               ; [call: encode_allow_alias_1]: call function
 move $r484 $zero                        ; [call: encode_allow_alias_1]: copy returned unit value
 movi $r484 i0                           ; [call: encode_allow_alias_1]: copy returned unit value
load $r485 data_NonConfigurable_0       ; load constant from data section
lw $r486 $$locbase i0                   ; load slice pointer for logging data
lw $r487 $$locbase i1                   ; load slice size for logging data
logd $zero $r485 $r486 $r487            ; log slice
load $r488 data_NonConfigurable_18      ; load constant from data section
rvrt $r488
DIFF------------------------------
.program:
.42                                     ; --- start of function: test_generic_panic_with_error_type_enum ---
move $$locbase $sp                      ; [entry init: test_generic_panic_with_error_type_enum]: set locals base register
cfei i72                                ; [entry init: test_generic_panic_with_error_type_enum]: allocate: locals 72 byte(s), call args 0 slot(s)
.103
sw $$locbase $zero i2                   ; store word
addi $r483 $$locbase i16                ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
move $$arg0 $r483                       ; [call: encode_allow_alias_1]: pass argument 0
move $$arg1 $$locbase                   ; [call: encode_allow_alias_1]: pass argument 1
fncall .4                               ; [call: encode_allow_alias_1]: call function
load $r485 data_NonConfigurable_0       ; load constant from data section
lw $r486 $$locbase i0                   ; load slice pointer for logging data
lw $r487 $$locbase i1                   ; load slice size for logging data
logd $zero $r485 $r486 $r487            ; log slice
load $r488 data_NonConfigurable_18      ; load constant from data section
rvrt $r488
DIFF------------------------------
.program:
.42                                     ; --- start of function: test_generic_panic_with_error_type_enum ---
move $$locbase $sp                      ; [entry init: test_generic_panic_with_error_type_enum]: set locals base register
cfei i72                                ; [entry init: test_generic_panic_with_error_type_enum]: allocate: locals 72 byte(s), call args 0 slot(s)
.103
sw $$locbase $zero i2                   ; store word
addi $r483 $$locbase i16                ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
move $$arg0 $r483                       ; [call: encode_allow_alias_1]: pass argument 0
move $$arg1 $$locbase                   ; [call: encode_allow_alias_1]: pass argument 1
fncall .4                               ; [call: encode_allow_alias_1]: call function
load $r485 data_NonConfigurable_0       ; load constant from data section
lw $r486 $$locbase i0                   ; load slice pointer for logging data
lw $r487 $$locbase i1                   ; load slice size for logging data
logd $zero $r485 $r486 $r487            ; log slice
load $r488 data_NonConfigurable_18      ; load constant from data section
rvrt $r488
DIFF------------------------------
.program:
.42                                     ; --- start of function: test_generic_panic_with_error_type_enum ---
move $$locbase $sp                      ; [entry init: test_generic_panic_with_error_type_enum]: set locals base register
cfei i72                                ; [entry init: test_generic_panic_with_error_type_enum]: allocate: locals 72 byte(s), call args 0 slot(s)
.103
sw $$locbase $zero i2                   ; store word
addi $r483 $$locbase i16                ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
move $$arg0 $r483                       ; [call: encode_allow_alias_1]: pass argument 0
move $$arg1 $$locbase                   ; [call: encode_allow_alias_1]: pass argument 1
fncall .4                               ; [call: encode_allow_alias_1]: call function
load $r485 data_NonConfigurable_0       ; load constant from data section
lw $r486 $$locbase i0                   ; load slice pointer for logging data
lw $r487 $$locbase i1                   ; load slice size for logging data
logd $zero $r485 $r486 $r487            ; log slice
load $r488 data_NonConfigurable_18      ; load constant from data section
rvrt $r488
DIFF------------------------------
.program:
.44                                     ; --- start of function: test_generic_panic_with_error_type_enum_different_variant_same_revert_code ---
move $$locbase $sp                      ; [entry init: test_generic_panic_with_error_type_enum_different_variant_same_revert_code]: set locals base register
cfei i72                                ; [entry init: test_generic_panic_with_error_type_enum_different_variant_same_revert_code]: allocate: locals 72 byte(s), call args 0 slot(s)
.104
addi $r490 $$locbase i16                ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
sw $$locbase $one i2                    ; store word
addi $r491 $r490 i55                    ; get offset to aggregate element
movi $r492 i42                          ; initialize constant into register
sb $r491 $r492 i0                       ; store byte
addi $r493 $$locbase i16                ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
move $$arg0 $r493                       ; [call: encode_allow_alias_1]: pass argument 0
move $$arg1 $$locbase                   ; [call: encode_allow_alias_1]: pass argument 1
fncall .4                               ; [call: encode_allow_alias_1]: call function
 move $r494 $zero                        ; [call: encode_allow_alias_1]: copy returned unit value
 movi $r494 i0                           ; [call: encode_allow_alias_1]: copy returned unit value
load $r495 data_NonConfigurable_0       ; load constant from data section
lw $r496 $$locbase i0                   ; load slice pointer for logging data
lw $r497 $$locbase i1                   ; load slice size for logging data
logd $zero $r495 $r496 $r497            ; log slice
load $r498 data_NonConfigurable_18      ; load constant from data section
rvrt $r498
DIFF------------------------------
.program:
.44                                     ; --- start of function: test_generic_panic_with_error_type_enum_different_variant_same_revert_code ---
move $$locbase $sp                      ; [entry init: test_generic_panic_with_error_type_enum_different_variant_same_revert_code]: set locals base register
cfei i72                                ; [entry init: test_generic_panic_with_error_type_enum_different_variant_same_revert_code]: allocate: locals 72 byte(s), call args 0 slot(s)
.104
addi $r490 $$locbase i16                ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
sw $$locbase $one i2                    ; store word
addi $r491 $r490 i55                    ; get offset to aggregate element
movi $r492 i42                          ; initialize constant into register
sb $r491 $r492 i0                       ; store byte
addi $r493 $$locbase i16                ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
move $$arg0 $r493                       ; [call: encode_allow_alias_1]: pass argument 0
move $$arg1 $$locbase                   ; [call: encode_allow_alias_1]: pass argument 1
fncall .4                               ; [call: encode_allow_alias_1]: call function
load $r495 data_NonConfigurable_0       ; load constant from data section
lw $r496 $$locbase i0                   ; load slice pointer for logging data
lw $r497 $$locbase i1                   ; load slice size for logging data
logd $zero $r495 $r496 $r497            ; log slice
load $r498 data_NonConfigurable_18      ; load constant from data section
rvrt $r498
DIFF------------------------------
.program:
.44                                     ; --- start of function: test_generic_panic_with_error_type_enum_different_variant_same_revert_code ---
move $$locbase $sp                      ; [entry init: test_generic_panic_with_error_type_enum_different_variant_same_revert_code]: set locals base register
cfei i72                                ; [entry init: test_generic_panic_with_error_type_enum_different_variant_same_revert_code]: allocate: locals 72 byte(s), call args 0 slot(s)
.104
addi $r490 $$locbase i16                ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
sw $$locbase $one i2                    ; store word
addi $r491 $r490 i55                    ; get offset to aggregate element
movi $r492 i42                          ; initialize constant into register
sb $r491 $r492 i0                       ; store byte
addi $r493 $$locbase i16                ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
move $$arg0 $r493                       ; [call: encode_allow_alias_1]: pass argument 0
move $$arg1 $$locbase                   ; [call: encode_allow_alias_1]: pass argument 1
fncall .4                               ; [call: encode_allow_alias_1]: call function
load $r495 data_NonConfigurable_0       ; load constant from data section
lw $r496 $$locbase i0                   ; load slice pointer for logging data
lw $r497 $$locbase i1                   ; load slice size for logging data
logd $zero $r495 $r496 $r497            ; log slice
load $r498 data_NonConfigurable_18      ; load constant from data section
rvrt $r498
DIFF------------------------------
.program:
.44                                     ; --- start of function: test_generic_panic_with_error_type_enum_different_variant_same_revert_code ---
move $$locbase $sp                      ; [entry init: test_generic_panic_with_error_type_enum_different_variant_same_revert_code]: set locals base register
cfei i72                                ; [entry init: test_generic_panic_with_error_type_enum_different_variant_same_revert_code]: allocate: locals 72 byte(s), call args 0 slot(s)
.104
addi $r490 $$locbase i16                ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
sw $$locbase $one i2                    ; store word
addi $r491 $r490 i55                    ; get offset to aggregate element
movi $r492 i42                          ; initialize constant into register
sb $r491 $r492 i0                       ; store byte
addi $r493 $$locbase i16                ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
move $$arg0 $r493                       ; [call: encode_allow_alias_1]: pass argument 0
move $$arg1 $$locbase                   ; [call: encode_allow_alias_1]: pass argument 1
fncall .4                               ; [call: encode_allow_alias_1]: call function
load $r495 data_NonConfigurable_0       ; load constant from data section
lw $r496 $$locbase i0                   ; load slice pointer for logging data
lw $r497 $$locbase i1                   ; load slice size for logging data
logd $zero $r495 $r496 $r497            ; log slice
load $r498 data_NonConfigurable_18      ; load constant from data section
rvrt $r498
DIFF------------------------------
.program:
.2                                      ; --- start of function: main_0 ---
pusha .2                                ; [fn init: main_0]: push all used registers to stack
move $$locbase $sp                      ; [fn init: main_0]: set locals base register
cfei i72                                ; [fn init: main_0]: allocate: locals 72 byte(s), call args 0 slot(s)
move $r2 $$reta                         ; [fn init: main_0]: save return address
.47
movi $r3 i2                             ; initialize constant into register
sw $$locbase $r3 i0                     ; store word
addi $r4 $$locbase i55                  ; get offset to aggregate element
sb $r4 $one i0                          ; store byte
addi $r5 $$locbase i56                  ; get offset to local __ptr slice
move $$arg0 $$locbase                   ; [call: encode_allow_alias_1]: pass argument 0
move $$arg1 $r5                         ; [call: encode_allow_alias_1]: pass argument 1
fncall .4                               ; [call: encode_allow_alias_1]: call function
 move $r6 $zero                          ; [call: encode_allow_alias_1]: copy returned unit value
 movi $r6 i0                             ; [call: encode_allow_alias_1]: copy returned unit value
addi $r7 $$locbase i56                  ; get offset to local __ptr slice
load $r8 data_NonConfigurable_0         ; load constant from data section
lw $r9 $$locbase i7                     ; load slice pointer for logging data
lw $r10 $$locbase i8                    ; load slice size for logging data
logd $zero $r8 $r9 $r10                 ; log slice
load $r11 data_NonConfigurable_1        ; load constant from data section
rvrt $r11
.3
cfsi i72                                ; [fn end: main_0] free: locals 72 byte(s), call args 0 slot(s)
move $$reta $r2                         ; [fn end: main_0] restore return address
popa .2                                 ; [fn end: main_0] restore all used registers
jal $zero $$reta i0                     ; [fn end: main_0] return from call
DIFF------------------------------
.program:
.2                                      ; --- start of function: main_0 ---
pusha .2                                ; [fn init: main_0]: push all used registers to stack
move $$locbase $sp                      ; [fn init: main_0]: set locals base register
cfei i72                                ; [fn init: main_0]: allocate: locals 72 byte(s), call args 0 slot(s)
.47
movi $r3 i2                             ; initialize constant into register
sw $$locbase $r3 i0                     ; store word
addi $r4 $$locbase i55                  ; get offset to aggregate element
sb $r4 $one i0                          ; store byte
addi $r5 $$locbase i56                  ; get offset to local __ptr slice
move $$arg0 $$locbase                   ; [call: encode_allow_alias_1]: pass argument 0
move $$arg1 $r5                         ; [call: encode_allow_alias_1]: pass argument 1
fncall .4                               ; [call: encode_allow_alias_1]: call function
load $r8 data_NonConfigurable_0         ; load constant from data section
lw $r9 $$locbase i7                     ; load slice pointer for logging data
lw $r10 $$locbase i8                    ; load slice size for logging data
logd $zero $r8 $r9 $r10                 ; log slice
load $r11 data_NonConfigurable_1        ; load constant from data section
rvrt $r11
DIFF------------------------------
.program:
.2                                      ; --- start of function: main_0 ---
pusha .2                                ; [fn init: main_0]: push all used registers to stack
move $$locbase $sp                      ; [fn init: main_0]: set locals base register
cfei i72                                ; [fn init: main_0]: allocate: locals 72 byte(s), call args 0 slot(s)
.47
movi $r3 i2                             ; initialize constant into register
sw $$locbase $r3 i0                     ; store word
addi $r4 $$locbase i55                  ; get offset to aggregate element
sb $r4 $one i0                          ; store byte
addi $r5 $$locbase i56                  ; get offset to local __ptr slice
move $$arg0 $$locbase                   ; [call: encode_allow_alias_1]: pass argument 0
move $$arg1 $r5                         ; [call: encode_allow_alias_1]: pass argument 1
fncall .4                               ; [call: encode_allow_alias_1]: call function
load $r8 data_NonConfigurable_0         ; load constant from data section
lw $r9 $$locbase i7                     ; load slice pointer for logging data
lw $r10 $$locbase i8                    ; load slice size for logging data
logd $zero $r8 $r9 $r10                 ; log slice
load $r11 data_NonConfigurable_1        ; load constant from data section
rvrt $r11
DIFF------------------------------
.program:
.2                                      ; --- start of function: main_0 ---
pusha .2                                ; [fn init: main_0]: push all used registers to stack
move $$locbase $sp                      ; [fn init: main_0]: set locals base register
cfei i72                                ; [fn init: main_0]: allocate: locals 72 byte(s), call args 0 slot(s)
.47
movi $r3 i2                             ; initialize constant into register
sw $$locbase $r3 i0                     ; store word
addi $r4 $$locbase i55                  ; get offset to aggregate element
sb $r4 $one i0                          ; store byte
addi $r5 $$locbase i56                  ; get offset to local __ptr slice
move $$arg0 $$locbase                   ; [call: encode_allow_alias_1]: pass argument 0
move $$arg1 $r5                         ; [call: encode_allow_alias_1]: pass argument 1
fncall .4                               ; [call: encode_allow_alias_1]: call function
load $r8 data_NonConfigurable_0         ; load constant from data section
lw $r9 $$locbase i7                     ; load slice pointer for logging data
lw $r10 $$locbase i8                    ; load slice size for logging data
logd $zero $r8 $r9 $r10                 ; log slice
load $r11 data_NonConfigurable_1        ; load constant from data section
rvrt $r11
DIFF------------------------------
.program:
.4                                      ; --- start of function: encode_allow_alias_1 ---
pusha .4                                ; [fn init: encode_allow_alias_1]: push all used registers to stack
move $$locbase $sp                      ; [fn init: encode_allow_alias_1]: set locals base register
cfei i1520                              ; [fn init: encode_allow_alias_1]: allocate: locals 1520 byte(s), call args 0 slot(s)
move $r12 $$arg0                        ; [fn init: encode_allow_alias_1]: copy argument 0 (item)
move $r13 $$arg1                        ; [fn init: encode_allow_alias_1]: copy argument 1 (__ret_value)
move $r14 $$reta                        ; [fn init: encode_allow_alias_1]: save return address
.48
 move $r15 $zero                         ; move parameter from branch to block argument
 jnzi $zero .49
 movi $r15 i0                            ; move parameter from branch to block argument
 
ji  .50
.49
 move $r15 $one                          ; move parameter from branch to block argument
 movi $r15 i1                            ; move parameter from branch to block argument
ji  .50
.50
move $r18 $r15                          ; move parameter from branch to block argument
 move $r19 $r18                          ; move parameter from branch to block argument
 jnzi $r18 .51
 move $r19 $r15                          ; move parameter from branch to block argument
 jnzi $r15 .51
ji  .52
.51
 move $r19 $one                          ; move parameter from branch to block argument
 movi $r19 i1                            ; move parameter from branch to block argument
ji  .52
.52
move $r22 $r19                          ; move parameter from branch to block argument
 move $r23 $r22                          ; move parameter from branch to block argument
 jnzi $r22 .53
 move $r23 $r19                          ; move parameter from branch to block argument
 jnzi $r19 .53
ji  .54
.53
 move $r23 $zero                         ; move parameter from branch to block argument
 movi $r23 i0                            ; move parameter from branch to block argument
ji  .54
.54
move $r26 $r23                          ; move parameter from branch to block argument
 jnzi $r26 .55
 jnzi $r23 .55
ji  .56
.56
addi $r27 $$locbase i456                ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r27                        ; [call: new_28]: pass argument 0
fncall .10                              ; [call: new_28]: call function
 move $r28 $zero                         ; [call: new_28]: copy returned unit value
 movi $r28 i0                            ; [call: new_28]: copy returned unit value
addi $r29 $$locbase i1336               ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
mcpi $r29 $r12 i56                      ; copy memory
addi $r30 $$locbase i928                ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r30 $r27 i24                      ; copy memory
addi $r31 $$locbase i1336               ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
addi $r32 $$locbase i208                ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
mcpi $r32 $r31 i56                      ; copy memory
addi $r33 $$locbase i208                ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
lw $r34 $$locbase i26                   ; load word
eq $r35 $r34 $zero
jnzi $r35 .57
ji  .58
.58
addi $r36 $$locbase i208                ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
lw $r37 $$locbase i26                   ; load word
eq $r38 $r37 $one
jnzi $r38 .59
ji  .60
.60
addi $r39 $$locbase i208                ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
lw $r40 $$locbase i26                   ; load word
movi $r41 i2                            ; initialize constant into register
eq $r42 $r40 $r41
jnzi $r42 .61
ji  .62
.62
addi $r43 $$locbase i208                ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
lw $r44 $$locbase i26                   ; load word
movi $r45 i3                            ; initialize constant into register
eq $r46 $r44 $r45
jnzi $r46 .63
ji  .64
.64
addi $r47 $$locbase i208                ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
lw $r48 $$locbase i26                   ; load word
movi $r49 i4                            ; initialize constant into register
eq $r50 $r48 $r49
jnzi $r50 .65
ji  .66
.66
load $r51 data_NonConfigurable_2        ; load constant from data section
rvrt $r51
.65
addi $r52 $$locbase i208                ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
addi $r53 $r52 i8                       ; get offset to aggregate element
addi $r54 $$locbase i1472               ; get offset to local __ptr [slice; 3]
mcpi $r54 $r53 i48                      ; copy memory
addi $r55 $$locbase i928                ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r56 $$locbase i688                ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r56 $r55 i24                      ; copy memory
addi $r57 $$locbase i408                ; get offset to local __ptr { { ptr, u64, u64 } }
movi $r58 i4                            ; initialize constant into register
 move $$arg0 $r58                        ; [call: abi_encode_20]: pass argument 0
 movi $$arg0 i4                          ; [call: abi_encode_20]: pass argument 0
move $$arg1 $r56                        ; [call: abi_encode_20]: pass argument 1
move $$arg2 $r57                        ; [call: abi_encode_20]: pass argument 2
fncall .6                               ; [call: abi_encode_20]: call function
 move $r59 $zero                         ; [call: abi_encode_20]: copy returned unit value
 movi $r59 i0                            ; [call: abi_encode_20]: copy returned unit value
addi $r60 $$locbase i1264               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r60 $r57 i24                      ; copy memory
addi $r61 $$locbase i1472               ; get offset to local __ptr [slice; 3]
addi $r62 $$locbase i1264               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r63 $$locbase i1408               ; get offset to local __ptr [slice; 3]
mcpi $r63 $r61 i48                      ; copy memory
addi $r64 $$locbase i1024               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r64 $r62 i24                      ; copy memory
addi $r65 $$locbase i1024               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r66 $$locbase i1096               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r66 $r65 i24                      ; copy memory
 move $r67 $zero                         ; move parameter from branch to block argument
 movi $r67 i0                            ; move parameter from branch to block argument
ji  .67
.67
move $r69 $r67                          ; move parameter from branch to block argument
movi $r70 i3                            ; initialize constant into register
 lt $r71 $r69 $r70
 lt $r71 $r67 $r70
jnzi $r71 .68
ji  .69
.69
addi $r72 $$locbase i1096               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r73 $$locbase i1288               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r73 $r72 i24                      ; copy memory
addi $r74 $$locbase i1288               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r75 $$locbase i776                ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r75 $r74 i24                      ; copy memory
move $r76 $r75                          ; move parameter from branch to block argument
ji  .70
.68
addi $r77 $$locbase i1408               ; get offset to local __ptr [slice; 3]
movi $r78 i16                           ; get array element size
 mul $r79 $r69 $r78                      ; get offset to array element
 muli $r79 $r69 i16                      ; get offset to array element
add $r79 $r77 $r79                      ; add array element offset to array base
addi $r80 $$locbase i1096               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r81 $$locbase i712                ; get offset to local __ptr slice
mcpi $r81 $r79 i16                      ; copy memory
addi $r82 $$locbase i728                ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r82 $r80 i24                      ; copy memory
addi $r83 $$locbase i432                ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r81                        ; [call: abi_encode_26]: pass argument 0
move $$arg1 $r82                        ; [call: abi_encode_26]: pass argument 1
move $$arg2 $r83                        ; [call: abi_encode_26]: pass argument 2
fncall .8                               ; [call: abi_encode_26]: call function
 move $r84 $zero                         ; [call: abi_encode_26]: copy returned unit value
 movi $r84 i0                            ; [call: abi_encode_26]: copy returned unit value
addi $r85 $$locbase i1096               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r85 $r83 i24                      ; copy memory
 add $r86 $r69 $one
 addi $r86 $r69 i1
move $r67 $r86                          ; move parameter from branch to block argument
ji  .67
.63
addi $r88 $$locbase i208                ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
addi $r89 $r88 i40                      ; get offset to aggregate element
addi $r90 $$locbase i1456               ; get offset to local __ptr { u64, u64 }
mcpi $r90 $r89 i16                      ; copy memory
addi $r91 $$locbase i928                ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r92 $$locbase i616                ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r92 $r91 i24                      ; copy memory
addi $r93 $$locbase i336                ; get offset to local __ptr { { ptr, u64, u64 } }
movi $r94 i3                            ; initialize constant into register
 move $$arg0 $r94                        ; [call: abi_encode_20]: pass argument 0
 movi $$arg0 i3                          ; [call: abi_encode_20]: pass argument 0
move $$arg1 $r92                        ; [call: abi_encode_20]: pass argument 1
move $$arg2 $r93                        ; [call: abi_encode_20]: pass argument 2
fncall .6                               ; [call: abi_encode_20]: call function
 move $r95 $zero                         ; [call: abi_encode_20]: copy returned unit value
 movi $r95 i0                            ; [call: abi_encode_20]: copy returned unit value
addi $r96 $$locbase i1216               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r96 $r93 i24                      ; copy memory
addi $r97 $$locbase i1456               ; get offset to local __ptr { u64, u64 }
addi $r98 $$locbase i1216               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r99 $$locbase i1392               ; get offset to local __ptr { u64, u64 }
mcpi $r99 $r97 i16                      ; copy memory
addi $r100 $$locbase i1000              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r100 $r98 i24                     ; copy memory
addi $r101 $$locbase i1392              ; get offset to local __ptr { u64, u64 }
lw $r102 $$locbase i174                 ; load word
addi $r103 $$locbase i1000              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r104 $$locbase i640               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r104 $r103 i24                    ; copy memory
addi $r105 $$locbase i360               ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r102                       ; [call: abi_encode_20]: pass argument 0
move $$arg1 $r104                       ; [call: abi_encode_20]: pass argument 1
move $$arg2 $r105                       ; [call: abi_encode_20]: pass argument 2
fncall .6                               ; [call: abi_encode_20]: call function
 move $r106 $zero                        ; [call: abi_encode_20]: copy returned unit value
 movi $r106 i0                           ; [call: abi_encode_20]: copy returned unit value
addi $r107 $$locbase i1072              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r107 $r105 i24                    ; copy memory
addi $r108 $$locbase i1392              ; get offset to local __ptr { u64, u64 }
addi $r109 $r108 i8                     ; get offset to aggregate element
lw $r110 $$locbase i175                 ; load word
addi $r111 $$locbase i1072              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r112 $$locbase i664               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r112 $r111 i24                    ; copy memory
addi $r113 $$locbase i384               ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r110                       ; [call: abi_encode_20]: pass argument 0
move $$arg1 $r112                       ; [call: abi_encode_20]: pass argument 1
move $$arg2 $r113                       ; [call: abi_encode_20]: pass argument 2
fncall .6                               ; [call: abi_encode_20]: call function
 move $r114 $zero                        ; [call: abi_encode_20]: copy returned unit value
 movi $r114 i0                           ; [call: abi_encode_20]: copy returned unit value
addi $r115 $$locbase i1144              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r115 $r113 i24                    ; copy memory
addi $r116 $$locbase i1144              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r117 $$locbase i1240              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r117 $r116 i24                    ; copy memory
addi $r118 $$locbase i1240              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r119 $$locbase i776               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r119 $r118 i24                    ; copy memory
move $r76 $r119                         ; move parameter from branch to block argument
ji  .70
.70
move $r122 $r76                         ; move parameter from branch to block argument
addi $r123 $$locbase i800               ; get offset to local __ptr { { ptr, u64, u64 } }
 mcpi $r123 $r122 i24                    ; copy memory
 mcpi $r123 $r76 i24                     ; copy memory
move $r124 $r123                        ; move parameter from branch to block argument
ji  .71
.61
addi $r125 $$locbase i208               ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
addi $r126 $r125 i55                    ; get offset to aggregate element
lb $r127 $r126 i0                       ; load byte
addi $r128 $$locbase i928               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r129 $$locbase i592               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r129 $r128 i24                    ; copy memory
addi $r130 $$locbase i312               ; get offset to local __ptr { { ptr, u64, u64 } }
movi $r131 i2                           ; initialize constant into register
 move $$arg0 $r131                       ; [call: abi_encode_20]: pass argument 0
 movi $$arg0 i2                          ; [call: abi_encode_20]: pass argument 0
move $$arg1 $r129                       ; [call: abi_encode_20]: pass argument 1
move $$arg2 $r130                       ; [call: abi_encode_20]: pass argument 2
fncall .6                               ; [call: abi_encode_20]: call function
 move $r132 $zero                        ; [call: abi_encode_20]: copy returned unit value
 movi $r132 i0                           ; [call: abi_encode_20]: copy returned unit value
addi $r133 $$locbase i1168              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r133 $r130 i24                    ; copy memory
addi $r134 $$locbase i1168              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r135 $$locbase i976               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r135 $r134 i24                    ; copy memory
addi $r136 $$locbase i520               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r137 $$locbase i976               ; get offset to local __ptr { { ptr, u64, u64 } }
move $r138 $r137                        ; return value from ASM block with return register buffer
addi $r139 $$locbase i48                ; get offset to local __ptr { ptr, u64, u64 }
 mcpi $r139 $r138 i24                    ; copy memory
 mcpi $r139 $r137 i24                    ; copy memory
addi $r140 $$locbase i136               ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r140 $r139 i24                    ; copy memory
lw $r141 $$locbase i17                  ; load word
addi $r142 $r140 i8                     ; get offset to aggregate element
lw $r143 $$locbase i18                  ; load word
addi $r144 $r140 i16                    ; get offset to aggregate element
lw $r145 $$locbase i19                  ; load word
 add $r146 $r145 $one
 addi $r146 $r145 i1
gt $r147 $r146 $r143
move $r148 $r141                        ; move parameter from branch to block argument
move $r149 $r143                        ; move parameter from branch to block argument
jnzi $r147 .72
ji  .73
.72
movi $r150 i2                           ; initialize constant into register
 mul $r151 $r143 $r150
 add $r152 $r151 $one
 muli $r151 $r143 i2
 addi $r152 $r151 i1
aloc $r152
mcp $hp $r141 $r145
move $r153 $hp                          ; return value from ASM block with return register hp
 move $r148 $r153                        ; move parameter from branch to block argument
 move $r148 $hp                          ; move parameter from branch to block argument
move $r149 $r152                        ; move parameter from branch to block argument
ji  .73
.73
move $r157 $r148                        ; move parameter from branch to block argument
move $r159 $r149                        ; move parameter from branch to block argument
 add $r160 $r157 $r145
 add $r160 $r148 $r145
sb $r160 $r127 i0                       ; store byte
addi $r161 $$locbase i184               ; get offset to local __ptr { ptr, u64, u64 }
sw $$locbase $r157 i23                  ; store word
addi $r162 $r161 i8                     ; get offset to aggregate element
sw $$locbase $r159 i24                  ; store word
addi $r163 $r161 i16                    ; get offset to aggregate element
sw $$locbase $r146 i25                  ; store word
move $r164 $r161                        ; return value from ASM block with return register buffer
addi $r165 $$locbase i72                ; get offset to local __ptr { ptr, u64, u64 }
 mcpi $r165 $r164 i24                    ; copy memory
 mcpi $r165 $r161 i24                    ; copy memory
mcpi $r136 $r165 i24                    ; copy memory
addi $r166 $$locbase i1192              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r166 $r136 i24                    ; copy memory
addi $r167 $$locbase i1192              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r168 $$locbase i800               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r168 $r167 i24                    ; copy memory
move $r124 $r168                        ; move parameter from branch to block argument
ji  .71
.71
move $r171 $r124                        ; move parameter from branch to block argument
addi $r172 $$locbase i824               ; get offset to local __ptr { { ptr, u64, u64 } }
 mcpi $r172 $r171 i24                    ; copy memory
 mcpi $r172 $r124 i24                    ; copy memory
move $r173 $r172                        ; move parameter from branch to block argument
ji  .74
.59
addi $r174 $$locbase i208               ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
addi $r175 $r174 i55                    ; get offset to aggregate element
lb $r176 $r175 i0                       ; load byte
addi $r177 $$locbase i928               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r178 $$locbase i568               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r178 $r177 i24                    ; copy memory
addi $r179 $$locbase i288               ; get offset to local __ptr { { ptr, u64, u64 } }
 move $$arg0 $one                        ; [call: abi_encode_20]: pass argument 0
 movi $$arg0 i1                          ; [call: abi_encode_20]: pass argument 0
move $$arg1 $r178                       ; [call: abi_encode_20]: pass argument 1
move $$arg2 $r179                       ; [call: abi_encode_20]: pass argument 2
fncall .6                               ; [call: abi_encode_20]: call function
 move $r180 $zero                        ; [call: abi_encode_20]: copy returned unit value
 movi $r180 i0                           ; [call: abi_encode_20]: copy returned unit value
addi $r181 $$locbase i1048              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r181 $r179 i24                    ; copy memory
addi $r182 $$locbase i1048              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r183 $$locbase i952               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r183 $r182 i24                    ; copy memory
addi $r184 $$locbase i496               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r185 $$locbase i952               ; get offset to local __ptr { { ptr, u64, u64 } }
move $r186 $r185                        ; return value from ASM block with return register buffer
 mcpi $$locbase $r186 i24                ; copy memory
 mcpi $$locbase $r185 i24                ; copy memory
addi $r187 $$locbase i112               ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r187 $$locbase i24                ; copy memory
lw $r188 $$locbase i14                  ; load word
addi $r189 $r187 i8                     ; get offset to aggregate element
lw $r190 $$locbase i15                  ; load word
addi $r191 $r187 i16                    ; get offset to aggregate element
lw $r192 $$locbase i16                  ; load word
 add $r193 $r192 $one
 addi $r193 $r192 i1
gt $r194 $r193 $r190
move $r195 $r188                        ; move parameter from branch to block argument
move $r196 $r190                        ; move parameter from branch to block argument
jnzi $r194 .75
ji  .76
.75
movi $r197 i2                           ; initialize constant into register
 mul $r198 $r190 $r197
 add $r199 $r198 $one
 muli $r198 $r190 i2
 addi $r199 $r198 i1
aloc $r199
mcp $hp $r188 $r192
move $r200 $hp                          ; return value from ASM block with return register hp
 move $r195 $r200                        ; move parameter from branch to block argument
 move $r195 $hp                          ; move parameter from branch to block argument
move $r196 $r199                        ; move parameter from branch to block argument
ji  .76
.76
move $r204 $r195                        ; move parameter from branch to block argument
move $r206 $r196                        ; move parameter from branch to block argument
 add $r207 $r204 $r192
 add $r207 $r195 $r192
sb $r207 $r176 i0                       ; store byte
addi $r208 $$locbase i160               ; get offset to local __ptr { ptr, u64, u64 }
sw $$locbase $r204 i20                  ; store word
addi $r209 $r208 i8                     ; get offset to aggregate element
sw $$locbase $r206 i21                  ; store word
addi $r210 $r208 i16                    ; get offset to aggregate element
sw $$locbase $r193 i22                  ; store word
move $r211 $r208                        ; return value from ASM block with return register buffer
addi $r212 $$locbase i24                ; get offset to local __ptr { ptr, u64, u64 }
 mcpi $r212 $r211 i24                    ; copy memory
 mcpi $r212 $r208 i24                    ; copy memory
mcpi $r184 $r212 i24                    ; copy memory
addi $r213 $$locbase i1120              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r213 $r184 i24                    ; copy memory
addi $r214 $$locbase i1120              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r215 $$locbase i824               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r215 $r214 i24                    ; copy memory
move $r173 $r215                        ; move parameter from branch to block argument
ji  .74
.74
move $r218 $r173                        ; move parameter from branch to block argument
addi $r219 $$locbase i848               ; get offset to local __ptr { { ptr, u64, u64 } }
 mcpi $r219 $r218 i24                    ; copy memory
 mcpi $r219 $r173 i24                    ; copy memory
move $r220 $r219                        ; move parameter from branch to block argument
ji  .77
.57
addi $r221 $$locbase i928               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r222 $$locbase i544               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r222 $r221 i24                    ; copy memory
addi $r223 $$locbase i264               ; get offset to local __ptr { { ptr, u64, u64 } }
 move $$arg0 $zero                       ; [call: abi_encode_20]: pass argument 0
 movi $$arg0 i0                          ; [call: abi_encode_20]: pass argument 0
move $$arg1 $r222                       ; [call: abi_encode_20]: pass argument 1
move $$arg2 $r223                       ; [call: abi_encode_20]: pass argument 2
fncall .6                               ; [call: abi_encode_20]: call function
 move $r224 $zero                        ; [call: abi_encode_20]: copy returned unit value
 movi $r224 i0                           ; [call: abi_encode_20]: copy returned unit value
addi $r225 $$locbase i848               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r225 $r223 i24                    ; copy memory
move $r220 $r225                        ; move parameter from branch to block argument
ji  .77
.77
move $r228 $r220                        ; move parameter from branch to block argument
addi $r229 $$locbase i1312              ; get offset to local __ptr { { ptr, u64, u64 } }
 mcpi $r229 $r228 i24                    ; copy memory
 mcpi $r229 $r220 i24                    ; copy memory
addi $r230 $$locbase i1312              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r231 $$locbase i904               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r231 $r230 i24                    ; copy memory
addi $r232 $$locbase i904               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r233 $$locbase i752               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r233 $r232 i24                    ; copy memory
addi $r234 $$locbase i480               ; get offset to local __ptr slice
move $$arg0 $r233                       ; [call: as_raw_slice_29]: pass argument 0
move $$arg1 $r234                       ; [call: as_raw_slice_29]: pass argument 1
fncall .12                              ; [call: as_raw_slice_29]: call function
 move $r235 $zero                        ; [call: as_raw_slice_29]: copy returned unit value
 movi $r235 i0                           ; [call: as_raw_slice_29]: copy returned unit value
addi $r236 $$locbase i872               ; get offset to local __ptr slice
mcpi $r236 $r234 i16                    ; copy memory
move $r237 $r236                        ; move parameter from branch to block argument
ji  .78
.55
addi $r238 $$locbase i888               ; get offset to local __ptr { __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }, u64 }
sw $$locbase $r12 i111                  ; store word
addi $r239 $r238 i8                     ; get offset to aggregate element
movi $r240 i56                          ; initialize constant into register
sw $$locbase $r240 i112                 ; store word
addi $r241 $$locbase i96                ; get offset to local __ptr { __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }, u64 }
mcpi $r241 $r238 i16                    ; copy memory
addi $r242 $$locbase i872               ; get offset to local __ptr slice
mcpi $r242 $r241 i16                    ; copy memory
move $r237 $r242                        ; move parameter from branch to block argument
ji  .78
.78
move $r245 $r237                        ; move parameter from branch to block argument
 mcpi $r13 $r245 i16                     ; copy memory
 mcpi $r13 $r237 i16                     ; copy memory
ji  .5
.5
cfsi i1520                              ; [fn end: encode_allow_alias_1] free: locals 1520 byte(s), call args 0 slot(s)
move $$reta $r14                        ; [fn end: encode_allow_alias_1] restore return address
popa .4                                 ; [fn end: encode_allow_alias_1] restore all used registers
jal $zero $$reta i0                     ; [fn end: encode_allow_alias_1] return from call
DIFF------------------------------
.program:
.4                                      ; --- start of function: encode_allow_alias_1 ---
pusha .4                                ; [fn init: encode_allow_alias_1]: push all used registers to stack
move $$locbase $sp                      ; [fn init: encode_allow_alias_1]: set locals base register
cfei i1520                              ; [fn init: encode_allow_alias_1]: allocate: locals 1520 byte(s), call args 0 slot(s)
move $r12 $$arg0                        ; [fn init: encode_allow_alias_1]: copy argument 0 (item)
move $r13 $$arg1                        ; [fn init: encode_allow_alias_1]: copy argument 1 (__ret_value)
move $r14 $$reta                        ; [fn init: encode_allow_alias_1]: save return address
.48
movi $r15 i0                            ; move parameter from branch to block argument
.50
 move $r19 $r15                          ; move parameter from branch to block argument
 jnzi $r15 .51
 movi $r19 i0                            ; move parameter from branch to block argument
 
ji  .52
.51
movi $r19 i1                            ; move parameter from branch to block argument
.52
move $r23 $r19                          ; move parameter from branch to block argument
jnzi $r19 .53
ji  .54
.53
movi $r23 i0                            ; move parameter from branch to block argument
.54
jnzi $r23 .55
.56
addi $r27 $$locbase i456                ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r27                        ; [call: new_28]: pass argument 0
fncall .10                              ; [call: new_28]: call function
addi $r29 $$locbase i1336               ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
mcpi $r29 $r12 i56                      ; copy memory
addi $r30 $$locbase i928                ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r30 $r27 i24                      ; copy memory
addi $r31 $$locbase i1336               ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
addi $r32 $$locbase i208                ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
mcpi $r32 $r31 i56                      ; copy memory
lw $r34 $$locbase i26                   ; load word
eq $r35 $r34 $zero
jnzi $r35 .57
.58
lw $r37 $$locbase i26                   ; load word
eq $r38 $r37 $one
jnzi $r38 .59
.60
lw $r40 $$locbase i26                   ; load word
movi $r41 i2                            ; initialize constant into register
eq $r42 $r40 $r41
jnzi $r42 .61
.62
lw $r44 $$locbase i26                   ; load word
movi $r45 i3                            ; initialize constant into register
eq $r46 $r44 $r45
jnzi $r46 .63
.64
lw $r48 $$locbase i26                   ; load word
movi $r49 i4                            ; initialize constant into register
eq $r50 $r48 $r49
jnzi $r50 .65
.66
load $r51 data_NonConfigurable_2        ; load constant from data section
rvrt $r51
.65
addi $r52 $$locbase i208                ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
addi $r53 $r52 i8                       ; get offset to aggregate element
addi $r54 $$locbase i1472               ; get offset to local __ptr [slice; 3]
mcpi $r54 $r53 i48                      ; copy memory
addi $r55 $$locbase i928                ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r56 $$locbase i688                ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r56 $r55 i24                      ; copy memory
addi $r57 $$locbase i408                ; get offset to local __ptr { { ptr, u64, u64 } }
movi $$arg0 i4                          ; [call: abi_encode_20]: pass argument 0
move $$arg1 $r56                        ; [call: abi_encode_20]: pass argument 1
move $$arg2 $r57                        ; [call: abi_encode_20]: pass argument 2
fncall .6                               ; [call: abi_encode_20]: call function
addi $r60 $$locbase i1264               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r60 $r57 i24                      ; copy memory
addi $r61 $$locbase i1472               ; get offset to local __ptr [slice; 3]
addi $r62 $$locbase i1264               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r63 $$locbase i1408               ; get offset to local __ptr [slice; 3]
mcpi $r63 $r61 i48                      ; copy memory
addi $r64 $$locbase i1024               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r64 $r62 i24                      ; copy memory
addi $r65 $$locbase i1024               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r66 $$locbase i1096               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r66 $r65 i24                      ; copy memory
movi $r67 i0                            ; move parameter from branch to block argument
.67
move $r69 $r67                          ; move parameter from branch to block argument
movi $r70 i3                            ; initialize constant into register
lt $r71 $r67 $r70
jnzi $r71 .68
.69
addi $r72 $$locbase i1096               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r73 $$locbase i1288               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r73 $r72 i24                      ; copy memory
addi $r74 $$locbase i1288               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r75 $$locbase i776                ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r75 $r74 i24                      ; copy memory
move $r76 $r75                          ; move parameter from branch to block argument
ji  .70
.68
addi $r77 $$locbase i1408               ; get offset to local __ptr [slice; 3]
muli $r79 $r69 i16                      ; get offset to array element
add $r79 $r77 $r79                      ; add array element offset to array base
addi $r80 $$locbase i1096               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r81 $$locbase i712                ; get offset to local __ptr slice
mcpi $r81 $r79 i16                      ; copy memory
addi $r82 $$locbase i728                ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r82 $r80 i24                      ; copy memory
addi $r83 $$locbase i432                ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r81                        ; [call: abi_encode_26]: pass argument 0
move $$arg1 $r82                        ; [call: abi_encode_26]: pass argument 1
move $$arg2 $r83                        ; [call: abi_encode_26]: pass argument 2
fncall .8                               ; [call: abi_encode_26]: call function
addi $r85 $$locbase i1096               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r85 $r83 i24                      ; copy memory
addi $r86 $r69 i1
move $r67 $r86                          ; move parameter from branch to block argument
ji  .67
.63
addi $r88 $$locbase i208                ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
addi $r89 $r88 i40                      ; get offset to aggregate element
addi $r90 $$locbase i1456               ; get offset to local __ptr { u64, u64 }
mcpi $r90 $r89 i16                      ; copy memory
addi $r91 $$locbase i928                ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r92 $$locbase i616                ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r92 $r91 i24                      ; copy memory
addi $r93 $$locbase i336                ; get offset to local __ptr { { ptr, u64, u64 } }
movi $$arg0 i3                          ; [call: abi_encode_20]: pass argument 0
move $$arg1 $r92                        ; [call: abi_encode_20]: pass argument 1
move $$arg2 $r93                        ; [call: abi_encode_20]: pass argument 2
fncall .6                               ; [call: abi_encode_20]: call function
addi $r96 $$locbase i1216               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r96 $r93 i24                      ; copy memory
addi $r97 $$locbase i1456               ; get offset to local __ptr { u64, u64 }
addi $r98 $$locbase i1216               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r99 $$locbase i1392               ; get offset to local __ptr { u64, u64 }
mcpi $r99 $r97 i16                      ; copy memory
addi $r100 $$locbase i1000              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r100 $r98 i24                     ; copy memory
lw $r102 $$locbase i174                 ; load word
addi $r103 $$locbase i1000              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r104 $$locbase i640               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r104 $r103 i24                    ; copy memory
addi $r105 $$locbase i360               ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r102                       ; [call: abi_encode_20]: pass argument 0
move $$arg1 $r104                       ; [call: abi_encode_20]: pass argument 1
move $$arg2 $r105                       ; [call: abi_encode_20]: pass argument 2
fncall .6                               ; [call: abi_encode_20]: call function
addi $r107 $$locbase i1072              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r107 $r105 i24                    ; copy memory
lw $r110 $$locbase i175                 ; load word
addi $r111 $$locbase i1072              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r112 $$locbase i664               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r112 $r111 i24                    ; copy memory
addi $r113 $$locbase i384               ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r110                       ; [call: abi_encode_20]: pass argument 0
move $$arg1 $r112                       ; [call: abi_encode_20]: pass argument 1
move $$arg2 $r113                       ; [call: abi_encode_20]: pass argument 2
fncall .6                               ; [call: abi_encode_20]: call function
addi $r115 $$locbase i1144              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r115 $r113 i24                    ; copy memory
addi $r116 $$locbase i1144              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r117 $$locbase i1240              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r117 $r116 i24                    ; copy memory
addi $r118 $$locbase i1240              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r119 $$locbase i776               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r119 $r118 i24                    ; copy memory
move $r76 $r119                         ; move parameter from branch to block argument
.70
addi $r123 $$locbase i800               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r123 $r76 i24                     ; copy memory
move $r124 $r123                        ; move parameter from branch to block argument
ji  .71
.61
addi $r125 $$locbase i208               ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
addi $r126 $r125 i55                    ; get offset to aggregate element
lb $r127 $r126 i0                       ; load byte
addi $r128 $$locbase i928               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r129 $$locbase i592               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r129 $r128 i24                    ; copy memory
addi $r130 $$locbase i312               ; get offset to local __ptr { { ptr, u64, u64 } }
movi $$arg0 i2                          ; [call: abi_encode_20]: pass argument 0
move $$arg1 $r129                       ; [call: abi_encode_20]: pass argument 1
move $$arg2 $r130                       ; [call: abi_encode_20]: pass argument 2
fncall .6                               ; [call: abi_encode_20]: call function
addi $r133 $$locbase i1168              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r133 $r130 i24                    ; copy memory
addi $r134 $$locbase i1168              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r135 $$locbase i976               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r135 $r134 i24                    ; copy memory
addi $r136 $$locbase i520               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r137 $$locbase i976               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r139 $$locbase i48                ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r139 $r137 i24                    ; copy memory
addi $r140 $$locbase i136               ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r140 $r139 i24                    ; copy memory
lw $r141 $$locbase i17                  ; load word
lw $r143 $$locbase i18                  ; load word
lw $r145 $$locbase i19                  ; load word
addi $r146 $r145 i1
gt $r147 $r146 $r143
move $r148 $r141                        ; move parameter from branch to block argument
move $r149 $r143                        ; move parameter from branch to block argument
jnzi $r147 .72
ji  .73
.72
muli $r151 $r143 i2
addi $r152 $r151 i1
aloc $r152
mcp $hp $r141 $r145
move $r148 $hp                          ; move parameter from branch to block argument
move $r149 $r152                        ; move parameter from branch to block argument
.73
move $r157 $r148                        ; move parameter from branch to block argument
move $r159 $r149                        ; move parameter from branch to block argument
add $r160 $r148 $r145
sb $r160 $r127 i0                       ; store byte
addi $r161 $$locbase i184               ; get offset to local __ptr { ptr, u64, u64 }
sw $$locbase $r157 i23                  ; store word
sw $$locbase $r159 i24                  ; store word
sw $$locbase $r146 i25                  ; store word
addi $r165 $$locbase i72                ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r165 $r161 i24                    ; copy memory
mcpi $r136 $r165 i24                    ; copy memory
addi $r166 $$locbase i1192              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r166 $r136 i24                    ; copy memory
addi $r167 $$locbase i1192              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r168 $$locbase i800               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r168 $r167 i24                    ; copy memory
move $r124 $r168                        ; move parameter from branch to block argument
.71
addi $r172 $$locbase i824               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r172 $r124 i24                    ; copy memory
move $r173 $r172                        ; move parameter from branch to block argument
ji  .74
.59
addi $r174 $$locbase i208               ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
addi $r175 $r174 i55                    ; get offset to aggregate element
lb $r176 $r175 i0                       ; load byte
addi $r177 $$locbase i928               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r178 $$locbase i568               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r178 $r177 i24                    ; copy memory
addi $r179 $$locbase i288               ; get offset to local __ptr { { ptr, u64, u64 } }
movi $$arg0 i1                          ; [call: abi_encode_20]: pass argument 0
move $$arg1 $r178                       ; [call: abi_encode_20]: pass argument 1
move $$arg2 $r179                       ; [call: abi_encode_20]: pass argument 2
fncall .6                               ; [call: abi_encode_20]: call function
addi $r181 $$locbase i1048              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r181 $r179 i24                    ; copy memory
addi $r182 $$locbase i1048              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r183 $$locbase i952               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r183 $r182 i24                    ; copy memory
addi $r184 $$locbase i496               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r185 $$locbase i952               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $$locbase $r185 i24                ; copy memory
addi $r187 $$locbase i112               ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r187 $$locbase i24                ; copy memory
lw $r188 $$locbase i14                  ; load word
lw $r190 $$locbase i15                  ; load word
lw $r192 $$locbase i16                  ; load word
addi $r193 $r192 i1
gt $r194 $r193 $r190
move $r195 $r188                        ; move parameter from branch to block argument
move $r196 $r190                        ; move parameter from branch to block argument
jnzi $r194 .75
ji  .76
.75
muli $r198 $r190 i2
addi $r199 $r198 i1
aloc $r199
mcp $hp $r188 $r192
move $r195 $hp                          ; move parameter from branch to block argument
move $r196 $r199                        ; move parameter from branch to block argument
.76
move $r204 $r195                        ; move parameter from branch to block argument
move $r206 $r196                        ; move parameter from branch to block argument
add $r207 $r195 $r192
sb $r207 $r176 i0                       ; store byte
addi $r208 $$locbase i160               ; get offset to local __ptr { ptr, u64, u64 }
sw $$locbase $r204 i20                  ; store word
sw $$locbase $r206 i21                  ; store word
sw $$locbase $r193 i22                  ; store word
addi $r212 $$locbase i24                ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r212 $r208 i24                    ; copy memory
mcpi $r184 $r212 i24                    ; copy memory
addi $r213 $$locbase i1120              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r213 $r184 i24                    ; copy memory
addi $r214 $$locbase i1120              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r215 $$locbase i824               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r215 $r214 i24                    ; copy memory
move $r173 $r215                        ; move parameter from branch to block argument
.74
addi $r219 $$locbase i848               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r219 $r173 i24                    ; copy memory
move $r220 $r219                        ; move parameter from branch to block argument
ji  .77
.57
addi $r221 $$locbase i928               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r222 $$locbase i544               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r222 $r221 i24                    ; copy memory
addi $r223 $$locbase i264               ; get offset to local __ptr { { ptr, u64, u64 } }
movi $$arg0 i0                          ; [call: abi_encode_20]: pass argument 0
move $$arg1 $r222                       ; [call: abi_encode_20]: pass argument 1
move $$arg2 $r223                       ; [call: abi_encode_20]: pass argument 2
fncall .6                               ; [call: abi_encode_20]: call function
addi $r225 $$locbase i848               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r225 $r223 i24                    ; copy memory
move $r220 $r225                        ; move parameter from branch to block argument
.77
addi $r229 $$locbase i1312              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r229 $r220 i24                    ; copy memory
addi $r230 $$locbase i1312              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r231 $$locbase i904               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r231 $r230 i24                    ; copy memory
addi $r232 $$locbase i904               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r233 $$locbase i752               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r233 $r232 i24                    ; copy memory
addi $r234 $$locbase i480               ; get offset to local __ptr slice
move $$arg0 $r233                       ; [call: as_raw_slice_29]: pass argument 0
move $$arg1 $r234                       ; [call: as_raw_slice_29]: pass argument 1
fncall .12                              ; [call: as_raw_slice_29]: call function
addi $r236 $$locbase i872               ; get offset to local __ptr slice
mcpi $r236 $r234 i16                    ; copy memory
move $r237 $r236                        ; move parameter from branch to block argument
ji  .78
.55
addi $r238 $$locbase i888               ; get offset to local __ptr { __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }, u64 }
sw $$locbase $r12 i111                  ; store word
movi $r240 i56                          ; initialize constant into register
sw $$locbase $r240 i112                 ; store word
addi $r241 $$locbase i96                ; get offset to local __ptr { __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }, u64 }
mcpi $r241 $r238 i16                    ; copy memory
addi $r242 $$locbase i872               ; get offset to local __ptr slice
mcpi $r242 $r241 i16                    ; copy memory
move $r237 $r242                        ; move parameter from branch to block argument
.78
mcpi $r13 $r237 i16                     ; copy memory
.5
cfsi i1520                              ; [fn end: encode_allow_alias_1] free: locals 1520 byte(s), call args 0 slot(s)
move $$reta $r14                        ; [fn end: encode_allow_alias_1] restore return address
popa .4                                 ; [fn end: encode_allow_alias_1] restore all used registers
jal $zero $$reta i0                     ; [fn end: encode_allow_alias_1] return from call
DIFF------------------------------
.program:
.4                                      ; --- start of function: encode_allow_alias_1 ---
pusha .4                                ; [fn init: encode_allow_alias_1]: push all used registers to stack
move $$locbase $sp                      ; [fn init: encode_allow_alias_1]: set locals base register
cfei i1520                              ; [fn init: encode_allow_alias_1]: allocate: locals 1520 byte(s), call args 0 slot(s)
move $r12 $$arg0                        ; [fn init: encode_allow_alias_1]: copy argument 0 (item)
move $r13 $$arg1                        ; [fn init: encode_allow_alias_1]: copy argument 1 (__ret_value)
move $r14 $$reta                        ; [fn init: encode_allow_alias_1]: save return address
.48
.50
movi $r19 i0                            ; move parameter from branch to block argument
.52
 move $r23 $r19                          ; move parameter from branch to block argument
 jnzi $r19 .53
 movi $r23 i0                            ; move parameter from branch to block argument
 
ji  .54
.53
 movi $r23 i0                            ; move parameter from branch to block argument
                                         ; move parameter from branch to block argument
.54
jnzi $r23 .55
.56
addi $r27 $$locbase i456                ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r27                        ; [call: new_28]: pass argument 0
fncall .10                              ; [call: new_28]: call function
addi $r29 $$locbase i1336               ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
mcpi $r29 $r12 i56                      ; copy memory
addi $r30 $$locbase i928                ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r30 $r27 i24                      ; copy memory
addi $r31 $$locbase i1336               ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
addi $r32 $$locbase i208                ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
mcpi $r32 $r31 i56                      ; copy memory
lw $r34 $$locbase i26                   ; load word
eq $r35 $r34 $zero
jnzi $r35 .57
.58
lw $r37 $$locbase i26                   ; load word
eq $r38 $r37 $one
jnzi $r38 .59
.60
lw $r40 $$locbase i26                   ; load word
movi $r41 i2                            ; initialize constant into register
eq $r42 $r40 $r41
jnzi $r42 .61
.62
lw $r44 $$locbase i26                   ; load word
movi $r45 i3                            ; initialize constant into register
eq $r46 $r44 $r45
jnzi $r46 .63
.64
lw $r48 $$locbase i26                   ; load word
movi $r49 i4                            ; initialize constant into register
eq $r50 $r48 $r49
jnzi $r50 .65
.66
load $r51 data_NonConfigurable_2        ; load constant from data section
rvrt $r51
.65
addi $r52 $$locbase i208                ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
addi $r53 $r52 i8                       ; get offset to aggregate element
addi $r54 $$locbase i1472               ; get offset to local __ptr [slice; 3]
mcpi $r54 $r53 i48                      ; copy memory
addi $r55 $$locbase i928                ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r56 $$locbase i688                ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r56 $r55 i24                      ; copy memory
addi $r57 $$locbase i408                ; get offset to local __ptr { { ptr, u64, u64 } }
movi $$arg0 i4                          ; [call: abi_encode_20]: pass argument 0
move $$arg1 $r56                        ; [call: abi_encode_20]: pass argument 1
move $$arg2 $r57                        ; [call: abi_encode_20]: pass argument 2
fncall .6                               ; [call: abi_encode_20]: call function
addi $r60 $$locbase i1264               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r60 $r57 i24                      ; copy memory
addi $r61 $$locbase i1472               ; get offset to local __ptr [slice; 3]
addi $r62 $$locbase i1264               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r63 $$locbase i1408               ; get offset to local __ptr [slice; 3]
mcpi $r63 $r61 i48                      ; copy memory
addi $r64 $$locbase i1024               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r64 $r62 i24                      ; copy memory
addi $r65 $$locbase i1024               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r66 $$locbase i1096               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r66 $r65 i24                      ; copy memory
movi $r67 i0                            ; move parameter from branch to block argument
.67
move $r69 $r67                          ; move parameter from branch to block argument
movi $r70 i3                            ; initialize constant into register
lt $r71 $r67 $r70
jnzi $r71 .68
.69
addi $r72 $$locbase i1096               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r73 $$locbase i1288               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r73 $r72 i24                      ; copy memory
addi $r74 $$locbase i1288               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r75 $$locbase i776                ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r75 $r74 i24                      ; copy memory
move $r76 $r75                          ; move parameter from branch to block argument
ji  .70
.68
addi $r77 $$locbase i1408               ; get offset to local __ptr [slice; 3]
muli $r79 $r69 i16                      ; get offset to array element
add $r79 $r77 $r79                      ; add array element offset to array base
addi $r80 $$locbase i1096               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r81 $$locbase i712                ; get offset to local __ptr slice
mcpi $r81 $r79 i16                      ; copy memory
addi $r82 $$locbase i728                ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r82 $r80 i24                      ; copy memory
addi $r83 $$locbase i432                ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r81                        ; [call: abi_encode_26]: pass argument 0
move $$arg1 $r82                        ; [call: abi_encode_26]: pass argument 1
move $$arg2 $r83                        ; [call: abi_encode_26]: pass argument 2
fncall .8                               ; [call: abi_encode_26]: call function
addi $r85 $$locbase i1096               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r85 $r83 i24                      ; copy memory
addi $r86 $r69 i1
move $r67 $r86                          ; move parameter from branch to block argument
ji  .67
.63
addi $r88 $$locbase i208                ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
addi $r89 $r88 i40                      ; get offset to aggregate element
addi $r90 $$locbase i1456               ; get offset to local __ptr { u64, u64 }
mcpi $r90 $r89 i16                      ; copy memory
addi $r91 $$locbase i928                ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r92 $$locbase i616                ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r92 $r91 i24                      ; copy memory
addi $r93 $$locbase i336                ; get offset to local __ptr { { ptr, u64, u64 } }
movi $$arg0 i3                          ; [call: abi_encode_20]: pass argument 0
move $$arg1 $r92                        ; [call: abi_encode_20]: pass argument 1
move $$arg2 $r93                        ; [call: abi_encode_20]: pass argument 2
fncall .6                               ; [call: abi_encode_20]: call function
addi $r96 $$locbase i1216               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r96 $r93 i24                      ; copy memory
addi $r97 $$locbase i1456               ; get offset to local __ptr { u64, u64 }
addi $r98 $$locbase i1216               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r99 $$locbase i1392               ; get offset to local __ptr { u64, u64 }
mcpi $r99 $r97 i16                      ; copy memory
addi $r100 $$locbase i1000              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r100 $r98 i24                     ; copy memory
lw $r102 $$locbase i174                 ; load word
addi $r103 $$locbase i1000              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r104 $$locbase i640               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r104 $r103 i24                    ; copy memory
addi $r105 $$locbase i360               ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r102                       ; [call: abi_encode_20]: pass argument 0
move $$arg1 $r104                       ; [call: abi_encode_20]: pass argument 1
move $$arg2 $r105                       ; [call: abi_encode_20]: pass argument 2
fncall .6                               ; [call: abi_encode_20]: call function
addi $r107 $$locbase i1072              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r107 $r105 i24                    ; copy memory
lw $r110 $$locbase i175                 ; load word
addi $r111 $$locbase i1072              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r112 $$locbase i664               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r112 $r111 i24                    ; copy memory
addi $r113 $$locbase i384               ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r110                       ; [call: abi_encode_20]: pass argument 0
move $$arg1 $r112                       ; [call: abi_encode_20]: pass argument 1
move $$arg2 $r113                       ; [call: abi_encode_20]: pass argument 2
fncall .6                               ; [call: abi_encode_20]: call function
addi $r115 $$locbase i1144              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r115 $r113 i24                    ; copy memory
addi $r116 $$locbase i1144              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r117 $$locbase i1240              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r117 $r116 i24                    ; copy memory
addi $r118 $$locbase i1240              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r119 $$locbase i776               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r119 $r118 i24                    ; copy memory
move $r76 $r119                         ; move parameter from branch to block argument
.70
addi $r123 $$locbase i800               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r123 $r76 i24                     ; copy memory
move $r124 $r123                        ; move parameter from branch to block argument
ji  .71
.61
addi $r125 $$locbase i208               ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
addi $r126 $r125 i55                    ; get offset to aggregate element
lb $r127 $r126 i0                       ; load byte
addi $r128 $$locbase i928               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r129 $$locbase i592               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r129 $r128 i24                    ; copy memory
addi $r130 $$locbase i312               ; get offset to local __ptr { { ptr, u64, u64 } }
movi $$arg0 i2                          ; [call: abi_encode_20]: pass argument 0
move $$arg1 $r129                       ; [call: abi_encode_20]: pass argument 1
move $$arg2 $r130                       ; [call: abi_encode_20]: pass argument 2
fncall .6                               ; [call: abi_encode_20]: call function
addi $r133 $$locbase i1168              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r133 $r130 i24                    ; copy memory
addi $r134 $$locbase i1168              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r135 $$locbase i976               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r135 $r134 i24                    ; copy memory
addi $r136 $$locbase i520               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r137 $$locbase i976               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r139 $$locbase i48                ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r139 $r137 i24                    ; copy memory
addi $r140 $$locbase i136               ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r140 $r139 i24                    ; copy memory
lw $r141 $$locbase i17                  ; load word
lw $r143 $$locbase i18                  ; load word
lw $r145 $$locbase i19                  ; load word
addi $r146 $r145 i1
gt $r147 $r146 $r143
move $r148 $r141                        ; move parameter from branch to block argument
move $r149 $r143                        ; move parameter from branch to block argument
jnzi $r147 .72
ji  .73
.72
muli $r151 $r143 i2
addi $r152 $r151 i1
aloc $r152
mcp $hp $r141 $r145
move $r148 $hp                          ; move parameter from branch to block argument
move $r149 $r152                        ; move parameter from branch to block argument
.73
move $r157 $r148                        ; move parameter from branch to block argument
move $r159 $r149                        ; move parameter from branch to block argument
add $r160 $r148 $r145
sb $r160 $r127 i0                       ; store byte
addi $r161 $$locbase i184               ; get offset to local __ptr { ptr, u64, u64 }
sw $$locbase $r157 i23                  ; store word
sw $$locbase $r159 i24                  ; store word
sw $$locbase $r146 i25                  ; store word
addi $r165 $$locbase i72                ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r165 $r161 i24                    ; copy memory
mcpi $r136 $r165 i24                    ; copy memory
addi $r166 $$locbase i1192              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r166 $r136 i24                    ; copy memory
addi $r167 $$locbase i1192              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r168 $$locbase i800               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r168 $r167 i24                    ; copy memory
move $r124 $r168                        ; move parameter from branch to block argument
.71
addi $r172 $$locbase i824               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r172 $r124 i24                    ; copy memory
move $r173 $r172                        ; move parameter from branch to block argument
ji  .74
.59
addi $r174 $$locbase i208               ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
addi $r175 $r174 i55                    ; get offset to aggregate element
lb $r176 $r175 i0                       ; load byte
addi $r177 $$locbase i928               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r178 $$locbase i568               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r178 $r177 i24                    ; copy memory
addi $r179 $$locbase i288               ; get offset to local __ptr { { ptr, u64, u64 } }
movi $$arg0 i1                          ; [call: abi_encode_20]: pass argument 0
move $$arg1 $r178                       ; [call: abi_encode_20]: pass argument 1
move $$arg2 $r179                       ; [call: abi_encode_20]: pass argument 2
fncall .6                               ; [call: abi_encode_20]: call function
addi $r181 $$locbase i1048              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r181 $r179 i24                    ; copy memory
addi $r182 $$locbase i1048              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r183 $$locbase i952               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r183 $r182 i24                    ; copy memory
addi $r184 $$locbase i496               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r185 $$locbase i952               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $$locbase $r185 i24                ; copy memory
addi $r187 $$locbase i112               ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r187 $$locbase i24                ; copy memory
lw $r188 $$locbase i14                  ; load word
lw $r190 $$locbase i15                  ; load word
lw $r192 $$locbase i16                  ; load word
addi $r193 $r192 i1
gt $r194 $r193 $r190
move $r195 $r188                        ; move parameter from branch to block argument
move $r196 $r190                        ; move parameter from branch to block argument
jnzi $r194 .75
ji  .76
.75
muli $r198 $r190 i2
addi $r199 $r198 i1
aloc $r199
mcp $hp $r188 $r192
move $r195 $hp                          ; move parameter from branch to block argument
move $r196 $r199                        ; move parameter from branch to block argument
.76
move $r204 $r195                        ; move parameter from branch to block argument
move $r206 $r196                        ; move parameter from branch to block argument
add $r207 $r195 $r192
sb $r207 $r176 i0                       ; store byte
addi $r208 $$locbase i160               ; get offset to local __ptr { ptr, u64, u64 }
sw $$locbase $r204 i20                  ; store word
sw $$locbase $r206 i21                  ; store word
sw $$locbase $r193 i22                  ; store word
addi $r212 $$locbase i24                ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r212 $r208 i24                    ; copy memory
mcpi $r184 $r212 i24                    ; copy memory
addi $r213 $$locbase i1120              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r213 $r184 i24                    ; copy memory
addi $r214 $$locbase i1120              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r215 $$locbase i824               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r215 $r214 i24                    ; copy memory
move $r173 $r215                        ; move parameter from branch to block argument
.74
addi $r219 $$locbase i848               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r219 $r173 i24                    ; copy memory
move $r220 $r219                        ; move parameter from branch to block argument
ji  .77
.57
addi $r221 $$locbase i928               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r222 $$locbase i544               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r222 $r221 i24                    ; copy memory
addi $r223 $$locbase i264               ; get offset to local __ptr { { ptr, u64, u64 } }
movi $$arg0 i0                          ; [call: abi_encode_20]: pass argument 0
move $$arg1 $r222                       ; [call: abi_encode_20]: pass argument 1
move $$arg2 $r223                       ; [call: abi_encode_20]: pass argument 2
fncall .6                               ; [call: abi_encode_20]: call function
addi $r225 $$locbase i848               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r225 $r223 i24                    ; copy memory
move $r220 $r225                        ; move parameter from branch to block argument
.77
addi $r229 $$locbase i1312              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r229 $r220 i24                    ; copy memory
addi $r230 $$locbase i1312              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r231 $$locbase i904               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r231 $r230 i24                    ; copy memory
addi $r232 $$locbase i904               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r233 $$locbase i752               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r233 $r232 i24                    ; copy memory
addi $r234 $$locbase i480               ; get offset to local __ptr slice
move $$arg0 $r233                       ; [call: as_raw_slice_29]: pass argument 0
move $$arg1 $r234                       ; [call: as_raw_slice_29]: pass argument 1
fncall .12                              ; [call: as_raw_slice_29]: call function
addi $r236 $$locbase i872               ; get offset to local __ptr slice
mcpi $r236 $r234 i16                    ; copy memory
move $r237 $r236                        ; move parameter from branch to block argument
ji  .78
.55
addi $r238 $$locbase i888               ; get offset to local __ptr { __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }, u64 }
sw $$locbase $r12 i111                  ; store word
movi $r240 i56                          ; initialize constant into register
sw $$locbase $r240 i112                 ; store word
addi $r241 $$locbase i96                ; get offset to local __ptr { __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }, u64 }
mcpi $r241 $r238 i16                    ; copy memory
addi $r242 $$locbase i872               ; get offset to local __ptr slice
mcpi $r242 $r241 i16                    ; copy memory
move $r237 $r242                        ; move parameter from branch to block argument
.78
mcpi $r13 $r237 i16                     ; copy memory
.5
cfsi i1520                              ; [fn end: encode_allow_alias_1] free: locals 1520 byte(s), call args 0 slot(s)
move $$reta $r14                        ; [fn end: encode_allow_alias_1] restore return address
popa .4                                 ; [fn end: encode_allow_alias_1] restore all used registers
jal $zero $$reta i0                     ; [fn end: encode_allow_alias_1] return from call
DIFF------------------------------
.program:
.4                                      ; --- start of function: encode_allow_alias_1 ---
pusha .4                                ; [fn init: encode_allow_alias_1]: push all used registers to stack
move $$locbase $sp                      ; [fn init: encode_allow_alias_1]: set locals base register
cfei i1520                              ; [fn init: encode_allow_alias_1]: allocate: locals 1520 byte(s), call args 0 slot(s)
move $r12 $$arg0                        ; [fn init: encode_allow_alias_1]: copy argument 0 (item)
move $r13 $$arg1                        ; [fn init: encode_allow_alias_1]: copy argument 1 (__ret_value)
move $r14 $$reta                        ; [fn init: encode_allow_alias_1]: save return address
.48
.50
.52
movi $r23 i0                            ; move parameter from branch to block argument
.54
 jnzi $r23 .55
 
.56
addi $r27 $$locbase i456                ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r27                        ; [call: new_28]: pass argument 0
fncall .10                              ; [call: new_28]: call function
addi $r29 $$locbase i1336               ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
mcpi $r29 $r12 i56                      ; copy memory
addi $r30 $$locbase i928                ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r30 $r27 i24                      ; copy memory
addi $r31 $$locbase i1336               ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
addi $r32 $$locbase i208                ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
mcpi $r32 $r31 i56                      ; copy memory
lw $r34 $$locbase i26                   ; load word
eq $r35 $r34 $zero
jnzi $r35 .57
.58
lw $r37 $$locbase i26                   ; load word
eq $r38 $r37 $one
jnzi $r38 .59
.60
lw $r40 $$locbase i26                   ; load word
movi $r41 i2                            ; initialize constant into register
eq $r42 $r40 $r41
jnzi $r42 .61
.62
lw $r44 $$locbase i26                   ; load word
movi $r45 i3                            ; initialize constant into register
eq $r46 $r44 $r45
jnzi $r46 .63
.64
lw $r48 $$locbase i26                   ; load word
movi $r49 i4                            ; initialize constant into register
eq $r50 $r48 $r49
jnzi $r50 .65
.66
load $r51 data_NonConfigurable_2        ; load constant from data section
rvrt $r51
.65
addi $r52 $$locbase i208                ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
addi $r53 $r52 i8                       ; get offset to aggregate element
addi $r54 $$locbase i1472               ; get offset to local __ptr [slice; 3]
mcpi $r54 $r53 i48                      ; copy memory
addi $r55 $$locbase i928                ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r56 $$locbase i688                ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r56 $r55 i24                      ; copy memory
addi $r57 $$locbase i408                ; get offset to local __ptr { { ptr, u64, u64 } }
movi $$arg0 i4                          ; [call: abi_encode_20]: pass argument 0
move $$arg1 $r56                        ; [call: abi_encode_20]: pass argument 1
move $$arg2 $r57                        ; [call: abi_encode_20]: pass argument 2
fncall .6                               ; [call: abi_encode_20]: call function
addi $r60 $$locbase i1264               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r60 $r57 i24                      ; copy memory
addi $r61 $$locbase i1472               ; get offset to local __ptr [slice; 3]
addi $r62 $$locbase i1264               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r63 $$locbase i1408               ; get offset to local __ptr [slice; 3]
mcpi $r63 $r61 i48                      ; copy memory
addi $r64 $$locbase i1024               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r64 $r62 i24                      ; copy memory
addi $r65 $$locbase i1024               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r66 $$locbase i1096               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r66 $r65 i24                      ; copy memory
movi $r67 i0                            ; move parameter from branch to block argument
.67
move $r69 $r67                          ; move parameter from branch to block argument
movi $r70 i3                            ; initialize constant into register
lt $r71 $r67 $r70
jnzi $r71 .68
.69
addi $r72 $$locbase i1096               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r73 $$locbase i1288               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r73 $r72 i24                      ; copy memory
addi $r74 $$locbase i1288               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r75 $$locbase i776                ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r75 $r74 i24                      ; copy memory
move $r76 $r75                          ; move parameter from branch to block argument
ji  .70
.68
addi $r77 $$locbase i1408               ; get offset to local __ptr [slice; 3]
muli $r79 $r69 i16                      ; get offset to array element
add $r79 $r77 $r79                      ; add array element offset to array base
addi $r80 $$locbase i1096               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r81 $$locbase i712                ; get offset to local __ptr slice
mcpi $r81 $r79 i16                      ; copy memory
addi $r82 $$locbase i728                ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r82 $r80 i24                      ; copy memory
addi $r83 $$locbase i432                ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r81                        ; [call: abi_encode_26]: pass argument 0
move $$arg1 $r82                        ; [call: abi_encode_26]: pass argument 1
move $$arg2 $r83                        ; [call: abi_encode_26]: pass argument 2
fncall .8                               ; [call: abi_encode_26]: call function
addi $r85 $$locbase i1096               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r85 $r83 i24                      ; copy memory
addi $r86 $r69 i1
move $r67 $r86                          ; move parameter from branch to block argument
ji  .67
.63
addi $r88 $$locbase i208                ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
addi $r89 $r88 i40                      ; get offset to aggregate element
addi $r90 $$locbase i1456               ; get offset to local __ptr { u64, u64 }
mcpi $r90 $r89 i16                      ; copy memory
addi $r91 $$locbase i928                ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r92 $$locbase i616                ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r92 $r91 i24                      ; copy memory
addi $r93 $$locbase i336                ; get offset to local __ptr { { ptr, u64, u64 } }
movi $$arg0 i3                          ; [call: abi_encode_20]: pass argument 0
move $$arg1 $r92                        ; [call: abi_encode_20]: pass argument 1
move $$arg2 $r93                        ; [call: abi_encode_20]: pass argument 2
fncall .6                               ; [call: abi_encode_20]: call function
addi $r96 $$locbase i1216               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r96 $r93 i24                      ; copy memory
addi $r97 $$locbase i1456               ; get offset to local __ptr { u64, u64 }
addi $r98 $$locbase i1216               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r99 $$locbase i1392               ; get offset to local __ptr { u64, u64 }
mcpi $r99 $r97 i16                      ; copy memory
addi $r100 $$locbase i1000              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r100 $r98 i24                     ; copy memory
lw $r102 $$locbase i174                 ; load word
addi $r103 $$locbase i1000              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r104 $$locbase i640               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r104 $r103 i24                    ; copy memory
addi $r105 $$locbase i360               ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r102                       ; [call: abi_encode_20]: pass argument 0
move $$arg1 $r104                       ; [call: abi_encode_20]: pass argument 1
move $$arg2 $r105                       ; [call: abi_encode_20]: pass argument 2
fncall .6                               ; [call: abi_encode_20]: call function
addi $r107 $$locbase i1072              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r107 $r105 i24                    ; copy memory
lw $r110 $$locbase i175                 ; load word
addi $r111 $$locbase i1072              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r112 $$locbase i664               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r112 $r111 i24                    ; copy memory
addi $r113 $$locbase i384               ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r110                       ; [call: abi_encode_20]: pass argument 0
move $$arg1 $r112                       ; [call: abi_encode_20]: pass argument 1
move $$arg2 $r113                       ; [call: abi_encode_20]: pass argument 2
fncall .6                               ; [call: abi_encode_20]: call function
addi $r115 $$locbase i1144              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r115 $r113 i24                    ; copy memory
addi $r116 $$locbase i1144              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r117 $$locbase i1240              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r117 $r116 i24                    ; copy memory
addi $r118 $$locbase i1240              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r119 $$locbase i776               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r119 $r118 i24                    ; copy memory
move $r76 $r119                         ; move parameter from branch to block argument
.70
addi $r123 $$locbase i800               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r123 $r76 i24                     ; copy memory
move $r124 $r123                        ; move parameter from branch to block argument
ji  .71
.61
addi $r125 $$locbase i208               ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
addi $r126 $r125 i55                    ; get offset to aggregate element
lb $r127 $r126 i0                       ; load byte
addi $r128 $$locbase i928               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r129 $$locbase i592               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r129 $r128 i24                    ; copy memory
addi $r130 $$locbase i312               ; get offset to local __ptr { { ptr, u64, u64 } }
movi $$arg0 i2                          ; [call: abi_encode_20]: pass argument 0
move $$arg1 $r129                       ; [call: abi_encode_20]: pass argument 1
move $$arg2 $r130                       ; [call: abi_encode_20]: pass argument 2
fncall .6                               ; [call: abi_encode_20]: call function
addi $r133 $$locbase i1168              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r133 $r130 i24                    ; copy memory
addi $r134 $$locbase i1168              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r135 $$locbase i976               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r135 $r134 i24                    ; copy memory
addi $r136 $$locbase i520               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r137 $$locbase i976               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r139 $$locbase i48                ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r139 $r137 i24                    ; copy memory
addi $r140 $$locbase i136               ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r140 $r139 i24                    ; copy memory
lw $r141 $$locbase i17                  ; load word
lw $r143 $$locbase i18                  ; load word
lw $r145 $$locbase i19                  ; load word
addi $r146 $r145 i1
gt $r147 $r146 $r143
move $r148 $r141                        ; move parameter from branch to block argument
move $r149 $r143                        ; move parameter from branch to block argument
jnzi $r147 .72
ji  .73
.72
muli $r151 $r143 i2
addi $r152 $r151 i1
aloc $r152
mcp $hp $r141 $r145
move $r148 $hp                          ; move parameter from branch to block argument
move $r149 $r152                        ; move parameter from branch to block argument
.73
move $r157 $r148                        ; move parameter from branch to block argument
move $r159 $r149                        ; move parameter from branch to block argument
add $r160 $r148 $r145
sb $r160 $r127 i0                       ; store byte
addi $r161 $$locbase i184               ; get offset to local __ptr { ptr, u64, u64 }
sw $$locbase $r157 i23                  ; store word
sw $$locbase $r159 i24                  ; store word
sw $$locbase $r146 i25                  ; store word
addi $r165 $$locbase i72                ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r165 $r161 i24                    ; copy memory
mcpi $r136 $r165 i24                    ; copy memory
addi $r166 $$locbase i1192              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r166 $r136 i24                    ; copy memory
addi $r167 $$locbase i1192              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r168 $$locbase i800               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r168 $r167 i24                    ; copy memory
move $r124 $r168                        ; move parameter from branch to block argument
.71
addi $r172 $$locbase i824               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r172 $r124 i24                    ; copy memory
move $r173 $r172                        ; move parameter from branch to block argument
ji  .74
.59
addi $r174 $$locbase i208               ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
addi $r175 $r174 i55                    ; get offset to aggregate element
lb $r176 $r175 i0                       ; load byte
addi $r177 $$locbase i928               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r178 $$locbase i568               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r178 $r177 i24                    ; copy memory
addi $r179 $$locbase i288               ; get offset to local __ptr { { ptr, u64, u64 } }
movi $$arg0 i1                          ; [call: abi_encode_20]: pass argument 0
move $$arg1 $r178                       ; [call: abi_encode_20]: pass argument 1
move $$arg2 $r179                       ; [call: abi_encode_20]: pass argument 2
fncall .6                               ; [call: abi_encode_20]: call function
addi $r181 $$locbase i1048              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r181 $r179 i24                    ; copy memory
addi $r182 $$locbase i1048              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r183 $$locbase i952               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r183 $r182 i24                    ; copy memory
addi $r184 $$locbase i496               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r185 $$locbase i952               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $$locbase $r185 i24                ; copy memory
addi $r187 $$locbase i112               ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r187 $$locbase i24                ; copy memory
lw $r188 $$locbase i14                  ; load word
lw $r190 $$locbase i15                  ; load word
lw $r192 $$locbase i16                  ; load word
addi $r193 $r192 i1
gt $r194 $r193 $r190
move $r195 $r188                        ; move parameter from branch to block argument
move $r196 $r190                        ; move parameter from branch to block argument
jnzi $r194 .75
ji  .76
.75
muli $r198 $r190 i2
addi $r199 $r198 i1
aloc $r199
mcp $hp $r188 $r192
move $r195 $hp                          ; move parameter from branch to block argument
move $r196 $r199                        ; move parameter from branch to block argument
.76
move $r204 $r195                        ; move parameter from branch to block argument
move $r206 $r196                        ; move parameter from branch to block argument
add $r207 $r195 $r192
sb $r207 $r176 i0                       ; store byte
addi $r208 $$locbase i160               ; get offset to local __ptr { ptr, u64, u64 }
sw $$locbase $r204 i20                  ; store word
sw $$locbase $r206 i21                  ; store word
sw $$locbase $r193 i22                  ; store word
addi $r212 $$locbase i24                ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r212 $r208 i24                    ; copy memory
mcpi $r184 $r212 i24                    ; copy memory
addi $r213 $$locbase i1120              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r213 $r184 i24                    ; copy memory
addi $r214 $$locbase i1120              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r215 $$locbase i824               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r215 $r214 i24                    ; copy memory
move $r173 $r215                        ; move parameter from branch to block argument
.74
addi $r219 $$locbase i848               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r219 $r173 i24                    ; copy memory
move $r220 $r219                        ; move parameter from branch to block argument
ji  .77
.57
addi $r221 $$locbase i928               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r222 $$locbase i544               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r222 $r221 i24                    ; copy memory
addi $r223 $$locbase i264               ; get offset to local __ptr { { ptr, u64, u64 } }
movi $$arg0 i0                          ; [call: abi_encode_20]: pass argument 0
move $$arg1 $r222                       ; [call: abi_encode_20]: pass argument 1
move $$arg2 $r223                       ; [call: abi_encode_20]: pass argument 2
fncall .6                               ; [call: abi_encode_20]: call function
addi $r225 $$locbase i848               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r225 $r223 i24                    ; copy memory
move $r220 $r225                        ; move parameter from branch to block argument
.77
addi $r229 $$locbase i1312              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r229 $r220 i24                    ; copy memory
addi $r230 $$locbase i1312              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r231 $$locbase i904               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r231 $r230 i24                    ; copy memory
addi $r232 $$locbase i904               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r233 $$locbase i752               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r233 $r232 i24                    ; copy memory
addi $r234 $$locbase i480               ; get offset to local __ptr slice
move $$arg0 $r233                       ; [call: as_raw_slice_29]: pass argument 0
move $$arg1 $r234                       ; [call: as_raw_slice_29]: pass argument 1
fncall .12                              ; [call: as_raw_slice_29]: call function
addi $r236 $$locbase i872               ; get offset to local __ptr slice
mcpi $r236 $r234 i16                    ; copy memory
move $r237 $r236                        ; move parameter from branch to block argument
ji  .78
.55
addi $r238 $$locbase i888               ; get offset to local __ptr { __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }, u64 }
sw $$locbase $r12 i111                  ; store word
movi $r240 i56                          ; initialize constant into register
sw $$locbase $r240 i112                 ; store word
addi $r241 $$locbase i96                ; get offset to local __ptr { __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }, u64 }
mcpi $r241 $r238 i16                    ; copy memory
addi $r242 $$locbase i872               ; get offset to local __ptr slice
mcpi $r242 $r241 i16                    ; copy memory
move $r237 $r242                        ; move parameter from branch to block argument
.78
mcpi $r13 $r237 i16                     ; copy memory
.5
cfsi i1520                              ; [fn end: encode_allow_alias_1] free: locals 1520 byte(s), call args 0 slot(s)
move $$reta $r14                        ; [fn end: encode_allow_alias_1] restore return address
popa .4                                 ; [fn end: encode_allow_alias_1] restore all used registers
jal $zero $$reta i0                     ; [fn end: encode_allow_alias_1] return from call
DIFF------------------------------
.program:
.4                                      ; --- start of function: encode_allow_alias_1 ---
pusha .4                                ; [fn init: encode_allow_alias_1]: push all used registers to stack
move $$locbase $sp                      ; [fn init: encode_allow_alias_1]: set locals base register
cfei i1520                              ; [fn init: encode_allow_alias_1]: allocate: locals 1520 byte(s), call args 0 slot(s)
move $r12 $$arg0                        ; [fn init: encode_allow_alias_1]: copy argument 0 (item)
move $r13 $$arg1                        ; [fn init: encode_allow_alias_1]: copy argument 1 (__ret_value)
move $r14 $$reta                        ; [fn init: encode_allow_alias_1]: save return address
.48
.50
.52
.54
.56
addi $r27 $$locbase i456                ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r27                        ; [call: new_28]: pass argument 0
fncall .10                              ; [call: new_28]: call function
addi $r29 $$locbase i1336               ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
mcpi $r29 $r12 i56                      ; copy memory
addi $r30 $$locbase i928                ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r30 $r27 i24                      ; copy memory
addi $r31 $$locbase i1336               ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
addi $r32 $$locbase i208                ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
mcpi $r32 $r31 i56                      ; copy memory
lw $r34 $$locbase i26                   ; load word
eq $r35 $r34 $zero
jnzi $r35 .57
.58
lw $r37 $$locbase i26                   ; load word
eq $r38 $r37 $one
jnzi $r38 .59
.60
lw $r40 $$locbase i26                   ; load word
movi $r41 i2                            ; initialize constant into register
eq $r42 $r40 $r41
jnzi $r42 .61
.62
lw $r44 $$locbase i26                   ; load word
movi $r45 i3                            ; initialize constant into register
eq $r46 $r44 $r45
jnzi $r46 .63
.64
lw $r48 $$locbase i26                   ; load word
movi $r49 i4                            ; initialize constant into register
eq $r50 $r48 $r49
jnzi $r50 .65
.66
load $r51 data_NonConfigurable_2        ; load constant from data section
rvrt $r51
.65
addi $r52 $$locbase i208                ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
addi $r53 $r52 i8                       ; get offset to aggregate element
addi $r54 $$locbase i1472               ; get offset to local __ptr [slice; 3]
mcpi $r54 $r53 i48                      ; copy memory
addi $r55 $$locbase i928                ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r56 $$locbase i688                ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r56 $r55 i24                      ; copy memory
addi $r57 $$locbase i408                ; get offset to local __ptr { { ptr, u64, u64 } }
movi $$arg0 i4                          ; [call: abi_encode_20]: pass argument 0
move $$arg1 $r56                        ; [call: abi_encode_20]: pass argument 1
move $$arg2 $r57                        ; [call: abi_encode_20]: pass argument 2
fncall .6                               ; [call: abi_encode_20]: call function
addi $r60 $$locbase i1264               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r60 $r57 i24                      ; copy memory
addi $r61 $$locbase i1472               ; get offset to local __ptr [slice; 3]
addi $r62 $$locbase i1264               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r63 $$locbase i1408               ; get offset to local __ptr [slice; 3]
mcpi $r63 $r61 i48                      ; copy memory
addi $r64 $$locbase i1024               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r64 $r62 i24                      ; copy memory
addi $r65 $$locbase i1024               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r66 $$locbase i1096               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r66 $r65 i24                      ; copy memory
movi $r67 i0                            ; move parameter from branch to block argument
.67
move $r69 $r67                          ; move parameter from branch to block argument
movi $r70 i3                            ; initialize constant into register
lt $r71 $r67 $r70
jnzi $r71 .68
.69
addi $r72 $$locbase i1096               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r73 $$locbase i1288               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r73 $r72 i24                      ; copy memory
addi $r74 $$locbase i1288               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r75 $$locbase i776                ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r75 $r74 i24                      ; copy memory
move $r76 $r75                          ; move parameter from branch to block argument
ji  .70
.68
addi $r77 $$locbase i1408               ; get offset to local __ptr [slice; 3]
muli $r79 $r69 i16                      ; get offset to array element
add $r79 $r77 $r79                      ; add array element offset to array base
addi $r80 $$locbase i1096               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r81 $$locbase i712                ; get offset to local __ptr slice
mcpi $r81 $r79 i16                      ; copy memory
addi $r82 $$locbase i728                ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r82 $r80 i24                      ; copy memory
addi $r83 $$locbase i432                ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r81                        ; [call: abi_encode_26]: pass argument 0
move $$arg1 $r82                        ; [call: abi_encode_26]: pass argument 1
move $$arg2 $r83                        ; [call: abi_encode_26]: pass argument 2
fncall .8                               ; [call: abi_encode_26]: call function
addi $r85 $$locbase i1096               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r85 $r83 i24                      ; copy memory
addi $r86 $r69 i1
move $r67 $r86                          ; move parameter from branch to block argument
ji  .67
.63
addi $r88 $$locbase i208                ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
addi $r89 $r88 i40                      ; get offset to aggregate element
addi $r90 $$locbase i1456               ; get offset to local __ptr { u64, u64 }
mcpi $r90 $r89 i16                      ; copy memory
addi $r91 $$locbase i928                ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r92 $$locbase i616                ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r92 $r91 i24                      ; copy memory
addi $r93 $$locbase i336                ; get offset to local __ptr { { ptr, u64, u64 } }
movi $$arg0 i3                          ; [call: abi_encode_20]: pass argument 0
move $$arg1 $r92                        ; [call: abi_encode_20]: pass argument 1
move $$arg2 $r93                        ; [call: abi_encode_20]: pass argument 2
fncall .6                               ; [call: abi_encode_20]: call function
addi $r96 $$locbase i1216               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r96 $r93 i24                      ; copy memory
addi $r97 $$locbase i1456               ; get offset to local __ptr { u64, u64 }
addi $r98 $$locbase i1216               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r99 $$locbase i1392               ; get offset to local __ptr { u64, u64 }
mcpi $r99 $r97 i16                      ; copy memory
addi $r100 $$locbase i1000              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r100 $r98 i24                     ; copy memory
lw $r102 $$locbase i174                 ; load word
addi $r103 $$locbase i1000              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r104 $$locbase i640               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r104 $r103 i24                    ; copy memory
addi $r105 $$locbase i360               ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r102                       ; [call: abi_encode_20]: pass argument 0
move $$arg1 $r104                       ; [call: abi_encode_20]: pass argument 1
move $$arg2 $r105                       ; [call: abi_encode_20]: pass argument 2
fncall .6                               ; [call: abi_encode_20]: call function
addi $r107 $$locbase i1072              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r107 $r105 i24                    ; copy memory
lw $r110 $$locbase i175                 ; load word
addi $r111 $$locbase i1072              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r112 $$locbase i664               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r112 $r111 i24                    ; copy memory
addi $r113 $$locbase i384               ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r110                       ; [call: abi_encode_20]: pass argument 0
move $$arg1 $r112                       ; [call: abi_encode_20]: pass argument 1
move $$arg2 $r113                       ; [call: abi_encode_20]: pass argument 2
fncall .6                               ; [call: abi_encode_20]: call function
addi $r115 $$locbase i1144              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r115 $r113 i24                    ; copy memory
addi $r116 $$locbase i1144              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r117 $$locbase i1240              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r117 $r116 i24                    ; copy memory
addi $r118 $$locbase i1240              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r119 $$locbase i776               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r119 $r118 i24                    ; copy memory
move $r76 $r119                         ; move parameter from branch to block argument
.70
addi $r123 $$locbase i800               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r123 $r76 i24                     ; copy memory
move $r124 $r123                        ; move parameter from branch to block argument
ji  .71
.61
addi $r125 $$locbase i208               ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
addi $r126 $r125 i55                    ; get offset to aggregate element
lb $r127 $r126 i0                       ; load byte
addi $r128 $$locbase i928               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r129 $$locbase i592               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r129 $r128 i24                    ; copy memory
addi $r130 $$locbase i312               ; get offset to local __ptr { { ptr, u64, u64 } }
movi $$arg0 i2                          ; [call: abi_encode_20]: pass argument 0
move $$arg1 $r129                       ; [call: abi_encode_20]: pass argument 1
move $$arg2 $r130                       ; [call: abi_encode_20]: pass argument 2
fncall .6                               ; [call: abi_encode_20]: call function
addi $r133 $$locbase i1168              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r133 $r130 i24                    ; copy memory
addi $r134 $$locbase i1168              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r135 $$locbase i976               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r135 $r134 i24                    ; copy memory
addi $r136 $$locbase i520               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r137 $$locbase i976               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r139 $$locbase i48                ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r139 $r137 i24                    ; copy memory
addi $r140 $$locbase i136               ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r140 $r139 i24                    ; copy memory
lw $r141 $$locbase i17                  ; load word
lw $r143 $$locbase i18                  ; load word
lw $r145 $$locbase i19                  ; load word
addi $r146 $r145 i1
gt $r147 $r146 $r143
move $r148 $r141                        ; move parameter from branch to block argument
move $r149 $r143                        ; move parameter from branch to block argument
jnzi $r147 .72
ji  .73
.72
muli $r151 $r143 i2
addi $r152 $r151 i1
aloc $r152
mcp $hp $r141 $r145
move $r148 $hp                          ; move parameter from branch to block argument
move $r149 $r152                        ; move parameter from branch to block argument
.73
move $r157 $r148                        ; move parameter from branch to block argument
move $r159 $r149                        ; move parameter from branch to block argument
add $r160 $r148 $r145
sb $r160 $r127 i0                       ; store byte
addi $r161 $$locbase i184               ; get offset to local __ptr { ptr, u64, u64 }
sw $$locbase $r157 i23                  ; store word
sw $$locbase $r159 i24                  ; store word
sw $$locbase $r146 i25                  ; store word
addi $r165 $$locbase i72                ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r165 $r161 i24                    ; copy memory
mcpi $r136 $r165 i24                    ; copy memory
addi $r166 $$locbase i1192              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r166 $r136 i24                    ; copy memory
addi $r167 $$locbase i1192              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r168 $$locbase i800               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r168 $r167 i24                    ; copy memory
move $r124 $r168                        ; move parameter from branch to block argument
.71
addi $r172 $$locbase i824               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r172 $r124 i24                    ; copy memory
move $r173 $r172                        ; move parameter from branch to block argument
ji  .74
.59
addi $r174 $$locbase i208               ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
addi $r175 $r174 i55                    ; get offset to aggregate element
lb $r176 $r175 i0                       ; load byte
addi $r177 $$locbase i928               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r178 $$locbase i568               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r178 $r177 i24                    ; copy memory
addi $r179 $$locbase i288               ; get offset to local __ptr { { ptr, u64, u64 } }
movi $$arg0 i1                          ; [call: abi_encode_20]: pass argument 0
move $$arg1 $r178                       ; [call: abi_encode_20]: pass argument 1
move $$arg2 $r179                       ; [call: abi_encode_20]: pass argument 2
fncall .6                               ; [call: abi_encode_20]: call function
addi $r181 $$locbase i1048              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r181 $r179 i24                    ; copy memory
addi $r182 $$locbase i1048              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r183 $$locbase i952               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r183 $r182 i24                    ; copy memory
addi $r184 $$locbase i496               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r185 $$locbase i952               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $$locbase $r185 i24                ; copy memory
addi $r187 $$locbase i112               ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r187 $$locbase i24                ; copy memory
lw $r188 $$locbase i14                  ; load word
lw $r190 $$locbase i15                  ; load word
lw $r192 $$locbase i16                  ; load word
addi $r193 $r192 i1
gt $r194 $r193 $r190
move $r195 $r188                        ; move parameter from branch to block argument
move $r196 $r190                        ; move parameter from branch to block argument
jnzi $r194 .75
ji  .76
.75
muli $r198 $r190 i2
addi $r199 $r198 i1
aloc $r199
mcp $hp $r188 $r192
move $r195 $hp                          ; move parameter from branch to block argument
move $r196 $r199                        ; move parameter from branch to block argument
.76
move $r204 $r195                        ; move parameter from branch to block argument
move $r206 $r196                        ; move parameter from branch to block argument
add $r207 $r195 $r192
sb $r207 $r176 i0                       ; store byte
addi $r208 $$locbase i160               ; get offset to local __ptr { ptr, u64, u64 }
sw $$locbase $r204 i20                  ; store word
sw $$locbase $r206 i21                  ; store word
sw $$locbase $r193 i22                  ; store word
addi $r212 $$locbase i24                ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r212 $r208 i24                    ; copy memory
mcpi $r184 $r212 i24                    ; copy memory
addi $r213 $$locbase i1120              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r213 $r184 i24                    ; copy memory
addi $r214 $$locbase i1120              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r215 $$locbase i824               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r215 $r214 i24                    ; copy memory
move $r173 $r215                        ; move parameter from branch to block argument
.74
addi $r219 $$locbase i848               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r219 $r173 i24                    ; copy memory
move $r220 $r219                        ; move parameter from branch to block argument
ji  .77
.57
addi $r221 $$locbase i928               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r222 $$locbase i544               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r222 $r221 i24                    ; copy memory
addi $r223 $$locbase i264               ; get offset to local __ptr { { ptr, u64, u64 } }
movi $$arg0 i0                          ; [call: abi_encode_20]: pass argument 0
move $$arg1 $r222                       ; [call: abi_encode_20]: pass argument 1
move $$arg2 $r223                       ; [call: abi_encode_20]: pass argument 2
fncall .6                               ; [call: abi_encode_20]: call function
addi $r225 $$locbase i848               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r225 $r223 i24                    ; copy memory
move $r220 $r225                        ; move parameter from branch to block argument
.77
addi $r229 $$locbase i1312              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r229 $r220 i24                    ; copy memory
addi $r230 $$locbase i1312              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r231 $$locbase i904               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r231 $r230 i24                    ; copy memory
addi $r232 $$locbase i904               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r233 $$locbase i752               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r233 $r232 i24                    ; copy memory
addi $r234 $$locbase i480               ; get offset to local __ptr slice
move $$arg0 $r233                       ; [call: as_raw_slice_29]: pass argument 0
move $$arg1 $r234                       ; [call: as_raw_slice_29]: pass argument 1
fncall .12                              ; [call: as_raw_slice_29]: call function
addi $r236 $$locbase i872               ; get offset to local __ptr slice
mcpi $r236 $r234 i16                    ; copy memory
move $r237 $r236                        ; move parameter from branch to block argument
.78
 mcpi $r13 $r237 i16                     ; copy memory
 mcpi $r13 $r236 i16                     ; copy memory
.5
cfsi i1520                              ; [fn end: encode_allow_alias_1] free: locals 1520 byte(s), call args 0 slot(s)
move $$reta $r14                        ; [fn end: encode_allow_alias_1] restore return address
popa .4                                 ; [fn end: encode_allow_alias_1] restore all used registers
jal $zero $$reta i0                     ; [fn end: encode_allow_alias_1] return from call
DIFF------------------------------
.program:
.4                                      ; --- start of function: encode_allow_alias_1 ---
pusha .4                                ; [fn init: encode_allow_alias_1]: push all used registers to stack
move $$locbase $sp                      ; [fn init: encode_allow_alias_1]: set locals base register
cfei i1520                              ; [fn init: encode_allow_alias_1]: allocate: locals 1520 byte(s), call args 0 slot(s)
move $r12 $$arg0                        ; [fn init: encode_allow_alias_1]: copy argument 0 (item)
move $r13 $$arg1                        ; [fn init: encode_allow_alias_1]: copy argument 1 (__ret_value)
move $r14 $$reta                        ; [fn init: encode_allow_alias_1]: save return address
.48
.50
.52
.54
.56
addi $r27 $$locbase i456                ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r27                        ; [call: new_28]: pass argument 0
fncall .10                              ; [call: new_28]: call function
addi $r29 $$locbase i1336               ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
mcpi $r29 $r12 i56                      ; copy memory
addi $r30 $$locbase i928                ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r30 $r27 i24                      ; copy memory
addi $r31 $$locbase i1336               ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
addi $r32 $$locbase i208                ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
mcpi $r32 $r31 i56                      ; copy memory
lw $r34 $$locbase i26                   ; load word
eq $r35 $r34 $zero
jnzi $r35 .57
.58
lw $r37 $$locbase i26                   ; load word
eq $r38 $r37 $one
jnzi $r38 .59
.60
lw $r40 $$locbase i26                   ; load word
movi $r41 i2                            ; initialize constant into register
eq $r42 $r40 $r41
jnzi $r42 .61
.62
lw $r44 $$locbase i26                   ; load word
movi $r45 i3                            ; initialize constant into register
eq $r46 $r44 $r45
jnzi $r46 .63
.64
lw $r48 $$locbase i26                   ; load word
movi $r49 i4                            ; initialize constant into register
eq $r50 $r48 $r49
jnzi $r50 .65
.66
load $r51 data_NonConfigurable_2        ; load constant from data section
rvrt $r51
.65
addi $r52 $$locbase i208                ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
addi $r53 $r52 i8                       ; get offset to aggregate element
addi $r54 $$locbase i1472               ; get offset to local __ptr [slice; 3]
mcpi $r54 $r53 i48                      ; copy memory
addi $r55 $$locbase i928                ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r56 $$locbase i688                ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r56 $r55 i24                      ; copy memory
addi $r57 $$locbase i408                ; get offset to local __ptr { { ptr, u64, u64 } }
movi $$arg0 i4                          ; [call: abi_encode_20]: pass argument 0
move $$arg1 $r56                        ; [call: abi_encode_20]: pass argument 1
move $$arg2 $r57                        ; [call: abi_encode_20]: pass argument 2
fncall .6                               ; [call: abi_encode_20]: call function
addi $r60 $$locbase i1264               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r60 $r57 i24                      ; copy memory
addi $r61 $$locbase i1472               ; get offset to local __ptr [slice; 3]
addi $r62 $$locbase i1264               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r63 $$locbase i1408               ; get offset to local __ptr [slice; 3]
mcpi $r63 $r61 i48                      ; copy memory
addi $r64 $$locbase i1024               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r64 $r62 i24                      ; copy memory
addi $r65 $$locbase i1024               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r66 $$locbase i1096               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r66 $r65 i24                      ; copy memory
movi $r67 i0                            ; move parameter from branch to block argument
.67
move $r69 $r67                          ; move parameter from branch to block argument
movi $r70 i3                            ; initialize constant into register
lt $r71 $r67 $r70
jnzi $r71 .68
.69
addi $r72 $$locbase i1096               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r73 $$locbase i1288               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r73 $r72 i24                      ; copy memory
addi $r74 $$locbase i1288               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r75 $$locbase i776                ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r75 $r74 i24                      ; copy memory
move $r76 $r75                          ; move parameter from branch to block argument
ji  .70
.68
addi $r77 $$locbase i1408               ; get offset to local __ptr [slice; 3]
muli $r79 $r69 i16                      ; get offset to array element
add $r79 $r77 $r79                      ; add array element offset to array base
addi $r80 $$locbase i1096               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r81 $$locbase i712                ; get offset to local __ptr slice
mcpi $r81 $r79 i16                      ; copy memory
addi $r82 $$locbase i728                ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r82 $r80 i24                      ; copy memory
addi $r83 $$locbase i432                ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r81                        ; [call: abi_encode_26]: pass argument 0
move $$arg1 $r82                        ; [call: abi_encode_26]: pass argument 1
move $$arg2 $r83                        ; [call: abi_encode_26]: pass argument 2
fncall .8                               ; [call: abi_encode_26]: call function
addi $r85 $$locbase i1096               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r85 $r83 i24                      ; copy memory
addi $r86 $r69 i1
move $r67 $r86                          ; move parameter from branch to block argument
ji  .67
.63
addi $r88 $$locbase i208                ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
addi $r89 $r88 i40                      ; get offset to aggregate element
addi $r90 $$locbase i1456               ; get offset to local __ptr { u64, u64 }
mcpi $r90 $r89 i16                      ; copy memory
addi $r91 $$locbase i928                ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r92 $$locbase i616                ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r92 $r91 i24                      ; copy memory
addi $r93 $$locbase i336                ; get offset to local __ptr { { ptr, u64, u64 } }
movi $$arg0 i3                          ; [call: abi_encode_20]: pass argument 0
move $$arg1 $r92                        ; [call: abi_encode_20]: pass argument 1
move $$arg2 $r93                        ; [call: abi_encode_20]: pass argument 2
fncall .6                               ; [call: abi_encode_20]: call function
addi $r96 $$locbase i1216               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r96 $r93 i24                      ; copy memory
addi $r97 $$locbase i1456               ; get offset to local __ptr { u64, u64 }
addi $r98 $$locbase i1216               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r99 $$locbase i1392               ; get offset to local __ptr { u64, u64 }
mcpi $r99 $r97 i16                      ; copy memory
addi $r100 $$locbase i1000              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r100 $r98 i24                     ; copy memory
lw $r102 $$locbase i174                 ; load word
addi $r103 $$locbase i1000              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r104 $$locbase i640               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r104 $r103 i24                    ; copy memory
addi $r105 $$locbase i360               ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r102                       ; [call: abi_encode_20]: pass argument 0
move $$arg1 $r104                       ; [call: abi_encode_20]: pass argument 1
move $$arg2 $r105                       ; [call: abi_encode_20]: pass argument 2
fncall .6                               ; [call: abi_encode_20]: call function
addi $r107 $$locbase i1072              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r107 $r105 i24                    ; copy memory
lw $r110 $$locbase i175                 ; load word
addi $r111 $$locbase i1072              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r112 $$locbase i664               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r112 $r111 i24                    ; copy memory
addi $r113 $$locbase i384               ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r110                       ; [call: abi_encode_20]: pass argument 0
move $$arg1 $r112                       ; [call: abi_encode_20]: pass argument 1
move $$arg2 $r113                       ; [call: abi_encode_20]: pass argument 2
fncall .6                               ; [call: abi_encode_20]: call function
addi $r115 $$locbase i1144              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r115 $r113 i24                    ; copy memory
addi $r116 $$locbase i1144              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r117 $$locbase i1240              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r117 $r116 i24                    ; copy memory
addi $r118 $$locbase i1240              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r119 $$locbase i776               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r119 $r118 i24                    ; copy memory
move $r76 $r119                         ; move parameter from branch to block argument
.70
addi $r123 $$locbase i800               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r123 $r76 i24                     ; copy memory
move $r124 $r123                        ; move parameter from branch to block argument
ji  .71
.61
addi $r125 $$locbase i208               ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
addi $r126 $r125 i55                    ; get offset to aggregate element
lb $r127 $r126 i0                       ; load byte
addi $r128 $$locbase i928               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r129 $$locbase i592               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r129 $r128 i24                    ; copy memory
addi $r130 $$locbase i312               ; get offset to local __ptr { { ptr, u64, u64 } }
movi $$arg0 i2                          ; [call: abi_encode_20]: pass argument 0
move $$arg1 $r129                       ; [call: abi_encode_20]: pass argument 1
move $$arg2 $r130                       ; [call: abi_encode_20]: pass argument 2
fncall .6                               ; [call: abi_encode_20]: call function
addi $r133 $$locbase i1168              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r133 $r130 i24                    ; copy memory
addi $r134 $$locbase i1168              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r135 $$locbase i976               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r135 $r134 i24                    ; copy memory
addi $r136 $$locbase i520               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r137 $$locbase i976               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r139 $$locbase i48                ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r139 $r137 i24                    ; copy memory
addi $r140 $$locbase i136               ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r140 $r139 i24                    ; copy memory
lw $r141 $$locbase i17                  ; load word
lw $r143 $$locbase i18                  ; load word
lw $r145 $$locbase i19                  ; load word
addi $r146 $r145 i1
gt $r147 $r146 $r143
move $r148 $r141                        ; move parameter from branch to block argument
move $r149 $r143                        ; move parameter from branch to block argument
jnzi $r147 .72
ji  .73
.72
muli $r151 $r143 i2
addi $r152 $r151 i1
aloc $r152
mcp $hp $r141 $r145
move $r148 $hp                          ; move parameter from branch to block argument
move $r149 $r152                        ; move parameter from branch to block argument
.73
move $r157 $r148                        ; move parameter from branch to block argument
move $r159 $r149                        ; move parameter from branch to block argument
add $r160 $r148 $r145
sb $r160 $r127 i0                       ; store byte
addi $r161 $$locbase i184               ; get offset to local __ptr { ptr, u64, u64 }
sw $$locbase $r157 i23                  ; store word
sw $$locbase $r159 i24                  ; store word
sw $$locbase $r146 i25                  ; store word
addi $r165 $$locbase i72                ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r165 $r161 i24                    ; copy memory
mcpi $r136 $r165 i24                    ; copy memory
addi $r166 $$locbase i1192              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r166 $r136 i24                    ; copy memory
addi $r167 $$locbase i1192              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r168 $$locbase i800               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r168 $r167 i24                    ; copy memory
move $r124 $r168                        ; move parameter from branch to block argument
.71
addi $r172 $$locbase i824               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r172 $r124 i24                    ; copy memory
move $r173 $r172                        ; move parameter from branch to block argument
ji  .74
.59
addi $r174 $$locbase i208               ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
addi $r175 $r174 i55                    ; get offset to aggregate element
lb $r176 $r175 i0                       ; load byte
addi $r177 $$locbase i928               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r178 $$locbase i568               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r178 $r177 i24                    ; copy memory
addi $r179 $$locbase i288               ; get offset to local __ptr { { ptr, u64, u64 } }
movi $$arg0 i1                          ; [call: abi_encode_20]: pass argument 0
move $$arg1 $r178                       ; [call: abi_encode_20]: pass argument 1
move $$arg2 $r179                       ; [call: abi_encode_20]: pass argument 2
fncall .6                               ; [call: abi_encode_20]: call function
addi $r181 $$locbase i1048              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r181 $r179 i24                    ; copy memory
addi $r182 $$locbase i1048              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r183 $$locbase i952               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r183 $r182 i24                    ; copy memory
addi $r184 $$locbase i496               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r185 $$locbase i952               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $$locbase $r185 i24                ; copy memory
addi $r187 $$locbase i112               ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r187 $$locbase i24                ; copy memory
lw $r188 $$locbase i14                  ; load word
lw $r190 $$locbase i15                  ; load word
lw $r192 $$locbase i16                  ; load word
addi $r193 $r192 i1
gt $r194 $r193 $r190
move $r195 $r188                        ; move parameter from branch to block argument
move $r196 $r190                        ; move parameter from branch to block argument
jnzi $r194 .75
ji  .76
.75
muli $r198 $r190 i2
addi $r199 $r198 i1
aloc $r199
mcp $hp $r188 $r192
move $r195 $hp                          ; move parameter from branch to block argument
move $r196 $r199                        ; move parameter from branch to block argument
.76
move $r204 $r195                        ; move parameter from branch to block argument
move $r206 $r196                        ; move parameter from branch to block argument
add $r207 $r195 $r192
sb $r207 $r176 i0                       ; store byte
addi $r208 $$locbase i160               ; get offset to local __ptr { ptr, u64, u64 }
sw $$locbase $r204 i20                  ; store word
sw $$locbase $r206 i21                  ; store word
sw $$locbase $r193 i22                  ; store word
addi $r212 $$locbase i24                ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r212 $r208 i24                    ; copy memory
mcpi $r184 $r212 i24                    ; copy memory
addi $r213 $$locbase i1120              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r213 $r184 i24                    ; copy memory
addi $r214 $$locbase i1120              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r215 $$locbase i824               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r215 $r214 i24                    ; copy memory
move $r173 $r215                        ; move parameter from branch to block argument
.74
addi $r219 $$locbase i848               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r219 $r173 i24                    ; copy memory
move $r220 $r219                        ; move parameter from branch to block argument
ji  .77
.57
addi $r221 $$locbase i928               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r222 $$locbase i544               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r222 $r221 i24                    ; copy memory
addi $r223 $$locbase i264               ; get offset to local __ptr { { ptr, u64, u64 } }
movi $$arg0 i0                          ; [call: abi_encode_20]: pass argument 0
move $$arg1 $r222                       ; [call: abi_encode_20]: pass argument 1
move $$arg2 $r223                       ; [call: abi_encode_20]: pass argument 2
fncall .6                               ; [call: abi_encode_20]: call function
addi $r225 $$locbase i848               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r225 $r223 i24                    ; copy memory
move $r220 $r225                        ; move parameter from branch to block argument
.77
addi $r229 $$locbase i1312              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r229 $r220 i24                    ; copy memory
addi $r230 $$locbase i1312              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r231 $$locbase i904               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r231 $r230 i24                    ; copy memory
addi $r232 $$locbase i904               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r233 $$locbase i752               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r233 $r232 i24                    ; copy memory
addi $r234 $$locbase i480               ; get offset to local __ptr slice
move $$arg0 $r233                       ; [call: as_raw_slice_29]: pass argument 0
move $$arg1 $r234                       ; [call: as_raw_slice_29]: pass argument 1
fncall .12                              ; [call: as_raw_slice_29]: call function
addi $r236 $$locbase i872               ; get offset to local __ptr slice
mcpi $r236 $r234 i16                    ; copy memory
.78
mcpi $r13 $r236 i16                     ; copy memory
.5
cfsi i1520                              ; [fn end: encode_allow_alias_1] free: locals 1520 byte(s), call args 0 slot(s)
move $$reta $r14                        ; [fn end: encode_allow_alias_1] restore return address
popa .4                                 ; [fn end: encode_allow_alias_1] restore all used registers
jal $zero $$reta i0                     ; [fn end: encode_allow_alias_1] return from call
DIFF------------------------------
.program:
.4                                      ; --- start of function: encode_allow_alias_1 ---
pusha .4                                ; [fn init: encode_allow_alias_1]: push all used registers to stack
move $$locbase $sp                      ; [fn init: encode_allow_alias_1]: set locals base register
cfei i1520                              ; [fn init: encode_allow_alias_1]: allocate: locals 1520 byte(s), call args 0 slot(s)
move $r12 $$arg0                        ; [fn init: encode_allow_alias_1]: copy argument 0 (item)
move $r13 $$arg1                        ; [fn init: encode_allow_alias_1]: copy argument 1 (__ret_value)
move $r14 $$reta                        ; [fn init: encode_allow_alias_1]: save return address
.48
.50
.52
.54
.56
addi $r27 $$locbase i456                ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r27                        ; [call: new_28]: pass argument 0
fncall .10                              ; [call: new_28]: call function
addi $r29 $$locbase i1336               ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
mcpi $r29 $r12 i56                      ; copy memory
addi $r30 $$locbase i928                ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r30 $r27 i24                      ; copy memory
addi $r31 $$locbase i1336               ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
addi $r32 $$locbase i208                ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
mcpi $r32 $r31 i56                      ; copy memory
lw $r34 $$locbase i26                   ; load word
eq $r35 $r34 $zero
jnzi $r35 .57
.58
lw $r37 $$locbase i26                   ; load word
eq $r38 $r37 $one
jnzi $r38 .59
.60
lw $r40 $$locbase i26                   ; load word
movi $r41 i2                            ; initialize constant into register
eq $r42 $r40 $r41
jnzi $r42 .61
.62
lw $r44 $$locbase i26                   ; load word
movi $r45 i3                            ; initialize constant into register
eq $r46 $r44 $r45
jnzi $r46 .63
.64
lw $r48 $$locbase i26                   ; load word
movi $r49 i4                            ; initialize constant into register
eq $r50 $r48 $r49
jnzi $r50 .65
.66
load $r51 data_NonConfigurable_2        ; load constant from data section
rvrt $r51
.65
addi $r52 $$locbase i208                ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
addi $r53 $r52 i8                       ; get offset to aggregate element
addi $r54 $$locbase i1472               ; get offset to local __ptr [slice; 3]
mcpi $r54 $r53 i48                      ; copy memory
addi $r55 $$locbase i928                ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r56 $$locbase i688                ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r56 $r55 i24                      ; copy memory
addi $r57 $$locbase i408                ; get offset to local __ptr { { ptr, u64, u64 } }
movi $$arg0 i4                          ; [call: abi_encode_20]: pass argument 0
move $$arg1 $r56                        ; [call: abi_encode_20]: pass argument 1
move $$arg2 $r57                        ; [call: abi_encode_20]: pass argument 2
fncall .6                               ; [call: abi_encode_20]: call function
addi $r60 $$locbase i1264               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r60 $r57 i24                      ; copy memory
addi $r61 $$locbase i1472               ; get offset to local __ptr [slice; 3]
addi $r62 $$locbase i1264               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r63 $$locbase i1408               ; get offset to local __ptr [slice; 3]
mcpi $r63 $r61 i48                      ; copy memory
addi $r64 $$locbase i1024               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r64 $r62 i24                      ; copy memory
addi $r65 $$locbase i1024               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r66 $$locbase i1096               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r66 $r65 i24                      ; copy memory
movi $r67 i0                            ; move parameter from branch to block argument
.67
move $r69 $r67                          ; move parameter from branch to block argument
movi $r70 i3                            ; initialize constant into register
lt $r71 $r67 $r70
jnzi $r71 .68
.69
addi $r72 $$locbase i1096               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r73 $$locbase i1288               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r73 $r72 i24                      ; copy memory
addi $r74 $$locbase i1288               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r75 $$locbase i776                ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r75 $r74 i24                      ; copy memory
move $r76 $r75                          ; move parameter from branch to block argument
ji  .70
.68
addi $r77 $$locbase i1408               ; get offset to local __ptr [slice; 3]
muli $r79 $r69 i16                      ; get offset to array element
add $r79 $r77 $r79                      ; add array element offset to array base
addi $r80 $$locbase i1096               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r81 $$locbase i712                ; get offset to local __ptr slice
mcpi $r81 $r79 i16                      ; copy memory
addi $r82 $$locbase i728                ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r82 $r80 i24                      ; copy memory
addi $r83 $$locbase i432                ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r81                        ; [call: abi_encode_26]: pass argument 0
move $$arg1 $r82                        ; [call: abi_encode_26]: pass argument 1
move $$arg2 $r83                        ; [call: abi_encode_26]: pass argument 2
fncall .8                               ; [call: abi_encode_26]: call function
addi $r85 $$locbase i1096               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r85 $r83 i24                      ; copy memory
addi $r86 $r69 i1
move $r67 $r86                          ; move parameter from branch to block argument
ji  .67
.63
addi $r88 $$locbase i208                ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
addi $r89 $r88 i40                      ; get offset to aggregate element
addi $r90 $$locbase i1456               ; get offset to local __ptr { u64, u64 }
mcpi $r90 $r89 i16                      ; copy memory
addi $r91 $$locbase i928                ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r92 $$locbase i616                ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r92 $r91 i24                      ; copy memory
addi $r93 $$locbase i336                ; get offset to local __ptr { { ptr, u64, u64 } }
movi $$arg0 i3                          ; [call: abi_encode_20]: pass argument 0
move $$arg1 $r92                        ; [call: abi_encode_20]: pass argument 1
move $$arg2 $r93                        ; [call: abi_encode_20]: pass argument 2
fncall .6                               ; [call: abi_encode_20]: call function
addi $r96 $$locbase i1216               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r96 $r93 i24                      ; copy memory
addi $r97 $$locbase i1456               ; get offset to local __ptr { u64, u64 }
addi $r98 $$locbase i1216               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r99 $$locbase i1392               ; get offset to local __ptr { u64, u64 }
mcpi $r99 $r97 i16                      ; copy memory
addi $r100 $$locbase i1000              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r100 $r98 i24                     ; copy memory
lw $r102 $$locbase i174                 ; load word
addi $r103 $$locbase i1000              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r104 $$locbase i640               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r104 $r103 i24                    ; copy memory
addi $r105 $$locbase i360               ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r102                       ; [call: abi_encode_20]: pass argument 0
move $$arg1 $r104                       ; [call: abi_encode_20]: pass argument 1
move $$arg2 $r105                       ; [call: abi_encode_20]: pass argument 2
fncall .6                               ; [call: abi_encode_20]: call function
addi $r107 $$locbase i1072              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r107 $r105 i24                    ; copy memory
lw $r110 $$locbase i175                 ; load word
addi $r111 $$locbase i1072              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r112 $$locbase i664               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r112 $r111 i24                    ; copy memory
addi $r113 $$locbase i384               ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r110                       ; [call: abi_encode_20]: pass argument 0
move $$arg1 $r112                       ; [call: abi_encode_20]: pass argument 1
move $$arg2 $r113                       ; [call: abi_encode_20]: pass argument 2
fncall .6                               ; [call: abi_encode_20]: call function
addi $r115 $$locbase i1144              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r115 $r113 i24                    ; copy memory
addi $r116 $$locbase i1144              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r117 $$locbase i1240              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r117 $r116 i24                    ; copy memory
addi $r118 $$locbase i1240              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r119 $$locbase i776               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r119 $r118 i24                    ; copy memory
move $r76 $r119                         ; move parameter from branch to block argument
.70
addi $r123 $$locbase i800               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r123 $r76 i24                     ; copy memory
move $r124 $r123                        ; move parameter from branch to block argument
ji  .71
.61
addi $r125 $$locbase i208               ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
addi $r126 $r125 i55                    ; get offset to aggregate element
lb $r127 $r126 i0                       ; load byte
addi $r128 $$locbase i928               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r129 $$locbase i592               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r129 $r128 i24                    ; copy memory
addi $r130 $$locbase i312               ; get offset to local __ptr { { ptr, u64, u64 } }
movi $$arg0 i2                          ; [call: abi_encode_20]: pass argument 0
move $$arg1 $r129                       ; [call: abi_encode_20]: pass argument 1
move $$arg2 $r130                       ; [call: abi_encode_20]: pass argument 2
fncall .6                               ; [call: abi_encode_20]: call function
addi $r133 $$locbase i1168              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r133 $r130 i24                    ; copy memory
addi $r134 $$locbase i1168              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r135 $$locbase i976               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r135 $r134 i24                    ; copy memory
addi $r136 $$locbase i520               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r137 $$locbase i976               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r139 $$locbase i48                ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r139 $r137 i24                    ; copy memory
addi $r140 $$locbase i136               ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r140 $r139 i24                    ; copy memory
lw $r141 $$locbase i17                  ; load word
lw $r143 $$locbase i18                  ; load word
lw $r145 $$locbase i19                  ; load word
addi $r146 $r145 i1
gt $r147 $r146 $r143
move $r148 $r141                        ; move parameter from branch to block argument
move $r149 $r143                        ; move parameter from branch to block argument
jnzi $r147 .72
ji  .73
.72
muli $r151 $r143 i2
addi $r152 $r151 i1
aloc $r152
mcp $hp $r141 $r145
move $r148 $hp                          ; move parameter from branch to block argument
move $r149 $r152                        ; move parameter from branch to block argument
.73
move $r157 $r148                        ; move parameter from branch to block argument
move $r159 $r149                        ; move parameter from branch to block argument
add $r160 $r148 $r145
sb $r160 $r127 i0                       ; store byte
addi $r161 $$locbase i184               ; get offset to local __ptr { ptr, u64, u64 }
sw $$locbase $r157 i23                  ; store word
sw $$locbase $r159 i24                  ; store word
sw $$locbase $r146 i25                  ; store word
addi $r165 $$locbase i72                ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r165 $r161 i24                    ; copy memory
mcpi $r136 $r165 i24                    ; copy memory
addi $r166 $$locbase i1192              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r166 $r136 i24                    ; copy memory
addi $r167 $$locbase i1192              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r168 $$locbase i800               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r168 $r167 i24                    ; copy memory
move $r124 $r168                        ; move parameter from branch to block argument
.71
addi $r172 $$locbase i824               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r172 $r124 i24                    ; copy memory
move $r173 $r172                        ; move parameter from branch to block argument
ji  .74
.59
addi $r174 $$locbase i208               ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
addi $r175 $r174 i55                    ; get offset to aggregate element
lb $r176 $r175 i0                       ; load byte
addi $r177 $$locbase i928               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r178 $$locbase i568               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r178 $r177 i24                    ; copy memory
addi $r179 $$locbase i288               ; get offset to local __ptr { { ptr, u64, u64 } }
movi $$arg0 i1                          ; [call: abi_encode_20]: pass argument 0
move $$arg1 $r178                       ; [call: abi_encode_20]: pass argument 1
move $$arg2 $r179                       ; [call: abi_encode_20]: pass argument 2
fncall .6                               ; [call: abi_encode_20]: call function
addi $r181 $$locbase i1048              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r181 $r179 i24                    ; copy memory
addi $r182 $$locbase i1048              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r183 $$locbase i952               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r183 $r182 i24                    ; copy memory
addi $r184 $$locbase i496               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r185 $$locbase i952               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $$locbase $r185 i24                ; copy memory
addi $r187 $$locbase i112               ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r187 $$locbase i24                ; copy memory
lw $r188 $$locbase i14                  ; load word
lw $r190 $$locbase i15                  ; load word
lw $r192 $$locbase i16                  ; load word
addi $r193 $r192 i1
gt $r194 $r193 $r190
move $r195 $r188                        ; move parameter from branch to block argument
move $r196 $r190                        ; move parameter from branch to block argument
jnzi $r194 .75
ji  .76
.75
muli $r198 $r190 i2
addi $r199 $r198 i1
aloc $r199
mcp $hp $r188 $r192
move $r195 $hp                          ; move parameter from branch to block argument
move $r196 $r199                        ; move parameter from branch to block argument
.76
move $r204 $r195                        ; move parameter from branch to block argument
move $r206 $r196                        ; move parameter from branch to block argument
add $r207 $r195 $r192
sb $r207 $r176 i0                       ; store byte
addi $r208 $$locbase i160               ; get offset to local __ptr { ptr, u64, u64 }
sw $$locbase $r204 i20                  ; store word
sw $$locbase $r206 i21                  ; store word
sw $$locbase $r193 i22                  ; store word
addi $r212 $$locbase i24                ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r212 $r208 i24                    ; copy memory
mcpi $r184 $r212 i24                    ; copy memory
addi $r213 $$locbase i1120              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r213 $r184 i24                    ; copy memory
addi $r214 $$locbase i1120              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r215 $$locbase i824               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r215 $r214 i24                    ; copy memory
move $r173 $r215                        ; move parameter from branch to block argument
.74
addi $r219 $$locbase i848               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r219 $r173 i24                    ; copy memory
move $r220 $r219                        ; move parameter from branch to block argument
ji  .77
.57
addi $r221 $$locbase i928               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r222 $$locbase i544               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r222 $r221 i24                    ; copy memory
addi $r223 $$locbase i264               ; get offset to local __ptr { { ptr, u64, u64 } }
movi $$arg0 i0                          ; [call: abi_encode_20]: pass argument 0
move $$arg1 $r222                       ; [call: abi_encode_20]: pass argument 1
move $$arg2 $r223                       ; [call: abi_encode_20]: pass argument 2
fncall .6                               ; [call: abi_encode_20]: call function
addi $r225 $$locbase i848               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r225 $r223 i24                    ; copy memory
move $r220 $r225                        ; move parameter from branch to block argument
.77
addi $r229 $$locbase i1312              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r229 $r220 i24                    ; copy memory
addi $r230 $$locbase i1312              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r231 $$locbase i904               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r231 $r230 i24                    ; copy memory
addi $r232 $$locbase i904               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r233 $$locbase i752               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r233 $r232 i24                    ; copy memory
addi $r234 $$locbase i480               ; get offset to local __ptr slice
move $$arg0 $r233                       ; [call: as_raw_slice_29]: pass argument 0
move $$arg1 $r234                       ; [call: as_raw_slice_29]: pass argument 1
fncall .12                              ; [call: as_raw_slice_29]: call function
addi $r236 $$locbase i872               ; get offset to local __ptr slice
mcpi $r236 $r234 i16                    ; copy memory
.78
mcpi $r13 $r236 i16                     ; copy memory
.5
cfsi i1520                              ; [fn end: encode_allow_alias_1] free: locals 1520 byte(s), call args 0 slot(s)
move $$reta $r14                        ; [fn end: encode_allow_alias_1] restore return address
popa .4                                 ; [fn end: encode_allow_alias_1] restore all used registers
jal $zero $$reta i0                     ; [fn end: encode_allow_alias_1] return from call
DIFF------------------------------
.program:
.4                                      ; --- start of function: encode_allow_alias_1 ---
pusha .4                                ; [fn init: encode_allow_alias_1]: push all used registers to stack
move $$locbase $sp                      ; [fn init: encode_allow_alias_1]: set locals base register
cfei i1520                              ; [fn init: encode_allow_alias_1]: allocate: locals 1520 byte(s), call args 0 slot(s)
move $r12 $$arg0                        ; [fn init: encode_allow_alias_1]: copy argument 0 (item)
move $r13 $$arg1                        ; [fn init: encode_allow_alias_1]: copy argument 1 (__ret_value)
move $r14 $$reta                        ; [fn init: encode_allow_alias_1]: save return address
.48
.50
.52
.54
.56
addi $r27 $$locbase i456                ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r27                        ; [call: new_28]: pass argument 0
fncall .10                              ; [call: new_28]: call function
addi $r29 $$locbase i1336               ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
mcpi $r29 $r12 i56                      ; copy memory
addi $r30 $$locbase i928                ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r30 $r27 i24                      ; copy memory
addi $r31 $$locbase i1336               ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
addi $r32 $$locbase i208                ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
mcpi $r32 $r31 i56                      ; copy memory
lw $r34 $$locbase i26                   ; load word
eq $r35 $r34 $zero
jnzi $r35 .57
.58
lw $r37 $$locbase i26                   ; load word
eq $r38 $r37 $one
jnzi $r38 .59
.60
lw $r40 $$locbase i26                   ; load word
movi $r41 i2                            ; initialize constant into register
eq $r42 $r40 $r41
jnzi $r42 .61
.62
lw $r44 $$locbase i26                   ; load word
movi $r45 i3                            ; initialize constant into register
eq $r46 $r44 $r45
jnzi $r46 .63
.64
lw $r48 $$locbase i26                   ; load word
movi $r49 i4                            ; initialize constant into register
eq $r50 $r48 $r49
jnzi $r50 .65
.66
load $r51 data_NonConfigurable_2        ; load constant from data section
rvrt $r51
.65
addi $r52 $$locbase i208                ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
addi $r53 $r52 i8                       ; get offset to aggregate element
addi $r54 $$locbase i1472               ; get offset to local __ptr [slice; 3]
mcpi $r54 $r53 i48                      ; copy memory
addi $r55 $$locbase i928                ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r56 $$locbase i688                ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r56 $r55 i24                      ; copy memory
addi $r57 $$locbase i408                ; get offset to local __ptr { { ptr, u64, u64 } }
movi $$arg0 i4                          ; [call: abi_encode_20]: pass argument 0
move $$arg1 $r56                        ; [call: abi_encode_20]: pass argument 1
move $$arg2 $r57                        ; [call: abi_encode_20]: pass argument 2
fncall .6                               ; [call: abi_encode_20]: call function
addi $r60 $$locbase i1264               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r60 $r57 i24                      ; copy memory
addi $r61 $$locbase i1472               ; get offset to local __ptr [slice; 3]
addi $r62 $$locbase i1264               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r63 $$locbase i1408               ; get offset to local __ptr [slice; 3]
mcpi $r63 $r61 i48                      ; copy memory
addi $r64 $$locbase i1024               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r64 $r62 i24                      ; copy memory
addi $r65 $$locbase i1024               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r66 $$locbase i1096               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r66 $r65 i24                      ; copy memory
movi $r67 i0                            ; move parameter from branch to block argument
.67
move $r69 $r67                          ; move parameter from branch to block argument
movi $r70 i3                            ; initialize constant into register
lt $r71 $r67 $r70
jnzi $r71 .68
.69
addi $r72 $$locbase i1096               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r73 $$locbase i1288               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r73 $r72 i24                      ; copy memory
addi $r74 $$locbase i1288               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r75 $$locbase i776                ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r75 $r74 i24                      ; copy memory
move $r76 $r75                          ; move parameter from branch to block argument
ji  .70
.68
addi $r77 $$locbase i1408               ; get offset to local __ptr [slice; 3]
muli $r79 $r69 i16                      ; get offset to array element
add $r79 $r77 $r79                      ; add array element offset to array base
addi $r80 $$locbase i1096               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r81 $$locbase i712                ; get offset to local __ptr slice
mcpi $r81 $r79 i16                      ; copy memory
addi $r82 $$locbase i728                ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r82 $r80 i24                      ; copy memory
addi $r83 $$locbase i432                ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r81                        ; [call: abi_encode_26]: pass argument 0
move $$arg1 $r82                        ; [call: abi_encode_26]: pass argument 1
move $$arg2 $r83                        ; [call: abi_encode_26]: pass argument 2
fncall .8                               ; [call: abi_encode_26]: call function
addi $r85 $$locbase i1096               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r85 $r83 i24                      ; copy memory
addi $r86 $r69 i1
move $r67 $r86                          ; move parameter from branch to block argument
ji  .67
.63
addi $r88 $$locbase i208                ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
addi $r89 $r88 i40                      ; get offset to aggregate element
addi $r90 $$locbase i1456               ; get offset to local __ptr { u64, u64 }
mcpi $r90 $r89 i16                      ; copy memory
addi $r91 $$locbase i928                ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r92 $$locbase i616                ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r92 $r91 i24                      ; copy memory
addi $r93 $$locbase i336                ; get offset to local __ptr { { ptr, u64, u64 } }
movi $$arg0 i3                          ; [call: abi_encode_20]: pass argument 0
move $$arg1 $r92                        ; [call: abi_encode_20]: pass argument 1
move $$arg2 $r93                        ; [call: abi_encode_20]: pass argument 2
fncall .6                               ; [call: abi_encode_20]: call function
addi $r96 $$locbase i1216               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r96 $r93 i24                      ; copy memory
addi $r97 $$locbase i1456               ; get offset to local __ptr { u64, u64 }
addi $r98 $$locbase i1216               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r99 $$locbase i1392               ; get offset to local __ptr { u64, u64 }
mcpi $r99 $r97 i16                      ; copy memory
addi $r100 $$locbase i1000              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r100 $r98 i24                     ; copy memory
lw $r102 $$locbase i174                 ; load word
addi $r103 $$locbase i1000              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r104 $$locbase i640               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r104 $r103 i24                    ; copy memory
addi $r105 $$locbase i360               ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r102                       ; [call: abi_encode_20]: pass argument 0
move $$arg1 $r104                       ; [call: abi_encode_20]: pass argument 1
move $$arg2 $r105                       ; [call: abi_encode_20]: pass argument 2
fncall .6                               ; [call: abi_encode_20]: call function
addi $r107 $$locbase i1072              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r107 $r105 i24                    ; copy memory
lw $r110 $$locbase i175                 ; load word
addi $r111 $$locbase i1072              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r112 $$locbase i664               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r112 $r111 i24                    ; copy memory
addi $r113 $$locbase i384               ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r110                       ; [call: abi_encode_20]: pass argument 0
move $$arg1 $r112                       ; [call: abi_encode_20]: pass argument 1
move $$arg2 $r113                       ; [call: abi_encode_20]: pass argument 2
fncall .6                               ; [call: abi_encode_20]: call function
addi $r115 $$locbase i1144              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r115 $r113 i24                    ; copy memory
addi $r116 $$locbase i1144              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r117 $$locbase i1240              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r117 $r116 i24                    ; copy memory
addi $r118 $$locbase i1240              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r119 $$locbase i776               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r119 $r118 i24                    ; copy memory
move $r76 $r119                         ; move parameter from branch to block argument
.70
addi $r123 $$locbase i800               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r123 $r76 i24                     ; copy memory
move $r124 $r123                        ; move parameter from branch to block argument
ji  .71
.61
addi $r125 $$locbase i208               ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
addi $r126 $r125 i55                    ; get offset to aggregate element
lb $r127 $r126 i0                       ; load byte
addi $r128 $$locbase i928               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r129 $$locbase i592               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r129 $r128 i24                    ; copy memory
addi $r130 $$locbase i312               ; get offset to local __ptr { { ptr, u64, u64 } }
movi $$arg0 i2                          ; [call: abi_encode_20]: pass argument 0
move $$arg1 $r129                       ; [call: abi_encode_20]: pass argument 1
move $$arg2 $r130                       ; [call: abi_encode_20]: pass argument 2
fncall .6                               ; [call: abi_encode_20]: call function
addi $r133 $$locbase i1168              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r133 $r130 i24                    ; copy memory
addi $r134 $$locbase i1168              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r135 $$locbase i976               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r135 $r134 i24                    ; copy memory
addi $r136 $$locbase i520               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r137 $$locbase i976               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r139 $$locbase i48                ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r139 $r137 i24                    ; copy memory
addi $r140 $$locbase i136               ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r140 $r139 i24                    ; copy memory
lw $r141 $$locbase i17                  ; load word
lw $r143 $$locbase i18                  ; load word
lw $r145 $$locbase i19                  ; load word
addi $r146 $r145 i1
gt $r147 $r146 $r143
move $r148 $r141                        ; move parameter from branch to block argument
move $r149 $r143                        ; move parameter from branch to block argument
jnzi $r147 .72
ji  .73
.72
muli $r151 $r143 i2
addi $r152 $r151 i1
aloc $r152
mcp $hp $r141 $r145
move $r148 $hp                          ; move parameter from branch to block argument
move $r149 $r152                        ; move parameter from branch to block argument
.73
move $r157 $r148                        ; move parameter from branch to block argument
move $r159 $r149                        ; move parameter from branch to block argument
add $r160 $r148 $r145
sb $r160 $r127 i0                       ; store byte
addi $r161 $$locbase i184               ; get offset to local __ptr { ptr, u64, u64 }
sw $$locbase $r157 i23                  ; store word
sw $$locbase $r159 i24                  ; store word
sw $$locbase $r146 i25                  ; store word
addi $r165 $$locbase i72                ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r165 $r161 i24                    ; copy memory
mcpi $r136 $r165 i24                    ; copy memory
addi $r166 $$locbase i1192              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r166 $r136 i24                    ; copy memory
addi $r167 $$locbase i1192              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r168 $$locbase i800               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r168 $r167 i24                    ; copy memory
move $r124 $r168                        ; move parameter from branch to block argument
.71
addi $r172 $$locbase i824               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r172 $r124 i24                    ; copy memory
move $r173 $r172                        ; move parameter from branch to block argument
ji  .74
.59
addi $r174 $$locbase i208               ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
addi $r175 $r174 i55                    ; get offset to aggregate element
lb $r176 $r175 i0                       ; load byte
addi $r177 $$locbase i928               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r178 $$locbase i568               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r178 $r177 i24                    ; copy memory
addi $r179 $$locbase i288               ; get offset to local __ptr { { ptr, u64, u64 } }
movi $$arg0 i1                          ; [call: abi_encode_20]: pass argument 0
move $$arg1 $r178                       ; [call: abi_encode_20]: pass argument 1
move $$arg2 $r179                       ; [call: abi_encode_20]: pass argument 2
fncall .6                               ; [call: abi_encode_20]: call function
addi $r181 $$locbase i1048              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r181 $r179 i24                    ; copy memory
addi $r182 $$locbase i1048              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r183 $$locbase i952               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r183 $r182 i24                    ; copy memory
addi $r184 $$locbase i496               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r185 $$locbase i952               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $$locbase $r185 i24                ; copy memory
addi $r187 $$locbase i112               ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r187 $$locbase i24                ; copy memory
lw $r188 $$locbase i14                  ; load word
lw $r190 $$locbase i15                  ; load word
lw $r192 $$locbase i16                  ; load word
addi $r193 $r192 i1
gt $r194 $r193 $r190
move $r195 $r188                        ; move parameter from branch to block argument
move $r196 $r190                        ; move parameter from branch to block argument
jnzi $r194 .75
ji  .76
.75
muli $r198 $r190 i2
addi $r199 $r198 i1
aloc $r199
mcp $hp $r188 $r192
move $r195 $hp                          ; move parameter from branch to block argument
move $r196 $r199                        ; move parameter from branch to block argument
.76
move $r204 $r195                        ; move parameter from branch to block argument
move $r206 $r196                        ; move parameter from branch to block argument
add $r207 $r195 $r192
sb $r207 $r176 i0                       ; store byte
addi $r208 $$locbase i160               ; get offset to local __ptr { ptr, u64, u64 }
sw $$locbase $r204 i20                  ; store word
sw $$locbase $r206 i21                  ; store word
sw $$locbase $r193 i22                  ; store word
addi $r212 $$locbase i24                ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r212 $r208 i24                    ; copy memory
mcpi $r184 $r212 i24                    ; copy memory
addi $r213 $$locbase i1120              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r213 $r184 i24                    ; copy memory
addi $r214 $$locbase i1120              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r215 $$locbase i824               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r215 $r214 i24                    ; copy memory
move $r173 $r215                        ; move parameter from branch to block argument
.74
addi $r219 $$locbase i848               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r219 $r173 i24                    ; copy memory
move $r220 $r219                        ; move parameter from branch to block argument
ji  .77
.57
addi $r221 $$locbase i928               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r222 $$locbase i544               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r222 $r221 i24                    ; copy memory
addi $r223 $$locbase i264               ; get offset to local __ptr { { ptr, u64, u64 } }
movi $$arg0 i0                          ; [call: abi_encode_20]: pass argument 0
move $$arg1 $r222                       ; [call: abi_encode_20]: pass argument 1
move $$arg2 $r223                       ; [call: abi_encode_20]: pass argument 2
fncall .6                               ; [call: abi_encode_20]: call function
addi $r225 $$locbase i848               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r225 $r223 i24                    ; copy memory
move $r220 $r225                        ; move parameter from branch to block argument
.77
addi $r229 $$locbase i1312              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r229 $r220 i24                    ; copy memory
addi $r230 $$locbase i1312              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r231 $$locbase i904               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r231 $r230 i24                    ; copy memory
addi $r232 $$locbase i904               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r233 $$locbase i752               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r233 $r232 i24                    ; copy memory
addi $r234 $$locbase i480               ; get offset to local __ptr slice
move $$arg0 $r233                       ; [call: as_raw_slice_29]: pass argument 0
move $$arg1 $r234                       ; [call: as_raw_slice_29]: pass argument 1
fncall .12                              ; [call: as_raw_slice_29]: call function
addi $r236 $$locbase i872               ; get offset to local __ptr slice
mcpi $r236 $r234 i16                    ; copy memory
.78
mcpi $r13 $r236 i16                     ; copy memory
.5
cfsi i1520                              ; [fn end: encode_allow_alias_1] free: locals 1520 byte(s), call args 0 slot(s)
move $$reta $r14                        ; [fn end: encode_allow_alias_1] restore return address
popa .4                                 ; [fn end: encode_allow_alias_1] restore all used registers
jal $zero $$reta i0                     ; [fn end: encode_allow_alias_1] return from call
DIFF------------------------------
.program:
.6                                      ; --- start of function: abi_encode_20 ---
pusha .6                                ; [fn init: abi_encode_20]: push all used registers to stack
move $$locbase $sp                      ; [fn init: abi_encode_20]: set locals base register
cfei i144                               ; [fn init: abi_encode_20]: allocate: locals 144 byte(s), call args 0 slot(s)
.79
addi $r247 $$locbase i120               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r247 $$arg1 i24                   ; copy memory
addi $r248 $$locbase i96                ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r249 $$locbase i120               ; get offset to local __ptr { { ptr, u64, u64 } }
move $r250 $r249                        ; return value from ASM block with return register buffer
 mcpi $$locbase $r250 i24                ; copy memory
 mcpi $$locbase $r249 i24                ; copy memory
addi $r251 $$locbase i48                ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r251 $$locbase i24                ; copy memory
lw $r252 $$locbase i6                   ; load word
addi $r253 $r251 i8                     ; get offset to aggregate element
lw $r254 $$locbase i7                   ; load word
addi $r255 $r251 i16                    ; get offset to aggregate element
lw $r256 $$locbase i8                   ; load word
movi $r257 i8                           ; initialize constant into register
 add $r258 $r256 $r257
 addi $r258 $r256 i8
gt $r259 $r258 $r254
move $r260 $r252                        ; move parameter from branch to block argument
move $r261 $r254                        ; move parameter from branch to block argument
jnzi $r259 .80
ji  .81
.80
movi $r262 i2                           ; initialize constant into register
 mul $r263 $r254 $r262
 muli $r263 $r254 i2
movi $r264 i8                           ; initialize constant into register
 add $r265 $r263 $r264
 addi $r265 $r263 i8
aloc $r265
mcp $hp $r252 $r256
move $r266 $hp                          ; return value from ASM block with return register hp
 move $r260 $r266                        ; move parameter from branch to block argument
 move $r260 $hp                          ; move parameter from branch to block argument
move $r261 $r265                        ; move parameter from branch to block argument
ji  .81
.81
move $r270 $r260                        ; move parameter from branch to block argument
move $r272 $r261                        ; move parameter from branch to block argument
 add $r273 $r270 $r256
 add $r273 $r260 $r256
sw $r273 $$arg0 i0                      ; store word
addi $r274 $$locbase i72                ; get offset to local __ptr { ptr, u64, u64 }
sw $$locbase $r270 i9                   ; store word
addi $r275 $r274 i8                     ; get offset to aggregate element
sw $$locbase $r272 i10                  ; store word
addi $r276 $r274 i16                    ; get offset to aggregate element
sw $$locbase $r258 i11                  ; store word
move $r277 $r274                        ; return value from ASM block with return register buffer
addi $r278 $$locbase i24                ; get offset to local __ptr { ptr, u64, u64 }
 mcpi $r278 $r277 i24                    ; copy memory
 mcpi $r278 $r274 i24                    ; copy memory
mcpi $r248 $r278 i24                    ; copy memory
mcpi $$arg2 $r248 i24                   ; copy memory
ji  .7
.7
cfsi i144                               ; [fn end: abi_encode_20] free: locals 144 byte(s), call args 0 slot(s)
popa .6                                 ; [fn end: abi_encode_20] restore all used registers
jal $zero $$reta i0                     ; [fn end: abi_encode_20] return from call
DIFF------------------------------
.program:
.6                                      ; --- start of function: abi_encode_20 ---
pusha .6                                ; [fn init: abi_encode_20]: push all used registers to stack
move $$locbase $sp                      ; [fn init: abi_encode_20]: set locals base register
cfei i144                               ; [fn init: abi_encode_20]: allocate: locals 144 byte(s), call args 0 slot(s)
.79
addi $r247 $$locbase i120               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r247 $$arg1 i24                   ; copy memory
addi $r248 $$locbase i96                ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r249 $$locbase i120               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $$locbase $r249 i24                ; copy memory
addi $r251 $$locbase i48                ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r251 $$locbase i24                ; copy memory
lw $r252 $$locbase i6                   ; load word
lw $r254 $$locbase i7                   ; load word
lw $r256 $$locbase i8                   ; load word
addi $r258 $r256 i8
gt $r259 $r258 $r254
move $r260 $r252                        ; move parameter from branch to block argument
move $r261 $r254                        ; move parameter from branch to block argument
jnzi $r259 .80
ji  .81
.80
muli $r263 $r254 i2
addi $r265 $r263 i8
aloc $r265
mcp $hp $r252 $r256
move $r260 $hp                          ; move parameter from branch to block argument
move $r261 $r265                        ; move parameter from branch to block argument
.81
move $r270 $r260                        ; move parameter from branch to block argument
move $r272 $r261                        ; move parameter from branch to block argument
add $r273 $r260 $r256
sw $r273 $$arg0 i0                      ; store word
addi $r274 $$locbase i72                ; get offset to local __ptr { ptr, u64, u64 }
sw $$locbase $r270 i9                   ; store word
sw $$locbase $r272 i10                  ; store word
sw $$locbase $r258 i11                  ; store word
addi $r278 $$locbase i24                ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r278 $r274 i24                    ; copy memory
mcpi $r248 $r278 i24                    ; copy memory
mcpi $$arg2 $r248 i24                   ; copy memory
.7
cfsi i144                               ; [fn end: abi_encode_20] free: locals 144 byte(s), call args 0 slot(s)
popa .6                                 ; [fn end: abi_encode_20] restore all used registers
jal $zero $$reta i0                     ; [fn end: abi_encode_20] return from call
DIFF------------------------------
.program:
.6                                      ; --- start of function: abi_encode_20 ---
pusha .6                                ; [fn init: abi_encode_20]: push all used registers to stack
move $$locbase $sp                      ; [fn init: abi_encode_20]: set locals base register
cfei i144                               ; [fn init: abi_encode_20]: allocate: locals 144 byte(s), call args 0 slot(s)
.79
addi $r247 $$locbase i120               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r247 $$arg1 i24                   ; copy memory
addi $r248 $$locbase i96                ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r249 $$locbase i120               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $$locbase $r249 i24                ; copy memory
addi $r251 $$locbase i48                ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r251 $$locbase i24                ; copy memory
lw $r252 $$locbase i6                   ; load word
lw $r254 $$locbase i7                   ; load word
lw $r256 $$locbase i8                   ; load word
addi $r258 $r256 i8
gt $r259 $r258 $r254
move $r260 $r252                        ; move parameter from branch to block argument
move $r261 $r254                        ; move parameter from branch to block argument
jnzi $r259 .80
ji  .81
.80
muli $r263 $r254 i2
addi $r265 $r263 i8
aloc $r265
mcp $hp $r252 $r256
move $r260 $hp                          ; move parameter from branch to block argument
move $r261 $r265                        ; move parameter from branch to block argument
.81
move $r270 $r260                        ; move parameter from branch to block argument
move $r272 $r261                        ; move parameter from branch to block argument
add $r273 $r260 $r256
sw $r273 $$arg0 i0                      ; store word
addi $r274 $$locbase i72                ; get offset to local __ptr { ptr, u64, u64 }
sw $$locbase $r270 i9                   ; store word
sw $$locbase $r272 i10                  ; store word
sw $$locbase $r258 i11                  ; store word
addi $r278 $$locbase i24                ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r278 $r274 i24                    ; copy memory
mcpi $r248 $r278 i24                    ; copy memory
mcpi $$arg2 $r248 i24                   ; copy memory
.7
cfsi i144                               ; [fn end: abi_encode_20] free: locals 144 byte(s), call args 0 slot(s)
popa .6                                 ; [fn end: abi_encode_20] restore all used registers
jal $zero $$reta i0                     ; [fn end: abi_encode_20] return from call
DIFF------------------------------
.program:
.6                                      ; --- start of function: abi_encode_20 ---
pusha .6                                ; [fn init: abi_encode_20]: push all used registers to stack
move $$locbase $sp                      ; [fn init: abi_encode_20]: set locals base register
cfei i144                               ; [fn init: abi_encode_20]: allocate: locals 144 byte(s), call args 0 slot(s)
.79
addi $r247 $$locbase i120               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r247 $$arg1 i24                   ; copy memory
addi $r248 $$locbase i96                ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r249 $$locbase i120               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $$locbase $r249 i24                ; copy memory
addi $r251 $$locbase i48                ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r251 $$locbase i24                ; copy memory
lw $r252 $$locbase i6                   ; load word
lw $r254 $$locbase i7                   ; load word
lw $r256 $$locbase i8                   ; load word
addi $r258 $r256 i8
gt $r259 $r258 $r254
move $r260 $r252                        ; move parameter from branch to block argument
move $r261 $r254                        ; move parameter from branch to block argument
jnzi $r259 .80
ji  .81
.80
muli $r263 $r254 i2
addi $r265 $r263 i8
aloc $r265
mcp $hp $r252 $r256
move $r260 $hp                          ; move parameter from branch to block argument
move $r261 $r265                        ; move parameter from branch to block argument
.81
move $r270 $r260                        ; move parameter from branch to block argument
move $r272 $r261                        ; move parameter from branch to block argument
add $r273 $r260 $r256
sw $r273 $$arg0 i0                      ; store word
addi $r274 $$locbase i72                ; get offset to local __ptr { ptr, u64, u64 }
sw $$locbase $r270 i9                   ; store word
sw $$locbase $r272 i10                  ; store word
sw $$locbase $r258 i11                  ; store word
addi $r278 $$locbase i24                ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r278 $r274 i24                    ; copy memory
mcpi $r248 $r278 i24                    ; copy memory
mcpi $$arg2 $r248 i24                   ; copy memory
.7
cfsi i144                               ; [fn end: abi_encode_20] free: locals 144 byte(s), call args 0 slot(s)
popa .6                                 ; [fn end: abi_encode_20] restore all used registers
jal $zero $$reta i0                     ; [fn end: abi_encode_20] return from call
DIFF------------------------------
.program:
.8                                      ; --- start of function: abi_encode_26 ---
pusha .8                                ; [fn init: abi_encode_26]: push all used registers to stack
move $$locbase $sp                      ; [fn init: abi_encode_26]: set locals base register
cfei i224                               ; [fn init: abi_encode_26]: allocate: locals 224 byte(s), call args 0 slot(s)
.82
addi $r280 $$locbase i208               ; get offset to local __ptr slice
mcpi $r280 $$arg0 i16                   ; copy memory
addi $r281 $$locbase i184               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r281 $$arg1 i24                   ; copy memory
addi $r282 $$locbase i160               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r283 $$locbase i184               ; get offset to local __ptr { { ptr, u64, u64 } }
move $r284 $r283                        ; return value from ASM block with return register buffer
 mcpi $$locbase $r284 i24                ; copy memory
 mcpi $$locbase $r283 i24                ; copy memory
addi $r285 $$locbase i80                ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r285 $$locbase i24                ; copy memory
lw $r286 $$locbase i10                  ; load word
addi $r287 $r285 i8                     ; get offset to aggregate element
lw $r288 $$locbase i11                  ; load word
addi $r289 $r285 i16                    ; get offset to aggregate element
lw $r290 $$locbase i12                  ; load word
addi $r291 $$locbase i208               ; get offset to local __ptr slice
addi $r292 $$locbase i40                ; get offset to local __ptr slice
mcpi $r292 $r291 i16                    ; copy memory
move $r293 $r291                        ; return value from ASM block with return register item
addi $r294 $$locbase i24                ; get offset to local __ptr { u64, u64 }
 mcpi $r294 $r293 i16                    ; copy memory
 mcpi $r294 $r291 i16                    ; copy memory
addi $r295 $$locbase i104               ; get offset to local __ptr { u64, u64 }
mcpi $r295 $r294 i16                    ; copy memory
addi $r296 $r295 i8                     ; get offset to aggregate element
lw $r297 $$locbase i14                  ; load word
movi $r298 i8                           ; initialize constant into register
 add $r299 $r297 $r298
 addi $r299 $r297 i8
add $r300 $r290 $r299
gt $r301 $r300 $r288
move $r302 $r286                        ; move parameter from branch to block argument
move $r303 $r288                        ; move parameter from branch to block argument
jnzi $r301 .83
ji  .84
.83
movi $r304 i2                           ; initialize constant into register
 mul $r305 $r288 $r304
 muli $r305 $r288 i2
add $r306 $r305 $r299
aloc $r306
mcp $hp $r286 $r290
move $r307 $hp                          ; return value from ASM block with return register hp
 move $r302 $r307                        ; move parameter from branch to block argument
 move $r302 $hp                          ; move parameter from branch to block argument
move $r303 $r306                        ; move parameter from branch to block argument
ji  .84
.84
move $r311 $r302                        ; move parameter from branch to block argument
move $r313 $r303                        ; move parameter from branch to block argument
addi $r314 $$locbase i120               ; get offset to local __ptr slice
mcpi $r314 $r292 i16                    ; copy memory
add $r315 $r311 $r290
lw $r317 $$locbase i16
sw $r315 $r317 i0
addi $r315 $r315 i8
lw $r316 $$locbase i15
mcp $r315 $r316 $r317
addi $r318 $r290 i8
add $r318 $r318 $r317
move $r319 $r318                        ; return value from ASM block with return register new_len
addi $r320 $$locbase i136               ; get offset to local __ptr { ptr, u64, u64 }
sw $$locbase $r311 i17                  ; store word
addi $r321 $r320 i8                     ; get offset to aggregate element
sw $$locbase $r313 i18                  ; store word
addi $r322 $r320 i16                    ; get offset to aggregate element
sw $$locbase $r319 i19                  ; store word
move $r323 $r320                        ; return value from ASM block with return register buffer
addi $r324 $$locbase i56                ; get offset to local __ptr { ptr, u64, u64 }
 mcpi $r324 $r323 i24                    ; copy memory
 mcpi $r324 $r320 i24                    ; copy memory
mcpi $r282 $r324 i24                    ; copy memory
mcpi $$arg2 $r282 i24                   ; copy memory
ji  .9
.9
cfsi i224                               ; [fn end: abi_encode_26] free: locals 224 byte(s), call args 0 slot(s)
popa .8                                 ; [fn end: abi_encode_26] restore all used registers
jal $zero $$reta i0                     ; [fn end: abi_encode_26] return from call
DIFF------------------------------
.program:
.8                                      ; --- start of function: abi_encode_26 ---
pusha .8                                ; [fn init: abi_encode_26]: push all used registers to stack
move $$locbase $sp                      ; [fn init: abi_encode_26]: set locals base register
cfei i224                               ; [fn init: abi_encode_26]: allocate: locals 224 byte(s), call args 0 slot(s)
.82
addi $r280 $$locbase i208               ; get offset to local __ptr slice
mcpi $r280 $$arg0 i16                   ; copy memory
addi $r281 $$locbase i184               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r281 $$arg1 i24                   ; copy memory
addi $r282 $$locbase i160               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r283 $$locbase i184               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $$locbase $r283 i24                ; copy memory
addi $r285 $$locbase i80                ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r285 $$locbase i24                ; copy memory
lw $r286 $$locbase i10                  ; load word
lw $r288 $$locbase i11                  ; load word
lw $r290 $$locbase i12                  ; load word
addi $r291 $$locbase i208               ; get offset to local __ptr slice
addi $r292 $$locbase i40                ; get offset to local __ptr slice
mcpi $r292 $r291 i16                    ; copy memory
addi $r294 $$locbase i24                ; get offset to local __ptr { u64, u64 }
mcpi $r294 $r291 i16                    ; copy memory
addi $r295 $$locbase i104               ; get offset to local __ptr { u64, u64 }
mcpi $r295 $r294 i16                    ; copy memory
lw $r297 $$locbase i14                  ; load word
addi $r299 $r297 i8
add $r300 $r290 $r299
gt $r301 $r300 $r288
move $r302 $r286                        ; move parameter from branch to block argument
move $r303 $r288                        ; move parameter from branch to block argument
jnzi $r301 .83
ji  .84
.83
muli $r305 $r288 i2
add $r306 $r305 $r299
aloc $r306
mcp $hp $r286 $r290
move $r302 $hp                          ; move parameter from branch to block argument
move $r303 $r306                        ; move parameter from branch to block argument
.84
move $r311 $r302                        ; move parameter from branch to block argument
move $r313 $r303                        ; move parameter from branch to block argument
addi $r314 $$locbase i120               ; get offset to local __ptr slice
mcpi $r314 $r292 i16                    ; copy memory
add $r315 $r311 $r290
lw $r317 $$locbase i16
sw $r315 $r317 i0
addi $r315 $r315 i8
lw $r316 $$locbase i15
mcp $r315 $r316 $r317
addi $r318 $r290 i8
add $r318 $r318 $r317
move $r319 $r318                        ; return value from ASM block with return register new_len
addi $r320 $$locbase i136               ; get offset to local __ptr { ptr, u64, u64 }
sw $$locbase $r311 i17                  ; store word
sw $$locbase $r313 i18                  ; store word
sw $$locbase $r319 i19                  ; store word
addi $r324 $$locbase i56                ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r324 $r320 i24                    ; copy memory
mcpi $r282 $r324 i24                    ; copy memory
mcpi $$arg2 $r282 i24                   ; copy memory
.9
cfsi i224                               ; [fn end: abi_encode_26] free: locals 224 byte(s), call args 0 slot(s)
popa .8                                 ; [fn end: abi_encode_26] restore all used registers
jal $zero $$reta i0                     ; [fn end: abi_encode_26] return from call
DIFF------------------------------
.program:
.8                                      ; --- start of function: abi_encode_26 ---
pusha .8                                ; [fn init: abi_encode_26]: push all used registers to stack
move $$locbase $sp                      ; [fn init: abi_encode_26]: set locals base register
cfei i224                               ; [fn init: abi_encode_26]: allocate: locals 224 byte(s), call args 0 slot(s)
.82
addi $r280 $$locbase i208               ; get offset to local __ptr slice
mcpi $r280 $$arg0 i16                   ; copy memory
addi $r281 $$locbase i184               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r281 $$arg1 i24                   ; copy memory
addi $r282 $$locbase i160               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r283 $$locbase i184               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $$locbase $r283 i24                ; copy memory
addi $r285 $$locbase i80                ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r285 $$locbase i24                ; copy memory
lw $r286 $$locbase i10                  ; load word
lw $r288 $$locbase i11                  ; load word
lw $r290 $$locbase i12                  ; load word
addi $r291 $$locbase i208               ; get offset to local __ptr slice
addi $r292 $$locbase i40                ; get offset to local __ptr slice
mcpi $r292 $r291 i16                    ; copy memory
addi $r294 $$locbase i24                ; get offset to local __ptr { u64, u64 }
mcpi $r294 $r291 i16                    ; copy memory
addi $r295 $$locbase i104               ; get offset to local __ptr { u64, u64 }
mcpi $r295 $r294 i16                    ; copy memory
lw $r297 $$locbase i14                  ; load word
addi $r299 $r297 i8
add $r300 $r290 $r299
gt $r301 $r300 $r288
move $r302 $r286                        ; move parameter from branch to block argument
move $r303 $r288                        ; move parameter from branch to block argument
jnzi $r301 .83
ji  .84
.83
muli $r305 $r288 i2
add $r306 $r305 $r299
aloc $r306
mcp $hp $r286 $r290
move $r302 $hp                          ; move parameter from branch to block argument
move $r303 $r306                        ; move parameter from branch to block argument
.84
move $r311 $r302                        ; move parameter from branch to block argument
move $r313 $r303                        ; move parameter from branch to block argument
addi $r314 $$locbase i120               ; get offset to local __ptr slice
mcpi $r314 $r292 i16                    ; copy memory
add $r315 $r311 $r290
lw $r317 $$locbase i16
sw $r315 $r317 i0
addi $r315 $r315 i8
lw $r316 $$locbase i15
mcp $r315 $r316 $r317
addi $r318 $r290 i8
add $r318 $r318 $r317
move $r319 $r318                        ; return value from ASM block with return register new_len
addi $r320 $$locbase i136               ; get offset to local __ptr { ptr, u64, u64 }
sw $$locbase $r311 i17                  ; store word
sw $$locbase $r313 i18                  ; store word
sw $$locbase $r319 i19                  ; store word
addi $r324 $$locbase i56                ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r324 $r320 i24                    ; copy memory
mcpi $r282 $r324 i24                    ; copy memory
mcpi $$arg2 $r282 i24                   ; copy memory
.9
cfsi i224                               ; [fn end: abi_encode_26] free: locals 224 byte(s), call args 0 slot(s)
popa .8                                 ; [fn end: abi_encode_26] restore all used registers
jal $zero $$reta i0                     ; [fn end: abi_encode_26] return from call
DIFF------------------------------
.program:
.8                                      ; --- start of function: abi_encode_26 ---
pusha .8                                ; [fn init: abi_encode_26]: push all used registers to stack
move $$locbase $sp                      ; [fn init: abi_encode_26]: set locals base register
cfei i224                               ; [fn init: abi_encode_26]: allocate: locals 224 byte(s), call args 0 slot(s)
.82
addi $r280 $$locbase i208               ; get offset to local __ptr slice
mcpi $r280 $$arg0 i16                   ; copy memory
addi $r281 $$locbase i184               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r281 $$arg1 i24                   ; copy memory
addi $r282 $$locbase i160               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r283 $$locbase i184               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $$locbase $r283 i24                ; copy memory
addi $r285 $$locbase i80                ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r285 $$locbase i24                ; copy memory
lw $r286 $$locbase i10                  ; load word
lw $r288 $$locbase i11                  ; load word
lw $r290 $$locbase i12                  ; load word
addi $r291 $$locbase i208               ; get offset to local __ptr slice
addi $r292 $$locbase i40                ; get offset to local __ptr slice
mcpi $r292 $r291 i16                    ; copy memory
addi $r294 $$locbase i24                ; get offset to local __ptr { u64, u64 }
mcpi $r294 $r291 i16                    ; copy memory
addi $r295 $$locbase i104               ; get offset to local __ptr { u64, u64 }
mcpi $r295 $r294 i16                    ; copy memory
lw $r297 $$locbase i14                  ; load word
addi $r299 $r297 i8
add $r300 $r290 $r299
gt $r301 $r300 $r288
move $r302 $r286                        ; move parameter from branch to block argument
move $r303 $r288                        ; move parameter from branch to block argument
jnzi $r301 .83
ji  .84
.83
muli $r305 $r288 i2
add $r306 $r305 $r299
aloc $r306
mcp $hp $r286 $r290
move $r302 $hp                          ; move parameter from branch to block argument
move $r303 $r306                        ; move parameter from branch to block argument
.84
move $r311 $r302                        ; move parameter from branch to block argument
move $r313 $r303                        ; move parameter from branch to block argument
addi $r314 $$locbase i120               ; get offset to local __ptr slice
mcpi $r314 $r292 i16                    ; copy memory
add $r315 $r311 $r290
lw $r317 $$locbase i16
sw $r315 $r317 i0
addi $r315 $r315 i8
lw $r316 $$locbase i15
mcp $r315 $r316 $r317
addi $r318 $r290 i8
add $r318 $r318 $r317
move $r319 $r318                        ; return value from ASM block with return register new_len
addi $r320 $$locbase i136               ; get offset to local __ptr { ptr, u64, u64 }
sw $$locbase $r311 i17                  ; store word
sw $$locbase $r313 i18                  ; store word
sw $$locbase $r319 i19                  ; store word
addi $r324 $$locbase i56                ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r324 $r320 i24                    ; copy memory
mcpi $r282 $r324 i24                    ; copy memory
mcpi $$arg2 $r282 i24                   ; copy memory
.9
cfsi i224                               ; [fn end: abi_encode_26] free: locals 224 byte(s), call args 0 slot(s)
popa .8                                 ; [fn end: abi_encode_26] restore all used registers
jal $zero $$reta i0                     ; [fn end: abi_encode_26] return from call
DIFF------------------------------
.program:
.10                                     ; --- start of function: new_28 ---
pusha .10                               ; [fn init: new_28]: push all used registers to stack
move $$locbase $sp                      ; [fn init: new_28]: set locals base register
cfei i72                                ; [fn init: new_28]: allocate: locals 72 byte(s), call args 0 slot(s)
.85
addi $r326 $$locbase i48                ; get offset to local __ptr { { ptr, u64, u64 } }
movi $r327 i1024                        ; initialize constant into register
aloc $r327
move $r328 $hp                          ; return value from ASM block with return register hp
addi $r329 $$locbase i24                ; get offset to local __ptr { ptr, u64, u64 }
 sw $$locbase $r328 i3                   ; store word
 sw $$locbase $hp i3                     ; store word
addi $r330 $r329 i8                     ; get offset to aggregate element
movi $r331 i1024                        ; initialize constant into register
sw $$locbase $r331 i4                   ; store word
addi $r332 $r329 i16                    ; get offset to aggregate element
sw $$locbase $zero i5                   ; store word
move $r333 $r329                        ; return value from ASM block with return register buffer
 mcpi $$locbase $r333 i24                ; copy memory
 mcpi $$locbase $r329 i24                ; copy memory
mcpi $r326 $$locbase i24                ; copy memory
mcpi $$arg0 $r326 i24                   ; copy memory
ji  .11
.11
cfsi i72                                ; [fn end: new_28] free: locals 72 byte(s), call args 0 slot(s)
popa .10                                ; [fn end: new_28] restore all used registers
jal $zero $$reta i0                     ; [fn end: new_28] return from call
DIFF------------------------------
.program:
.10                                     ; --- start of function: new_28 ---
pusha .10                               ; [fn init: new_28]: push all used registers to stack
move $$locbase $sp                      ; [fn init: new_28]: set locals base register
cfei i72                                ; [fn init: new_28]: allocate: locals 72 byte(s), call args 0 slot(s)
.85
addi $r326 $$locbase i48                ; get offset to local __ptr { { ptr, u64, u64 } }
movi $r327 i1024                        ; initialize constant into register
aloc $r327
addi $r329 $$locbase i24                ; get offset to local __ptr { ptr, u64, u64 }
sw $$locbase $hp i3                     ; store word
movi $r331 i1024                        ; initialize constant into register
sw $$locbase $r331 i4                   ; store word
sw $$locbase $zero i5                   ; store word
mcpi $$locbase $r329 i24                ; copy memory
mcpi $r326 $$locbase i24                ; copy memory
mcpi $$arg0 $r326 i24                   ; copy memory
.11
cfsi i72                                ; [fn end: new_28] free: locals 72 byte(s), call args 0 slot(s)
popa .10                                ; [fn end: new_28] restore all used registers
jal $zero $$reta i0                     ; [fn end: new_28] return from call
DIFF------------------------------
.program:
.10                                     ; --- start of function: new_28 ---
pusha .10                               ; [fn init: new_28]: push all used registers to stack
move $$locbase $sp                      ; [fn init: new_28]: set locals base register
cfei i72                                ; [fn init: new_28]: allocate: locals 72 byte(s), call args 0 slot(s)
.85
addi $r326 $$locbase i48                ; get offset to local __ptr { { ptr, u64, u64 } }
movi $r327 i1024                        ; initialize constant into register
aloc $r327
addi $r329 $$locbase i24                ; get offset to local __ptr { ptr, u64, u64 }
sw $$locbase $hp i3                     ; store word
movi $r331 i1024                        ; initialize constant into register
sw $$locbase $r331 i4                   ; store word
sw $$locbase $zero i5                   ; store word
mcpi $$locbase $r329 i24                ; copy memory
mcpi $r326 $$locbase i24                ; copy memory
mcpi $$arg0 $r326 i24                   ; copy memory
.11
cfsi i72                                ; [fn end: new_28] free: locals 72 byte(s), call args 0 slot(s)
popa .10                                ; [fn end: new_28] restore all used registers
jal $zero $$reta i0                     ; [fn end: new_28] return from call
DIFF------------------------------
.program:
.10                                     ; --- start of function: new_28 ---
pusha .10                               ; [fn init: new_28]: push all used registers to stack
move $$locbase $sp                      ; [fn init: new_28]: set locals base register
cfei i72                                ; [fn init: new_28]: allocate: locals 72 byte(s), call args 0 slot(s)
.85
addi $r326 $$locbase i48                ; get offset to local __ptr { { ptr, u64, u64 } }
movi $r327 i1024                        ; initialize constant into register
aloc $r327
addi $r329 $$locbase i24                ; get offset to local __ptr { ptr, u64, u64 }
sw $$locbase $hp i3                     ; store word
movi $r331 i1024                        ; initialize constant into register
sw $$locbase $r331 i4                   ; store word
sw $$locbase $zero i5                   ; store word
mcpi $$locbase $r329 i24                ; copy memory
mcpi $r326 $$locbase i24                ; copy memory
mcpi $$arg0 $r326 i24                   ; copy memory
.11
cfsi i72                                ; [fn end: new_28] free: locals 72 byte(s), call args 0 slot(s)
popa .10                                ; [fn end: new_28] restore all used registers
jal $zero $$reta i0                     ; [fn end: new_28] return from call
DIFF------------------------------
.program:
.12                                     ; --- start of function: as_raw_slice_29 ---
pusha .12                               ; [fn init: as_raw_slice_29]: push all used registers to stack
move $$locbase $sp                      ; [fn init: as_raw_slice_29]: set locals base register
cfei i56                                ; [fn init: as_raw_slice_29]: allocate: locals 56 byte(s), call args 0 slot(s)
.86
addi $r335 $$locbase i32                ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r335 $$arg0 i24                   ; copy memory
addi $r336 $$locbase i32                ; get offset to local __ptr { { ptr, u64, u64 } }
move $r337 $r336                        ; return value from ASM block with return register buffer
lw $r338 $r336 i0                       ; load word
 addi $r339 $r337 i16                    ; get offset to aggregate element
 addi $r339 $r336 i16                    ; get offset to aggregate element
lw $r340 $r336 i2                       ; load word
addi $r341 $$locbase i16                ; get offset to local __ptr { ptr, u64 }
sw $$locbase $r338 i2                   ; store word
addi $r342 $r341 i8                     ; get offset to aggregate element
sw $$locbase $r340 i3                   ; store word
move $r343 $r341                        ; return value from ASM block with return register s
 mcpi $$locbase $r343 i16                ; copy memory
 mcpi $$locbase $r341 i16                ; copy memory
mcpi $$arg1 $$locbase i16               ; copy memory
ji  .13
.13
cfsi i56                                ; [fn end: as_raw_slice_29] free: locals 56 byte(s), call args 0 slot(s)
popa .12                                ; [fn end: as_raw_slice_29] restore all used registers
jal $zero $$reta i0                     ; [fn end: as_raw_slice_29] return from call
DIFF------------------------------
.program:
.12                                     ; --- start of function: as_raw_slice_29 ---
pusha .12                               ; [fn init: as_raw_slice_29]: push all used registers to stack
move $$locbase $sp                      ; [fn init: as_raw_slice_29]: set locals base register
cfei i56                                ; [fn init: as_raw_slice_29]: allocate: locals 56 byte(s), call args 0 slot(s)
.86
addi $r335 $$locbase i32                ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r335 $$arg0 i24                   ; copy memory
addi $r336 $$locbase i32                ; get offset to local __ptr { { ptr, u64, u64 } }
lw $r338 $$locbase i4                   ; load word
lw $r340 $$locbase i6                   ; load word
addi $r341 $$locbase i16                ; get offset to local __ptr { ptr, u64 }
sw $$locbase $r338 i2                   ; store word
sw $$locbase $r340 i3                   ; store word
mcpi $$locbase $r341 i16                ; copy memory
mcpi $$arg1 $$locbase i16               ; copy memory
.13
cfsi i56                                ; [fn end: as_raw_slice_29] free: locals 56 byte(s), call args 0 slot(s)
popa .12                                ; [fn end: as_raw_slice_29] restore all used registers
jal $zero $$reta i0                     ; [fn end: as_raw_slice_29] return from call
DIFF------------------------------
.program:
.12                                     ; --- start of function: as_raw_slice_29 ---
pusha .12                               ; [fn init: as_raw_slice_29]: push all used registers to stack
move $$locbase $sp                      ; [fn init: as_raw_slice_29]: set locals base register
cfei i56                                ; [fn init: as_raw_slice_29]: allocate: locals 56 byte(s), call args 0 slot(s)
.86
addi $r335 $$locbase i32                ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r335 $$arg0 i24                   ; copy memory
lw $r338 $$locbase i4                   ; load word
lw $r340 $$locbase i6                   ; load word
addi $r341 $$locbase i16                ; get offset to local __ptr { ptr, u64 }
sw $$locbase $r338 i2                   ; store word
sw $$locbase $r340 i3                   ; store word
mcpi $$locbase $r341 i16                ; copy memory
mcpi $$arg1 $$locbase i16               ; copy memory
.13
cfsi i56                                ; [fn end: as_raw_slice_29] free: locals 56 byte(s), call args 0 slot(s)
popa .12                                ; [fn end: as_raw_slice_29] restore all used registers
jal $zero $$reta i0                     ; [fn end: as_raw_slice_29] return from call
DIFF------------------------------
.program:
.12                                     ; --- start of function: as_raw_slice_29 ---
pusha .12                               ; [fn init: as_raw_slice_29]: push all used registers to stack
move $$locbase $sp                      ; [fn init: as_raw_slice_29]: set locals base register
cfei i56                                ; [fn init: as_raw_slice_29]: allocate: locals 56 byte(s), call args 0 slot(s)
.86
addi $r335 $$locbase i32                ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r335 $$arg0 i24                   ; copy memory
lw $r338 $$locbase i4                   ; load word
lw $r340 $$locbase i6                   ; load word
addi $r341 $$locbase i16                ; get offset to local __ptr { ptr, u64 }
sw $$locbase $r338 i2                   ; store word
sw $$locbase $r340 i3                   ; store word
mcpi $$locbase $r341 i16                ; copy memory
mcpi $$arg1 $$locbase i16               ; copy memory
.13
cfsi i56                                ; [fn end: as_raw_slice_29] free: locals 56 byte(s), call args 0 slot(s)
popa .12                                ; [fn end: as_raw_slice_29] restore all used registers
jal $zero $$reta i0                     ; [fn end: as_raw_slice_29] return from call
DIFF------------------------------
.program:
.18                                     ; --- start of function: call_nested_panic_inlined_30 ---
pusha .18                               ; [fn init: call_nested_panic_inlined_30]: push all used registers to stack
move $$locbase $sp                      ; [fn init: call_nested_panic_inlined_30]: set locals base register
cfei i216                               ; [fn init: call_nested_panic_inlined_30]: allocate: locals 216 byte(s), call args 0 slot(s)
move $r348 $$arg0                       ; [fn init: call_nested_panic_inlined_30]: copy argument 0 (__backtrace)
move $r349 $$reta                       ; [fn init: call_nested_panic_inlined_30]: save return address
.89
addi $r350 $$locbase i160               ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
movi $r351 i4                           ; initialize constant into register
sw $$locbase $r351 i20                  ; store word
addi $r352 $$locbase i96                ; get offset to local __ptr [slice; 3]
addr $r353 data_NonConfigurable_3       ; get __const_global's address in data section
sw $$locbase $r353 i0                   ; store word
addi $r354 $$locbase i8                 ; get offset to aggregate element
movi $r355 i7                           ; initialize constant into register
sw $$locbase $r355 i1                   ; store word
addi $r356 $$locbase i16                ; get offset to local __ptr slice
mcpi $r356 $$locbase i16                ; copy memory
addr $r357 data_NonConfigurable_4       ; get __const_global0's address in data section
addi $r358 $$locbase i32                ; get offset to local __ptr { ptr, u64 }
sw $$locbase $r357 i4                   ; store word
addi $r359 $r358 i8                     ; get offset to aggregate element
movi $r360 i7                           ; initialize constant into register
sw $$locbase $r360 i5                   ; store word
addi $r361 $$locbase i48                ; get offset to local __ptr slice
mcpi $r361 $r358 i16                    ; copy memory
addr $r362 data_NonConfigurable_5       ; get __const_global1's address in data section
addi $r363 $$locbase i64                ; get offset to local __ptr { ptr, u64 }
sw $$locbase $r362 i8                   ; store word
addi $r364 $r363 i8                     ; get offset to aggregate element
movi $r365 i22                          ; initialize constant into register
sw $$locbase $r365 i9                   ; store word
addi $r366 $$locbase i80                ; get offset to local __ptr slice
mcpi $r366 $r363 i16                    ; copy memory
movi $r367 i16                          ; get array element size
 mul $r368 $zero $r367                   ; get offset to array element
 add $r368 $r352 $r368                   ; add array element offset to array base
 mcpi $r368 $r356 i16                    ; copy memory
 movi $r368 i0                           ; get offset to array element
 move $r368 $r352                        ; add array element offset to array base
 mcpi $r352 $r356 i16                    ; copy memory
movi $r369 i16                          ; get array element size
 mul $r370 $one $r369                    ; get offset to array element
 add $r370 $r352 $r370                   ; add array element offset to array base
 movi $r370 i16                          ; get offset to array element
 addi $r370 $r352 i16                    ; add array element offset to array base
mcpi $r370 $r361 i16                    ; copy memory
movi $r371 i16                          ; get array element size
movi $r372 i2                           ; initialize constant into register
 mul $r373 $r372 $r371                   ; get offset to array element
 add $r373 $r352 $r373                   ; add array element offset to array base
 movi $r373 i32                          ; get offset to array element
 addi $r373 $r352 i32                    ; add array element offset to array base
mcpi $r373 $r366 i16                    ; copy memory
addi $r374 $r350 i8                     ; get offset to aggregate element
mcpi $r374 $r352 i48                    ; copy memory
addi $r375 $$locbase i160               ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
addi $r376 $$locbase i144               ; get offset to local __ptr slice
move $$arg0 $r375                       ; [call: encode_allow_alias_1]: pass argument 0
move $$arg1 $r376                       ; [call: encode_allow_alias_1]: pass argument 1
fncall .4                               ; [call: encode_allow_alias_1]: call function
 move $r377 $zero                        ; [call: encode_allow_alias_1]: copy returned unit value
 movi $r377 i0                           ; [call: encode_allow_alias_1]: copy returned unit value
addi $r378 $$locbase i144               ; get offset to local __ptr slice
load $r379 data_NonConfigurable_0       ; load constant from data section
lw $r380 $$locbase i18                  ; load slice pointer for logging data
lw $r381 $$locbase i19                  ; load slice size for logging data
logd $zero $r379 $r380 $r381            ; log slice
load $r382 data_NonConfigurable_6       ; load constant from data section
and $r383 $r348 $r382
load $r384 data_NonConfigurable_7       ; load constant from data section
or $r385 $r384 $r383
rvrt $r385
.19
cfsi i216                               ; [fn end: call_nested_panic_inlined_30] free: locals 216 byte(s), call args 0 slot(s)
move $$reta $r349                       ; [fn end: call_nested_panic_inlined_30] restore return address
popa .18                                ; [fn end: call_nested_panic_inlined_30] restore all used registers
jal $zero $$reta i0                     ; [fn end: call_nested_panic_inlined_30] return from call
DIFF------------------------------
.program:
.18                                     ; --- start of function: call_nested_panic_inlined_30 ---
pusha .18                               ; [fn init: call_nested_panic_inlined_30]: push all used registers to stack
move $$locbase $sp                      ; [fn init: call_nested_panic_inlined_30]: set locals base register
cfei i216                               ; [fn init: call_nested_panic_inlined_30]: allocate: locals 216 byte(s), call args 0 slot(s)
move $r348 $$arg0                       ; [fn init: call_nested_panic_inlined_30]: copy argument 0 (__backtrace)
.89
addi $r350 $$locbase i160               ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
movi $r351 i4                           ; initialize constant into register
sw $$locbase $r351 i20                  ; store word
addi $r352 $$locbase i96                ; get offset to local __ptr [slice; 3]
addr $r353 data_NonConfigurable_3       ; get __const_global's address in data section
sw $$locbase $r353 i0                   ; store word
movi $r355 i7                           ; initialize constant into register
sw $$locbase $r355 i1                   ; store word
addi $r356 $$locbase i16                ; get offset to local __ptr slice
mcpi $r356 $$locbase i16                ; copy memory
addr $r357 data_NonConfigurable_4       ; get __const_global0's address in data section
addi $r358 $$locbase i32                ; get offset to local __ptr { ptr, u64 }
sw $$locbase $r357 i4                   ; store word
movi $r360 i7                           ; initialize constant into register
sw $$locbase $r360 i5                   ; store word
addi $r361 $$locbase i48                ; get offset to local __ptr slice
mcpi $r361 $r358 i16                    ; copy memory
addr $r362 data_NonConfigurable_5       ; get __const_global1's address in data section
addi $r363 $$locbase i64                ; get offset to local __ptr { ptr, u64 }
sw $$locbase $r362 i8                   ; store word
movi $r365 i22                          ; initialize constant into register
sw $$locbase $r365 i9                   ; store word
addi $r366 $$locbase i80                ; get offset to local __ptr slice
mcpi $r366 $r363 i16                    ; copy memory
mcpi $r352 $r356 i16                    ; copy memory
addi $r370 $r352 i16                    ; add array element offset to array base
mcpi $r370 $r361 i16                    ; copy memory
addi $r373 $r352 i32                    ; add array element offset to array base
mcpi $r373 $r366 i16                    ; copy memory
addi $r374 $r350 i8                     ; get offset to aggregate element
mcpi $r374 $r352 i48                    ; copy memory
addi $r375 $$locbase i160               ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
addi $r376 $$locbase i144               ; get offset to local __ptr slice
move $$arg0 $r375                       ; [call: encode_allow_alias_1]: pass argument 0
move $$arg1 $r376                       ; [call: encode_allow_alias_1]: pass argument 1
fncall .4                               ; [call: encode_allow_alias_1]: call function
load $r379 data_NonConfigurable_0       ; load constant from data section
lw $r380 $$locbase i18                  ; load slice pointer for logging data
lw $r381 $$locbase i19                  ; load slice size for logging data
logd $zero $r379 $r380 $r381            ; log slice
load $r382 data_NonConfigurable_6       ; load constant from data section
and $r383 $r348 $r382
load $r384 data_NonConfigurable_7       ; load constant from data section
or $r385 $r384 $r383
rvrt $r385
DIFF------------------------------
.program:
.18                                     ; --- start of function: call_nested_panic_inlined_30 ---
pusha .18                               ; [fn init: call_nested_panic_inlined_30]: push all used registers to stack
move $$locbase $sp                      ; [fn init: call_nested_panic_inlined_30]: set locals base register
cfei i216                               ; [fn init: call_nested_panic_inlined_30]: allocate: locals 216 byte(s), call args 0 slot(s)
move $r348 $$arg0                       ; [fn init: call_nested_panic_inlined_30]: copy argument 0 (__backtrace)
.89
addi $r350 $$locbase i160               ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
movi $r351 i4                           ; initialize constant into register
sw $$locbase $r351 i20                  ; store word
addi $r352 $$locbase i96                ; get offset to local __ptr [slice; 3]
addr $r353 data_NonConfigurable_3       ; get __const_global's address in data section
sw $$locbase $r353 i0                   ; store word
movi $r355 i7                           ; initialize constant into register
sw $$locbase $r355 i1                   ; store word
addi $r356 $$locbase i16                ; get offset to local __ptr slice
mcpi $r356 $$locbase i16                ; copy memory
addr $r357 data_NonConfigurable_4       ; get __const_global0's address in data section
addi $r358 $$locbase i32                ; get offset to local __ptr { ptr, u64 }
sw $$locbase $r357 i4                   ; store word
movi $r360 i7                           ; initialize constant into register
sw $$locbase $r360 i5                   ; store word
addi $r361 $$locbase i48                ; get offset to local __ptr slice
mcpi $r361 $r358 i16                    ; copy memory
addr $r362 data_NonConfigurable_5       ; get __const_global1's address in data section
addi $r363 $$locbase i64                ; get offset to local __ptr { ptr, u64 }
sw $$locbase $r362 i8                   ; store word
movi $r365 i22                          ; initialize constant into register
sw $$locbase $r365 i9                   ; store word
addi $r366 $$locbase i80                ; get offset to local __ptr slice
mcpi $r366 $r363 i16                    ; copy memory
mcpi $r352 $r356 i16                    ; copy memory
addi $r370 $r352 i16                    ; add array element offset to array base
mcpi $r370 $r361 i16                    ; copy memory
addi $r373 $r352 i32                    ; add array element offset to array base
mcpi $r373 $r366 i16                    ; copy memory
addi $r374 $r350 i8                     ; get offset to aggregate element
mcpi $r374 $r352 i48                    ; copy memory
addi $r375 $$locbase i160               ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
addi $r376 $$locbase i144               ; get offset to local __ptr slice
move $$arg0 $r375                       ; [call: encode_allow_alias_1]: pass argument 0
move $$arg1 $r376                       ; [call: encode_allow_alias_1]: pass argument 1
fncall .4                               ; [call: encode_allow_alias_1]: call function
load $r379 data_NonConfigurable_0       ; load constant from data section
lw $r380 $$locbase i18                  ; load slice pointer for logging data
lw $r381 $$locbase i19                  ; load slice size for logging data
logd $zero $r379 $r380 $r381            ; log slice
load $r382 data_NonConfigurable_6       ; load constant from data section
and $r383 $r348 $r382
load $r384 data_NonConfigurable_7       ; load constant from data section
or $r385 $r384 $r383
rvrt $r385
DIFF------------------------------
.program:
.18                                     ; --- start of function: call_nested_panic_inlined_30 ---
pusha .18                               ; [fn init: call_nested_panic_inlined_30]: push all used registers to stack
move $$locbase $sp                      ; [fn init: call_nested_panic_inlined_30]: set locals base register
cfei i216                               ; [fn init: call_nested_panic_inlined_30]: allocate: locals 216 byte(s), call args 0 slot(s)
move $r348 $$arg0                       ; [fn init: call_nested_panic_inlined_30]: copy argument 0 (__backtrace)
.89
addi $r350 $$locbase i160               ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
movi $r351 i4                           ; initialize constant into register
sw $$locbase $r351 i20                  ; store word
addi $r352 $$locbase i96                ; get offset to local __ptr [slice; 3]
addr $r353 data_NonConfigurable_3       ; get __const_global's address in data section
sw $$locbase $r353 i0                   ; store word
movi $r355 i7                           ; initialize constant into register
sw $$locbase $r355 i1                   ; store word
addi $r356 $$locbase i16                ; get offset to local __ptr slice
mcpi $r356 $$locbase i16                ; copy memory
addr $r357 data_NonConfigurable_4       ; get __const_global0's address in data section
addi $r358 $$locbase i32                ; get offset to local __ptr { ptr, u64 }
sw $$locbase $r357 i4                   ; store word
movi $r360 i7                           ; initialize constant into register
sw $$locbase $r360 i5                   ; store word
addi $r361 $$locbase i48                ; get offset to local __ptr slice
mcpi $r361 $r358 i16                    ; copy memory
addr $r362 data_NonConfigurable_5       ; get __const_global1's address in data section
addi $r363 $$locbase i64                ; get offset to local __ptr { ptr, u64 }
sw $$locbase $r362 i8                   ; store word
movi $r365 i22                          ; initialize constant into register
sw $$locbase $r365 i9                   ; store word
addi $r366 $$locbase i80                ; get offset to local __ptr slice
mcpi $r366 $r363 i16                    ; copy memory
mcpi $r352 $r356 i16                    ; copy memory
addi $r370 $r352 i16                    ; add array element offset to array base
mcpi $r370 $r361 i16                    ; copy memory
addi $r373 $r352 i32                    ; add array element offset to array base
mcpi $r373 $r366 i16                    ; copy memory
addi $r374 $r350 i8                     ; get offset to aggregate element
mcpi $r374 $r352 i48                    ; copy memory
addi $r375 $$locbase i160               ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
addi $r376 $$locbase i144               ; get offset to local __ptr slice
move $$arg0 $r375                       ; [call: encode_allow_alias_1]: pass argument 0
move $$arg1 $r376                       ; [call: encode_allow_alias_1]: pass argument 1
fncall .4                               ; [call: encode_allow_alias_1]: call function
load $r379 data_NonConfigurable_0       ; load constant from data section
lw $r380 $$locbase i18                  ; load slice pointer for logging data
lw $r381 $$locbase i19                  ; load slice size for logging data
logd $zero $r379 $r380 $r381            ; log slice
load $r382 data_NonConfigurable_6       ; load constant from data section
and $r383 $r348 $r382
load $r384 data_NonConfigurable_7       ; load constant from data section
or $r385 $r384 $r383
rvrt $r385
DIFF------------------------------
.program:
.24                                     ; --- start of function: call_nested_panic_non_inlined_32 ---
pusha .24                               ; [fn init: call_nested_panic_non_inlined_32]: push all used registers to stack
move $$locbase $sp                      ; [fn init: call_nested_panic_non_inlined_32]: set locals base register
cfei i200                               ; [fn init: call_nested_panic_non_inlined_32]: allocate: locals 200 byte(s), call args 0 slot(s)
move $r390 $$arg0                       ; [fn init: call_nested_panic_non_inlined_32]: copy argument 0 (__backtrace)
move $r391 $$reta                       ; [fn init: call_nested_panic_non_inlined_32]: save return address
.92
movi $r392 i4                           ; initialize constant into register
sw $$locbase $r392 i0                   ; store word
addi $r393 $$locbase i152               ; get offset to local __ptr [slice; 3]
addr $r394 data_NonConfigurable_8       ; get __const_global2's address in data section
addi $r395 $$locbase i56                ; get offset to local __ptr { ptr, u64 }
sw $$locbase $r394 i7                   ; store word
addi $r396 $r395 i8                     ; get offset to aggregate element
movi $r397 i4                           ; initialize constant into register
sw $$locbase $r397 i8                   ; store word
addi $r398 $$locbase i72                ; get offset to local __ptr slice
mcpi $r398 $r395 i16                    ; copy memory
addr $r399 data_NonConfigurable_9       ; get __const_global3's address in data section
addi $r400 $$locbase i88                ; get offset to local __ptr { ptr, u64 }
sw $$locbase $r399 i11                  ; store word
addi $r401 $r400 i8                     ; get offset to aggregate element
movi $r402 i6                           ; initialize constant into register
sw $$locbase $r402 i12                  ; store word
addi $r403 $$locbase i104               ; get offset to local __ptr slice
mcpi $r403 $r400 i16                    ; copy memory
addr $r404 data_NonConfigurable_10      ; get __const_global4's address in data section
addi $r405 $$locbase i120               ; get offset to local __ptr { ptr, u64 }
sw $$locbase $r404 i15                  ; store word
addi $r406 $r405 i8                     ; get offset to aggregate element
movi $r407 i17                          ; initialize constant into register
sw $$locbase $r407 i16                  ; store word
addi $r408 $$locbase i136               ; get offset to local __ptr slice
mcpi $r408 $r405 i16                    ; copy memory
movi $r409 i16                          ; get array element size
 mul $r410 $zero $r409                   ; get offset to array element
 add $r410 $r393 $r410                   ; add array element offset to array base
 mcpi $r410 $r398 i16                    ; copy memory
 movi $r410 i0                           ; get offset to array element
 move $r410 $r393                        ; add array element offset to array base
 mcpi $r393 $r398 i16                    ; copy memory
movi $r411 i16                          ; get array element size
 mul $r412 $one $r411                    ; get offset to array element
 add $r412 $r393 $r412                   ; add array element offset to array base
 movi $r412 i16                          ; get offset to array element
 addi $r412 $r393 i16                    ; add array element offset to array base
mcpi $r412 $r403 i16                    ; copy memory
movi $r413 i16                          ; get array element size
movi $r414 i2                           ; initialize constant into register
 mul $r415 $r414 $r413                   ; get offset to array element
 add $r415 $r393 $r415                   ; add array element offset to array base
 movi $r415 i32                          ; get offset to array element
 addi $r415 $r393 i32                    ; add array element offset to array base
mcpi $r415 $r408 i16                    ; copy memory
addi $r416 $$locbase i8                 ; get offset to aggregate element
mcpi $r416 $r393 i48                    ; copy memory
 move $$arg0 $one                        ; [call: nested_panic_non_inlined_33]: pass argument 0
 movi $$arg0 i1                          ; [call: nested_panic_non_inlined_33]: pass argument 0
move $$arg1 $$locbase                   ; [call: nested_panic_non_inlined_33]: pass argument 1
move $$arg2 $r390                       ; [call: nested_panic_non_inlined_33]: pass argument 2
fncall .26                              ; [call: nested_panic_non_inlined_33]: call function
 move $r417 $zero                        ; [call: nested_panic_non_inlined_33]: copy returned unit value
 movi $r417 i0                           ; [call: nested_panic_non_inlined_33]: copy returned unit value
ji  .25
.25
cfsi i200                               ; [fn end: call_nested_panic_non_inlined_32] free: locals 200 byte(s), call args 0 slot(s)
move $$reta $r391                       ; [fn end: call_nested_panic_non_inlined_32] restore return address
popa .24                                ; [fn end: call_nested_panic_non_inlined_32] restore all used registers
jal $zero $$reta i0                     ; [fn end: call_nested_panic_non_inlined_32] return from call
DIFF------------------------------
.program:
.24                                     ; --- start of function: call_nested_panic_non_inlined_32 ---
pusha .24                               ; [fn init: call_nested_panic_non_inlined_32]: push all used registers to stack
move $$locbase $sp                      ; [fn init: call_nested_panic_non_inlined_32]: set locals base register
cfei i200                               ; [fn init: call_nested_panic_non_inlined_32]: allocate: locals 200 byte(s), call args 0 slot(s)
move $r390 $$arg0                       ; [fn init: call_nested_panic_non_inlined_32]: copy argument 0 (__backtrace)
move $r391 $$reta                       ; [fn init: call_nested_panic_non_inlined_32]: save return address
.92
movi $r392 i4                           ; initialize constant into register
sw $$locbase $r392 i0                   ; store word
addi $r393 $$locbase i152               ; get offset to local __ptr [slice; 3]
addr $r394 data_NonConfigurable_8       ; get __const_global2's address in data section
addi $r395 $$locbase i56                ; get offset to local __ptr { ptr, u64 }
sw $$locbase $r394 i7                   ; store word
movi $r397 i4                           ; initialize constant into register
sw $$locbase $r397 i8                   ; store word
addi $r398 $$locbase i72                ; get offset to local __ptr slice
mcpi $r398 $r395 i16                    ; copy memory
addr $r399 data_NonConfigurable_9       ; get __const_global3's address in data section
addi $r400 $$locbase i88                ; get offset to local __ptr { ptr, u64 }
sw $$locbase $r399 i11                  ; store word
movi $r402 i6                           ; initialize constant into register
sw $$locbase $r402 i12                  ; store word
addi $r403 $$locbase i104               ; get offset to local __ptr slice
mcpi $r403 $r400 i16                    ; copy memory
addr $r404 data_NonConfigurable_10      ; get __const_global4's address in data section
addi $r405 $$locbase i120               ; get offset to local __ptr { ptr, u64 }
sw $$locbase $r404 i15                  ; store word
movi $r407 i17                          ; initialize constant into register
sw $$locbase $r407 i16                  ; store word
addi $r408 $$locbase i136               ; get offset to local __ptr slice
mcpi $r408 $r405 i16                    ; copy memory
mcpi $r393 $r398 i16                    ; copy memory
addi $r412 $r393 i16                    ; add array element offset to array base
mcpi $r412 $r403 i16                    ; copy memory
addi $r415 $r393 i32                    ; add array element offset to array base
mcpi $r415 $r408 i16                    ; copy memory
addi $r416 $$locbase i8                 ; get offset to aggregate element
mcpi $r416 $r393 i48                    ; copy memory
movi $$arg0 i1                          ; [call: nested_panic_non_inlined_33]: pass argument 0
move $$arg1 $$locbase                   ; [call: nested_panic_non_inlined_33]: pass argument 1
move $$arg2 $r390                       ; [call: nested_panic_non_inlined_33]: pass argument 2
fncall .26                              ; [call: nested_panic_non_inlined_33]: call function
.25
cfsi i200                               ; [fn end: call_nested_panic_non_inlined_32] free: locals 200 byte(s), call args 0 slot(s)
move $$reta $r391                       ; [fn end: call_nested_panic_non_inlined_32] restore return address
popa .24                                ; [fn end: call_nested_panic_non_inlined_32] restore all used registers
jal $zero $$reta i0                     ; [fn end: call_nested_panic_non_inlined_32] return from call
DIFF------------------------------
.program:
.24                                     ; --- start of function: call_nested_panic_non_inlined_32 ---
pusha .24                               ; [fn init: call_nested_panic_non_inlined_32]: push all used registers to stack
move $$locbase $sp                      ; [fn init: call_nested_panic_non_inlined_32]: set locals base register
cfei i200                               ; [fn init: call_nested_panic_non_inlined_32]: allocate: locals 200 byte(s), call args 0 slot(s)
move $r390 $$arg0                       ; [fn init: call_nested_panic_non_inlined_32]: copy argument 0 (__backtrace)
move $r391 $$reta                       ; [fn init: call_nested_panic_non_inlined_32]: save return address
.92
movi $r392 i4                           ; initialize constant into register
sw $$locbase $r392 i0                   ; store word
addi $r393 $$locbase i152               ; get offset to local __ptr [slice; 3]
addr $r394 data_NonConfigurable_8       ; get __const_global2's address in data section
addi $r395 $$locbase i56                ; get offset to local __ptr { ptr, u64 }
sw $$locbase $r394 i7                   ; store word
movi $r397 i4                           ; initialize constant into register
sw $$locbase $r397 i8                   ; store word
addi $r398 $$locbase i72                ; get offset to local __ptr slice
mcpi $r398 $r395 i16                    ; copy memory
addr $r399 data_NonConfigurable_9       ; get __const_global3's address in data section
addi $r400 $$locbase i88                ; get offset to local __ptr { ptr, u64 }
sw $$locbase $r399 i11                  ; store word
movi $r402 i6                           ; initialize constant into register
sw $$locbase $r402 i12                  ; store word
addi $r403 $$locbase i104               ; get offset to local __ptr slice
mcpi $r403 $r400 i16                    ; copy memory
addr $r404 data_NonConfigurable_10      ; get __const_global4's address in data section
addi $r405 $$locbase i120               ; get offset to local __ptr { ptr, u64 }
sw $$locbase $r404 i15                  ; store word
movi $r407 i17                          ; initialize constant into register
sw $$locbase $r407 i16                  ; store word
addi $r408 $$locbase i136               ; get offset to local __ptr slice
mcpi $r408 $r405 i16                    ; copy memory
mcpi $r393 $r398 i16                    ; copy memory
addi $r412 $r393 i16                    ; add array element offset to array base
mcpi $r412 $r403 i16                    ; copy memory
addi $r415 $r393 i32                    ; add array element offset to array base
mcpi $r415 $r408 i16                    ; copy memory
addi $r416 $$locbase i8                 ; get offset to aggregate element
mcpi $r416 $r393 i48                    ; copy memory
movi $$arg0 i1                          ; [call: nested_panic_non_inlined_33]: pass argument 0
move $$arg1 $$locbase                   ; [call: nested_panic_non_inlined_33]: pass argument 1
move $$arg2 $r390                       ; [call: nested_panic_non_inlined_33]: pass argument 2
fncall .26                              ; [call: nested_panic_non_inlined_33]: call function
.25
cfsi i200                               ; [fn end: call_nested_panic_non_inlined_32] free: locals 200 byte(s), call args 0 slot(s)
move $$reta $r391                       ; [fn end: call_nested_panic_non_inlined_32] restore return address
popa .24                                ; [fn end: call_nested_panic_non_inlined_32] restore all used registers
jal $zero $$reta i0                     ; [fn end: call_nested_panic_non_inlined_32] return from call
DIFF------------------------------
.program:
.24                                     ; --- start of function: call_nested_panic_non_inlined_32 ---
pusha .24                               ; [fn init: call_nested_panic_non_inlined_32]: push all used registers to stack
move $$locbase $sp                      ; [fn init: call_nested_panic_non_inlined_32]: set locals base register
cfei i200                               ; [fn init: call_nested_panic_non_inlined_32]: allocate: locals 200 byte(s), call args 0 slot(s)
move $r390 $$arg0                       ; [fn init: call_nested_panic_non_inlined_32]: copy argument 0 (__backtrace)
move $r391 $$reta                       ; [fn init: call_nested_panic_non_inlined_32]: save return address
.92
movi $r392 i4                           ; initialize constant into register
sw $$locbase $r392 i0                   ; store word
addi $r393 $$locbase i152               ; get offset to local __ptr [slice; 3]
addr $r394 data_NonConfigurable_8       ; get __const_global2's address in data section
addi $r395 $$locbase i56                ; get offset to local __ptr { ptr, u64 }
sw $$locbase $r394 i7                   ; store word
movi $r397 i4                           ; initialize constant into register
sw $$locbase $r397 i8                   ; store word
addi $r398 $$locbase i72                ; get offset to local __ptr slice
mcpi $r398 $r395 i16                    ; copy memory
addr $r399 data_NonConfigurable_9       ; get __const_global3's address in data section
addi $r400 $$locbase i88                ; get offset to local __ptr { ptr, u64 }
sw $$locbase $r399 i11                  ; store word
movi $r402 i6                           ; initialize constant into register
sw $$locbase $r402 i12                  ; store word
addi $r403 $$locbase i104               ; get offset to local __ptr slice
mcpi $r403 $r400 i16                    ; copy memory
addr $r404 data_NonConfigurable_10      ; get __const_global4's address in data section
addi $r405 $$locbase i120               ; get offset to local __ptr { ptr, u64 }
sw $$locbase $r404 i15                  ; store word
movi $r407 i17                          ; initialize constant into register
sw $$locbase $r407 i16                  ; store word
addi $r408 $$locbase i136               ; get offset to local __ptr slice
mcpi $r408 $r405 i16                    ; copy memory
mcpi $r393 $r398 i16                    ; copy memory
addi $r412 $r393 i16                    ; add array element offset to array base
mcpi $r412 $r403 i16                    ; copy memory
addi $r415 $r393 i32                    ; add array element offset to array base
mcpi $r415 $r408 i16                    ; copy memory
addi $r416 $$locbase i8                 ; get offset to aggregate element
mcpi $r416 $r393 i48                    ; copy memory
movi $$arg0 i1                          ; [call: nested_panic_non_inlined_33]: pass argument 0
move $$arg1 $$locbase                   ; [call: nested_panic_non_inlined_33]: pass argument 1
move $$arg2 $r390                       ; [call: nested_panic_non_inlined_33]: pass argument 2
fncall .26                              ; [call: nested_panic_non_inlined_33]: call function
.25
cfsi i200                               ; [fn end: call_nested_panic_non_inlined_32] free: locals 200 byte(s), call args 0 slot(s)
move $$reta $r391                       ; [fn end: call_nested_panic_non_inlined_32] restore return address
popa .24                                ; [fn end: call_nested_panic_non_inlined_32] restore all used registers
jal $zero $$reta i0                     ; [fn end: call_nested_panic_non_inlined_32] return from call
DIFF------------------------------
.program:
.26                                     ; --- start of function: nested_panic_non_inlined_33 ---
pusha .26                               ; [fn init: nested_panic_non_inlined_33]: push all used registers to stack
move $$locbase $sp                      ; [fn init: nested_panic_non_inlined_33]: set locals base register
cfei i72                                ; [fn init: nested_panic_non_inlined_33]: allocate: locals 72 byte(s), call args 0 slot(s)
move $r418 $$arg0                       ; [fn init: nested_panic_non_inlined_33]: copy argument 0 (to_panic)
move $r419 $$arg1                       ; [fn init: nested_panic_non_inlined_33]: copy argument 1 (err)
move $r420 $$arg2                       ; [fn init: nested_panic_non_inlined_33]: copy argument 2 (__backtrace)
move $r421 $$reta                       ; [fn init: nested_panic_non_inlined_33]: save return address
.93
addi $r422 $$locbase i16                ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
 mcpi $r422 $r419 i56                    ; copy memory
 mcpi $r422 $$arg1 i56                   ; copy memory
jnzi $r418 .94
ji  .95
.95
ji  .27
.94
addi $r423 $$locbase i16                ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
move $$arg0 $r423                       ; [call: encode_allow_alias_1]: pass argument 0
move $$arg1 $$locbase                   ; [call: encode_allow_alias_1]: pass argument 1
fncall .4                               ; [call: encode_allow_alias_1]: call function
 move $r424 $zero                        ; [call: encode_allow_alias_1]: copy returned unit value
 movi $r424 i0                           ; [call: encode_allow_alias_1]: copy returned unit value
load $r425 data_NonConfigurable_0       ; load constant from data section
lw $r426 $$locbase i0                   ; load slice pointer for logging data
lw $r427 $$locbase i1                   ; load slice size for logging data
logd $zero $r425 $r426 $r427            ; log slice
load $r428 data_NonConfigurable_6       ; load constant from data section
and $r429 $r420 $r428
load $r430 data_NonConfigurable_11      ; load constant from data section
or $r431 $r430 $r429
rvrt $r431
.27
cfsi i72                                ; [fn end: nested_panic_non_inlined_33] free: locals 72 byte(s), call args 0 slot(s)
move $$reta $r421                       ; [fn end: nested_panic_non_inlined_33] restore return address
popa .26                                ; [fn end: nested_panic_non_inlined_33] restore all used registers
jal $zero $$reta i0                     ; [fn end: nested_panic_non_inlined_33] return from call
DIFF------------------------------
.program:
.26                                     ; --- start of function: nested_panic_non_inlined_33 ---
pusha .26                               ; [fn init: nested_panic_non_inlined_33]: push all used registers to stack
move $$locbase $sp                      ; [fn init: nested_panic_non_inlined_33]: set locals base register
cfei i72                                ; [fn init: nested_panic_non_inlined_33]: allocate: locals 72 byte(s), call args 0 slot(s)
move $r418 $$arg0                       ; [fn init: nested_panic_non_inlined_33]: copy argument 0 (to_panic)
move $r420 $$arg2                       ; [fn init: nested_panic_non_inlined_33]: copy argument 2 (__backtrace)
move $r421 $$reta                       ; [fn init: nested_panic_non_inlined_33]: save return address
.93
addi $r422 $$locbase i16                ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
mcpi $r422 $$arg1 i56                   ; copy memory
jnzi $r418 .94
.95
ji  .27
.94
addi $r423 $$locbase i16                ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
move $$arg0 $r423                       ; [call: encode_allow_alias_1]: pass argument 0
move $$arg1 $$locbase                   ; [call: encode_allow_alias_1]: pass argument 1
fncall .4                               ; [call: encode_allow_alias_1]: call function
load $r425 data_NonConfigurable_0       ; load constant from data section
lw $r426 $$locbase i0                   ; load slice pointer for logging data
lw $r427 $$locbase i1                   ; load slice size for logging data
logd $zero $r425 $r426 $r427            ; log slice
load $r428 data_NonConfigurable_6       ; load constant from data section
and $r429 $r420 $r428
load $r430 data_NonConfigurable_11      ; load constant from data section
or $r431 $r430 $r429
rvrt $r431
.27
cfsi i72                                ; [fn end: nested_panic_non_inlined_33] free: locals 72 byte(s), call args 0 slot(s)
move $$reta $r421                       ; [fn end: nested_panic_non_inlined_33] restore return address
popa .26                                ; [fn end: nested_panic_non_inlined_33] restore all used registers
jal $zero $$reta i0                     ; [fn end: nested_panic_non_inlined_33] return from call
DIFF------------------------------
.program:
.26                                     ; --- start of function: nested_panic_non_inlined_33 ---
pusha .26                               ; [fn init: nested_panic_non_inlined_33]: push all used registers to stack
move $$locbase $sp                      ; [fn init: nested_panic_non_inlined_33]: set locals base register
cfei i72                                ; [fn init: nested_panic_non_inlined_33]: allocate: locals 72 byte(s), call args 0 slot(s)
move $r418 $$arg0                       ; [fn init: nested_panic_non_inlined_33]: copy argument 0 (to_panic)
move $r420 $$arg2                       ; [fn init: nested_panic_non_inlined_33]: copy argument 2 (__backtrace)
move $r421 $$reta                       ; [fn init: nested_panic_non_inlined_33]: save return address
.93
addi $r422 $$locbase i16                ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
mcpi $r422 $$arg1 i56                   ; copy memory
jnzi $r418 .94
.95
ji  .27
.94
addi $r423 $$locbase i16                ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
move $$arg0 $r423                       ; [call: encode_allow_alias_1]: pass argument 0
move $$arg1 $$locbase                   ; [call: encode_allow_alias_1]: pass argument 1
fncall .4                               ; [call: encode_allow_alias_1]: call function
load $r425 data_NonConfigurable_0       ; load constant from data section
lw $r426 $$locbase i0                   ; load slice pointer for logging data
lw $r427 $$locbase i1                   ; load slice size for logging data
logd $zero $r425 $r426 $r427            ; log slice
load $r428 data_NonConfigurable_6       ; load constant from data section
and $r429 $r420 $r428
load $r430 data_NonConfigurable_11      ; load constant from data section
or $r431 $r430 $r429
rvrt $r431
.27
cfsi i72                                ; [fn end: nested_panic_non_inlined_33] free: locals 72 byte(s), call args 0 slot(s)
move $$reta $r421                       ; [fn end: nested_panic_non_inlined_33] restore return address
popa .26                                ; [fn end: nested_panic_non_inlined_33] restore all used registers
jal $zero $$reta i0                     ; [fn end: nested_panic_non_inlined_33] return from call
DIFF------------------------------
.program:
.26                                     ; --- start of function: nested_panic_non_inlined_33 ---
pusha .26                               ; [fn init: nested_panic_non_inlined_33]: push all used registers to stack
move $$locbase $sp                      ; [fn init: nested_panic_non_inlined_33]: set locals base register
cfei i72                                ; [fn init: nested_panic_non_inlined_33]: allocate: locals 72 byte(s), call args 0 slot(s)
move $r418 $$arg0                       ; [fn init: nested_panic_non_inlined_33]: copy argument 0 (to_panic)
move $r420 $$arg2                       ; [fn init: nested_panic_non_inlined_33]: copy argument 2 (__backtrace)
move $r421 $$reta                       ; [fn init: nested_panic_non_inlined_33]: save return address
.93
addi $r422 $$locbase i16                ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
mcpi $r422 $$arg1 i56                   ; copy memory
jnzi $r418 .94
.95
ji  .27
.94
addi $r423 $$locbase i16                ; get offset to local __ptr { u64, ( () | u8 | bool | { u64, u64 } | [slice; 3] ) }
move $$arg0 $r423                       ; [call: encode_allow_alias_1]: pass argument 0
move $$arg1 $$locbase                   ; [call: encode_allow_alias_1]: pass argument 1
fncall .4                               ; [call: encode_allow_alias_1]: call function
load $r425 data_NonConfigurable_0       ; load constant from data section
lw $r426 $$locbase i0                   ; load slice pointer for logging data
lw $r427 $$locbase i1                   ; load slice size for logging data
logd $zero $r425 $r426 $r427            ; log slice
load $r428 data_NonConfigurable_6       ; load constant from data section
and $r429 $r420 $r428
load $r430 data_NonConfigurable_11      ; load constant from data section
or $r431 $r430 $r429
rvrt $r431
.27
cfsi i72                                ; [fn end: nested_panic_non_inlined_33] free: locals 72 byte(s), call args 0 slot(s)
move $$reta $r421                       ; [fn end: nested_panic_non_inlined_33] restore return address
popa .26                                ; [fn end: nested_panic_non_inlined_33] restore all used registers
jal $zero $$reta i0                     ; [fn end: nested_panic_non_inlined_33] return from call
DIFF------------------------------
.program:
.32                                     ; --- start of function: generic_panic_34 ---
pusha .32                               ; [fn init: generic_panic_34]: push all used registers to stack
move $$locbase $sp                      ; [fn init: generic_panic_34]: set locals base register
cfei i32                                ; [fn init: generic_panic_34]: allocate: locals 32 byte(s), call args 0 slot(s)
.98
addi $r437 $$locbase i32                ; get offset to local __ptr ()
addi $r438 $$locbase i32                ; get offset to local __ptr ()
sw $$locbase $r438 i0                   ; store word
addi $r439 $$locbase i8                 ; get offset to aggregate element
sw $$locbase $zero i1                   ; store word
addi $r440 $$locbase i16                ; get offset to local __ptr slice
mcpi $r440 $$locbase i16                ; copy memory
load $r441 data_NonConfigurable_12      ; load constant from data section
lw $r442 $$locbase i2                   ; load slice pointer for logging data
lw $r443 $$locbase i3                   ; load slice size for logging data
logd $zero $r441 $r442 $r443            ; log slice
load $r444 data_NonConfigurable_6       ; load constant from data section
and $r445 $$arg1 $r444
load $r446 data_NonConfigurable_13      ; load constant from data section
or $r447 $r446 $r445
rvrt $r447
.33
cfsi i32                                ; [fn end: generic_panic_34] free: locals 32 byte(s), call args 0 slot(s)
popa .32                                ; [fn end: generic_panic_34] restore all used registers
jal $zero $$reta i0                     ; [fn end: generic_panic_34] return from call
DIFF------------------------------
.program:
.32                                     ; --- start of function: generic_panic_34 ---
pusha .32                               ; [fn init: generic_panic_34]: push all used registers to stack
move $$locbase $sp                      ; [fn init: generic_panic_34]: set locals base register
cfei i32                                ; [fn init: generic_panic_34]: allocate: locals 32 byte(s), call args 0 slot(s)
.98
addi $r438 $$locbase i32                ; get offset to local __ptr ()
sw $$locbase $r438 i0                   ; store word
sw $$locbase $zero i1                   ; store word
addi $r440 $$locbase i16                ; get offset to local __ptr slice
mcpi $r440 $$locbase i16                ; copy memory
load $r441 data_NonConfigurable_12      ; load constant from data section
lw $r442 $$locbase i2                   ; load slice pointer for logging data
lw $r443 $$locbase i3                   ; load slice size for logging data
logd $zero $r441 $r442 $r443            ; log slice
load $r444 data_NonConfigurable_6       ; load constant from data section
and $r445 $$arg1 $r444
load $r446 data_NonConfigurable_13      ; load constant from data section
or $r447 $r446 $r445
rvrt $r447
DIFF------------------------------
.program:
.32                                     ; --- start of function: generic_panic_34 ---
pusha .32                               ; [fn init: generic_panic_34]: push all used registers to stack
move $$locbase $sp                      ; [fn init: generic_panic_34]: set locals base register
cfei i32                                ; [fn init: generic_panic_34]: allocate: locals 32 byte(s), call args 0 slot(s)
.98
addi $r438 $$locbase i32                ; get offset to local __ptr ()
sw $$locbase $r438 i0                   ; store word
sw $$locbase $zero i1                   ; store word
addi $r440 $$locbase i16                ; get offset to local __ptr slice
mcpi $r440 $$locbase i16                ; copy memory
load $r441 data_NonConfigurable_12      ; load constant from data section
lw $r442 $$locbase i2                   ; load slice pointer for logging data
lw $r443 $$locbase i3                   ; load slice size for logging data
logd $zero $r441 $r442 $r443            ; log slice
load $r444 data_NonConfigurable_6       ; load constant from data section
and $r445 $$arg1 $r444
load $r446 data_NonConfigurable_13      ; load constant from data section
or $r447 $r446 $r445
rvrt $r447
DIFF------------------------------
.program:
.32                                     ; --- start of function: generic_panic_34 ---
pusha .32                               ; [fn init: generic_panic_34]: push all used registers to stack
move $$locbase $sp                      ; [fn init: generic_panic_34]: set locals base register
cfei i32                                ; [fn init: generic_panic_34]: allocate: locals 32 byte(s), call args 0 slot(s)
.98
addi $r438 $$locbase i32                ; get offset to local __ptr ()
sw $$locbase $r438 i0                   ; store word
sw $$locbase $zero i1                   ; store word
addi $r440 $$locbase i16                ; get offset to local __ptr slice
mcpi $r440 $$locbase i16                ; copy memory
load $r441 data_NonConfigurable_12      ; load constant from data section
lw $r442 $$locbase i2                   ; load slice pointer for logging data
lw $r443 $$locbase i3                   ; load slice size for logging data
logd $zero $r441 $r442 $r443            ; log slice
load $r444 data_NonConfigurable_6       ; load constant from data section
and $r445 $$arg1 $r444
load $r446 data_NonConfigurable_13      ; load constant from data section
or $r447 $r446 $r445
rvrt $r447
DIFF------------------------------
.program:
.38                                     ; --- start of function: generic_panic_37 ---
pusha .38                               ; [fn init: generic_panic_37]: push all used registers to stack
move $$locbase $sp                      ; [fn init: generic_panic_37]: set locals base register
cfei i64                                ; [fn init: generic_panic_37]: allocate: locals 64 byte(s), call args 0 slot(s)
move $r457 $$arg0                       ; [fn init: generic_panic_37]: copy argument 0 (t)
move $r458 $$arg1                       ; [fn init: generic_panic_37]: copy argument 1 (__backtrace)
move $r459 $$reta                       ; [fn init: generic_panic_37]: save return address
.101
addi $r460 $$locbase i16                ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r460                       ; [call: new_28]: pass argument 0
fncall .10                              ; [call: new_28]: call function
 move $r461 $zero                        ; [call: new_28]: copy returned unit value
 movi $r461 i0                           ; [call: new_28]: copy returned unit value
addi $r462 $$locbase i16                ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r463 $$locbase i40                ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r457                       ; [call: abi_encode_26]: pass argument 0
move $$arg1 $r462                       ; [call: abi_encode_26]: pass argument 1
move $$arg2 $r463                       ; [call: abi_encode_26]: pass argument 2
fncall .8                               ; [call: abi_encode_26]: call function
 move $r464 $zero                        ; [call: abi_encode_26]: copy returned unit value
 movi $r464 i0                           ; [call: abi_encode_26]: copy returned unit value
addi $r465 $$locbase i40                ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r465                       ; [call: as_raw_slice_29]: pass argument 0
move $$arg1 $$locbase                   ; [call: as_raw_slice_29]: pass argument 1
fncall .12                              ; [call: as_raw_slice_29]: call function
 move $r466 $zero                        ; [call: as_raw_slice_29]: copy returned unit value
 movi $r466 i0                           ; [call: as_raw_slice_29]: copy returned unit value
load $r467 data_NonConfigurable_15      ; load constant from data section
lw $r468 $$locbase i0                   ; load slice pointer for logging data
lw $r469 $$locbase i1                   ; load slice size for logging data
logd $zero $r467 $r468 $r469            ; log slice
load $r470 data_NonConfigurable_6       ; load constant from data section
and $r471 $r458 $r470
load $r472 data_NonConfigurable_16      ; load constant from data section
or $r473 $r472 $r471
rvrt $r473
.39
cfsi i64                                ; [fn end: generic_panic_37] free: locals 64 byte(s), call args 0 slot(s)
move $$reta $r459                       ; [fn end: generic_panic_37] restore return address
popa .38                                ; [fn end: generic_panic_37] restore all used registers
jal $zero $$reta i0                     ; [fn end: generic_panic_37] return from call
DIFF------------------------------
.program:
.38                                     ; --- start of function: generic_panic_37 ---
pusha .38                               ; [fn init: generic_panic_37]: push all used registers to stack
move $$locbase $sp                      ; [fn init: generic_panic_37]: set locals base register
cfei i64                                ; [fn init: generic_panic_37]: allocate: locals 64 byte(s), call args 0 slot(s)
move $r457 $$arg0                       ; [fn init: generic_panic_37]: copy argument 0 (t)
move $r458 $$arg1                       ; [fn init: generic_panic_37]: copy argument 1 (__backtrace)
.101
addi $r460 $$locbase i16                ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r460                       ; [call: new_28]: pass argument 0
fncall .10                              ; [call: new_28]: call function
addi $r462 $$locbase i16                ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r463 $$locbase i40                ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r457                       ; [call: abi_encode_26]: pass argument 0
move $$arg1 $r462                       ; [call: abi_encode_26]: pass argument 1
move $$arg2 $r463                       ; [call: abi_encode_26]: pass argument 2
fncall .8                               ; [call: abi_encode_26]: call function
addi $r465 $$locbase i40                ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r465                       ; [call: as_raw_slice_29]: pass argument 0
move $$arg1 $$locbase                   ; [call: as_raw_slice_29]: pass argument 1
fncall .12                              ; [call: as_raw_slice_29]: call function
load $r467 data_NonConfigurable_15      ; load constant from data section
lw $r468 $$locbase i0                   ; load slice pointer for logging data
lw $r469 $$locbase i1                   ; load slice size for logging data
logd $zero $r467 $r468 $r469            ; log slice
load $r470 data_NonConfigurable_6       ; load constant from data section
and $r471 $r458 $r470
load $r472 data_NonConfigurable_16      ; load constant from data section
or $r473 $r472 $r471
rvrt $r473
DIFF------------------------------
.program:
.38                                     ; --- start of function: generic_panic_37 ---
pusha .38                               ; [fn init: generic_panic_37]: push all used registers to stack
move $$locbase $sp                      ; [fn init: generic_panic_37]: set locals base register
cfei i64                                ; [fn init: generic_panic_37]: allocate: locals 64 byte(s), call args 0 slot(s)
move $r457 $$arg0                       ; [fn init: generic_panic_37]: copy argument 0 (t)
move $r458 $$arg1                       ; [fn init: generic_panic_37]: copy argument 1 (__backtrace)
.101
addi $r460 $$locbase i16                ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r460                       ; [call: new_28]: pass argument 0
fncall .10                              ; [call: new_28]: call function
addi $r462 $$locbase i16                ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r463 $$locbase i40                ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r457                       ; [call: abi_encode_26]: pass argument 0
move $$arg1 $r462                       ; [call: abi_encode_26]: pass argument 1
move $$arg2 $r463                       ; [call: abi_encode_26]: pass argument 2
fncall .8                               ; [call: abi_encode_26]: call function
addi $r465 $$locbase i40                ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r465                       ; [call: as_raw_slice_29]: pass argument 0
move $$arg1 $$locbase                   ; [call: as_raw_slice_29]: pass argument 1
fncall .12                              ; [call: as_raw_slice_29]: call function
load $r467 data_NonConfigurable_15      ; load constant from data section
lw $r468 $$locbase i0                   ; load slice pointer for logging data
lw $r469 $$locbase i1                   ; load slice size for logging data
logd $zero $r467 $r468 $r469            ; log slice
load $r470 data_NonConfigurable_6       ; load constant from data section
and $r471 $r458 $r470
load $r472 data_NonConfigurable_16      ; load constant from data section
or $r473 $r472 $r471
rvrt $r473
DIFF------------------------------
.program:
.38                                     ; --- start of function: generic_panic_37 ---
pusha .38                               ; [fn init: generic_panic_37]: push all used registers to stack
move $$locbase $sp                      ; [fn init: generic_panic_37]: set locals base register
cfei i64                                ; [fn init: generic_panic_37]: allocate: locals 64 byte(s), call args 0 slot(s)
move $r457 $$arg0                       ; [fn init: generic_panic_37]: copy argument 0 (t)
move $r458 $$arg1                       ; [fn init: generic_panic_37]: copy argument 1 (__backtrace)
.101
addi $r460 $$locbase i16                ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r460                       ; [call: new_28]: pass argument 0
fncall .10                              ; [call: new_28]: call function
addi $r462 $$locbase i16                ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r463 $$locbase i40                ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r457                       ; [call: abi_encode_26]: pass argument 0
move $$arg1 $r462                       ; [call: abi_encode_26]: pass argument 1
move $$arg2 $r463                       ; [call: abi_encode_26]: pass argument 2
fncall .8                               ; [call: abi_encode_26]: call function
addi $r465 $$locbase i40                ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r465                       ; [call: as_raw_slice_29]: pass argument 0
move $$arg1 $$locbase                   ; [call: as_raw_slice_29]: pass argument 1
fncall .12                              ; [call: as_raw_slice_29]: call function
load $r467 data_NonConfigurable_15      ; load constant from data section
lw $r468 $$locbase i0                   ; load slice pointer for logging data
lw $r469 $$locbase i1                   ; load slice size for logging data
logd $zero $r467 $r468 $r469            ; log slice
load $r470 data_NonConfigurable_6       ; load constant from data section
and $r471 $r458 $r470
load $r472 data_NonConfigurable_16      ; load constant from data section
or $r473 $r472 $r471
rvrt $r473
    Finished release [optimized + fuel] target(s) [3.032 KB] in ???
     Running 11 tests, filtered 0 tests

tested -- panicking_script

      test test_panic_in_main ... ok (???, 982 gas)
           revert code: 8000000000000000
             panic message: Error C.
             panic value:   C(true)
             panicked:      in panicking_script::main
                                at panicking_script, src/main.sw:6:5
           decoded log values:
C(true), log rb: 5503570629422409978
      test test_nested_panic_inlined ... ok (???, 1621 gas)
           revert code: 8080000000000000
             panic message: Error E.
             panic value:   E([AsciiString { data: "to have" }, AsciiString { data: "strings" }, AsciiString { data: "in error enum variants" }])
             panicked:      in panicking_lib::nested_panic_inlined
                                at panicking_lib, src/lib.sw:35:5
           decoded log values:
E([AsciiString { data: "to have" }, AsciiString { data: "strings" }, AsciiString { data: "in error enum variants" }]), log rb: 5503570629422409978
      test test_nested_panic_inlined_same_revert_code ... ok (???, 1621 gas)
           revert code: 8080000000000000
             panic message: Error E.
             panic value:   E([AsciiString { data: "to have" }, AsciiString { data: "strings" }, AsciiString { data: "in error enum variants" }])
             panicked:      in panicking_lib::nested_panic_inlined
                                at panicking_lib, src/lib.sw:35:5
           decoded log values:
E([AsciiString { data: "to have" }, AsciiString { data: "strings" }, AsciiString { data: "in error enum variants" }]), log rb: 5503570629422409978
      test test_nested_panic_non_inlined ... ok (???, 1651 gas)
           revert code: 8100000000000000
             panic message: Error E.
             panic value:   E([AsciiString { data: "this" }, AsciiString { data: "is not" }, AsciiString { data: "the best practice" }])
             panicked:      in panicking_lib::nested_panic_non_inlined
                                at panicking_lib, src/lib.sw:41:9
           decoded log values:
E([AsciiString { data: "this" }, AsciiString { data: "is not" }, AsciiString { data: "the best practice" }]), log rb: 5503570629422409978
      test test_nested_panic_non_inlined_same_revert_code ... ok (???, 1651 gas)
           revert code: 8100000000000000
             panic message: Error E.
             panic value:   E([AsciiString { data: "this" }, AsciiString { data: "is not" }, AsciiString { data: "the best practice" }])
             panicked:      in panicking_lib::nested_panic_non_inlined
                                at panicking_lib, src/lib.sw:41:9
           decoded log values:
E([AsciiString { data: "this" }, AsciiString { data: "is not" }, AsciiString { data: "the best practice" }]), log rb: 5503570629422409978
      test test_generic_panic_with_unit ... ok (???, 571 gas)
           revert code: 8180000000000000
             panic value:   ()
             panicked:      in panicking_lib::generic_panic
                                at panicking_lib, src/lib.sw:74:5
           decoded log values:
(), log rb: 3330666440490685604
      test test_generic_panic_with_unit_same_revert_code ... ok (???, 571 gas)
           revert code: 8180000000000000
             panic value:   ()
             panicked:      in panicking_lib::generic_panic
                                at panicking_lib, src/lib.sw:74:5
           decoded log values:
(), log rb: 3330666440490685604
      test test_generic_panic_with_str ... ok (???, 852 gas)
           revert code: 8200000000000000
             panic message: generic panic with string
             panicked:      in panicking_lib::generic_panic
                                at panicking_lib, src/lib.sw:74:5
           decoded log values:
AsciiString { data: "generic panic with string" }, log rb: 10098701174489624218
      test test_generic_panic_with_different_str_same_revert_code ... ok (???, 855 gas)
           revert code: 8200000000000000
             panic message: generic panic with different string
             panicked:      in panicking_lib::generic_panic
                                at panicking_lib, src/lib.sw:74:5
           decoded log values:
AsciiString { data: "generic panic with different string" }, log rb: 10098701174489624218
      test test_generic_panic_with_error_type_enum ... ok (???, 854 gas)
           revert code: 8280000000000000
             panic message: Error A.
             panic value:   A
             panicked:      in panicking_lib::generic_panic
                                at panicking_lib, src/lib.sw:74:5
           decoded log values:
A, log rb: 5503570629422409978
      test test_generic_panic_with_error_type_enum_different_variant_same_revert_code ... ok (???, 955 gas)
           revert code: 8280000000000000
             panic message: Error B.
             panic value:   B(42)
             panicked:      in panicking_lib::generic_panic
                                at panicking_lib, src/lib.sw:74:5
           decoded log values:
B(42), log rb: 5503570629422409978

test result: OK. 11 passed; 0 failed; finished in ???

    Finished in ???
