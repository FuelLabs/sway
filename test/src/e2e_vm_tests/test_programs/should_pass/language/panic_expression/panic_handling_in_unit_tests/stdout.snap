---
source: test/src/snapshot/mod.rs
---
> forc test --path test/src/e2e_vm_tests/test_programs/should_pass/language/panic_expression/panic_handling_in_unit_tests --logs --raw-logs --dbgs --reverts passing_
exit status: 0
output:
    Building test/src/e2e_vm_tests/test_programs/should_pass/language/panic_expression/panic_handling_in_unit_tests
   Compiling library std (sway-lib-std)
DIFF------------------------------
.program:
   Compiling script panic_handling_in_unit_tests (test/src/e2e_vm_tests/test_programs/should_pass/language/panic_expression/panic_handling_in_unit_tests)
DIFF------------------------------
.program:
DIFF------------------------------
.program:
.0                                      ; --- start of function: __entry ---
move $$locbase $sp                      ; [entry init: __entry]: set locals base register
cfei i0                                 ; [entry init: __entry]: allocate: locals 0 byte(s), call args 0 slot(s)
.78
fncall .2                               ; [call: main_0]: call function
 move $r1 $zero                          ; [call: main_0]: copy returned unit value
 movi $r1 i0                             ; [call: main_0]: copy returned unit value
retd $zero $zero                        ; [entry end: __entry] return slice
DIFF------------------------------
.program:
.4                                      ; --- start of function: passing_dbgs_and_logs ---
move $$locbase $sp                      ; [entry init: passing_dbgs_and_logs]: set locals base register
cfei i264                               ; [entry init: passing_dbgs_and_logs]: allocate: locals 264 byte(s), call args 0 slot(s)
.80
addr $r4 data_NonConfigurable_0         ; get __const_global's address in data section
sw $$locbase $r4 i0                     ; store word
addi $r5 $$locbase i8                   ; get offset to aggregate element
movi $r6 i50                            ; initialize constant into register
sw $$locbase $r6 i1                     ; store word
addi $r7 $$locbase i16                  ; get offset to local __ptr slice
mcpi $r7 $$locbase i16                  ; copy memory
addi $r8 $$locbase i224                 ; get offset to local __ptr {  }
addi $r9 $$locbase i224                 ; get offset to local __ptr {  }
addi $r10 $$locbase i224                ; get offset to local __ptr {  }
addr $r11 data_NonConfigurable_1        ; get __const_global0's address in data section
addi $r12 $$locbase i64                 ; get offset to local __ptr { ptr, u64 }
sw $$locbase $r11 i8                    ; store word
addi $r13 $r12 i8                       ; get offset to aggregate element
movi $r14 i75                           ; initialize constant into register
sw $$locbase $r14 i9                    ; store word
addi $r15 $$locbase i80                 ; get offset to local __ptr slice
mcpi $r15 $r12 i16                      ; copy memory
addi $r16 $$locbase i224                ; get offset to local __ptr {  }
addi $r17 $$locbase i80                 ; get offset to local __ptr slice
move $$arg0 $r16                        ; [call: print_str_1]: pass argument 0
move $$arg1 $r17                        ; [call: print_str_1]: pass argument 1
fncall .6                               ; [call: print_str_1]: call function
 move $r18 $zero                         ; [call: print_str_1]: copy returned unit value
 movi $r18 i0                            ; [call: print_str_1]: copy returned unit value
addi $r19 $$locbase i224                ; get offset to local __ptr {  }
addi $r20 $$locbase i16                 ; get offset to local __ptr slice
move $$arg0 $r20                        ; [call: fmt_5]: pass argument 0
move $$arg1 $r19                        ; [call: fmt_5]: pass argument 1
fncall .12                              ; [call: fmt_5]: call function
 move $r21 $zero                         ; [call: fmt_5]: copy returned unit value
 movi $r21 i0                            ; [call: fmt_5]: copy returned unit value
addi $r22 $$locbase i224                ; get offset to local __ptr {  }
addr $r23 data_NonConfigurable_2        ; get __const_global1's address in data section
addi $r24 $$locbase i96                 ; get offset to local __ptr { ptr, u64 }
sw $$locbase $r23 i12                   ; store word
addi $r25 $r24 i8                       ; get offset to aggregate element
sw $$locbase $one i13                   ; store word
addi $r26 $$locbase i112                ; get offset to local __ptr slice
mcpi $r26 $r24 i16                      ; copy memory
addi $r27 $$locbase i224                ; get offset to local __ptr {  }
addi $r28 $$locbase i112                ; get offset to local __ptr slice
move $$arg0 $r27                        ; [call: print_str_1]: pass argument 0
move $$arg1 $r28                        ; [call: print_str_1]: pass argument 1
fncall .6                               ; [call: print_str_1]: call function
 move $r29 $zero                         ; [call: print_str_1]: copy returned unit value
 movi $r29 i0                            ; [call: print_str_1]: copy returned unit value
addr $r30 data_NonConfigurable_3        ; get std::debug::STDERR's address in data section
addi $r31 $$locbase i224                ; get offset to local __ptr u64
mcpi $r31 $r30 i8                       ; copy memory
addi $r32 $$locbase i224                ; get offset to local __ptr u64
lw $r33 $$locbase i28                   ; load word
movi $r34 i1001                         ; initialize constant into register
ecal $r34 $r33 $zero $zero              ; ecal id fd zero zero
 move $r35 $zero                         ; return unit value from ASM block without return register
 movi $r35 i0                            ; return unit value from ASM block without return register
addi $r36 $$locbase i256                ; get offset to local __ptr u64
movi $r37 i42                           ; initialize constant into register
sw $$locbase $r37 i32                   ; store word
addi $r38 $$locbase i224                ; get offset to local __ptr {  }
addi $r39 $$locbase i224                ; get offset to local __ptr {  }
addi $r40 $$locbase i224                ; get offset to local __ptr {  }
addr $r41 data_NonConfigurable_4        ; get __const_global2's address in data section
addi $r42 $$locbase i128                ; get offset to local __ptr { ptr, u64 }
sw $$locbase $r41 i16                   ; store word
addi $r43 $r42 i8                       ; get offset to aggregate element
movi $r44 i24                           ; initialize constant into register
sw $$locbase $r44 i17                   ; store word
addi $r45 $$locbase i144                ; get offset to local __ptr slice
mcpi $r45 $r42 i16                      ; copy memory
addi $r46 $$locbase i224                ; get offset to local __ptr {  }
addi $r47 $$locbase i144                ; get offset to local __ptr slice
move $$arg0 $r46                        ; [call: print_str_1]: pass argument 0
move $$arg1 $r47                        ; [call: print_str_1]: pass argument 1
fncall .6                               ; [call: print_str_1]: call function
 move $r48 $zero                         ; [call: print_str_1]: copy returned unit value
 movi $r48 i0                            ; [call: print_str_1]: copy returned unit value
addi $r49 $$locbase i256                ; get offset to local __ptr u64
lw $r50 $$locbase i32                   ; load word
addi $r51 $$locbase i224                ; get offset to local __ptr {  }
move $$arg0 $r50                        ; [call: fmt_9]: pass argument 0
move $$arg1 $r51                        ; [call: fmt_9]: pass argument 1
fncall .16                              ; [call: fmt_9]: call function
 move $r52 $zero                         ; [call: fmt_9]: copy returned unit value
 movi $r52 i0                            ; [call: fmt_9]: copy returned unit value
addi $r53 $$locbase i224                ; get offset to local __ptr {  }
addr $r54 data_NonConfigurable_2        ; get __const_global3's address in data section
addi $r55 $$locbase i160                ; get offset to local __ptr { ptr, u64 }
sw $$locbase $r54 i20                   ; store word
addi $r56 $r55 i8                       ; get offset to aggregate element
sw $$locbase $one i21                   ; store word
addi $r57 $$locbase i176                ; get offset to local __ptr slice
mcpi $r57 $r55 i16                      ; copy memory
addi $r58 $$locbase i224                ; get offset to local __ptr {  }
addi $r59 $$locbase i176                ; get offset to local __ptr slice
move $$arg0 $r58                        ; [call: print_str_1]: pass argument 0
move $$arg1 $r59                        ; [call: print_str_1]: pass argument 1
fncall .6                               ; [call: print_str_1]: call function
 move $r60 $zero                         ; [call: print_str_1]: copy returned unit value
 movi $r60 i0                            ; [call: print_str_1]: copy returned unit value
addr $r61 data_NonConfigurable_3        ; get std::debug::STDERR's address in data section
addi $r62 $$locbase i232                ; get offset to local __ptr u64
mcpi $r62 $r61 i8                       ; copy memory
addi $r63 $$locbase i232                ; get offset to local __ptr u64
lw $r64 $$locbase i29                   ; load word
movi $r65 i1001                         ; initialize constant into register
ecal $r65 $r64 $zero $zero              ; ecal id fd zero zero
 move $r66 $zero                         ; return unit value from ASM block without return register
 movi $r66 i0                            ; return unit value from ASM block without return register
addr $r67 data_NonConfigurable_5        ; get __const_global4's address in data section
addi $r68 $$locbase i32                 ; get offset to local __ptr { ptr, u64 }
sw $$locbase $r67 i4                    ; store word
addi $r69 $r68 i8                       ; get offset to aggregate element
movi $r70 i36                           ; initialize constant into register
sw $$locbase $r70 i5                    ; store word
addi $r71 $$locbase i48                 ; get offset to local __ptr slice
mcpi $r71 $r68 i16                      ; copy memory
addi $r72 $$locbase i240                ; get offset to local __ptr slice
mcpi $r72 $r71 i16                      ; copy memory
addi $r73 $$locbase i240                ; get offset to local __ptr slice
addi $r74 $$locbase i208                ; get offset to local __ptr slice
move $$arg0 $r73                        ; [call: encode_allow_alias_23]: pass argument 0
move $$arg1 $r74                        ; [call: encode_allow_alias_23]: pass argument 1
fncall .18                              ; [call: encode_allow_alias_23]: call function
 move $r75 $zero                         ; [call: encode_allow_alias_23]: copy returned unit value
 movi $r75 i0                            ; [call: encode_allow_alias_23]: copy returned unit value
addi $r76 $$locbase i192                ; get offset to local __ptr slice
mcpi $r76 $r74 i16                      ; copy memory
load $r77 data_NonConfigurable_6        ; load constant from data section
lw $r78 $$locbase i24                   ; load slice pointer for logging data
lw $r79 $$locbase i25                   ; load slice size for logging data
logd $zero $r77 $r78 $r79               ; log slice
addi $r80 $$locbase i256                ; get offset to local __ptr u64
lw $r81 $$locbase i32                   ; load word
move $$arg0 $r81                        ; [call: log_29]: pass argument 0
fncall .26                              ; [call: log_29]: call function
 move $r82 $zero                         ; [call: log_29]: copy returned unit value
 movi $r82 i0                            ; [call: log_29]: copy returned unit value
ret $zero                               ; [entry end: passing_dbgs_and_logs] return unit as zero
DIFF------------------------------
.program:
.30                                     ; --- start of function: passing_no_dbgs_or_logs ---
move $$locbase $sp                      ; [entry init: passing_no_dbgs_or_logs]: set locals base register
cfei i0                                 ; [entry init: passing_no_dbgs_or_logs]: allocate: locals 0 byte(s), call args 0 slot(s)
.114
ret $zero                               ; [entry end: passing_no_dbgs_or_logs] return unit as zero
DIFF------------------------------
.program:
.32                                     ; --- start of function: failing_revert_intrinsic ---
move $$locbase $sp                      ; [entry init: failing_revert_intrinsic]: set locals base register
cfei i0                                 ; [entry init: failing_revert_intrinsic]: allocate: locals 0 byte(s), call args 0 slot(s)
.115
movi $r447 i112233                      ; initialize constant into register
rvrt $r447
DIFF------------------------------
.program:
.34                                     ; --- start of function: failing_revert_function_with_dbgs_and_logs ---
move $$locbase $sp                      ; [entry init: failing_revert_function_with_dbgs_and_logs]: set locals base register
cfei i264                               ; [entry init: failing_revert_function_with_dbgs_and_logs]: allocate: locals 264 byte(s), call args 0 slot(s)
.116
addr $r449 data_NonConfigurable_8       ; get __const_global5's address in data section
sw $$locbase $r449 i0                   ; store word
addi $r450 $$locbase i8                 ; get offset to aggregate element
movi $r451 i29                          ; initialize constant into register
sw $$locbase $r451 i1                   ; store word
addi $r452 $$locbase i16                ; get offset to local __ptr slice
mcpi $r452 $$locbase i16                ; copy memory
addi $r453 $$locbase i224               ; get offset to local __ptr {  }
addi $r454 $$locbase i224               ; get offset to local __ptr {  }
addi $r455 $$locbase i224               ; get offset to local __ptr {  }
addr $r456 data_NonConfigurable_9       ; get __const_global6's address in data section
addi $r457 $$locbase i64                ; get offset to local __ptr { ptr, u64 }
sw $$locbase $r456 i8                   ; store word
addi $r458 $r457 i8                     ; get offset to aggregate element
movi $r459 i54                          ; initialize constant into register
sw $$locbase $r459 i9                   ; store word
addi $r460 $$locbase i80                ; get offset to local __ptr slice
mcpi $r460 $r457 i16                    ; copy memory
addi $r461 $$locbase i224               ; get offset to local __ptr {  }
addi $r462 $$locbase i80                ; get offset to local __ptr slice
move $$arg0 $r461                       ; [call: print_str_1]: pass argument 0
move $$arg1 $r462                       ; [call: print_str_1]: pass argument 1
fncall .6                               ; [call: print_str_1]: call function
 move $r463 $zero                        ; [call: print_str_1]: copy returned unit value
 movi $r463 i0                           ; [call: print_str_1]: copy returned unit value
addi $r464 $$locbase i224               ; get offset to local __ptr {  }
addi $r465 $$locbase i16                ; get offset to local __ptr slice
move $$arg0 $r465                       ; [call: fmt_5]: pass argument 0
move $$arg1 $r464                       ; [call: fmt_5]: pass argument 1
fncall .12                              ; [call: fmt_5]: call function
 move $r466 $zero                        ; [call: fmt_5]: copy returned unit value
 movi $r466 i0                           ; [call: fmt_5]: copy returned unit value
addi $r467 $$locbase i224               ; get offset to local __ptr {  }
addr $r468 data_NonConfigurable_2       ; get __const_global7's address in data section
addi $r469 $$locbase i96                ; get offset to local __ptr { ptr, u64 }
sw $$locbase $r468 i12                  ; store word
addi $r470 $r469 i8                     ; get offset to aggregate element
sw $$locbase $one i13                   ; store word
addi $r471 $$locbase i112               ; get offset to local __ptr slice
mcpi $r471 $r469 i16                    ; copy memory
addi $r472 $$locbase i224               ; get offset to local __ptr {  }
addi $r473 $$locbase i112               ; get offset to local __ptr slice
move $$arg0 $r472                       ; [call: print_str_1]: pass argument 0
move $$arg1 $r473                       ; [call: print_str_1]: pass argument 1
fncall .6                               ; [call: print_str_1]: call function
 move $r474 $zero                        ; [call: print_str_1]: copy returned unit value
 movi $r474 i0                           ; [call: print_str_1]: copy returned unit value
addr $r475 data_NonConfigurable_3       ; get std::debug::STDERR's address in data section
addi $r476 $$locbase i224               ; get offset to local __ptr u64
mcpi $r476 $r475 i8                     ; copy memory
addi $r477 $$locbase i224               ; get offset to local __ptr u64
lw $r478 $$locbase i28                  ; load word
movi $r479 i1001                        ; initialize constant into register
ecal $r479 $r478 $zero $zero            ; ecal id fd zero zero
 move $r480 $zero                        ; return unit value from ASM block without return register
 movi $r480 i0                           ; return unit value from ASM block without return register
addi $r481 $$locbase i240               ; get offset to local __ptr u64
load $r482 data_NonConfigurable_10      ; load constant from data section
sw $$locbase $r482 i30                  ; store word
addi $r483 $$locbase i224               ; get offset to local __ptr {  }
addi $r484 $$locbase i224               ; get offset to local __ptr {  }
addi $r485 $$locbase i224               ; get offset to local __ptr {  }
addr $r486 data_NonConfigurable_11      ; get __const_global8's address in data section
addi $r487 $$locbase i128               ; get offset to local __ptr { ptr, u64 }
sw $$locbase $r486 i16                  ; store word
addi $r488 $r487 i8                     ; get offset to aggregate element
movi $r489 i34                          ; initialize constant into register
sw $$locbase $r489 i17                  ; store word
addi $r490 $$locbase i144               ; get offset to local __ptr slice
mcpi $r490 $r487 i16                    ; copy memory
addi $r491 $$locbase i224               ; get offset to local __ptr {  }
addi $r492 $$locbase i144               ; get offset to local __ptr slice
move $$arg0 $r491                       ; [call: print_str_1]: pass argument 0
move $$arg1 $r492                       ; [call: print_str_1]: pass argument 1
fncall .6                               ; [call: print_str_1]: call function
 move $r493 $zero                        ; [call: print_str_1]: copy returned unit value
 movi $r493 i0                           ; [call: print_str_1]: copy returned unit value
addi $r494 $$locbase i240               ; get offset to local __ptr u64
lw $r495 $$locbase i30                  ; load word
addi $r496 $$locbase i224               ; get offset to local __ptr {  }
move $$arg0 $r495                       ; [call: fmt_9]: pass argument 0
move $$arg1 $r496                       ; [call: fmt_9]: pass argument 1
fncall .16                              ; [call: fmt_9]: call function
 move $r497 $zero                        ; [call: fmt_9]: copy returned unit value
 movi $r497 i0                           ; [call: fmt_9]: copy returned unit value
addi $r498 $$locbase i224               ; get offset to local __ptr {  }
addr $r499 data_NonConfigurable_2       ; get __const_global9's address in data section
addi $r500 $$locbase i160               ; get offset to local __ptr { ptr, u64 }
sw $$locbase $r499 i20                  ; store word
addi $r501 $r500 i8                     ; get offset to aggregate element
sw $$locbase $one i21                   ; store word
addi $r502 $$locbase i176               ; get offset to local __ptr slice
mcpi $r502 $r500 i16                    ; copy memory
addi $r503 $$locbase i224               ; get offset to local __ptr {  }
addi $r504 $$locbase i176               ; get offset to local __ptr slice
move $$arg0 $r503                       ; [call: print_str_1]: pass argument 0
move $$arg1 $r504                       ; [call: print_str_1]: pass argument 1
fncall .6                               ; [call: print_str_1]: call function
 move $r505 $zero                        ; [call: print_str_1]: copy returned unit value
 movi $r505 i0                           ; [call: print_str_1]: copy returned unit value
addr $r506 data_NonConfigurable_3       ; get std::debug::STDERR's address in data section
addi $r507 $$locbase i232               ; get offset to local __ptr u64
mcpi $r507 $r506 i8                     ; copy memory
addi $r508 $$locbase i232               ; get offset to local __ptr u64
lw $r509 $$locbase i29                  ; load word
movi $r510 i1001                        ; initialize constant into register
ecal $r510 $r509 $zero $zero            ; ecal id fd zero zero
 move $r511 $zero                        ; return unit value from ASM block without return register
 movi $r511 i0                           ; return unit value from ASM block without return register
addr $r512 data_NonConfigurable_12      ; get __const_global10's address in data section
addi $r513 $$locbase i32                ; get offset to local __ptr { ptr, u64 }
sw $$locbase $r512 i4                   ; store word
addi $r514 $r513 i8                     ; get offset to aggregate element
movi $r515 i38                          ; initialize constant into register
sw $$locbase $r515 i5                   ; store word
addi $r516 $$locbase i48                ; get offset to local __ptr slice
mcpi $r516 $r513 i16                    ; copy memory
addi $r517 $$locbase i248               ; get offset to local __ptr slice
mcpi $r517 $r516 i16                    ; copy memory
addi $r518 $$locbase i248               ; get offset to local __ptr slice
addi $r519 $$locbase i208               ; get offset to local __ptr slice
move $$arg0 $r518                       ; [call: encode_allow_alias_23]: pass argument 0
move $$arg1 $r519                       ; [call: encode_allow_alias_23]: pass argument 1
fncall .18                              ; [call: encode_allow_alias_23]: call function
 move $r520 $zero                        ; [call: encode_allow_alias_23]: copy returned unit value
 movi $r520 i0                           ; [call: encode_allow_alias_23]: copy returned unit value
addi $r521 $$locbase i192               ; get offset to local __ptr slice
mcpi $r521 $r519 i16                    ; copy memory
load $r522 data_NonConfigurable_6       ; load constant from data section
lw $r523 $$locbase i24                  ; load slice pointer for logging data
lw $r524 $$locbase i25                  ; load slice size for logging data
logd $zero $r522 $r523 $r524            ; log slice
addi $r525 $$locbase i240               ; get offset to local __ptr u64
lw $r526 $$locbase i30                  ; load word
rvrt $r526
DIFF------------------------------
.program:
.36                                     ; --- start of function: failing_error_signal_assert ---
move $$locbase $sp                      ; [entry init: failing_error_signal_assert]: set locals base register
cfei i520                               ; [entry init: failing_error_signal_assert]: allocate: locals 520 byte(s), call args 0 slot(s)
.117
sw $$locbase $zero i0                   ; store word
addi $r528 $$locbase i376               ; get offset to local __ptr {  }
addi $r529 $$locbase i416               ; get offset to local __ptr {  }
addi $r530 $$locbase i416               ; get offset to local __ptr {  }
addr $r531 data_NonConfigurable_13      ; get __const_global11's address in data section
addi $r532 $$locbase i72                ; get offset to local __ptr { ptr, u64 }
sw $$locbase $r531 i9                   ; store word
addi $r533 $r532 i8                     ; get offset to aggregate element
movi $r534 i35                          ; initialize constant into register
sw $$locbase $r534 i10                  ; store word
addi $r535 $$locbase i136               ; get offset to local __ptr slice
mcpi $r535 $r532 i16                    ; copy memory
addi $r536 $$locbase i376               ; get offset to local __ptr {  }
addi $r537 $$locbase i136               ; get offset to local __ptr slice
move $$arg0 $r536                       ; [call: print_str_1]: pass argument 0
move $$arg1 $r537                       ; [call: print_str_1]: pass argument 1
fncall .6                               ; [call: print_str_1]: call function
 move $r538 $zero                        ; [call: print_str_1]: copy returned unit value
 movi $r538 i0                           ; [call: print_str_1]: copy returned unit value
addi $r539 $$locbase i416               ; get offset to local __ptr {  }
addi $r540 $$locbase i384               ; get offset to local __ptr __ptr {  }
sw $$locbase $r539 i48                  ; store word
addi $r541 $$locbase i312               ; get offset to local __ptr { u64, ( () | bool | slice | slice ) }
mcpi $r541 $$locbase i24                ; copy memory
addi $r542 $$locbase i424               ; get offset to local __ptr u64
sw $$locbase $zero i53                  ; store word
lw $r543 $$locbase i0                   ; load word
addi $r544 $$locbase i424               ; get offset to local __ptr u64
lw $r545 $$locbase i53                  ; load word
eq $r546 $r543 $r545
jnzi $r546 .118
ji  .119
.119
addi $r547 $$locbase i312               ; get offset to local __ptr { u64, ( () | bool | slice | slice ) }
addi $r548 $$locbase i432               ; get offset to local __ptr u64
sw $$locbase $one i54                   ; store word
lw $r549 $$locbase i39                  ; load word
addi $r550 $$locbase i432               ; get offset to local __ptr u64
lw $r551 $$locbase i54                  ; load word
eq $r552 $r549 $r551
jnzi $r552 .120
ji  .121
.121
addi $r553 $$locbase i312               ; get offset to local __ptr { u64, ( () | bool | slice | slice ) }
addi $r554 $$locbase i440               ; get offset to local __ptr u64
movi $r555 i2                           ; initialize constant into register
sw $$locbase $r555 i55                  ; store word
lw $r556 $$locbase i39                  ; load word
addi $r557 $$locbase i440               ; get offset to local __ptr u64
lw $r558 $$locbase i55                  ; load word
eq $r559 $r556 $r558
jnzi $r559 .122
ji  .123
.123
addi $r560 $$locbase i312               ; get offset to local __ptr { u64, ( () | bool | slice | slice ) }
addi $r561 $$locbase i448               ; get offset to local __ptr u64
movi $r562 i3                           ; initialize constant into register
sw $$locbase $r562 i56                  ; store word
lw $r563 $$locbase i39                  ; load word
addi $r564 $$locbase i448               ; get offset to local __ptr u64
lw $r565 $$locbase i56                  ; load word
eq $r566 $r563 $r565
jnzi $r566 .124
ji  .125
.125
load $r567 data_NonConfigurable_14      ; load constant from data section
rvrt $r567
.124
addi $r568 $$locbase i312               ; get offset to local __ptr { u64, ( () | bool | slice | slice ) }
addi $r569 $r568 i8                     ; get offset to aggregate element
addi $r570 $$locbase i384               ; get offset to local __ptr __ptr {  }
lw $r571 $$locbase i48                  ; load word
addr $r572 data_NonConfigurable_15      ; get __const_global21's address in data section
addi $r573 $$locbase i280               ; get offset to local __ptr { ptr, u64 }
sw $$locbase $r572 i35                  ; store word
addi $r574 $r573 i8                     ; get offset to aggregate element
movi $r575 i9                           ; initialize constant into register
sw $$locbase $r575 i36                  ; store word
addi $r576 $$locbase i296               ; get offset to local __ptr slice
mcpi $r576 $r573 i16                    ; copy memory
addi $r577 $$locbase i376               ; get offset to local __ptr {  }
addi $r578 $$locbase i296               ; get offset to local __ptr slice
addi $r579 $$locbase i352               ; get offset to local __ptr { {  }, bool }
move $$arg0 $r577                       ; [call: debug_tuple_39]: pass argument 0
move $$arg1 $r578                       ; [call: debug_tuple_39]: pass argument 1
move $$arg2 $r579                       ; [call: debug_tuple_39]: pass argument 2
fncall .40                              ; [call: debug_tuple_39]: call function
 move $r580 $zero                        ; [call: debug_tuple_39]: copy returned unit value
 movi $r580 i0                           ; [call: debug_tuple_39]: copy returned unit value
addi $r581 $$locbase i496               ; get offset to local __ptr { {  }, bool }
mcpi $r581 $r579 i8                     ; copy memory
addi $r582 $$locbase i368               ; get offset to local __ptr { {  }, bool }
move $$arg0 $r581                       ; [call: field_41]: pass argument 0
move $$arg1 $r569                       ; [call: field_41]: pass argument 1
move $$arg2 $r582                       ; [call: field_41]: pass argument 2
fncall .42                              ; [call: field_41]: call function
 move $r583 $zero                        ; [call: field_41]: copy returned unit value
 movi $r583 i0                           ; [call: field_41]: copy returned unit value
addi $r584 $$locbase i504               ; get offset to local __ptr { {  }, bool }
mcpi $r584 $r582 i8                     ; copy memory
move $$arg0 $r584                       ; [call: finish_36]: pass argument 0
fncall .38                              ; [call: finish_36]: call function
 move $r585 $zero                        ; [call: finish_36]: copy returned unit value
 movi $r585 i0                           ; [call: finish_36]: copy returned unit value
ji  .126
.122
addi $r586 $$locbase i312               ; get offset to local __ptr { u64, ( () | bool | slice | slice ) }
addi $r587 $r586 i8                     ; get offset to aggregate element
addi $r588 $$locbase i384               ; get offset to local __ptr __ptr {  }
lw $r589 $$locbase i48                  ; load word
addr $r590 data_NonConfigurable_15      ; get __const_global20's address in data section
addi $r591 $$locbase i248               ; get offset to local __ptr { ptr, u64 }
sw $$locbase $r590 i31                  ; store word
addi $r592 $r591 i8                     ; get offset to aggregate element
movi $r593 i9                           ; initialize constant into register
sw $$locbase $r593 i32                  ; store word
addi $r594 $$locbase i264               ; get offset to local __ptr slice
mcpi $r594 $r591 i16                    ; copy memory
addi $r595 $$locbase i376               ; get offset to local __ptr {  }
addi $r596 $$locbase i264               ; get offset to local __ptr slice
addi $r597 $$locbase i344               ; get offset to local __ptr { {  }, bool }
move $$arg0 $r595                       ; [call: debug_tuple_39]: pass argument 0
move $$arg1 $r596                       ; [call: debug_tuple_39]: pass argument 1
move $$arg2 $r597                       ; [call: debug_tuple_39]: pass argument 2
fncall .40                              ; [call: debug_tuple_39]: call function
 move $r598 $zero                        ; [call: debug_tuple_39]: copy returned unit value
 movi $r598 i0                           ; [call: debug_tuple_39]: copy returned unit value
addi $r599 $$locbase i480               ; get offset to local __ptr { {  }, bool }
mcpi $r599 $r597 i8                     ; copy memory
addi $r600 $$locbase i360               ; get offset to local __ptr { {  }, bool }
move $$arg0 $r599                       ; [call: field_41]: pass argument 0
move $$arg1 $r587                       ; [call: field_41]: pass argument 1
move $$arg2 $r600                       ; [call: field_41]: pass argument 2
fncall .42                              ; [call: field_41]: call function
 move $r601 $zero                        ; [call: field_41]: copy returned unit value
 movi $r601 i0                           ; [call: field_41]: copy returned unit value
addi $r602 $$locbase i488               ; get offset to local __ptr { {  }, bool }
mcpi $r602 $r600 i8                     ; copy memory
move $$arg0 $r602                       ; [call: finish_36]: pass argument 0
fncall .38                              ; [call: finish_36]: call function
 move $r603 $zero                        ; [call: finish_36]: copy returned unit value
 movi $r603 i0                           ; [call: finish_36]: copy returned unit value
ji  .126
.120
addi $r604 $$locbase i312               ; get offset to local __ptr { u64, ( () | bool | slice | slice ) }
addi $r605 $r604 i23                    ; get offset to aggregate element
addi $r606 $$locbase i384               ; get offset to local __ptr __ptr {  }
lw $r607 $$locbase i48                  ; load word
addr $r608 data_NonConfigurable_15      ; get __const_global18's address in data section
addi $r609 $$locbase i152               ; get offset to local __ptr { ptr, u64 }
sw $$locbase $r608 i19                  ; store word
addi $r610 $r609 i8                     ; get offset to aggregate element
movi $r611 i9                           ; initialize constant into register
sw $$locbase $r611 i20                  ; store word
addi $r612 $$locbase i200               ; get offset to local __ptr slice
mcpi $r612 $r609 i16                    ; copy memory
addi $r613 $$locbase i376               ; get offset to local __ptr {  }
addi $r614 $$locbase i200               ; get offset to local __ptr slice
addi $r615 $$locbase i336               ; get offset to local __ptr { {  }, bool }
move $$arg0 $r613                       ; [call: debug_tuple_39]: pass argument 0
move $$arg1 $r614                       ; [call: debug_tuple_39]: pass argument 1
move $$arg2 $r615                       ; [call: debug_tuple_39]: pass argument 2
fncall .40                              ; [call: debug_tuple_39]: call function
 move $r616 $zero                        ; [call: debug_tuple_39]: copy returned unit value
 movi $r616 i0                           ; [call: debug_tuple_39]: copy returned unit value
addi $r617 $$locbase i464               ; get offset to local __ptr { {  }, bool }
mcpi $r617 $r615 i8                     ; copy memory
addi $r618 $$locbase i456               ; get offset to local __ptr __ptr { {  }, bool }
sw $$locbase $r617 i57                  ; store word
addi $r619 $$locbase i512               ; get offset to local __ptr bool
mcpi $r619 $r605 i1                     ; copy memory
addi $r620 $$locbase i456               ; get offset to local __ptr __ptr { {  }, bool }
lw $r621 $$locbase i57                  ; load word
lb $r622 $r621 i0                       ; load byte
jnzi $r622 .127
ji  .128
.127
addi $r623 $$locbase i456               ; get offset to local __ptr __ptr { {  }, bool }
lw $r624 $$locbase i57                  ; load word
addr $r625 data_NonConfigurable_16      ; get __const_global14's address in data section
addi $r626 $$locbase i40                ; get offset to local __ptr { ptr, u64 }
sw $$locbase $r625 i5                   ; store word
addi $r627 $r626 i8                     ; get offset to aggregate element
movi $r628 i2                           ; initialize constant into register
sw $$locbase $r628 i6                   ; store word
addi $r629 $$locbase i104               ; get offset to local __ptr slice
mcpi $r629 $r626 i16                    ; copy memory
addi $r630 $$locbase i376               ; get offset to local __ptr {  }
addi $r631 $$locbase i104               ; get offset to local __ptr slice
move $$arg0 $r630                       ; [call: print_str_1]: pass argument 0
move $$arg1 $r631                       ; [call: print_str_1]: pass argument 1
fncall .6                               ; [call: print_str_1]: call function
 move $r632 $zero                        ; [call: print_str_1]: copy returned unit value
 movi $r632 i0                           ; [call: print_str_1]: copy returned unit value
ji  .128
.128
addi $r633 $$locbase i512               ; get offset to local __ptr bool
addi $r634 $$locbase i456               ; get offset to local __ptr __ptr { {  }, bool }
lw $r635 $$locbase i57                  ; load word
addi $r636 $$locbase i408               ; get offset to local __ptr __ptr {  }
sw $$locbase $r635 i51                  ; store word
lb $r637 $r633 i0                       ; load byte
jnzi $r637 .129
ji  .130
.130
addi $r638 $$locbase i408               ; get offset to local __ptr __ptr {  }
lw $r639 $$locbase i51                  ; load word
addr $r640 data_NonConfigurable_17      ; get __const_global16's address in data section
addi $r641 $$locbase i168               ; get offset to local __ptr { ptr, u64 }
sw $$locbase $r640 i21                  ; store word
addi $r642 $r641 i8                     ; get offset to aggregate element
movi $r643 i5                           ; initialize constant into register
sw $$locbase $r643 i22                  ; store word
addi $r644 $$locbase i216               ; get offset to local __ptr slice
mcpi $r644 $r641 i16                    ; copy memory
addi $r645 $$locbase i376               ; get offset to local __ptr {  }
addi $r646 $$locbase i216               ; get offset to local __ptr slice
move $$arg0 $r645                       ; [call: print_str_1]: pass argument 0
move $$arg1 $r646                       ; [call: print_str_1]: pass argument 1
fncall .6                               ; [call: print_str_1]: call function
 move $r647 $zero                        ; [call: print_str_1]: copy returned unit value
 movi $r647 i0                           ; [call: print_str_1]: copy returned unit value
ji  .131
.129
addi $r648 $$locbase i408               ; get offset to local __ptr __ptr {  }
lw $r649 $$locbase i51                  ; load word
addr $r650 data_NonConfigurable_18      ; get __const_global15's address in data section
addi $r651 $$locbase i56                ; get offset to local __ptr { ptr, u64 }
sw $$locbase $r650 i7                   ; store word
addi $r652 $r651 i8                     ; get offset to aggregate element
movi $r653 i4                           ; initialize constant into register
sw $$locbase $r653 i8                   ; store word
addi $r654 $$locbase i120               ; get offset to local __ptr slice
mcpi $r654 $r651 i16                    ; copy memory
addi $r655 $$locbase i376               ; get offset to local __ptr {  }
addi $r656 $$locbase i120               ; get offset to local __ptr slice
move $$arg0 $r655                       ; [call: print_str_1]: pass argument 0
move $$arg1 $r656                       ; [call: print_str_1]: pass argument 1
fncall .6                               ; [call: print_str_1]: call function
 move $r657 $zero                        ; [call: print_str_1]: copy returned unit value
 movi $r657 i0                           ; [call: print_str_1]: copy returned unit value
ji  .131
.131
addi $r658 $$locbase i456               ; get offset to local __ptr __ptr { {  }, bool }
lw $r659 $$locbase i57                  ; load word
sb $r659 $one i0                        ; store byte
addi $r660 $$locbase i456               ; get offset to local __ptr __ptr { {  }, bool }
lw $r661 $$locbase i57                  ; load word
addi $r662 $$locbase i376               ; get offset to local __ptr { {  }, bool }
mcpi $r662 $r661 i8                     ; copy memory
addi $r663 $$locbase i472               ; get offset to local __ptr { {  }, bool }
mcpi $r663 $r662 i8                     ; copy memory
move $$arg0 $r663                       ; [call: finish_36]: pass argument 0
fncall .38                              ; [call: finish_36]: call function
 move $r664 $zero                        ; [call: finish_36]: copy returned unit value
 movi $r664 i0                           ; [call: finish_36]: copy returned unit value
ji  .126
.118
addi $r665 $$locbase i384               ; get offset to local __ptr __ptr {  }
lw $r666 $$locbase i48                  ; load word
addr $r667 data_NonConfigurable_19      ; get __const_global12's address in data section
addi $r668 $$locbase i24                ; get offset to local __ptr { ptr, u64 }
sw $$locbase $r667 i3                   ; store word
addi $r669 $r668 i8                     ; get offset to aggregate element
sw $$locbase $one i4                    ; store word
addi $r670 $$locbase i88                ; get offset to local __ptr slice
mcpi $r670 $r668 i16                    ; copy memory
addi $r671 $$locbase i376               ; get offset to local __ptr {  }
addi $r672 $$locbase i88                ; get offset to local __ptr slice
move $$arg0 $r671                       ; [call: print_str_1]: pass argument 0
move $$arg1 $r672                       ; [call: print_str_1]: pass argument 1
fncall .6                               ; [call: print_str_1]: call function
 move $r673 $zero                        ; [call: print_str_1]: copy returned unit value
 movi $r673 i0                           ; [call: print_str_1]: copy returned unit value
ji  .126
.126
addi $r674 $$locbase i416               ; get offset to local __ptr {  }
addr $r675 data_NonConfigurable_2       ; get __const_global22's address in data section
addi $r676 $$locbase i184               ; get offset to local __ptr { ptr, u64 }
sw $$locbase $r675 i23                  ; store word
addi $r677 $r676 i8                     ; get offset to aggregate element
sw $$locbase $one i24                   ; store word
addi $r678 $$locbase i232               ; get offset to local __ptr slice
mcpi $r678 $r676 i16                    ; copy memory
addi $r679 $$locbase i376               ; get offset to local __ptr {  }
addi $r680 $$locbase i232               ; get offset to local __ptr slice
move $$arg0 $r679                       ; [call: print_str_1]: pass argument 0
move $$arg1 $r680                       ; [call: print_str_1]: pass argument 1
fncall .6                               ; [call: print_str_1]: call function
 move $r681 $zero                        ; [call: print_str_1]: copy returned unit value
 movi $r681 i0                           ; [call: print_str_1]: copy returned unit value
addr $r682 data_NonConfigurable_3       ; get std::debug::STDERR's address in data section
addi $r683 $$locbase i416               ; get offset to local __ptr u64
mcpi $r683 $r682 i8                     ; copy memory
addi $r684 $$locbase i416               ; get offset to local __ptr u64
lw $r685 $$locbase i52                  ; load word
movi $r686 i1001                        ; initialize constant into register
ecal $r686 $r685 $zero $zero            ; ecal id fd zero zero
 move $r687 $zero                        ; return unit value from ASM block without return register
 movi $r687 i0                           ; return unit value from ASM block without return register
addi $r688 $$locbase i400               ; get offset to local __ptr bool
sb $r688 $zero i0                       ; store byte
addi $r689 $$locbase i400               ; get offset to local __ptr bool
lb $r690 $r689 i0                       ; load byte
eq $r691 $r690 $zero
jnzi $r691 .132
ji  .133
.133
ret $zero                               ; [entry end: failing_error_signal_assert] return unit as zero
.132
addr $r692 data_NonConfigurable_20      ; get std::error_signals::FAILED_ASSERT_SIGNAL's address in data section
addi $r693 $$locbase i392               ; get offset to local __ptr u64
mcpi $r693 $r692 i8                     ; copy memory
addi $r694 $$locbase i392               ; get offset to local __ptr u64
lw $r695 $$locbase i49                  ; load word
rvrt $r695
DIFF------------------------------
.program:
.44                                     ; --- start of function: failing_error_signal_assert_eq ---
move $$locbase $sp                      ; [entry init: failing_error_signal_assert_eq]: set locals base register
cfei i216                               ; [entry init: failing_error_signal_assert_eq]: allocate: locals 216 byte(s), call args 0 slot(s)
.141
addr $r759 data_NonConfigurable_23      ; get __const_global23's address in data section
sw $$locbase $r759 i0                   ; store word
addi $r760 $$locbase i8                 ; get offset to aggregate element
movi $r761 i47                          ; initialize constant into register
sw $$locbase $r761 i1                   ; store word
addi $r762 $$locbase i16                ; get offset to local __ptr slice
mcpi $r762 $$locbase i16                ; copy memory
addi $r763 $$locbase i160               ; get offset to local __ptr {  }
addi $r764 $$locbase i168               ; get offset to local __ptr {  }
addi $r765 $$locbase i168               ; get offset to local __ptr {  }
addr $r766 data_NonConfigurable_24      ; get __const_global24's address in data section
addi $r767 $$locbase i32                ; get offset to local __ptr { ptr, u64 }
sw $$locbase $r766 i4                   ; store word
addi $r768 $r767 i8                     ; get offset to aggregate element
movi $r769 i72                          ; initialize constant into register
sw $$locbase $r769 i5                   ; store word
addi $r770 $$locbase i48                ; get offset to local __ptr slice
mcpi $r770 $r767 i16                    ; copy memory
addi $r771 $$locbase i160               ; get offset to local __ptr {  }
addi $r772 $$locbase i48                ; get offset to local __ptr slice
move $$arg0 $r771                       ; [call: print_str_1]: pass argument 0
move $$arg1 $r772                       ; [call: print_str_1]: pass argument 1
fncall .6                               ; [call: print_str_1]: call function
 move $r773 $zero                        ; [call: print_str_1]: copy returned unit value
 movi $r773 i0                           ; [call: print_str_1]: copy returned unit value
addi $r774 $$locbase i168               ; get offset to local __ptr {  }
addi $r775 $$locbase i16                ; get offset to local __ptr slice
move $$arg0 $r775                       ; [call: fmt_5]: pass argument 0
move $$arg1 $r774                       ; [call: fmt_5]: pass argument 1
fncall .12                              ; [call: fmt_5]: call function
 move $r776 $zero                        ; [call: fmt_5]: copy returned unit value
 movi $r776 i0                           ; [call: fmt_5]: copy returned unit value
addi $r777 $$locbase i168               ; get offset to local __ptr {  }
addr $r778 data_NonConfigurable_2       ; get __const_global25's address in data section
addi $r779 $$locbase i64                ; get offset to local __ptr { ptr, u64 }
sw $$locbase $r778 i8                   ; store word
addi $r780 $r779 i8                     ; get offset to aggregate element
sw $$locbase $one i9                    ; store word
addi $r781 $$locbase i80                ; get offset to local __ptr slice
mcpi $r781 $r779 i16                    ; copy memory
addi $r782 $$locbase i160               ; get offset to local __ptr {  }
addi $r783 $$locbase i80                ; get offset to local __ptr slice
move $$arg0 $r782                       ; [call: print_str_1]: pass argument 0
move $$arg1 $r783                       ; [call: print_str_1]: pass argument 1
fncall .6                               ; [call: print_str_1]: call function
 move $r784 $zero                        ; [call: print_str_1]: copy returned unit value
 movi $r784 i0                           ; [call: print_str_1]: copy returned unit value
addr $r785 data_NonConfigurable_3       ; get std::debug::STDERR's address in data section
addi $r786 $$locbase i168               ; get offset to local __ptr u64
mcpi $r786 $r785 i8                     ; copy memory
addi $r787 $$locbase i168               ; get offset to local __ptr u64
lw $r788 $$locbase i21                  ; load word
movi $r789 i1001                        ; initialize constant into register
ecal $r789 $r788 $zero $zero            ; ecal id fd zero zero
 move $r790 $zero                        ; return unit value from ASM block without return register
 movi $r790 i0                           ; return unit value from ASM block without return register
addr $r791 data_NonConfigurable_25      ; get __const_global26's address in data section
addi $r792 $$locbase i96                ; get offset to local __ptr { ptr, u64 }
sw $$locbase $r791 i12                  ; store word
addi $r793 $r792 i8                     ; get offset to aggregate element
movi $r794 i56                          ; initialize constant into register
sw $$locbase $r794 i13                  ; store word
addi $r795 $$locbase i112               ; get offset to local __ptr slice
mcpi $r795 $r792 i16                    ; copy memory
addi $r796 $$locbase i200               ; get offset to local __ptr slice
mcpi $r796 $r795 i16                    ; copy memory
addi $r797 $$locbase i200               ; get offset to local __ptr slice
addi $r798 $$locbase i144               ; get offset to local __ptr slice
move $$arg0 $r797                       ; [call: encode_allow_alias_23]: pass argument 0
move $$arg1 $r798                       ; [call: encode_allow_alias_23]: pass argument 1
fncall .18                              ; [call: encode_allow_alias_23]: call function
 move $r799 $zero                        ; [call: encode_allow_alias_23]: copy returned unit value
 movi $r799 i0                           ; [call: encode_allow_alias_23]: copy returned unit value
addi $r800 $$locbase i128               ; get offset to local __ptr slice
mcpi $r800 $r798 i16                    ; copy memory
load $r801 data_NonConfigurable_6       ; load constant from data section
lw $r802 $$locbase i16                  ; load slice pointer for logging data
lw $r803 $$locbase i17                  ; load slice size for logging data
logd $zero $r801 $r802 $r803            ; log slice
addi $r804 $$locbase i184               ; get offset to local __ptr u64
movi $r805 i1111                        ; initialize constant into register
sw $$locbase $r805 i23                  ; store word
addi $r806 $$locbase i192               ; get offset to local __ptr u64
movi $r807 i2222                        ; initialize constant into register
sw $$locbase $r807 i24                  ; store word
addi $r808 $$locbase i184               ; get offset to local __ptr u64
lw $r809 $$locbase i23                  ; load word
addi $r810 $$locbase i192               ; get offset to local __ptr u64
lw $r811 $$locbase i24                  ; load word
eq $r812 $r809 $r811
addi $r813 $$locbase i176               ; get offset to local __ptr bool
sb $r813 $r812 i0                       ; store byte
addi $r814 $$locbase i176               ; get offset to local __ptr bool
lb $r815 $r814 i0                       ; load byte
eq $r816 $r815 $zero
jnzi $r816 .142
ji  .143
.143
ret $zero                               ; [entry end: failing_error_signal_assert_eq] return unit as zero
.142
addi $r817 $$locbase i184               ; get offset to local __ptr u64
lw $r818 $$locbase i23                  ; load word
move $$arg0 $r818                       ; [call: log_29]: pass argument 0
fncall .26                              ; [call: log_29]: call function
 move $r819 $zero                        ; [call: log_29]: copy returned unit value
 movi $r819 i0                           ; [call: log_29]: copy returned unit value
addi $r820 $$locbase i192               ; get offset to local __ptr u64
lw $r821 $$locbase i24                  ; load word
move $$arg0 $r821                       ; [call: log_29]: pass argument 0
fncall .26                              ; [call: log_29]: call function
 move $r822 $zero                        ; [call: log_29]: copy returned unit value
 movi $r822 i0                           ; [call: log_29]: copy returned unit value
addr $r823 data_NonConfigurable_26      ; get std::error_signals::FAILED_ASSERT_EQ_SIGNAL's address in data section
addi $r824 $$locbase i160               ; get offset to local __ptr u64
mcpi $r824 $r823 i8                     ; copy memory
addi $r825 $$locbase i160               ; get offset to local __ptr u64
lw $r826 $$locbase i20                  ; load word
rvrt $r826
DIFF------------------------------
.program:
.46                                     ; --- start of function: failing_error_signal_assert_ne ---
move $$locbase $sp                      ; [entry init: failing_error_signal_assert_ne]: set locals base register
cfei i208                               ; [entry init: failing_error_signal_assert_ne]: allocate: locals 208 byte(s), call args 0 slot(s)
.144
addr $r828 data_NonConfigurable_27      ; get __const_global27's address in data section
sw $$locbase $r828 i0                   ; store word
addi $r829 $$locbase i8                 ; get offset to aggregate element
movi $r830 i47                          ; initialize constant into register
sw $$locbase $r830 i1                   ; store word
addi $r831 $$locbase i16                ; get offset to local __ptr slice
mcpi $r831 $$locbase i16                ; copy memory
addi $r832 $$locbase i160               ; get offset to local __ptr {  }
addi $r833 $$locbase i168               ; get offset to local __ptr {  }
addi $r834 $$locbase i168               ; get offset to local __ptr {  }
addr $r835 data_NonConfigurable_28      ; get __const_global28's address in data section
addi $r836 $$locbase i32                ; get offset to local __ptr { ptr, u64 }
sw $$locbase $r835 i4                   ; store word
addi $r837 $r836 i8                     ; get offset to aggregate element
movi $r838 i72                          ; initialize constant into register
sw $$locbase $r838 i5                   ; store word
addi $r839 $$locbase i48                ; get offset to local __ptr slice
mcpi $r839 $r836 i16                    ; copy memory
addi $r840 $$locbase i160               ; get offset to local __ptr {  }
addi $r841 $$locbase i48                ; get offset to local __ptr slice
move $$arg0 $r840                       ; [call: print_str_1]: pass argument 0
move $$arg1 $r841                       ; [call: print_str_1]: pass argument 1
fncall .6                               ; [call: print_str_1]: call function
 move $r842 $zero                        ; [call: print_str_1]: copy returned unit value
 movi $r842 i0                           ; [call: print_str_1]: copy returned unit value
addi $r843 $$locbase i168               ; get offset to local __ptr {  }
addi $r844 $$locbase i16                ; get offset to local __ptr slice
move $$arg0 $r844                       ; [call: fmt_5]: pass argument 0
move $$arg1 $r843                       ; [call: fmt_5]: pass argument 1
fncall .12                              ; [call: fmt_5]: call function
 move $r845 $zero                        ; [call: fmt_5]: copy returned unit value
 movi $r845 i0                           ; [call: fmt_5]: copy returned unit value
addi $r846 $$locbase i168               ; get offset to local __ptr {  }
addr $r847 data_NonConfigurable_2       ; get __const_global29's address in data section
addi $r848 $$locbase i64                ; get offset to local __ptr { ptr, u64 }
sw $$locbase $r847 i8                   ; store word
addi $r849 $r848 i8                     ; get offset to aggregate element
sw $$locbase $one i9                    ; store word
addi $r850 $$locbase i80                ; get offset to local __ptr slice
mcpi $r850 $r848 i16                    ; copy memory
addi $r851 $$locbase i160               ; get offset to local __ptr {  }
addi $r852 $$locbase i80                ; get offset to local __ptr slice
move $$arg0 $r851                       ; [call: print_str_1]: pass argument 0
move $$arg1 $r852                       ; [call: print_str_1]: pass argument 1
fncall .6                               ; [call: print_str_1]: call function
 move $r853 $zero                        ; [call: print_str_1]: copy returned unit value
 movi $r853 i0                           ; [call: print_str_1]: copy returned unit value
addr $r854 data_NonConfigurable_3       ; get std::debug::STDERR's address in data section
addi $r855 $$locbase i168               ; get offset to local __ptr u64
mcpi $r855 $r854 i8                     ; copy memory
addi $r856 $$locbase i168               ; get offset to local __ptr u64
lw $r857 $$locbase i21                  ; load word
movi $r858 i1001                        ; initialize constant into register
ecal $r858 $r857 $zero $zero            ; ecal id fd zero zero
 move $r859 $zero                        ; return unit value from ASM block without return register
 movi $r859 i0                           ; return unit value from ASM block without return register
addr $r860 data_NonConfigurable_25      ; get __const_global30's address in data section
addi $r861 $$locbase i96                ; get offset to local __ptr { ptr, u64 }
sw $$locbase $r860 i12                  ; store word
addi $r862 $r861 i8                     ; get offset to aggregate element
movi $r863 i56                          ; initialize constant into register
sw $$locbase $r863 i13                  ; store word
addi $r864 $$locbase i112               ; get offset to local __ptr slice
mcpi $r864 $r861 i16                    ; copy memory
addi $r865 $$locbase i192               ; get offset to local __ptr slice
mcpi $r865 $r864 i16                    ; copy memory
addi $r866 $$locbase i192               ; get offset to local __ptr slice
addi $r867 $$locbase i144               ; get offset to local __ptr slice
move $$arg0 $r866                       ; [call: encode_allow_alias_23]: pass argument 0
move $$arg1 $r867                       ; [call: encode_allow_alias_23]: pass argument 1
fncall .18                              ; [call: encode_allow_alias_23]: call function
 move $r868 $zero                        ; [call: encode_allow_alias_23]: copy returned unit value
 movi $r868 i0                           ; [call: encode_allow_alias_23]: copy returned unit value
addi $r869 $$locbase i128               ; get offset to local __ptr slice
mcpi $r869 $r867 i16                    ; copy memory
load $r870 data_NonConfigurable_6       ; load constant from data section
lw $r871 $$locbase i16                  ; load slice pointer for logging data
lw $r872 $$locbase i17                  ; load slice size for logging data
logd $zero $r870 $r871 $r872            ; log slice
addi $r873 $$locbase i176               ; get offset to local __ptr u64
movi $r874 i3333                        ; initialize constant into register
sw $$locbase $r874 i22                  ; store word
addi $r875 $$locbase i184               ; get offset to local __ptr u64
movi $r876 i3333                        ; initialize constant into register
sw $$locbase $r876 i23                  ; store word
addi $r877 $$locbase i176               ; get offset to local __ptr u64
lw $r878 $$locbase i22                  ; load word
addi $r879 $$locbase i184               ; get offset to local __ptr u64
lw $r880 $$locbase i23                  ; load word
eq $r881 $r878 $r880
jnzi $r881 .145
ji  .146
.146
ret $zero                               ; [entry end: failing_error_signal_assert_ne] return unit as zero
.145
addi $r882 $$locbase i176               ; get offset to local __ptr u64
lw $r883 $$locbase i22                  ; load word
move $$arg0 $r883                       ; [call: log_29]: pass argument 0
fncall .26                              ; [call: log_29]: call function
 move $r884 $zero                        ; [call: log_29]: copy returned unit value
 movi $r884 i0                           ; [call: log_29]: copy returned unit value
addi $r885 $$locbase i184               ; get offset to local __ptr u64
lw $r886 $$locbase i23                  ; load word
move $$arg0 $r886                       ; [call: log_29]: pass argument 0
fncall .26                              ; [call: log_29]: call function
 move $r887 $zero                        ; [call: log_29]: copy returned unit value
 movi $r887 i0                           ; [call: log_29]: copy returned unit value
addr $r888 data_NonConfigurable_29      ; get std::error_signals::FAILED_ASSERT_NE_SIGNAL's address in data section
addi $r889 $$locbase i160               ; get offset to local __ptr u64
mcpi $r889 $r888 i8                     ; copy memory
addi $r890 $$locbase i160               ; get offset to local __ptr u64
lw $r891 $$locbase i20                  ; load word
rvrt $r891
DIFF------------------------------
.program:
.48                                     ; --- start of function: failing_error_signal_require_str_error ---
move $$locbase $sp                      ; [entry init: failing_error_signal_require_str_error]: set locals base register
cfei i112                               ; [entry init: failing_error_signal_require_str_error]: allocate: locals 112 byte(s), call args 0 slot(s)
.147
addr $r893 data_NonConfigurable_30      ; get __const_global31's address in data section
sw $$locbase $r893 i0                   ; store word
addi $r894 $$locbase i8                 ; get offset to aggregate element
movi $r895 i45                          ; initialize constant into register
sw $$locbase $r895 i1                   ; store word
addi $r896 $$locbase i16                ; get offset to local __ptr slice
mcpi $r896 $$locbase i16                ; copy memory
addi $r897 $$locbase i72                ; get offset to local __ptr bool
sb $r897 $zero i0                       ; store byte
addi $r898 $$locbase i80                ; get offset to local __ptr slice
mcpi $r898 $r896 i16                    ; copy memory
addi $r899 $$locbase i72                ; get offset to local __ptr bool
lb $r900 $r899 i0                       ; load byte
eq $r901 $r900 $zero
jnzi $r901 .148
ji  .149
.149
ret $zero                               ; [entry end: failing_error_signal_require_str_error] return unit as zero
.148
addi $r902 $$locbase i80                ; get offset to local __ptr slice
addi $r903 $$locbase i96                ; get offset to local __ptr slice
mcpi $r903 $r902 i16                    ; copy memory
addi $r904 $$locbase i96                ; get offset to local __ptr slice
addi $r905 $$locbase i48                ; get offset to local __ptr slice
move $$arg0 $r904                       ; [call: encode_allow_alias_23]: pass argument 0
move $$arg1 $r905                       ; [call: encode_allow_alias_23]: pass argument 1
fncall .18                              ; [call: encode_allow_alias_23]: call function
 move $r906 $zero                        ; [call: encode_allow_alias_23]: copy returned unit value
 movi $r906 i0                           ; [call: encode_allow_alias_23]: copy returned unit value
addi $r907 $$locbase i32                ; get offset to local __ptr slice
mcpi $r907 $r905 i16                    ; copy memory
load $r908 data_NonConfigurable_6       ; load constant from data section
lw $r909 $$locbase i4                   ; load slice pointer for logging data
lw $r910 $$locbase i5                   ; load slice size for logging data
logd $zero $r908 $r909 $r910            ; log slice
addr $r911 data_NonConfigurable_31      ; get std::error_signals::FAILED_REQUIRE_SIGNAL's address in data section
addi $r912 $$locbase i64                ; get offset to local __ptr u64
mcpi $r912 $r911 i8                     ; copy memory
addi $r913 $$locbase i64                ; get offset to local __ptr u64
lw $r914 $$locbase i8                   ; load word
rvrt $r914
DIFF------------------------------
.program:
.50                                     ; --- start of function: failing_error_signal_require_enum_error ---
move $$locbase $sp                      ; [entry init: failing_error_signal_require_enum_error]: set locals base register
cfei i120                               ; [entry init: failing_error_signal_require_enum_error]: allocate: locals 120 byte(s), call args 0 slot(s)
.150
sw $$locbase $one i0                    ; store word
addi $r916 $$locbase i23                ; get offset to aggregate element
sb $r916 $one i0                        ; store byte
addi $r917 $$locbase i64                ; get offset to local __ptr bool
sb $r917 $zero i0                       ; store byte
addi $r918 $$locbase i72                ; get offset to local __ptr { u64, ( () | bool | slice | slice ) }
mcpi $r918 $$locbase i24                ; copy memory
addi $r919 $$locbase i64                ; get offset to local __ptr bool
lb $r920 $r919 i0                       ; load byte
eq $r921 $r920 $zero
jnzi $r921 .151
ji  .152
.152
ret $zero                               ; [entry end: failing_error_signal_require_enum_error] return unit as zero
.151
addi $r922 $$locbase i72                ; get offset to local __ptr { u64, ( () | bool | slice | slice ) }
addi $r923 $$locbase i96                ; get offset to local __ptr { u64, ( () | bool | slice | slice ) }
mcpi $r923 $r922 i24                    ; copy memory
addi $r924 $$locbase i96                ; get offset to local __ptr { u64, ( () | bool | slice | slice ) }
addi $r925 $$locbase i40                ; get offset to local __ptr slice
move $$arg0 $r924                       ; [call: encode_allow_alias_50]: pass argument 0
move $$arg1 $r925                       ; [call: encode_allow_alias_50]: pass argument 1
fncall .52                              ; [call: encode_allow_alias_50]: call function
 move $r926 $zero                        ; [call: encode_allow_alias_50]: copy returned unit value
 movi $r926 i0                           ; [call: encode_allow_alias_50]: copy returned unit value
addi $r927 $$locbase i24                ; get offset to local __ptr slice
mcpi $r927 $r925 i16                    ; copy memory
load $r928 data_NonConfigurable_32      ; load constant from data section
lw $r929 $$locbase i3                   ; load slice pointer for logging data
lw $r930 $$locbase i4                   ; load slice size for logging data
logd $zero $r928 $r929 $r930            ; log slice
addr $r931 data_NonConfigurable_31      ; get std::error_signals::FAILED_REQUIRE_SIGNAL's address in data section
addi $r932 $$locbase i56                ; get offset to local __ptr u64
mcpi $r932 $r931 i8                     ; copy memory
addi $r933 $$locbase i56                ; get offset to local __ptr u64
lw $r934 $$locbase i7                   ; load word
rvrt $r934
DIFF------------------------------
.program:
.54                                     ; --- start of function: failing_panic_no_arg ---
move $$locbase $sp                      ; [entry init: failing_panic_no_arg]: set locals base register
cfei i32                                ; [entry init: failing_panic_no_arg]: allocate: locals 32 byte(s), call args 0 slot(s)
.178
addi $r1132 $$locbase i16               ; get offset to local __ptr slice
move $$arg0 $$locbase                   ; [call: encode_allow_alias_59]: pass argument 0
move $$arg1 $r1132                      ; [call: encode_allow_alias_59]: pass argument 1
fncall .56                              ; [call: encode_allow_alias_59]: call function
 move $r1133 $zero                       ; [call: encode_allow_alias_59]: copy returned unit value
 movi $r1133 i0                          ; [call: encode_allow_alias_59]: copy returned unit value
mcpi $$locbase $r1132 i16               ; copy memory
load $r1134 data_NonConfigurable_34     ; load constant from data section
lw $r1135 $$locbase i0                  ; load slice pointer for logging data
lw $r1136 $$locbase i1                  ; load slice size for logging data
logd $zero $r1134 $r1135 $r1136         ; log slice
load $r1137 data_NonConfigurable_35     ; load constant from data section
rvrt $r1137
DIFF------------------------------
.program:
.58                                     ; --- start of function: failing_panic_unit_arg ---
move $$locbase $sp                      ; [entry init: failing_panic_unit_arg]: set locals base register
cfei i32                                ; [entry init: failing_panic_unit_arg]: allocate: locals 32 byte(s), call args 0 slot(s)
.183
addi $r1161 $$locbase i16               ; get offset to local __ptr slice
move $$arg0 $$locbase                   ; [call: encode_allow_alias_59]: pass argument 0
move $$arg1 $r1161                      ; [call: encode_allow_alias_59]: pass argument 1
fncall .56                              ; [call: encode_allow_alias_59]: call function
 move $r1162 $zero                       ; [call: encode_allow_alias_59]: copy returned unit value
 movi $r1162 i0                          ; [call: encode_allow_alias_59]: copy returned unit value
mcpi $$locbase $r1161 i16               ; copy memory
load $r1163 data_NonConfigurable_34     ; load constant from data section
lw $r1164 $$locbase i0                  ; load slice pointer for logging data
lw $r1165 $$locbase i1                  ; load slice size for logging data
logd $zero $r1163 $r1164 $r1165         ; log slice
load $r1166 data_NonConfigurable_36     ; load constant from data section
rvrt $r1166
DIFF------------------------------
.program:
.60                                     ; --- start of function: failing_panic_const_eval_str_arg ---
move $$locbase $sp                      ; [entry init: failing_panic_const_eval_str_arg]: set locals base register
cfei i0                                 ; [entry init: failing_panic_const_eval_str_arg]: allocate: locals 0 byte(s), call args 0 slot(s)
.184
load $r1168 data_NonConfigurable_37     ; load constant from data section
rvrt $r1168
DIFF------------------------------
.program:
.62                                     ; --- start of function: failing_panic_const_eval_empty_str_arg ---
move $$locbase $sp                      ; [entry init: failing_panic_const_eval_empty_str_arg]: set locals base register
cfei i0                                 ; [entry init: failing_panic_const_eval_empty_str_arg]: allocate: locals 0 byte(s), call args 0 slot(s)
.185
load $r1170 data_NonConfigurable_38     ; load constant from data section
rvrt $r1170
DIFF------------------------------
.program:
.64                                     ; --- start of function: failing_panic_const_eval_whitespace_str_arg ---
move $$locbase $sp                      ; [entry init: failing_panic_const_eval_whitespace_str_arg]: set locals base register
cfei i0                                 ; [entry init: failing_panic_const_eval_whitespace_str_arg]: allocate: locals 0 byte(s), call args 0 slot(s)
.186
load $r1172 data_NonConfigurable_39     ; load constant from data section
rvrt $r1172
DIFF------------------------------
.program:
.66                                     ; --- start of function: failing_panic_non_const_eval_str_arg ---
move $$locbase $sp                      ; [entry init: failing_panic_non_const_eval_str_arg]: set locals base register
cfei i112                               ; [entry init: failing_panic_non_const_eval_str_arg]: allocate: locals 112 byte(s), call args 0 slot(s)
.187
addr $r1174 data_NonConfigurable_40     ; get __const_global32's address in data section
sw $$locbase $r1174 i0                  ; store word
addi $r1175 $$locbase i8                ; get offset to aggregate element
movi $r1176 i52                         ; initialize constant into register
sw $$locbase $r1176 i1                  ; store word
addi $r1177 $$locbase i16               ; get offset to local __ptr slice
mcpi $r1177 $$locbase i16               ; copy memory
addi $r1178 $$locbase i96               ; get offset to local __ptr slice
mcpi $r1178 $r1177 i16                  ; copy memory
addi $r1179 $$locbase i96               ; get offset to local __ptr slice
addi $r1180 $$locbase i64               ; get offset to local __ptr slice
move $$arg0 $r1179                      ; [call: encode_allow_alias_23]: pass argument 0
move $$arg1 $r1180                      ; [call: encode_allow_alias_23]: pass argument 1
fncall .18                              ; [call: encode_allow_alias_23]: call function
 move $r1181 $zero                       ; [call: encode_allow_alias_23]: copy returned unit value
 movi $r1181 i0                          ; [call: encode_allow_alias_23]: copy returned unit value
addi $r1182 $$locbase i32               ; get offset to local __ptr slice
mcpi $r1182 $r1180 i16                  ; copy memory
load $r1183 data_NonConfigurable_6      ; load constant from data section
lw $r1184 $$locbase i4                  ; load slice pointer for logging data
lw $r1185 $$locbase i5                  ; load slice size for logging data
logd $zero $r1183 $r1184 $r1185         ; log slice
load $r1186 data_NonConfigurable_41     ; load constant from data section
 and $r1187 $one $r1186
 andi $r1187 $r1186 i1
load $r1188 data_NonConfigurable_42     ; load constant from data section
or $r1189 $r1188 $r1187
rvrt $r1189
DIFF------------------------------
.program:
.68                                     ; --- start of function: failing_panic_non_const_eval_str_empty_arg ---
move $$locbase $sp                      ; [entry init: failing_panic_non_const_eval_str_empty_arg]: set locals base register
cfei i112                               ; [entry init: failing_panic_non_const_eval_str_empty_arg]: allocate: locals 112 byte(s), call args 0 slot(s)
.188
addr $r1191 data_NonConfigurable_43     ; get __const_global33's address in data section
sw $$locbase $r1191 i0                  ; store word
addi $r1192 $$locbase i8                ; get offset to aggregate element
sw $$locbase $zero i1                   ; store word
addi $r1193 $$locbase i16               ; get offset to local __ptr slice
mcpi $r1193 $$locbase i16               ; copy memory
addi $r1194 $$locbase i96               ; get offset to local __ptr slice
mcpi $r1194 $r1193 i16                  ; copy memory
addi $r1195 $$locbase i96               ; get offset to local __ptr slice
addi $r1196 $$locbase i64               ; get offset to local __ptr slice
move $$arg0 $r1195                      ; [call: encode_allow_alias_23]: pass argument 0
move $$arg1 $r1196                      ; [call: encode_allow_alias_23]: pass argument 1
fncall .18                              ; [call: encode_allow_alias_23]: call function
 move $r1197 $zero                       ; [call: encode_allow_alias_23]: copy returned unit value
 movi $r1197 i0                          ; [call: encode_allow_alias_23]: copy returned unit value
addi $r1198 $$locbase i32               ; get offset to local __ptr slice
mcpi $r1198 $r1196 i16                  ; copy memory
load $r1199 data_NonConfigurable_6      ; load constant from data section
lw $r1200 $$locbase i4                  ; load slice pointer for logging data
lw $r1201 $$locbase i5                  ; load slice size for logging data
logd $zero $r1199 $r1200 $r1201         ; log slice
movi $r1202 i2                          ; initialize constant into register
load $r1203 data_NonConfigurable_41     ; load constant from data section
 and $r1204 $r1202 $r1203
 andi $r1204 $r1203 i2
load $r1205 data_NonConfigurable_42     ; load constant from data section
or $r1206 $r1205 $r1204
rvrt $r1206
DIFF------------------------------
.program:
.70                                     ; --- start of function: failing_panic_non_const_eval_str_whitespace_arg ---
move $$locbase $sp                      ; [entry init: failing_panic_non_const_eval_str_whitespace_arg]: set locals base register
cfei i112                               ; [entry init: failing_panic_non_const_eval_str_whitespace_arg]: allocate: locals 112 byte(s), call args 0 slot(s)
.189
addr $r1208 data_NonConfigurable_44     ; get __const_global34's address in data section
sw $$locbase $r1208 i0                  ; store word
addi $r1209 $$locbase i8                ; get offset to aggregate element
movi $r1210 i4                          ; initialize constant into register
sw $$locbase $r1210 i1                  ; store word
addi $r1211 $$locbase i16               ; get offset to local __ptr slice
mcpi $r1211 $$locbase i16               ; copy memory
addi $r1212 $$locbase i96               ; get offset to local __ptr slice
mcpi $r1212 $r1211 i16                  ; copy memory
addi $r1213 $$locbase i96               ; get offset to local __ptr slice
addi $r1214 $$locbase i64               ; get offset to local __ptr slice
move $$arg0 $r1213                      ; [call: encode_allow_alias_23]: pass argument 0
move $$arg1 $r1214                      ; [call: encode_allow_alias_23]: pass argument 1
fncall .18                              ; [call: encode_allow_alias_23]: call function
 move $r1215 $zero                       ; [call: encode_allow_alias_23]: copy returned unit value
 movi $r1215 i0                          ; [call: encode_allow_alias_23]: copy returned unit value
addi $r1216 $$locbase i32               ; get offset to local __ptr slice
mcpi $r1216 $r1214 i16                  ; copy memory
load $r1217 data_NonConfigurable_6      ; load constant from data section
lw $r1218 $$locbase i4                  ; load slice pointer for logging data
lw $r1219 $$locbase i5                  ; load slice size for logging data
logd $zero $r1217 $r1218 $r1219         ; log slice
movi $r1220 i3                          ; initialize constant into register
load $r1221 data_NonConfigurable_41     ; load constant from data section
 and $r1222 $r1220 $r1221
 andi $r1222 $r1221 i3
load $r1223 data_NonConfigurable_42     ; load constant from data section
or $r1224 $r1223 $r1222
rvrt $r1224
DIFF------------------------------
.program:
.72                                     ; --- start of function: failing_panic_error_enum_arg ---
move $$locbase $sp                      ; [entry init: failing_panic_error_enum_arg]: set locals base register
cfei i56                                ; [entry init: failing_panic_error_enum_arg]: allocate: locals 56 byte(s), call args 0 slot(s)
.190
sw $$locbase $one i0                    ; store word
addi $r1226 $$locbase i23               ; get offset to aggregate element
sb $r1226 $one i0                       ; store byte
addi $r1227 $$locbase i40               ; get offset to local __ptr slice
move $$arg0 $$locbase                   ; [call: encode_allow_alias_50]: pass argument 0
move $$arg1 $r1227                      ; [call: encode_allow_alias_50]: pass argument 1
fncall .52                              ; [call: encode_allow_alias_50]: call function
 move $r1228 $zero                       ; [call: encode_allow_alias_50]: copy returned unit value
 movi $r1228 i0                          ; [call: encode_allow_alias_50]: copy returned unit value
addi $r1229 $$locbase i24               ; get offset to local __ptr slice
mcpi $r1229 $r1227 i16                  ; copy memory
load $r1230 data_NonConfigurable_32     ; load constant from data section
lw $r1231 $$locbase i3                  ; load slice pointer for logging data
lw $r1232 $$locbase i4                  ; load slice size for logging data
logd $zero $r1230 $r1231 $r1232         ; log slice
load $r1233 data_NonConfigurable_45     ; load constant from data section
rvrt $r1233
DIFF------------------------------
.program:
.74                                     ; --- start of function: failing_panic_error_enum_arg_with_empty_msg ---
move $$locbase $sp                      ; [entry init: failing_panic_error_enum_arg_with_empty_msg]: set locals base register
cfei i88                                ; [entry init: failing_panic_error_enum_arg_with_empty_msg]: allocate: locals 88 byte(s), call args 0 slot(s)
.191
movi $r1235 i2                          ; initialize constant into register
sw $$locbase $r1235 i0                  ; store word
addr $r1236 data_NonConfigurable_46     ; get __const_global35's address in data section
addi $r1237 $$locbase i24               ; get offset to local __ptr { ptr, u64 }
sw $$locbase $r1236 i3                  ; store word
addi $r1238 $r1237 i8                   ; get offset to aggregate element
movi $r1239 i45                         ; initialize constant into register
sw $$locbase $r1239 i4                  ; store word
addi $r1240 $$locbase i40               ; get offset to local __ptr slice
mcpi $r1240 $r1237 i16                  ; copy memory
addi $r1241 $$locbase i8                ; get offset to aggregate element
mcpi $r1241 $r1240 i16                  ; copy memory
addi $r1242 $$locbase i72               ; get offset to local __ptr slice
move $$arg0 $$locbase                   ; [call: encode_allow_alias_50]: pass argument 0
move $$arg1 $r1242                      ; [call: encode_allow_alias_50]: pass argument 1
fncall .52                              ; [call: encode_allow_alias_50]: call function
 move $r1243 $zero                       ; [call: encode_allow_alias_50]: copy returned unit value
 movi $r1243 i0                          ; [call: encode_allow_alias_50]: copy returned unit value
addi $r1244 $$locbase i56               ; get offset to local __ptr slice
mcpi $r1244 $r1242 i16                  ; copy memory
load $r1245 data_NonConfigurable_32     ; load constant from data section
lw $r1246 $$locbase i7                  ; load slice pointer for logging data
lw $r1247 $$locbase i8                  ; load slice size for logging data
logd $zero $r1245 $r1246 $r1247         ; log slice
load $r1248 data_NonConfigurable_47     ; load constant from data section
rvrt $r1248
DIFF------------------------------
.program:
.76                                     ; --- start of function: failing_panic_error_enum_arg_with_whitespace_msg ---
move $$locbase $sp                      ; [entry init: failing_panic_error_enum_arg_with_whitespace_msg]: set locals base register
cfei i88                                ; [entry init: failing_panic_error_enum_arg_with_whitespace_msg]: allocate: locals 88 byte(s), call args 0 slot(s)
.192
movi $r1250 i3                          ; initialize constant into register
sw $$locbase $r1250 i0                  ; store word
addr $r1251 data_NonConfigurable_48     ; get __const_global36's address in data section
addi $r1252 $$locbase i24               ; get offset to local __ptr { ptr, u64 }
sw $$locbase $r1251 i3                  ; store word
addi $r1253 $r1252 i8                   ; get offset to aggregate element
movi $r1254 i49                         ; initialize constant into register
sw $$locbase $r1254 i4                  ; store word
addi $r1255 $$locbase i40               ; get offset to local __ptr slice
mcpi $r1255 $r1252 i16                  ; copy memory
addi $r1256 $$locbase i8                ; get offset to aggregate element
mcpi $r1256 $r1255 i16                  ; copy memory
addi $r1257 $$locbase i72               ; get offset to local __ptr slice
move $$arg0 $$locbase                   ; [call: encode_allow_alias_50]: pass argument 0
move $$arg1 $r1257                      ; [call: encode_allow_alias_50]: pass argument 1
fncall .52                              ; [call: encode_allow_alias_50]: call function
 move $r1258 $zero                       ; [call: encode_allow_alias_50]: copy returned unit value
 movi $r1258 i0                          ; [call: encode_allow_alias_50]: copy returned unit value
addi $r1259 $$locbase i56               ; get offset to local __ptr slice
mcpi $r1259 $r1257 i16                  ; copy memory
load $r1260 data_NonConfigurable_32     ; load constant from data section
lw $r1261 $$locbase i7                  ; load slice pointer for logging data
lw $r1262 $$locbase i8                  ; load slice size for logging data
logd $zero $r1260 $r1261 $r1262         ; log slice
load $r1263 data_NonConfigurable_49     ; load constant from data section
rvrt $r1263
DIFF------------------------------
.program:
.2                                      ; --- start of function: main_0 ---
pusha .2                                ; [fn init: main_0]: push all used registers to stack
move $$locbase $sp                      ; [fn init: main_0]: set locals base register
cfei i0                                 ; [fn init: main_0]: allocate: locals 0 byte(s), call args 0 slot(s)
.79
ji  .3
.3
cfsi i0                                 ; [fn end: main_0] free: locals 0 byte(s), call args 0 slot(s)
popa .2                                 ; [fn end: main_0] restore all used registers
jal $zero $$reta i0                     ; [fn end: main_0] return from call
DIFF------------------------------
.program:
.6                                      ; --- start of function: print_str_1 ---
pusha .6                                ; [fn init: print_str_1]: push all used registers to stack
move $$locbase $sp                      ; [fn init: print_str_1]: set locals base register
cfei i104                               ; [fn init: print_str_1]: allocate: locals 104 byte(s), call args 0 slot(s)
move $r83 $$arg0                        ; [fn init: print_str_1]: copy argument 0 (self)
move $r84 $$arg1                        ; [fn init: print_str_1]: copy argument 1 (s)
move $r85 $$reta                        ; [fn init: print_str_1]: save return address
.81
addi $r86 $$locbase i72                 ; get offset to local __ptr slice
 mcpi $r86 $r84 i16                      ; copy memory
 mcpi $r86 $$arg1 i16                    ; copy memory
addr $r87 data_NonConfigurable_3        ; get std::debug::STDERR's address in data section
lw $r88 $r87 i0                         ; load word
addi $r89 $$locbase i88                 ; get offset to local __ptr slice
mcpi $r89 $r84 i16                      ; copy memory
addi $r90 $$locbase i88                 ; get offset to local __ptr slice
move $r91 $r90                          ; return value from ASM block with return register s
 mcpi $$locbase $r91 i16                 ; copy memory
 mcpi $$locbase $r90 i16                 ; copy memory
addi $r92 $$locbase i32                 ; get offset to local __ptr { ptr, u64 }
mcpi $r92 $$locbase i16                 ; copy memory
addi $r93 $$locbase i48                 ; get offset to local __ptr { ptr, u64 }
mcpi $r93 $$locbase i16                 ; copy memory
addi $r94 $$locbase i48                 ; get offset to local __ptr { ptr, u64 }
addi $r95 $$locbase i64                 ; get offset to local __ptr ptr
mcpi $r95 $r94 i8                       ; copy memory
addi $r96 $$locbase i64                 ; get offset to local __ptr ptr
lw $r97 $$locbase i8                    ; load word
addi $r98 $$locbase i72                 ; get offset to local __ptr slice
addi $r99 $$locbase i16                 ; get offset to local __ptr slice
mcpi $r99 $r98 i16                      ; copy memory
move $$arg0 $r98                        ; [call: len_4]: pass argument 0
fncall .10                              ; [call: len_4]: call function
move $r100 $$retv                       ; [call: len_4]: copy returned value
move $$arg0 $r88                        ; [call: syscall_write_2]: pass argument 0
move $$arg1 $r97                        ; [call: syscall_write_2]: pass argument 1
 move $$arg2 $r100                       ; [call: syscall_write_2]: pass argument 2
 move $$arg2 $$retv                      ; [call: syscall_write_2]: pass argument 2
fncall .8                               ; [call: syscall_write_2]: call function
 move $r101 $zero                        ; [call: syscall_write_2]: copy returned unit value
 movi $r101 i0                           ; [call: syscall_write_2]: copy returned unit value
ji  .7
.7
cfsi i104                               ; [fn end: print_str_1] free: locals 104 byte(s), call args 0 slot(s)
move $$reta $r85                        ; [fn end: print_str_1] restore return address
popa .6                                 ; [fn end: print_str_1] restore all used registers
jal $zero $$reta i0                     ; [fn end: print_str_1] return from call
DIFF------------------------------
.program:
.8                                      ; --- start of function: syscall_write_2 ---
pusha .8                                ; [fn init: syscall_write_2]: push all used registers to stack
move $$locbase $sp                      ; [fn init: syscall_write_2]: set locals base register
cfei i24                                ; [fn init: syscall_write_2]: allocate: locals 24 byte(s), call args 0 slot(s)
.82
addi $r103 $$locbase i16                ; get offset to local __ptr u64
sw $$locbase $$arg0 i2                  ; store word
sw $$locbase $$arg1 i0                  ; store word
addi $r104 $$locbase i8                 ; get offset to local __ptr u64
sw $$locbase $$arg2 i1                  ; store word
addi $r105 $$locbase i16                ; get offset to local __ptr u64
lw $r106 $$locbase i2                   ; load word
lw $r107 $$locbase i0                   ; load word
addi $r108 $$locbase i8                 ; get offset to local __ptr u64
lw $r109 $$locbase i1                   ; load word
movi $r110 i1000                        ; initialize constant into register
ecal $r110 $r106 $r107 $r109            ; ecal id fd buf count
 move $r111 $zero                        ; return unit value from ASM block without return register
 movi $r111 i0                           ; return unit value from ASM block without return register
ji  .9
.9
cfsi i24                                ; [fn end: syscall_write_2] free: locals 24 byte(s), call args 0 slot(s)
popa .8                                 ; [fn end: syscall_write_2] restore all used registers
jal $zero $$reta i0                     ; [fn end: syscall_write_2] return from call
DIFF------------------------------
.program:
.10                                     ; --- start of function: len_4 ---
pusha .10                               ; [fn init: len_4]: push all used registers to stack
move $$locbase $sp                      ; [fn init: len_4]: set locals base register
cfei i56                                ; [fn init: len_4]: allocate: locals 56 byte(s), call args 0 slot(s)
.83
addi $r113 $$locbase i40                ; get offset to local __ptr slice
mcpi $r113 $$arg0 i16                   ; copy memory
addi $r114 $$locbase i40                ; get offset to local __ptr slice
move $r115 $r114                        ; return value from ASM block with return register s
 mcpi $$locbase $r115 i16                ; copy memory
 mcpi $$locbase $r114 i16                ; copy memory
addi $r116 $$locbase i16                ; get offset to local __ptr { ptr, u64 }
mcpi $r116 $$locbase i16                ; copy memory
addi $r117 $$locbase i32                ; get offset to local __ptr u64
addi $r118 $$locbase i8                 ; get offset to aggregate element
mcpi $r117 $r118 i8                     ; copy memory
lw $r119 $$locbase i1                   ; load word
move $$retv $r119                       ; [fn end: len_4] set return value
ji  .11
.11
cfsi i56                                ; [fn end: len_4] free: locals 56 byte(s), call args 0 slot(s)
popa .10                                ; [fn end: len_4] restore all used registers
jal $zero $$reta i0                     ; [fn end: len_4] return from call
DIFF------------------------------
.program:
.12                                     ; --- start of function: fmt_5 ---
pusha .12                               ; [fn init: fmt_5]: push all used registers to stack
move $$locbase $sp                      ; [fn init: fmt_5]: set locals base register
cfei i8                                 ; [fn init: fmt_5]: allocate: locals 8 byte(s), call args 0 slot(s)
move $r120 $$arg0                       ; [fn init: fmt_5]: copy argument 0 (self)
move $r121 $$arg1                       ; [fn init: fmt_5]: copy argument 1 (f)
move $r122 $$reta                       ; [fn init: fmt_5]: save return address
.84
 sw $$locbase $r121 i0                   ; store word
 sw $$locbase $$arg1 i0                  ; store word
lw $r123 $$locbase i0                   ; load word
move $$arg0 $$locbase                   ; [call: print_string_quotes_6]: pass argument 0
fncall .14                              ; [call: print_string_quotes_6]: call function
 move $r124 $zero                        ; [call: print_string_quotes_6]: copy returned unit value
 movi $r124 i0                           ; [call: print_string_quotes_6]: copy returned unit value
lw $r125 $$locbase i0                   ; load word
move $$arg0 $$locbase                   ; [call: print_str_1]: pass argument 0
move $$arg1 $r120                       ; [call: print_str_1]: pass argument 1
fncall .6                               ; [call: print_str_1]: call function
 move $r126 $zero                        ; [call: print_str_1]: copy returned unit value
 movi $r126 i0                           ; [call: print_str_1]: copy returned unit value
lw $r127 $$locbase i0                   ; load word
move $$arg0 $$locbase                   ; [call: print_string_quotes_6]: pass argument 0
fncall .14                              ; [call: print_string_quotes_6]: call function
 move $r128 $zero                        ; [call: print_string_quotes_6]: copy returned unit value
 movi $r128 i0                           ; [call: print_string_quotes_6]: copy returned unit value
ji  .13
.13
cfsi i8                                 ; [fn end: fmt_5] free: locals 8 byte(s), call args 0 slot(s)
move $$reta $r122                       ; [fn end: fmt_5] restore return address
popa .12                                ; [fn end: fmt_5] restore all used registers
jal $zero $$reta i0                     ; [fn end: fmt_5] return from call
DIFF------------------------------
.program:
.14                                     ; --- start of function: print_string_quotes_6 ---
pusha .14                               ; [fn init: print_string_quotes_6]: push all used registers to stack
move $$locbase $sp                      ; [fn init: print_string_quotes_6]: set locals base register
cfei i16                                ; [fn init: print_string_quotes_6]: allocate: locals 16 byte(s), call args 0 slot(s)
move $r129 $$arg0                       ; [fn init: print_string_quotes_6]: copy argument 0 (self)
move $r130 $$reta                       ; [fn init: print_string_quotes_6]: save return address
.85
movi $r131 i1                           ; get array element size
 mul $r132 $zero $r131                   ; get offset to array element
 add $r132 $$locbase $r132               ; add array element offset to array base
 movi $r132 i0                           ; get offset to array element
 move $r132 $$locbase                    ; add array element offset to array base
movi $r133 i34                          ; initialize constant into register
 sb $r132 $r133 i0                       ; store byte
 sb $$locbase $r133 i0                   ; store byte
addi $r134 $$locbase i8                 ; get offset to local __ptr [u8; 1]
mcpi $r134 $$locbase i1                 ; copy memory
addr $r135 data_NonConfigurable_3       ; get std::debug::STDERR's address in data section
lw $r136 $r135 i0                       ; load word
addi $r137 $$locbase i8                 ; get offset to local __ptr [u8; 1]
move $$arg0 $r136                       ; [call: syscall_write_2]: pass argument 0
move $$arg1 $r137                       ; [call: syscall_write_2]: pass argument 1
 move $$arg2 $one                        ; [call: syscall_write_2]: pass argument 2
 movi $$arg2 i1                          ; [call: syscall_write_2]: pass argument 2
fncall .8                               ; [call: syscall_write_2]: call function
 move $r138 $zero                        ; [call: syscall_write_2]: copy returned unit value
 movi $r138 i0                           ; [call: syscall_write_2]: copy returned unit value
ji  .15
.15
cfsi i16                                ; [fn end: print_string_quotes_6] free: locals 16 byte(s), call args 0 slot(s)
move $$reta $r130                       ; [fn end: print_string_quotes_6] restore return address
popa .14                                ; [fn end: print_string_quotes_6] restore all used registers
jal $zero $$reta i0                     ; [fn end: print_string_quotes_6] return from call
DIFF------------------------------
.program:
.16                                     ; --- start of function: fmt_9 ---
pusha .16                               ; [fn init: fmt_9]: push all used registers to stack
move $$locbase $sp                      ; [fn init: fmt_9]: set locals base register
cfei i344                               ; [fn init: fmt_9]: allocate: locals 344 byte(s), call args 0 slot(s)
move $r139 $$arg0                       ; [fn init: fmt_9]: copy argument 0 (self)
move $r140 $$arg1                       ; [fn init: fmt_9]: copy argument 1 (f)
move $r141 $$reta                       ; [fn init: fmt_9]: save return address
.86
addi $r142 $$locbase i224               ; get offset to local __ptr u64
 sw $$locbase $r139 i28                  ; store word
 sw $$locbase $$arg0 i28                 ; store word
addi $r143 $$locbase i144               ; get offset to local __ptr __ptr {  }
sw $$locbase $r140 i18                  ; store word
addi $r144 $$locbase i144               ; get offset to local __ptr __ptr {  }
lw $r145 $$locbase i18                  ; load word
addi $r146 $$locbase i224               ; get offset to local __ptr u64
addi $r147 $$locbase i232               ; get offset to local __ptr {  }
addi $r148 $$locbase i328               ; get offset to local __ptr u64
mcpi $r148 $r146 i8                     ; copy memory
addi $r149 $$locbase i328               ; get offset to local __ptr u64
addi $r150 $$locbase i336               ; get offset to local __ptr u64
mcpi $r150 $r149 i8                     ; copy memory
 move $r151 $zero                        ; move parameter from branch to block argument
 movi $r151 i0                           ; move parameter from branch to block argument
ji  .87
.87
move $r153 $r151                        ; move parameter from branch to block argument
movi $r154 i1                           ; get array element size
 mul $r155 $r153 $r154                   ; get offset to array element
 muli $r155 $r151 i1                     ; get offset to array element
add $r155 $$locbase $r155               ; add array element offset to array base
movi $r156 i48                          ; initialize constant into register
sb $r155 $r156 i0                       ; store byte
 add $r157 $r153 $one
 addi $r157 $r153 i1
movi $r158 i64                          ; initialize constant into register
lt $r159 $r157 $r158
move $r151 $r157                        ; move parameter from branch to block argument
jnzi $r159 .87
ji  .88
.88
addi $r161 $$locbase i80                ; get offset to local __ptr [u8; 64]
mcpi $r161 $$locbase i64                ; copy memory
addi $r162 $$locbase i152               ; get offset to local __ptr u64
movi $r163 i63                          ; initialize constant into register
sw $$locbase $r163 i19                  ; store word
ji  .89
.89
 jnzi $one .90
 ji  .90
ji  .91
.90
addi $r164 $$locbase i336               ; get offset to local __ptr u64
addi $r165 $$locbase i232               ; get offset to local __ptr u64
mcpi $r165 $r164 i8                     ; copy memory
addi $r166 $$locbase i168               ; get offset to local __ptr u64
movi $r167 i10                          ; initialize constant into register
sw $$locbase $r167 i21                  ; store word
addi $r168 $$locbase i232               ; get offset to local __ptr u64
lw $r169 $$locbase i29                  ; load word
addi $r170 $$locbase i168               ; get offset to local __ptr u64
lw $r171 $$locbase i21                  ; load word
mod $r172 $r169 $r171
move $r173 $r172                        ; return value from ASM block with return register v
addi $r174 $$locbase i72                ; get offset to local __ptr u8
 sb $r174 $r173 i0                       ; store byte
 sb $r174 $r172 i0                       ; store byte
addi $r175 $$locbase i72                ; get offset to local __ptr u8
addi $r176 $$locbase i240               ; get offset to local __ptr u8
mcpi $r176 $r175 i1                     ; copy memory
addi $r177 $$locbase i176               ; get offset to local __ptr u8
movi $r178 i48                          ; initialize constant into register
sb $r177 $r178 i0                       ; store byte
addi $r179 $$locbase i240               ; get offset to local __ptr u8
addi $r180 $$locbase i288               ; get offset to local __ptr u8
mcpi $r180 $r179 i1                     ; copy memory
addi $r181 $$locbase i288               ; get offset to local __ptr u8
lb $r182 $r181 i0                       ; load byte
move $r183 $r182                        ; return value from ASM block with return register input
addi $r184 $$locbase i176               ; get offset to local __ptr u8
addi $r185 $$locbase i296               ; get offset to local __ptr u8
mcpi $r185 $r184 i1                     ; copy memory
addi $r186 $$locbase i296               ; get offset to local __ptr u8
lb $r187 $r186 i0                       ; load byte
move $r188 $r187                        ; return value from ASM block with return register input
 add $r189 $r183 $r188
 add $r189 $r183 $r187
addi $r190 $$locbase i216               ; get offset to local __ptr u64
sw $$locbase $r189 i27                  ; store word
addi $r191 $$locbase i304               ; get offset to local __ptr u8
movi $r192 i255                         ; initialize constant into register
sb $r191 $r192 i0                       ; store byte
addi $r193 $$locbase i304               ; get offset to local __ptr u8
lb $r194 $r193 i0                       ; load byte
move $r195 $r194                        ; return value from ASM block with return register input
addi $r196 $$locbase i160               ; get offset to local __ptr u64
 sw $$locbase $r195 i20                  ; store word
 sw $$locbase $r194 i20                  ; store word
addi $r197 $$locbase i216               ; get offset to local __ptr u64
lw $r198 $$locbase i27                  ; load word
addi $r199 $$locbase i160               ; get offset to local __ptr u64
lw $r200 $$locbase i20                  ; load word
gt $r201 $r198 $r200
jnzi $r201 .92
ji  .93
.93
addi $r202 $$locbase i216               ; get offset to local __ptr u64
addi $r203 $$locbase i320               ; get offset to local __ptr u64
mcpi $r203 $r202 i8                     ; copy memory
addi $r204 $$locbase i320               ; get offset to local __ptr u64
lw $r205 $$locbase i40                  ; load word
move $r206 $r205                        ; return value from ASM block with return register input
 move $r207 $r206                        ; move parameter from branch to block argument
 move $r207 $r205                        ; move parameter from branch to block argument
ji  .94
.92
move $r208 $flag                        ; return value from ASM block with return register flag
addr $r209 data_NonConfigurable_3       ; get std::flags::F_WRAPPING_DISABLE_MASK's address in data section
lw $r210 $r209 i0                       ; load word
 and $r211 $r208 $r210
 and $r211 $flag $r210
eq $r212 $r211 $zero
jnzi $r212 .95
ji  .96
.96
addi $r213 $$locbase i216               ; get offset to local __ptr u64
lw $r214 $$locbase i27                  ; load word
addi $r215 $$locbase i160               ; get offset to local __ptr u64
lw $r216 $$locbase i20                  ; load word
 add $r217 $r216 $one
 addi $r217 $r216 i1
mod $r218 $r214 $r217
addi $r219 $$locbase i312               ; get offset to local __ptr u64
sw $$locbase $r218 i39                  ; store word
addi $r220 $$locbase i312               ; get offset to local __ptr u64
lw $r221 $$locbase i39                  ; load word
move $r222 $r221                        ; return value from ASM block with return register input
 move $r207 $r222                        ; move parameter from branch to block argument
 move $r207 $r221                        ; move parameter from branch to block argument
ji  .94
.94
move $r225 $r207                        ; move parameter from branch to block argument
addi $r226 $$locbase i80                ; get offset to local __ptr [u8; 64]
addi $r227 $$locbase i152               ; get offset to local __ptr u64
lw $r228 $$locbase i19                  ; load word
movi $r229 i1                           ; get array element size
 mul $r230 $r228 $r229                   ; get offset to array element
 muli $r230 $r228 i1                     ; get offset to array element
add $r230 $r226 $r230                   ; add array element offset to array base
 sb $r230 $r225 i0                       ; store byte
 sb $r230 $r207 i0                       ; store byte
addi $r231 $$locbase i336               ; get offset to local __ptr u64
addi $r232 $$locbase i248               ; get offset to local __ptr u64
mcpi $r232 $r231 i8                     ; copy memory
addi $r233 $$locbase i184               ; get offset to local __ptr u64
movi $r234 i10                          ; initialize constant into register
sw $$locbase $r234 i23                  ; store word
addi $r235 $$locbase i248               ; get offset to local __ptr u64
lw $r236 $$locbase i31                  ; load word
addi $r237 $$locbase i184               ; get offset to local __ptr u64
lw $r238 $$locbase i23                  ; load word
div $r239 $r236 $r238
addi $r240 $$locbase i336               ; get offset to local __ptr u64
sw $$locbase $r239 i42                  ; store word
addi $r241 $$locbase i336               ; get offset to local __ptr u64
addi $r242 $$locbase i256               ; get offset to local __ptr u64
mcpi $r242 $r241 i8                     ; copy memory
addi $r243 $$locbase i192               ; get offset to local __ptr u64
sw $$locbase $zero i24                  ; store word
addi $r244 $$locbase i256               ; get offset to local __ptr u64
lw $r245 $$locbase i32                  ; load word
addi $r246 $$locbase i192               ; get offset to local __ptr u64
lw $r247 $$locbase i24                  ; load word
eq $r248 $r245 $r247
jnzi $r248 .91
ji  .97
.97
addi $r249 $$locbase i152               ; get offset to local __ptr u64
addi $r250 $$locbase i264               ; get offset to local __ptr u64
mcpi $r250 $r249 i8                     ; copy memory
addi $r251 $$locbase i200               ; get offset to local __ptr u64
sw $$locbase $one i25                   ; store word
addi $r252 $$locbase i264               ; get offset to local __ptr u64
lw $r253 $$locbase i33                  ; load word
addi $r254 $$locbase i200               ; get offset to local __ptr u64
lw $r255 $$locbase i25                  ; load word
sub $r256 $r253 $r255
addi $r257 $$locbase i152               ; get offset to local __ptr u64
sw $$locbase $r256 i19                  ; store word
ji  .89
.91
addr $r258 data_NonConfigurable_3       ; get std::debug::STDERR's address in data section
lw $r259 $r258 i0                       ; load word
addi $r260 $$locbase i80                ; get offset to local __ptr [u8; 64]
addi $r261 $$locbase i152               ; get offset to local __ptr u64
addi $r262 $$locbase i272               ; get offset to local __ptr ptr
sw $$locbase $r260 i34                  ; store word
addi $r263 $$locbase i64                ; get offset to local __ptr u64
mcpi $r263 $r261 i8                     ; copy memory
addi $r264 $$locbase i272               ; get offset to local __ptr ptr
lw $r265 $$locbase i34                  ; load word
addi $r266 $$locbase i64                ; get offset to local __ptr u64
lw $r267 $$locbase i8                   ; load word
 mul $r268 $one $r267
 muli $r268 $r267 i1
add $r269 $r265 $r268
addi $r270 $$locbase i152               ; get offset to local __ptr u64
addi $r271 $$locbase i280               ; get offset to local __ptr u64
movi $r272 i64                          ; initialize constant into register
sw $$locbase $r272 i35                  ; store word
addi $r273 $$locbase i208               ; get offset to local __ptr u64
mcpi $r273 $r270 i8                     ; copy memory
addi $r274 $$locbase i280               ; get offset to local __ptr u64
lw $r275 $$locbase i35                  ; load word
addi $r276 $$locbase i208               ; get offset to local __ptr u64
lw $r277 $$locbase i26                  ; load word
sub $r278 $r275 $r277
move $$arg0 $r259                       ; [call: syscall_write_2]: pass argument 0
move $$arg1 $r269                       ; [call: syscall_write_2]: pass argument 1
move $$arg2 $r278                       ; [call: syscall_write_2]: pass argument 2
fncall .8                               ; [call: syscall_write_2]: call function
 move $r279 $zero                        ; [call: syscall_write_2]: copy returned unit value
 movi $r279 i0                           ; [call: syscall_write_2]: copy returned unit value
ji  .17
.95
rvrt $zero
.17
cfsi i344                               ; [fn end: fmt_9] free: locals 344 byte(s), call args 0 slot(s)
move $$reta $r141                       ; [fn end: fmt_9] restore return address
popa .16                                ; [fn end: fmt_9] restore all used registers
jal $zero $$reta i0                     ; [fn end: fmt_9] return from call
DIFF------------------------------
.program:
.18                                     ; --- start of function: encode_allow_alias_23 ---
pusha .18                               ; [fn init: encode_allow_alias_23]: push all used registers to stack
move $$locbase $sp                      ; [fn init: encode_allow_alias_23]: set locals base register
cfei i192                               ; [fn init: encode_allow_alias_23]: allocate: locals 192 byte(s), call args 0 slot(s)
move $r280 $$arg0                       ; [fn init: encode_allow_alias_23]: copy argument 0 (item)
move $r281 $$arg1                       ; [fn init: encode_allow_alias_23]: copy argument 1 (__ret_value)
move $r282 $$reta                       ; [fn init: encode_allow_alias_23]: save return address
.98
addi $r283 $$locbase i176               ; get offset to local __ptr __ptr slice
 sw $$locbase $r280 i22                  ; store word
 jnzi $zero .99
 sw $$locbase $$arg0 i22                 ; store word
 
ji  .100
.100
addi $r284 $$locbase i176               ; get offset to local __ptr __ptr slice
lw $r285 $$locbase i22                  ; load word
addi $r286 $$locbase i40                ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r286                       ; [call: new_27]: pass argument 0
fncall .22                              ; [call: new_27]: call function
 move $r287 $zero                        ; [call: new_27]: copy returned unit value
 movi $r287 i0                           ; [call: new_27]: copy returned unit value
addi $r288 $$locbase i80                ; get offset to local __ptr slice
mcpi $r288 $r285 i16                    ; copy memory
addi $r289 $$locbase i96                ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r289 $r286 i24                    ; copy memory
addi $r290 $$locbase i16                ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r288                       ; [call: abi_encode_26]: pass argument 0
move $$arg1 $r289                       ; [call: abi_encode_26]: pass argument 1
move $$arg2 $r290                       ; [call: abi_encode_26]: pass argument 2
fncall .20                              ; [call: abi_encode_26]: call function
 move $r291 $zero                        ; [call: abi_encode_26]: copy returned unit value
 movi $r291 i0                           ; [call: abi_encode_26]: copy returned unit value
addi $r292 $$locbase i152               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r292 $r290 i24                    ; copy memory
addi $r293 $$locbase i152               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r294 $$locbase i64                ; get offset to local __ptr slice
move $$arg0 $r293                       ; [call: as_raw_slice_28]: pass argument 0
move $$arg1 $r294                       ; [call: as_raw_slice_28]: pass argument 1
fncall .24                              ; [call: as_raw_slice_28]: call function
 move $r295 $zero                        ; [call: as_raw_slice_28]: copy returned unit value
 movi $r295 i0                           ; [call: as_raw_slice_28]: copy returned unit value
addi $r296 $$locbase i120               ; get offset to local __ptr slice
mcpi $r296 $r294 i16                    ; copy memory
move $r297 $r296                        ; move parameter from branch to block argument
ji  .101
.99
addi $r298 $$locbase i184               ; get offset to local __ptr u64
movi $r299 i16                          ; initialize constant into register
sw $$locbase $r299 i23                  ; store word
addi $r300 $$locbase i136               ; get offset to local __ptr { __ptr slice, u64 }
addi $r301 $$locbase i176               ; get offset to local __ptr __ptr slice
addi $r302 $$locbase i184               ; get offset to local __ptr u64
mcpi $r300 $r301 i8                     ; copy memory
addi $r303 $r300 i8                     ; get offset to aggregate element
mcpi $r303 $r302 i8                     ; copy memory
mcpi $$locbase $r300 i16                ; copy memory
addi $r304 $$locbase i120               ; get offset to local __ptr slice
mcpi $r304 $$locbase i16                ; copy memory
move $r297 $r304                        ; move parameter from branch to block argument
ji  .101
.101
move $r307 $r297                        ; move parameter from branch to block argument
 mcpi $r281 $r307 i16                    ; copy memory
 mcpi $r281 $r297 i16                    ; copy memory
ji  .19
.19
cfsi i192                               ; [fn end: encode_allow_alias_23] free: locals 192 byte(s), call args 0 slot(s)
move $$reta $r282                       ; [fn end: encode_allow_alias_23] restore return address
popa .18                                ; [fn end: encode_allow_alias_23] restore all used registers
jal $zero $$reta i0                     ; [fn end: encode_allow_alias_23] return from call
DIFF------------------------------
.program:
.20                                     ; --- start of function: abi_encode_26 ---
pusha .20                               ; [fn init: abi_encode_26]: push all used registers to stack
move $$locbase $sp                      ; [fn init: abi_encode_26]: set locals base register
cfei i224                               ; [fn init: abi_encode_26]: allocate: locals 224 byte(s), call args 0 slot(s)
.102
addi $r309 $$locbase i208               ; get offset to local __ptr slice
mcpi $r309 $$arg0 i16                   ; copy memory
addi $r310 $$locbase i184               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r310 $$arg1 i24                   ; copy memory
addi $r311 $$locbase i160               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r312 $$locbase i184               ; get offset to local __ptr { { ptr, u64, u64 } }
move $r313 $r312                        ; return value from ASM block with return register buffer
 mcpi $$locbase $r313 i24                ; copy memory
 mcpi $$locbase $r312 i24                ; copy memory
addi $r314 $$locbase i80                ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r314 $$locbase i24                ; copy memory
lw $r315 $$locbase i10                  ; load word
addi $r316 $r314 i8                     ; get offset to aggregate element
lw $r317 $$locbase i11                  ; load word
addi $r318 $r314 i16                    ; get offset to aggregate element
lw $r319 $$locbase i12                  ; load word
addi $r320 $$locbase i208               ; get offset to local __ptr slice
addi $r321 $$locbase i40                ; get offset to local __ptr slice
mcpi $r321 $r320 i16                    ; copy memory
move $r322 $r320                        ; return value from ASM block with return register item
addi $r323 $$locbase i24                ; get offset to local __ptr { u64, u64 }
 mcpi $r323 $r322 i16                    ; copy memory
 mcpi $r323 $r320 i16                    ; copy memory
addi $r324 $$locbase i104               ; get offset to local __ptr { u64, u64 }
mcpi $r324 $r323 i16                    ; copy memory
addi $r325 $r324 i8                     ; get offset to aggregate element
lw $r326 $$locbase i14                  ; load word
movi $r327 i8                           ; initialize constant into register
 add $r328 $r326 $r327
 addi $r328 $r326 i8
add $r329 $r319 $r328
gt $r330 $r329 $r317
move $r331 $r315                        ; move parameter from branch to block argument
move $r332 $r317                        ; move parameter from branch to block argument
jnzi $r330 .103
ji  .104
.103
movi $r333 i2                           ; initialize constant into register
 mul $r334 $r317 $r333
 muli $r334 $r317 i2
add $r335 $r334 $r328
aloc $r335
mcp $hp $r315 $r319
move $r336 $hp                          ; return value from ASM block with return register hp
 move $r331 $r336                        ; move parameter from branch to block argument
 move $r331 $hp                          ; move parameter from branch to block argument
move $r332 $r335                        ; move parameter from branch to block argument
ji  .104
.104
move $r340 $r331                        ; move parameter from branch to block argument
move $r342 $r332                        ; move parameter from branch to block argument
addi $r343 $$locbase i120               ; get offset to local __ptr slice
mcpi $r343 $r321 i16                    ; copy memory
add $r344 $r340 $r319
lw $r346 $$locbase i16
sw $r344 $r346 i0
addi $r344 $r344 i8
lw $r345 $$locbase i15
mcp $r344 $r345 $r346
addi $r347 $r319 i8
add $r347 $r347 $r346
move $r348 $r347                        ; return value from ASM block with return register new_len
addi $r349 $$locbase i136               ; get offset to local __ptr { ptr, u64, u64 }
sw $$locbase $r340 i17                  ; store word
addi $r350 $r349 i8                     ; get offset to aggregate element
sw $$locbase $r342 i18                  ; store word
addi $r351 $r349 i16                    ; get offset to aggregate element
sw $$locbase $r348 i19                  ; store word
move $r352 $r349                        ; return value from ASM block with return register buffer
addi $r353 $$locbase i56                ; get offset to local __ptr { ptr, u64, u64 }
 mcpi $r353 $r352 i24                    ; copy memory
 mcpi $r353 $r349 i24                    ; copy memory
mcpi $r311 $r353 i24                    ; copy memory
mcpi $$arg2 $r311 i24                   ; copy memory
ji  .21
.21
cfsi i224                               ; [fn end: abi_encode_26] free: locals 224 byte(s), call args 0 slot(s)
popa .20                                ; [fn end: abi_encode_26] restore all used registers
jal $zero $$reta i0                     ; [fn end: abi_encode_26] return from call
DIFF------------------------------
.program:
.22                                     ; --- start of function: new_27 ---
pusha .22                               ; [fn init: new_27]: push all used registers to stack
move $$locbase $sp                      ; [fn init: new_27]: set locals base register
cfei i72                                ; [fn init: new_27]: allocate: locals 72 byte(s), call args 0 slot(s)
.105
addi $r355 $$locbase i48                ; get offset to local __ptr { { ptr, u64, u64 } }
movi $r356 i1024                        ; initialize constant into register
aloc $r356
move $r357 $hp                          ; return value from ASM block with return register hp
addi $r358 $$locbase i24                ; get offset to local __ptr { ptr, u64, u64 }
 sw $$locbase $r357 i3                   ; store word
 sw $$locbase $hp i3                     ; store word
addi $r359 $r358 i8                     ; get offset to aggregate element
movi $r360 i1024                        ; initialize constant into register
sw $$locbase $r360 i4                   ; store word
addi $r361 $r358 i16                    ; get offset to aggregate element
sw $$locbase $zero i5                   ; store word
move $r362 $r358                        ; return value from ASM block with return register buffer
 mcpi $$locbase $r362 i24                ; copy memory
 mcpi $$locbase $r358 i24                ; copy memory
mcpi $r355 $$locbase i24                ; copy memory
mcpi $$arg0 $r355 i24                   ; copy memory
ji  .23
.23
cfsi i72                                ; [fn end: new_27] free: locals 72 byte(s), call args 0 slot(s)
popa .22                                ; [fn end: new_27] restore all used registers
jal $zero $$reta i0                     ; [fn end: new_27] return from call
DIFF------------------------------
.program:
.24                                     ; --- start of function: as_raw_slice_28 ---
pusha .24                               ; [fn init: as_raw_slice_28]: push all used registers to stack
move $$locbase $sp                      ; [fn init: as_raw_slice_28]: set locals base register
cfei i104                               ; [fn init: as_raw_slice_28]: allocate: locals 104 byte(s), call args 0 slot(s)
.106
addi $r364 $$locbase i80                ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r364 $$arg0 i24                   ; copy memory
addi $r365 $$locbase i80                ; get offset to local __ptr { { ptr, u64, u64 } }
move $r366 $r365                        ; return value from ASM block with return register buffer
 mcpi $$locbase $r366 i24                ; copy memory
 mcpi $$locbase $r365 i24                ; copy memory
addi $r367 $$locbase i40                ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r367 $$locbase i24                ; copy memory
addi $r368 $r367 i16                    ; get offset to aggregate element
addi $r369 $$locbase i64                ; get offset to local __ptr { ptr, u64 }
mcpi $r369 $r367 i8                     ; copy memory
addi $r370 $r369 i8                     ; get offset to aggregate element
mcpi $r370 $r368 i8                     ; copy memory
move $r371 $r369                        ; return value from ASM block with return register s
addi $r372 $$locbase i24                ; get offset to local __ptr slice
 mcpi $r372 $r371 i16                    ; copy memory
 mcpi $r372 $r369 i16                    ; copy memory
mcpi $$arg1 $r372 i16                   ; copy memory
ji  .25
.25
cfsi i104                               ; [fn end: as_raw_slice_28] free: locals 104 byte(s), call args 0 slot(s)
popa .24                                ; [fn end: as_raw_slice_28] restore all used registers
jal $zero $$reta i0                     ; [fn end: as_raw_slice_28] return from call
DIFF------------------------------
.program:
.26                                     ; --- start of function: log_29 ---
pusha .26                               ; [fn init: log_29]: push all used registers to stack
move $$locbase $sp                      ; [fn init: log_29]: set locals base register
cfei i216                               ; [fn init: log_29]: allocate: locals 216 byte(s), call args 0 slot(s)
move $r373 $$arg0                       ; [fn init: log_29]: copy argument 0 (value)
move $r374 $$reta                       ; [fn init: log_29]: save return address
.107
addi $r375 $$locbase i208               ; get offset to local __ptr u64
 sw $$locbase $r373 i26                  ; store word
 sw $$locbase $$arg0 i26                 ; store word
addi $r376 $$locbase i208               ; get offset to local __ptr u64
addi $r377 $$locbase i192               ; get offset to local __ptr __ptr u64
sw $$locbase $r376 i24                  ; store word
 jnzi $one .108
 ji  .108
ji  .109
.109
addi $r378 $$locbase i192               ; get offset to local __ptr __ptr u64
lw $r379 $$locbase i24                  ; load word
lw $r380 $r379 i0                       ; load word
addi $r381 $$locbase i32                ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r381                       ; [call: new_27]: pass argument 0
fncall .22                              ; [call: new_27]: call function
 move $r382 $zero                        ; [call: new_27]: copy returned unit value
 movi $r382 i0                           ; [call: new_27]: copy returned unit value
addi $r383 $$locbase i96                ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r383 $r381 i24                    ; copy memory
addi $r384 $$locbase i72                ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r380                       ; [call: abi_encode_33]: pass argument 0
move $$arg1 $r383                       ; [call: abi_encode_33]: pass argument 1
move $$arg2 $r384                       ; [call: abi_encode_33]: pass argument 2
fncall .28                              ; [call: abi_encode_33]: call function
 move $r385 $zero                        ; [call: abi_encode_33]: copy returned unit value
 movi $r385 i0                           ; [call: abi_encode_33]: copy returned unit value
addi $r386 $$locbase i168               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r386 $r384 i24                    ; copy memory
addi $r387 $$locbase i168               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r388 $$locbase i56                ; get offset to local __ptr slice
move $$arg0 $r387                       ; [call: as_raw_slice_28]: pass argument 0
move $$arg1 $r388                       ; [call: as_raw_slice_28]: pass argument 1
fncall .24                              ; [call: as_raw_slice_28]: call function
 move $r389 $zero                        ; [call: as_raw_slice_28]: copy returned unit value
 movi $r389 i0                           ; [call: as_raw_slice_28]: copy returned unit value
addi $r390 $$locbase i120               ; get offset to local __ptr slice
mcpi $r390 $r388 i16                    ; copy memory
move $r391 $r390                        ; move parameter from branch to block argument
ji  .110
.108
addi $r392 $$locbase i200               ; get offset to local __ptr u64
movi $r393 i8                           ; initialize constant into register
sw $$locbase $r393 i25                  ; store word
addi $r394 $$locbase i152               ; get offset to local __ptr { __ptr u64, u64 }
addi $r395 $$locbase i192               ; get offset to local __ptr __ptr u64
addi $r396 $$locbase i200               ; get offset to local __ptr u64
mcpi $r394 $r395 i8                     ; copy memory
addi $r397 $r394 i8                     ; get offset to aggregate element
mcpi $r397 $r396 i8                     ; copy memory
mcpi $$locbase $r394 i16                ; copy memory
addi $r398 $$locbase i120               ; get offset to local __ptr slice
mcpi $r398 $$locbase i16                ; copy memory
move $r391 $r398                        ; move parameter from branch to block argument
ji  .110
.110
move $r401 $r391                        ; move parameter from branch to block argument
addi $r402 $$locbase i136               ; get offset to local __ptr slice
 mcpi $r402 $r401 i16                    ; copy memory
 mcpi $r402 $r391 i16                    ; copy memory
addi $r403 $$locbase i16                ; get offset to local __ptr slice
mcpi $r403 $r402 i16                    ; copy memory
load $r404 data_NonConfigurable_7       ; load constant from data section
lw $r405 $$locbase i2                   ; load slice pointer for logging data
lw $r406 $$locbase i3                   ; load slice size for logging data
logd $zero $r404 $r405 $r406            ; log slice
ji  .27
.27
cfsi i216                               ; [fn end: log_29] free: locals 216 byte(s), call args 0 slot(s)
move $$reta $r374                       ; [fn end: log_29] restore return address
popa .26                                ; [fn end: log_29] restore all used registers
jal $zero $$reta i0                     ; [fn end: log_29] return from call
DIFF------------------------------
.program:
.28                                     ; --- start of function: abi_encode_33 ---
pusha .28                               ; [fn init: abi_encode_33]: push all used registers to stack
move $$locbase $sp                      ; [fn init: abi_encode_33]: set locals base register
cfei i152                               ; [fn init: abi_encode_33]: allocate: locals 152 byte(s), call args 0 slot(s)
.111
addi $r408 $$locbase i144               ; get offset to local __ptr u64
sw $$locbase $$arg0 i18                 ; store word
addi $r409 $$locbase i120               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r409 $$arg1 i24                   ; copy memory
addi $r410 $$locbase i96                ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r411 $$locbase i120               ; get offset to local __ptr { { ptr, u64, u64 } }
move $r412 $r411                        ; return value from ASM block with return register buffer
 mcpi $$locbase $r412 i24                ; copy memory
 mcpi $$locbase $r411 i24                ; copy memory
addi $r413 $$locbase i48                ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r413 $$locbase i24                ; copy memory
lw $r414 $$locbase i6                   ; load word
addi $r415 $r413 i8                     ; get offset to aggregate element
lw $r416 $$locbase i7                   ; load word
addi $r417 $r413 i16                    ; get offset to aggregate element
lw $r418 $$locbase i8                   ; load word
addi $r419 $$locbase i144               ; get offset to local __ptr u64
lw $r420 $$locbase i18                  ; load word
movi $r421 i8                           ; initialize constant into register
 add $r422 $r418 $r421
 addi $r422 $r418 i8
gt $r423 $r422 $r416
move $r424 $r414                        ; move parameter from branch to block argument
move $r425 $r416                        ; move parameter from branch to block argument
jnzi $r423 .112
ji  .113
.112
movi $r426 i2                           ; initialize constant into register
 mul $r427 $r416 $r426
 muli $r427 $r416 i2
movi $r428 i8                           ; initialize constant into register
 add $r429 $r427 $r428
 addi $r429 $r427 i8
aloc $r429
mcp $hp $r414 $r418
move $r430 $hp                          ; return value from ASM block with return register hp
 move $r424 $r430                        ; move parameter from branch to block argument
 move $r424 $hp                          ; move parameter from branch to block argument
move $r425 $r429                        ; move parameter from branch to block argument
ji  .113
.113
move $r434 $r424                        ; move parameter from branch to block argument
move $r436 $r425                        ; move parameter from branch to block argument
 add $r437 $r434 $r418
 add $r437 $r424 $r418
sw $r437 $r420 i0                       ; store word
movi $r438 i8                           ; initialize constant into register
 add $r439 $r418 $r438
 addi $r439 $r418 i8
addi $r440 $$locbase i72                ; get offset to local __ptr { ptr, u64, u64 }
sw $$locbase $r434 i9                   ; store word
addi $r441 $r440 i8                     ; get offset to aggregate element
sw $$locbase $r436 i10                  ; store word
addi $r442 $r440 i16                    ; get offset to aggregate element
sw $$locbase $r439 i11                  ; store word
move $r443 $r440                        ; return value from ASM block with return register buffer
addi $r444 $$locbase i24                ; get offset to local __ptr { ptr, u64, u64 }
 mcpi $r444 $r443 i24                    ; copy memory
 mcpi $r444 $r440 i24                    ; copy memory
mcpi $r410 $r444 i24                    ; copy memory
mcpi $$arg2 $r410 i24                   ; copy memory
ji  .29
.29
cfsi i152                               ; [fn end: abi_encode_33] free: locals 152 byte(s), call args 0 slot(s)
popa .28                                ; [fn end: abi_encode_33] restore all used registers
jal $zero $$reta i0                     ; [fn end: abi_encode_33] return from call
DIFF------------------------------
.program:
.38                                     ; --- start of function: finish_36 ---
pusha .38                               ; [fn init: finish_36]: push all used registers to stack
move $$locbase $sp                      ; [fn init: finish_36]: set locals base register
cfei i40                                ; [fn init: finish_36]: allocate: locals 40 byte(s), call args 0 slot(s)
move $r696 $$arg0                       ; [fn init: finish_36]: copy argument 0 (self)
move $r697 $$reta                       ; [fn init: finish_36]: save return address
.134
addi $r698 $$locbase i32                ; get offset to local __ptr __ptr { {  }, bool }
 sw $$locbase $r696 i4                   ; store word
 sw $$locbase $$arg0 i4                  ; store word
addi $r699 $$locbase i32                ; get offset to local __ptr __ptr { {  }, bool }
lw $r700 $$locbase i4                   ; load word
addr $r701 data_NonConfigurable_21      ; get __const_global13's address in data section
sw $$locbase $r701 i0                   ; store word
addi $r702 $$locbase i8                 ; get offset to aggregate element
sw $$locbase $one i1                    ; store word
addi $r703 $$locbase i16                ; get offset to local __ptr slice
mcpi $r703 $$locbase i16                ; copy memory
addi $r704 $$locbase i32                ; get offset to local __ptr {  }
addi $r705 $$locbase i16                ; get offset to local __ptr slice
move $$arg0 $r704                       ; [call: print_str_1]: pass argument 0
move $$arg1 $r705                       ; [call: print_str_1]: pass argument 1
fncall .6                               ; [call: print_str_1]: call function
 move $r706 $zero                        ; [call: print_str_1]: copy returned unit value
 movi $r706 i0                           ; [call: print_str_1]: copy returned unit value
ji  .39
.39
cfsi i40                                ; [fn end: finish_36] free: locals 40 byte(s), call args 0 slot(s)
move $$reta $r697                       ; [fn end: finish_36] restore return address
popa .38                                ; [fn end: finish_36] restore all used registers
jal $zero $$reta i0                     ; [fn end: finish_36] return from call
DIFF------------------------------
.program:
.40                                     ; --- start of function: debug_tuple_39 ---
pusha .40                               ; [fn init: debug_tuple_39]: push all used registers to stack
move $$locbase $sp                      ; [fn init: debug_tuple_39]: set locals base register
cfei i72                                ; [fn init: debug_tuple_39]: allocate: locals 72 byte(s), call args 0 slot(s)
move $r707 $$arg0                       ; [fn init: debug_tuple_39]: copy argument 0 (self)
move $r708 $$arg1                       ; [fn init: debug_tuple_39]: copy argument 1 (name)
move $r709 $$arg2                       ; [fn init: debug_tuple_39]: copy argument 2 (__ret_value)
move $r710 $$reta                       ; [fn init: debug_tuple_39]: save return address
.135
addi $r711 $$locbase i64                ; get offset to local __ptr {  }
addi $r712 $$locbase i40                ; get offset to local __ptr slice
 mcpi $r712 $r708 i16                    ; copy memory
 mcpi $r712 $$arg1 i16                   ; copy memory
move $$arg0 $r708                       ; [call: len_4]: pass argument 0
fncall .10                              ; [call: len_4]: call function
move $r713 $$retv                       ; [call: len_4]: copy returned value
addi $r714 $$locbase i64                ; get offset to local __ptr u64
 sw $$locbase $r713 i8                   ; store word
 sw $$locbase $$retv i8                  ; store word
addi $r715 $$locbase i56                ; get offset to local __ptr u64
sw $$locbase $zero i7                   ; store word
addi $r716 $$locbase i64                ; get offset to local __ptr u64
lw $r717 $$locbase i8                   ; load word
addi $r718 $$locbase i56                ; get offset to local __ptr u64
lw $r719 $$locbase i7                   ; load word
gt $r720 $r717 $r719
jnzi $r720 .136
ji  .137
.136
addi $r721 $$locbase i64                ; get offset to local __ptr {  }
addi $r722 $$locbase i40                ; get offset to local __ptr slice
move $$arg0 $r721                       ; [call: print_str_1]: pass argument 0
move $$arg1 $r722                       ; [call: print_str_1]: pass argument 1
fncall .6                               ; [call: print_str_1]: call function
 move $r723 $zero                        ; [call: print_str_1]: copy returned unit value
 movi $r723 i0                           ; [call: print_str_1]: copy returned unit value
ji  .137
.137
addi $r724 $$locbase i64                ; get offset to local __ptr {  }
addr $r725 data_NonConfigurable_22      ; get __const_global17's address in data section
sw $$locbase $r725 i0                   ; store word
addi $r726 $$locbase i8                 ; get offset to aggregate element
sw $$locbase $one i1                    ; store word
addi $r727 $$locbase i16                ; get offset to local __ptr slice
mcpi $r727 $$locbase i16                ; copy memory
addi $r728 $$locbase i16                ; get offset to local __ptr slice
move $$arg0 $r724                       ; [call: print_str_1]: pass argument 0
move $$arg1 $r728                       ; [call: print_str_1]: pass argument 1
fncall .6                               ; [call: print_str_1]: call function
 move $r729 $zero                        ; [call: print_str_1]: copy returned unit value
 movi $r729 i0                           ; [call: print_str_1]: copy returned unit value
addi $r730 $$locbase i32                ; get offset to local __ptr { {  }, bool }
addi $r731 $$locbase i64                ; get offset to local __ptr {  }
sb $r730 $zero i0                       ; store byte
mcpi $r709 $r730 i8                     ; copy memory
ji  .41
.41
cfsi i72                                ; [fn end: debug_tuple_39] free: locals 72 byte(s), call args 0 slot(s)
move $$reta $r710                       ; [fn end: debug_tuple_39] restore return address
popa .40                                ; [fn end: debug_tuple_39] restore all used registers
jal $zero $$reta i0                     ; [fn end: debug_tuple_39] return from call
DIFF------------------------------
.program:
.42                                     ; --- start of function: field_41 ---
pusha .42                               ; [fn init: field_41]: push all used registers to stack
move $$locbase $sp                      ; [fn init: field_41]: set locals base register
cfei i56                                ; [fn init: field_41]: allocate: locals 56 byte(s), call args 0 slot(s)
move $r732 $$arg0                       ; [fn init: field_41]: copy argument 0 (self)
move $r733 $$arg1                       ; [fn init: field_41]: copy argument 1 (value)
move $r734 $$arg2                       ; [fn init: field_41]: copy argument 2 (__ret_value)
move $r735 $$reta                       ; [fn init: field_41]: save return address
.138
addi $r736 $$locbase i32                ; get offset to local __ptr __ptr { {  }, bool }
 sw $$locbase $r732 i4                   ; store word
 sw $$locbase $$arg0 i4                  ; store word
addi $r737 $$locbase i40                ; get offset to local __ptr slice
mcpi $r737 $r733 i16                    ; copy memory
addi $r738 $$locbase i32                ; get offset to local __ptr __ptr { {  }, bool }
lw $r739 $$locbase i4                   ; load word
lb $r740 $r739 i0                       ; load byte
jnzi $r740 .139
ji  .140
.139
addi $r741 $$locbase i32                ; get offset to local __ptr __ptr { {  }, bool }
lw $r742 $$locbase i4                   ; load word
addr $r743 data_NonConfigurable_16      ; get __const_global19's address in data section
sw $$locbase $r743 i0                   ; store word
addi $r744 $$locbase i8                 ; get offset to aggregate element
movi $r745 i2                           ; initialize constant into register
sw $$locbase $r745 i1                   ; store word
addi $r746 $$locbase i16                ; get offset to local __ptr slice
mcpi $r746 $$locbase i16                ; copy memory
addi $r747 $$locbase i32                ; get offset to local __ptr {  }
addi $r748 $$locbase i16                ; get offset to local __ptr slice
move $$arg0 $r747                       ; [call: print_str_1]: pass argument 0
move $$arg1 $r748                       ; [call: print_str_1]: pass argument 1
fncall .6                               ; [call: print_str_1]: call function
 move $r749 $zero                        ; [call: print_str_1]: copy returned unit value
 movi $r749 i0                           ; [call: print_str_1]: copy returned unit value
ji  .140
.140
addi $r750 $$locbase i40                ; get offset to local __ptr slice
addi $r751 $$locbase i32                ; get offset to local __ptr __ptr { {  }, bool }
lw $r752 $$locbase i4                   ; load word
move $$arg0 $r750                       ; [call: fmt_5]: pass argument 0
move $$arg1 $r752                       ; [call: fmt_5]: pass argument 1
fncall .12                              ; [call: fmt_5]: call function
 move $r753 $zero                        ; [call: fmt_5]: copy returned unit value
 movi $r753 i0                           ; [call: fmt_5]: copy returned unit value
addi $r754 $$locbase i32                ; get offset to local __ptr __ptr { {  }, bool }
lw $r755 $$locbase i4                   ; load word
sb $r755 $one i0                        ; store byte
addi $r756 $$locbase i32                ; get offset to local __ptr __ptr { {  }, bool }
lw $r757 $$locbase i4                   ; load word
mcpi $r734 $r757 i8                     ; copy memory
ji  .43
.43
cfsi i56                                ; [fn end: field_41] free: locals 56 byte(s), call args 0 slot(s)
move $$reta $r735                       ; [fn end: field_41] restore return address
popa .42                                ; [fn end: field_41] restore all used registers
jal $zero $$reta i0                     ; [fn end: field_41] return from call
DIFF------------------------------
.program:
.52                                     ; --- start of function: encode_allow_alias_50 ---
pusha .52                               ; [fn init: encode_allow_alias_50]: push all used registers to stack
move $$locbase $sp                      ; [fn init: encode_allow_alias_50]: set locals base register
cfei i1128                              ; [fn init: encode_allow_alias_50]: allocate: locals 1128 byte(s), call args 0 slot(s)
move $r935 $$arg0                       ; [fn init: encode_allow_alias_50]: copy argument 0 (item)
move $r936 $$arg1                       ; [fn init: encode_allow_alias_50]: copy argument 1 (__ret_value)
move $r937 $$reta                       ; [fn init: encode_allow_alias_50]: save return address
.153
addi $r938 $$locbase i960               ; get offset to local __ptr __ptr { u64, ( () | bool | slice | slice ) }
 sw $$locbase $r935 i120                 ; store word
 sw $$locbase $$arg0 i120                ; store word
addi $r939 $$locbase i1008              ; get offset to local __ptr u64
load $r940 data_NonConfigurable_33      ; load constant from data section
sw $$locbase $r940 i126                 ; store word
addi $r941 $$locbase i968               ; get offset to local __ptr u64
sw $$locbase $zero i121                 ; store word
addi $r942 $$locbase i1008              ; get offset to local __ptr u64
lw $r943 $$locbase i126                 ; load word
addi $r944 $$locbase i968               ; get offset to local __ptr u64
lw $r945 $$locbase i121                 ; load word
eq $r946 $r943 $r945
move $r947 $r946                        ; move parameter from branch to block argument
jnzi $r946 .154
ji  .155
.154
 move $r947 $one                         ; move parameter from branch to block argument
 movi $r947 i1                           ; move parameter from branch to block argument
ji  .155
.155
move $r950 $r947                        ; move parameter from branch to block argument
 move $r951 $r950                        ; move parameter from branch to block argument
 jnzi $r950 .156
 move $r951 $r947                        ; move parameter from branch to block argument
 jnzi $r947 .156
ji  .157
.156
 move $r951 $one                         ; move parameter from branch to block argument
 movi $r951 i1                           ; move parameter from branch to block argument
ji  .157
.157
move $r954 $r951                        ; move parameter from branch to block argument
 move $r955 $r954                        ; move parameter from branch to block argument
 jnzi $r954 .158
 move $r955 $r951                        ; move parameter from branch to block argument
 jnzi $r951 .158
ji  .159
.158
 move $r955 $zero                        ; move parameter from branch to block argument
 movi $r955 i0                           ; move parameter from branch to block argument
ji  .159
.159
move $r958 $r955                        ; move parameter from branch to block argument
 move $r959 $r958                        ; move parameter from branch to block argument
 jnzi $r958 .160
 move $r959 $r955                        ; move parameter from branch to block argument
 jnzi $r955 .160
ji  .161
.160
 move $r959 $zero                        ; move parameter from branch to block argument
 movi $r959 i0                           ; move parameter from branch to block argument
ji  .161
.161
move $r962 $r959                        ; move parameter from branch to block argument
 jnzi $r962 .162
 jnzi $r959 .162
ji  .163
.163
addi $r963 $$locbase i960               ; get offset to local __ptr __ptr { u64, ( () | bool | slice | slice ) }
lw $r964 $$locbase i120                 ; load word
addi $r965 $$locbase i184               ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r965                       ; [call: new_27]: pass argument 0
fncall .22                              ; [call: new_27]: call function
 move $r966 $zero                        ; [call: new_27]: copy returned unit value
 movi $r966 i0                           ; [call: new_27]: copy returned unit value
addi $r967 $$locbase i1016              ; get offset to local __ptr { u64, ( () | bool | slice | slice ) }
mcpi $r967 $r964 i24                    ; copy memory
addi $r968 $$locbase i744               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r968 $r965 i24                    ; copy memory
addi $r969 $$locbase i1016              ; get offset to local __ptr { u64, ( () | bool | slice | slice ) }
addi $r970 $$locbase i112               ; get offset to local __ptr { u64, ( () | bool | slice | slice ) }
mcpi $r970 $r969 i24                    ; copy memory
addi $r971 $$locbase i112               ; get offset to local __ptr { u64, ( () | bool | slice | slice ) }
addi $r972 $$locbase i1040              ; get offset to local __ptr u64
mcpi $r972 $r971 i8                     ; copy memory
addi $r973 $$locbase i976               ; get offset to local __ptr u64
sw $$locbase $zero i122                 ; store word
addi $r974 $$locbase i1040              ; get offset to local __ptr u64
lw $r975 $$locbase i130                 ; load word
addi $r976 $$locbase i976               ; get offset to local __ptr u64
lw $r977 $$locbase i122                 ; load word
eq $r978 $r975 $r977
jnzi $r978 .164
ji  .165
.165
addi $r979 $$locbase i112               ; get offset to local __ptr { u64, ( () | bool | slice | slice ) }
addi $r980 $$locbase i1048              ; get offset to local __ptr u64
mcpi $r980 $r979 i8                     ; copy memory
addi $r981 $$locbase i984               ; get offset to local __ptr u64
sw $$locbase $one i123                  ; store word
addi $r982 $$locbase i1048              ; get offset to local __ptr u64
lw $r983 $$locbase i131                 ; load word
addi $r984 $$locbase i984               ; get offset to local __ptr u64
lw $r985 $$locbase i123                 ; load word
eq $r986 $r983 $r985
jnzi $r986 .166
ji  .167
.167
addi $r987 $$locbase i112               ; get offset to local __ptr { u64, ( () | bool | slice | slice ) }
addi $r988 $$locbase i1064              ; get offset to local __ptr u64
mcpi $r988 $r987 i8                     ; copy memory
addi $r989 $$locbase i992               ; get offset to local __ptr u64
movi $r990 i2                           ; initialize constant into register
sw $$locbase $r990 i124                 ; store word
addi $r991 $$locbase i1064              ; get offset to local __ptr u64
lw $r992 $$locbase i133                 ; load word
addi $r993 $$locbase i992               ; get offset to local __ptr u64
lw $r994 $$locbase i124                 ; load word
eq $r995 $r992 $r994
jnzi $r995 .168
ji  .169
.169
addi $r996 $$locbase i112               ; get offset to local __ptr { u64, ( () | bool | slice | slice ) }
addi $r997 $$locbase i1072              ; get offset to local __ptr u64
mcpi $r997 $r996 i8                     ; copy memory
addi $r998 $$locbase i1000              ; get offset to local __ptr u64
movi $r999 i3                           ; initialize constant into register
sw $$locbase $r999 i125                 ; store word
addi $r1000 $$locbase i1072             ; get offset to local __ptr u64
lw $r1001 $$locbase i134                ; load word
addi $r1002 $$locbase i1000             ; get offset to local __ptr u64
lw $r1003 $$locbase i125                ; load word
eq $r1004 $r1001 $r1003
jnzi $r1004 .170
ji  .171
.171
load $r1005 data_NonConfigurable_14     ; load constant from data section
rvrt $r1005
.170
addi $r1006 $$locbase i112              ; get offset to local __ptr { u64, ( () | bool | slice | slice ) }
addi $r1007 $r1006 i8                   ; get offset to aggregate element
addi $r1008 $$locbase i1112             ; get offset to local __ptr slice
mcpi $r1008 $r1007 i16                  ; copy memory
addi $r1009 $$locbase i744              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r1010 $$locbase i520              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r1010 $r1009 i24                  ; copy memory
addi $r1011 $$locbase i296              ; get offset to local __ptr { { ptr, u64, u64 } }
movi $r1012 i3                          ; initialize constant into register
 move $$arg0 $r1012                      ; [call: abi_encode_33]: pass argument 0
 movi $$arg0 i3                          ; [call: abi_encode_33]: pass argument 0
move $$arg1 $r1010                      ; [call: abi_encode_33]: pass argument 1
move $$arg2 $r1011                      ; [call: abi_encode_33]: pass argument 2
fncall .28                              ; [call: abi_encode_33]: call function
 move $r1013 $zero                       ; [call: abi_encode_33]: copy returned unit value
 movi $r1013 i0                          ; [call: abi_encode_33]: copy returned unit value
addi $r1014 $$locbase i888              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r1014 $r1011 i24                  ; copy memory
addi $r1015 $$locbase i1112             ; get offset to local __ptr slice
addi $r1016 $$locbase i888              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r1017 $$locbase i384              ; get offset to local __ptr slice
mcpi $r1017 $r1015 i16                  ; copy memory
addi $r1018 $$locbase i400              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r1018 $r1016 i24                  ; copy memory
addi $r1019 $$locbase i160              ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r1017                      ; [call: abi_encode_26]: pass argument 0
move $$arg1 $r1018                      ; [call: abi_encode_26]: pass argument 1
move $$arg2 $r1019                      ; [call: abi_encode_26]: pass argument 2
fncall .20                              ; [call: abi_encode_26]: call function
 move $r1020 $zero                       ; [call: abi_encode_26]: copy returned unit value
 movi $r1020 i0                          ; [call: abi_encode_26]: copy returned unit value
addi $r1021 $$locbase i912              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r1021 $r1019 i24                  ; copy memory
addi $r1022 $$locbase i912              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r1023 $$locbase i568              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r1023 $r1022 i24                  ; copy memory
addi $r1024 $$locbase i592              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r1024 $r1023 i24                  ; copy memory
move $r1025 $r1024                      ; move parameter from branch to block argument
ji  .172
.168
addi $r1026 $$locbase i112              ; get offset to local __ptr { u64, ( () | bool | slice | slice ) }
addi $r1027 $r1026 i8                   ; get offset to aggregate element
addi $r1028 $$locbase i1096             ; get offset to local __ptr slice
mcpi $r1028 $r1027 i16                  ; copy memory
addi $r1029 $$locbase i744              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r1030 $$locbase i496              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r1030 $r1029 i24                  ; copy memory
addi $r1031 $$locbase i272              ; get offset to local __ptr { { ptr, u64, u64 } }
movi $r1032 i2                          ; initialize constant into register
 move $$arg0 $r1032                      ; [call: abi_encode_33]: pass argument 0
 movi $$arg0 i2                          ; [call: abi_encode_33]: pass argument 0
move $$arg1 $r1030                      ; [call: abi_encode_33]: pass argument 1
move $$arg2 $r1031                      ; [call: abi_encode_33]: pass argument 2
fncall .28                              ; [call: abi_encode_33]: call function
 move $r1033 $zero                       ; [call: abi_encode_33]: copy returned unit value
 movi $r1033 i0                          ; [call: abi_encode_33]: copy returned unit value
addi $r1034 $$locbase i840              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r1034 $r1031 i24                  ; copy memory
addi $r1035 $$locbase i1096             ; get offset to local __ptr slice
addi $r1036 $$locbase i840              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r1037 $$locbase i344              ; get offset to local __ptr slice
mcpi $r1037 $r1035 i16                  ; copy memory
addi $r1038 $$locbase i360              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r1038 $r1036 i24                  ; copy memory
addi $r1039 $$locbase i136              ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r1037                      ; [call: abi_encode_26]: pass argument 0
move $$arg1 $r1038                      ; [call: abi_encode_26]: pass argument 1
move $$arg2 $r1039                      ; [call: abi_encode_26]: pass argument 2
fncall .20                              ; [call: abi_encode_26]: call function
 move $r1040 $zero                       ; [call: abi_encode_26]: copy returned unit value
 movi $r1040 i0                          ; [call: abi_encode_26]: copy returned unit value
addi $r1041 $$locbase i864              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r1041 $r1039 i24                  ; copy memory
addi $r1042 $$locbase i864              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r1043 $$locbase i592              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r1043 $r1042 i24                  ; copy memory
move $r1025 $r1043                      ; move parameter from branch to block argument
ji  .172
.172
move $r1046 $r1025                      ; move parameter from branch to block argument
addi $r1047 $$locbase i616              ; get offset to local __ptr { { ptr, u64, u64 } }
 mcpi $r1047 $r1046 i24                  ; copy memory
 mcpi $r1047 $r1025 i24                  ; copy memory
move $r1048 $r1047                      ; move parameter from branch to block argument
ji  .173
.166
addi $r1049 $$locbase i112              ; get offset to local __ptr { u64, ( () | bool | slice | slice ) }
addi $r1050 $r1049 i23                  ; get offset to aggregate element
addi $r1051 $$locbase i1088             ; get offset to local __ptr bool
mcpi $r1051 $r1050 i1                   ; copy memory
addi $r1052 $$locbase i744              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r1053 $$locbase i472              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r1053 $r1052 i24                  ; copy memory
addi $r1054 $$locbase i248              ; get offset to local __ptr { { ptr, u64, u64 } }
 move $$arg0 $one                        ; [call: abi_encode_33]: pass argument 0
 movi $$arg0 i1                          ; [call: abi_encode_33]: pass argument 0
move $$arg1 $r1053                      ; [call: abi_encode_33]: pass argument 1
move $$arg2 $r1054                      ; [call: abi_encode_33]: pass argument 2
fncall .28                              ; [call: abi_encode_33]: call function
 move $r1055 $zero                       ; [call: abi_encode_33]: copy returned unit value
 movi $r1055 i0                          ; [call: abi_encode_33]: copy returned unit value
addi $r1056 $$locbase i792              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r1056 $r1054 i24                  ; copy memory
addi $r1057 $$locbase i1088             ; get offset to local __ptr bool
addi $r1058 $$locbase i792              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r1059 $$locbase i1056             ; get offset to local __ptr bool
mcpi $r1059 $r1057 i1                   ; copy memory
addi $r1060 $$locbase i768              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r1060 $r1058 i24                  ; copy memory
addi $r1061 $$locbase i320              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r1062 $$locbase i768              ; get offset to local __ptr { { ptr, u64, u64 } }
move $r1063 $r1062                      ; return value from ASM block with return register buffer
 mcpi $$locbase $r1063 i24               ; copy memory
 mcpi $$locbase $r1062 i24               ; copy memory
addi $r1064 $$locbase i64               ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r1064 $$locbase i24               ; copy memory
lw $r1065 $$locbase i8                  ; load word
addi $r1066 $r1064 i8                   ; get offset to aggregate element
lw $r1067 $$locbase i9                  ; load word
addi $r1068 $r1064 i16                  ; get offset to aggregate element
lw $r1069 $$locbase i10                 ; load word
addi $r1070 $$locbase i1056             ; get offset to local __ptr bool
lb $r1071 $r1070 i0                     ; load byte
 add $r1072 $r1069 $one
 addi $r1072 $r1069 i1
gt $r1073 $r1072 $r1067
move $r1074 $r1065                      ; move parameter from branch to block argument
move $r1075 $r1067                      ; move parameter from branch to block argument
jnzi $r1073 .174
ji  .175
.174
movi $r1076 i2                          ; initialize constant into register
 mul $r1077 $r1067 $r1076
 add $r1078 $r1077 $one
 muli $r1077 $r1067 i2
 addi $r1078 $r1077 i1
aloc $r1078
mcp $hp $r1065 $r1069
move $r1079 $hp                         ; return value from ASM block with return register hp
 move $r1074 $r1079                      ; move parameter from branch to block argument
 move $r1074 $hp                         ; move parameter from branch to block argument
move $r1075 $r1078                      ; move parameter from branch to block argument
ji  .175
.175
move $r1083 $r1074                      ; move parameter from branch to block argument
move $r1085 $r1075                      ; move parameter from branch to block argument
 add $r1086 $r1083 $r1069
 add $r1086 $r1074 $r1069
sb $r1086 $r1071 i0                     ; store byte
 add $r1087 $r1069 $one
 addi $r1087 $r1069 i1
addi $r1088 $$locbase i88               ; get offset to local __ptr { ptr, u64, u64 }
sw $$locbase $r1083 i11                 ; store word
addi $r1089 $r1088 i8                   ; get offset to aggregate element
sw $$locbase $r1085 i12                 ; store word
addi $r1090 $r1088 i16                  ; get offset to aggregate element
sw $$locbase $r1087 i13                 ; store word
move $r1091 $r1088                      ; return value from ASM block with return register buffer
addi $r1092 $$locbase i24               ; get offset to local __ptr { ptr, u64, u64 }
 mcpi $r1092 $r1091 i24                  ; copy memory
 mcpi $r1092 $r1088 i24                  ; copy memory
mcpi $r1061 $r1092 i24                  ; copy memory
addi $r1093 $$locbase i544              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r1093 $r1061 i24                  ; copy memory
addi $r1094 $$locbase i816              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r1094 $r1093 i24                  ; copy memory
addi $r1095 $$locbase i816              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r1096 $$locbase i616              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r1096 $r1095 i24                  ; copy memory
move $r1048 $r1096                      ; move parameter from branch to block argument
ji  .173
.173
move $r1099 $r1048                      ; move parameter from branch to block argument
addi $r1100 $$locbase i640              ; get offset to local __ptr { { ptr, u64, u64 } }
 mcpi $r1100 $r1099 i24                  ; copy memory
 mcpi $r1100 $r1048 i24                  ; copy memory
move $r1101 $r1100                      ; move parameter from branch to block argument
ji  .176
.164
addi $r1102 $$locbase i744              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r1103 $$locbase i448              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r1103 $r1102 i24                  ; copy memory
addi $r1104 $$locbase i224              ; get offset to local __ptr { { ptr, u64, u64 } }
 move $$arg0 $zero                       ; [call: abi_encode_33]: pass argument 0
 movi $$arg0 i0                          ; [call: abi_encode_33]: pass argument 0
move $$arg1 $r1103                      ; [call: abi_encode_33]: pass argument 1
move $$arg2 $r1104                      ; [call: abi_encode_33]: pass argument 2
fncall .28                              ; [call: abi_encode_33]: call function
 move $r1105 $zero                       ; [call: abi_encode_33]: copy returned unit value
 movi $r1105 i0                          ; [call: abi_encode_33]: copy returned unit value
addi $r1106 $$locbase i640              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r1106 $r1104 i24                  ; copy memory
move $r1101 $r1106                      ; move parameter from branch to block argument
ji  .176
.176
move $r1109 $r1101                      ; move parameter from branch to block argument
addi $r1110 $$locbase i936              ; get offset to local __ptr { { ptr, u64, u64 } }
 mcpi $r1110 $r1109 i24                  ; copy memory
 mcpi $r1110 $r1101 i24                  ; copy memory
addi $r1111 $$locbase i936              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r1112 $$locbase i664              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r1112 $r1111 i24                  ; copy memory
addi $r1113 $$locbase i720              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r1113 $r1112 i24                  ; copy memory
addi $r1114 $$locbase i720              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r1115 $$locbase i424              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r1115 $r1114 i24                  ; copy memory
addi $r1116 $$locbase i208              ; get offset to local __ptr slice
move $$arg0 $r1115                      ; [call: as_raw_slice_28]: pass argument 0
move $$arg1 $r1116                      ; [call: as_raw_slice_28]: pass argument 1
fncall .24                              ; [call: as_raw_slice_28]: call function
 move $r1117 $zero                       ; [call: as_raw_slice_28]: copy returned unit value
 movi $r1117 i0                          ; [call: as_raw_slice_28]: copy returned unit value
addi $r1118 $$locbase i688              ; get offset to local __ptr slice
mcpi $r1118 $r1116 i16                  ; copy memory
move $r1119 $r1118                      ; move parameter from branch to block argument
ji  .177
.162
addi $r1120 $$locbase i1080             ; get offset to local __ptr u64
movi $r1121 i24                         ; initialize constant into register
sw $$locbase $r1121 i135                ; store word
addi $r1122 $$locbase i704              ; get offset to local __ptr { __ptr { u64, ( () | bool | slice | slice ) }, u64 }
addi $r1123 $$locbase i960              ; get offset to local __ptr __ptr { u64, ( () | bool | slice | slice ) }
addi $r1124 $$locbase i1080             ; get offset to local __ptr u64
mcpi $r1122 $r1123 i8                   ; copy memory
addi $r1125 $r1122 i8                   ; get offset to aggregate element
mcpi $r1125 $r1124 i8                   ; copy memory
addi $r1126 $$locbase i48               ; get offset to local __ptr { __ptr { u64, ( () | bool | slice | slice ) }, u64 }
mcpi $r1126 $r1122 i16                  ; copy memory
addi $r1127 $$locbase i688              ; get offset to local __ptr slice
mcpi $r1127 $r1126 i16                  ; copy memory
move $r1119 $r1127                      ; move parameter from branch to block argument
ji  .177
.177
move $r1130 $r1119                      ; move parameter from branch to block argument
 mcpi $r936 $r1130 i16                   ; copy memory
 mcpi $r936 $r1119 i16                   ; copy memory
ji  .53
.53
cfsi i1128                              ; [fn end: encode_allow_alias_50] free: locals 1128 byte(s), call args 0 slot(s)
move $$reta $r937                       ; [fn end: encode_allow_alias_50] restore return address
popa .52                                ; [fn end: encode_allow_alias_50] restore all used registers
jal $zero $$reta i0                     ; [fn end: encode_allow_alias_50] return from call
DIFF------------------------------
.program:
.56                                     ; --- start of function: encode_allow_alias_59 ---
pusha .56                               ; [fn init: encode_allow_alias_59]: push all used registers to stack
move $$locbase $sp                      ; [fn init: encode_allow_alias_59]: set locals base register
cfei i152                               ; [fn init: encode_allow_alias_59]: allocate: locals 152 byte(s), call args 0 slot(s)
move $r1138 $$arg0                      ; [fn init: encode_allow_alias_59]: copy argument 0 (item)
move $r1139 $$arg1                      ; [fn init: encode_allow_alias_59]: copy argument 1 (__ret_value)
move $r1140 $$reta                      ; [fn init: encode_allow_alias_59]: save return address
.179
addi $r1141 $$locbase i136              ; get offset to local __ptr __ptr ()
 sw $$locbase $r1138 i17                 ; store word
 jnzi $one .180
 sw $$locbase $$arg0 i17                 ; store word
 ji  .180
ji  .181
.181
addi $r1142 $$locbase i16               ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r1142                      ; [call: new_27]: pass argument 0
fncall .22                              ; [call: new_27]: call function
 move $r1143 $zero                       ; [call: new_27]: copy returned unit value
 movi $r1143 i0                          ; [call: new_27]: copy returned unit value
addi $r1144 $$locbase i112              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r1144 $r1142 i24                  ; copy memory
addi $r1145 $$locbase i112              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r1146 $$locbase i56               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r1146 $r1145 i24                  ; copy memory
addi $r1147 $$locbase i40               ; get offset to local __ptr slice
move $$arg0 $r1146                      ; [call: as_raw_slice_28]: pass argument 0
move $$arg1 $r1147                      ; [call: as_raw_slice_28]: pass argument 1
fncall .24                              ; [call: as_raw_slice_28]: call function
 move $r1148 $zero                       ; [call: as_raw_slice_28]: copy returned unit value
 movi $r1148 i0                          ; [call: as_raw_slice_28]: copy returned unit value
addi $r1149 $$locbase i80               ; get offset to local __ptr slice
mcpi $r1149 $r1147 i16                  ; copy memory
move $r1150 $r1149                      ; move parameter from branch to block argument
ji  .182
.180
addi $r1151 $$locbase i144              ; get offset to local __ptr u64
sw $$locbase $zero i18                  ; store word
addi $r1152 $$locbase i96               ; get offset to local __ptr { __ptr (), u64 }
addi $r1153 $$locbase i136              ; get offset to local __ptr __ptr ()
addi $r1154 $$locbase i144              ; get offset to local __ptr u64
mcpi $r1152 $r1153 i8                   ; copy memory
addi $r1155 $r1152 i8                   ; get offset to aggregate element
mcpi $r1155 $r1154 i8                   ; copy memory
mcpi $$locbase $r1152 i16               ; copy memory
addi $r1156 $$locbase i80               ; get offset to local __ptr slice
mcpi $r1156 $$locbase i16               ; copy memory
move $r1150 $r1156                      ; move parameter from branch to block argument
ji  .182
.182
move $r1159 $r1150                      ; move parameter from branch to block argument
 mcpi $r1139 $r1159 i16                  ; copy memory
 mcpi $r1139 $r1150 i16                  ; copy memory
ji  .57
.57
cfsi i152                               ; [fn end: encode_allow_alias_59] free: locals 152 byte(s), call args 0 slot(s)
move $$reta $r1140                      ; [fn end: encode_allow_alias_59] restore return address
popa .56                                ; [fn end: encode_allow_alias_59] restore all used registers
jal $zero $$reta i0                     ; [fn end: encode_allow_alias_59] return from call
warning: Error message is empty
  --> test/src/e2e_vm_tests/test_programs/should_pass/language/panic_expression/panic_handling_in_unit_tests/src/main.sw:13:17
   |
...
13 |     #[error(m = "")]
   |                 -- Error enum variant "TestError::C" has an empty error message.
   |                 -- help: Consider adding a helpful error message here.
   |
____

  Compiled script "panic_handling_in_unit_tests" with 1 warning.
    Finished debug [unoptimized + fuel] target(s) [8.168 KB] in ???
     Running 2 tests, filtered 18 tests

tested -- panic_handling_in_unit_tests

      test passing_dbgs_and_logs ... ok (???, 4228 gas)
           debug output:
[src/main.sw:23:13] "This is a passing test containing `__dbg` outputs." = "This is a passing test containing `__dbg` outputs."
[src/main.sw:25:13] x = 42
           decoded log values:
AsciiString { data: "This is a log from the passing test." }, log rb: 10098701174489624218
42, log rb: 1515152261580153489
           raw logs:
[{"LogData":{"data":"0000000000000024546869732069732061206c6f672066726f6d207468652070617373696e6720746573742e","digest":"29d742ad9093cdf81404ff756467a44448729b85ab3c0d65197829fb61d2dd29","id":"0000000000000000000000000000000000000000000000000000000000000000","is":10368,"len":44,"pc":10832,"ptr":67107840,"ra":0,"rb":10098701174489624218}},{"LogData":{"data":"000000000000002a","digest":"a6bb133cb1e3638ad7b8a3ff0539668e9e56f9b850ef1b2a810f5422eaa6c323","id":"0000000000000000000000000000000000000000000000000000000000000000","is":10368,"len":8,"pc":15644,"ptr":19304,"ra":0,"rb":1515152261580153489}}]
      test passing_no_dbgs_or_logs ... ok (???, 74 gas)

test result: OK. 2 passed; 0 failed; finished in ???

    Finished in ???

> forc test --path test/src/e2e_vm_tests/test_programs/should_pass/language/panic_expression/panic_handling_in_unit_tests
exit status: 101
output:
    Building test/src/e2e_vm_tests/test_programs/should_pass/language/panic_expression/panic_handling_in_unit_tests
   Compiling library std (sway-lib-std)
DIFF------------------------------
.program:
   Compiling script panic_handling_in_unit_tests (test/src/e2e_vm_tests/test_programs/should_pass/language/panic_expression/panic_handling_in_unit_tests)
DIFF------------------------------
.program:
DIFF------------------------------
.program:
.0                                      ; --- start of function: __entry ---
move $$locbase $sp                      ; [entry init: __entry]: set locals base register
cfei i0                                 ; [entry init: __entry]: allocate: locals 0 byte(s), call args 0 slot(s)
.78
fncall .2                               ; [call: main_0]: call function
 move $r1 $zero                          ; [call: main_0]: copy returned unit value
 movi $r1 i0                             ; [call: main_0]: copy returned unit value
retd $zero $zero                        ; [entry end: __entry] return slice
DIFF------------------------------
.program:
.4                                      ; --- start of function: passing_dbgs_and_logs ---
move $$locbase $sp                      ; [entry init: passing_dbgs_and_logs]: set locals base register
cfei i264                               ; [entry init: passing_dbgs_and_logs]: allocate: locals 264 byte(s), call args 0 slot(s)
.80
addr $r4 data_NonConfigurable_0         ; get __const_global's address in data section
sw $$locbase $r4 i0                     ; store word
addi $r5 $$locbase i8                   ; get offset to aggregate element
movi $r6 i50                            ; initialize constant into register
sw $$locbase $r6 i1                     ; store word
addi $r7 $$locbase i16                  ; get offset to local __ptr slice
mcpi $r7 $$locbase i16                  ; copy memory
addi $r8 $$locbase i224                 ; get offset to local __ptr {  }
addi $r9 $$locbase i224                 ; get offset to local __ptr {  }
addi $r10 $$locbase i224                ; get offset to local __ptr {  }
addr $r11 data_NonConfigurable_1        ; get __const_global0's address in data section
addi $r12 $$locbase i64                 ; get offset to local __ptr { ptr, u64 }
sw $$locbase $r11 i8                    ; store word
addi $r13 $r12 i8                       ; get offset to aggregate element
movi $r14 i75                           ; initialize constant into register
sw $$locbase $r14 i9                    ; store word
addi $r15 $$locbase i80                 ; get offset to local __ptr slice
mcpi $r15 $r12 i16                      ; copy memory
addi $r16 $$locbase i224                ; get offset to local __ptr {  }
addi $r17 $$locbase i80                 ; get offset to local __ptr slice
move $$arg0 $r16                        ; [call: print_str_1]: pass argument 0
move $$arg1 $r17                        ; [call: print_str_1]: pass argument 1
fncall .6                               ; [call: print_str_1]: call function
 move $r18 $zero                         ; [call: print_str_1]: copy returned unit value
 movi $r18 i0                            ; [call: print_str_1]: copy returned unit value
addi $r19 $$locbase i224                ; get offset to local __ptr {  }
addi $r20 $$locbase i16                 ; get offset to local __ptr slice
move $$arg0 $r20                        ; [call: fmt_5]: pass argument 0
move $$arg1 $r19                        ; [call: fmt_5]: pass argument 1
fncall .12                              ; [call: fmt_5]: call function
 move $r21 $zero                         ; [call: fmt_5]: copy returned unit value
 movi $r21 i0                            ; [call: fmt_5]: copy returned unit value
addi $r22 $$locbase i224                ; get offset to local __ptr {  }
addr $r23 data_NonConfigurable_2        ; get __const_global1's address in data section
addi $r24 $$locbase i96                 ; get offset to local __ptr { ptr, u64 }
sw $$locbase $r23 i12                   ; store word
addi $r25 $r24 i8                       ; get offset to aggregate element
sw $$locbase $one i13                   ; store word
addi $r26 $$locbase i112                ; get offset to local __ptr slice
mcpi $r26 $r24 i16                      ; copy memory
addi $r27 $$locbase i224                ; get offset to local __ptr {  }
addi $r28 $$locbase i112                ; get offset to local __ptr slice
move $$arg0 $r27                        ; [call: print_str_1]: pass argument 0
move $$arg1 $r28                        ; [call: print_str_1]: pass argument 1
fncall .6                               ; [call: print_str_1]: call function
 move $r29 $zero                         ; [call: print_str_1]: copy returned unit value
 movi $r29 i0                            ; [call: print_str_1]: copy returned unit value
addr $r30 data_NonConfigurable_3        ; get std::debug::STDERR's address in data section
addi $r31 $$locbase i224                ; get offset to local __ptr u64
mcpi $r31 $r30 i8                       ; copy memory
addi $r32 $$locbase i224                ; get offset to local __ptr u64
lw $r33 $$locbase i28                   ; load word
movi $r34 i1001                         ; initialize constant into register
ecal $r34 $r33 $zero $zero              ; ecal id fd zero zero
 move $r35 $zero                         ; return unit value from ASM block without return register
 movi $r35 i0                            ; return unit value from ASM block without return register
addi $r36 $$locbase i256                ; get offset to local __ptr u64
movi $r37 i42                           ; initialize constant into register
sw $$locbase $r37 i32                   ; store word
addi $r38 $$locbase i224                ; get offset to local __ptr {  }
addi $r39 $$locbase i224                ; get offset to local __ptr {  }
addi $r40 $$locbase i224                ; get offset to local __ptr {  }
addr $r41 data_NonConfigurable_4        ; get __const_global2's address in data section
addi $r42 $$locbase i128                ; get offset to local __ptr { ptr, u64 }
sw $$locbase $r41 i16                   ; store word
addi $r43 $r42 i8                       ; get offset to aggregate element
movi $r44 i24                           ; initialize constant into register
sw $$locbase $r44 i17                   ; store word
addi $r45 $$locbase i144                ; get offset to local __ptr slice
mcpi $r45 $r42 i16                      ; copy memory
addi $r46 $$locbase i224                ; get offset to local __ptr {  }
addi $r47 $$locbase i144                ; get offset to local __ptr slice
move $$arg0 $r46                        ; [call: print_str_1]: pass argument 0
move $$arg1 $r47                        ; [call: print_str_1]: pass argument 1
fncall .6                               ; [call: print_str_1]: call function
 move $r48 $zero                         ; [call: print_str_1]: copy returned unit value
 movi $r48 i0                            ; [call: print_str_1]: copy returned unit value
addi $r49 $$locbase i256                ; get offset to local __ptr u64
lw $r50 $$locbase i32                   ; load word
addi $r51 $$locbase i224                ; get offset to local __ptr {  }
move $$arg0 $r50                        ; [call: fmt_9]: pass argument 0
move $$arg1 $r51                        ; [call: fmt_9]: pass argument 1
fncall .16                              ; [call: fmt_9]: call function
 move $r52 $zero                         ; [call: fmt_9]: copy returned unit value
 movi $r52 i0                            ; [call: fmt_9]: copy returned unit value
addi $r53 $$locbase i224                ; get offset to local __ptr {  }
addr $r54 data_NonConfigurable_2        ; get __const_global3's address in data section
addi $r55 $$locbase i160                ; get offset to local __ptr { ptr, u64 }
sw $$locbase $r54 i20                   ; store word
addi $r56 $r55 i8                       ; get offset to aggregate element
sw $$locbase $one i21                   ; store word
addi $r57 $$locbase i176                ; get offset to local __ptr slice
mcpi $r57 $r55 i16                      ; copy memory
addi $r58 $$locbase i224                ; get offset to local __ptr {  }
addi $r59 $$locbase i176                ; get offset to local __ptr slice
move $$arg0 $r58                        ; [call: print_str_1]: pass argument 0
move $$arg1 $r59                        ; [call: print_str_1]: pass argument 1
fncall .6                               ; [call: print_str_1]: call function
 move $r60 $zero                         ; [call: print_str_1]: copy returned unit value
 movi $r60 i0                            ; [call: print_str_1]: copy returned unit value
addr $r61 data_NonConfigurable_3        ; get std::debug::STDERR's address in data section
addi $r62 $$locbase i232                ; get offset to local __ptr u64
mcpi $r62 $r61 i8                       ; copy memory
addi $r63 $$locbase i232                ; get offset to local __ptr u64
lw $r64 $$locbase i29                   ; load word
movi $r65 i1001                         ; initialize constant into register
ecal $r65 $r64 $zero $zero              ; ecal id fd zero zero
 move $r66 $zero                         ; return unit value from ASM block without return register
 movi $r66 i0                            ; return unit value from ASM block without return register
addr $r67 data_NonConfigurable_5        ; get __const_global4's address in data section
addi $r68 $$locbase i32                 ; get offset to local __ptr { ptr, u64 }
sw $$locbase $r67 i4                    ; store word
addi $r69 $r68 i8                       ; get offset to aggregate element
movi $r70 i36                           ; initialize constant into register
sw $$locbase $r70 i5                    ; store word
addi $r71 $$locbase i48                 ; get offset to local __ptr slice
mcpi $r71 $r68 i16                      ; copy memory
addi $r72 $$locbase i240                ; get offset to local __ptr slice
mcpi $r72 $r71 i16                      ; copy memory
addi $r73 $$locbase i240                ; get offset to local __ptr slice
addi $r74 $$locbase i208                ; get offset to local __ptr slice
move $$arg0 $r73                        ; [call: encode_allow_alias_23]: pass argument 0
move $$arg1 $r74                        ; [call: encode_allow_alias_23]: pass argument 1
fncall .18                              ; [call: encode_allow_alias_23]: call function
 move $r75 $zero                         ; [call: encode_allow_alias_23]: copy returned unit value
 movi $r75 i0                            ; [call: encode_allow_alias_23]: copy returned unit value
addi $r76 $$locbase i192                ; get offset to local __ptr slice
mcpi $r76 $r74 i16                      ; copy memory
load $r77 data_NonConfigurable_6        ; load constant from data section
lw $r78 $$locbase i24                   ; load slice pointer for logging data
lw $r79 $$locbase i25                   ; load slice size for logging data
logd $zero $r77 $r78 $r79               ; log slice
addi $r80 $$locbase i256                ; get offset to local __ptr u64
lw $r81 $$locbase i32                   ; load word
move $$arg0 $r81                        ; [call: log_29]: pass argument 0
fncall .26                              ; [call: log_29]: call function
 move $r82 $zero                         ; [call: log_29]: copy returned unit value
 movi $r82 i0                            ; [call: log_29]: copy returned unit value
ret $zero                               ; [entry end: passing_dbgs_and_logs] return unit as zero
DIFF------------------------------
.program:
.30                                     ; --- start of function: passing_no_dbgs_or_logs ---
move $$locbase $sp                      ; [entry init: passing_no_dbgs_or_logs]: set locals base register
cfei i0                                 ; [entry init: passing_no_dbgs_or_logs]: allocate: locals 0 byte(s), call args 0 slot(s)
.114
ret $zero                               ; [entry end: passing_no_dbgs_or_logs] return unit as zero
DIFF------------------------------
.program:
.32                                     ; --- start of function: failing_revert_intrinsic ---
move $$locbase $sp                      ; [entry init: failing_revert_intrinsic]: set locals base register
cfei i0                                 ; [entry init: failing_revert_intrinsic]: allocate: locals 0 byte(s), call args 0 slot(s)
.115
movi $r447 i112233                      ; initialize constant into register
rvrt $r447
DIFF------------------------------
.program:
.34                                     ; --- start of function: failing_revert_function_with_dbgs_and_logs ---
move $$locbase $sp                      ; [entry init: failing_revert_function_with_dbgs_and_logs]: set locals base register
cfei i264                               ; [entry init: failing_revert_function_with_dbgs_and_logs]: allocate: locals 264 byte(s), call args 0 slot(s)
.116
addr $r449 data_NonConfigurable_8       ; get __const_global5's address in data section
sw $$locbase $r449 i0                   ; store word
addi $r450 $$locbase i8                 ; get offset to aggregate element
movi $r451 i29                          ; initialize constant into register
sw $$locbase $r451 i1                   ; store word
addi $r452 $$locbase i16                ; get offset to local __ptr slice
mcpi $r452 $$locbase i16                ; copy memory
addi $r453 $$locbase i224               ; get offset to local __ptr {  }
addi $r454 $$locbase i224               ; get offset to local __ptr {  }
addi $r455 $$locbase i224               ; get offset to local __ptr {  }
addr $r456 data_NonConfigurable_9       ; get __const_global6's address in data section
addi $r457 $$locbase i64                ; get offset to local __ptr { ptr, u64 }
sw $$locbase $r456 i8                   ; store word
addi $r458 $r457 i8                     ; get offset to aggregate element
movi $r459 i54                          ; initialize constant into register
sw $$locbase $r459 i9                   ; store word
addi $r460 $$locbase i80                ; get offset to local __ptr slice
mcpi $r460 $r457 i16                    ; copy memory
addi $r461 $$locbase i224               ; get offset to local __ptr {  }
addi $r462 $$locbase i80                ; get offset to local __ptr slice
move $$arg0 $r461                       ; [call: print_str_1]: pass argument 0
move $$arg1 $r462                       ; [call: print_str_1]: pass argument 1
fncall .6                               ; [call: print_str_1]: call function
 move $r463 $zero                        ; [call: print_str_1]: copy returned unit value
 movi $r463 i0                           ; [call: print_str_1]: copy returned unit value
addi $r464 $$locbase i224               ; get offset to local __ptr {  }
addi $r465 $$locbase i16                ; get offset to local __ptr slice
move $$arg0 $r465                       ; [call: fmt_5]: pass argument 0
move $$arg1 $r464                       ; [call: fmt_5]: pass argument 1
fncall .12                              ; [call: fmt_5]: call function
 move $r466 $zero                        ; [call: fmt_5]: copy returned unit value
 movi $r466 i0                           ; [call: fmt_5]: copy returned unit value
addi $r467 $$locbase i224               ; get offset to local __ptr {  }
addr $r468 data_NonConfigurable_2       ; get __const_global7's address in data section
addi $r469 $$locbase i96                ; get offset to local __ptr { ptr, u64 }
sw $$locbase $r468 i12                  ; store word
addi $r470 $r469 i8                     ; get offset to aggregate element
sw $$locbase $one i13                   ; store word
addi $r471 $$locbase i112               ; get offset to local __ptr slice
mcpi $r471 $r469 i16                    ; copy memory
addi $r472 $$locbase i224               ; get offset to local __ptr {  }
addi $r473 $$locbase i112               ; get offset to local __ptr slice
move $$arg0 $r472                       ; [call: print_str_1]: pass argument 0
move $$arg1 $r473                       ; [call: print_str_1]: pass argument 1
fncall .6                               ; [call: print_str_1]: call function
 move $r474 $zero                        ; [call: print_str_1]: copy returned unit value
 movi $r474 i0                           ; [call: print_str_1]: copy returned unit value
addr $r475 data_NonConfigurable_3       ; get std::debug::STDERR's address in data section
addi $r476 $$locbase i224               ; get offset to local __ptr u64
mcpi $r476 $r475 i8                     ; copy memory
addi $r477 $$locbase i224               ; get offset to local __ptr u64
lw $r478 $$locbase i28                  ; load word
movi $r479 i1001                        ; initialize constant into register
ecal $r479 $r478 $zero $zero            ; ecal id fd zero zero
 move $r480 $zero                        ; return unit value from ASM block without return register
 movi $r480 i0                           ; return unit value from ASM block without return register
addi $r481 $$locbase i240               ; get offset to local __ptr u64
load $r482 data_NonConfigurable_10      ; load constant from data section
sw $$locbase $r482 i30                  ; store word
addi $r483 $$locbase i224               ; get offset to local __ptr {  }
addi $r484 $$locbase i224               ; get offset to local __ptr {  }
addi $r485 $$locbase i224               ; get offset to local __ptr {  }
addr $r486 data_NonConfigurable_11      ; get __const_global8's address in data section
addi $r487 $$locbase i128               ; get offset to local __ptr { ptr, u64 }
sw $$locbase $r486 i16                  ; store word
addi $r488 $r487 i8                     ; get offset to aggregate element
movi $r489 i34                          ; initialize constant into register
sw $$locbase $r489 i17                  ; store word
addi $r490 $$locbase i144               ; get offset to local __ptr slice
mcpi $r490 $r487 i16                    ; copy memory
addi $r491 $$locbase i224               ; get offset to local __ptr {  }
addi $r492 $$locbase i144               ; get offset to local __ptr slice
move $$arg0 $r491                       ; [call: print_str_1]: pass argument 0
move $$arg1 $r492                       ; [call: print_str_1]: pass argument 1
fncall .6                               ; [call: print_str_1]: call function
 move $r493 $zero                        ; [call: print_str_1]: copy returned unit value
 movi $r493 i0                           ; [call: print_str_1]: copy returned unit value
addi $r494 $$locbase i240               ; get offset to local __ptr u64
lw $r495 $$locbase i30                  ; load word
addi $r496 $$locbase i224               ; get offset to local __ptr {  }
move $$arg0 $r495                       ; [call: fmt_9]: pass argument 0
move $$arg1 $r496                       ; [call: fmt_9]: pass argument 1
fncall .16                              ; [call: fmt_9]: call function
 move $r497 $zero                        ; [call: fmt_9]: copy returned unit value
 movi $r497 i0                           ; [call: fmt_9]: copy returned unit value
addi $r498 $$locbase i224               ; get offset to local __ptr {  }
addr $r499 data_NonConfigurable_2       ; get __const_global9's address in data section
addi $r500 $$locbase i160               ; get offset to local __ptr { ptr, u64 }
sw $$locbase $r499 i20                  ; store word
addi $r501 $r500 i8                     ; get offset to aggregate element
sw $$locbase $one i21                   ; store word
addi $r502 $$locbase i176               ; get offset to local __ptr slice
mcpi $r502 $r500 i16                    ; copy memory
addi $r503 $$locbase i224               ; get offset to local __ptr {  }
addi $r504 $$locbase i176               ; get offset to local __ptr slice
move $$arg0 $r503                       ; [call: print_str_1]: pass argument 0
move $$arg1 $r504                       ; [call: print_str_1]: pass argument 1
fncall .6                               ; [call: print_str_1]: call function
 move $r505 $zero                        ; [call: print_str_1]: copy returned unit value
 movi $r505 i0                           ; [call: print_str_1]: copy returned unit value
addr $r506 data_NonConfigurable_3       ; get std::debug::STDERR's address in data section
addi $r507 $$locbase i232               ; get offset to local __ptr u64
mcpi $r507 $r506 i8                     ; copy memory
addi $r508 $$locbase i232               ; get offset to local __ptr u64
lw $r509 $$locbase i29                  ; load word
movi $r510 i1001                        ; initialize constant into register
ecal $r510 $r509 $zero $zero            ; ecal id fd zero zero
 move $r511 $zero                        ; return unit value from ASM block without return register
 movi $r511 i0                           ; return unit value from ASM block without return register
addr $r512 data_NonConfigurable_12      ; get __const_global10's address in data section
addi $r513 $$locbase i32                ; get offset to local __ptr { ptr, u64 }
sw $$locbase $r512 i4                   ; store word
addi $r514 $r513 i8                     ; get offset to aggregate element
movi $r515 i38                          ; initialize constant into register
sw $$locbase $r515 i5                   ; store word
addi $r516 $$locbase i48                ; get offset to local __ptr slice
mcpi $r516 $r513 i16                    ; copy memory
addi $r517 $$locbase i248               ; get offset to local __ptr slice
mcpi $r517 $r516 i16                    ; copy memory
addi $r518 $$locbase i248               ; get offset to local __ptr slice
addi $r519 $$locbase i208               ; get offset to local __ptr slice
move $$arg0 $r518                       ; [call: encode_allow_alias_23]: pass argument 0
move $$arg1 $r519                       ; [call: encode_allow_alias_23]: pass argument 1
fncall .18                              ; [call: encode_allow_alias_23]: call function
 move $r520 $zero                        ; [call: encode_allow_alias_23]: copy returned unit value
 movi $r520 i0                           ; [call: encode_allow_alias_23]: copy returned unit value
addi $r521 $$locbase i192               ; get offset to local __ptr slice
mcpi $r521 $r519 i16                    ; copy memory
load $r522 data_NonConfigurable_6       ; load constant from data section
lw $r523 $$locbase i24                  ; load slice pointer for logging data
lw $r524 $$locbase i25                  ; load slice size for logging data
logd $zero $r522 $r523 $r524            ; log slice
addi $r525 $$locbase i240               ; get offset to local __ptr u64
lw $r526 $$locbase i30                  ; load word
rvrt $r526
DIFF------------------------------
.program:
.36                                     ; --- start of function: failing_error_signal_assert ---
move $$locbase $sp                      ; [entry init: failing_error_signal_assert]: set locals base register
cfei i520                               ; [entry init: failing_error_signal_assert]: allocate: locals 520 byte(s), call args 0 slot(s)
.117
sw $$locbase $zero i0                   ; store word
addi $r528 $$locbase i376               ; get offset to local __ptr {  }
addi $r529 $$locbase i416               ; get offset to local __ptr {  }
addi $r530 $$locbase i416               ; get offset to local __ptr {  }
addr $r531 data_NonConfigurable_13      ; get __const_global11's address in data section
addi $r532 $$locbase i72                ; get offset to local __ptr { ptr, u64 }
sw $$locbase $r531 i9                   ; store word
addi $r533 $r532 i8                     ; get offset to aggregate element
movi $r534 i35                          ; initialize constant into register
sw $$locbase $r534 i10                  ; store word
addi $r535 $$locbase i136               ; get offset to local __ptr slice
mcpi $r535 $r532 i16                    ; copy memory
addi $r536 $$locbase i376               ; get offset to local __ptr {  }
addi $r537 $$locbase i136               ; get offset to local __ptr slice
move $$arg0 $r536                       ; [call: print_str_1]: pass argument 0
move $$arg1 $r537                       ; [call: print_str_1]: pass argument 1
fncall .6                               ; [call: print_str_1]: call function
 move $r538 $zero                        ; [call: print_str_1]: copy returned unit value
 movi $r538 i0                           ; [call: print_str_1]: copy returned unit value
addi $r539 $$locbase i416               ; get offset to local __ptr {  }
addi $r540 $$locbase i384               ; get offset to local __ptr __ptr {  }
sw $$locbase $r539 i48                  ; store word
addi $r541 $$locbase i312               ; get offset to local __ptr { u64, ( () | bool | slice | slice ) }
mcpi $r541 $$locbase i24                ; copy memory
addi $r542 $$locbase i424               ; get offset to local __ptr u64
sw $$locbase $zero i53                  ; store word
lw $r543 $$locbase i0                   ; load word
addi $r544 $$locbase i424               ; get offset to local __ptr u64
lw $r545 $$locbase i53                  ; load word
eq $r546 $r543 $r545
jnzi $r546 .118
ji  .119
.119
addi $r547 $$locbase i312               ; get offset to local __ptr { u64, ( () | bool | slice | slice ) }
addi $r548 $$locbase i432               ; get offset to local __ptr u64
sw $$locbase $one i54                   ; store word
lw $r549 $$locbase i39                  ; load word
addi $r550 $$locbase i432               ; get offset to local __ptr u64
lw $r551 $$locbase i54                  ; load word
eq $r552 $r549 $r551
jnzi $r552 .120
ji  .121
.121
addi $r553 $$locbase i312               ; get offset to local __ptr { u64, ( () | bool | slice | slice ) }
addi $r554 $$locbase i440               ; get offset to local __ptr u64
movi $r555 i2                           ; initialize constant into register
sw $$locbase $r555 i55                  ; store word
lw $r556 $$locbase i39                  ; load word
addi $r557 $$locbase i440               ; get offset to local __ptr u64
lw $r558 $$locbase i55                  ; load word
eq $r559 $r556 $r558
jnzi $r559 .122
ji  .123
.123
addi $r560 $$locbase i312               ; get offset to local __ptr { u64, ( () | bool | slice | slice ) }
addi $r561 $$locbase i448               ; get offset to local __ptr u64
movi $r562 i3                           ; initialize constant into register
sw $$locbase $r562 i56                  ; store word
lw $r563 $$locbase i39                  ; load word
addi $r564 $$locbase i448               ; get offset to local __ptr u64
lw $r565 $$locbase i56                  ; load word
eq $r566 $r563 $r565
jnzi $r566 .124
ji  .125
.125
load $r567 data_NonConfigurable_14      ; load constant from data section
rvrt $r567
.124
addi $r568 $$locbase i312               ; get offset to local __ptr { u64, ( () | bool | slice | slice ) }
addi $r569 $r568 i8                     ; get offset to aggregate element
addi $r570 $$locbase i384               ; get offset to local __ptr __ptr {  }
lw $r571 $$locbase i48                  ; load word
addr $r572 data_NonConfigurable_15      ; get __const_global21's address in data section
addi $r573 $$locbase i280               ; get offset to local __ptr { ptr, u64 }
sw $$locbase $r572 i35                  ; store word
addi $r574 $r573 i8                     ; get offset to aggregate element
movi $r575 i9                           ; initialize constant into register
sw $$locbase $r575 i36                  ; store word
addi $r576 $$locbase i296               ; get offset to local __ptr slice
mcpi $r576 $r573 i16                    ; copy memory
addi $r577 $$locbase i376               ; get offset to local __ptr {  }
addi $r578 $$locbase i296               ; get offset to local __ptr slice
addi $r579 $$locbase i352               ; get offset to local __ptr { {  }, bool }
move $$arg0 $r577                       ; [call: debug_tuple_39]: pass argument 0
move $$arg1 $r578                       ; [call: debug_tuple_39]: pass argument 1
move $$arg2 $r579                       ; [call: debug_tuple_39]: pass argument 2
fncall .40                              ; [call: debug_tuple_39]: call function
 move $r580 $zero                        ; [call: debug_tuple_39]: copy returned unit value
 movi $r580 i0                           ; [call: debug_tuple_39]: copy returned unit value
addi $r581 $$locbase i496               ; get offset to local __ptr { {  }, bool }
mcpi $r581 $r579 i8                     ; copy memory
addi $r582 $$locbase i368               ; get offset to local __ptr { {  }, bool }
move $$arg0 $r581                       ; [call: field_41]: pass argument 0
move $$arg1 $r569                       ; [call: field_41]: pass argument 1
move $$arg2 $r582                       ; [call: field_41]: pass argument 2
fncall .42                              ; [call: field_41]: call function
 move $r583 $zero                        ; [call: field_41]: copy returned unit value
 movi $r583 i0                           ; [call: field_41]: copy returned unit value
addi $r584 $$locbase i504               ; get offset to local __ptr { {  }, bool }
mcpi $r584 $r582 i8                     ; copy memory
move $$arg0 $r584                       ; [call: finish_36]: pass argument 0
fncall .38                              ; [call: finish_36]: call function
 move $r585 $zero                        ; [call: finish_36]: copy returned unit value
 movi $r585 i0                           ; [call: finish_36]: copy returned unit value
ji  .126
.122
addi $r586 $$locbase i312               ; get offset to local __ptr { u64, ( () | bool | slice | slice ) }
addi $r587 $r586 i8                     ; get offset to aggregate element
addi $r588 $$locbase i384               ; get offset to local __ptr __ptr {  }
lw $r589 $$locbase i48                  ; load word
addr $r590 data_NonConfigurable_15      ; get __const_global20's address in data section
addi $r591 $$locbase i248               ; get offset to local __ptr { ptr, u64 }
sw $$locbase $r590 i31                  ; store word
addi $r592 $r591 i8                     ; get offset to aggregate element
movi $r593 i9                           ; initialize constant into register
sw $$locbase $r593 i32                  ; store word
addi $r594 $$locbase i264               ; get offset to local __ptr slice
mcpi $r594 $r591 i16                    ; copy memory
addi $r595 $$locbase i376               ; get offset to local __ptr {  }
addi $r596 $$locbase i264               ; get offset to local __ptr slice
addi $r597 $$locbase i344               ; get offset to local __ptr { {  }, bool }
move $$arg0 $r595                       ; [call: debug_tuple_39]: pass argument 0
move $$arg1 $r596                       ; [call: debug_tuple_39]: pass argument 1
move $$arg2 $r597                       ; [call: debug_tuple_39]: pass argument 2
fncall .40                              ; [call: debug_tuple_39]: call function
 move $r598 $zero                        ; [call: debug_tuple_39]: copy returned unit value
 movi $r598 i0                           ; [call: debug_tuple_39]: copy returned unit value
addi $r599 $$locbase i480               ; get offset to local __ptr { {  }, bool }
mcpi $r599 $r597 i8                     ; copy memory
addi $r600 $$locbase i360               ; get offset to local __ptr { {  }, bool }
move $$arg0 $r599                       ; [call: field_41]: pass argument 0
move $$arg1 $r587                       ; [call: field_41]: pass argument 1
move $$arg2 $r600                       ; [call: field_41]: pass argument 2
fncall .42                              ; [call: field_41]: call function
 move $r601 $zero                        ; [call: field_41]: copy returned unit value
 movi $r601 i0                           ; [call: field_41]: copy returned unit value
addi $r602 $$locbase i488               ; get offset to local __ptr { {  }, bool }
mcpi $r602 $r600 i8                     ; copy memory
move $$arg0 $r602                       ; [call: finish_36]: pass argument 0
fncall .38                              ; [call: finish_36]: call function
 move $r603 $zero                        ; [call: finish_36]: copy returned unit value
 movi $r603 i0                           ; [call: finish_36]: copy returned unit value
ji  .126
.120
addi $r604 $$locbase i312               ; get offset to local __ptr { u64, ( () | bool | slice | slice ) }
addi $r605 $r604 i23                    ; get offset to aggregate element
addi $r606 $$locbase i384               ; get offset to local __ptr __ptr {  }
lw $r607 $$locbase i48                  ; load word
addr $r608 data_NonConfigurable_15      ; get __const_global18's address in data section
addi $r609 $$locbase i152               ; get offset to local __ptr { ptr, u64 }
sw $$locbase $r608 i19                  ; store word
addi $r610 $r609 i8                     ; get offset to aggregate element
movi $r611 i9                           ; initialize constant into register
sw $$locbase $r611 i20                  ; store word
addi $r612 $$locbase i200               ; get offset to local __ptr slice
mcpi $r612 $r609 i16                    ; copy memory
addi $r613 $$locbase i376               ; get offset to local __ptr {  }
addi $r614 $$locbase i200               ; get offset to local __ptr slice
addi $r615 $$locbase i336               ; get offset to local __ptr { {  }, bool }
move $$arg0 $r613                       ; [call: debug_tuple_39]: pass argument 0
move $$arg1 $r614                       ; [call: debug_tuple_39]: pass argument 1
move $$arg2 $r615                       ; [call: debug_tuple_39]: pass argument 2
fncall .40                              ; [call: debug_tuple_39]: call function
 move $r616 $zero                        ; [call: debug_tuple_39]: copy returned unit value
 movi $r616 i0                           ; [call: debug_tuple_39]: copy returned unit value
addi $r617 $$locbase i464               ; get offset to local __ptr { {  }, bool }
mcpi $r617 $r615 i8                     ; copy memory
addi $r618 $$locbase i456               ; get offset to local __ptr __ptr { {  }, bool }
sw $$locbase $r617 i57                  ; store word
addi $r619 $$locbase i512               ; get offset to local __ptr bool
mcpi $r619 $r605 i1                     ; copy memory
addi $r620 $$locbase i456               ; get offset to local __ptr __ptr { {  }, bool }
lw $r621 $$locbase i57                  ; load word
lb $r622 $r621 i0                       ; load byte
jnzi $r622 .127
ji  .128
.127
addi $r623 $$locbase i456               ; get offset to local __ptr __ptr { {  }, bool }
lw $r624 $$locbase i57                  ; load word
addr $r625 data_NonConfigurable_16      ; get __const_global14's address in data section
addi $r626 $$locbase i40                ; get offset to local __ptr { ptr, u64 }
sw $$locbase $r625 i5                   ; store word
addi $r627 $r626 i8                     ; get offset to aggregate element
movi $r628 i2                           ; initialize constant into register
sw $$locbase $r628 i6                   ; store word
addi $r629 $$locbase i104               ; get offset to local __ptr slice
mcpi $r629 $r626 i16                    ; copy memory
addi $r630 $$locbase i376               ; get offset to local __ptr {  }
addi $r631 $$locbase i104               ; get offset to local __ptr slice
move $$arg0 $r630                       ; [call: print_str_1]: pass argument 0
move $$arg1 $r631                       ; [call: print_str_1]: pass argument 1
fncall .6                               ; [call: print_str_1]: call function
 move $r632 $zero                        ; [call: print_str_1]: copy returned unit value
 movi $r632 i0                           ; [call: print_str_1]: copy returned unit value
ji  .128
.128
addi $r633 $$locbase i512               ; get offset to local __ptr bool
addi $r634 $$locbase i456               ; get offset to local __ptr __ptr { {  }, bool }
lw $r635 $$locbase i57                  ; load word
addi $r636 $$locbase i408               ; get offset to local __ptr __ptr {  }
sw $$locbase $r635 i51                  ; store word
lb $r637 $r633 i0                       ; load byte
jnzi $r637 .129
ji  .130
.130
addi $r638 $$locbase i408               ; get offset to local __ptr __ptr {  }
lw $r639 $$locbase i51                  ; load word
addr $r640 data_NonConfigurable_17      ; get __const_global16's address in data section
addi $r641 $$locbase i168               ; get offset to local __ptr { ptr, u64 }
sw $$locbase $r640 i21                  ; store word
addi $r642 $r641 i8                     ; get offset to aggregate element
movi $r643 i5                           ; initialize constant into register
sw $$locbase $r643 i22                  ; store word
addi $r644 $$locbase i216               ; get offset to local __ptr slice
mcpi $r644 $r641 i16                    ; copy memory
addi $r645 $$locbase i376               ; get offset to local __ptr {  }
addi $r646 $$locbase i216               ; get offset to local __ptr slice
move $$arg0 $r645                       ; [call: print_str_1]: pass argument 0
move $$arg1 $r646                       ; [call: print_str_1]: pass argument 1
fncall .6                               ; [call: print_str_1]: call function
 move $r647 $zero                        ; [call: print_str_1]: copy returned unit value
 movi $r647 i0                           ; [call: print_str_1]: copy returned unit value
ji  .131
.129
addi $r648 $$locbase i408               ; get offset to local __ptr __ptr {  }
lw $r649 $$locbase i51                  ; load word
addr $r650 data_NonConfigurable_18      ; get __const_global15's address in data section
addi $r651 $$locbase i56                ; get offset to local __ptr { ptr, u64 }
sw $$locbase $r650 i7                   ; store word
addi $r652 $r651 i8                     ; get offset to aggregate element
movi $r653 i4                           ; initialize constant into register
sw $$locbase $r653 i8                   ; store word
addi $r654 $$locbase i120               ; get offset to local __ptr slice
mcpi $r654 $r651 i16                    ; copy memory
addi $r655 $$locbase i376               ; get offset to local __ptr {  }
addi $r656 $$locbase i120               ; get offset to local __ptr slice
move $$arg0 $r655                       ; [call: print_str_1]: pass argument 0
move $$arg1 $r656                       ; [call: print_str_1]: pass argument 1
fncall .6                               ; [call: print_str_1]: call function
 move $r657 $zero                        ; [call: print_str_1]: copy returned unit value
 movi $r657 i0                           ; [call: print_str_1]: copy returned unit value
ji  .131
.131
addi $r658 $$locbase i456               ; get offset to local __ptr __ptr { {  }, bool }
lw $r659 $$locbase i57                  ; load word
sb $r659 $one i0                        ; store byte
addi $r660 $$locbase i456               ; get offset to local __ptr __ptr { {  }, bool }
lw $r661 $$locbase i57                  ; load word
addi $r662 $$locbase i376               ; get offset to local __ptr { {  }, bool }
mcpi $r662 $r661 i8                     ; copy memory
addi $r663 $$locbase i472               ; get offset to local __ptr { {  }, bool }
mcpi $r663 $r662 i8                     ; copy memory
move $$arg0 $r663                       ; [call: finish_36]: pass argument 0
fncall .38                              ; [call: finish_36]: call function
 move $r664 $zero                        ; [call: finish_36]: copy returned unit value
 movi $r664 i0                           ; [call: finish_36]: copy returned unit value
ji  .126
.118
addi $r665 $$locbase i384               ; get offset to local __ptr __ptr {  }
lw $r666 $$locbase i48                  ; load word
addr $r667 data_NonConfigurable_19      ; get __const_global12's address in data section
addi $r668 $$locbase i24                ; get offset to local __ptr { ptr, u64 }
sw $$locbase $r667 i3                   ; store word
addi $r669 $r668 i8                     ; get offset to aggregate element
sw $$locbase $one i4                    ; store word
addi $r670 $$locbase i88                ; get offset to local __ptr slice
mcpi $r670 $r668 i16                    ; copy memory
addi $r671 $$locbase i376               ; get offset to local __ptr {  }
addi $r672 $$locbase i88                ; get offset to local __ptr slice
move $$arg0 $r671                       ; [call: print_str_1]: pass argument 0
move $$arg1 $r672                       ; [call: print_str_1]: pass argument 1
fncall .6                               ; [call: print_str_1]: call function
 move $r673 $zero                        ; [call: print_str_1]: copy returned unit value
 movi $r673 i0                           ; [call: print_str_1]: copy returned unit value
ji  .126
.126
addi $r674 $$locbase i416               ; get offset to local __ptr {  }
addr $r675 data_NonConfigurable_2       ; get __const_global22's address in data section
addi $r676 $$locbase i184               ; get offset to local __ptr { ptr, u64 }
sw $$locbase $r675 i23                  ; store word
addi $r677 $r676 i8                     ; get offset to aggregate element
sw $$locbase $one i24                   ; store word
addi $r678 $$locbase i232               ; get offset to local __ptr slice
mcpi $r678 $r676 i16                    ; copy memory
addi $r679 $$locbase i376               ; get offset to local __ptr {  }
addi $r680 $$locbase i232               ; get offset to local __ptr slice
move $$arg0 $r679                       ; [call: print_str_1]: pass argument 0
move $$arg1 $r680                       ; [call: print_str_1]: pass argument 1
fncall .6                               ; [call: print_str_1]: call function
 move $r681 $zero                        ; [call: print_str_1]: copy returned unit value
 movi $r681 i0                           ; [call: print_str_1]: copy returned unit value
addr $r682 data_NonConfigurable_3       ; get std::debug::STDERR's address in data section
addi $r683 $$locbase i416               ; get offset to local __ptr u64
mcpi $r683 $r682 i8                     ; copy memory
addi $r684 $$locbase i416               ; get offset to local __ptr u64
lw $r685 $$locbase i52                  ; load word
movi $r686 i1001                        ; initialize constant into register
ecal $r686 $r685 $zero $zero            ; ecal id fd zero zero
 move $r687 $zero                        ; return unit value from ASM block without return register
 movi $r687 i0                           ; return unit value from ASM block without return register
addi $r688 $$locbase i400               ; get offset to local __ptr bool
sb $r688 $zero i0                       ; store byte
addi $r689 $$locbase i400               ; get offset to local __ptr bool
lb $r690 $r689 i0                       ; load byte
eq $r691 $r690 $zero
jnzi $r691 .132
ji  .133
.133
ret $zero                               ; [entry end: failing_error_signal_assert] return unit as zero
.132
addr $r692 data_NonConfigurable_20      ; get std::error_signals::FAILED_ASSERT_SIGNAL's address in data section
addi $r693 $$locbase i392               ; get offset to local __ptr u64
mcpi $r693 $r692 i8                     ; copy memory
addi $r694 $$locbase i392               ; get offset to local __ptr u64
lw $r695 $$locbase i49                  ; load word
rvrt $r695
DIFF------------------------------
.program:
.44                                     ; --- start of function: failing_error_signal_assert_eq ---
move $$locbase $sp                      ; [entry init: failing_error_signal_assert_eq]: set locals base register
cfei i216                               ; [entry init: failing_error_signal_assert_eq]: allocate: locals 216 byte(s), call args 0 slot(s)
.141
addr $r759 data_NonConfigurable_23      ; get __const_global23's address in data section
sw $$locbase $r759 i0                   ; store word
addi $r760 $$locbase i8                 ; get offset to aggregate element
movi $r761 i47                          ; initialize constant into register
sw $$locbase $r761 i1                   ; store word
addi $r762 $$locbase i16                ; get offset to local __ptr slice
mcpi $r762 $$locbase i16                ; copy memory
addi $r763 $$locbase i160               ; get offset to local __ptr {  }
addi $r764 $$locbase i168               ; get offset to local __ptr {  }
addi $r765 $$locbase i168               ; get offset to local __ptr {  }
addr $r766 data_NonConfigurable_24      ; get __const_global24's address in data section
addi $r767 $$locbase i32                ; get offset to local __ptr { ptr, u64 }
sw $$locbase $r766 i4                   ; store word
addi $r768 $r767 i8                     ; get offset to aggregate element
movi $r769 i72                          ; initialize constant into register
sw $$locbase $r769 i5                   ; store word
addi $r770 $$locbase i48                ; get offset to local __ptr slice
mcpi $r770 $r767 i16                    ; copy memory
addi $r771 $$locbase i160               ; get offset to local __ptr {  }
addi $r772 $$locbase i48                ; get offset to local __ptr slice
move $$arg0 $r771                       ; [call: print_str_1]: pass argument 0
move $$arg1 $r772                       ; [call: print_str_1]: pass argument 1
fncall .6                               ; [call: print_str_1]: call function
 move $r773 $zero                        ; [call: print_str_1]: copy returned unit value
 movi $r773 i0                           ; [call: print_str_1]: copy returned unit value
addi $r774 $$locbase i168               ; get offset to local __ptr {  }
addi $r775 $$locbase i16                ; get offset to local __ptr slice
move $$arg0 $r775                       ; [call: fmt_5]: pass argument 0
move $$arg1 $r774                       ; [call: fmt_5]: pass argument 1
fncall .12                              ; [call: fmt_5]: call function
 move $r776 $zero                        ; [call: fmt_5]: copy returned unit value
 movi $r776 i0                           ; [call: fmt_5]: copy returned unit value
addi $r777 $$locbase i168               ; get offset to local __ptr {  }
addr $r778 data_NonConfigurable_2       ; get __const_global25's address in data section
addi $r779 $$locbase i64                ; get offset to local __ptr { ptr, u64 }
sw $$locbase $r778 i8                   ; store word
addi $r780 $r779 i8                     ; get offset to aggregate element
sw $$locbase $one i9                    ; store word
addi $r781 $$locbase i80                ; get offset to local __ptr slice
mcpi $r781 $r779 i16                    ; copy memory
addi $r782 $$locbase i160               ; get offset to local __ptr {  }
addi $r783 $$locbase i80                ; get offset to local __ptr slice
move $$arg0 $r782                       ; [call: print_str_1]: pass argument 0
move $$arg1 $r783                       ; [call: print_str_1]: pass argument 1
fncall .6                               ; [call: print_str_1]: call function
 move $r784 $zero                        ; [call: print_str_1]: copy returned unit value
 movi $r784 i0                           ; [call: print_str_1]: copy returned unit value
addr $r785 data_NonConfigurable_3       ; get std::debug::STDERR's address in data section
addi $r786 $$locbase i168               ; get offset to local __ptr u64
mcpi $r786 $r785 i8                     ; copy memory
addi $r787 $$locbase i168               ; get offset to local __ptr u64
lw $r788 $$locbase i21                  ; load word
movi $r789 i1001                        ; initialize constant into register
ecal $r789 $r788 $zero $zero            ; ecal id fd zero zero
 move $r790 $zero                        ; return unit value from ASM block without return register
 movi $r790 i0                           ; return unit value from ASM block without return register
addr $r791 data_NonConfigurable_25      ; get __const_global26's address in data section
addi $r792 $$locbase i96                ; get offset to local __ptr { ptr, u64 }
sw $$locbase $r791 i12                  ; store word
addi $r793 $r792 i8                     ; get offset to aggregate element
movi $r794 i56                          ; initialize constant into register
sw $$locbase $r794 i13                  ; store word
addi $r795 $$locbase i112               ; get offset to local __ptr slice
mcpi $r795 $r792 i16                    ; copy memory
addi $r796 $$locbase i200               ; get offset to local __ptr slice
mcpi $r796 $r795 i16                    ; copy memory
addi $r797 $$locbase i200               ; get offset to local __ptr slice
addi $r798 $$locbase i144               ; get offset to local __ptr slice
move $$arg0 $r797                       ; [call: encode_allow_alias_23]: pass argument 0
move $$arg1 $r798                       ; [call: encode_allow_alias_23]: pass argument 1
fncall .18                              ; [call: encode_allow_alias_23]: call function
 move $r799 $zero                        ; [call: encode_allow_alias_23]: copy returned unit value
 movi $r799 i0                           ; [call: encode_allow_alias_23]: copy returned unit value
addi $r800 $$locbase i128               ; get offset to local __ptr slice
mcpi $r800 $r798 i16                    ; copy memory
load $r801 data_NonConfigurable_6       ; load constant from data section
lw $r802 $$locbase i16                  ; load slice pointer for logging data
lw $r803 $$locbase i17                  ; load slice size for logging data
logd $zero $r801 $r802 $r803            ; log slice
addi $r804 $$locbase i184               ; get offset to local __ptr u64
movi $r805 i1111                        ; initialize constant into register
sw $$locbase $r805 i23                  ; store word
addi $r806 $$locbase i192               ; get offset to local __ptr u64
movi $r807 i2222                        ; initialize constant into register
sw $$locbase $r807 i24                  ; store word
addi $r808 $$locbase i184               ; get offset to local __ptr u64
lw $r809 $$locbase i23                  ; load word
addi $r810 $$locbase i192               ; get offset to local __ptr u64
lw $r811 $$locbase i24                  ; load word
eq $r812 $r809 $r811
addi $r813 $$locbase i176               ; get offset to local __ptr bool
sb $r813 $r812 i0                       ; store byte
addi $r814 $$locbase i176               ; get offset to local __ptr bool
lb $r815 $r814 i0                       ; load byte
eq $r816 $r815 $zero
jnzi $r816 .142
ji  .143
.143
ret $zero                               ; [entry end: failing_error_signal_assert_eq] return unit as zero
.142
addi $r817 $$locbase i184               ; get offset to local __ptr u64
lw $r818 $$locbase i23                  ; load word
move $$arg0 $r818                       ; [call: log_29]: pass argument 0
fncall .26                              ; [call: log_29]: call function
 move $r819 $zero                        ; [call: log_29]: copy returned unit value
 movi $r819 i0                           ; [call: log_29]: copy returned unit value
addi $r820 $$locbase i192               ; get offset to local __ptr u64
lw $r821 $$locbase i24                  ; load word
move $$arg0 $r821                       ; [call: log_29]: pass argument 0
fncall .26                              ; [call: log_29]: call function
 move $r822 $zero                        ; [call: log_29]: copy returned unit value
 movi $r822 i0                           ; [call: log_29]: copy returned unit value
addr $r823 data_NonConfigurable_26      ; get std::error_signals::FAILED_ASSERT_EQ_SIGNAL's address in data section
addi $r824 $$locbase i160               ; get offset to local __ptr u64
mcpi $r824 $r823 i8                     ; copy memory
addi $r825 $$locbase i160               ; get offset to local __ptr u64
lw $r826 $$locbase i20                  ; load word
rvrt $r826
DIFF------------------------------
.program:
.46                                     ; --- start of function: failing_error_signal_assert_ne ---
move $$locbase $sp                      ; [entry init: failing_error_signal_assert_ne]: set locals base register
cfei i208                               ; [entry init: failing_error_signal_assert_ne]: allocate: locals 208 byte(s), call args 0 slot(s)
.144
addr $r828 data_NonConfigurable_27      ; get __const_global27's address in data section
sw $$locbase $r828 i0                   ; store word
addi $r829 $$locbase i8                 ; get offset to aggregate element
movi $r830 i47                          ; initialize constant into register
sw $$locbase $r830 i1                   ; store word
addi $r831 $$locbase i16                ; get offset to local __ptr slice
mcpi $r831 $$locbase i16                ; copy memory
addi $r832 $$locbase i160               ; get offset to local __ptr {  }
addi $r833 $$locbase i168               ; get offset to local __ptr {  }
addi $r834 $$locbase i168               ; get offset to local __ptr {  }
addr $r835 data_NonConfigurable_28      ; get __const_global28's address in data section
addi $r836 $$locbase i32                ; get offset to local __ptr { ptr, u64 }
sw $$locbase $r835 i4                   ; store word
addi $r837 $r836 i8                     ; get offset to aggregate element
movi $r838 i72                          ; initialize constant into register
sw $$locbase $r838 i5                   ; store word
addi $r839 $$locbase i48                ; get offset to local __ptr slice
mcpi $r839 $r836 i16                    ; copy memory
addi $r840 $$locbase i160               ; get offset to local __ptr {  }
addi $r841 $$locbase i48                ; get offset to local __ptr slice
move $$arg0 $r840                       ; [call: print_str_1]: pass argument 0
move $$arg1 $r841                       ; [call: print_str_1]: pass argument 1
fncall .6                               ; [call: print_str_1]: call function
 move $r842 $zero                        ; [call: print_str_1]: copy returned unit value
 movi $r842 i0                           ; [call: print_str_1]: copy returned unit value
addi $r843 $$locbase i168               ; get offset to local __ptr {  }
addi $r844 $$locbase i16                ; get offset to local __ptr slice
move $$arg0 $r844                       ; [call: fmt_5]: pass argument 0
move $$arg1 $r843                       ; [call: fmt_5]: pass argument 1
fncall .12                              ; [call: fmt_5]: call function
 move $r845 $zero                        ; [call: fmt_5]: copy returned unit value
 movi $r845 i0                           ; [call: fmt_5]: copy returned unit value
addi $r846 $$locbase i168               ; get offset to local __ptr {  }
addr $r847 data_NonConfigurable_2       ; get __const_global29's address in data section
addi $r848 $$locbase i64                ; get offset to local __ptr { ptr, u64 }
sw $$locbase $r847 i8                   ; store word
addi $r849 $r848 i8                     ; get offset to aggregate element
sw $$locbase $one i9                    ; store word
addi $r850 $$locbase i80                ; get offset to local __ptr slice
mcpi $r850 $r848 i16                    ; copy memory
addi $r851 $$locbase i160               ; get offset to local __ptr {  }
addi $r852 $$locbase i80                ; get offset to local __ptr slice
move $$arg0 $r851                       ; [call: print_str_1]: pass argument 0
move $$arg1 $r852                       ; [call: print_str_1]: pass argument 1
fncall .6                               ; [call: print_str_1]: call function
 move $r853 $zero                        ; [call: print_str_1]: copy returned unit value
 movi $r853 i0                           ; [call: print_str_1]: copy returned unit value
addr $r854 data_NonConfigurable_3       ; get std::debug::STDERR's address in data section
addi $r855 $$locbase i168               ; get offset to local __ptr u64
mcpi $r855 $r854 i8                     ; copy memory
addi $r856 $$locbase i168               ; get offset to local __ptr u64
lw $r857 $$locbase i21                  ; load word
movi $r858 i1001                        ; initialize constant into register
ecal $r858 $r857 $zero $zero            ; ecal id fd zero zero
 move $r859 $zero                        ; return unit value from ASM block without return register
 movi $r859 i0                           ; return unit value from ASM block without return register
addr $r860 data_NonConfigurable_25      ; get __const_global30's address in data section
addi $r861 $$locbase i96                ; get offset to local __ptr { ptr, u64 }
sw $$locbase $r860 i12                  ; store word
addi $r862 $r861 i8                     ; get offset to aggregate element
movi $r863 i56                          ; initialize constant into register
sw $$locbase $r863 i13                  ; store word
addi $r864 $$locbase i112               ; get offset to local __ptr slice
mcpi $r864 $r861 i16                    ; copy memory
addi $r865 $$locbase i192               ; get offset to local __ptr slice
mcpi $r865 $r864 i16                    ; copy memory
addi $r866 $$locbase i192               ; get offset to local __ptr slice
addi $r867 $$locbase i144               ; get offset to local __ptr slice
move $$arg0 $r866                       ; [call: encode_allow_alias_23]: pass argument 0
move $$arg1 $r867                       ; [call: encode_allow_alias_23]: pass argument 1
fncall .18                              ; [call: encode_allow_alias_23]: call function
 move $r868 $zero                        ; [call: encode_allow_alias_23]: copy returned unit value
 movi $r868 i0                           ; [call: encode_allow_alias_23]: copy returned unit value
addi $r869 $$locbase i128               ; get offset to local __ptr slice
mcpi $r869 $r867 i16                    ; copy memory
load $r870 data_NonConfigurable_6       ; load constant from data section
lw $r871 $$locbase i16                  ; load slice pointer for logging data
lw $r872 $$locbase i17                  ; load slice size for logging data
logd $zero $r870 $r871 $r872            ; log slice
addi $r873 $$locbase i176               ; get offset to local __ptr u64
movi $r874 i3333                        ; initialize constant into register
sw $$locbase $r874 i22                  ; store word
addi $r875 $$locbase i184               ; get offset to local __ptr u64
movi $r876 i3333                        ; initialize constant into register
sw $$locbase $r876 i23                  ; store word
addi $r877 $$locbase i176               ; get offset to local __ptr u64
lw $r878 $$locbase i22                  ; load word
addi $r879 $$locbase i184               ; get offset to local __ptr u64
lw $r880 $$locbase i23                  ; load word
eq $r881 $r878 $r880
jnzi $r881 .145
ji  .146
.146
ret $zero                               ; [entry end: failing_error_signal_assert_ne] return unit as zero
.145
addi $r882 $$locbase i176               ; get offset to local __ptr u64
lw $r883 $$locbase i22                  ; load word
move $$arg0 $r883                       ; [call: log_29]: pass argument 0
fncall .26                              ; [call: log_29]: call function
 move $r884 $zero                        ; [call: log_29]: copy returned unit value
 movi $r884 i0                           ; [call: log_29]: copy returned unit value
addi $r885 $$locbase i184               ; get offset to local __ptr u64
lw $r886 $$locbase i23                  ; load word
move $$arg0 $r886                       ; [call: log_29]: pass argument 0
fncall .26                              ; [call: log_29]: call function
 move $r887 $zero                        ; [call: log_29]: copy returned unit value
 movi $r887 i0                           ; [call: log_29]: copy returned unit value
addr $r888 data_NonConfigurable_29      ; get std::error_signals::FAILED_ASSERT_NE_SIGNAL's address in data section
addi $r889 $$locbase i160               ; get offset to local __ptr u64
mcpi $r889 $r888 i8                     ; copy memory
addi $r890 $$locbase i160               ; get offset to local __ptr u64
lw $r891 $$locbase i20                  ; load word
rvrt $r891
DIFF------------------------------
.program:
.48                                     ; --- start of function: failing_error_signal_require_str_error ---
move $$locbase $sp                      ; [entry init: failing_error_signal_require_str_error]: set locals base register
cfei i112                               ; [entry init: failing_error_signal_require_str_error]: allocate: locals 112 byte(s), call args 0 slot(s)
.147
addr $r893 data_NonConfigurable_30      ; get __const_global31's address in data section
sw $$locbase $r893 i0                   ; store word
addi $r894 $$locbase i8                 ; get offset to aggregate element
movi $r895 i45                          ; initialize constant into register
sw $$locbase $r895 i1                   ; store word
addi $r896 $$locbase i16                ; get offset to local __ptr slice
mcpi $r896 $$locbase i16                ; copy memory
addi $r897 $$locbase i72                ; get offset to local __ptr bool
sb $r897 $zero i0                       ; store byte
addi $r898 $$locbase i80                ; get offset to local __ptr slice
mcpi $r898 $r896 i16                    ; copy memory
addi $r899 $$locbase i72                ; get offset to local __ptr bool
lb $r900 $r899 i0                       ; load byte
eq $r901 $r900 $zero
jnzi $r901 .148
ji  .149
.149
ret $zero                               ; [entry end: failing_error_signal_require_str_error] return unit as zero
.148
addi $r902 $$locbase i80                ; get offset to local __ptr slice
addi $r903 $$locbase i96                ; get offset to local __ptr slice
mcpi $r903 $r902 i16                    ; copy memory
addi $r904 $$locbase i96                ; get offset to local __ptr slice
addi $r905 $$locbase i48                ; get offset to local __ptr slice
move $$arg0 $r904                       ; [call: encode_allow_alias_23]: pass argument 0
move $$arg1 $r905                       ; [call: encode_allow_alias_23]: pass argument 1
fncall .18                              ; [call: encode_allow_alias_23]: call function
 move $r906 $zero                        ; [call: encode_allow_alias_23]: copy returned unit value
 movi $r906 i0                           ; [call: encode_allow_alias_23]: copy returned unit value
addi $r907 $$locbase i32                ; get offset to local __ptr slice
mcpi $r907 $r905 i16                    ; copy memory
load $r908 data_NonConfigurable_6       ; load constant from data section
lw $r909 $$locbase i4                   ; load slice pointer for logging data
lw $r910 $$locbase i5                   ; load slice size for logging data
logd $zero $r908 $r909 $r910            ; log slice
addr $r911 data_NonConfigurable_31      ; get std::error_signals::FAILED_REQUIRE_SIGNAL's address in data section
addi $r912 $$locbase i64                ; get offset to local __ptr u64
mcpi $r912 $r911 i8                     ; copy memory
addi $r913 $$locbase i64                ; get offset to local __ptr u64
lw $r914 $$locbase i8                   ; load word
rvrt $r914
DIFF------------------------------
.program:
.50                                     ; --- start of function: failing_error_signal_require_enum_error ---
move $$locbase $sp                      ; [entry init: failing_error_signal_require_enum_error]: set locals base register
cfei i120                               ; [entry init: failing_error_signal_require_enum_error]: allocate: locals 120 byte(s), call args 0 slot(s)
.150
sw $$locbase $one i0                    ; store word
addi $r916 $$locbase i23                ; get offset to aggregate element
sb $r916 $one i0                        ; store byte
addi $r917 $$locbase i64                ; get offset to local __ptr bool
sb $r917 $zero i0                       ; store byte
addi $r918 $$locbase i72                ; get offset to local __ptr { u64, ( () | bool | slice | slice ) }
mcpi $r918 $$locbase i24                ; copy memory
addi $r919 $$locbase i64                ; get offset to local __ptr bool
lb $r920 $r919 i0                       ; load byte
eq $r921 $r920 $zero
jnzi $r921 .151
ji  .152
.152
ret $zero                               ; [entry end: failing_error_signal_require_enum_error] return unit as zero
.151
addi $r922 $$locbase i72                ; get offset to local __ptr { u64, ( () | bool | slice | slice ) }
addi $r923 $$locbase i96                ; get offset to local __ptr { u64, ( () | bool | slice | slice ) }
mcpi $r923 $r922 i24                    ; copy memory
addi $r924 $$locbase i96                ; get offset to local __ptr { u64, ( () | bool | slice | slice ) }
addi $r925 $$locbase i40                ; get offset to local __ptr slice
move $$arg0 $r924                       ; [call: encode_allow_alias_50]: pass argument 0
move $$arg1 $r925                       ; [call: encode_allow_alias_50]: pass argument 1
fncall .52                              ; [call: encode_allow_alias_50]: call function
 move $r926 $zero                        ; [call: encode_allow_alias_50]: copy returned unit value
 movi $r926 i0                           ; [call: encode_allow_alias_50]: copy returned unit value
addi $r927 $$locbase i24                ; get offset to local __ptr slice
mcpi $r927 $r925 i16                    ; copy memory
load $r928 data_NonConfigurable_32      ; load constant from data section
lw $r929 $$locbase i3                   ; load slice pointer for logging data
lw $r930 $$locbase i4                   ; load slice size for logging data
logd $zero $r928 $r929 $r930            ; log slice
addr $r931 data_NonConfigurable_31      ; get std::error_signals::FAILED_REQUIRE_SIGNAL's address in data section
addi $r932 $$locbase i56                ; get offset to local __ptr u64
mcpi $r932 $r931 i8                     ; copy memory
addi $r933 $$locbase i56                ; get offset to local __ptr u64
lw $r934 $$locbase i7                   ; load word
rvrt $r934
DIFF------------------------------
.program:
.54                                     ; --- start of function: failing_panic_no_arg ---
move $$locbase $sp                      ; [entry init: failing_panic_no_arg]: set locals base register
cfei i32                                ; [entry init: failing_panic_no_arg]: allocate: locals 32 byte(s), call args 0 slot(s)
.178
addi $r1132 $$locbase i16               ; get offset to local __ptr slice
move $$arg0 $$locbase                   ; [call: encode_allow_alias_59]: pass argument 0
move $$arg1 $r1132                      ; [call: encode_allow_alias_59]: pass argument 1
fncall .56                              ; [call: encode_allow_alias_59]: call function
 move $r1133 $zero                       ; [call: encode_allow_alias_59]: copy returned unit value
 movi $r1133 i0                          ; [call: encode_allow_alias_59]: copy returned unit value
mcpi $$locbase $r1132 i16               ; copy memory
load $r1134 data_NonConfigurable_34     ; load constant from data section
lw $r1135 $$locbase i0                  ; load slice pointer for logging data
lw $r1136 $$locbase i1                  ; load slice size for logging data
logd $zero $r1134 $r1135 $r1136         ; log slice
load $r1137 data_NonConfigurable_35     ; load constant from data section
rvrt $r1137
DIFF------------------------------
.program:
.58                                     ; --- start of function: failing_panic_unit_arg ---
move $$locbase $sp                      ; [entry init: failing_panic_unit_arg]: set locals base register
cfei i32                                ; [entry init: failing_panic_unit_arg]: allocate: locals 32 byte(s), call args 0 slot(s)
.183
addi $r1161 $$locbase i16               ; get offset to local __ptr slice
move $$arg0 $$locbase                   ; [call: encode_allow_alias_59]: pass argument 0
move $$arg1 $r1161                      ; [call: encode_allow_alias_59]: pass argument 1
fncall .56                              ; [call: encode_allow_alias_59]: call function
 move $r1162 $zero                       ; [call: encode_allow_alias_59]: copy returned unit value
 movi $r1162 i0                          ; [call: encode_allow_alias_59]: copy returned unit value
mcpi $$locbase $r1161 i16               ; copy memory
load $r1163 data_NonConfigurable_34     ; load constant from data section
lw $r1164 $$locbase i0                  ; load slice pointer for logging data
lw $r1165 $$locbase i1                  ; load slice size for logging data
logd $zero $r1163 $r1164 $r1165         ; log slice
load $r1166 data_NonConfigurable_36     ; load constant from data section
rvrt $r1166
DIFF------------------------------
.program:
.60                                     ; --- start of function: failing_panic_const_eval_str_arg ---
move $$locbase $sp                      ; [entry init: failing_panic_const_eval_str_arg]: set locals base register
cfei i0                                 ; [entry init: failing_panic_const_eval_str_arg]: allocate: locals 0 byte(s), call args 0 slot(s)
.184
load $r1168 data_NonConfigurable_37     ; load constant from data section
rvrt $r1168
DIFF------------------------------
.program:
.62                                     ; --- start of function: failing_panic_const_eval_empty_str_arg ---
move $$locbase $sp                      ; [entry init: failing_panic_const_eval_empty_str_arg]: set locals base register
cfei i0                                 ; [entry init: failing_panic_const_eval_empty_str_arg]: allocate: locals 0 byte(s), call args 0 slot(s)
.185
load $r1170 data_NonConfigurable_38     ; load constant from data section
rvrt $r1170
DIFF------------------------------
.program:
.64                                     ; --- start of function: failing_panic_const_eval_whitespace_str_arg ---
move $$locbase $sp                      ; [entry init: failing_panic_const_eval_whitespace_str_arg]: set locals base register
cfei i0                                 ; [entry init: failing_panic_const_eval_whitespace_str_arg]: allocate: locals 0 byte(s), call args 0 slot(s)
.186
load $r1172 data_NonConfigurable_39     ; load constant from data section
rvrt $r1172
DIFF------------------------------
.program:
.66                                     ; --- start of function: failing_panic_non_const_eval_str_arg ---
move $$locbase $sp                      ; [entry init: failing_panic_non_const_eval_str_arg]: set locals base register
cfei i112                               ; [entry init: failing_panic_non_const_eval_str_arg]: allocate: locals 112 byte(s), call args 0 slot(s)
.187
addr $r1174 data_NonConfigurable_40     ; get __const_global32's address in data section
sw $$locbase $r1174 i0                  ; store word
addi $r1175 $$locbase i8                ; get offset to aggregate element
movi $r1176 i52                         ; initialize constant into register
sw $$locbase $r1176 i1                  ; store word
addi $r1177 $$locbase i16               ; get offset to local __ptr slice
mcpi $r1177 $$locbase i16               ; copy memory
addi $r1178 $$locbase i96               ; get offset to local __ptr slice
mcpi $r1178 $r1177 i16                  ; copy memory
addi $r1179 $$locbase i96               ; get offset to local __ptr slice
addi $r1180 $$locbase i64               ; get offset to local __ptr slice
move $$arg0 $r1179                      ; [call: encode_allow_alias_23]: pass argument 0
move $$arg1 $r1180                      ; [call: encode_allow_alias_23]: pass argument 1
fncall .18                              ; [call: encode_allow_alias_23]: call function
 move $r1181 $zero                       ; [call: encode_allow_alias_23]: copy returned unit value
 movi $r1181 i0                          ; [call: encode_allow_alias_23]: copy returned unit value
addi $r1182 $$locbase i32               ; get offset to local __ptr slice
mcpi $r1182 $r1180 i16                  ; copy memory
load $r1183 data_NonConfigurable_6      ; load constant from data section
lw $r1184 $$locbase i4                  ; load slice pointer for logging data
lw $r1185 $$locbase i5                  ; load slice size for logging data
logd $zero $r1183 $r1184 $r1185         ; log slice
load $r1186 data_NonConfigurable_41     ; load constant from data section
 and $r1187 $one $r1186
 andi $r1187 $r1186 i1
load $r1188 data_NonConfigurable_42     ; load constant from data section
or $r1189 $r1188 $r1187
rvrt $r1189
DIFF------------------------------
.program:
.68                                     ; --- start of function: failing_panic_non_const_eval_str_empty_arg ---
move $$locbase $sp                      ; [entry init: failing_panic_non_const_eval_str_empty_arg]: set locals base register
cfei i112                               ; [entry init: failing_panic_non_const_eval_str_empty_arg]: allocate: locals 112 byte(s), call args 0 slot(s)
.188
addr $r1191 data_NonConfigurable_43     ; get __const_global33's address in data section
sw $$locbase $r1191 i0                  ; store word
addi $r1192 $$locbase i8                ; get offset to aggregate element
sw $$locbase $zero i1                   ; store word
addi $r1193 $$locbase i16               ; get offset to local __ptr slice
mcpi $r1193 $$locbase i16               ; copy memory
addi $r1194 $$locbase i96               ; get offset to local __ptr slice
mcpi $r1194 $r1193 i16                  ; copy memory
addi $r1195 $$locbase i96               ; get offset to local __ptr slice
addi $r1196 $$locbase i64               ; get offset to local __ptr slice
move $$arg0 $r1195                      ; [call: encode_allow_alias_23]: pass argument 0
move $$arg1 $r1196                      ; [call: encode_allow_alias_23]: pass argument 1
fncall .18                              ; [call: encode_allow_alias_23]: call function
 move $r1197 $zero                       ; [call: encode_allow_alias_23]: copy returned unit value
 movi $r1197 i0                          ; [call: encode_allow_alias_23]: copy returned unit value
addi $r1198 $$locbase i32               ; get offset to local __ptr slice
mcpi $r1198 $r1196 i16                  ; copy memory
load $r1199 data_NonConfigurable_6      ; load constant from data section
lw $r1200 $$locbase i4                  ; load slice pointer for logging data
lw $r1201 $$locbase i5                  ; load slice size for logging data
logd $zero $r1199 $r1200 $r1201         ; log slice
movi $r1202 i2                          ; initialize constant into register
load $r1203 data_NonConfigurable_41     ; load constant from data section
 and $r1204 $r1202 $r1203
 andi $r1204 $r1203 i2
load $r1205 data_NonConfigurable_42     ; load constant from data section
or $r1206 $r1205 $r1204
rvrt $r1206
DIFF------------------------------
.program:
.70                                     ; --- start of function: failing_panic_non_const_eval_str_whitespace_arg ---
move $$locbase $sp                      ; [entry init: failing_panic_non_const_eval_str_whitespace_arg]: set locals base register
cfei i112                               ; [entry init: failing_panic_non_const_eval_str_whitespace_arg]: allocate: locals 112 byte(s), call args 0 slot(s)
.189
addr $r1208 data_NonConfigurable_44     ; get __const_global34's address in data section
sw $$locbase $r1208 i0                  ; store word
addi $r1209 $$locbase i8                ; get offset to aggregate element
movi $r1210 i4                          ; initialize constant into register
sw $$locbase $r1210 i1                  ; store word
addi $r1211 $$locbase i16               ; get offset to local __ptr slice
mcpi $r1211 $$locbase i16               ; copy memory
addi $r1212 $$locbase i96               ; get offset to local __ptr slice
mcpi $r1212 $r1211 i16                  ; copy memory
addi $r1213 $$locbase i96               ; get offset to local __ptr slice
addi $r1214 $$locbase i64               ; get offset to local __ptr slice
move $$arg0 $r1213                      ; [call: encode_allow_alias_23]: pass argument 0
move $$arg1 $r1214                      ; [call: encode_allow_alias_23]: pass argument 1
fncall .18                              ; [call: encode_allow_alias_23]: call function
 move $r1215 $zero                       ; [call: encode_allow_alias_23]: copy returned unit value
 movi $r1215 i0                          ; [call: encode_allow_alias_23]: copy returned unit value
addi $r1216 $$locbase i32               ; get offset to local __ptr slice
mcpi $r1216 $r1214 i16                  ; copy memory
load $r1217 data_NonConfigurable_6      ; load constant from data section
lw $r1218 $$locbase i4                  ; load slice pointer for logging data
lw $r1219 $$locbase i5                  ; load slice size for logging data
logd $zero $r1217 $r1218 $r1219         ; log slice
movi $r1220 i3                          ; initialize constant into register
load $r1221 data_NonConfigurable_41     ; load constant from data section
 and $r1222 $r1220 $r1221
 andi $r1222 $r1221 i3
load $r1223 data_NonConfigurable_42     ; load constant from data section
or $r1224 $r1223 $r1222
rvrt $r1224
DIFF------------------------------
.program:
.72                                     ; --- start of function: failing_panic_error_enum_arg ---
move $$locbase $sp                      ; [entry init: failing_panic_error_enum_arg]: set locals base register
cfei i56                                ; [entry init: failing_panic_error_enum_arg]: allocate: locals 56 byte(s), call args 0 slot(s)
.190
sw $$locbase $one i0                    ; store word
addi $r1226 $$locbase i23               ; get offset to aggregate element
sb $r1226 $one i0                       ; store byte
addi $r1227 $$locbase i40               ; get offset to local __ptr slice
move $$arg0 $$locbase                   ; [call: encode_allow_alias_50]: pass argument 0
move $$arg1 $r1227                      ; [call: encode_allow_alias_50]: pass argument 1
fncall .52                              ; [call: encode_allow_alias_50]: call function
 move $r1228 $zero                       ; [call: encode_allow_alias_50]: copy returned unit value
 movi $r1228 i0                          ; [call: encode_allow_alias_50]: copy returned unit value
addi $r1229 $$locbase i24               ; get offset to local __ptr slice
mcpi $r1229 $r1227 i16                  ; copy memory
load $r1230 data_NonConfigurable_32     ; load constant from data section
lw $r1231 $$locbase i3                  ; load slice pointer for logging data
lw $r1232 $$locbase i4                  ; load slice size for logging data
logd $zero $r1230 $r1231 $r1232         ; log slice
load $r1233 data_NonConfigurable_45     ; load constant from data section
rvrt $r1233
DIFF------------------------------
.program:
.74                                     ; --- start of function: failing_panic_error_enum_arg_with_empty_msg ---
move $$locbase $sp                      ; [entry init: failing_panic_error_enum_arg_with_empty_msg]: set locals base register
cfei i88                                ; [entry init: failing_panic_error_enum_arg_with_empty_msg]: allocate: locals 88 byte(s), call args 0 slot(s)
.191
movi $r1235 i2                          ; initialize constant into register
sw $$locbase $r1235 i0                  ; store word
addr $r1236 data_NonConfigurable_46     ; get __const_global35's address in data section
addi $r1237 $$locbase i24               ; get offset to local __ptr { ptr, u64 }
sw $$locbase $r1236 i3                  ; store word
addi $r1238 $r1237 i8                   ; get offset to aggregate element
movi $r1239 i45                         ; initialize constant into register
sw $$locbase $r1239 i4                  ; store word
addi $r1240 $$locbase i40               ; get offset to local __ptr slice
mcpi $r1240 $r1237 i16                  ; copy memory
addi $r1241 $$locbase i8                ; get offset to aggregate element
mcpi $r1241 $r1240 i16                  ; copy memory
addi $r1242 $$locbase i72               ; get offset to local __ptr slice
move $$arg0 $$locbase                   ; [call: encode_allow_alias_50]: pass argument 0
move $$arg1 $r1242                      ; [call: encode_allow_alias_50]: pass argument 1
fncall .52                              ; [call: encode_allow_alias_50]: call function
 move $r1243 $zero                       ; [call: encode_allow_alias_50]: copy returned unit value
 movi $r1243 i0                          ; [call: encode_allow_alias_50]: copy returned unit value
addi $r1244 $$locbase i56               ; get offset to local __ptr slice
mcpi $r1244 $r1242 i16                  ; copy memory
load $r1245 data_NonConfigurable_32     ; load constant from data section
lw $r1246 $$locbase i7                  ; load slice pointer for logging data
lw $r1247 $$locbase i8                  ; load slice size for logging data
logd $zero $r1245 $r1246 $r1247         ; log slice
load $r1248 data_NonConfigurable_47     ; load constant from data section
rvrt $r1248
DIFF------------------------------
.program:
.76                                     ; --- start of function: failing_panic_error_enum_arg_with_whitespace_msg ---
move $$locbase $sp                      ; [entry init: failing_panic_error_enum_arg_with_whitespace_msg]: set locals base register
cfei i88                                ; [entry init: failing_panic_error_enum_arg_with_whitespace_msg]: allocate: locals 88 byte(s), call args 0 slot(s)
.192
movi $r1250 i3                          ; initialize constant into register
sw $$locbase $r1250 i0                  ; store word
addr $r1251 data_NonConfigurable_48     ; get __const_global36's address in data section
addi $r1252 $$locbase i24               ; get offset to local __ptr { ptr, u64 }
sw $$locbase $r1251 i3                  ; store word
addi $r1253 $r1252 i8                   ; get offset to aggregate element
movi $r1254 i49                         ; initialize constant into register
sw $$locbase $r1254 i4                  ; store word
addi $r1255 $$locbase i40               ; get offset to local __ptr slice
mcpi $r1255 $r1252 i16                  ; copy memory
addi $r1256 $$locbase i8                ; get offset to aggregate element
mcpi $r1256 $r1255 i16                  ; copy memory
addi $r1257 $$locbase i72               ; get offset to local __ptr slice
move $$arg0 $$locbase                   ; [call: encode_allow_alias_50]: pass argument 0
move $$arg1 $r1257                      ; [call: encode_allow_alias_50]: pass argument 1
fncall .52                              ; [call: encode_allow_alias_50]: call function
 move $r1258 $zero                       ; [call: encode_allow_alias_50]: copy returned unit value
 movi $r1258 i0                          ; [call: encode_allow_alias_50]: copy returned unit value
addi $r1259 $$locbase i56               ; get offset to local __ptr slice
mcpi $r1259 $r1257 i16                  ; copy memory
load $r1260 data_NonConfigurable_32     ; load constant from data section
lw $r1261 $$locbase i7                  ; load slice pointer for logging data
lw $r1262 $$locbase i8                  ; load slice size for logging data
logd $zero $r1260 $r1261 $r1262         ; log slice
load $r1263 data_NonConfigurable_49     ; load constant from data section
rvrt $r1263
DIFF------------------------------
.program:
.2                                      ; --- start of function: main_0 ---
pusha .2                                ; [fn init: main_0]: push all used registers to stack
move $$locbase $sp                      ; [fn init: main_0]: set locals base register
cfei i0                                 ; [fn init: main_0]: allocate: locals 0 byte(s), call args 0 slot(s)
.79
ji  .3
.3
cfsi i0                                 ; [fn end: main_0] free: locals 0 byte(s), call args 0 slot(s)
popa .2                                 ; [fn end: main_0] restore all used registers
jal $zero $$reta i0                     ; [fn end: main_0] return from call
DIFF------------------------------
.program:
.6                                      ; --- start of function: print_str_1 ---
pusha .6                                ; [fn init: print_str_1]: push all used registers to stack
move $$locbase $sp                      ; [fn init: print_str_1]: set locals base register
cfei i104                               ; [fn init: print_str_1]: allocate: locals 104 byte(s), call args 0 slot(s)
move $r83 $$arg0                        ; [fn init: print_str_1]: copy argument 0 (self)
move $r84 $$arg1                        ; [fn init: print_str_1]: copy argument 1 (s)
move $r85 $$reta                        ; [fn init: print_str_1]: save return address
.81
addi $r86 $$locbase i72                 ; get offset to local __ptr slice
 mcpi $r86 $r84 i16                      ; copy memory
 mcpi $r86 $$arg1 i16                    ; copy memory
addr $r87 data_NonConfigurable_3        ; get std::debug::STDERR's address in data section
lw $r88 $r87 i0                         ; load word
addi $r89 $$locbase i88                 ; get offset to local __ptr slice
mcpi $r89 $r84 i16                      ; copy memory
addi $r90 $$locbase i88                 ; get offset to local __ptr slice
move $r91 $r90                          ; return value from ASM block with return register s
 mcpi $$locbase $r91 i16                 ; copy memory
 mcpi $$locbase $r90 i16                 ; copy memory
addi $r92 $$locbase i32                 ; get offset to local __ptr { ptr, u64 }
mcpi $r92 $$locbase i16                 ; copy memory
addi $r93 $$locbase i48                 ; get offset to local __ptr { ptr, u64 }
mcpi $r93 $$locbase i16                 ; copy memory
addi $r94 $$locbase i48                 ; get offset to local __ptr { ptr, u64 }
addi $r95 $$locbase i64                 ; get offset to local __ptr ptr
mcpi $r95 $r94 i8                       ; copy memory
addi $r96 $$locbase i64                 ; get offset to local __ptr ptr
lw $r97 $$locbase i8                    ; load word
addi $r98 $$locbase i72                 ; get offset to local __ptr slice
addi $r99 $$locbase i16                 ; get offset to local __ptr slice
mcpi $r99 $r98 i16                      ; copy memory
move $$arg0 $r98                        ; [call: len_4]: pass argument 0
fncall .10                              ; [call: len_4]: call function
move $r100 $$retv                       ; [call: len_4]: copy returned value
move $$arg0 $r88                        ; [call: syscall_write_2]: pass argument 0
move $$arg1 $r97                        ; [call: syscall_write_2]: pass argument 1
 move $$arg2 $r100                       ; [call: syscall_write_2]: pass argument 2
 move $$arg2 $$retv                      ; [call: syscall_write_2]: pass argument 2
fncall .8                               ; [call: syscall_write_2]: call function
 move $r101 $zero                        ; [call: syscall_write_2]: copy returned unit value
 movi $r101 i0                           ; [call: syscall_write_2]: copy returned unit value
ji  .7
.7
cfsi i104                               ; [fn end: print_str_1] free: locals 104 byte(s), call args 0 slot(s)
move $$reta $r85                        ; [fn end: print_str_1] restore return address
popa .6                                 ; [fn end: print_str_1] restore all used registers
jal $zero $$reta i0                     ; [fn end: print_str_1] return from call
DIFF------------------------------
.program:
.8                                      ; --- start of function: syscall_write_2 ---
pusha .8                                ; [fn init: syscall_write_2]: push all used registers to stack
move $$locbase $sp                      ; [fn init: syscall_write_2]: set locals base register
cfei i24                                ; [fn init: syscall_write_2]: allocate: locals 24 byte(s), call args 0 slot(s)
.82
addi $r103 $$locbase i16                ; get offset to local __ptr u64
sw $$locbase $$arg0 i2                  ; store word
sw $$locbase $$arg1 i0                  ; store word
addi $r104 $$locbase i8                 ; get offset to local __ptr u64
sw $$locbase $$arg2 i1                  ; store word
addi $r105 $$locbase i16                ; get offset to local __ptr u64
lw $r106 $$locbase i2                   ; load word
lw $r107 $$locbase i0                   ; load word
addi $r108 $$locbase i8                 ; get offset to local __ptr u64
lw $r109 $$locbase i1                   ; load word
movi $r110 i1000                        ; initialize constant into register
ecal $r110 $r106 $r107 $r109            ; ecal id fd buf count
 move $r111 $zero                        ; return unit value from ASM block without return register
 movi $r111 i0                           ; return unit value from ASM block without return register
ji  .9
.9
cfsi i24                                ; [fn end: syscall_write_2] free: locals 24 byte(s), call args 0 slot(s)
popa .8                                 ; [fn end: syscall_write_2] restore all used registers
jal $zero $$reta i0                     ; [fn end: syscall_write_2] return from call
DIFF------------------------------
.program:
.10                                     ; --- start of function: len_4 ---
pusha .10                               ; [fn init: len_4]: push all used registers to stack
move $$locbase $sp                      ; [fn init: len_4]: set locals base register
cfei i56                                ; [fn init: len_4]: allocate: locals 56 byte(s), call args 0 slot(s)
.83
addi $r113 $$locbase i40                ; get offset to local __ptr slice
mcpi $r113 $$arg0 i16                   ; copy memory
addi $r114 $$locbase i40                ; get offset to local __ptr slice
move $r115 $r114                        ; return value from ASM block with return register s
 mcpi $$locbase $r115 i16                ; copy memory
 mcpi $$locbase $r114 i16                ; copy memory
addi $r116 $$locbase i16                ; get offset to local __ptr { ptr, u64 }
mcpi $r116 $$locbase i16                ; copy memory
addi $r117 $$locbase i32                ; get offset to local __ptr u64
addi $r118 $$locbase i8                 ; get offset to aggregate element
mcpi $r117 $r118 i8                     ; copy memory
lw $r119 $$locbase i1                   ; load word
move $$retv $r119                       ; [fn end: len_4] set return value
ji  .11
.11
cfsi i56                                ; [fn end: len_4] free: locals 56 byte(s), call args 0 slot(s)
popa .10                                ; [fn end: len_4] restore all used registers
jal $zero $$reta i0                     ; [fn end: len_4] return from call
DIFF------------------------------
.program:
.12                                     ; --- start of function: fmt_5 ---
pusha .12                               ; [fn init: fmt_5]: push all used registers to stack
move $$locbase $sp                      ; [fn init: fmt_5]: set locals base register
cfei i8                                 ; [fn init: fmt_5]: allocate: locals 8 byte(s), call args 0 slot(s)
move $r120 $$arg0                       ; [fn init: fmt_5]: copy argument 0 (self)
move $r121 $$arg1                       ; [fn init: fmt_5]: copy argument 1 (f)
move $r122 $$reta                       ; [fn init: fmt_5]: save return address
.84
 sw $$locbase $r121 i0                   ; store word
 sw $$locbase $$arg1 i0                  ; store word
lw $r123 $$locbase i0                   ; load word
move $$arg0 $$locbase                   ; [call: print_string_quotes_6]: pass argument 0
fncall .14                              ; [call: print_string_quotes_6]: call function
 move $r124 $zero                        ; [call: print_string_quotes_6]: copy returned unit value
 movi $r124 i0                           ; [call: print_string_quotes_6]: copy returned unit value
lw $r125 $$locbase i0                   ; load word
move $$arg0 $$locbase                   ; [call: print_str_1]: pass argument 0
move $$arg1 $r120                       ; [call: print_str_1]: pass argument 1
fncall .6                               ; [call: print_str_1]: call function
 move $r126 $zero                        ; [call: print_str_1]: copy returned unit value
 movi $r126 i0                           ; [call: print_str_1]: copy returned unit value
lw $r127 $$locbase i0                   ; load word
move $$arg0 $$locbase                   ; [call: print_string_quotes_6]: pass argument 0
fncall .14                              ; [call: print_string_quotes_6]: call function
 move $r128 $zero                        ; [call: print_string_quotes_6]: copy returned unit value
 movi $r128 i0                           ; [call: print_string_quotes_6]: copy returned unit value
ji  .13
.13
cfsi i8                                 ; [fn end: fmt_5] free: locals 8 byte(s), call args 0 slot(s)
move $$reta $r122                       ; [fn end: fmt_5] restore return address
popa .12                                ; [fn end: fmt_5] restore all used registers
jal $zero $$reta i0                     ; [fn end: fmt_5] return from call
DIFF------------------------------
.program:
.14                                     ; --- start of function: print_string_quotes_6 ---
pusha .14                               ; [fn init: print_string_quotes_6]: push all used registers to stack
move $$locbase $sp                      ; [fn init: print_string_quotes_6]: set locals base register
cfei i16                                ; [fn init: print_string_quotes_6]: allocate: locals 16 byte(s), call args 0 slot(s)
move $r129 $$arg0                       ; [fn init: print_string_quotes_6]: copy argument 0 (self)
move $r130 $$reta                       ; [fn init: print_string_quotes_6]: save return address
.85
movi $r131 i1                           ; get array element size
 mul $r132 $zero $r131                   ; get offset to array element
 add $r132 $$locbase $r132               ; add array element offset to array base
 movi $r132 i0                           ; get offset to array element
 move $r132 $$locbase                    ; add array element offset to array base
movi $r133 i34                          ; initialize constant into register
 sb $r132 $r133 i0                       ; store byte
 sb $$locbase $r133 i0                   ; store byte
addi $r134 $$locbase i8                 ; get offset to local __ptr [u8; 1]
mcpi $r134 $$locbase i1                 ; copy memory
addr $r135 data_NonConfigurable_3       ; get std::debug::STDERR's address in data section
lw $r136 $r135 i0                       ; load word
addi $r137 $$locbase i8                 ; get offset to local __ptr [u8; 1]
move $$arg0 $r136                       ; [call: syscall_write_2]: pass argument 0
move $$arg1 $r137                       ; [call: syscall_write_2]: pass argument 1
 move $$arg2 $one                        ; [call: syscall_write_2]: pass argument 2
 movi $$arg2 i1                          ; [call: syscall_write_2]: pass argument 2
fncall .8                               ; [call: syscall_write_2]: call function
 move $r138 $zero                        ; [call: syscall_write_2]: copy returned unit value
 movi $r138 i0                           ; [call: syscall_write_2]: copy returned unit value
ji  .15
.15
cfsi i16                                ; [fn end: print_string_quotes_6] free: locals 16 byte(s), call args 0 slot(s)
move $$reta $r130                       ; [fn end: print_string_quotes_6] restore return address
popa .14                                ; [fn end: print_string_quotes_6] restore all used registers
jal $zero $$reta i0                     ; [fn end: print_string_quotes_6] return from call
DIFF------------------------------
.program:
.16                                     ; --- start of function: fmt_9 ---
pusha .16                               ; [fn init: fmt_9]: push all used registers to stack
move $$locbase $sp                      ; [fn init: fmt_9]: set locals base register
cfei i344                               ; [fn init: fmt_9]: allocate: locals 344 byte(s), call args 0 slot(s)
move $r139 $$arg0                       ; [fn init: fmt_9]: copy argument 0 (self)
move $r140 $$arg1                       ; [fn init: fmt_9]: copy argument 1 (f)
move $r141 $$reta                       ; [fn init: fmt_9]: save return address
.86
addi $r142 $$locbase i224               ; get offset to local __ptr u64
 sw $$locbase $r139 i28                  ; store word
 sw $$locbase $$arg0 i28                 ; store word
addi $r143 $$locbase i144               ; get offset to local __ptr __ptr {  }
sw $$locbase $r140 i18                  ; store word
addi $r144 $$locbase i144               ; get offset to local __ptr __ptr {  }
lw $r145 $$locbase i18                  ; load word
addi $r146 $$locbase i224               ; get offset to local __ptr u64
addi $r147 $$locbase i232               ; get offset to local __ptr {  }
addi $r148 $$locbase i328               ; get offset to local __ptr u64
mcpi $r148 $r146 i8                     ; copy memory
addi $r149 $$locbase i328               ; get offset to local __ptr u64
addi $r150 $$locbase i336               ; get offset to local __ptr u64
mcpi $r150 $r149 i8                     ; copy memory
 move $r151 $zero                        ; move parameter from branch to block argument
 movi $r151 i0                           ; move parameter from branch to block argument
ji  .87
.87
move $r153 $r151                        ; move parameter from branch to block argument
movi $r154 i1                           ; get array element size
 mul $r155 $r153 $r154                   ; get offset to array element
 muli $r155 $r151 i1                     ; get offset to array element
add $r155 $$locbase $r155               ; add array element offset to array base
movi $r156 i48                          ; initialize constant into register
sb $r155 $r156 i0                       ; store byte
 add $r157 $r153 $one
 addi $r157 $r153 i1
movi $r158 i64                          ; initialize constant into register
lt $r159 $r157 $r158
move $r151 $r157                        ; move parameter from branch to block argument
jnzi $r159 .87
ji  .88
.88
addi $r161 $$locbase i80                ; get offset to local __ptr [u8; 64]
mcpi $r161 $$locbase i64                ; copy memory
addi $r162 $$locbase i152               ; get offset to local __ptr u64
movi $r163 i63                          ; initialize constant into register
sw $$locbase $r163 i19                  ; store word
ji  .89
.89
 jnzi $one .90
 ji  .90
ji  .91
.90
addi $r164 $$locbase i336               ; get offset to local __ptr u64
addi $r165 $$locbase i232               ; get offset to local __ptr u64
mcpi $r165 $r164 i8                     ; copy memory
addi $r166 $$locbase i168               ; get offset to local __ptr u64
movi $r167 i10                          ; initialize constant into register
sw $$locbase $r167 i21                  ; store word
addi $r168 $$locbase i232               ; get offset to local __ptr u64
lw $r169 $$locbase i29                  ; load word
addi $r170 $$locbase i168               ; get offset to local __ptr u64
lw $r171 $$locbase i21                  ; load word
mod $r172 $r169 $r171
move $r173 $r172                        ; return value from ASM block with return register v
addi $r174 $$locbase i72                ; get offset to local __ptr u8
 sb $r174 $r173 i0                       ; store byte
 sb $r174 $r172 i0                       ; store byte
addi $r175 $$locbase i72                ; get offset to local __ptr u8
addi $r176 $$locbase i240               ; get offset to local __ptr u8
mcpi $r176 $r175 i1                     ; copy memory
addi $r177 $$locbase i176               ; get offset to local __ptr u8
movi $r178 i48                          ; initialize constant into register
sb $r177 $r178 i0                       ; store byte
addi $r179 $$locbase i240               ; get offset to local __ptr u8
addi $r180 $$locbase i288               ; get offset to local __ptr u8
mcpi $r180 $r179 i1                     ; copy memory
addi $r181 $$locbase i288               ; get offset to local __ptr u8
lb $r182 $r181 i0                       ; load byte
move $r183 $r182                        ; return value from ASM block with return register input
addi $r184 $$locbase i176               ; get offset to local __ptr u8
addi $r185 $$locbase i296               ; get offset to local __ptr u8
mcpi $r185 $r184 i1                     ; copy memory
addi $r186 $$locbase i296               ; get offset to local __ptr u8
lb $r187 $r186 i0                       ; load byte
move $r188 $r187                        ; return value from ASM block with return register input
 add $r189 $r183 $r188
 add $r189 $r183 $r187
addi $r190 $$locbase i216               ; get offset to local __ptr u64
sw $$locbase $r189 i27                  ; store word
addi $r191 $$locbase i304               ; get offset to local __ptr u8
movi $r192 i255                         ; initialize constant into register
sb $r191 $r192 i0                       ; store byte
addi $r193 $$locbase i304               ; get offset to local __ptr u8
lb $r194 $r193 i0                       ; load byte
move $r195 $r194                        ; return value from ASM block with return register input
addi $r196 $$locbase i160               ; get offset to local __ptr u64
 sw $$locbase $r195 i20                  ; store word
 sw $$locbase $r194 i20                  ; store word
addi $r197 $$locbase i216               ; get offset to local __ptr u64
lw $r198 $$locbase i27                  ; load word
addi $r199 $$locbase i160               ; get offset to local __ptr u64
lw $r200 $$locbase i20                  ; load word
gt $r201 $r198 $r200
jnzi $r201 .92
ji  .93
.93
addi $r202 $$locbase i216               ; get offset to local __ptr u64
addi $r203 $$locbase i320               ; get offset to local __ptr u64
mcpi $r203 $r202 i8                     ; copy memory
addi $r204 $$locbase i320               ; get offset to local __ptr u64
lw $r205 $$locbase i40                  ; load word
move $r206 $r205                        ; return value from ASM block with return register input
 move $r207 $r206                        ; move parameter from branch to block argument
 move $r207 $r205                        ; move parameter from branch to block argument
ji  .94
.92
move $r208 $flag                        ; return value from ASM block with return register flag
addr $r209 data_NonConfigurable_3       ; get std::flags::F_WRAPPING_DISABLE_MASK's address in data section
lw $r210 $r209 i0                       ; load word
 and $r211 $r208 $r210
 and $r211 $flag $r210
eq $r212 $r211 $zero
jnzi $r212 .95
ji  .96
.96
addi $r213 $$locbase i216               ; get offset to local __ptr u64
lw $r214 $$locbase i27                  ; load word
addi $r215 $$locbase i160               ; get offset to local __ptr u64
lw $r216 $$locbase i20                  ; load word
 add $r217 $r216 $one
 addi $r217 $r216 i1
mod $r218 $r214 $r217
addi $r219 $$locbase i312               ; get offset to local __ptr u64
sw $$locbase $r218 i39                  ; store word
addi $r220 $$locbase i312               ; get offset to local __ptr u64
lw $r221 $$locbase i39                  ; load word
move $r222 $r221                        ; return value from ASM block with return register input
 move $r207 $r222                        ; move parameter from branch to block argument
 move $r207 $r221                        ; move parameter from branch to block argument
ji  .94
.94
move $r225 $r207                        ; move parameter from branch to block argument
addi $r226 $$locbase i80                ; get offset to local __ptr [u8; 64]
addi $r227 $$locbase i152               ; get offset to local __ptr u64
lw $r228 $$locbase i19                  ; load word
movi $r229 i1                           ; get array element size
 mul $r230 $r228 $r229                   ; get offset to array element
 muli $r230 $r228 i1                     ; get offset to array element
add $r230 $r226 $r230                   ; add array element offset to array base
 sb $r230 $r225 i0                       ; store byte
 sb $r230 $r207 i0                       ; store byte
addi $r231 $$locbase i336               ; get offset to local __ptr u64
addi $r232 $$locbase i248               ; get offset to local __ptr u64
mcpi $r232 $r231 i8                     ; copy memory
addi $r233 $$locbase i184               ; get offset to local __ptr u64
movi $r234 i10                          ; initialize constant into register
sw $$locbase $r234 i23                  ; store word
addi $r235 $$locbase i248               ; get offset to local __ptr u64
lw $r236 $$locbase i31                  ; load word
addi $r237 $$locbase i184               ; get offset to local __ptr u64
lw $r238 $$locbase i23                  ; load word
div $r239 $r236 $r238
addi $r240 $$locbase i336               ; get offset to local __ptr u64
sw $$locbase $r239 i42                  ; store word
addi $r241 $$locbase i336               ; get offset to local __ptr u64
addi $r242 $$locbase i256               ; get offset to local __ptr u64
mcpi $r242 $r241 i8                     ; copy memory
addi $r243 $$locbase i192               ; get offset to local __ptr u64
sw $$locbase $zero i24                  ; store word
addi $r244 $$locbase i256               ; get offset to local __ptr u64
lw $r245 $$locbase i32                  ; load word
addi $r246 $$locbase i192               ; get offset to local __ptr u64
lw $r247 $$locbase i24                  ; load word
eq $r248 $r245 $r247
jnzi $r248 .91
ji  .97
.97
addi $r249 $$locbase i152               ; get offset to local __ptr u64
addi $r250 $$locbase i264               ; get offset to local __ptr u64
mcpi $r250 $r249 i8                     ; copy memory
addi $r251 $$locbase i200               ; get offset to local __ptr u64
sw $$locbase $one i25                   ; store word
addi $r252 $$locbase i264               ; get offset to local __ptr u64
lw $r253 $$locbase i33                  ; load word
addi $r254 $$locbase i200               ; get offset to local __ptr u64
lw $r255 $$locbase i25                  ; load word
sub $r256 $r253 $r255
addi $r257 $$locbase i152               ; get offset to local __ptr u64
sw $$locbase $r256 i19                  ; store word
ji  .89
.91
addr $r258 data_NonConfigurable_3       ; get std::debug::STDERR's address in data section
lw $r259 $r258 i0                       ; load word
addi $r260 $$locbase i80                ; get offset to local __ptr [u8; 64]
addi $r261 $$locbase i152               ; get offset to local __ptr u64
addi $r262 $$locbase i272               ; get offset to local __ptr ptr
sw $$locbase $r260 i34                  ; store word
addi $r263 $$locbase i64                ; get offset to local __ptr u64
mcpi $r263 $r261 i8                     ; copy memory
addi $r264 $$locbase i272               ; get offset to local __ptr ptr
lw $r265 $$locbase i34                  ; load word
addi $r266 $$locbase i64                ; get offset to local __ptr u64
lw $r267 $$locbase i8                   ; load word
 mul $r268 $one $r267
 muli $r268 $r267 i1
add $r269 $r265 $r268
addi $r270 $$locbase i152               ; get offset to local __ptr u64
addi $r271 $$locbase i280               ; get offset to local __ptr u64
movi $r272 i64                          ; initialize constant into register
sw $$locbase $r272 i35                  ; store word
addi $r273 $$locbase i208               ; get offset to local __ptr u64
mcpi $r273 $r270 i8                     ; copy memory
addi $r274 $$locbase i280               ; get offset to local __ptr u64
lw $r275 $$locbase i35                  ; load word
addi $r276 $$locbase i208               ; get offset to local __ptr u64
lw $r277 $$locbase i26                  ; load word
sub $r278 $r275 $r277
move $$arg0 $r259                       ; [call: syscall_write_2]: pass argument 0
move $$arg1 $r269                       ; [call: syscall_write_2]: pass argument 1
move $$arg2 $r278                       ; [call: syscall_write_2]: pass argument 2
fncall .8                               ; [call: syscall_write_2]: call function
 move $r279 $zero                        ; [call: syscall_write_2]: copy returned unit value
 movi $r279 i0                           ; [call: syscall_write_2]: copy returned unit value
ji  .17
.95
rvrt $zero
.17
cfsi i344                               ; [fn end: fmt_9] free: locals 344 byte(s), call args 0 slot(s)
move $$reta $r141                       ; [fn end: fmt_9] restore return address
popa .16                                ; [fn end: fmt_9] restore all used registers
jal $zero $$reta i0                     ; [fn end: fmt_9] return from call
DIFF------------------------------
.program:
.18                                     ; --- start of function: encode_allow_alias_23 ---
pusha .18                               ; [fn init: encode_allow_alias_23]: push all used registers to stack
move $$locbase $sp                      ; [fn init: encode_allow_alias_23]: set locals base register
cfei i192                               ; [fn init: encode_allow_alias_23]: allocate: locals 192 byte(s), call args 0 slot(s)
move $r280 $$arg0                       ; [fn init: encode_allow_alias_23]: copy argument 0 (item)
move $r281 $$arg1                       ; [fn init: encode_allow_alias_23]: copy argument 1 (__ret_value)
move $r282 $$reta                       ; [fn init: encode_allow_alias_23]: save return address
.98
addi $r283 $$locbase i176               ; get offset to local __ptr __ptr slice
 sw $$locbase $r280 i22                  ; store word
 jnzi $zero .99
 sw $$locbase $$arg0 i22                 ; store word
 
ji  .100
.100
addi $r284 $$locbase i176               ; get offset to local __ptr __ptr slice
lw $r285 $$locbase i22                  ; load word
addi $r286 $$locbase i40                ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r286                       ; [call: new_27]: pass argument 0
fncall .22                              ; [call: new_27]: call function
 move $r287 $zero                        ; [call: new_27]: copy returned unit value
 movi $r287 i0                           ; [call: new_27]: copy returned unit value
addi $r288 $$locbase i80                ; get offset to local __ptr slice
mcpi $r288 $r285 i16                    ; copy memory
addi $r289 $$locbase i96                ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r289 $r286 i24                    ; copy memory
addi $r290 $$locbase i16                ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r288                       ; [call: abi_encode_26]: pass argument 0
move $$arg1 $r289                       ; [call: abi_encode_26]: pass argument 1
move $$arg2 $r290                       ; [call: abi_encode_26]: pass argument 2
fncall .20                              ; [call: abi_encode_26]: call function
 move $r291 $zero                        ; [call: abi_encode_26]: copy returned unit value
 movi $r291 i0                           ; [call: abi_encode_26]: copy returned unit value
addi $r292 $$locbase i152               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r292 $r290 i24                    ; copy memory
addi $r293 $$locbase i152               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r294 $$locbase i64                ; get offset to local __ptr slice
move $$arg0 $r293                       ; [call: as_raw_slice_28]: pass argument 0
move $$arg1 $r294                       ; [call: as_raw_slice_28]: pass argument 1
fncall .24                              ; [call: as_raw_slice_28]: call function
 move $r295 $zero                        ; [call: as_raw_slice_28]: copy returned unit value
 movi $r295 i0                           ; [call: as_raw_slice_28]: copy returned unit value
addi $r296 $$locbase i120               ; get offset to local __ptr slice
mcpi $r296 $r294 i16                    ; copy memory
move $r297 $r296                        ; move parameter from branch to block argument
ji  .101
.99
addi $r298 $$locbase i184               ; get offset to local __ptr u64
movi $r299 i16                          ; initialize constant into register
sw $$locbase $r299 i23                  ; store word
addi $r300 $$locbase i136               ; get offset to local __ptr { __ptr slice, u64 }
addi $r301 $$locbase i176               ; get offset to local __ptr __ptr slice
addi $r302 $$locbase i184               ; get offset to local __ptr u64
mcpi $r300 $r301 i8                     ; copy memory
addi $r303 $r300 i8                     ; get offset to aggregate element
mcpi $r303 $r302 i8                     ; copy memory
mcpi $$locbase $r300 i16                ; copy memory
addi $r304 $$locbase i120               ; get offset to local __ptr slice
mcpi $r304 $$locbase i16                ; copy memory
move $r297 $r304                        ; move parameter from branch to block argument
ji  .101
.101
move $r307 $r297                        ; move parameter from branch to block argument
 mcpi $r281 $r307 i16                    ; copy memory
 mcpi $r281 $r297 i16                    ; copy memory
ji  .19
.19
cfsi i192                               ; [fn end: encode_allow_alias_23] free: locals 192 byte(s), call args 0 slot(s)
move $$reta $r282                       ; [fn end: encode_allow_alias_23] restore return address
popa .18                                ; [fn end: encode_allow_alias_23] restore all used registers
jal $zero $$reta i0                     ; [fn end: encode_allow_alias_23] return from call
DIFF------------------------------
.program:
.20                                     ; --- start of function: abi_encode_26 ---
pusha .20                               ; [fn init: abi_encode_26]: push all used registers to stack
move $$locbase $sp                      ; [fn init: abi_encode_26]: set locals base register
cfei i224                               ; [fn init: abi_encode_26]: allocate: locals 224 byte(s), call args 0 slot(s)
.102
addi $r309 $$locbase i208               ; get offset to local __ptr slice
mcpi $r309 $$arg0 i16                   ; copy memory
addi $r310 $$locbase i184               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r310 $$arg1 i24                   ; copy memory
addi $r311 $$locbase i160               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r312 $$locbase i184               ; get offset to local __ptr { { ptr, u64, u64 } }
move $r313 $r312                        ; return value from ASM block with return register buffer
 mcpi $$locbase $r313 i24                ; copy memory
 mcpi $$locbase $r312 i24                ; copy memory
addi $r314 $$locbase i80                ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r314 $$locbase i24                ; copy memory
lw $r315 $$locbase i10                  ; load word
addi $r316 $r314 i8                     ; get offset to aggregate element
lw $r317 $$locbase i11                  ; load word
addi $r318 $r314 i16                    ; get offset to aggregate element
lw $r319 $$locbase i12                  ; load word
addi $r320 $$locbase i208               ; get offset to local __ptr slice
addi $r321 $$locbase i40                ; get offset to local __ptr slice
mcpi $r321 $r320 i16                    ; copy memory
move $r322 $r320                        ; return value from ASM block with return register item
addi $r323 $$locbase i24                ; get offset to local __ptr { u64, u64 }
 mcpi $r323 $r322 i16                    ; copy memory
 mcpi $r323 $r320 i16                    ; copy memory
addi $r324 $$locbase i104               ; get offset to local __ptr { u64, u64 }
mcpi $r324 $r323 i16                    ; copy memory
addi $r325 $r324 i8                     ; get offset to aggregate element
lw $r326 $$locbase i14                  ; load word
movi $r327 i8                           ; initialize constant into register
 add $r328 $r326 $r327
 addi $r328 $r326 i8
add $r329 $r319 $r328
gt $r330 $r329 $r317
move $r331 $r315                        ; move parameter from branch to block argument
move $r332 $r317                        ; move parameter from branch to block argument
jnzi $r330 .103
ji  .104
.103
movi $r333 i2                           ; initialize constant into register
 mul $r334 $r317 $r333
 muli $r334 $r317 i2
add $r335 $r334 $r328
aloc $r335
mcp $hp $r315 $r319
move $r336 $hp                          ; return value from ASM block with return register hp
 move $r331 $r336                        ; move parameter from branch to block argument
 move $r331 $hp                          ; move parameter from branch to block argument
move $r332 $r335                        ; move parameter from branch to block argument
ji  .104
.104
move $r340 $r331                        ; move parameter from branch to block argument
move $r342 $r332                        ; move parameter from branch to block argument
addi $r343 $$locbase i120               ; get offset to local __ptr slice
mcpi $r343 $r321 i16                    ; copy memory
add $r344 $r340 $r319
lw $r346 $$locbase i16
sw $r344 $r346 i0
addi $r344 $r344 i8
lw $r345 $$locbase i15
mcp $r344 $r345 $r346
addi $r347 $r319 i8
add $r347 $r347 $r346
move $r348 $r347                        ; return value from ASM block with return register new_len
addi $r349 $$locbase i136               ; get offset to local __ptr { ptr, u64, u64 }
sw $$locbase $r340 i17                  ; store word
addi $r350 $r349 i8                     ; get offset to aggregate element
sw $$locbase $r342 i18                  ; store word
addi $r351 $r349 i16                    ; get offset to aggregate element
sw $$locbase $r348 i19                  ; store word
move $r352 $r349                        ; return value from ASM block with return register buffer
addi $r353 $$locbase i56                ; get offset to local __ptr { ptr, u64, u64 }
 mcpi $r353 $r352 i24                    ; copy memory
 mcpi $r353 $r349 i24                    ; copy memory
mcpi $r311 $r353 i24                    ; copy memory
mcpi $$arg2 $r311 i24                   ; copy memory
ji  .21
.21
cfsi i224                               ; [fn end: abi_encode_26] free: locals 224 byte(s), call args 0 slot(s)
popa .20                                ; [fn end: abi_encode_26] restore all used registers
jal $zero $$reta i0                     ; [fn end: abi_encode_26] return from call
DIFF------------------------------
.program:
.22                                     ; --- start of function: new_27 ---
pusha .22                               ; [fn init: new_27]: push all used registers to stack
move $$locbase $sp                      ; [fn init: new_27]: set locals base register
cfei i72                                ; [fn init: new_27]: allocate: locals 72 byte(s), call args 0 slot(s)
.105
addi $r355 $$locbase i48                ; get offset to local __ptr { { ptr, u64, u64 } }
movi $r356 i1024                        ; initialize constant into register
aloc $r356
move $r357 $hp                          ; return value from ASM block with return register hp
addi $r358 $$locbase i24                ; get offset to local __ptr { ptr, u64, u64 }
 sw $$locbase $r357 i3                   ; store word
 sw $$locbase $hp i3                     ; store word
addi $r359 $r358 i8                     ; get offset to aggregate element
movi $r360 i1024                        ; initialize constant into register
sw $$locbase $r360 i4                   ; store word
addi $r361 $r358 i16                    ; get offset to aggregate element
sw $$locbase $zero i5                   ; store word
move $r362 $r358                        ; return value from ASM block with return register buffer
 mcpi $$locbase $r362 i24                ; copy memory
 mcpi $$locbase $r358 i24                ; copy memory
mcpi $r355 $$locbase i24                ; copy memory
mcpi $$arg0 $r355 i24                   ; copy memory
ji  .23
.23
cfsi i72                                ; [fn end: new_27] free: locals 72 byte(s), call args 0 slot(s)
popa .22                                ; [fn end: new_27] restore all used registers
jal $zero $$reta i0                     ; [fn end: new_27] return from call
DIFF------------------------------
.program:
.24                                     ; --- start of function: as_raw_slice_28 ---
pusha .24                               ; [fn init: as_raw_slice_28]: push all used registers to stack
move $$locbase $sp                      ; [fn init: as_raw_slice_28]: set locals base register
cfei i104                               ; [fn init: as_raw_slice_28]: allocate: locals 104 byte(s), call args 0 slot(s)
.106
addi $r364 $$locbase i80                ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r364 $$arg0 i24                   ; copy memory
addi $r365 $$locbase i80                ; get offset to local __ptr { { ptr, u64, u64 } }
move $r366 $r365                        ; return value from ASM block with return register buffer
 mcpi $$locbase $r366 i24                ; copy memory
 mcpi $$locbase $r365 i24                ; copy memory
addi $r367 $$locbase i40                ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r367 $$locbase i24                ; copy memory
addi $r368 $r367 i16                    ; get offset to aggregate element
addi $r369 $$locbase i64                ; get offset to local __ptr { ptr, u64 }
mcpi $r369 $r367 i8                     ; copy memory
addi $r370 $r369 i8                     ; get offset to aggregate element
mcpi $r370 $r368 i8                     ; copy memory
move $r371 $r369                        ; return value from ASM block with return register s
addi $r372 $$locbase i24                ; get offset to local __ptr slice
 mcpi $r372 $r371 i16                    ; copy memory
 mcpi $r372 $r369 i16                    ; copy memory
mcpi $$arg1 $r372 i16                   ; copy memory
ji  .25
.25
cfsi i104                               ; [fn end: as_raw_slice_28] free: locals 104 byte(s), call args 0 slot(s)
popa .24                                ; [fn end: as_raw_slice_28] restore all used registers
jal $zero $$reta i0                     ; [fn end: as_raw_slice_28] return from call
DIFF------------------------------
.program:
.26                                     ; --- start of function: log_29 ---
pusha .26                               ; [fn init: log_29]: push all used registers to stack
move $$locbase $sp                      ; [fn init: log_29]: set locals base register
cfei i216                               ; [fn init: log_29]: allocate: locals 216 byte(s), call args 0 slot(s)
move $r373 $$arg0                       ; [fn init: log_29]: copy argument 0 (value)
move $r374 $$reta                       ; [fn init: log_29]: save return address
.107
addi $r375 $$locbase i208               ; get offset to local __ptr u64
 sw $$locbase $r373 i26                  ; store word
 sw $$locbase $$arg0 i26                 ; store word
addi $r376 $$locbase i208               ; get offset to local __ptr u64
addi $r377 $$locbase i192               ; get offset to local __ptr __ptr u64
sw $$locbase $r376 i24                  ; store word
 jnzi $one .108
 ji  .108
ji  .109
.109
addi $r378 $$locbase i192               ; get offset to local __ptr __ptr u64
lw $r379 $$locbase i24                  ; load word
lw $r380 $r379 i0                       ; load word
addi $r381 $$locbase i32                ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r381                       ; [call: new_27]: pass argument 0
fncall .22                              ; [call: new_27]: call function
 move $r382 $zero                        ; [call: new_27]: copy returned unit value
 movi $r382 i0                           ; [call: new_27]: copy returned unit value
addi $r383 $$locbase i96                ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r383 $r381 i24                    ; copy memory
addi $r384 $$locbase i72                ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r380                       ; [call: abi_encode_33]: pass argument 0
move $$arg1 $r383                       ; [call: abi_encode_33]: pass argument 1
move $$arg2 $r384                       ; [call: abi_encode_33]: pass argument 2
fncall .28                              ; [call: abi_encode_33]: call function
 move $r385 $zero                        ; [call: abi_encode_33]: copy returned unit value
 movi $r385 i0                           ; [call: abi_encode_33]: copy returned unit value
addi $r386 $$locbase i168               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r386 $r384 i24                    ; copy memory
addi $r387 $$locbase i168               ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r388 $$locbase i56                ; get offset to local __ptr slice
move $$arg0 $r387                       ; [call: as_raw_slice_28]: pass argument 0
move $$arg1 $r388                       ; [call: as_raw_slice_28]: pass argument 1
fncall .24                              ; [call: as_raw_slice_28]: call function
 move $r389 $zero                        ; [call: as_raw_slice_28]: copy returned unit value
 movi $r389 i0                           ; [call: as_raw_slice_28]: copy returned unit value
addi $r390 $$locbase i120               ; get offset to local __ptr slice
mcpi $r390 $r388 i16                    ; copy memory
move $r391 $r390                        ; move parameter from branch to block argument
ji  .110
.108
addi $r392 $$locbase i200               ; get offset to local __ptr u64
movi $r393 i8                           ; initialize constant into register
sw $$locbase $r393 i25                  ; store word
addi $r394 $$locbase i152               ; get offset to local __ptr { __ptr u64, u64 }
addi $r395 $$locbase i192               ; get offset to local __ptr __ptr u64
addi $r396 $$locbase i200               ; get offset to local __ptr u64
mcpi $r394 $r395 i8                     ; copy memory
addi $r397 $r394 i8                     ; get offset to aggregate element
mcpi $r397 $r396 i8                     ; copy memory
mcpi $$locbase $r394 i16                ; copy memory
addi $r398 $$locbase i120               ; get offset to local __ptr slice
mcpi $r398 $$locbase i16                ; copy memory
move $r391 $r398                        ; move parameter from branch to block argument
ji  .110
.110
move $r401 $r391                        ; move parameter from branch to block argument
addi $r402 $$locbase i136               ; get offset to local __ptr slice
 mcpi $r402 $r401 i16                    ; copy memory
 mcpi $r402 $r391 i16                    ; copy memory
addi $r403 $$locbase i16                ; get offset to local __ptr slice
mcpi $r403 $r402 i16                    ; copy memory
load $r404 data_NonConfigurable_7       ; load constant from data section
lw $r405 $$locbase i2                   ; load slice pointer for logging data
lw $r406 $$locbase i3                   ; load slice size for logging data
logd $zero $r404 $r405 $r406            ; log slice
ji  .27
.27
cfsi i216                               ; [fn end: log_29] free: locals 216 byte(s), call args 0 slot(s)
move $$reta $r374                       ; [fn end: log_29] restore return address
popa .26                                ; [fn end: log_29] restore all used registers
jal $zero $$reta i0                     ; [fn end: log_29] return from call
DIFF------------------------------
.program:
.28                                     ; --- start of function: abi_encode_33 ---
pusha .28                               ; [fn init: abi_encode_33]: push all used registers to stack
move $$locbase $sp                      ; [fn init: abi_encode_33]: set locals base register
cfei i152                               ; [fn init: abi_encode_33]: allocate: locals 152 byte(s), call args 0 slot(s)
.111
addi $r408 $$locbase i144               ; get offset to local __ptr u64
sw $$locbase $$arg0 i18                 ; store word
addi $r409 $$locbase i120               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r409 $$arg1 i24                   ; copy memory
addi $r410 $$locbase i96                ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r411 $$locbase i120               ; get offset to local __ptr { { ptr, u64, u64 } }
move $r412 $r411                        ; return value from ASM block with return register buffer
 mcpi $$locbase $r412 i24                ; copy memory
 mcpi $$locbase $r411 i24                ; copy memory
addi $r413 $$locbase i48                ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r413 $$locbase i24                ; copy memory
lw $r414 $$locbase i6                   ; load word
addi $r415 $r413 i8                     ; get offset to aggregate element
lw $r416 $$locbase i7                   ; load word
addi $r417 $r413 i16                    ; get offset to aggregate element
lw $r418 $$locbase i8                   ; load word
addi $r419 $$locbase i144               ; get offset to local __ptr u64
lw $r420 $$locbase i18                  ; load word
movi $r421 i8                           ; initialize constant into register
 add $r422 $r418 $r421
 addi $r422 $r418 i8
gt $r423 $r422 $r416
move $r424 $r414                        ; move parameter from branch to block argument
move $r425 $r416                        ; move parameter from branch to block argument
jnzi $r423 .112
ji  .113
.112
movi $r426 i2                           ; initialize constant into register
 mul $r427 $r416 $r426
 muli $r427 $r416 i2
movi $r428 i8                           ; initialize constant into register
 add $r429 $r427 $r428
 addi $r429 $r427 i8
aloc $r429
mcp $hp $r414 $r418
move $r430 $hp                          ; return value from ASM block with return register hp
 move $r424 $r430                        ; move parameter from branch to block argument
 move $r424 $hp                          ; move parameter from branch to block argument
move $r425 $r429                        ; move parameter from branch to block argument
ji  .113
.113
move $r434 $r424                        ; move parameter from branch to block argument
move $r436 $r425                        ; move parameter from branch to block argument
 add $r437 $r434 $r418
 add $r437 $r424 $r418
sw $r437 $r420 i0                       ; store word
movi $r438 i8                           ; initialize constant into register
 add $r439 $r418 $r438
 addi $r439 $r418 i8
addi $r440 $$locbase i72                ; get offset to local __ptr { ptr, u64, u64 }
sw $$locbase $r434 i9                   ; store word
addi $r441 $r440 i8                     ; get offset to aggregate element
sw $$locbase $r436 i10                  ; store word
addi $r442 $r440 i16                    ; get offset to aggregate element
sw $$locbase $r439 i11                  ; store word
move $r443 $r440                        ; return value from ASM block with return register buffer
addi $r444 $$locbase i24                ; get offset to local __ptr { ptr, u64, u64 }
 mcpi $r444 $r443 i24                    ; copy memory
 mcpi $r444 $r440 i24                    ; copy memory
mcpi $r410 $r444 i24                    ; copy memory
mcpi $$arg2 $r410 i24                   ; copy memory
ji  .29
.29
cfsi i152                               ; [fn end: abi_encode_33] free: locals 152 byte(s), call args 0 slot(s)
popa .28                                ; [fn end: abi_encode_33] restore all used registers
jal $zero $$reta i0                     ; [fn end: abi_encode_33] return from call
DIFF------------------------------
.program:
.38                                     ; --- start of function: finish_36 ---
pusha .38                               ; [fn init: finish_36]: push all used registers to stack
move $$locbase $sp                      ; [fn init: finish_36]: set locals base register
cfei i40                                ; [fn init: finish_36]: allocate: locals 40 byte(s), call args 0 slot(s)
move $r696 $$arg0                       ; [fn init: finish_36]: copy argument 0 (self)
move $r697 $$reta                       ; [fn init: finish_36]: save return address
.134
addi $r698 $$locbase i32                ; get offset to local __ptr __ptr { {  }, bool }
 sw $$locbase $r696 i4                   ; store word
 sw $$locbase $$arg0 i4                  ; store word
addi $r699 $$locbase i32                ; get offset to local __ptr __ptr { {  }, bool }
lw $r700 $$locbase i4                   ; load word
addr $r701 data_NonConfigurable_21      ; get __const_global13's address in data section
sw $$locbase $r701 i0                   ; store word
addi $r702 $$locbase i8                 ; get offset to aggregate element
sw $$locbase $one i1                    ; store word
addi $r703 $$locbase i16                ; get offset to local __ptr slice
mcpi $r703 $$locbase i16                ; copy memory
addi $r704 $$locbase i32                ; get offset to local __ptr {  }
addi $r705 $$locbase i16                ; get offset to local __ptr slice
move $$arg0 $r704                       ; [call: print_str_1]: pass argument 0
move $$arg1 $r705                       ; [call: print_str_1]: pass argument 1
fncall .6                               ; [call: print_str_1]: call function
 move $r706 $zero                        ; [call: print_str_1]: copy returned unit value
 movi $r706 i0                           ; [call: print_str_1]: copy returned unit value
ji  .39
.39
cfsi i40                                ; [fn end: finish_36] free: locals 40 byte(s), call args 0 slot(s)
move $$reta $r697                       ; [fn end: finish_36] restore return address
popa .38                                ; [fn end: finish_36] restore all used registers
jal $zero $$reta i0                     ; [fn end: finish_36] return from call
DIFF------------------------------
.program:
.40                                     ; --- start of function: debug_tuple_39 ---
pusha .40                               ; [fn init: debug_tuple_39]: push all used registers to stack
move $$locbase $sp                      ; [fn init: debug_tuple_39]: set locals base register
cfei i72                                ; [fn init: debug_tuple_39]: allocate: locals 72 byte(s), call args 0 slot(s)
move $r707 $$arg0                       ; [fn init: debug_tuple_39]: copy argument 0 (self)
move $r708 $$arg1                       ; [fn init: debug_tuple_39]: copy argument 1 (name)
move $r709 $$arg2                       ; [fn init: debug_tuple_39]: copy argument 2 (__ret_value)
move $r710 $$reta                       ; [fn init: debug_tuple_39]: save return address
.135
addi $r711 $$locbase i64                ; get offset to local __ptr {  }
addi $r712 $$locbase i40                ; get offset to local __ptr slice
 mcpi $r712 $r708 i16                    ; copy memory
 mcpi $r712 $$arg1 i16                   ; copy memory
move $$arg0 $r708                       ; [call: len_4]: pass argument 0
fncall .10                              ; [call: len_4]: call function
move $r713 $$retv                       ; [call: len_4]: copy returned value
addi $r714 $$locbase i64                ; get offset to local __ptr u64
 sw $$locbase $r713 i8                   ; store word
 sw $$locbase $$retv i8                  ; store word
addi $r715 $$locbase i56                ; get offset to local __ptr u64
sw $$locbase $zero i7                   ; store word
addi $r716 $$locbase i64                ; get offset to local __ptr u64
lw $r717 $$locbase i8                   ; load word
addi $r718 $$locbase i56                ; get offset to local __ptr u64
lw $r719 $$locbase i7                   ; load word
gt $r720 $r717 $r719
jnzi $r720 .136
ji  .137
.136
addi $r721 $$locbase i64                ; get offset to local __ptr {  }
addi $r722 $$locbase i40                ; get offset to local __ptr slice
move $$arg0 $r721                       ; [call: print_str_1]: pass argument 0
move $$arg1 $r722                       ; [call: print_str_1]: pass argument 1
fncall .6                               ; [call: print_str_1]: call function
 move $r723 $zero                        ; [call: print_str_1]: copy returned unit value
 movi $r723 i0                           ; [call: print_str_1]: copy returned unit value
ji  .137
.137
addi $r724 $$locbase i64                ; get offset to local __ptr {  }
addr $r725 data_NonConfigurable_22      ; get __const_global17's address in data section
sw $$locbase $r725 i0                   ; store word
addi $r726 $$locbase i8                 ; get offset to aggregate element
sw $$locbase $one i1                    ; store word
addi $r727 $$locbase i16                ; get offset to local __ptr slice
mcpi $r727 $$locbase i16                ; copy memory
addi $r728 $$locbase i16                ; get offset to local __ptr slice
move $$arg0 $r724                       ; [call: print_str_1]: pass argument 0
move $$arg1 $r728                       ; [call: print_str_1]: pass argument 1
fncall .6                               ; [call: print_str_1]: call function
 move $r729 $zero                        ; [call: print_str_1]: copy returned unit value
 movi $r729 i0                           ; [call: print_str_1]: copy returned unit value
addi $r730 $$locbase i32                ; get offset to local __ptr { {  }, bool }
addi $r731 $$locbase i64                ; get offset to local __ptr {  }
sb $r730 $zero i0                       ; store byte
mcpi $r709 $r730 i8                     ; copy memory
ji  .41
.41
cfsi i72                                ; [fn end: debug_tuple_39] free: locals 72 byte(s), call args 0 slot(s)
move $$reta $r710                       ; [fn end: debug_tuple_39] restore return address
popa .40                                ; [fn end: debug_tuple_39] restore all used registers
jal $zero $$reta i0                     ; [fn end: debug_tuple_39] return from call
DIFF------------------------------
.program:
.42                                     ; --- start of function: field_41 ---
pusha .42                               ; [fn init: field_41]: push all used registers to stack
move $$locbase $sp                      ; [fn init: field_41]: set locals base register
cfei i56                                ; [fn init: field_41]: allocate: locals 56 byte(s), call args 0 slot(s)
move $r732 $$arg0                       ; [fn init: field_41]: copy argument 0 (self)
move $r733 $$arg1                       ; [fn init: field_41]: copy argument 1 (value)
move $r734 $$arg2                       ; [fn init: field_41]: copy argument 2 (__ret_value)
move $r735 $$reta                       ; [fn init: field_41]: save return address
.138
addi $r736 $$locbase i32                ; get offset to local __ptr __ptr { {  }, bool }
 sw $$locbase $r732 i4                   ; store word
 sw $$locbase $$arg0 i4                  ; store word
addi $r737 $$locbase i40                ; get offset to local __ptr slice
mcpi $r737 $r733 i16                    ; copy memory
addi $r738 $$locbase i32                ; get offset to local __ptr __ptr { {  }, bool }
lw $r739 $$locbase i4                   ; load word
lb $r740 $r739 i0                       ; load byte
jnzi $r740 .139
ji  .140
.139
addi $r741 $$locbase i32                ; get offset to local __ptr __ptr { {  }, bool }
lw $r742 $$locbase i4                   ; load word
addr $r743 data_NonConfigurable_16      ; get __const_global19's address in data section
sw $$locbase $r743 i0                   ; store word
addi $r744 $$locbase i8                 ; get offset to aggregate element
movi $r745 i2                           ; initialize constant into register
sw $$locbase $r745 i1                   ; store word
addi $r746 $$locbase i16                ; get offset to local __ptr slice
mcpi $r746 $$locbase i16                ; copy memory
addi $r747 $$locbase i32                ; get offset to local __ptr {  }
addi $r748 $$locbase i16                ; get offset to local __ptr slice
move $$arg0 $r747                       ; [call: print_str_1]: pass argument 0
move $$arg1 $r748                       ; [call: print_str_1]: pass argument 1
fncall .6                               ; [call: print_str_1]: call function
 move $r749 $zero                        ; [call: print_str_1]: copy returned unit value
 movi $r749 i0                           ; [call: print_str_1]: copy returned unit value
ji  .140
.140
addi $r750 $$locbase i40                ; get offset to local __ptr slice
addi $r751 $$locbase i32                ; get offset to local __ptr __ptr { {  }, bool }
lw $r752 $$locbase i4                   ; load word
move $$arg0 $r750                       ; [call: fmt_5]: pass argument 0
move $$arg1 $r752                       ; [call: fmt_5]: pass argument 1
fncall .12                              ; [call: fmt_5]: call function
 move $r753 $zero                        ; [call: fmt_5]: copy returned unit value
 movi $r753 i0                           ; [call: fmt_5]: copy returned unit value
addi $r754 $$locbase i32                ; get offset to local __ptr __ptr { {  }, bool }
lw $r755 $$locbase i4                   ; load word
sb $r755 $one i0                        ; store byte
addi $r756 $$locbase i32                ; get offset to local __ptr __ptr { {  }, bool }
lw $r757 $$locbase i4                   ; load word
mcpi $r734 $r757 i8                     ; copy memory
ji  .43
.43
cfsi i56                                ; [fn end: field_41] free: locals 56 byte(s), call args 0 slot(s)
move $$reta $r735                       ; [fn end: field_41] restore return address
popa .42                                ; [fn end: field_41] restore all used registers
jal $zero $$reta i0                     ; [fn end: field_41] return from call
DIFF------------------------------
.program:
.52                                     ; --- start of function: encode_allow_alias_50 ---
pusha .52                               ; [fn init: encode_allow_alias_50]: push all used registers to stack
move $$locbase $sp                      ; [fn init: encode_allow_alias_50]: set locals base register
cfei i1128                              ; [fn init: encode_allow_alias_50]: allocate: locals 1128 byte(s), call args 0 slot(s)
move $r935 $$arg0                       ; [fn init: encode_allow_alias_50]: copy argument 0 (item)
move $r936 $$arg1                       ; [fn init: encode_allow_alias_50]: copy argument 1 (__ret_value)
move $r937 $$reta                       ; [fn init: encode_allow_alias_50]: save return address
.153
addi $r938 $$locbase i960               ; get offset to local __ptr __ptr { u64, ( () | bool | slice | slice ) }
 sw $$locbase $r935 i120                 ; store word
 sw $$locbase $$arg0 i120                ; store word
addi $r939 $$locbase i1008              ; get offset to local __ptr u64
load $r940 data_NonConfigurable_33      ; load constant from data section
sw $$locbase $r940 i126                 ; store word
addi $r941 $$locbase i968               ; get offset to local __ptr u64
sw $$locbase $zero i121                 ; store word
addi $r942 $$locbase i1008              ; get offset to local __ptr u64
lw $r943 $$locbase i126                 ; load word
addi $r944 $$locbase i968               ; get offset to local __ptr u64
lw $r945 $$locbase i121                 ; load word
eq $r946 $r943 $r945
move $r947 $r946                        ; move parameter from branch to block argument
jnzi $r946 .154
ji  .155
.154
 move $r947 $one                         ; move parameter from branch to block argument
 movi $r947 i1                           ; move parameter from branch to block argument
ji  .155
.155
move $r950 $r947                        ; move parameter from branch to block argument
 move $r951 $r950                        ; move parameter from branch to block argument
 jnzi $r950 .156
 move $r951 $r947                        ; move parameter from branch to block argument
 jnzi $r947 .156
ji  .157
.156
 move $r951 $one                         ; move parameter from branch to block argument
 movi $r951 i1                           ; move parameter from branch to block argument
ji  .157
.157
move $r954 $r951                        ; move parameter from branch to block argument
 move $r955 $r954                        ; move parameter from branch to block argument
 jnzi $r954 .158
 move $r955 $r951                        ; move parameter from branch to block argument
 jnzi $r951 .158
ji  .159
.158
 move $r955 $zero                        ; move parameter from branch to block argument
 movi $r955 i0                           ; move parameter from branch to block argument
ji  .159
.159
move $r958 $r955                        ; move parameter from branch to block argument
 move $r959 $r958                        ; move parameter from branch to block argument
 jnzi $r958 .160
 move $r959 $r955                        ; move parameter from branch to block argument
 jnzi $r955 .160
ji  .161
.160
 move $r959 $zero                        ; move parameter from branch to block argument
 movi $r959 i0                           ; move parameter from branch to block argument
ji  .161
.161
move $r962 $r959                        ; move parameter from branch to block argument
 jnzi $r962 .162
 jnzi $r959 .162
ji  .163
.163
addi $r963 $$locbase i960               ; get offset to local __ptr __ptr { u64, ( () | bool | slice | slice ) }
lw $r964 $$locbase i120                 ; load word
addi $r965 $$locbase i184               ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r965                       ; [call: new_27]: pass argument 0
fncall .22                              ; [call: new_27]: call function
 move $r966 $zero                        ; [call: new_27]: copy returned unit value
 movi $r966 i0                           ; [call: new_27]: copy returned unit value
addi $r967 $$locbase i1016              ; get offset to local __ptr { u64, ( () | bool | slice | slice ) }
mcpi $r967 $r964 i24                    ; copy memory
addi $r968 $$locbase i744               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r968 $r965 i24                    ; copy memory
addi $r969 $$locbase i1016              ; get offset to local __ptr { u64, ( () | bool | slice | slice ) }
addi $r970 $$locbase i112               ; get offset to local __ptr { u64, ( () | bool | slice | slice ) }
mcpi $r970 $r969 i24                    ; copy memory
addi $r971 $$locbase i112               ; get offset to local __ptr { u64, ( () | bool | slice | slice ) }
addi $r972 $$locbase i1040              ; get offset to local __ptr u64
mcpi $r972 $r971 i8                     ; copy memory
addi $r973 $$locbase i976               ; get offset to local __ptr u64
sw $$locbase $zero i122                 ; store word
addi $r974 $$locbase i1040              ; get offset to local __ptr u64
lw $r975 $$locbase i130                 ; load word
addi $r976 $$locbase i976               ; get offset to local __ptr u64
lw $r977 $$locbase i122                 ; load word
eq $r978 $r975 $r977
jnzi $r978 .164
ji  .165
.165
addi $r979 $$locbase i112               ; get offset to local __ptr { u64, ( () | bool | slice | slice ) }
addi $r980 $$locbase i1048              ; get offset to local __ptr u64
mcpi $r980 $r979 i8                     ; copy memory
addi $r981 $$locbase i984               ; get offset to local __ptr u64
sw $$locbase $one i123                  ; store word
addi $r982 $$locbase i1048              ; get offset to local __ptr u64
lw $r983 $$locbase i131                 ; load word
addi $r984 $$locbase i984               ; get offset to local __ptr u64
lw $r985 $$locbase i123                 ; load word
eq $r986 $r983 $r985
jnzi $r986 .166
ji  .167
.167
addi $r987 $$locbase i112               ; get offset to local __ptr { u64, ( () | bool | slice | slice ) }
addi $r988 $$locbase i1064              ; get offset to local __ptr u64
mcpi $r988 $r987 i8                     ; copy memory
addi $r989 $$locbase i992               ; get offset to local __ptr u64
movi $r990 i2                           ; initialize constant into register
sw $$locbase $r990 i124                 ; store word
addi $r991 $$locbase i1064              ; get offset to local __ptr u64
lw $r992 $$locbase i133                 ; load word
addi $r993 $$locbase i992               ; get offset to local __ptr u64
lw $r994 $$locbase i124                 ; load word
eq $r995 $r992 $r994
jnzi $r995 .168
ji  .169
.169
addi $r996 $$locbase i112               ; get offset to local __ptr { u64, ( () | bool | slice | slice ) }
addi $r997 $$locbase i1072              ; get offset to local __ptr u64
mcpi $r997 $r996 i8                     ; copy memory
addi $r998 $$locbase i1000              ; get offset to local __ptr u64
movi $r999 i3                           ; initialize constant into register
sw $$locbase $r999 i125                 ; store word
addi $r1000 $$locbase i1072             ; get offset to local __ptr u64
lw $r1001 $$locbase i134                ; load word
addi $r1002 $$locbase i1000             ; get offset to local __ptr u64
lw $r1003 $$locbase i125                ; load word
eq $r1004 $r1001 $r1003
jnzi $r1004 .170
ji  .171
.171
load $r1005 data_NonConfigurable_14     ; load constant from data section
rvrt $r1005
.170
addi $r1006 $$locbase i112              ; get offset to local __ptr { u64, ( () | bool | slice | slice ) }
addi $r1007 $r1006 i8                   ; get offset to aggregate element
addi $r1008 $$locbase i1112             ; get offset to local __ptr slice
mcpi $r1008 $r1007 i16                  ; copy memory
addi $r1009 $$locbase i744              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r1010 $$locbase i520              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r1010 $r1009 i24                  ; copy memory
addi $r1011 $$locbase i296              ; get offset to local __ptr { { ptr, u64, u64 } }
movi $r1012 i3                          ; initialize constant into register
 move $$arg0 $r1012                      ; [call: abi_encode_33]: pass argument 0
 movi $$arg0 i3                          ; [call: abi_encode_33]: pass argument 0
move $$arg1 $r1010                      ; [call: abi_encode_33]: pass argument 1
move $$arg2 $r1011                      ; [call: abi_encode_33]: pass argument 2
fncall .28                              ; [call: abi_encode_33]: call function
 move $r1013 $zero                       ; [call: abi_encode_33]: copy returned unit value
 movi $r1013 i0                          ; [call: abi_encode_33]: copy returned unit value
addi $r1014 $$locbase i888              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r1014 $r1011 i24                  ; copy memory
addi $r1015 $$locbase i1112             ; get offset to local __ptr slice
addi $r1016 $$locbase i888              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r1017 $$locbase i384              ; get offset to local __ptr slice
mcpi $r1017 $r1015 i16                  ; copy memory
addi $r1018 $$locbase i400              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r1018 $r1016 i24                  ; copy memory
addi $r1019 $$locbase i160              ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r1017                      ; [call: abi_encode_26]: pass argument 0
move $$arg1 $r1018                      ; [call: abi_encode_26]: pass argument 1
move $$arg2 $r1019                      ; [call: abi_encode_26]: pass argument 2
fncall .20                              ; [call: abi_encode_26]: call function
 move $r1020 $zero                       ; [call: abi_encode_26]: copy returned unit value
 movi $r1020 i0                          ; [call: abi_encode_26]: copy returned unit value
addi $r1021 $$locbase i912              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r1021 $r1019 i24                  ; copy memory
addi $r1022 $$locbase i912              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r1023 $$locbase i568              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r1023 $r1022 i24                  ; copy memory
addi $r1024 $$locbase i592              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r1024 $r1023 i24                  ; copy memory
move $r1025 $r1024                      ; move parameter from branch to block argument
ji  .172
.168
addi $r1026 $$locbase i112              ; get offset to local __ptr { u64, ( () | bool | slice | slice ) }
addi $r1027 $r1026 i8                   ; get offset to aggregate element
addi $r1028 $$locbase i1096             ; get offset to local __ptr slice
mcpi $r1028 $r1027 i16                  ; copy memory
addi $r1029 $$locbase i744              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r1030 $$locbase i496              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r1030 $r1029 i24                  ; copy memory
addi $r1031 $$locbase i272              ; get offset to local __ptr { { ptr, u64, u64 } }
movi $r1032 i2                          ; initialize constant into register
 move $$arg0 $r1032                      ; [call: abi_encode_33]: pass argument 0
 movi $$arg0 i2                          ; [call: abi_encode_33]: pass argument 0
move $$arg1 $r1030                      ; [call: abi_encode_33]: pass argument 1
move $$arg2 $r1031                      ; [call: abi_encode_33]: pass argument 2
fncall .28                              ; [call: abi_encode_33]: call function
 move $r1033 $zero                       ; [call: abi_encode_33]: copy returned unit value
 movi $r1033 i0                          ; [call: abi_encode_33]: copy returned unit value
addi $r1034 $$locbase i840              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r1034 $r1031 i24                  ; copy memory
addi $r1035 $$locbase i1096             ; get offset to local __ptr slice
addi $r1036 $$locbase i840              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r1037 $$locbase i344              ; get offset to local __ptr slice
mcpi $r1037 $r1035 i16                  ; copy memory
addi $r1038 $$locbase i360              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r1038 $r1036 i24                  ; copy memory
addi $r1039 $$locbase i136              ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r1037                      ; [call: abi_encode_26]: pass argument 0
move $$arg1 $r1038                      ; [call: abi_encode_26]: pass argument 1
move $$arg2 $r1039                      ; [call: abi_encode_26]: pass argument 2
fncall .20                              ; [call: abi_encode_26]: call function
 move $r1040 $zero                       ; [call: abi_encode_26]: copy returned unit value
 movi $r1040 i0                          ; [call: abi_encode_26]: copy returned unit value
addi $r1041 $$locbase i864              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r1041 $r1039 i24                  ; copy memory
addi $r1042 $$locbase i864              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r1043 $$locbase i592              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r1043 $r1042 i24                  ; copy memory
move $r1025 $r1043                      ; move parameter from branch to block argument
ji  .172
.172
move $r1046 $r1025                      ; move parameter from branch to block argument
addi $r1047 $$locbase i616              ; get offset to local __ptr { { ptr, u64, u64 } }
 mcpi $r1047 $r1046 i24                  ; copy memory
 mcpi $r1047 $r1025 i24                  ; copy memory
move $r1048 $r1047                      ; move parameter from branch to block argument
ji  .173
.166
addi $r1049 $$locbase i112              ; get offset to local __ptr { u64, ( () | bool | slice | slice ) }
addi $r1050 $r1049 i23                  ; get offset to aggregate element
addi $r1051 $$locbase i1088             ; get offset to local __ptr bool
mcpi $r1051 $r1050 i1                   ; copy memory
addi $r1052 $$locbase i744              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r1053 $$locbase i472              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r1053 $r1052 i24                  ; copy memory
addi $r1054 $$locbase i248              ; get offset to local __ptr { { ptr, u64, u64 } }
 move $$arg0 $one                        ; [call: abi_encode_33]: pass argument 0
 movi $$arg0 i1                          ; [call: abi_encode_33]: pass argument 0
move $$arg1 $r1053                      ; [call: abi_encode_33]: pass argument 1
move $$arg2 $r1054                      ; [call: abi_encode_33]: pass argument 2
fncall .28                              ; [call: abi_encode_33]: call function
 move $r1055 $zero                       ; [call: abi_encode_33]: copy returned unit value
 movi $r1055 i0                          ; [call: abi_encode_33]: copy returned unit value
addi $r1056 $$locbase i792              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r1056 $r1054 i24                  ; copy memory
addi $r1057 $$locbase i1088             ; get offset to local __ptr bool
addi $r1058 $$locbase i792              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r1059 $$locbase i1056             ; get offset to local __ptr bool
mcpi $r1059 $r1057 i1                   ; copy memory
addi $r1060 $$locbase i768              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r1060 $r1058 i24                  ; copy memory
addi $r1061 $$locbase i320              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r1062 $$locbase i768              ; get offset to local __ptr { { ptr, u64, u64 } }
move $r1063 $r1062                      ; return value from ASM block with return register buffer
 mcpi $$locbase $r1063 i24               ; copy memory
 mcpi $$locbase $r1062 i24               ; copy memory
addi $r1064 $$locbase i64               ; get offset to local __ptr { ptr, u64, u64 }
mcpi $r1064 $$locbase i24               ; copy memory
lw $r1065 $$locbase i8                  ; load word
addi $r1066 $r1064 i8                   ; get offset to aggregate element
lw $r1067 $$locbase i9                  ; load word
addi $r1068 $r1064 i16                  ; get offset to aggregate element
lw $r1069 $$locbase i10                 ; load word
addi $r1070 $$locbase i1056             ; get offset to local __ptr bool
lb $r1071 $r1070 i0                     ; load byte
 add $r1072 $r1069 $one
 addi $r1072 $r1069 i1
gt $r1073 $r1072 $r1067
move $r1074 $r1065                      ; move parameter from branch to block argument
move $r1075 $r1067                      ; move parameter from branch to block argument
jnzi $r1073 .174
ji  .175
.174
movi $r1076 i2                          ; initialize constant into register
 mul $r1077 $r1067 $r1076
 add $r1078 $r1077 $one
 muli $r1077 $r1067 i2
 addi $r1078 $r1077 i1
aloc $r1078
mcp $hp $r1065 $r1069
move $r1079 $hp                         ; return value from ASM block with return register hp
 move $r1074 $r1079                      ; move parameter from branch to block argument
 move $r1074 $hp                         ; move parameter from branch to block argument
move $r1075 $r1078                      ; move parameter from branch to block argument
ji  .175
.175
move $r1083 $r1074                      ; move parameter from branch to block argument
move $r1085 $r1075                      ; move parameter from branch to block argument
 add $r1086 $r1083 $r1069
 add $r1086 $r1074 $r1069
sb $r1086 $r1071 i0                     ; store byte
 add $r1087 $r1069 $one
 addi $r1087 $r1069 i1
addi $r1088 $$locbase i88               ; get offset to local __ptr { ptr, u64, u64 }
sw $$locbase $r1083 i11                 ; store word
addi $r1089 $r1088 i8                   ; get offset to aggregate element
sw $$locbase $r1085 i12                 ; store word
addi $r1090 $r1088 i16                  ; get offset to aggregate element
sw $$locbase $r1087 i13                 ; store word
move $r1091 $r1088                      ; return value from ASM block with return register buffer
addi $r1092 $$locbase i24               ; get offset to local __ptr { ptr, u64, u64 }
 mcpi $r1092 $r1091 i24                  ; copy memory
 mcpi $r1092 $r1088 i24                  ; copy memory
mcpi $r1061 $r1092 i24                  ; copy memory
addi $r1093 $$locbase i544              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r1093 $r1061 i24                  ; copy memory
addi $r1094 $$locbase i816              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r1094 $r1093 i24                  ; copy memory
addi $r1095 $$locbase i816              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r1096 $$locbase i616              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r1096 $r1095 i24                  ; copy memory
move $r1048 $r1096                      ; move parameter from branch to block argument
ji  .173
.173
move $r1099 $r1048                      ; move parameter from branch to block argument
addi $r1100 $$locbase i640              ; get offset to local __ptr { { ptr, u64, u64 } }
 mcpi $r1100 $r1099 i24                  ; copy memory
 mcpi $r1100 $r1048 i24                  ; copy memory
move $r1101 $r1100                      ; move parameter from branch to block argument
ji  .176
.164
addi $r1102 $$locbase i744              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r1103 $$locbase i448              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r1103 $r1102 i24                  ; copy memory
addi $r1104 $$locbase i224              ; get offset to local __ptr { { ptr, u64, u64 } }
 move $$arg0 $zero                       ; [call: abi_encode_33]: pass argument 0
 movi $$arg0 i0                          ; [call: abi_encode_33]: pass argument 0
move $$arg1 $r1103                      ; [call: abi_encode_33]: pass argument 1
move $$arg2 $r1104                      ; [call: abi_encode_33]: pass argument 2
fncall .28                              ; [call: abi_encode_33]: call function
 move $r1105 $zero                       ; [call: abi_encode_33]: copy returned unit value
 movi $r1105 i0                          ; [call: abi_encode_33]: copy returned unit value
addi $r1106 $$locbase i640              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r1106 $r1104 i24                  ; copy memory
move $r1101 $r1106                      ; move parameter from branch to block argument
ji  .176
.176
move $r1109 $r1101                      ; move parameter from branch to block argument
addi $r1110 $$locbase i936              ; get offset to local __ptr { { ptr, u64, u64 } }
 mcpi $r1110 $r1109 i24                  ; copy memory
 mcpi $r1110 $r1101 i24                  ; copy memory
addi $r1111 $$locbase i936              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r1112 $$locbase i664              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r1112 $r1111 i24                  ; copy memory
addi $r1113 $$locbase i720              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r1113 $r1112 i24                  ; copy memory
addi $r1114 $$locbase i720              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r1115 $$locbase i424              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r1115 $r1114 i24                  ; copy memory
addi $r1116 $$locbase i208              ; get offset to local __ptr slice
move $$arg0 $r1115                      ; [call: as_raw_slice_28]: pass argument 0
move $$arg1 $r1116                      ; [call: as_raw_slice_28]: pass argument 1
fncall .24                              ; [call: as_raw_slice_28]: call function
 move $r1117 $zero                       ; [call: as_raw_slice_28]: copy returned unit value
 movi $r1117 i0                          ; [call: as_raw_slice_28]: copy returned unit value
addi $r1118 $$locbase i688              ; get offset to local __ptr slice
mcpi $r1118 $r1116 i16                  ; copy memory
move $r1119 $r1118                      ; move parameter from branch to block argument
ji  .177
.162
addi $r1120 $$locbase i1080             ; get offset to local __ptr u64
movi $r1121 i24                         ; initialize constant into register
sw $$locbase $r1121 i135                ; store word
addi $r1122 $$locbase i704              ; get offset to local __ptr { __ptr { u64, ( () | bool | slice | slice ) }, u64 }
addi $r1123 $$locbase i960              ; get offset to local __ptr __ptr { u64, ( () | bool | slice | slice ) }
addi $r1124 $$locbase i1080             ; get offset to local __ptr u64
mcpi $r1122 $r1123 i8                   ; copy memory
addi $r1125 $r1122 i8                   ; get offset to aggregate element
mcpi $r1125 $r1124 i8                   ; copy memory
addi $r1126 $$locbase i48               ; get offset to local __ptr { __ptr { u64, ( () | bool | slice | slice ) }, u64 }
mcpi $r1126 $r1122 i16                  ; copy memory
addi $r1127 $$locbase i688              ; get offset to local __ptr slice
mcpi $r1127 $r1126 i16                  ; copy memory
move $r1119 $r1127                      ; move parameter from branch to block argument
ji  .177
.177
move $r1130 $r1119                      ; move parameter from branch to block argument
 mcpi $r936 $r1130 i16                   ; copy memory
 mcpi $r936 $r1119 i16                   ; copy memory
ji  .53
.53
cfsi i1128                              ; [fn end: encode_allow_alias_50] free: locals 1128 byte(s), call args 0 slot(s)
move $$reta $r937                       ; [fn end: encode_allow_alias_50] restore return address
popa .52                                ; [fn end: encode_allow_alias_50] restore all used registers
jal $zero $$reta i0                     ; [fn end: encode_allow_alias_50] return from call
DIFF------------------------------
.program:
.56                                     ; --- start of function: encode_allow_alias_59 ---
pusha .56                               ; [fn init: encode_allow_alias_59]: push all used registers to stack
move $$locbase $sp                      ; [fn init: encode_allow_alias_59]: set locals base register
cfei i152                               ; [fn init: encode_allow_alias_59]: allocate: locals 152 byte(s), call args 0 slot(s)
move $r1138 $$arg0                      ; [fn init: encode_allow_alias_59]: copy argument 0 (item)
move $r1139 $$arg1                      ; [fn init: encode_allow_alias_59]: copy argument 1 (__ret_value)
move $r1140 $$reta                      ; [fn init: encode_allow_alias_59]: save return address
.179
addi $r1141 $$locbase i136              ; get offset to local __ptr __ptr ()
 sw $$locbase $r1138 i17                 ; store word
 jnzi $one .180
 sw $$locbase $$arg0 i17                 ; store word
 ji  .180
ji  .181
.181
addi $r1142 $$locbase i16               ; get offset to local __ptr { { ptr, u64, u64 } }
move $$arg0 $r1142                      ; [call: new_27]: pass argument 0
fncall .22                              ; [call: new_27]: call function
 move $r1143 $zero                       ; [call: new_27]: copy returned unit value
 movi $r1143 i0                          ; [call: new_27]: copy returned unit value
addi $r1144 $$locbase i112              ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r1144 $r1142 i24                  ; copy memory
addi $r1145 $$locbase i112              ; get offset to local __ptr { { ptr, u64, u64 } }
addi $r1146 $$locbase i56               ; get offset to local __ptr { { ptr, u64, u64 } }
mcpi $r1146 $r1145 i24                  ; copy memory
addi $r1147 $$locbase i40               ; get offset to local __ptr slice
move $$arg0 $r1146                      ; [call: as_raw_slice_28]: pass argument 0
move $$arg1 $r1147                      ; [call: as_raw_slice_28]: pass argument 1
fncall .24                              ; [call: as_raw_slice_28]: call function
 move $r1148 $zero                       ; [call: as_raw_slice_28]: copy returned unit value
 movi $r1148 i0                          ; [call: as_raw_slice_28]: copy returned unit value
addi $r1149 $$locbase i80               ; get offset to local __ptr slice
mcpi $r1149 $r1147 i16                  ; copy memory
move $r1150 $r1149                      ; move parameter from branch to block argument
ji  .182
.180
addi $r1151 $$locbase i144              ; get offset to local __ptr u64
sw $$locbase $zero i18                  ; store word
addi $r1152 $$locbase i96               ; get offset to local __ptr { __ptr (), u64 }
addi $r1153 $$locbase i136              ; get offset to local __ptr __ptr ()
addi $r1154 $$locbase i144              ; get offset to local __ptr u64
mcpi $r1152 $r1153 i8                   ; copy memory
addi $r1155 $r1152 i8                   ; get offset to aggregate element
mcpi $r1155 $r1154 i8                   ; copy memory
mcpi $$locbase $r1152 i16               ; copy memory
addi $r1156 $$locbase i80               ; get offset to local __ptr slice
mcpi $r1156 $$locbase i16               ; copy memory
move $r1150 $r1156                      ; move parameter from branch to block argument
ji  .182
.182
move $r1159 $r1150                      ; move parameter from branch to block argument
 mcpi $r1139 $r1159 i16                  ; copy memory
 mcpi $r1139 $r1150 i16                  ; copy memory
ji  .57
.57
cfsi i152                               ; [fn end: encode_allow_alias_59] free: locals 152 byte(s), call args 0 slot(s)
move $$reta $r1140                      ; [fn end: encode_allow_alias_59] restore return address
popa .56                                ; [fn end: encode_allow_alias_59] restore all used registers
jal $zero $$reta i0                     ; [fn end: encode_allow_alias_59] return from call
warning: Error message is empty
  --> test/src/e2e_vm_tests/test_programs/should_pass/language/panic_expression/panic_handling_in_unit_tests/src/main.sw:13:17
   |
...
13 |     #[error(m = "")]
   |                 -- Error enum variant "TestError::C" has an empty error message.
   |                 -- help: Consider adding a helpful error message here.
   |
____

  Compiled script "panic_handling_in_unit_tests" with 1 warning.
    Finished debug [unoptimized + fuel] target(s) [8.168 KB] in ???
     Running 20 tests, filtered 0 tests

tested -- panic_handling_in_unit_tests

      test passing_dbgs_and_logs ... ok (???, 4228 gas)
      test passing_no_dbgs_or_logs ... ok (???, 74 gas)
      test failing_revert_intrinsic ... FAILED (???, 79 gas)
      test failing_revert_function_with_dbgs_and_logs ... FAILED (???, 4352 gas)
      test failing_error_signal_assert ... FAILED (???, 756 gas)
      test failing_error_signal_assert_eq ... FAILED (???, 2892 gas)
      test failing_error_signal_assert_ne ... FAILED (???, 2882 gas)
      test failing_error_signal_require_str_error ... FAILED (???, 952 gas)
      test failing_error_signal_require_enum_error ... FAILED (???, 1113 gas)
      test failing_panic_no_arg ... FAILED (???, 611 gas)
      test failing_panic_unit_arg ... FAILED (???, 611 gas)
      test failing_panic_const_eval_str_arg ... FAILED (???, 79 gas)
      test failing_panic_const_eval_empty_str_arg ... FAILED (???, 79 gas)
      test failing_panic_const_eval_whitespace_str_arg ... FAILED (???, 79 gas)
      test failing_panic_non_const_eval_str_arg ... FAILED (???, 931 gas)
      test failing_panic_non_const_eval_str_empty_arg ... FAILED (???, 911 gas)
      test failing_panic_non_const_eval_str_whitespace_arg ... FAILED (???, 915 gas)
      test failing_panic_error_enum_arg ... FAILED (???, 1075 gas)
      test failing_panic_error_enum_arg_with_empty_msg ... FAILED (???, 1222 gas)
      test failing_panic_error_enum_arg_with_whitespace_msg ... FAILED (???, 1251 gas)

   failures:
      test failing_revert_intrinsic, "test/src/e2e_vm_tests/test_programs/should_pass/language/panic_expression/panic_handling_in_unit_tests/src/main.sw":34
           revert code: 1b669


      test failing_revert_function_with_dbgs_and_logs, "test/src/e2e_vm_tests/test_programs/should_pass/language/panic_expression/panic_handling_in_unit_tests/src/main.sw":39
           revert code: 511b3
           debug output:
[src/main.sw:41:13] "Reverting in a test function." = "Reverting in a test function."
[src/main.sw:43:13] revert_code = 332211
           decoded log values:
AsciiString { data: "This is a log from the reverting test." }, log rb: 10098701174489624218
           raw logs:
[
  {
    "LogData": {
      "data": "0000000000000026546869732069732061206c6f672066726f6d2074686520726576657274696e6720746573742e",
      "digest": "9888163918d49ac28cfad600031b81fe696ff1377d25c6faf5fc2b761608567d",
      "id": "0000000000000000000000000000000000000000000000000000000000000000",
      "is": 10368,
      "len": 46,
      "pc": 11292,
      "ptr": 67107840,
      "ra": 0,
      "rb": 10098701174489624218
    }
  }
]


      test failing_error_signal_assert, "test/src/e2e_vm_tests/test_programs/should_pass/language/panic_expression/panic_handling_in_unit_tests/src/main.sw":49
           revert code: ffffffffffff0004
             error message: Failing call to `std::assert::assert`.
           debug output:
[src/main.sw:51:13] TestError::A = A


      test failing_error_signal_assert_eq, "test/src/e2e_vm_tests/test_programs/should_pass/language/panic_expression/panic_handling_in_unit_tests/src/main.sw":55
           revert code: ffffffffffff0003
             error message: Failing call to `std::assert::assert_eq`.
           debug output:
[src/main.sw:57:13] "This is a `__dbg` before the failing assert_eq." = "This is a `__dbg` before the failing assert_eq."
           decoded log values:
AsciiString { data: "We will get logged the asserted values and this message." }, log rb: 10098701174489624218
1111, log rb: 1515152261580153489
2222, log rb: 1515152261580153489
           raw logs:
[
  {
    "LogData": {
      "data": "000000000000003857652077696c6c20676574206c6f67676564207468652061737365727465642076616c75657320616e642074686973206d6573736167652e",
      "digest": "7cd2ee64a324feb34d768ff087eed6d5f4f55a01f328f1808211224a996293dd",
      "id": "0000000000000000000000000000000000000000000000000000000000000000",
      "is": 10368,
      "len": 64,
      "pc": 12476,
      "ptr": 67107840,
      "ra": 0,
      "rb": 10098701174489624218
    }
  },
  {
    "LogData": {
      "data": "0000000000000457",
      "digest": "a6347082809348ffb57ff10f841e60b202fc450a1c46f292b508cf878602fb21",
      "id": "0000000000000000000000000000000000000000000000000000000000000000",
      "is": 10368,
      "len": 8,
      "pc": 15644,
      "ptr": 19256,
      "ra": 0,
      "rb": 1515152261580153489
    }
  },
  {
    "LogData": {
      "data": "00000000000008ae",
      "digest": "c423e036030a4b16c5b00ff36181839b15b8c82274149ca378101d459a25e30c",
      "id": "0000000000000000000000000000000000000000000000000000000000000000",
      "is": 10368,
      "len": 8,
      "pc": 15644,
      "ptr": 19256,
      "ra": 0,
      "rb": 1515152261580153489
    }
  }
]


      test failing_error_signal_assert_ne, "test/src/e2e_vm_tests/test_programs/should_pass/language/panic_expression/panic_handling_in_unit_tests/src/main.sw":62
           revert code: ffffffffffff0005
             error message: Failing call to `std::assert::assert_ne`.
           debug output:
[src/main.sw:64:13] "This is a `__dbg` before the failing assert_ne." = "This is a `__dbg` before the failing assert_ne."
           decoded log values:
AsciiString { data: "We will get logged the asserted values and this message." }, log rb: 10098701174489624218
3333, log rb: 1515152261580153489
3333, log rb: 1515152261580153489
           raw logs:
[
  {
    "LogData": {
      "data": "000000000000003857652077696c6c20676574206c6f67676564207468652061737365727465642076616c75657320616e642074686973206d6573736167652e",
      "digest": "7cd2ee64a324feb34d768ff087eed6d5f4f55a01f328f1808211224a996293dd",
      "id": "0000000000000000000000000000000000000000000000000000000000000000",
      "is": 10368,
      "len": 64,
      "pc": 12848,
      "ptr": 67107840,
      "ra": 0,
      "rb": 10098701174489624218
    }
  },
  {
    "LogData": {
      "data": "0000000000000d05",
      "digest": "13a0755cd62d23f5931afac99688b50e3c6049a17811a340a79597c51c92fccd",
      "id": "0000000000000000000000000000000000000000000000000000000000000000",
      "is": 10368,
      "len": 8,
      "pc": 15644,
      "ptr": 19248,
      "ra": 0,
      "rb": 1515152261580153489
    }
  },
  {
    "LogData": {
      "data": "0000000000000d05",
      "digest": "13a0755cd62d23f5931afac99688b50e3c6049a17811a340a79597c51c92fccd",
      "id": "0000000000000000000000000000000000000000000000000000000000000000",
      "is": 10368,
      "len": 8,
      "pc": 15644,
      "ptr": 19248,
      "ra": 0,
      "rb": 1515152261580153489
    }
  }
]


      test failing_error_signal_require_str_error, "test/src/e2e_vm_tests/test_programs/should_pass/language/panic_expression/panic_handling_in_unit_tests/src/main.sw":69
           revert code: ffffffffffff0000
             error message: Failing call to `std::revert::require`.
           decoded log values:
AsciiString { data: "This is an error message in a `require` call." }, log rb: 10098701174489624218
           raw logs:
[
  {
    "LogData": {
      "data": "000000000000002d5468697320697320616e206572726f72206d65737361676520696e2061206072657175697265602063616c6c2e",
      "digest": "2d960aa1b6936dd00a6d51e51e3faab405f35bfc49ce2093b7ba13336d583104",
      "id": "0000000000000000000000000000000000000000000000000000000000000000",
      "is": 10368,
      "len": 53,
      "pc": 13060,
      "ptr": 67107840,
      "ra": 0,
      "rb": 10098701174489624218
    }
  }
]


      test failing_error_signal_require_enum_error, "test/src/e2e_vm_tests/test_programs/should_pass/language/panic_expression/panic_handling_in_unit_tests/src/main.sw":74
           revert code: ffffffffffff0000
             error message: Failing call to `std::revert::require`.
           decoded log values:
B(true), log rb: 8516346929033386016
           raw logs:
[
  {
    "LogData": {
      "data": "000000000000000101",
      "digest": "bd87b2cda99df5b642ac9c0a97d3bc76f9921e2cce16058faa44bc954dbb065f",
      "id": "0000000000000000000000000000000000000000000000000000000000000000",
      "is": 10368,
      "len": 9,
      "pc": 13196,
      "ptr": 67107840,
      "ra": 0,
      "rb": 8516346929033386016
    }
  }
]


      test failing_panic_no_arg, "test/src/e2e_vm_tests/test_programs/should_pass/language/panic_expression/panic_handling_in_unit_tests/src/main.sw":79
           revert code: 8000000000000000
             panic value:   ()
             panicked:      in panic_handling_in_unit_tests::failing_panic_no_arg
                                at panic_handling_in_unit_tests@0.1.2, src/main.sw:81:5
           decoded log values:
(), log rb: 3330666440490685604
           raw logs:
[
  {
    "LogData": {
      "data": "",
      "digest": "e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855",
      "id": "0000000000000000000000000000000000000000000000000000000000000000",
      "is": 10368,
      "len": 0,
      "pc": 13264,
      "ptr": 18792,
      "ra": 0,
      "rb": 3330666440490685604
    }
  }
]


      test failing_panic_unit_arg, "test/src/e2e_vm_tests/test_programs/should_pass/language/panic_expression/panic_handling_in_unit_tests/src/main.sw":84
           revert code: 8080000000000000
             panic value:   ()
             panicked:      in panic_handling_in_unit_tests::failing_panic_unit_arg
                                at panic_handling_in_unit_tests@0.1.2, src/main.sw:86:5
           decoded log values:
(), log rb: 3330666440490685604
           raw logs:
[
  {
    "LogData": {
      "data": "",
      "digest": "e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855",
      "id": "0000000000000000000000000000000000000000000000000000000000000000",
      "is": 10368,
      "len": 0,
      "pc": 13316,
      "ptr": 18792,
      "ra": 0,
      "rb": 3330666440490685604
    }
  }
]


      test failing_panic_const_eval_str_arg, "test/src/e2e_vm_tests/test_programs/should_pass/language/panic_expression/panic_handling_in_unit_tests/src/main.sw":89
           revert code: 8100000000000000
             panic message: Panicked with a string argument.
             panicked:      in panic_handling_in_unit_tests::failing_panic_const_eval_str_arg
                                at panic_handling_in_unit_tests@0.1.2, src/main.sw:91:5


      test failing_panic_const_eval_empty_str_arg, "test/src/e2e_vm_tests/test_programs/should_pass/language/panic_expression/panic_handling_in_unit_tests/src/main.sw":94
           revert code: 8180000000000000
             panic message: 
             panicked:      in panic_handling_in_unit_tests::failing_panic_const_eval_empty_str_arg
                                at panic_handling_in_unit_tests@0.1.2, src/main.sw:96:5


      test failing_panic_const_eval_whitespace_str_arg, "test/src/e2e_vm_tests/test_programs/should_pass/language/panic_expression/panic_handling_in_unit_tests/src/main.sw":99
           revert code: 8200000000000000
             panic message:     
             panicked:      in panic_handling_in_unit_tests::failing_panic_const_eval_whitespace_str_arg
                                at panic_handling_in_unit_tests@0.1.2, src/main.sw:101:5


      test failing_panic_non_const_eval_str_arg, "test/src/e2e_vm_tests/test_programs/should_pass/language/panic_expression/panic_handling_in_unit_tests/src/main.sw":104
           revert code: 8280000000000001
             panic message: Panicked with a non-const evaluated string argument.
             panicked:      in panic_handling_in_unit_tests::non_const_eval_str
                               at panic_handling_in_unit_tests@0.1.2, src/main.sw:135:5
             backtrace:     called in panic_handling_in_unit_tests::failing_panic_non_const_eval_str_arg
                                at panic_handling_in_unit_tests@0.1.2, src/main.sw:106:11
           decoded log values:
AsciiString { data: "Panicked with a non-const evaluated string argument." }, log rb: 10098701174489624218
           raw logs:
[
  {
    "LogData": {
      "data": "000000000000003450616e69636b656420776974682061206e6f6e2d636f6e7374206576616c756174656420737472696e6720617267756d656e742e",
      "digest": "3fcfc985ef72a10bd0d1f12fd2d259a10a261f745c95a0fea304d9b2068e5eb9",
      "id": "0000000000000000000000000000000000000000000000000000000000000000",
      "is": 10368,
      "len": 60,
      "pc": 13448,
      "ptr": 67107840,
      "ra": 0,
      "rb": 10098701174489624218
    }
  }
]


      test failing_panic_non_const_eval_str_empty_arg, "test/src/e2e_vm_tests/test_programs/should_pass/language/panic_expression/panic_handling_in_unit_tests/src/main.sw":109
           revert code: 8280000000000002
             panic message: 
             panicked:      in panic_handling_in_unit_tests::non_const_eval_str
                               at panic_handling_in_unit_tests@0.1.2, src/main.sw:135:5
             backtrace:     called in panic_handling_in_unit_tests::failing_panic_non_const_eval_str_empty_arg
                                at panic_handling_in_unit_tests@0.1.2, src/main.sw:111:11
           decoded log values:
AsciiString { data: "" }, log rb: 10098701174489624218
           raw logs:
[
  {
    "LogData": {
      "data": "0000000000000000",
      "digest": "af5570f5a1810b7af78caf4bc70a660f0df51e42baf91d4de5b2328de0e83dfc",
      "id": "0000000000000000000000000000000000000000000000000000000000000000",
      "is": 10368,
      "len": 8,
      "pc": 13552,
      "ptr": 67107840,
      "ra": 0,
      "rb": 10098701174489624218
    }
  }
]


      test failing_panic_non_const_eval_str_whitespace_arg, "test/src/e2e_vm_tests/test_programs/should_pass/language/panic_expression/panic_handling_in_unit_tests/src/main.sw":114
           revert code: 8280000000000003
             panic message:     
             panicked:      in panic_handling_in_unit_tests::non_const_eval_str
                               at panic_handling_in_unit_tests@0.1.2, src/main.sw:135:5
             backtrace:     called in panic_handling_in_unit_tests::failing_panic_non_const_eval_str_whitespace_arg
                                at panic_handling_in_unit_tests@0.1.2, src/main.sw:116:11
           decoded log values:
AsciiString { data: "    " }, log rb: 10098701174489624218
           raw logs:
[
  {
    "LogData": {
      "data": "000000000000000420202020",
      "digest": "b115410b146aa17a70b8a1fdfd669361410625ed4415cc65b89b718543dc4f32",
      "id": "0000000000000000000000000000000000000000000000000000000000000000",
      "is": 10368,
      "len": 12,
      "pc": 13660,
      "ptr": 67107840,
      "ra": 0,
      "rb": 10098701174489624218
    }
  }
]


      test failing_panic_error_enum_arg, "test/src/e2e_vm_tests/test_programs/should_pass/language/panic_expression/panic_handling_in_unit_tests/src/main.sw":119
           revert code: 8480000000000000
             panic message: Error B has occurred, with a boolean value.
             panic value:   B(true)
             panicked:      in panic_handling_in_unit_tests::failing_panic_error_enum_arg
                                at panic_handling_in_unit_tests@0.1.2, src/main.sw:121:5
           decoded log values:
B(true), log rb: 8516346929033386016
           raw logs:
[
  {
    "LogData": {
      "data": "000000000000000101",
      "digest": "bd87b2cda99df5b642ac9c0a97d3bc76f9921e2cce16058faa44bc954dbb065f",
      "id": "0000000000000000000000000000000000000000000000000000000000000000",
      "is": 10368,
      "len": 9,
      "pc": 13740,
      "ptr": 67107840,
      "ra": 0,
      "rb": 8516346929033386016
    }
  }
]


      test failing_panic_error_enum_arg_with_empty_msg, "test/src/e2e_vm_tests/test_programs/should_pass/language/panic_expression/panic_handling_in_unit_tests/src/main.sw":124
           revert code: 8500000000000000
             panic message: 
             panic value:   C(AsciiString { data: "This is an error with an empty error message." })
             panicked:      in panic_handling_in_unit_tests::failing_panic_error_enum_arg_with_empty_msg
                                at panic_handling_in_unit_tests@0.1.2, src/main.sw:126:5
           decoded log values:
C(AsciiString { data: "This is an error with an empty error message." }), log rb: 8516346929033386016
           raw logs:
[
  {
    "LogData": {
      "data": "0000000000000002000000000000002d5468697320697320616e206572726f72207769746820616e20656d707479206572726f72206d6573736167652e",
      "digest": "5f00877918eba9a1e5052799a3f57841731138a154d31a1af5575a05feca0c0b",
      "id": "0000000000000000000000000000000000000000000000000000000000000000",
      "is": 10368,
      "len": 61,
      "pc": 13844,
      "ptr": 67107840,
      "ra": 0,
      "rb": 8516346929033386016
    }
  }
]


      test failing_panic_error_enum_arg_with_whitespace_msg, "test/src/e2e_vm_tests/test_programs/should_pass/language/panic_expression/panic_handling_in_unit_tests/src/main.sw":129
           revert code: 8580000000000000
             panic message:     
             panic value:   D(AsciiString { data: "This is an error with a whitespace error message." })
             panicked:      in panic_handling_in_unit_tests::failing_panic_error_enum_arg_with_whitespace_msg
                                at panic_handling_in_unit_tests@0.1.2, src/main.sw:131:5
           decoded log values:
D(AsciiString { data: "This is an error with a whitespace error message." }), log rb: 8516346929033386016
           raw logs:
[
  {
    "LogData": {
      "data": "000000000000000300000000000000315468697320697320616e206572726f72207769746820612077686974657370616365206572726f72206d6573736167652e",
      "digest": "97d9bb6a2f1bb59a495f69bddec5aeaf7a072e5424634d2cb56942b8d0b888e7",
      "id": "0000000000000000000000000000000000000000000000000000000000000000",
      "is": 10368,
      "len": 65,
      "pc": 13948,
      "ptr": 67107840,
      "ra": 0,
      "rb": 8516346929033386016
    }
  }
]



test result: FAILED. 2 passed; 18 failed; finished in ???

    Finished in ???
error: Some tests failed.
