<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>The Sway Reference</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Sway Reference</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/FuelLabs/sway" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="the-sway-reference"><a class="header" href="#the-sway-reference">The Sway Reference</a></h1>
<!-- markdown-link-check-disable -->
<p>This is the technical reference for the Sway programming language. For a prose explanation and introduction to the language, please refer to the <a href="https://fuellabs.github.io/sway/v0.61.1/book/">Sway Book</a>.</p>
<!-- markdown-link-check-enable -->
<div style="break-before: page; page-break-before: always;"></div><h1 id="installation"><a class="header" href="#installation">Installation</a></h1>
<p>The <code>Sway toolchain</code> is required to compile <code>Sway</code> programs.</p>
<p>There are three ways to install the <code>Sway toolchain</code>:</p>
<ul>
<li><a href="documentation/introduction/installation/fuelup.html"><code>Fuelup</code></a></li>
<li><a href="documentation/introduction/installation/cargo.html"><code>Cargo</code></a></li>
<li><a href="documentation/introduction/installation/source.html"><code>From Source</code></a></li>
</ul>
<p>The supported operating systems include Linux and macOS; however, Windows is <a href="https://github.com/FuelLabs/sway/issues/1526"><code>unsupported</code></a>.</p>
<h2 id="fuelup"><a class="header" href="#fuelup">Fuelup</a></h2>
<p><a href="documentation/introduction/installation/fuelup.html"><code>Fuelup</code></a> is the recommended tool for installation and management of the toolchain.</p>
<h2 id="cargo"><a class="header" href="#cargo">Cargo</a></h2>
<p><code>Cargo</code> may be used instead of <a href="documentation/introduction/installation/fuelup.html"><code>Fuelup</code></a>; however, the user needs to manage the toolchain themselves.</p>
<!-- markdown-link-check-disable -->
<p>The advantage of using <code>Cargo</code> is the installation of <a href="https://fuellabs.github.io/sway/v0.61.1/book/forc/plugins/index.html"><code>plugins</code></a> that have not been added into <a href="documentation/introduction/installation/fuelup.html"><code>Fuelup</code></a>.</p>
<p>The disadvantage occurs when <a href="documentation/introduction/installation/fuelup.html"><code>Fuelup</code></a> and <code>Cargo</code> are used in tandem because the latest <a href="https://fuellabs.github.io/sway/v0.61.1/book/forc/plugins/index.html"><code>plugins</code></a> may not be recognized.</p>
<!-- markdown-link-check-enable -->
<h2 id="source"><a class="header" href="#source">Source</a></h2>
<p>The latest features may be accessed when installing from <a href="documentation/introduction/installation/source.html"><code>source</code></a>; however, the features may not be ready for release and lead to unstable behavior.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="fuelup-1"><a class="header" href="#fuelup-1">Fuelup</a></h1>
<p><a href="https://github.com/FuelLabs/fuelup"><code>Fuelup</code></a> is a tool used to manage the Sway toolchain. It allows the user to download compiled binaries and switch between different versions of Sway.</p>
<p>The installation instructions can be found at the start of the <a href="https://fuellabs.github.io/fuelup/latest"><code>Fuelup Book</code></a>.</p>
<p>After installing <a href="https://github.com/FuelLabs/fuelup"><code>fuelup</code></a> run the following command to check the version:</p>
<pre><code class="language-bash">fuelup --version
</code></pre>
<p>The output may look similar to:</p>
<pre><code class="language-bash">fuelup 0.13.0
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cargo-1"><a class="header" href="#cargo-1">Cargo</a></h1>
<!-- markdown-link-check-disable -->
<p>Cargo can be used to install the Sway toolchain with various <a href="https://fuellabs.github.io/sway/v0.61.1/book/forc/plugins/index.html"><code>plugins</code></a>.</p>
<!-- markdown-link-check-enable -->
<h2 id="dependencies"><a class="header" href="#dependencies">Dependencies</a></h2>
<p>A prerequisite for installing and using Sway is the <a href="https://www.rust-lang.org/tools/install"><code>Rust toolchain</code></a> running on the <code>stable</code> channel.</p>
<p>After installing the <code>Rust toolchain</code> run the following command to check default channel:</p>
<pre><code class="language-bash">rustup toolchain list
</code></pre>
<p>The output may look similar to:</p>
<pre><code class="language-bash">stable-x86_64-unknown-linux-gnu (default)
</code></pre>
<h2 id="installation--updating"><a class="header" href="#installation--updating">Installation &amp; Updating</a></h2>
<p>The <code>Sway toolchain</code> can be installed/updated with:</p>
<pre><code class="language-bash">cargo install forc
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="from-source"><a class="header" href="#from-source">From Source</a></h1>
<p>The <code>Sway toolchain</code> can be built directly from the <a href="https://github.com/FuelLabs/sway"><code>Sway repository</code></a>.</p>
<h2 id="installation--updating-1"><a class="header" href="#installation--updating-1">Installation &amp; Updating</a></h2>
<!-- markdown-link-check-disable -->
<p>In the root of the repository <code>/sway/&lt;here&gt;</code> build <a href="https://fuellabs.github.io/sway/v0.61.1/book/forc/commands/index.html"><code>forc</code></a> with the following command:</p>
<!-- markdown-link-check-enable -->
<pre><code class="language-bash">cargo build
</code></pre>
<p>The executable binary can be found in <code>/sway/target/debug/forc</code>.</p>
<h2 id="using-the-toolchain"><a class="header" href="#using-the-toolchain">Using the Toolchain</a></h2>
<p>After installing run the following command to check the version:</p>
<pre><code class="language-bash">/sway/target/debug/forc --version
</code></pre>
<p>The output may look similar to:</p>
<pre><code class="language-bash">forc 0.31.2
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="fuel-core"><a class="header" href="#fuel-core">Fuel Core</a></h1>
<p>The <code>Fuel toolchain</code> is an extension of the <a href="documentation/introduction/installation/index.html"><code>Sway toolchain</code></a>.</p>
<p>It consists of a full node known as <a href="https://github.com/FuelLabs/fuel-core"><code>Fuel Core</code></a> and it enables deployment and testing via the <a href="documentation/introduction/installation/../../misc/sdk/rust.html"><code>Rust SDK</code></a>.</p>
<h2 id="installation--updating-2"><a class="header" href="#installation--updating-2">Installation &amp; Updating</a></h2>
<p><a href="https://github.com/FuelLabs/fuel-core"><code>Fuel Core</code></a> can be installed/updated with:</p>
<pre><code class="language-bash">cargo install fuel-core
</code></pre>
<p>There may be additional <a href="https://github.com/FuelLabs/fuel-core#building"><code>system dependencies</code></a> required for installation.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sway-program-types"><a class="header" href="#sway-program-types">Sway Program Types</a></h1>
<p>A Sway program is a file ending with the extension <code>.sw</code>, e.g. <code>main.sw</code>, and the first line of the file is a declaration of the <em>type</em> of program.</p>
<p>A Sway program can be one of four types:</p>
<ul>
<li><a href="documentation/language/program-types/contract.html">contract</a>
<ul>
<li>Primarily used for protocols or systems that operate within a fixed set of rules e.g. staking contracts, decentralized exchanges, etc.</li>
</ul>
</li>
<li><a href="documentation/language/program-types/libraries/index.html">library</a>
<ul>
<li>Reusable code for handling common operations</li>
</ul>
</li>
<li><a href="documentation/language/program-types/script.html">script</a>
<ul>
<li>Used for complex, multi-step, on-chain interactions that won't persist, such as using a decentralized exchange to create a leveraged position (borrow, swap, re-collateralize)</li>
</ul>
</li>
<li><a href="documentation/language/program-types/predicate.html">predicate</a>
<ul>
<li>A set of preconditions to the construction of a transaction, the result of which must be a Boolean value of <code>true</code> in order for the transaction to be considered valid</li>
</ul>
</li>
</ul>
<h2 id="sway-project-types"><a class="header" href="#sway-project-types">Sway Project Types</a></h2>
<p>A project type in Sway refers to which program type is in the main file of the project.</p>
<p>This means that there are four types of projects:</p>
<ul>
<li>contracts</li>
<li>libraries</li>
<li>scripts</li>
<li>predicates</li>
</ul>
<p>All four projects can contain multiple library files in the <code>src</code> directory.</p>
<p>There is a caveat when it comes to <em>contracts</em>, <em>scripts</em> and <em>predicates</em> and it's as follows:</p>
<ul>
<li>A project can at most contain <em>any one</em> of a contract, script or predicate.</li>
</ul>
<p>This means that a project cannot contain more than one contract, one script, one predicate and it cannot mix them together.</p>
<h2 id="entry-points"><a class="header" href="#entry-points">Entry Points</a></h2>
<p>An entry point is the starting point of execution for a program.</p>
<p>Since a library is not directly deployable to the blockchain it does not have an entry point and instead its code is exported for use within other programs.</p>
<p>Unlike libraries; contracts, scripts and predicates all have an entry point. Contracts expose an <code>Application Binary Interface (ABI)</code> while scripts and predicates expose a <code>main()</code> function for entry.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="smart-contracts"><a class="header" href="#smart-contracts">Smart Contracts</a></h1>
<p>A smart contract is a piece of bytecode that can be deployed to a blockchain via a <a href="https://github.com/FuelLabs/fuel-specs/blob/master/src/tx-format/index.md">transaction</a>.</p>
<p>It can be called in the same way that an API may be called to perform computation and store and retrieve data from a database.</p>
<p>A smart contract consists of two parts:</p>
<!--no toc-->
<ul>
<li><a href="documentation/language/program-types/contract.html#application-binary-interface-abi">Application Binary Interface (<code>ABI</code>)</a></li>
<li><a href="documentation/language/program-types/contract.html#implementation-the-abi">Implementation of the <code>ABI</code></a></li>
</ul>
<h2 id="application-binary-interface-abi"><a class="header" href="#application-binary-interface-abi">Application Binary Interface (<code>ABI</code>)</a></h2>
<p>The <code>ABI</code> is a structure which defines the endpoints that a contract exposes for calls. That is to say that functions defined in the <code>ABI</code> are considered to be <code>external</code> and thus a contract cannot call its own functions.</p>
<p>The following example demonstrates an interface for a wallet which is able to receive and send funds.</p>
<p>The structure begins by using the keyword <code>abi</code> followed by the name of the contract.</p>
<p>Inside the declaration are function signatures, annotations denoting the interaction with storage and documentation comments outlining the functionality.</p>
<pre><code class="language-sway">library;

abi Wallet {
    /// When the BASE_ASSET is sent to this function the internal contract balance is incremented
    #[storage(read, write)]
    fn receive_funds();

    /// Sends `amount_to_send` of the BASE_ASSET to `recipient`
    ///
    /// # Arguments
    ///
    /// - `amount_to_send`: amount of BASE_ASSET to send
    /// - `recipient`: user to send the BASE_ASSET to
    ///
    /// # Reverts
    ///
    /// * When the caller is not the owner of the wallet
    /// * When the amount being sent is greater than the amount in the contract
    #[storage(read, write)]
    fn send_funds(amount_to_send: u64, recipient: Identity);
}
</code></pre>
<h2 id="implementation-the-abi"><a class="header" href="#implementation-the-abi">Implementation the <code>ABI</code></a></h2>
<p>Similar to <a href="https://doc.rust-lang.org/rust-by-example/trait.html">traits</a> in Rust implementing the <code>ABI</code> is done with the syntax <code>impl &lt;name-of-abi&gt; for Contract</code>.</p>
<p>All functions defined in the <code>ABI</code> must be declared in the implementation.</p>
<p>Since the interface is defined outside of the contract we must import it using the <code>use</code> syntax before we can use it.</p>
<pre><code class="language-sway">contract;

use interface::Wallet;

impl Wallet for Contract {
    #[storage(read, write)]
    fn receive_funds() {
        // function implementation
    }

    #[storage(read, write)]
    fn send_funds(amount_to_send: u64, recipient: Identity) {
        // function implementation
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="library"><a class="header" href="#library">Library</a></h1>
<p>A library is used to contain code that performs common operations in order to prevent code duplication.</p>
<h2 id="definition"><a class="header" href="#definition">Definition</a></h2>
<p>Libraries are defined using the <code>library</code> keyword at the beginning of a file.</p>
<pre><code class="language-sway">library;
</code></pre>
<h2 id="accessibility"><a class="header" href="#accessibility">Accessibility</a></h2>
<p>Code defined inside a library, but more generally anywhere inside a Sway project, is considered to be <code>private</code> which means that it is inaccessible to other files unless explicitly exposed.</p>
<p>Code can be exposed through a two step process:</p>
<ul>
<li>Add a <code>pub</code> keyword at the start of some code</li>
<li>Specify the <a href="documentation/language/program-types/libraries/external.html">library</a> in the <code>Forc.toml</code> file as a dependency and then import the <code>pub</code> declaration</li>
</ul>
<pre><code class="language-sway">library;

// Cannot import because the `pub` keyword is missing
fn foo() {}

// Can import everything below because they are using the `pub` keyword
pub const ONE = __to_str_array("1");

pub struct MyStruct {}

impl MyStruct {
    pub fn my_function() {}
}

pub enum MyEnum {
    Variant: (),
}

pub fn bar() {}

pub trait MyTrait {
    fn my_function();
}
</code></pre>
<p>The following structures can be marked as <code>pub</code>:</p>
<ul>
<li>Globally defined constants</li>
<li>Structs</li>
<li>Enums</li>
<li>Functions</li>
<li>Traits</li>
</ul>
<h2 id="deployment"><a class="header" href="#deployment">Deployment</a></h2>
<p>Libraries cannot be directly deployed to a blockchain, but they can be deployed as part of a <a href="documentation/language/program-types/libraries/../contract.html">contract</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="internal-libraries"><a class="header" href="#internal-libraries">Internal Libraries</a></h1>
<p>A library is internal to a project if it is in the same source <code>src</code> directory as the other program files.</p>
<pre><code class="language-bash">$ tree
.
├── Cargo.toml
├── Forc.toml
└── src
    ├── lib.sw
    └── my_library.sw
</code></pre>
<p>To be able to use our library <code>my_library.sw</code> in <code>lib.sw</code> there are two steps to take:</p>
<ol>
<li>Bring our library into scope by using the <code>mod</code> keyword followed by the library name</li>
<li>Use the <code>use</code> keyword to selectively import various items from the library</li>
</ol>
<pre><code class="language-sway">library;

mod my_library;

use my_library::bar;

// `bar` from `my_library` is now available throughout the file
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="external-libraries"><a class="header" href="#external-libraries">External Libraries</a></h1>
<p>An external library is a library that is outside of the <code>src</code> directory (most likely in an entirely different project).</p>
<pre><code class="language-bash">$ tree
.
├── my_library
│   ├── Cargo.toml
│   ├── Forc.toml
│   └─── src
│       └── lib.sw
│
└── my_other_library
    ├── Cargo.toml
    ├── Forc.toml
    └─── src
        └── lib.sw
</code></pre>
<h2 id="libraries"><a class="header" href="#libraries">Libraries</a></h2>
<h3 id="my_other_library"><a class="header" href="#my_other_library">my_other_library</a></h3>
<p><code>my_other_library</code> has a function <code>quix()</code> which can be imported into <code>my_library</code> because it uses the <code>pub</code> keyword.</p>
<pre><code class="language-sway">library;

pub fn quix() {}
</code></pre>
<h3 id="my_library"><a class="header" href="#my_library">my_library</a></h3>
<p>To be able to use <code>quix()</code> inside <code>my_library</code> there are two steps to take.</p>
<h4 id="add-to-dependencies"><a class="header" href="#add-to-dependencies">Add to Dependencies</a></h4>
<p>Add <code>my_other_library</code> as a dependency under the <code>[dependencies]</code> section of the <code>my_library</code> <code>Forc.toml</code> file.</p>
<pre><code class="language-bash">[project]
authors = ["Fuel Labs &lt;contact@fuel.sh&gt;"]
entry = "lib.sw"
license = "Apache-2.0"
name = "my_library"

[dependencies]
my_other_library = { path = "../my_other_library" }
std = { path = "../../../../../../../../../sway-lib-std" }
</code></pre>
<h4 id="import"><a class="header" href="#import">Import</a></h4>
<p>Use the <code>use</code> keyword to selectively import our code from <code>my_other_library</code></p>
<pre><code class="language-sway">library;

use my_other_library::quix;

// `quix` from `my_other_library` is now available throughout the file
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="scripts"><a class="header" href="#scripts">Scripts</a></h1>
<p>A script is an executable that does not need to be deployed because it only exists during a transaction.</p>
<p>It can be used to replicate the functionality of contracts, such as routers, without the cost of deployment or increase of the blockchain size.</p>
<p>Some properties of a script include:</p>
<ul>
<li>It cannot be called by a <a href="documentation/language/program-types/contract.html">contract</a></li>
<li>It is stateless but can interact with <a href="documentation/language/program-types/../../operations/storage/index.html">storage</a> through a contract</li>
<li>Can call multiple contracts</li>
</ul>
<h2 id="example"><a class="header" href="#example">Example</a></h2>
<p>The following example demonstrates a script which takes one argument and <a href="documentation/language/program-types/../functions/return.html">returns</a> the <a href="documentation/language/program-types/../built-ins/boolean.html">Boolean</a> value of <code>true</code>.</p>
<pre><code class="language-sway">script;

// All scripts require a main function. The return type is optional.
fn main(amount: u64) -&gt; bool {
    true
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="predicates"><a class="header" href="#predicates">Predicates</a></h1>
<p>A predicate is an executable that represents a UTXO spending condition, such as a multisig predicate, which has restrictions on the VM instructions that can be used .</p>
<p>It does not need to be deployed to a blockchain because it only exists during a transaction. That being said, the predicate root is on chain as the owner of one or more UTXOs.</p>
<p>Predicates can neither read from nor write to any contract state. Moreover, they cannot use any <a href="https://docs.fuel.network/docs/specs/fuel-vm/instruction-set/#contract-instructions">contract instructions</a>.</p>
<h2 id="transfer-coins-to-a-predicate"><a class="header" href="#transfer-coins-to-a-predicate">Transfer Coins to a Predicate</a></h2>
<p>In Fuel, coins can be sent to an address uniquely representing a particular predicate's bytecode (the bytecode root, calculated <a href="https://github.com/FuelLabs/fuel-specs/blob/master/src/identifiers/contract-id.md">here</a>).</p>
<h2 id="spending-predicate-coins"><a class="header" href="#spending-predicate-coins">Spending Predicate Coins</a></h2>
<p>The coin UTXOs become spendable not on the provision of a valid signature, but rather if the supplied predicate both has a root that matches their owner, and <a href="https://github.com/FuelLabs/fuel-specs/blob/master/src/fuel-vm/index.md#predicate-verification">evaluates</a> to <code>true</code>.</p>
<p>If a predicate reverts, or tries to access impure VM opcodes, the evaluation is automatically <code>false</code>.</p>
<h2 id="spending-conditions"><a class="header" href="#spending-conditions">Spending Conditions</a></h2>
<p>Predicates may introspect the transaction spending their coins (inputs, outputs, script bytecode, etc.) and may take runtime arguments (the <code>predicateData</code>), either or both of which may affect the evaluation of the predicate.</p>
<h2 id="example-1"><a class="header" href="#example-1">Example</a></h2>
<p>Similar to a <a href="documentation/language/program-types/script.html">script</a>, a predicate consists of a single <code>main()</code> function which can take any number of arguments but must return a <a href="documentation/language/program-types/../built-ins/boolean.html">Boolean</a>. In order for the predicate to be valid, the returned <a href="documentation/language/program-types/../built-ins/boolean.html">Boolean</a> value must be <code>true</code>.</p>
<pre><code class="language-sway">predicate;

// All predicates require a main function which return a Boolean value.
fn main(amount: u64) -&gt; bool {
    true
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="built-in-types"><a class="header" href="#built-in-types">Built-in Types</a></h1>
<p>Sway is a statically typed language therefore every value must be known at compile time. This means that each value must have a <em>type</em> and the compiler can <em>usually</em> infer the type without the user being required to specify it.</p>
<p>Sway provides a number of out-of-the-box (primitive) types which can be used to construct more complex data structures and programs.</p>
<h2 id="primitive-types"><a class="header" href="#primitive-types">Primitive Types</a></h2>
<p>Sway has the following primitive types:</p>
<ol>
<li><a href="documentation/language/built-ins/numeric.html">Numerics</a>
<ol>
<li><code>u8</code> (8-bit unsigned integer)</li>
<li><code>u16</code> (16-bit unsigned integer)</li>
<li><code>u32</code> (32-bit unsigned integer)</li>
<li><code>u64</code> (64-bit unsigned integer)</li>
<li><code>u256</code> (256-bit unsigned integer)</li>
<li><code>hexadecimal</code>, <code>binary</code> &amp; <code>base-10</code> syntax</li>
</ol>
</li>
<li><a href="documentation/language/built-ins/boolean.html">Boolean</a>
<ol>
<li><code>bool</code> (true or false)</li>
</ol>
</li>
<li><a href="documentation/language/built-ins/string.html">Strings</a>
<ol>
<li><code>str</code> (string slice)</li>
<li><code>str[n]</code> (fixed-length string of size n)</li>
</ol>
</li>
<li><a href="documentation/language/built-ins/b256.html">Bytes</a>
<ol>
<li><code>b256</code> (256 bits / 32 bytes, i.e. a hash)</li>
</ol>
</li>
<li><a href="documentation/language/built-ins/slices.html">Slices</a></li>
</ol>
<!-- TODO: The following sentence does not belong here. We need to convey the default size, including word size, somewhere however not on this page -->
<p>The default numeric type is <code>u64</code>. The FuelVM's word size is 64 bits, and the cases where using a smaller numeric type to save space are minimal.</p>
<p>All other types in Sway are built up of these primitive types, or references to these primitive types.</p>
<h2 id="compound-types"><a class="header" href="#compound-types">Compound Types</a></h2>
<p>Compound types are types that group multiple values into one type.</p>
<p>Sway has the following compound types:</p>
<ol>
<li><a href="documentation/language/built-ins/arrays.html">Arrays</a></li>
<li><a href="documentation/language/built-ins/tuples.html">Tuples</a></li>
<li><a href="documentation/language/built-ins/structs.html">Structs</a></li>
<li><a href="documentation/language/built-ins/enums.html">Enums</a></li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="numeric-types"><a class="header" href="#numeric-types">Numeric Types</a></h1>
<p>Broadly speaking there are two types of integers:</p>
<!-- no toc -->
<ul>
<li><a href="documentation/language/built-ins/numeric.html#signed-integers">Signed</a> (positive and negative)</li>
<li><a href="documentation/language/built-ins/numeric.html#unsigned-integers">Unsigned</a> (only positive)</li>
</ul>
<h2 id="signed-integers"><a class="header" href="#signed-integers">Signed Integers</a></h2>
<p>A signed integer is a whole number which can take the value of zero and both negative and positive values. This means that a signed integer can take values such as:</p>
<ul>
<li>-42</li>
<li>0</li>
<li>42</li>
</ul>
<p>In order to achieve this one <em>bit</em> must be kept for tracking the sign (+ or -) of the value and thus the range of available values is smaller than an unsigned integer.</p>
<p>For those inclined, the range for an n-bit signed integer is -2<sup>n-1</sup> to 2<sup>n-1</sup>-1.</p>
<p>Sway does not natively support signed integers however there is nothing stopping a library from using primitives to create types that act like signed types.</p>
<h2 id="unsigned-integers"><a class="header" href="#unsigned-integers">Unsigned Integers</a></h2>
<p>An unsigned integer is a whole number which can take the value of zero or any positive number, but cannot be negative. This allows for one more <em>bit</em> of values to be used for the positive numbers and thus the positive range is significantly larger than for signed integers.</p>
<p>An example of available values is:</p>
<ul>
<li>0</li>
<li>42</li>
</ul>
<p>For those inclined, the range for an n-bit unsigned integer is 0 to 2<sup>n</sup>-1.</p>
<h2 id="alternative-syntax"><a class="header" href="#alternative-syntax">Alternative Syntax</a></h2>
<p>All of the unsigned integer types are numeric types, and the <code>byte</code> type can also be viewed as an 8-bit unsigned integer.</p>
<p>Numbers can be declared with binary syntax, hexadecimal syntax, base-10 syntax, and underscores for delineation.</p>
<pre><code class="language-sway">    let hexadecimal = 0xffffff;
    let binary = 0b10101010;
    let base_10 = 10;
    let underscore_delineated_base_10 = 100_000;
    let underscore_delineated_binary = 0x1111_0000;
    let underscore_delineated_hexadecimal = 0xfff_aaa;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="boolean-type"><a class="header" href="#boolean-type">Boolean Type</a></h1>
<p>A Boolean is a type that is represented by either a value of one or a value of zero. To make it easier to use the values have been given names: <code>true</code> &amp; <code>false</code>.</p>
<p>Boolean values are typically used for conditional logic or validation, for example in <a href="documentation/language/built-ins/../control-flow/if-expressions.html">if expressions</a>, and thus expressions are said to be evaluated to <code>true</code> or <code>false</code>.</p>
<p>Using the unary operator <code>!</code> the Boolean value can be changed:</p>
<ul>
<li>From <code>true</code> to <code>false</code></li>
<li>From <code>false</code> to <code>true</code></li>
</ul>
<h2 id="example-2"><a class="header" href="#example-2">Example</a></h2>
<p>The following example creates two Boolean <a href="documentation/language/built-ins/../variables/index.html">variables</a>, performs a comparison using the unary operator <code>!</code> and <a href="documentation/language/built-ins/../functions/return.html">implicitly</a> returns the result.</p>
<pre><code class="language-sway">fn returns_true() -&gt; bool {
    let is_true = true;
    let is_false = false;

    // implicitly returns the Boolean value of `true`
    is_true == !is_false
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="string-type"><a class="header" href="#string-type">String Type</a></h1>
<p>A string is a collection of characters (letters, numbers etc.).</p>
<p>Sway has one string type and it's a fixed length string which has the following implications:</p>
<ul>
<li>A string cannot be grown or shrunk during execution</li>
<li>The content of the string must meet its length
<ul>
<li>This could be via a legitimate value that takes up the entire length or through padding</li>
</ul>
</li>
</ul>
<p>The reason for this is that the compiler must know the size of the type and the length is a part of the type.</p>
<p>A string can be created through the use of double-quotation marks <code>"</code> around the text. The length of the string is permanently set at that point and cannot be changed even if the variable is marked as mutable.</p>
<pre><code class="language-sway">    // The variable `fuel` is a string slice with length equals 4
    let fuel = "fuel";
    let crypto = __to_str_array("crypto");
</code></pre>
<p>Strings default to UTF-8 in Sway.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bytes"><a class="header" href="#bytes">Bytes</a></h1>
<p>Sway has a single "bytes" type which is the <code>b256</code>.</p>
<p>As the name suggests it contains <code>256 bits</code> / <code>32 bytes</code> of information. Unlike some other programming languages this type is treated as a single, whole, type unlike an array of bytes which is iterated over.</p>
<pre><code class="language-sway">    let zero = 0x0000000000000000000000000000000000000000000000000000000000000000;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tuples"><a class="header" href="#tuples">Tuples</a></h1>
<p>A tuple is a general-purpose static-length aggregation of types, in other words, it's a single type that consists of an aggregate of zero or more types. The internal types that make up a tuple, and the tuple's arity, define the tuple's type.</p>
<h2 id="declare"><a class="header" href="#declare">Declare</a></h2>
<p>To declare a tuple we wrap the values in <code>()</code>.</p>
<pre><code class="language-sway">    // Define a tuple containing 2 u64 types
    let mut balances = (42, 1337);
</code></pre>
<h2 id="retrieve-by-index"><a class="header" href="#retrieve-by-index">Retrieve by Index</a></h2>
<p>Values can be retrieved individually from the tuple by specifying the index.</p>
<pre><code class="language-sway">    // first = 42, second = 1337
    let first = balances.0;
    let second = balances.1;
</code></pre>
<h2 id="mutate"><a class="header" href="#mutate">Mutate</a></h2>
<p>A value can be mutated in a tuple as long as the tuple is declared to be <a href="documentation/language/built-ins/../variables/index.html">mutable</a> and the new value has the same type as the previous value.</p>
<pre><code class="language-sway">    // 12 has the same type as 42 (u64) therefore this is valid
    balances.0 = 12;

    // true is a Boolean and the tuple expects a u64 therefore this is invalid
    // balances.0 = true;
</code></pre>
<p>The entire tuple can be overwritten when it is <a href="documentation/language/built-ins/../variables/index.html">mutable</a> and the type for each value is the same.</p>
<pre><code class="language-sway">    // 3 is the same type as 42 (u64) and so is 4 and 1337 therefore this is valid
    balances = (3, 4);
</code></pre>
<h2 id="destructure"><a class="header" href="#destructure">Destructure</a></h2>
<p>Elements can be destructured from a tuple into individual variables.</p>
<pre><code class="language-sway">    // first = 42, second = 1337
    let (first, second) = balances;
</code></pre>
<p>We can also ignore elements when destructuring.</p>
<pre><code class="language-sway">    // 42 is ignored and cannot be used
    let (_, second) = balances;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="arrays"><a class="header" href="#arrays">Arrays</a></h1>
<p>An array is similar to a <a href="documentation/language/built-ins/tuples.html">tuple</a>, but an array's values must all be of the same type. It's defined using square brackets <code>[]</code> and separates its values using commas.</p>
<p>Unlike a tuple, an array can be iterated over through indexing.</p>
<pre><code class="language-sway">fn syntax() {
    let array = [1, 2, 3, 4, 5];

    let mut counter = 0;
    let mut total = 0;

    while counter &lt; 5 {
        total += array[counter];
        counter += 1;
    }
}
</code></pre>
<p>Arrays are allocated on the stack and thus the size of an array is considered to be <code>static</code>. What this means is that once an array is declared to have a size of <code>n</code> it cannot be changed to contain more, or fewer, elements than <code>n</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="structs"><a class="header" href="#structs">Structs</a></h1>
<p>A struct in Sway is a <code>product type</code> which is a data structure that allows grouping of various types under a name that can be referenced, unlike a <a href="documentation/language/built-ins/tuples.html">tuple</a>. The types contained in the struct are named and thus they can be referenced by their names as well.</p>
<h2 id="declaration"><a class="header" href="#declaration">Declaration</a></h2>
<p>The following syntax demonstrates the declaration of a struct named <code>Foo</code> containing two fields - public field <code>bar</code>, a <code>u64</code>, and a private field <code>baz</code>, a <code>bool</code>.</p>
<pre><code class="language-sway">struct Foo {
    pub bar: u64,
    baz: bool,
}
</code></pre>
<p>Public fields are accessible in all the modules in which the struct is accessible. Private fields are accessible only within the module in which the struct is declared.</p>
<h2 id="instantiation"><a class="header" href="#instantiation">Instantiation</a></h2>
<p>To instantiate a struct the name of the struct must be used followed by <code>{}</code> where the fields from the <a href="documentation/language/built-ins/structs.html#declaration">declaration</a> must be specified inside the brackets. Instantiation requires all fields to be initialized, both private and public.</p>
<pre><code class="language-sway">fn hardcoded_instantiation() {
    // Instantiate the variable `foo` as `Foo`
    let mut foo = Foo {
        bar: 42,
        baz: false,
    };

    // Access and write to "baz"
    foo.baz = true;
}

fn variable_instantiation() {
    // Declare variables and pass them into `Foo`
    let number = 42;
    let boolean = false;

    let mut foo = Foo {
        bar: number,
        baz: boolean,
    };

    // Access and write to "baz"
    foo.baz = true;
}

fn shorthand_instantiation() {
    // Declare variables with the same names as the fields in `Foo`
    let bar = 42;
    let baz = false;

    // Instantiate `foo` as `Foo`
    let mut foo = Foo { bar, baz };

    // Access and write to "baz"
    foo.baz = true;
}
</code></pre>
<p>Structs with private fields can be instantiated only within the module in which the struct is declared.</p>
<h2 id="destructuring"><a class="header" href="#destructuring">Destructuring</a></h2>
<p>The fields of a struct can be accessed through destructuring.</p>
<pre><code class="language-sway">fn destructuring() {
    let foo = Foo {
        bar: 42,
        baz: false,
    };

    // bar and baz are now accessible as variables
    let Foo { bar, baz } = foo;

    if baz {
        let quix = bar * 2;
    }

    // You may use `..` to omit the remaining fields if the types match
    // The compiler will fill them in for you
    let Foo { bar, .. } = foo;
}
</code></pre>
<p>When destructuring structs with private fields outside of a module in which the struct is defined, the private fields must be omitted by using the <code>..</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="enums"><a class="header" href="#enums">Enums</a></h1>
<p>An enum, also known as a <code>sum type</code>, is a type that consists of several variants where each variant is named and has a type.</p>
<p>Let's take a look at an example where we define an enum called <code>Color</code> with a few color variations.</p>
<pre><code class="language-sway">enum Color {
    Blue: (),
    Green: (),
    Red: (),
    Silver: (),
    Grey: (),
}
</code></pre>
<p>We begin by using the <code>enum</code> keyword followed by the name for our enumeration. The variants are contained inside <code>{}</code> and they are ordered sequentially from top to bottom. Each variant has a name, such as the first <code>Blue</code> variant, and a type, which in this case is the unit type <code>()</code> for all variants.</p>
<p>The unit type is a type that does not contain any data however any type can be used.</p>
<pre><code class="language-sway">    // To instantiate an enum with a variant of the unit type the syntax is
    let blue = Color::Blue;
    let silver = Color::Silver;
</code></pre>
<h2 id="enums-of-structs"><a class="header" href="#enums-of-structs">Enums of Structs</a></h2>
<p>In order to demonstrate more complex data types we can define a struct and assign that struct as a data type for any of an enum's variants.</p>
<p>Here we have a struct <code>Item</code> and an enum <code>MyEnum</code>. The enum has one variant by the name <code>Product</code> and its type is declared to the right of <code>:</code> which in this case is our struct <code>Item</code>.</p>
<pre><code class="language-sway">struct Item {
    amount: u64,
    id: u64,
    price: u64,
}

enum MyEnum {
    Product: Item,
}

fn main() {
    let my_enum = MyEnum::Product(Item {
        amount: 2,
        id: 42,
        price: 5,
    });
}
</code></pre>
<h2 id="enums-of-enums"><a class="header" href="#enums-of-enums">Enums of Enums</a></h2>
<p>Similar to structs we can use other enums as types for our variants.</p>
<pre><code class="language-sway">enum UserError {
    InsufficientPermissions: (),
    Unauthorized: (),
}

enum Error {
    UserError: UserError,
}

fn main() {
    let my_enum = Error::UserError(UserError::Unauthorized);
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="variables"><a class="header" href="#variables">Variables</a></h1>
<p>A variable is a way to reference some information by a specific name and it can take the form of a variety of <a href="documentation/language/variables/../built-ins/index.html">data structures</a>.</p>
<p>In Sway there are two states that a variable can take:</p>
<ul>
<li>Immutable
<ul>
<li>Can be read but cannot be changed after it has been declared</li>
</ul>
</li>
<li>Mutable
<ul>
<li>Can be read and can have its value changed if and only if the new value is the same type</li>
</ul>
</li>
</ul>
<p>By default all variables in Sway are immutable unless declared as mutable through the use of the <code>mut</code> keyword. This is one of the ways in which Sway encourages safe programming, and many modern languages have the same default.</p>
<p>In the following sections, we'll take a look at two keywords that are used to instantiate information (<a href="documentation/language/variables/let.html">let</a> &amp; <a href="documentation/language/variables/const.html">const</a>) and a way to temporarily reuse a variable name without affecting the original instantiation through <a href="documentation/language/variables/variable-shadowing.html">variable shadowing</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="let"><a class="header" href="#let">let</a></h1>
<p>The <code>let</code> keyword is used to assign a value to a variable during run-time. It can only be used inside of a <a href="documentation/language/variables/../functions/index.html">function</a> and its value can be changed when declared as <a href="documentation/language/variables/let.html#mutable">mutable</a>.</p>
<h2 id="immutable"><a class="header" href="#immutable">Immutable</a></h2>
<p>We can declare a variable that cannot have its value changed in the following way.</p>
<pre><code class="language-sway">    let foo = 5;
</code></pre>
<p>By default <code>foo</code> is an immutable <a href="documentation/language/variables/../built-ins/index.html#primitive-types"><code>u64</code></a> with the value of <code>5</code>. This means that we can pass <code>foo</code> around and its value can be read, but it cannot have its value changed from <code>5</code> to any other value.</p>
<h2 id="mutable"><a class="header" href="#mutable">Mutable</a></h2>
<p>We can declare a variable that can have its value changed through the use of the <code>mut</code> keyword.</p>
<pre><code class="language-sway">    let mut foo = 5;
    foo = 6;
</code></pre>
<p>When assigning to a mutable variable, the right-hand side of the assignment is evaluated before the left-hand side. In the below example, the mutable variable <code>i</code> will first be increased and the resulting value of <code>1</code> will be stored to <code>array[1]</code>, thus resulting in <code>array</code> being changed to <code>[0, 1, 0]</code>.</p>
<pre><code class="language-sway">    let mut array = [0, 0, 0];
    let mut i = 0;

    array[i] = {
        i += 1;
        i
    };
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="constants"><a class="header" href="#constants">Constants</a></h1>
<p>Constants are similar to <a href="documentation/language/variables/./let.html#immutable">immutable let</a> variables; however, there are a few differences:</p>
<ul>
<li>Constants are always evaluated at compile-time.</li>
<li>Constants can be declared both inside of a <a href="documentation/language/variables/../functions/index.html">function</a> and at global/<code>impl</code> scope.</li>
<li>The <code>mut</code> keyword cannot be used with constants.</li>
</ul>
<h2 id="declaration-1"><a class="header" href="#declaration-1">Declaration</a></h2>
<p>To define a constant the <code>const</code> keyword is used followed by a name and an assignment of a value.</p>
<pre><code class="language-sway">    const FOO = 5;
</code></pre>
<p>The example above hardcodes the value of <code>5</code> however function calls may also be used alongside <a href="documentation/language/variables/../built-ins/index.html">built-in types</a>.</p>
<h2 id="impl-self-constants"><a class="header" href="#impl-self-constants"><code>impl self</code> Constants</a></h2>
<p>Constants can also be declared inside <code>impl</code> blocks. In this case, the constant is referred to as an associated constant.</p>
<pre><code class="language-sway">struct Point {
    x: u64,
    y: u64,
}

impl Point {
    const ZERO: Point = Point { x: 0, y: 0 };
}

fn main() -&gt; u64  {
    Point::ZERO.x
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="shadowing"><a class="header" href="#shadowing">Shadowing</a></h1>
<p>When looking at the <a href="documentation/language/variables/let.html">let</a> variable we've seen that the value can be changed through the use of the <code>mut</code> keyword. We can take this a couple steps further through <a href="documentation/language/variables/variable-shadowing.html#reassignment">reassignment</a> and <a href="documentation/language/variables/variable-shadowing.html#variable-shadowing">variable shadowing</a>. Note that shadowing applies only to variables. <a href="documentation/language/variables/const.html">Constants</a> cannot be shadowed.</p>
<h2 id="reassignment"><a class="header" href="#reassignment">Reassignment</a></h2>
<p>We can redefine the type and value of a variable by instantiating a new version after the first declaration.</p>
<pre><code class="language-sway">    // Set `foo` to take the value of `5` and the default `u64` type
    let foo = 5;

    // Reassign `foo` to be a `str` with the value of `Fuel`
    let foo = "Fuel";
</code></pre>
<h2 id="variable-shadowing"><a class="header" href="#variable-shadowing">Variable Shadowing</a></h2>
<p>If we do not want to alter the original variable but we'd like to temporarily reuse the variable name then we can use block scope to constrain the variable.</p>
<pre><code class="language-sway">    let foo = 5;
     {
        let foo = 42;
    }
    assert(foo == 5);
</code></pre>
<p><code>foo</code> is defined inside the curly brackets <code>{ }</code> and only exist inside the <code>{ .. }</code> scope; therefore, the original <code>foo</code> variable with the value of <code>5</code> maintains its value.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="comments"><a class="header" href="#comments">Comments</a></h1>
<p>There are two kinds of comments in Sway.</p>
<ul>
<li><a href="documentation/language/comments/index.html#regular-comments">Regular Comments</a> are used for conveying information to the reader of the source code</li>
<li><a href="documentation/language/comments/index.html#documentation-comments">Documentation Comments</a> are used for documenting functionality for external use</li>
</ul>
<h2 id="regular-comments"><a class="header" href="#regular-comments">Regular Comments</a></h2>
<p>Regular comments are broken down into two forms of syntax:</p>
<ul>
<li><code>// comment</code></li>
<li><code>/* comment */</code></li>
</ul>
<p>The first form starts after the two forward slashes and continues to the end of the line.</p>
<p>Comments can be placed on multiple lines by starting each line with <code>//</code> and they can be placed at the end of some code.</p>
<pre><code class="language-sway">    // imagine that this line is twice as long
    // and it needed to be split onto multiple lines
    let baz = 8; // Eight is a good number
</code></pre>
<p>Similarly, the second form continues to the end of the line and it can also be placed at the end of some code.</p>
<pre><code class="language-sway">    /*
        imagine that this line is twice as long
        and it needed to be split onto multiple lines
    */
</code></pre>
<h2 id="documentation-comments"><a class="header" href="#documentation-comments">Documentation Comments</a></h2>
<p>Documentation comments start with three forward slashes <code>///</code> and are placed on top of functions or above fields e.g. in a <a href="documentation/language/comments/../built-ins/structs.html">struct</a>.</p>
<p>Documentation comments are typically used by tools for automatic documentation generation.</p>
<pre><code class="language-sway">/// Data structure containing metadata about product XYZ
struct Product {
    /// Some information about field 1
    field1: u64,
    /// Some information about field 2
    field2: bool,
}

/// Creates a new instance of a Product
///
/// # Arguments
///
/// - `field1`: description of field1
/// - `field2`: description of field2
///
/// # Returns
///
/// A struct containing metadata about a Product
fn create_product(field1: u64, field2: bool) -&gt; Product {
    Product { field1, field2 }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="functions-methods-and-associated-functions"><a class="header" href="#functions-methods-and-associated-functions">Functions, methods, and associated functions</a></h1>
<p>Functions, and by extension methods and associated functions, are a way to group functionality together in a way that allows for code reuse without having to re-write the code in each place that it is used.</p>
<p>The distinction between a function, method and associated function is as follows:</p>
<ul>
<li>A <a href="documentation/language/functions/function.html">function</a> is a grouping of code that is independent of any object</li>
<li>A <a href="documentation/language/functions/method.html">method</a> is a function that is associated with an object and it uses <code>self</code> as the first parameter</li>
<li>An <a href="documentation/language/functions/associated-function.html">associated function</a> is a method but without the <code>self</code> parameter</li>
</ul>
<h2 id="function-declaration"><a class="header" href="#function-declaration">Function Declaration</a></h2>
<p>A function declaration consists of a few components</p>
<ul>
<li>The <code>fn</code> keyword</li>
<li>A unique name for the function</li>
<li>Comma separated optional parameters, and their types, inside <code>()</code></li>
<li>An optional return type</li>
</ul>
<p>Here is a template that applies to the aforementioned functions.</p>
<pre><code class="language-sway">fn my_function(my_parameter: u64 /* ... */ ) -&gt; u64 {
    // function code
    42
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="functions"><a class="header" href="#functions">Functions</a></h1>
<p>In this section we will define a function that takes two numerical inputs and returns a <a href="documentation/language/functions/../built-ins/boolean.html">Boolean</a> value indicating whether they are equal. We will also take a look at how to use the function.</p>
<h2 id="declaration-2"><a class="header" href="#declaration-2">Declaration</a></h2>
<p>The following function is called <code>equals</code> and it takes two parameters of type <code>u64</code> (64-bit unsigned integers). It performs a comparison and <a href="documentation/language/functions/./return.html">implicitly</a> returns the result of that comparison.</p>
<pre><code class="language-sway">fn equals(first_parameter: u64, second_parameter: u64) -&gt; bool {
    first_parameter == second_parameter
}
</code></pre>
<h2 id="usage"><a class="header" href="#usage">Usage</a></h2>
<p>The following is a way to use the function defined above.</p>
<pre><code class="language-sway">    let result_one = equals(5, 5); // evaluates to `true`
    let result_two = equals(5, 6); // evaluates to `false`
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="methods"><a class="header" href="#methods">Methods</a></h1>
<p>Methods are defined within the context of a <a href="documentation/language/functions/../built-ins/structs.html">struct</a> (or <a href="documentation/language/functions/../built-ins/enums.html">enum</a>) and either refer to the type or mutate it.</p>
<p>The first parameter of a method is always <code>self</code>, which represents the instance of the type the method is being called on.</p>
<h2 id="declaration-3"><a class="header" href="#declaration-3">Declaration</a></h2>
<p>In this example we will take a look at a struct however an enum will work in the same way.</p>
<pre><code class="language-sway">struct Foo {
    bar: u64,
}
</code></pre>
<p>We start by using the <code>impl</code> (implementation) keyword, followed by the name of our struct, to define a function that belongs to our object i.e. a method.</p>
<pre><code class="language-sway">impl Foo {
    // refer to `bar`
    fn add_number(self, number: u64) -&gt; u64 {
        self.bar + number
    }

    // mutate `bar`
    fn increment(ref mut self, number: u64) {
        self.bar += number;
    }
}
</code></pre>
<h2 id="usage-1"><a class="header" href="#usage-1">Usage</a></h2>
<p>To call a method use the dot syntax: <code>&lt;variable name&gt;.&lt;method name&gt;()</code>.</p>
<pre><code class="language-sway">    let mut foo = Foo { bar: 42 };
    let result = foo.add_number(5); // evaluates to `47`
    foo.increment(5); // `bar` inside `foo` has been changed from 42 to 47
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="associated-functions"><a class="header" href="#associated-functions">Associated Functions</a></h1>
<p>Associated functions are similar to methods in that they are also defined in the context of a <a href="documentation/language/functions/../built-ins/structs.html">struct</a> or <a href="documentation/language/functions/../built-ins/enums.html">enum</a>, but they do not use any of the data in the struct and as a result do not take <code>self</code> as a parameter.</p>
<p>Associated functions could be standalone functions, but they are included in a specific type for organizational or semantic reasons.</p>
<h2 id="constructors"><a class="header" href="#constructors">Constructors</a></h2>
<p>A distinguished family of associated functions of a specific type are <em>type constructors</em>. Constructors are associated functions that construct, or in other words instantiate, new instances of a type. Their return type always includes the type itself, and is often just the type itself.</p>
<p>Public <a href="documentation/language/functions/../built-ins/structs.html">structs</a> that have private fields must provide a public constructor, or otherwise cannot be instantiated outside of the module in which they are declared.</p>
<h2 id="declaration-4"><a class="header" href="#declaration-4">Declaration</a></h2>
<p>In this example we will take a look at a struct; however, an enum will work in the same way.</p>
<pre><code class="language-sway">struct Foo {
    bar: u64,
}
</code></pre>
<p>We start by using the <code>impl</code> (implementation) keyword, followed by the name of our struct, to define a function that belongs to our object i.e. a method.</p>
<pre><code class="language-sway">impl Foo {
    // this is an associated function because it does not take `self` as a parameter
    // it is also a constructor because it instantiates
    // and returns a new instance of `Foo`
    fn new(number: u64) -&gt; Self {
        Self { bar: number }
    }
}
</code></pre>
<h2 id="usage-2"><a class="header" href="#usage-2">Usage</a></h2>
<p>To call an associated function on a type we use the following syntax.</p>
<pre><code class="language-sway">    let foo = Foo::new(42);
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="returning-from-functions"><a class="header" href="#returning-from-functions">Returning from functions</a></h1>
<p>In the previous sections we have seen how functions return values without going into detail. In this section we will take a closer look at how we can return data from a function.</p>
<p>There are two ways to return:</p>
<!-- no toc -->
<ul>
<li><a href="documentation/language/functions/return.html#explicit-return">Explicit Return</a></li>
<li><a href="documentation/language/functions/return.html#implicit-return">Implicit Return</a></li>
</ul>
<p>When returning data from a function the return types must match up with the return types declared in the function signature. This means that if the first return type is a <code>u64</code> then the type of the first value being returned must also be a <code>u64</code>.</p>
<h2 id="explicit-return"><a class="header" href="#explicit-return">Explicit Return</a></h2>
<p>To return from a function explicitly we use the <code>return</code> keyword followed by the arguments and a semi-colon.</p>
<pre><code class="language-sway">fn main() -&gt; bool {
    return true;
}
</code></pre>
<p>A return expression is typically used at the end of a function; however, it can be used earlier as a mechanism to exit a function early if some condition is met.</p>
<pre><code class="language-sway">fn return_data(parameter_one: u64, parameter_two: bool) -&gt; (bool, u64) {
    if parameter_two {
        return (!parameter_two, parameter_one + 42);
    }
    return (parameter_two, 42);
}
</code></pre>
<h2 id="implicit-return"><a class="header" href="#implicit-return">Implicit Return</a></h2>
<p>To return from a function implicitly we do not use the <code>return</code> keyword and we omit the semi-colon at the end of the line.</p>
<pre><code class="language-sway">fn main() -&gt; bool {
    true
}
</code></pre>
<p>An implicit return is a special case of the <a href="documentation/language/functions/return.html#explicit-return">explicit return</a>. It can only be used at the end of a function.</p>
<pre><code class="language-sway">fn return_data(parameter_one: u64, parameter_two: bool) -&gt; (bool, u64) {
    if parameter_two {
        (!parameter_two, parameter_one + 42)
    } else {
        (parameter_two, 42)
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="control-flow"><a class="header" href="#control-flow">Control Flow</a></h1>
<p>A control flow in a program is the order in which instructions are executed.</p>
<p>For example, a function may take an input <code>u64</code> and if the value is greater than <code>5</code> then it calls one function otherwise it calls a different function.</p>
<p>Controlling the order of instructions can be done through the use of conditional expressions such as <a href="documentation/language/control-flow/if-expressions.html">if</a> and <a href="documentation/language/control-flow/match/index.html">match</a> and through <a href="documentation/language/control-flow/looping/index.html">looping</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="if-expressions"><a class="header" href="#if-expressions">if expressions</a></h1>
<p>Sway supports <em>if</em>, <em>else</em>, and <em>else if</em> expressions which provide control over which instructions should be executed depending on the conditions.</p>
<h2 id="conditional-branching"><a class="header" href="#conditional-branching">Conditional Branching</a></h2>
<p>In the following example we have a hardcoded variable <code>number</code> set to the value of <code>5</code> which is put through some conditional checks.</p>
<pre><code class="language-sway">    let number = 5;

    if number % 3 == 0 {
        // call function 1
    } else if number % 4 == 0 {
        // call function 2
    } else {
        // call function 3
    }

    // more code here
</code></pre>
<p>The conditional checks are performed in the order that they are defined therefore the first check is to see if the <code>number</code> is divisible by <code>3</code>.</p>
<p>If the condition evaluates to the <a href="documentation/language/control-flow/../built-ins/boolean.html">Boolean</a> value of <code>true</code> then we call <code>function 1</code> and we move on to the end where the comment <code>more code here</code> is written. We do not evaluate the remaining conditions.</p>
<p>On the other hand if the condition evaluates to <code>false</code> then we check the next condition, in this case if the <code>number</code> is divisible by <code>4</code>. We can have as many <code>else if</code> checks as we like as long as they evaluate to a Boolean.</p>
<p>At the end there is a special case which is known as a <code>catch all</code> case i.e. the <code>else</code>. What this means is that we have gone through all of our conditional checks above and none of them have been met. In this scenario we may want to have some special logic to handle a generic case which encompasses all the other conditions which we do not care about or can be treated in the same way.</p>
<h2 id="using-if--let-together"><a class="header" href="#using-if--let-together">Using if &amp; let together</a></h2>
<p>In <a href="documentation/language/control-flow/if-expressions.html#conditional-branching">Conditional Branching</a> we have opted to call some functions depending on which condition is met however that is not the only thing that we can do. Since <code>if</code>'s are expressions in Sway we can use them to match on a pattern.</p>
<h3 id="if-let"><a class="header" href="#if-let">if let</a></h3>
<p>In the following examples we combine <code>if</code> and <code>let</code> into <code>if let</code> followed by some comparison which must evaluate to a <a href="documentation/language/control-flow/../built-ins/boolean.html">Boolean</a>.</p>
<pre><code class="language-sway">enum Foo {
    One: (),
    Two: (),
}
</code></pre>
<h4 id="example-1"><a class="header" href="#example-1">Example 1</a></h4>
<p>Here we check to see if the hardcoded variable <code>one</code> is the same as the first variant of <code>Foo</code>.</p>
<pre><code class="language-sway">    let one = Foo::One;
    let mut result = 0;
    
    if let Foo::One = one {
        result = 1;
    }
</code></pre>
<h4 id="example-2"><a class="header" href="#example-2">Example 2</a></h4>
<p>Alternatively, we can take the outcome of the comparison and assign it directly to a variable.</p>
<pre><code class="language-sway">    let one = Foo::One;
    let result = if let Foo::One = one {
        1
    } else {
        2
    };
</code></pre>
<p>The syntax above can be altered to include an <code>else if</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="match"><a class="header" href="#match">match</a></h1>
<p><a href="documentation/language/control-flow/match/../if-expressions.html">If expressions</a> can be used to check a large number of conditions however, there is an alternative syntax which allows us to perform advanced pattern matching.</p>
<p>A <code>match</code> expression matches on a variable and checks each case, also known as an <code>arm</code>, to see which branch of logic should be performed.</p>
<p>The cases are checked sequentially in the order they are declared, i.e. from top to bottom, and the last arm must ensure that all cases in the pattern are covered otherwise the compiler will not know how to handle an unspecified pattern and will throw an error.</p>
<p>In the following sections we'll look at:</p>
<ul>
<li>A primitive case where a <a href="documentation/language/control-flow/match/single-line.html">single line</a> of code is used in a case</li>
<li>Expand the first example to use code blocks in the <a href="documentation/language/control-flow/match/multi-line.html">multi line</a> case</li>
<li>Look at <a href="documentation/language/control-flow/match/complex/index.html">complex pattern</a> matching to demonstrate their utility</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="single-line-arm"><a class="header" href="#single-line-arm">Single Line Arm</a></h1>
<p>The following example demonstrates how a type can be matched on and its output is assigned to a variable. The assignment to a variable is optional.</p>
<pre><code class="language-sway">    let number = 5;

    let result = match number {
        0 =&gt; 10,
        1 =&gt; 20,
        5 =&gt; 50,
        6 | 7 =&gt; 60,
        catch_all =&gt; 0,
    };
</code></pre>
<p>The left side of the arrow <code>=&gt;</code> is the pattern that we are matching on and the right side of the arrow <code>=&gt;</code> is the logic that we want to perform, in this case we are returning a different multiple of <code>10</code> depending on which arm is matched.</p>
<p>We check each arm starting from <code>0</code> and make our way down until we either find a match on our pattern or we reach the <code>catch_all</code> case.</p>
<p>The <code>|</code> operator can be used to produce a pattern that is a disjunction of other patterns.</p>
<p>The <code>catch_all</code> case is equivalent to an <code>else</code> in <a href="documentation/language/control-flow/match/../if-expressions.html">if expressions</a> and it does not have to be called <code>catch_all</code>. Any pattern declared after a <code>catch_all</code> case will not be matched because once the compiler sees the first <code>catch_all</code> it stop performing further checks.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="multi-line-arm"><a class="header" href="#multi-line-arm">Multi Line Arm</a></h1>
<p>The arm of a <code>match</code> expression can contain multiple lines of code by wrapping the right side of the arrow <code>=&gt;</code> in brackets <code>{}</code>.</p>
<pre><code class="language-sway">    let number = 5;

    let result = match number {
        0 =&gt; {
            // Multiple lines of code here then return 10
            10
        },
        1 =&gt; 20,
        5 =&gt; 50,
        catch_all =&gt; 0,
    };
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="complex-patterns"><a class="header" href="#complex-patterns">Complex Patterns</a></h1>
<p>Match expressions are meant to cover advanced patterns so the following sections demonstrate some examples:</p>
<ul>
<li><a href="documentation/language/control-flow/match/complex/enum.html">enum variants</a></li>
<li><a href="documentation/language/control-flow/match/complex/struct.html">structs and their fields</a></li>
<li><a href="documentation/language/control-flow/match/complex/constant.html">constant variables</a></li>
<li><a href="documentation/language/control-flow/match/complex/nested-expression.html">nested match expressions</a></li>
<li><a href="documentation/language/control-flow/match/complex/multiple-values.html">matching on multiple values</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="enums-1"><a class="header" href="#enums-1">Enums</a></h1>
<p>An enum can be matched on by specifying the name of the enum and the variant.</p>
<pre><code class="language-sway">enum Color {
    Red: (),
    Green: (),
    Blue: (),
}

fn enum_match(input: Color) {
    let result = match input {
        Color::Red =&gt; 0,
        Color::Green =&gt; 1,
        Color::Blue =&gt; 2,
    };
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="structs-1"><a class="header" href="#structs-1">Structs</a></h1>
<p>We can match on specific arguments inside a struct while ignoring the rest by using <code>..</code>.</p>
<pre><code class="language-sway">struct Point {
    x: u64,
    y: u64
}

fn struct_matching() {
    let point = Point {
        x: 1u64,
        y: 2u64,
    };

    let result = match point {
        Point { x: 5, y } =&gt; y + 1,
        Point { x, .. } =&gt; x,
        Point { y, .. } =&gt; y,
        _ =&gt; 42,
    };
}
</code></pre>
<p>If the struct is imported from another module and has private fields, the private fields must always be ignored by using <code>..</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="constants-1"><a class="header" href="#constants-1">Constants</a></h1>
<p>Variables can be matched on but only if they are constants.</p>
<pre><code class="language-sway">const NUMBER_1: u64 = 7;
const NUMBER_2: u64 = 14;

fn constant_match() {
    let number = 5;

    let result = match number {
        NUMBER_1 =&gt; 1,
        NUMBER_2 =&gt; 42,
        other =&gt; other,
    };
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="nested-expressions"><a class="header" href="#nested-expressions">Nested Expressions</a></h1>
<p>We can nest <code>match</code> expressions by placing them inside code blocks.</p>
<pre><code class="language-sway">enum TopLevel {
    One: (),
    Two: SecondLevel,
}

enum SecondLevel {
    Value1: u64,
    Value2: (),
}

fn nested_match(input: TopLevel) -&gt; u64 {
    match input {
        TopLevel::One =&gt; 1,
        TopLevel::Two(second) =&gt; {
            match second {
                SecondLevel::Value1(2) =&gt; 2,
                SecondLevel::Value1(_) =&gt; 3,
                SecondLevel::Value2 =&gt; 42,
            }
        },
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="multiple-values"><a class="header" href="#multiple-values">Multiple Values</a></h1>
<p>We can <code>match</code> on multiple values by wrapping them in a <a href="documentation/language/control-flow/match/complex/../../../built-ins/tuples.html">tuple</a> and then specifying each variant in the same structure (tuple) that they have been defined.</p>
<pre><code class="language-sway">enum Binary {
    True: (),
    False: (),
}

impl PartialEq for Binary {
    fn eq(self, other: Self) -&gt; bool {
        match (self, other) {
            (Binary::True, Binary::True) =&gt; true,
            (Binary::False, Binary::False) =&gt; true,
            _ =&gt; false,
        }
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="looping"><a class="header" href="#looping">Looping</a></h1>
<p>A loop is a type of operation which allows us to perform computation a certain number of times. For example, given a collection of items we could call a method on the first item and iterate until the method has been called on each item.</p>
<p>Usually, a loop has a condition which prevents it from continuing indefinitely however it is possible to create a loop that never stops i.e. an infinite loop.</p>
<p>Programming languages have various forms of syntax for declaring a loop which may slightly alter how the iteration takes place.</p>
<p>Sway has the following loops:</p>
<ul>
<li><a href="documentation/language/control-flow/looping/while.html">while</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="while"><a class="header" href="#while">while</a></h1>
<p>A <code>while</code> loop uses the <code>while</code> keyword followed by a condition which evaluates to a <a href="documentation/language/control-flow/looping/../../built-ins/boolean.html">Boolean</a>.</p>
<pre><code class="language-sway">    let mut counter = 0;
    let mut condition = true;
    while counter &lt; 10 &amp;&amp; condition {
        counter += 1;
        if 5 &lt; counter {
            condition = false;
        }
    }
</code></pre>
<p>In the example above we use two conditions.</p>
<ol>
<li>If the <code>counter</code> is less than <code>10</code> then continue to iterate</li>
<li>If the <code>condition</code> variable is <code>true</code> then continue to iterate</li>
</ol>
<p>As long as both those conditions are <code>true</code> then the loop will iterate. In this case the loop will finish iterating once <code>counter</code> reaches the value of <code>6</code> because <code>condition</code> will be set to <code>false</code>.</p>
<h2 id="nested-loops"><a class="header" href="#nested-loops">Nested loops</a></h2>
<p>Sway also allows nested <code>while</code> loops.</p>
<pre><code class="language-sway">    while true {
        // computation here
        while true {
            // more computation here
        }
    }
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="break"><a class="header" href="#break">break</a></h1>
<p><code>break</code> is a keyword available for use inside of a <a href="documentation/language/control-flow/looping/while.html"><code>while</code></a> loop and it is used to exit out of the loop before the looping condition is met.</p>
<pre><code class="language-sway">    let mut counter = 0;
    while counter &lt; 10 {
        counter += 1;
        if 5 &lt; counter {
            break;
        }
    }
</code></pre>
<p>In the example above the <code>while</code> loop is set to iterate until <code>counter</code> reaches the value of <code>10</code> however the <a href="documentation/language/control-flow/looping/../if-expressions.html">if expression</a> will break out of the loop once <code>counter</code> reaches the value of <code>6</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="continue"><a class="header" href="#continue">continue</a></h1>
<p><code>continue</code> is a keyword available for use inside of a <a href="documentation/language/control-flow/looping/while.html"><code>while</code></a> loop and it is used to skip to the next iteration without executing the code after <code>continue</code>.</p>
<pre><code class="language-sway">    let mut counter = 0;
    while counter &lt; 10 {
        counter += 1;
        if counter % 2 == 0 {
            continue;
        }
        // "other code"
    }
</code></pre>
<p>In the example above the <code>while</code> loop is set to iterate until <code>counter</code> reaches the value of <code>10</code> however the <a href="documentation/language/control-flow/looping/../if-expressions.html">if expression</a> will skip (not execute) the "other code" when <code>counter</code> is an even value. For example, this could be used to add all the odd numbers from <code>0</code> to <code>10</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="annotations"><a class="header" href="#annotations">Annotations</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="types"><a class="header" href="#types">Types</a></h1>
<p>Sway is a compiled language and as such each data structure has a definition i.e. a <code>type</code> which has some <code>size</code> that must be allocated on the stack.</p>
<p>The compiler can usually infer the <code>type</code> based on its usage however there may be occasions where the compiler cannot make the inference or the developer may deem it more useful to explicitly annotate a variable in order to make the code easier to read.</p>
<p>Annotating a variable is done by placing the annotation after the variable name but before the assignment (the <code>=</code> sign).</p>
<pre><code class="language-sway">    let bar: str = "sway";
    let baz: bool = true;
</code></pre>
<p>The compiler will disallow incorrect <code>type</code> annotations therefore replacing the <code>bool</code> annotation on the variable <code>baz</code> with a <code>u64</code> will result in a compilation error.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="attributes"><a class="header" href="#attributes">Attributes</a></h1>
<p>An attribute is a metadatum which provides some additional functionality.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="storage"><a class="header" href="#storage">Storage</a></h1>
<p>A storage attribute indicates the purity of a function i.e. whether it:</p>
<ul>
<li>reads from storage</li>
<li>writes to storage</li>
<li>reads from and writes to storage</li>
<li>does not read or write (is pure)</li>
</ul>
<p>When a function is pure the annotation is omitted otherwise the correct annotation must be placed above the function signature.</p>
<p>More information about storage can be found in the <a href="documentation/language/annotations/attributes/../../../operations/storage/index.html">common storage operations</a> section.</p>
<h2 id="reading-from-storage"><a class="header" href="#reading-from-storage">Reading from Storage</a></h2>
<p>When we read from storage we use the <code>read</code> keyword.</p>
<pre><code class="language-sway">#[storage(read)]
</code></pre>
<h2 id="writing-to-storage"><a class="header" href="#writing-to-storage">Writing to Storage</a></h2>
<p>When we write to storage we use the <code>write</code> keyword.</p>
<pre><code class="language-sway">#[storage(write)]
</code></pre>
<h2 id="reading--writing"><a class="header" href="#reading--writing">Reading &amp; Writing</a></h2>
<p>When we read from and write to storage we use the <code>read</code> &amp; <code>write</code> keywords.</p>
<pre><code class="language-sway">#[storage(read, write)]
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="payable"><a class="header" href="#payable">Payable</a></h1>
<p>The payable annotation is used to allow a <a href="documentation/language/annotations/attributes/../../program-types/contract.html">contract</a> <a href="documentation/language/annotations/attributes/../../functions/index.html">function</a> to accept an asset forwarded via a call.</p>
<h2 id="usage-3"><a class="header" href="#usage-3">Usage</a></h2>
<p>To allow a <a href="documentation/language/annotations/attributes/../../program-types/contract.html">contract</a> to accept assets we use the <code>payable</code> keyword.</p>
<pre><code class="language-sway">    #[payable]
    fn deposit();
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="test"><a class="header" href="#test">Test</a></h1>
<p>Sway provides the <code>#[test]</code> attribute which enables unit tests to be written in Sway.</p>
<h2 id="success-case"><a class="header" href="#success-case">Success case</a></h2>
<p>The <code>#[test]</code> attribute indicates that a test has passed if it did not revert.</p>
<pre><code class="language-sway">#[test]
fn equal() {
    assert_eq(1 + 1, 2);
}
</code></pre>
<h2 id="revert-case"><a class="header" href="#revert-case">Revert Case</a></h2>
<p>To test a case where code should revert we can use the <code>#[test(should_revert)]</code> annotation. If the test reverts then it will be reported as a passing test.</p>
<pre><code class="language-sway">#[test(should_revert)]
fn unequal() {
    assert_eq(1 + 1, 3);
}
</code></pre>
<p>We may specify a code to specifically test against.</p>
<pre><code class="language-sway">#[test(should_revert = "18446744073709486084")]
fn assert_revert_code() {
    assert(1 + 1 == 3);
}

#[test(should_revert = "42")]
fn custom_revert_code() {
    revert(42);
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="allow"><a class="header" href="#allow">Allow</a></h1>
<h2 id="dead-code"><a class="header" href="#dead-code">Dead code</a></h2>
<p>The <code>#[allow(dead_code)]</code> annotation disables warnings which are emitted by the compiler for code that is unused.</p>
<pre><code class="language-sway">#[allow(dead_code)]
fn unused_function() {}
</code></pre>
<h2 id="deprecated"><a class="header" href="#deprecated">Deprecated</a></h2>
<p>The <code>#[allow(deprecated)]</code> annotation disables warnings which are emitted by the compiler for usage of deprecated items.</p>
<pre><code class="language-sway">#[deprecated(note = "This is deprecated.")]
struct DeprecatedStruct {}

#[allow(deprecated)]
fn using_deprecated_struct() {
    let _ = DeprecatedStruct {};
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="inline"><a class="header" href="#inline">Inline</a></h1>
<p>When making a call the compiler may generate code to call a function where it is defined or it may copy the function code (inline) to prevent additional code generation.</p>
<p>The Sway compiler automatically inlines functions based on internal heuristics; however, the <code>inline</code> attribute may be used to suggest, but not require, code generation or code copying.</p>
<h2 id="generate-code"><a class="header" href="#generate-code">Generate code</a></h2>
<p>To suggest code generation use the <code>never</code> keyword.</p>
<pre><code class="language-sway">#[inline(never)]
fn foo() {}
</code></pre>
<h2 id="copy-code"><a class="header" href="#copy-code">Copy code</a></h2>
<p>To suggest code copy use the <code>always</code> keyword.</p>
<pre><code class="language-sway">#[inline(always)]
fn bar() {}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="deprecated-1"><a class="header" href="#deprecated-1">Deprecated</a></h1>
<p>This annotation marks an item as deprecated, which makes the compiler to emit a warning for each usage of the item. This warning can be disabled using <code>#[allow(deprecated)]</code>.</p>
<p>It is also possible to customize the warning message using the argument <code>note</code>.</p>
<pre><code class="language-sway">#[deprecated(note = "This is deprecated.")]
struct DeprecatedStruct {}

#[allow(deprecated)]
fn using_deprecated_struct() {
    let _ = DeprecatedStruct {};
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="traits"><a class="header" href="#traits">Traits</a></h1>
<p>A trait describes an abstract interface that types can implement. This interface consists of an <code>interface surface</code> of associated items, along with <code>methods</code>.</p>
<pre><code class="language-sway">trait Trait {
    fn fn_sig(self, b: Self) -&gt; bool;
} {
    fn method(self, b: Self) -&gt; bool {
        true
    }
}
</code></pre>
<p>Associated items come in two varieties:</p>
<ul>
<li><a href="documentation/language/traits/index.html#associated-functions">Functions</a></li>
<li><a href="documentation/language/traits/index.html#associated-constants">Constants</a></li>
<li><a href="documentation/language/traits/index.html#associated-types">Types</a></li>
</ul>
<p>All traits define an implicit type parameter <code>Self</code> that refers to "the type that is implementing this interface".
Traits may also contain additional type parameters. These type parameters, including <code>Self</code>, may be constrained by
other traits and so forth as usual.</p>
<p>Traits are implemented for specific types through separate implementations.</p>
<h2 id="associated-functions-1"><a class="header" href="#associated-functions-1">Associated functions</a></h2>
<p>Trait functions consist of just a function signature. This indicates that the implementation must define the function.</p>
<h2 id="associated-constants"><a class="header" href="#associated-constants">Associated constants</a></h2>
<p>Associated constants are constants associated with a type.</p>
<p>An <em>associated constant declaration</em> declares a signature for <em>associated constant definitions</em>.
It is written as <code>const</code>, then an identifier, then <code>:</code>, then a type, finished by a <code>;</code>.</p>
<p>The identifier is the name of the constant used in the path. The type is the type that the definition has to implement.</p>
<p>An <em>associated constant definition</em> defines a constant associated with a type.</p>
<h3 id="associated-constants-examples"><a class="header" href="#associated-constants-examples">Associated constants examples</a></h3>
<pre><code class="language-sway">script;

trait T {
    const C: bool;
}

struct S {}

impl T for S {
    const C: bool = true;
}

fn main() -&gt; bool {
    let s = S {};
    S::C
}
</code></pre>
<p>Associated constants may omit the equals sign and expression to indicate implementations must define the constant value.</p>
<h2 id="associated-types"><a class="header" href="#associated-types">Associated types</a></h2>
<p>Associated types in Sway allow you to define placeholder types within a trait, which can be customized by concrete
implementations of that trait. These associated types are used to specify the return types of trait methods or to
define type relationships within the trait.</p>
<h3 id="associated-types-examples"><a class="header" href="#associated-types-examples">Associated types examples</a></h3>
<pre><code class="language-sway">script;

trait TypeTrait {
    type T;

    fn method(self, s1: Self::T) -&gt; Self::T;
}

struct Struct {}

struct Struct2 {}

impl TypeTrait for Struct2 {
  type T = Struct;

  fn method(self, s1: Self::T) -&gt; Self::T {
    s1
  }
}

fn main() -&gt; u32 {
  Struct2{}.method(Struct{});

  1
}

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="generics"><a class="header" href="#generics">Generics</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="style-guide"><a class="header" href="#style-guide">Style Guide</a></h1>
<p>Programming languages have different ways of styling code i.e. how variables, functions, structures etc. are written.</p>
<p>The following snippets present the style guide for writing <code>Sway</code>.</p>
<blockquote>
<p>TODO: overview of content</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="naming-convention"><a class="header" href="#naming-convention">Naming Convention</a></h1>
<p>A naming convention is a set of rules used to standardize how code is written.</p>
<h2 id="capitalcase"><a class="header" href="#capitalcase">CapitalCase</a></h2>
<p><a href="documentation/language/style-guide/../built-ins/structs.html">Structs</a>, <a href="documentation/language/style-guide/../traits/index.html">traits</a>, and <a href="documentation/language/style-guide/../built-ins/enums.html">enums</a> are <code>CapitalCase</code> which means each word has a capitalized first letter. The fields inside a struct should be <a href="documentation/language/style-guide/name-convention.html#snake_case">snake_case</a> and <code>CapitalCase</code> inside an enum.</p>
<pre><code class="language-sway">struct MultiSignatureWallet {
    owner_count: u64,
}

trait MetaData {
    // code
}

enum DepositError {
    IncorrectAmount: (),
    IncorrectAsset: (),
}
</code></pre>
<h2 id="snake_case"><a class="header" href="#snake_case">snake_case</a></h2>
<p>Modules, <a href="documentation/language/style-guide/../variables/index.html">variables</a>, and <a href="documentation/language/style-guide/../functions/index.html">functions</a> are <code>snake_case</code> which means that each word is lowercase and separated by an underscore.</p>
<p>Module name:</p>
<pre><code class="language-sway">library;
</code></pre>
<p>Function and variable:</p>
<pre><code class="language-sway">fn authorize_user(user: Identity) {
    let blacklist_user = false;
    // code
}
</code></pre>
<h2 id="screaming_snake_case"><a class="header" href="#screaming_snake_case">SCREAMING_SNAKE_CASE</a></h2>
<p><a href="documentation/language/style-guide/../variables/const.html">Constants</a> are <code>SCREAMING_SNAKE_CASE</code> which means that each word in capitalized and separated by an underscore.</p>
<pre><code class="language-sway">const MAXIMUM_DEPOSIT = 10;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="type-annotations"><a class="header" href="#type-annotations">Type Annotations</a></h1>
<p>When declaring a variable it is possible to annotate it with a type; however, the compiler can usually infer that information automatically.</p>
<p>The general approach is to omit a type if the compiler does not throw an error; however, if it is deemed clearer by the developer to indicate the type then that is also encouraged.</p>
<pre><code class="language-sway">fn execute() {
    // Avoid unless it's more helpful to annotate
    let executed: bool = false;

    // Generally encouraged
    let executed = false;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="struct-shorthand"><a class="header" href="#struct-shorthand">Struct Shorthand</a></h1>
<p>A <a href="documentation/language/style-guide/../built-ins/structs.html">struct</a> has a shorthand notation for initializing its fields. The shorthand works by passing a variable into a struct with the exact same name and type.</p>
<p>The following struct has a field <code>amount</code> with type <code>u64</code>.</p>
<pre><code class="language-sway">struct Structure {
    amount: u64,
}
</code></pre>
<p>Using the shorthand notation we can initialize the struct in the following way.</p>
<pre><code class="language-sway">fn call(amount: u64) {
    let structure = Structure { amount };
}
</code></pre>
<p>The shorthand is encouraged because it is a cleaner alternative to the following.</p>
<pre><code class="language-sway">fn action(value: u64) {
    let amount = value;
    let structure = Structure { amount: value };
    let structure = Structure { amount: amount };
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="enums-2"><a class="header" href="#enums-2">Enums</a></h1>
<p>An <a href="documentation/language/style-guide/../../language/built-ins/enums.html"><code>enum</code></a> may contain many types including other enums.</p>
<pre><code class="language-sway">pub enum Error {
    StateError: StateError,
    UserError: UserError,
}

pub enum StateError {
    Void: (),
    Pending: (),
    Completed: (),
}

pub enum UserError {
    InsufficientPermissions: (),
    Unauthorized: (),
}
</code></pre>
<h2 id="encouraged"><a class="header" href="#encouraged">Encouraged</a></h2>
<p>The preferred way to use <a href="documentation/language/style-guide/../built-ins/enums.html"><code>enums</code></a> is to use the individual (not nested) enums directly because they are easy to follow and the lines are short:</p>
<pre><code class="language-sway">    let error1 = StateError::Void;
    let error2 = UserError::Unauthorized;
</code></pre>
<h2 id="discouraged"><a class="header" href="#discouraged">Discouraged</a></h2>
<p>If you wish to use the nested form of enums via the <code>Error</code> enum from the example above, then you can instantiate them into variables using the following syntax:</p>
<pre><code class="language-sway">    let error1 = Error::StateError(StateError::Void);
    let error2 = Error::UserError(UserError::Unauthorized);
</code></pre>
<p>Key points to note:</p>
<ul>
<li>You must import all of the enums i.e. <code>Error</code>, <code>StateError</code> &amp; <code>UserError</code></li>
<li>The lines may get unnecessarily long (depending on the names)</li>
<li>The syntax is unergonomic</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="returning"><a class="header" href="#returning">Returning</a></h1>
<p>In <a href="documentation/language/style-guide/../functions/return.html">returning from functions</a> we outline two styles of returning:</p>
<ul>
<li><a href="documentation/language/style-guide/../functions/return.html#explicit-return">Explicitly</a> which uses the <code>return</code> keyword</li>
<li><a href="documentation/language/style-guide/../functions/return.html#implicit-return">Implicitly</a> which does not use the <code>return</code> keyword</li>
</ul>
<p>In general the preferred style is to follow the <a href="documentation/language/style-guide/../functions/return.html#implicit-return">implicit</a> return however both are perfectly acceptable.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pattern-matching"><a class="header" href="#pattern-matching">Pattern Matching</a></h1>
<p>The following examples present pattern matching using the <a href="documentation/language/style-guide/../../language/control-flow/match/index.html"><code>match</code></a> keyword for the catch-all case.</p>
<h2 id="encouraged-1"><a class="header" href="#encouraged-1">Encouraged</a></h2>
<p>The <code>_</code> is used for the catch-all to indicate the important cases have been defined above and the last case is not important enough to warrant a name.</p>
<pre><code class="language-sway">fn unnamed_case(shape: Shape) {
    let value = match shape {
        Shape::Triangle =&gt; 3,
        Shape::Quadrilateral =&gt; 4,
        Shape::Pentagon =&gt; 5,
        _ =&gt; 0,
    };
}
</code></pre>
<h2 id="alternative"><a class="header" href="#alternative">Alternative</a></h2>
<p>We may apply an appropriate name to provide context to the reader; however, unless it provides additional information the preferred usage is defined in the <a href="documentation/language/style-guide/pattern-matching.html#encouraged"><code>encouraged</code></a> case.</p>
<pre><code class="language-sway">fn named_case(shape: Shape) {
    let value = match shape {
        Shape::Triangle =&gt; 3,
        Shape::Quadrilateral =&gt; 4,
        Shape::Pentagon =&gt; 5,
        _invalid_shape =&gt; 0,
    };
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="comments-1"><a class="header" href="#comments-1">Comments</a></h1>
<p>In <a href="documentation/language/style-guide/../comments/index.html#regular-comments">regular comments</a> we outline two forms:</p>
<ul>
<li><code>// comment</code></li>
<li><code>/* comment */</code></li>
</ul>
<p>The first form is generally encouraged however there may be instances where a comment needs to be placed in the middle of some code in which case the second form is encouraged.</p>
<p>For example, in <a href="documentation/language/style-guide/../functions/index.html#function-declaration">function declaration</a> the second form is used to indicate additional parameters.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="getter-functions"><a class="header" href="#getter-functions">Getter Functions</a></h1>
<p>Functions that return values typically follow one of two styles:</p>
<ul>
<li>Prepending <code>get_</code> to the start of the name</li>
<li>Omitting <code>get_</code></li>
</ul>
<h2 id="encouraged-2"><a class="header" href="#encouraged-2">Encouraged</a></h2>
<p>In Sway the encouraged usage is to omit the <code>get_</code> prefix.</p>
<pre><code class="language-sway">fn maximum_deposit() -&gt; u64 {
    100
}
</code></pre>
<h2 id="discouraged-1"><a class="header" href="#discouraged-1">Discouraged</a></h2>
<p>That is to say the following is discouraged.</p>
<pre><code class="language-sway">fn get_maximum_deposit() -&gt; u64 {
    100
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="unused-variables"><a class="header" href="#unused-variables">Unused Variables</a></h1>
<p>A good practice is naming variables appropriately; however, variables may be unused at times such as the <code>timestamp</code> from the <code>call()</code>.</p>
<pre><code class="language-sway">fn unused_variable() -&gt; u64 {
    let (timestamp, deposit_amount) = call();

    deposit_amount
}
</code></pre>
<h2 id="named"><a class="header" href="#named">Named</a></h2>
<p>We may preserve the name to provide context to the reader by prepending the variable with <code>_</code>.</p>
<pre><code class="language-sway">fn named_unused_variable() -&gt; u64 {
    let (_timestamp, deposit_amount) = call();

    deposit_amount
}
</code></pre>
<h2 id="nameless"><a class="header" href="#nameless">Nameless</a></h2>
<p>We may discard the context and the value by assigning it to <code>_</code>.</p>
<pre><code class="language-sway">fn nameless_variable() -&gt; u64 {
    let (_, deposit_amount) = call();

    deposit_amount
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="intermediate-variables"><a class="header" href="#intermediate-variables">Intermediate Variables</a></h1>
<p>An intermediate variable, or a temporary variable, is a variable that is typically used once. In most cases we avoid creating intermediate variables; however, there are cases where they may enrich the code.</p>
<h2 id="contextual-assignment"><a class="header" href="#contextual-assignment">Contextual Assignment</a></h2>
<p>It may be beneficial to use an intermediate variable to provide context to the reader about the value.</p>
<pre><code class="language-sway">fn contextual_assignment() {
    let remaining_amount = update_state();
    // code that uses `remaining_amount` instead of directly calling `update_state()`
}
</code></pre>
<h2 id="shortened-name"><a class="header" href="#shortened-name">Shortened Name</a></h2>
<p>In the cases of multiple levels of indentation or overly verbose names it may be beneficial to create an intermediate variable with a shorter name.</p>
<pre><code class="language-sway">fn shortened_name() {
    let remaining_amount = update_state_of_vault_v3_storage_contract();
    // code that uses `remaining_amount` instead of directly calling `update_state_of_vault_v3_storage_contract()`
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="storage-1"><a class="header" href="#storage-1">Storage</a></h1>
<p>A <a href="documentation/operations/storage/../../language/program-types/contract.html">smart contract</a> is able to perform computation and store &amp; manipulate data over time.</p>
<p>In the following sections we'll take a look at how Sway handles <code>storage</code> through:</p>
<ul>
<li><a href="documentation/operations/storage/init.html">Storage Initialization</a>: How to declare a <code>storage</code> block</li>
<li><a href="documentation/operations/storage/read-write.html">Reading &amp; Writing</a>: How to read from and write to storage</li>
<li><a href="documentation/operations/storage/libraries/index.html">Libraries</a>: Additional functionality provided by the <a href="https://github.com/FuelLabs/sway/blob/master/sway-lib-std/src/storage.sw">storage library</a></li>
<li><a href="documentation/operations/storage/namespace.html">Namespaces</a>: How to use <code>storage</code> namespaces</li>
<li><a href="documentation/operations/storage/in-keyword.html">In keyword</a>: How to override storage variable position</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="initialization"><a class="header" href="#initialization">Initialization</a></h1>
<p>Storage is declared through the use of the <code>storage</code> keyword.</p>
<p>Inside the <code>storage</code> block each variable is named, associated with a type and a default value.</p>
<pre><code class="language-sway">storage {
    // variable_name1: variable_type1 = default_value1,
    // variable_name2: variable_type2 = default_value2,
    // ...
}
</code></pre>
<h2 id="example-3"><a class="header" href="#example-3">Example</a></h2>
<p>In the following example we will take a look at two ways of storing a struct.</p>
<ul>
<li>Explicitly declaring the values in the <code>storage</code> block</li>
<li>Encapsulating the values in an <a href="documentation/operations/storage/../../language/functions/index.html">associated function</a></li>
</ul>
<p>We'll begin by defining the <code>Owner</code> &amp; <code>Role</code> data structures and implement a <code>default</code> <a href="documentation/operations/storage/../../language/functions/associated-function.html#constructors">constructor</a> on the <code>Owner</code>.</p>
<pre><code class="language-sway">struct Owner {
    maximum_owners: u64,
    role: Role,
}

impl Owner {
    // a constructor that can be evaluated to a constant `Owner` during compilation
    fn default() -&gt; Self {
        Self {
            maximum_owners: 10,
            role: Role::FullAccess,
        }
    }
}

enum Role {
    FullAccess: (),
    PartialAccess: (),
    NoAccess: (),
}
</code></pre>
<p>Now that we have our data structures we'll keep track of how many <code>current_owners</code> we have and declare the owner in the two aforementioned styles.</p>
<pre><code class="language-sway">storage {
    current_owners: u64 = 0,
    explicit_declaration: Owner = Owner {
        maximum_owners: 10,
        role: Role::FullAccess,
    },
    encapsulated_declaration: Owner = Owner::default(),
}
</code></pre>
<p>An explicit declaration is likely to be sufficient for most types. However, it may be preferable to encapsulate the initialization of complex types within a <a href="documentation/operations/storage/../../language/functions/associated-function.html#constructors">constructor</a> in order to keep the code concise.</p>
<p>Note that the constructors used in <code>storage</code> blocks must evaluate to a constant during compilation.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="reading--writing-1"><a class="header" href="#reading--writing-1">Reading &amp; Writing</a></h1>
<p>When dealing with storage we have two options, we can either read from or write to storage. In both cases we must use a <a href="documentation/operations/storage/../../language/annotations/attributes/storage.html">storage annotation</a> to indicate the purity of the function.</p>
<p>When referencing a variable in storage we must explicitly indicate that the variable comes from storage and not a local scope.</p>
<p>This is done via the syntax <code>storage.variable_name</code> e.g. <code>storage.counter</code>.</p>
<pre><code class="language-sway">storage {
    counter: u64 = 0,
}
</code></pre>
<h2 id="reading-from-storage-1"><a class="header" href="#reading-from-storage-1">Reading from Storage</a></h2>
<p>When dealing with a <a href="documentation/operations/storage/../../language/built-ins/index.html">built-in</a> type we can retrieve the variable without the use of any special methods.</p>
<pre><code class="language-sway">#[storage(read)]
fn read() {
    let counter = storage.counter.read();
}
</code></pre>
<h2 id="writing-to-storage-1"><a class="header" href="#writing-to-storage-1">Writing to Storage</a></h2>
<p>When dealing with a <a href="documentation/operations/storage/../../language/built-ins/index.html">built-in</a> type we can update the variable without the use of any special methods.</p>
<pre><code class="language-sway">#[storage(write)]
fn write() {
    storage.counter.write(storage.counter.read() + 1);
}
</code></pre>
<h2 id="read--write"><a class="header" href="#read--write">Read &amp; Write</a></h2>
<p>We can read and write to storage by using both keywords in the attribute.</p>
<pre><code class="language-sway">#[storage(read, write)]
fn read_write() {
    let counter = storage.counter.read();
    storage.counter.write(counter + 1);
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="libraries-1"><a class="header" href="#libraries-1">Libraries</a></h1>
<p>The <a href="https://github.com/FuelLabs/sway/tree/master/sway-lib-std">standard library</a> provides additional utility for handling <a href="https://github.com/FuelLabs/sway/blob/master/sway-lib-std/src/storage.sw">storage</a>.</p>
<ul>
<li><a href="documentation/operations/storage/libraries/storage-map.html">Mapping</a>: Tracking key-value pairs</li>
<li><a href="documentation/operations/storage/libraries/storage-vec.html">Vectors</a>: Using a persistent (not heap-allocated) vector</li>
<li><a href="documentation/operations/storage/libraries/store-get.html">Store &amp; Get</a>: Manually manipulating storage slots</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="storagemap"><a class="header" href="#storagemap">StorageMap</a></h1>
<p>A <code>StorageMap</code>, a.k.a. a hash table, is a structure which associates a value <code>v</code> with a key <code>k</code>. The key is used to find the position in the table (memory) where the value is stored.</p>
<p>The benefit of a hash table is that no matter where the value is in the table the computation required to find the location of that value is constant i.e. it has an order of 1 <code>O(1)</code>.</p>
<p>Sway provides a flexible <code>StorageMap</code> because it uses <a href="documentation/operations/storage/libraries/../../../language/generics/index.html">generics</a> for both <code>k</code> &amp; <code>v</code> with the caveat that <code>k</code> and <code>v</code> have to be a single value. The value can be a <a href="documentation/operations/storage/libraries/../../../language/built-ins/structs.html">struct</a>, <a href="documentation/operations/storage/libraries/../../../language/built-ins/tuples.html">tuple</a>, <a href="documentation/operations/storage/libraries/../../../language/built-ins/arrays.html">array</a> etc. therefore if you'd like to have a complex <code>k</code> or <code>v</code> then the data needs to be wrapped into a single type.</p>
<h2 id="declaration-5"><a class="header" href="#declaration-5">Declaration</a></h2>
<p>The <code>StorageMap</code> type is included in the <a href="documentation/operations/storage/libraries/../../../misc/prelude.html">prelude</a> therefore we do not need to import it. We'll be using <code>msg_sender()</code> in the subsequent section so we'll import that here.</p>
<p>After the import we initialize our <code>StorageMap</code> as described in the <a href="documentation/operations/storage/libraries/../init.html">initialization</a> section.</p>
<pre><code class="language-sway">
storage {
    // k = Identity, v = u64
    balance: StorageMap&lt;Identity, u64&gt; = StorageMap::&lt;Identity, u64&gt; {},
    // k = (Identity, u64), v = bool
    user: StorageMap&lt;(Identity, u64), bool&gt; = StorageMap::&lt;(Identity, u64), bool&gt; {},
}
</code></pre>
<p>There are two <code>storage</code> variables: <code>balance</code> &amp; <code>user</code>. <code>balance</code> takes a single value as the key while <code>user</code> wraps two values into a <a href="documentation/operations/storage/libraries/../../../language/built-ins/tuples.html">tuple</a> and uses that as a key.</p>
<h2 id="reading-from-storage-2"><a class="header" href="#reading-from-storage-2">Reading from Storage</a></h2>
<p>Retrieving data from a storage variable is done through the <code>.get(key)</code> method. That is to say that we state which storage variable we would like to read from and append <code>.get()</code> to the end while providing the key for the data that we want to retrieve. The method <code>get</code> returns an <code>Option</code>; if there is no value for <code>key</code> in the map, <code>get</code> will return <code>None</code>.</p>
<p>In this example we wrap the <a href="documentation/operations/storage/libraries/../../namespace/identity.html"><code>Identity</code></a> of the caller with their provided <code>id</code> into a <a href="documentation/operations/storage/libraries/../../../language/built-ins/tuples.html">tuple</a> and use that as the key.</p>
<pre><code class="language-sway">#[storage(read)]
fn reading_from_storage(id: u64) {
    let user = storage.user.get((msg_sender().unwrap(), id)).read();
}
</code></pre>
<p>This contract method handles the returned <code>Option</code> by calling <code>unwrap_or</code> to set <code>user</code> to zero if the map <code>user</code> doesn't have an entry for the key.</p>
<h2 id="writing-to-storage-2"><a class="header" href="#writing-to-storage-2">Writing to Storage</a></h2>
<p>Writing to storage is similar to <a href="documentation/operations/storage/libraries/storage-map.html#reading-from-storage">reading</a>. The difference is that we use a different method <code>.insert(key, value)</code>.</p>
<p>In this example we retrieve the balance of the caller and then increment their balance by 1.</p>
<pre><code class="language-sway">#[storage(read, write)]
fn writing_to_storage() {
    let balance = storage.balance.get(msg_sender().unwrap()).read();
    storage.balance.insert(msg_sender().unwrap(), balance + 1);
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="storagevec"><a class="header" href="#storagevec">StorageVec</a></h1>
<p>A <code>StorageVec</code> is a vector that permanently stores its data in <code>storage</code>. It replicates the functionality of a regular vector however its data is not stored contiguously because it utilizes hashing and <a href="documentation/operations/storage/libraries/../../../language/generics/index.html">generics</a> to find a location to store the value <code>T</code>.</p>
<p>There is a number of methods in the <a href="https://github.com/FuelLabs/sway/blob/master/sway-lib-std/src/storage.sw">standard library</a> however we will take a look at pushing and retrieving data.</p>
<h2 id="declaration-6"><a class="header" href="#declaration-6">Declaration</a></h2>
<p>To use a <code>StorageVec</code> we need to import it from the <a href="https://github.com/FuelLabs/sway/tree/master/sway-lib-std">standard library</a> and while we're at it we'll import the <code>msg_sender()</code> so that we can use it in the following section.</p>
<p>After the import we initialize our <code>StorageVec</code> as described in the <a href="documentation/operations/storage/libraries/../init.html">initialization</a> section.</p>
<pre><code class="language-sway">use std::storage::storage_vec::*;

storage {
    // T = u64
    balance: StorageVec&lt;u64&gt; = StorageVec {},
    // T = (Identity, u64)
    user: StorageVec&lt;(Identity, u64)&gt; = StorageVec {},
}
</code></pre>
<p>There are two <code>storage</code> variables: <code>balance</code> &amp; <code>user</code>. <code>balance</code> takes a single value while <code>user</code> wraps two values into a <a href="documentation/operations/storage/libraries/../../../language/built-ins/tuples.html">tuple</a>.</p>
<h2 id="reading-from-storage-3"><a class="header" href="#reading-from-storage-3">Reading from Storage</a></h2>
<p>Retrieving data from a storage variable is done through the <code>.get(index)</code> method. That is to say that we state which index by specifying it inside <code>.get()</code> and appending that to the end of the storage variable.</p>
<p>In this example we look at how we can retrieve a single value <code>balance</code> and how we can unpack multiple values from <code>user</code>.</p>
<pre><code class="language-sway">#[storage(read)]
fn reading_from_storage(id: u64) {
    let balance = storage.balance.get(id).unwrap();

    let (user, value) = storage.user.get(id).unwrap().read();
}
</code></pre>
<h2 id="writing-to-storage-3"><a class="header" href="#writing-to-storage-3">Writing to Storage</a></h2>
<p>Writing to storage is similar to <a href="documentation/operations/storage/libraries/storage-vec.html#reading-from-storage">reading</a>. The difference is that we use a different method <code>.push(value)</code> and we use the <code>read</code> keyword because the implementation reads the length of the vector to determine where to store the value.</p>
<p>In this example we insert a <a href="documentation/operations/storage/libraries/../../../language/built-ins/tuples.html">tuple</a> containing an the <a href="documentation/operations/storage/libraries/../../namespace/identity.html"><code>Identity</code></a> of the caller and some <code>id</code> into the vector.</p>
<pre><code class="language-sway">#[storage(read, write)]
fn writing_to_storage(id: u64) {
    storage.user.push((msg_sender().unwrap(), id));
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="store--get"><a class="header" href="#store--get">Store &amp; Get</a></h1>
<p>Storage can be manipulated directly through the use of <code>store()</code> &amp; <code>get()</code> functions. They utilize <a href="documentation/operations/storage/libraries/../../../language/generics/index.html">generics</a> to store and retrieve values.</p>
<h2 id="declaration-7"><a class="header" href="#declaration-7">Declaration</a></h2>
<p>To use <code>store()</code> &amp; <code>get()</code> we must import them however we are not required to declare a <code>storage</code> block.</p>
<pre><code class="language-sway">use std::storage::storage_api::{read, write};
</code></pre>
<h2 id="store"><a class="header" href="#store">Store</a></h2>
<p>To store a generic value <code>T</code> we must provide a key of type <code>b256</code>.</p>
<p>In this example we store some number of type <code>u64</code>.</p>
<pre><code class="language-sway">#[storage(write)]
fn store(key: b256, value: u64) {
    // write(key, SLOT, T) where T = generic type
    write(key, 0, value);
}
</code></pre>
<h2 id="get"><a class="header" href="#get">Get</a></h2>
<p>To retrieve a generic value <code>T</code> at the position of <code>key</code> we must specify the type that we are retrieving.</p>
<p>In this example we retrieve some <code>u64</code> at the position of <code>key</code>.</p>
<pre><code class="language-sway">#[storage(read)]
fn get(key: b256) {
    // read::&lt;T&gt;(key, SLOT) where T = generic type
    let value = read::&lt;u64&gt;(key, 0);
}
</code></pre>
<p>The function <code>get</code> returns an <code>Option</code>; if the storage slots requested have not been set before, <code>get</code> will return <code>None</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="assertions"><a class="header" href="#assertions">Assertions</a></h1>
<p>An assertion is a condition which must evaluate to the <a href="documentation/operations/assertions/../../language/built-ins/boolean.html">Boolean</a> value of <code>true</code> and its purpose is to prevent undesirable computation when the condition is evaluated to <code>false</code>.</p>
<p>For example, a function may only work if the condition <code>argument &lt; 5</code> is <code>true</code>. We can use an assertion to enforce this condition by:</p>
<ul>
<li>Forcing a revert in the program when <code>5 &lt;= argument</code></li>
<li>Handling the exception with additional code</li>
</ul>
<p>Handling exceptions may be done through <a href="documentation/operations/assertions/../../language/control-flow/if-expressions.html">if expressions</a> therefore the following sections will take a look at how we can make the virtual machine revert (safely crash).</p>
<ul>
<li><a href="documentation/operations/assertions/assert.html"><code>assert</code></a>: Checks if a <code>condition</code> is <code>true</code> otherwise reverts</li>
<li><a href="documentation/operations/assertions/require.html"><code>require</code></a>: Checks if a <code>condition</code> is <code>true</code> otherwise logs a <code>value</code> and reverts</li>
<li><a href="documentation/operations/assertions/revert.html"><code>revert</code></a>: Reverts the virtual machine with the provided exit code</li>
<li><a href="documentation/operations/assertions/assert-eq.html"><code>assert_eq</code></a>: Checks if <code>a</code> and <code>b</code> are equal otherwise reverts</li>
<li><a href="documentation/operations/assertions/assert-ne.html"><code>assert_ne</code></a>: Checks if <code>a</code> and <code>b</code> are not equal otherwise reverts</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="assert"><a class="header" href="#assert">assert</a></h1>
<p>The <code>assert</code> function is automatically imported into every program from the <a href="documentation/operations/assertions/../../misc/prelude.html">prelude</a> and it takes an expression which must evaluate to a <a href="documentation/operations/assertions/../../language/built-ins/boolean.html">Boolean</a>. If the Boolean is <code>true</code> then nothing will happen and the code will continue to run otherwise the virtual machine will revert.</p>
<h2 id="example-4"><a class="header" href="#example-4">Example</a></h2>
<p>Here we have a function which takes two <code>u64</code> arguments and subtracts them. A <code>u64</code> cannot be negative therefore the assertion enforces that <code>b</code> must be less than or equal to <code>a</code>.</p>
<p>If the condition is not met, then the virtual machine will revert.</p>
<pre><code class="language-sway">fn subtract(a: u64, b: u64) -&gt; u64 {
    assert(b &lt;= a);
    a - b
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="require"><a class="header" href="#require">require</a></h1>
<p>The <code>require</code> function is automatically imported into every program from the <a href="documentation/operations/assertions/../../misc/prelude.html">prelude</a> and it takes an expression which must evaluate to a <a href="documentation/operations/assertions/../../language/built-ins/boolean.html">Boolean</a>. If the Boolean is <code>true</code> then nothing will happen and the rest of the code will continue to run otherwise a log will be emitted and the virtual machine will revert.</p>
<h2 id="example-5"><a class="header" href="#example-5">Example</a></h2>
<p>Here we have a function which takes two <code>u64</code> arguments and subtracts them. A <code>u64</code> cannot be negative therefore the assertion enforces that <code>b</code> must be less than or equal to <code>a</code>.</p>
<p>If the condition is not met then the message <code>b is too large</code> will be logged and the virtual machine will revert.</p>
<p>The message is <a href="documentation/operations/assertions/../../language/generics/index.html">generic</a> therefore it can be any type, in this example it's a string.</p>
<pre><code class="language-sway">fn subtract(a: u64, b: u64) -&gt; u64 {
    require(b &lt;= a, "b is too large");
    a - b
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="revert"><a class="header" href="#revert">revert</a></h1>
<p>The <code>revert</code> function is automatically imported into every program from the <a href="documentation/operations/assertions/../../misc/prelude.html">prelude</a> and it takes a <code>u64</code> as an exit code.</p>
<p>The function will behave differently depending on the context in which it is used:</p>
<ul>
<li>When used inside a <a href="documentation/operations/assertions/../../language/program-types/predicate.html">predicate</a> the function will panic and crash the program</li>
<li>Otherwise it will revert the virtual machine</li>
</ul>
<h2 id="example-6"><a class="header" href="#example-6">Example</a></h2>
<p>To manually force a revert we need to provide an exit code. To be able to distinguish one revert from another different exit codes can be used in different places.</p>
<pre><code class="language-sway">    revert(42);
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="assert_eq"><a class="header" href="#assert_eq">assert_eq</a></h1>
<p>The <code>assert_eq</code> function is automatically imported into every program from the <a href="documentation/operations/assertions/../../misc/prelude.html">prelude</a>. It takes two expressions which are compared and the result is a <a href="documentation/operations/assertions/../../language/built-ins/boolean.html">Boolean</a>. If the value is <code>false</code> then the virtual machine will revert.</p>
<h2 id="example-7"><a class="header" href="#example-7">Example</a></h2>
<p>Here is a function which asserts that <code>a</code> and <code>b</code> must be equal.</p>
<pre><code class="language-sway">fn compare_eq(a: u64, b: u64) {
    assert_eq(a, b);
    // code
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="assert_ne"><a class="header" href="#assert_ne">assert_ne</a></h1>
<p>The <code>assert_ne</code> function is automatically imported into every program from the <a href="documentation/operations/assertions/../../misc/prelude.html">prelude</a>. It takes two expressions which are compared and the result is a <a href="documentation/operations/assertions/../../language/built-ins/boolean.html">Boolean</a>. If the value is <code>false</code> then the virtual machine will revert.</p>
<h2 id="example-8"><a class="header" href="#example-8">Example</a></h2>
<p>Here is a function which asserts that <code>a</code> and <code>b</code> must not be equal.</p>
<pre><code class="language-sway">fn compare_ne(a: u64, b: u64) {
    assert_ne(a, b);
    // code
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="address-namespace"><a class="header" href="#address-namespace">Address Namespace</a></h1>
<p>Sway utilizes namespaces to distinguish between address types.</p>
<p>Having multiple address types enforces type-safety and expands the range of values that an address can take because the same value can be used across multiple types.</p>
<p>The main types are:</p>
<ul>
<li><a href="documentation/operations/namespace/address.html"><code>Address</code></a>: Used to identify the UTXO</li>
<li><a href="documentation/operations/namespace/contract-id.html"><code>ContractId</code></a>: Used to identify a contract</li>
</ul>
<p>For ease of use there is an <a href="documentation/operations/namespace/../../language/built-ins/enums.html">enum</a> wrapper <a href="documentation/operations/namespace/identity.html"><code>Identity</code></a> which contains both types.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="address"><a class="header" href="#address">Address</a></h1>
<p>In the UTXO model each output has an address.</p>
<p>The <code>Address</code> type is a struct containing a value of a <code>b256</code> type.</p>
<pre><code class="language-sway">pub struct Address {
    bits: b256,
}
</code></pre>
<p>The value of an <code>Address</code> is a hash of either:</p>
<ul>
<li>A public key</li>
<li><a href="documentation/operations/namespace/../../language/program-types/predicate.html">Predicate</a></li>
</ul>
<p>The <code>Address</code> type is completely separate from a <a href="documentation/operations/namespace/contract-id.html"><code>ContractId</code></a> and thus it should not be used when dealing with an address of a deployed contract.</p>
<p>Casting between an <code>Address</code> and <code>b256</code> can be done in the following way:</p>
<pre><code class="language-sway">    let variable1 = 0x000000000000000000000000000000000000000000000000000000000000002A;
    let my_address = Address::from(variable1);
    let variable2: b256 = my_address.into();
    // variable1 == variable2
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="contractid"><a class="header" href="#contractid">ContractId</a></h1>
<p>A contract's ID is a unique, deterministic identifier analogous to a contract's address in the EVM. Contracts cannot own UTXOs but they can own assets.</p>
<p>The <code>ContractId</code> type is a struct containing a value of a <code>b256</code> type.</p>
<pre><code class="language-sway">pub struct ContractId {
    bits: b256,
}
</code></pre>
<p>Casting between an <code>ContractId</code> and <code>b256</code> can be done in the following way:</p>
<pre><code class="language-sway">    let variable1 = 0x000000000000000000000000000000000000000000000000000000000000002A;
    let my_contract_id = ContractId::from(variable1);
    let variable2: b256 = my_contract_id.into();
    // variable1 == variable2
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="identity"><a class="header" href="#identity">Identity</a></h1>
<p>The <code>Identity</code> type is an <a href="documentation/operations/namespace/../../language/built-ins/enums.html">enum</a> that allows for the handling of both <a href="documentation/operations/namespace/address.html"><code>Address</code></a> and <a href="documentation/operations/namespace/contract-id.html"><code>ContractId</code></a> types. This is useful in cases where either type is accepted, e.g. receiving funds from an identified sender, but not caring if the sender is an address or a contract.</p>
<p>An <code>Identity</code> is implemented as follows.</p>
<pre><code class="language-sway">pub enum Identity {
    Address: Address,
    ContractId: ContractId,
}
</code></pre>
<p>Casting to an <code>Identity</code> must be done explicitly:</p>
<pre><code class="language-sway">    let address = 0xddec0e7e6a9a4a4e3e57d08d080d71a299c628a46bc609aab4627695679421ca;
    let my_address_identity = Identity::Address(Address::from(address));
    let my_contract_identity = Identity::ContractId(ContractId::from(address));
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="call-data"><a class="header" href="#call-data">Call Data</a></h1>
<p>The term <code>call-data</code> refers to the metadata that is available to the recipient of a call.</p>
<p>In the following sections we'll cover the following <code>call-data</code>:</p>
<ul>
<li><a href="documentation/operations/call-data/msg-sender.html"><code>Message Sender</code></a>: who is making the call</li>
<li><a href="documentation/operations/call-data/msg-asset.html"><code>Asset Sent</code></a>: which asset has been sent into the contract</li>
<li><a href="documentation/operations/call-data/msg-asset-amount.html"><code>Amount of Asset Sent</code></a>: how much of an asset has been sent</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="message-sender"><a class="header" href="#message-sender">Message Sender</a></h1>
<p>The standard <a href="https://github.com/FuelLabs/sway/blob/master/docs/reference/src/documentation/misc/prelude.md">prelude</a> imports a function <a href="https://github.com/FuelLabs/sway/blob/master/sway-lib-std/src/auth.sw"><code>msg_sender()</code></a> automatically, which retrieves the <a href="documentation/operations/call-data/../namespace/identity.html">Identity</a> of the caller.</p>
<p>The identity can be used for a variety of reasons however a common application is access control i.e. restricting functionality for non-privileged users (non-admins).</p>
<h2 id="example-9"><a class="header" href="#example-9">Example</a></h2>
<p>We can implement access control by specifying that only the owner can call a function.</p>
<p>In the following snippet we accomplish this by comparing the caller <code>msg_sender()</code> to the <code>OWNER</code>. If a regular user calls the function then it will revert otherwise it will continue to run when called by the <code>OWNER</code>.</p>
<pre><code class="language-sway">const OWNER = Identity::Address(Address::from(0x0000000000000000000000000000000000000000000000000000000000000000));

fn update() {
    require(msg_sender().unwrap() == OWNER, "Owner Only");
    // code
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="asset-sent"><a class="header" href="#asset-sent">Asset Sent</a></h1>
<p>The <a href="https://github.com/FuelLabs/sway/tree/master/sway-lib-std">standard library</a> provides a function <a href="https://github.com/FuelLabs/sway/blob/master/sway-lib-std/src/call_frames.sw"><code>msg_asset_id()</code></a> which retrieves the <a href="documentation/operations/call-data/../namespace/contract-id.html">ContractId</a> of the asset being sent.</p>
<p>This can be used to determine which asset has been sent into the contract.</p>
<h2 id="example-10"><a class="header" href="#example-10">Example</a></h2>
<p>To use <code>msg_asset_id()</code> we must import it from the standard library. We'll also import the base asset for comparison.</p>
<pre><code class="language-sway">use std::call_frames::msg_asset_id;
</code></pre>
<p>We can check which asset has been sent and perform different computation based on the type.</p>
<pre><code class="language-sway">fn deposit() {
    if msg_asset_id() == AssetId::base() {
        // code
    } else {
        // code
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="amount-of-asset-sent"><a class="header" href="#amount-of-asset-sent">Amount of Asset Sent</a></h1>
<p>The <a href="https://github.com/FuelLabs/sway/tree/master/sway-lib-std">standard library</a> provides a function <a href="https://github.com/FuelLabs/sway/blob/master/sway-lib-std/src/context.sw"><code>msg_amount()</code></a> which retrieves the amount of asset sent without any concern for <a href="documentation/operations/call-data/msg-asset.html">which asset</a> is sent.</p>
<p>This can be used to set a price or manually track the amount sent by each user.</p>
<h2 id="example-11"><a class="header" href="#example-11">Example</a></h2>
<p>To use <code>msg_amount()</code> we must import it from the standard library.</p>
<pre><code class="language-sway">use std::context::msg_amount;
</code></pre>
<p>We can check how much of <em>any</em> asset has been sent and if an incorrect amount has been sent then we may revert.</p>
<pre><code class="language-sway">fn purchase() {
    require(msg_amount() == 100_000_000, "Incorrect amount sent");
    // code
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="logging"><a class="header" href="#logging">Logging</a></h1>
<p>Logging is a way to record data as the program runs.</p>
<p>The <a href="https://github.com/FuelLabs/sway/tree/master/sway-lib-std">standard library</a> provides a <a href="https://github.com/FuelLabs/sway/blob/master/sway-lib-std/src/logging.sw"><code>logging</code></a> module which contains a <a href="documentation/operations/../language/generics/index.html">generic</a> <code>log</code> function that is used to log a variable of any type.</p>
<p>Each call to <code>log</code> appends 1 of 2 types of a <a href="https://fuellabs.github.io/fuel-specs/master/protocol/abi/receipts.html"><code>receipt</code></a> to the list of receipts</p>
<ul>
<li><a href="https://fuellabs.github.io/fuel-specs/master/protocol/abi/receipts.html#log-receipt"><code>Log</code></a>
<ul>
<li>Generated for <em>non-reference</em> types: <code>bool</code>, <code>u8</code>, <code>u16</code>, <code>u32</code>, and <code>u64</code></li>
</ul>
</li>
<li><a href="https://fuellabs.github.io/fuel-specs/master/protocol/abi/receipts.html#logdata-receipt"><code>LogData</code></a>
<ul>
<li>Generated for <em>reference</em> types and <code>u256</code></li>
</ul>
</li>
</ul>
<p>The <a href="https://fuellabs.github.io/fuels-rs/latest/">Rust</a> &amp; <a href="https://fuellabs.github.io/fuels-ts/">Typescript</a> SDKs may be used to decode the data.</p>
<h2 id="example-12"><a class="header" href="#example-12">Example</a></h2>
<p>To use the <code>log</code> function we must import it from the standard library and pass in any <a href="documentation/operations/../language/generics/index.html">generic</a> type <code>T</code> that we want to log.</p>
<pre><code class="language-sway">fn log_data(number: u64) {
    // generic T = `number` of type `u64`
    log(number);
}
</code></pre>
<p>In the example above a <code>u64</code> is used however we can pass in any <a href="documentation/operations/../language/generics/index.html">generic</a> type such as a <a href="documentation/operations/../language/built-ins/structs.html">struct</a>, <a href="documentation/operations/../language/built-ins/enums.html">enum</a>, <a href="documentation/operations/../language/built-ins/string.html">string</a> etc.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="call-a-contract"><a class="header" href="#call-a-contract">Call a Contract</a></h1>
<p>A common blockchain operation is communication between <a href="documentation/operations/../language/program-types/contract.html">smart contracts</a>.</p>
<h2 id="example-13"><a class="header" href="#example-13">Example</a></h2>
<p>To perform a call there are three steps that we must take:</p>
<ol>
<li>Provide an interface to call</li>
<li>Create a type that allows us to make a call</li>
<li>Call a function on our interface</li>
</ol>
<h3 id="defining-the-interface"><a class="header" href="#defining-the-interface">Defining the Interface</a></h3>
<p>Let's take the example of a <code>Vault</code> to demonstrate how a call can be performed.</p>
<pre><code class="language-sway">library;

abi Vault {
    #[payable]
    fn deposit();
    fn withdraw(amount: u64, asset: ContractId);
}
</code></pre>
<h3 id="creating-a-callable-type"><a class="header" href="#creating-a-callable-type">Creating a Callable Type</a></h3>
<p>To call a function on our <code>Vault</code> we must create a type that can perform calls. The syntax for creating a callable type is: <code>abi(&lt;interface-name&gt;, &lt;b256-address&gt;)</code>.</p>
<h3 id="calling-a-contract"><a class="header" href="#calling-a-contract">Calling a Contract</a></h3>
<p>The following snippet uses a <a href="documentation/operations/../language/program-types/script.html"><code>script</code></a> to call our <code>Vault</code> contract.</p>
<pre><code class="language-sway">script;

use contract_interface::Vault;

fn main(amount: u64, asset_id: ContractId, vault_id: b256) -&gt; bool {
    let caller = abi(Vault, vault_id);

    // Optional arguments are wrapped in `{}`
    caller.deposit {
        // `u64` that represents the gas being forwarded to the contract
        gas: 10000,
        // `u64` that represents how many coins are being forwarded
        coins: amount,
        // `b256` that represents the asset ID of the forwarded coins 
        asset_id: asset_id.into(),
    }();

    caller.withdraw(amount, asset_id);

    true
}
</code></pre>
<p>The <code>deposit()</code> function uses pre-defined optional arguments provided by the <code>Sway</code> language.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="re-entrancy"><a class="header" href="#re-entrancy">Re-entrancy</a></h1>
<p>Re-entrancy occurs when a contract makes a call back into the contract that called it, e.g. <code>Contract A</code> calls <code>Contract B</code> but then <code>Contract B</code> makes a call back into <code>Contract A</code>.</p>
<p>To mitigate security concerns there are two approaches that are commonly used:</p>
<ul>
<li><a href="documentation/operations/reentrancy.html#re-entrancy-guard">Implement a guard</a>: detect when a re-entrancy occurs</li>
<li><a href="documentation/operations/reentrancy.html#checks-effects-interactions-pattern">Defensive programming</a>: perform calls after all state changes have been made</li>
</ul>
<h2 id="re-entrancy-guard"><a class="header" href="#re-entrancy-guard">Re-entrancy Guard</a></h2>
<p>Sway provides a stateless <a href="https://fuellabs.github.io/sway-libs/book/reentrancy/index.html">re-entrancy</a> guard, which reverts at run-time when re-entrancy is detected.</p>
<p>To use the guard we must import it.</p>
<pre><code class="language-sway">use reentrancy::reentrancy_guard;
</code></pre>
<p>Then call it in a contract function.</p>
<pre><code class="language-sway">    fn deposit() {
        reentrancy_guard();

        // code
    }
</code></pre>
<h2 id="checks-effects-interactions-pattern"><a class="header" href="#checks-effects-interactions-pattern">Checks-Effects-Interactions Pattern</a></h2>
<p>The pattern states that all state (storage) changes should be made before a call is made.</p>
<pre><code class="language-sway">    fn withdraw() {
        // Step 1. Perform any state changes to update balance
        // Step 2. After all state changes make a call
    }
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="asset-operations"><a class="header" href="#asset-operations">Asset Operations</a></h1>
<p>A common application of a smart contract is the creation of an asset / token i.e. a cryptocurrency.</p>
<p>Managing a cryptocurrency is typically done via the following models:</p>
<ul>
<li>Account based e.g. Ethereum</li>
<li>Unspent Transaction Output (UTXO) e.g. Bitcoin</li>
</ul>
<p>Sway operates on the UTXO model therefore assets can be transferred out of the contract that created them. What this means is that keeping track of assets that have been transferred out of the contract may be more difficult because the information is not centralized in one place.</p>
<p>With that regard in mind, the account based approach can be partially replicated while utilizing certain asset operations that are build into the FuelVM.</p>
<p>The following sections will take a look at how an asset can be:</p>
<ul>
<li><a href="documentation/operations/asset/mint/index.html"><code>Minted</code></a> (created)</li>
<li><a href="documentation/operations/asset/burn.html"><code>Burned</code></a> (destroyed)</li>
<li><a href="documentation/operations/asset/transfer/index.html"><code>Transferred</code></a> (sent)</li>
</ul>
<p>While also taking a look at:</p>
<ul>
<li><a href="documentation/operations/asset/balance.html"><code>The contract balance</code></a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="minting"><a class="header" href="#minting">Minting</a></h1>
<p>Minting an asset means to create a new asset with an id of the contract that created it.</p>
<p>The <a href="https://github.com/FuelLabs/sway/tree/master/sway-lib-std">standard library</a> contains a <a href="https://github.com/FuelLabs/sway/blob/master/sway-lib-std/src/asset.sw"><code>module</code></a> that can be used to mint an asset.</p>
<p>There are two functions that can be used to mint:</p>
<!-- no toc -->
<ul>
<li><a href="documentation/operations/asset/mint/./mint.html"><code>mint()</code></a></li>
<li><a href="documentation/operations/asset/mint/./address-or-contract.html"><code>mint_to()</code></a></li>
</ul>
<p>Specific implementation details on transferring assets to addresses can be found <a href="documentation/operations/asset/mint/./address.html">here</a>.</p>
<p>Specific implementation details on transferring assets to contracts can be found <a href="documentation/operations/asset/mint/./contract.html">here</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mint"><a class="header" href="#mint">Mint</a></h1>
<p>To use the function we must import it.</p>
<pre><code class="language-sway">use std::asset::mint;
</code></pre>
<p>To mint some amount of an asset we specify the <code>amount</code> that we would like to mint and pass it into the <code>mint()</code> function.</p>
<pre><code class="language-sway">    let amount = 10;
    mint(SubId::zero(), amount);
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mint-to-address"><a class="header" href="#mint-to-address">Mint to Address</a></h1>
<p>We can <a href="documentation/operations/asset/mint/mint.html"><code>mint</code></a> and <a href="documentation/operations/asset/mint/../transfer/index.html"><code>transfer</code></a> the asset to an <a href="documentation/operations/asset/mint/../../namespace/address.html"><code>Address</code></a>.</p>
<p>To use the function we must import it.</p>
<pre><code class="language-sway">use std::asset::mint_to;
</code></pre>
<p>To mint some amount of an asset we specify the <code>amount</code> that we would like to mint and the <code>Address</code> to send it to.</p>
<pre><code class="language-sway">    let amount = 10;
    let address = 0x0000000000000000000000000000000000000000000000000000000000000001;
    let user = Address::from(address);

    mint_to(Identity::Address(user), SubId::zero(), amount);
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mint-to-contract"><a class="header" href="#mint-to-contract">Mint to Contract</a></h1>
<p>We can <a href="documentation/operations/asset/mint/mint.html"><code>mint</code></a> and <a href="documentation/operations/asset/mint/../transfer/index.html"><code>transfer</code></a> the asset to an <a href="documentation/operations/asset/mint/../../namespace/contract-id.html"><code>Contract</code></a>.</p>
<p>To use the function we must import it.</p>
<pre><code class="language-sway">use std::asset::mint_to;
</code></pre>
<p>To mint some amount of an asset we specify the <code>amount</code> that we would like to mint and the <code>ContractId</code> to send it to.</p>
<pre><code class="language-sway">    let amount = 10;
    let address = 0x0000000000000000000000000000000000000000000000000000000000000001;
    let pool = ContractId::from(address);

    mint_to(Identity::ContractId(pool), SubId::zero(), amount);
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mint-to-address-or-contract"><a class="header" href="#mint-to-address-or-contract">Mint to Address or Contract</a></h1>
<p>We can <a href="documentation/operations/asset/mint/./mint.html"><code>mint</code></a> and <a href="documentation/operations/asset/mint/../transfer/index.html"><code>transfers</code></a> to an <a href="documentation/operations/asset/mint/../../namespace/address.html"><code>Address</code></a> or a <a href="documentation/operations/asset/mint/../../namespace/contract-id.html"><code>Contract</code></a>.</p>
<p>To use the function we must import it.</p>
<pre><code class="language-sway">use std::asset::mint_to;
</code></pre>
<p>To mint some amount of an asset we specify the <code>amount</code> that we would like to mint and the <code>Identity</code> to send it to.</p>
<pre><code class="language-sway">    let amount = 10;
    let address = 0x0000000000000000000000000000000000000000000000000000000000000001;
    let user = Identity::Address(Address::from(address));
    let pool = Identity::ContractId(ContractId::from(address));

    mint_to(user, SubId::zero(), amount);
    mint_to(pool, SubId::zero(), amount);
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="burning"><a class="header" href="#burning">Burning</a></h1>
<p>Burning an asset means to destroy an asset that a contract has <a href="documentation/operations/asset/./mint/index.html"><code>minted</code></a>.</p>
<p>The <a href="https://github.com/FuelLabs/sway/tree/master/sway-lib-std">standard library</a> contains a <a href="https://github.com/FuelLabs/sway/blob/master/sway-lib-std/src/asset.sw"><code>module</code></a> that can be used to burn an asset.</p>
<p>There is one function used to burn:</p>
<!-- no toc -->
<ul>
<li><a href="documentation/operations/asset/burn.html#burn"><code>burn()</code></a></li>
</ul>
<p>To use the function we must import it.</p>
<pre><code class="language-sway">use std::asset::burn;
</code></pre>
<h2 id="burn"><a class="header" href="#burn">burn</a></h2>
<p>To burn some amount of an asset we specify the <code>amount</code> that we would like to burn and pass it into the <code>burn()</code> function.</p>
<pre><code class="language-sway">    let amount = 10;
    burn(SubId::zero(), amount);
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="transfer"><a class="header" href="#transfer">Transfer</a></h1>
<p>The <a href="https://github.com/FuelLabs/sway/tree/master/sway-lib-std">standard library</a> contains a <a href="https://github.com/FuelLabs/sway/blob/master/sway-lib-std/src/asset.sw"><code>module</code></a> that can be used to transfer (send) an asset from one owner to another.</p>
<p>There is one function that can be used to transfer an asset to any entity:</p>
<ul>
<li><a href="documentation/operations/asset/transfer/./address-or-contract.html"><code>transfer()</code></a></li>
</ul>
<p>Specific implementation details on transferring assets to addresses can be found <a href="documentation/operations/asset/transfer/./address.html">here</a>.</p>
<p>Specific implementation details on transferring assets to contracts can be found <a href="documentation/operations/asset/transfer/./contract.html">here</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="to-address"><a class="header" href="#to-address">To Address</a></h1>
<p>To use the function we must import it.</p>
<pre><code class="language-sway">use std::asset::transfer;
</code></pre>
<p>To transfer some amount of an asset we specify the <code>amount</code> that we would like to transfer, the <code>asset</code> and the <code>Address</code> to send it to.</p>
<pre><code class="language-sway">    let amount = 10;
    let address = 0x0000000000000000000000000000000000000000000000000000000000000001;
    let asset = AssetId::base();
    let user = Address::from(address);

    transfer(Identity::Address(user), asset, amount);
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="to-contract"><a class="header" href="#to-contract">To Contract</a></h1>
<p>To use the transfer function we must import it.</p>
<pre><code class="language-sway">use std::asset::transfer;
</code></pre>
<p>To transfer some amount of an asset we specify the <code>amount</code> that we would like to transfer, the <code>asset</code> and the <code>ContractId</code> to send it to.</p>
<pre><code class="language-sway">    let amount = 10;
    let address = 0x0000000000000000000000000000000000000000000000000000000000000001;
    let asset = AssetId::base();
    let pool = ContractId::from(address);

    transfer(Identity::ContractId(pool), asset, amount);
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="to-address-or-contract"><a class="header" href="#to-address-or-contract">To Address or Contract</a></h1>
<p>To use the function we must import it.</p>
<pre><code class="language-sway">use std::asset::transfer;
</code></pre>
<p>To transfer some amount of an asset we specify the <code>amount</code> that we would like to transfer, the <code>asset</code> and the <code>Identity</code> to send it to.</p>
<pre><code class="language-sway">    let amount = 10;
    let address = 0x0000000000000000000000000000000000000000000000000000000000000001;
    let asset = AssetId::base();
    let user = Identity::Address(Address::from(address));
    let pool = Identity::ContractId(ContractId::from(address));

    transfer(user, asset, amount);
    transfer(pool, asset, amount);
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="contract-balance"><a class="header" href="#contract-balance">Contract Balance</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hashing"><a class="header" href="#hashing">Hashing</a></h1>
<p>The <a href="https://github.com/FuelLabs/sway/blob/master/sway-lib-std/src/hash.sw"><code>hash module</code></a> contains the following functions:</p>
<!-- no toc -->
<ul>
<li><a href="documentation/operations/hashing/sha256.html"><code>sha256</code></a></li>
<li><a href="documentation/operations/hashing/keccak256.html"><code>keccak256</code></a></li>
</ul>
<p>They take one <a href="documentation/operations/hashing/../../language/generics/index.html"><code>generic</code></a> argument <code>T</code> and return a <a href="documentation/operations/hashing/../../language/built-ins/b256.html"><code>b256</code></a> (hash of <code>T</code>).</p>
<p>To hash multiple values the values must be wrapped into one type such as a <a href="documentation/operations/hashing/../../language/built-ins/tuples.html"><code>tuple</code></a>, <a href="documentation/operations/hashing/../../language/built-ins/arrays.html"><code>array</code></a>, <a href="documentation/operations/hashing/../../language/built-ins/structs.html"><code>struct</code></a> &amp; <a href="documentation/operations/hashing/../../language/built-ins/enums.html"><code>enum</code></a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sha256"><a class="header" href="#sha256">sha256</a></h1>
<p>To use the <code>sha256</code> function we must import it.</p>
<pre><code class="language-sway">
</code></pre>
<p>To hash multiple values we wrap them into a <a href="documentation/operations/hashing/../../language/built-ins/tuples.html"><code>tuple</code></a> however other <a href="documentation/operations/hashing/../../language/built-ins/index.html#compound-types"><code>compound types</code></a> may be used.</p>
<pre><code class="language-sway">fn sha256_hashing(age: u64, name: str, status: bool) -&gt; b256 {
    let mut hasher = Hasher::new();
    age.hash(hasher);
    hasher.write_str(name);
    status.hash(hasher);
    hasher.sha256()
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="keccak256"><a class="header" href="#keccak256">keccak256</a></h1>
<p>To use the <code>keccak256</code> function we must import it.</p>
<pre><code class="language-sway">
</code></pre>
<p>To hash multiple values we wrap them into a <a href="documentation/operations/hashing/../../language/built-ins/tuples.html"><code>tuple</code></a> however other <a href="documentation/operations/hashing/../../language/built-ins/index.html#compound-types"><code>compound types</code></a> may be used.</p>
<pre><code class="language-sway">fn keccak256_hashing(age: u64, name: str, status: bool) -&gt; b256 {
    let mut hasher = Hasher::new();
    age.hash(hasher);
    hasher.write_str(name);
    status.hash(hasher);
    hasher.keccak256()
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="signature-recovery"><a class="header" href="#signature-recovery">Signature Recovery</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="fuel-address"><a class="header" href="#fuel-address">Fuel Address</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ethereum-address"><a class="header" href="#ethereum-address">Ethereum Address</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="counter"><a class="header" href="#counter">Counter</a></h1>
<p>The following example implements a counter which is able to:</p>
<ul>
<li>Increment the count by 1</li>
<li>Decrement the count by 1</li>
<li>Retrieve the value of the counter</li>
</ul>
<h2 id="abi"><a class="header" href="#abi">ABI</a></h2>
<p>To create a counter we must define an <a href="documentation/examples/../language/program-types/contract.html"><code>ABI</code></a> which exposes methods that manipulate the count and retrieve its value. Since we are handling <a href="documentation/examples/../operations/storage/index.html"><code>storage</code></a> we must provide <a href="documentation/examples/../language/annotations/attributes/storage.html"><code>storage annotations</code></a> on the functions.</p>
<pre><code class="language-sway">abi Counter {
    #[storage(read, write)]
    fn increment();

    #[storage(read, write)]
    fn decrement();

    #[storage(read)]
    fn count() -&gt; u64;
}
</code></pre>
<h2 id="implementation"><a class="header" href="#implementation">Implementation</a></h2>
<p>We initialize a count in <a href="documentation/examples/../operations/storage/index.html"><code>storage</code></a> with the value of zero and implement methods to increment &amp; decrement the count by one and return the value.</p>
<pre><code class="language-sway">storage {
    counter: u64 = 0,
}

impl Counter for Contract {
    #[storage(read, write)]
    fn increment() {
        storage.counter.write(storage.counter.read() + 1);
    }

    #[storage(read, write)]
    fn decrement() {
        storage.counter.write(storage.counter.read() - 1);
    }

    #[storage(read)]
    fn count() -&gt; u64 {
        storage.counter.read()
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="fizzbuzz"><a class="header" href="#fizzbuzz">Fizzbuzz</a></h1>
<p>The following example implements the fizzbuzz game.</p>
<p>The rules are:</p>
<ul>
<li>A number divisible by <code>3</code> returns <code>Fizz</code></li>
<li>A number divisible by <code>5</code> returns <code>Buzz</code></li>
<li>A number which is divisible by <code>3</code> &amp; <code>5</code> returns <code>Fizzbuzz</code></li>
<li>Any other number entered is returned back to the user</li>
</ul>
<h2 id="state"><a class="header" href="#state">State</a></h2>
<p>Let's define an <a href="documentation/examples/../language/built-ins/enums.html"><code>enum</code></a> which contains the state of the game.</p>
<pre><code class="language-sway">enum State {
    Fizz: (),
    Buzz: (),
    FizzBuzz: (),
    Other: u64,
}
</code></pre>
<h2 id="implementation-1"><a class="header" href="#implementation-1">Implementation</a></h2>
<p>We can write a <a href="documentation/examples/../language/functions/index.html"><code>function</code></a> which takes an <code>input</code> and checks its divisibility. Depending on the result a different <code>State</code> will be returned.</p>
<pre><code class="language-sway">fn fizzbuzz(input: u64) -&gt; State {
    if input % 15 == 0 {
        State::FizzBuzz
    } else if input % 3 == 0 {
        State::Fizz
    } else if input % 5 == 0 {
        State::Buzz
    } else {
        State::Other(input)
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="contract-ownership"><a class="header" href="#contract-ownership">Contract Ownership</a></h1>
<p>The following example implements access control to restrict functionality to a privileged user.</p>
<h2 id="abi-1"><a class="header" href="#abi-1">ABI</a></h2>
<p>The <a href="documentation/examples/../language/program-types/contract.html"><code>interface</code></a> contains a function to set the owner and a function that only the owner can use.</p>
<pre><code class="language-sway">abi Ownership {
    #[storage(read, write)]
    fn set_owner(owner: Option&lt;Identity&gt;);

    #[storage(read)]
    fn action();
}
</code></pre>
<h2 id="identity-1"><a class="header" href="#identity-1">Identity</a></h2>
<p>We must keep track of the owner in storage and compare them against the caller via <a href="documentation/examples/../operations/call-data/msg-sender.html"><code>msg_sender()</code></a>.</p>
<p>Initially there is no owner so we'll set them to <code>None</code>.</p>
<pre><code class="language-sway">storage {
    owner: Option&lt;Identity&gt; = None,
}

</code></pre>
<h2 id="implementation-2"><a class="header" href="#implementation-2">Implementation</a></h2>
<p>To set the owner one of two conditions must be met:</p>
<ul>
<li>There is no owner</li>
<li>The current owner is calling the function</li>
</ul>
<p>To call our <code>action()</code> function the caller must be the owner of the contract.</p>
<pre><code class="language-sway">impl Ownership for Contract {
    #[storage(read, write)]
    fn set_owner(owner: Option&lt;Identity&gt;) {
        assert(storage.owner.read().is_none() || storage.owner.read().unwrap() == msg_sender().unwrap());
        storage.owner.write(owner);
    }

    #[storage(read)]
    fn action() {
        assert(storage.owner.read().unwrap() == msg_sender().unwrap());
        // code
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="wallet"><a class="header" href="#wallet">Wallet</a></h1>
<p>The following example implements a wallet that utilizes the base asset.</p>
<h2 id="abi-2"><a class="header" href="#abi-2">ABI</a></h2>
<p>The <a href="documentation/examples/../language/program-types/contract.html"><code>interface</code></a> contains a function which tracks the amount of the base asset received and a function to transfer the funds.</p>
<pre><code class="language-sway">abi Wallet {
    #[storage(read, write)]
    fn receive();

    #[storage(read, write)]
    fn send(amount: u64, recipient: Identity);
}
</code></pre>
<h2 id="implementation-3"><a class="header" href="#implementation-3">Implementation</a></h2>
<p>When receiving funds we assert that the wallet accepts the base asset and we track the amount sent. When transferring funds out of the wallet we assert that only the owner can perform the transfer.</p>
<pre><code class="language-sway">use std::{
    call_frames::msg_asset_id,
    context::msg_amount,
    asset::transfer,
};

storage {
    balance: u64 = 0,
}

const OWNER = Address::from(0x8900c5bec4ca97d4febf9ceb4754a60d782abbf3cd815836c1872116f203f861);

impl Wallet for Contract {
    #[storage(read, write)]
    fn receive() {
        assert(msg_asset_id() == AssetId::base());
        storage.balance.write(storage.balance.read() + msg_amount());
    }

    #[storage(read, write)]
    fn send(amount: u64, recipient: Identity) {
        assert(msg_sender().unwrap() == Identity::Address(OWNER));
        storage.balance.write(storage.balance.read() - amount);
        transfer(recipient, AssetId::base(), amount);
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="liquidity-pool"><a class="header" href="#liquidity-pool">Liquidity Pool</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="standard-library-prelude"><a class="header" href="#standard-library-prelude">Standard Library Prelude</a></h1>
<p>The <a href="https://github.com/FuelLabs/sway/blob/master/sway-lib-std/src/prelude.sw">prelude</a> is a list of commonly used features from the <a href="https://github.com/FuelLabs/sway/tree/master/sway-lib-std">standard library</a> which is automatically imported into every Sway program.</p>
<p>The prelude contains the following:</p>
<ul>
<li><a href="https://github.com/FuelLabs/sway/blob/master/sway-lib-std/src/address.sw"><code>Address</code></a>: A struct containing a <code>b256</code> value which represents the wallet address</li>
<li><a href="https://github.com/FuelLabs/sway/blob/master/sway-lib-std/src/contract_id.sw"><code>ContractId</code></a> A struct containing a <code>b256</code> value which represents the ID of a contract</li>
<li><a href="https://github.com/FuelLabs/sway/blob/master/sway-lib-std/src/identity.sw"><code>Identity</code></a>: An enum containing <code>Address</code> &amp; <code>ContractID</code> structs</li>
<li><a href="https://github.com/FuelLabs/sway/blob/master/sway-lib-std/src/vec.sw"><code>Vec</code></a>: A growable, heap-allocated vector</li>
<li><a href="https://github.com/FuelLabs/sway/blob/master/sway-lib-std/src/storage.sw"><code>StorageMap</code></a>: A key-value mapping in contract storage</li>
<li><a href="https://github.com/FuelLabs/sway/blob/master/sway-lib-std/src/option.sw"><code>Option</code></a>: An enum containing either some generic value <code>&lt;T&gt;</code> or an absence of that value, we also expose the variants directly:
<ul>
<li><code>Some</code></li>
<li><code>None</code></li>
</ul>
</li>
<li><a href="https://github.com/FuelLabs/sway/blob/master/sway-lib-std/src/result.sw"><code>Result</code></a>: An enum used to represent either a success or failure of an operation, we also expose the variants directly:
<ul>
<li><code>Ok</code></li>
<li><code>Err</code></li>
</ul>
</li>
<li><a href="https://github.com/FuelLabs/sway/blob/master/sway-lib-std/src/assert.sw"><code>assert</code></a>: A module containing
<ul>
<li><code>assert</code>: A function that reverts the VM if the condition provided to it is false</li>
<li><code>assert_eq</code>: A function that reverts the VM and logs its two inputs v1 and v2 if the condition v1 == v2 is false</li>
<li><code>assert_ne</code>: A function that reverts the VM and logs its two inputs v1 and v2 if the condition v1 != v2 is false</li>
</ul>
</li>
<li><a href="https://github.com/FuelLabs/sway/blob/master/sway-lib-std/src/revert.sw"><code>revert</code></a>: A module containing
<ul>
<li><code>require</code>: A function that reverts and logs a given value if the condition is <code>false</code></li>
<li><code>revert</code>: A function that reverts</li>
</ul>
</li>
<li><a href="https://github.com/FuelLabs/sway/blob/master/sway-lib-std/src/logging.sw"><code>log</code></a>: A function that logs arbitrary stack types</li>
<li><a href="https://github.com/FuelLabs/sway/blob/master/sway-lib-std/src/auth.sw"><code>msg_sender</code></a>: A function that gets the Identity from which a call was made</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="language-comparison"><a class="header" href="#language-comparison">Language Comparison</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rust"><a class="header" href="#rust">Rust</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="solidity"><a class="header" href="#solidity">Solidity</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="software-development-kits"><a class="header" href="#software-development-kits">Software Development Kits</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rust-sdk"><a class="header" href="#rust-sdk">Rust SDK</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="typescript-sdk"><a class="header" href="#typescript-sdk">TypeScript SDK</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="advanced-concepts"><a class="header" href="#advanced-concepts">Advanced Concepts</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="struct-memory-layout"><a class="header" href="#struct-memory-layout">Struct Memory Layout</a></h1>
<p>Structs have zero memory overhead, meaning that each field is laid out sequentially in memory. No metadata regarding the struct's name or other properties is preserved at runtime.</p>
<p>In other words, structs are compile-time constructs similar to Rust, but different in other languages with runtimes like Java.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="enum-memory-layout"><a class="header" href="#enum-memory-layout">Enum Memory Layout</a></h1>
<p>Enums have some memory overhead. To know which variant is being represented, Sway stores a one-word (8-byte) tag for the enum variant.</p>
<p>The space reserved after the tag is equivalent to the size of the <em>largest</em> enum variant. To calculate the size of an enum in memory, add 8 bytes to the size of the largest variant.</p>
<h2 id="examples"><a class="header" href="#examples">Examples</a></h2>
<p>The following examples consist of <a href="documentation/misc/advanced-concepts/../../language/built-ins/enums.html">enums</a> with two variants.</p>
<p>The largest variant for <a href="documentation/misc/advanced-concepts/enums.html#example-one"><code>Example One</code></a> is the <a href="documentation/misc/advanced-concepts/../../language/built-ins/numeric.html"><code>u64</code></a> and <a href="documentation/misc/advanced-concepts/../../language/built-ins/b256.html"><code>b256</code></a> for <a href="documentation/misc/advanced-concepts/enums.html#example-two"><code>Example Two</code></a>.</p>
<h3 id="example-one"><a class="header" href="#example-one">Example One</a></h3>
<p>The size of enum <code>T</code> is <code>16 bytes</code>, <code>8 bytes</code> for the tag and <code>8 bytes</code> for the <a href="documentation/misc/advanced-concepts/../../language/built-ins/numeric.html"><code>u64</code></a>.</p>
<pre><code class="language-sway">pub enum T {
    a: u64,
    b: (),
}
</code></pre>
<p>Instantiating the <a href="documentation/misc/advanced-concepts/../../language/built-ins/numeric.html"><code>u64</code></a> type will take up <code>16 bytes</code>.</p>
<pre><code class="language-sway">    let a = T::a(42);
</code></pre>
<p>Instantiating the <code>unit</code> type will take up <code>16 bytes</code>.</p>
<pre><code class="language-sway">    let b = T::b;
</code></pre>
<h3 id="example-two"><a class="header" href="#example-two">Example Two</a></h3>
<p>The size of enum <code>K</code> is <code>40 bytes</code>, <code>8 bytes</code> for the tag and <code>32 bytes</code> for the <a href="documentation/misc/advanced-concepts/../../language/built-ins/b256.html"><code>b256</code></a>.</p>
<pre><code class="language-sway">pub enum K {
    a: b256,
    b: u64,
}
</code></pre>
<p>Instantiating the <a href="documentation/misc/advanced-concepts/../../language/built-ins/b256.html"><code>b256</code></a> type will take up <code>40 bytes</code>.</p>
<pre><code class="language-sway">    let a = K::a(0x0000000000000000000000000000000000000000000000000000000000000000);
</code></pre>
<p>Instantiating the <code>u64</code> type will take up <code>40 bytes</code>.</p>
<pre><code class="language-sway">    let b = K::b(42);
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="compiler-intrinsics"><a class="header" href="#compiler-intrinsics">Compiler Intrinsics</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="known-issues-and-workarounds"><a class="header" href="#known-issues-and-workarounds">Known Issues and Workarounds</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="general"><a class="header" href="#general">General</a></h1>
<blockquote>
<p>TODO: need help filling this in, might remove this page and move content into individual sections</p>
</blockquote>
<ul>
<li><a href="https://github.com/FuelLabs/sway/issues/870">Issue: #870</a>
<ul>
<li>All <code>impl</code> blocks need to be defined before any of the functions they define can be called. This includes sibling functions in the same <code>impl</code> declaration, i.e., functions in an <code>impl</code> can't call each other yet.</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="missing-features"><a class="header" href="#missing-features">Missing Features</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="importing"><a class="header" href="#importing">Importing</a></h1>
<p>In <a href="documentation/misc/workarounds/../../language/program-types/libraries/external.html">external libraries</a> we have looked at how a library can be imported into a project so that code can be reused.</p>
<p>When it comes to importing only external libraries can be imported through the <code>Forc.toml</code> file; any other type of program will result in an error.</p>
<p>This means that the following projects cannot be imported:</p>
<ul>
<li><a href="documentation/misc/workarounds/../../language/program-types/contract.html">contracts</a></li>
<li><a href="documentation/misc/workarounds/../../language/program-types/libraries/internal.html">internal libraries</a></li>
<li><a href="documentation/misc/workarounds/../../language/program-types/script.html">scripts</a></li>
<li><a href="documentation/misc/workarounds/../../language/program-types/predicate.html">predicates</a></li>
</ul>
<p>While contracts cannot be imported, a workaround is to move the contract's <code>abi</code> declaration into an <a href="documentation/misc/workarounds/../../language/program-types/libraries/external.html">external library</a> and import that library anywhere the ABI is needed.</p>
<blockquote>
<p>TODO: move the next comment into a page where it makes sense to keep it</p>
</blockquote>
<p>Furthermore, using contract dependencies it is possible to import the contract ID automatically as a public constant.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="strings"><a class="header" href="#strings">Strings</a></h1>
<p>Sway strings are declared using double-quotes <code>"</code>. Single quotes <code>'</code> cannot be used. Attempting to define a string with single-quotes will result in an error.</p>
<pre><code class="language-sway">    // Will error if uncommented
    // let fuel = 'fuel';
</code></pre>
<p>Strings are UTF-8 encoded therefore they cannot be indexed.</p>
<pre><code class="language-sway">    let fuel = "fuel";
    // Will error if uncommented
    // let f = fuel[0];
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="predicates-1"><a class="header" href="#predicates-1">Predicates</a></h1>
<p>A <a href="documentation/misc/workarounds/../../language/program-types/predicate.html">predicate</a> does not have any side effects because it is pure and thus it cannot create <a href="https://github.com/FuelLabs/fuel-specs/blob/master/src/abi/receipts.md">receipts</a>.</p>
<p>Since there are no receipts they cannot use logging nor create a stack backtrace for debugging. This means that there is no way to debug them aside from using a single-stepping <a href="documentation/misc/workarounds/../../../../../../forc-plugins/forc-debug/README.html">debugger</a>.</p>
<p>As a workaround, the predicate can be written, tested, and debugged first as a <a href="documentation/misc/workarounds/../../language/program-types/script.html"><code>script</code></a>, and then changed back into a <code>predicate</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pattern-matching-1"><a class="header" href="#pattern-matching-1">Pattern Matching</a></h1>
<h2 id="nested-match-expressions"><a class="header" href="#nested-match-expressions">Nested Match Expressions</a></h2>
<p>In <a href="documentation/misc/workarounds/../../language/control-flow/match/complex/nested-expression.html">nested match expressions</a> we nest a <code>match</code> expression by embedding it inside the <code>{}</code> brackets on the right side of the arrow <code>=&gt;</code>.</p>
<p>Match expressions cannot be used as a pattern, the left side of the arrow <code>=&gt;</code>.</p>
<h2 id="constants-2"><a class="header" href="#constants-2">Constants</a></h2>
<p>When matching on <a href="documentation/misc/workarounds/../../language/control-flow/match/complex/constant.html">constants</a> we specify that a constant must be used in order to match on a variable. Dynamic values, such as an argument to a function, cannot be matched upon because it will be treated as a <a href="documentation/misc/workarounds/../../language/control-flow/match/single-line.html"><code>catch_all</code></a> case and thus any subsequent patterns will not be checked.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="storage-2"><a class="header" href="#storage-2">Storage</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="manifest-reference"><a class="header" href="#manifest-reference">Manifest Reference</a></h1>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
