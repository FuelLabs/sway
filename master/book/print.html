<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>The Sway Programming Language</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Sway Programming Language</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/FuelLabs/sway" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="the-sway-programming-language"><a class="header" href="#the-sway-programming-language">The Sway Programming Language</a></h1>
<p>Welcome to the Sway programming language book ðŸŒ´.</p>
<p><strong>Q: Hi! What is Sway?</strong></p>
<p>Sway is a domain-specific programming language for implementing smart contracts on blockchain platforms, most notably for the <a href="https://docs.fuel.network/docs/specs/fuel-vm/">Fuel Virtual Machine (Fuel VM)</a>.</p>
<p>Heavily inspired by <a href="https://doc.rust-lang.org/book/">Rust</a>'s approach to systems programming, Sway aims to bring modern programming language features and tooling to smart contract development whilst retaining performance, fine grained control and making extensive use of static analysis to prevent common security issues.</p>
<p><strong>Q: What does "domain-specific" mean?</strong></p>
<p>Sway is specifically made to be used within a blockchain environment, which behaves very differently than traditional computers.
This domain specific design permits it to make the right decisions about trade-offs at every level of the stack, enabling you to write fast, secure and cost effective smart contracts with features suited to your specific needs.</p>
<p><strong>Q: Why not use Solidity?</strong></p>
<p>Solidity is a venerable pioneer but it suffers from being tied to a lot of the historical quirks of the EVM.
It lacks common features programmers have come to expect, has a relatively inexpressive type system, and it lacks a unified tooling ecosystem.</p>
<p>In Sway, we let you design smart contracts with a full modern box of tools.
You get a fully featured language with generics, algebraic types and trait based polymorphism.
You also get an integrated, unified and easy to use toolchain with code completion LSP server, formatter, documentation generation and everything you need to run and deploy your contracts so that nothing comes between you and implementing what you want.</p>
<p>Our expressive type system allows you to catch semantic mistakes, we provide good defaults and we do extensive static analysis checks (such as enforcing the <a href="./blockchain-development/calling_contracts.html#cei-pattern-violation-static-analysis">Checks, Effects, Interactions</a> pattern) so that you can make sure you write secure and correct code at compile time.</p>
<p><strong>Q: Why not use Rust?</strong></p>
<p>Whilst Rust is a great systems programming language (and Sway itself is written in Rust), it isn't suited for smart contract development.</p>
<p>Rust shines because it can use zero-cost abstractions and its sophisticated borrow-checker memory model to achieve impressive runtime performance for complex programs without a garbage collector.</p>
<p>On a blockchain, cost of execution and deployment is the scarce resource.
Memory usage is low and execution time is short.
This makes complex memory management in general much too expensive to be worthwhile and Rust's borrow checker a burden with no upside.</p>
<p>General purpose programming languages in general are ill suited to this environment because their design has to assume execution on a general-purpose computing environment.</p>
<p>Sway attempts to bring all the other advantages of Rust, including its modern type system, approach to safety and good defaults to smart contract developers by providing familiar syntax and features adapted to the specific needs of the blockchain environment.</p>
<p><strong>Q: I don't know Rust or Solidity. Can I still learn Sway?</strong></p>
<p>Yes! If you are familiar with the basics of programming, blockchain, and using a terminal you can build with Sway.</p>
<p><strong>Q: What can I build with Sway?</strong></p>
<p>You can build smart contracts and their components and libraries for them.
You can learn more about the different program types and how they fit together in the <a href="./sway-program-types/index.html">Program Types</a> section.</p>
<p><strong>Q: Do I need to install anything?</strong></p>
<p>If you want to develop with Sway in your local environment, you need to install <a href="https://docs.fuel.network/guides/installation/"><code>fuelup</code></a> and your editor of choice that supports LSP, such as <a href="https://code.visualstudio.com/">VSCode</a>.</p>
<p>If you don't want to install anything just yet, you can use the <a href="https://www.sway-playground.org/">Sway Playground</a> to edit, compile, and deploy Sway code.</p>
<p><strong>Q: Where can I find example Sway code?</strong></p>
<p>You can find example applications built with Sway in the <a href="https://github.com/FuelLabs/sway-applications">Sway Applications repository</a> on GitHub. You can also find projects building on Fuel in the <a href="https://app.fuel.network/ecosystem">Fuel ecosystem home</a>.</p>
<p><strong>Q: What is the standard library?</strong></p>
<p>The <a href="./introduction/standard_library.html">standard library</a>, also referred to as <code>std</code>, is a library that offers core functions and helpers for developing in Sway. The standard library has its own <a href="https://fuellabs.github.io/sway/master/std/">reference documentation</a> that has detailed information about each module in <code>std</code>.</p>
<p><strong>Q: What are Sway standards?</strong></p>
<p>Similar to ERC standards for Ethereum and Solidity, Sway has its own SRC standards that help enable cross compatibility across different smart contracts. For more information on using a Sway Standard, you can check out the <a href="https://github.com/FuelLabs/sway-standards">Sway-Standards Repository</a>.</p>
<p><strong>Q: How can I make a token?</strong></p>
<p>Sway has multiple native assets. To mint a new native asset, check out the <a href="./blockchain-development/native_assets.html">native assets</a> page.</p>
<p><strong>Q: How can I make an NFT?</strong></p>
<p>You can find an example of an NFT contract in Sway in the <a href="https://github.com/FuelLabs/sway-applications/tree/master/NFT">Sway Applications repo</a>.</p>
<p><strong>Q: How can I test Sway code?</strong></p>
<p>Sway provides <a href="./testing/unit-testing.html">unit testing</a>, so you can test your Sway code with Sway. You can also use the Fuel <a href="https://docs.fuel.network/docs/fuels-rs/testing/">Rust SDK</a> or <a href="https://docs.fuel.network/docs/fuels-ts/testing/">TypeScript SDK</a> to test your Sway programs.</p>
<p><strong>Q: How can I deploy a contract?</strong></p>
<p>You can use the <code>forc deploy</code> command to deploy a contract. For a detailed guide on how to deploy a contract, refer to the <a href="https://docs.fuel.network/docs/intro/quickstart-contract/">quickstart guide</a>.</p>
<p><strong>Q: Is there a way to convert Solidity code to Sway?</strong></p>
<p>Yes! You can use the Solidity to Sway transpiler built in to the <a href="https://www.sway-playground.org/">Sway Playground</a> to convert Solidity code into Sway code. Note that the transpiler is still experimental, and may not work in every case.</p>
<p><strong>Q: How can I get help with Sway?</strong></p>
<p>If you run into an issue or have a question, post it on the <a href="https://forum.fuel.network/">Fuel forum</a> so someone in the Fuel community can help.</p>
<p><strong>Q: Where should I get started?</strong></p>
<p><em>Ready to build?</em> You can find step-by-step guides for how to build an application with Sway in the <a href="https://docs.fuel.network/guides/">Fuel Developer Guides</a>.</p>
<p><em>Want to read?</em> Get started by reading the <a href="./introduction/index.html">Introduction</a> and <a href="./basics/index.html">Basics</a> sections of this book.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p>To get started with Forc and Sway smart contract development, install the Fuel toolchain and Fuel full node and set up your first project.</p>
<ul>
<li><a href="introduction/./getting_started.html">Getting Started</a></li>
<li><a href="introduction/./fuel_toolchain.html">The Fuel Toolchain</a></li>
<li><a href="introduction/./forc_project.html">A Forc Project</a></li>
<li><a href="introduction/./standard_library.html">Standard Library</a></li>
<li><a href="introduction/./sway_standards.html">Sway Language Standards</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="getting-started"><a class="header" href="#getting-started">Getting Started</a></h1>
<h2 id="installing-the-fuel-toolchain"><a class="header" href="#installing-the-fuel-toolchain">Installing the <code>Fuel</code> toolchain</a></h2>
<p>Please visit the Fuel <a href="https://docs.fuel.network/guides/installation">Installation Guide</a> to install the Fuel toolchain binaries and prerequisites.</p>
<h2 id="sway-quickstart"><a class="header" href="#sway-quickstart">Sway Quickstart</a></h2>
<p>Check out the <a href="https://docs.fuel.network/guides/quickstart/">Developer Quickstart Guide</a> for a step-by-step guide on building a fullstack dapp on Fuel. The guide will walk you through writing a smart contract, setting up a wallet, and building a frontend to interact with your contract.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-fuel-toolchain"><a class="header" href="#the-fuel-toolchain">The Fuel Toolchain</a></h1>
<p>The Fuel toolchain consists of several components.</p>
<h2 id="forc-forc"><a class="header" href="#forc-forc">Forc (<code>forc</code>)</a></h2>
<p>The "Fuel Orchestrator" <a href="https://github.com/FuelLabs/sway/tree/master/forc">Forc</a> is our equivalent of Rust's <a href="https://doc.rust-lang.org/cargo/">Cargo</a>. It is the primary entry point for creating, building, testing, and deploying Sway projects.</p>
<h2 id="sway-language-server-forc-lsp"><a class="header" href="#sway-language-server-forc-lsp">Sway Language Server (<code>forc-lsp</code>)</a></h2>
<p>The Sway Language Server <code>forc-lsp</code> is provided to expose features to IDEs. <a href="introduction/../lsp/installation.html">Installation instructions</a>.</p>
<h2 id="sway-formatter-forc-fmt"><a class="header" href="#sway-formatter-forc-fmt">Sway Formatter (<code>forc-fmt</code>)</a></h2>
<p>A canonical formatter is provided with <code>forc-fmt</code>. <a href="introduction/./getting_started.html">Installation instructions</a>. It can be run manually with</p>
<pre><code class="language-sh">forc fmt
</code></pre>
<p>The <a href="https://marketplace.visualstudio.com/items?itemName=FuelLabs.sway-vscode-plugin">Visual Studio Code plugin</a> will
automatically format Sway files with <code>forc-fmt</code> on save, though you might have to explicitly set the Sway plugin as the
default formatter, like this:</p>
<pre><code class="language-json">"[sway]": {
  "editor.defaultFormatter": "FuelLabs.sway-vscode-plugin"
}
</code></pre>
<h2 id="fuel-core-fuel-core"><a class="header" href="#fuel-core-fuel-core">Fuel Core (<code>fuel-core</code>)</a></h2>
<p>An implementation of the Fuel protocol, <a href="https://github.com/FuelLabs/fuel-core">Fuel Core</a>, is provided together with the <em>Sway toolchain</em> to form the <em>Fuel toolchain</em>. <a href="https://github.com/FuelLabs/fuels-rs">The Rust SDK</a> will automatically start and stop an instance of the node during tests, so there is no need to manually run a node unless using Forc directly without the SDK.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="a-forc-project"><a class="header" href="#a-forc-project">A Forc Project</a></h1>
<p>To initialize a new project with Forc, use <code>forc new</code>:</p>
<pre><code class="language-sh">forc new my-fuel-project
</code></pre>
<p>Here is the project that Forc has initialized:</p>
<!-- This section should show the tree for a new forc project -->
<!-- tree:example:start -->
<pre><code class="language-console">$ cd my-fuel-project
$ tree .
â”œâ”€â”€ Forc.toml
â””â”€â”€ src
 Â Â  â””â”€â”€ main.sw
</code></pre>
<!-- tree:example:end -->
<!-- This section should explain the `Forc.toml` file -->
<!-- forc_toml:example:start -->
<p><code>Forc.toml</code> is the <em>manifest file</em> (similar to <code>Cargo.toml</code> for Cargo or <code>package.json</code> for Node), and defines project metadata such as the project name and dependencies.</p>
<!-- forc_toml:example:end -->
<p>For additional information on dependency management, see: <a href="introduction/../forc/dependencies.html">here</a>.</p>
<pre><code class="language-toml">[project]
authors = ["User"]
entry = "main.sw"
license = "Apache-2.0"
name = "my-fuel-project"

[dependencies]
</code></pre>
<p>Here are the contents of the only Sway file in the project, and the main entry point, <code>src/main.sw</code>:</p>
<pre><code class="language-sway">contract;

abi MyContract {
    fn test_function() -&gt; bool;
}

impl MyContract for Contract {
    fn test_function() -&gt; bool {
        true
    }
}
</code></pre>
<p>The project is a <em>contract</em>, one of four different project types. For additional information on different project types, see <a href="introduction/../sway-program-types/index.html">here</a>.</p>
<p>We now compile our project with <code>forc build</code>, passing the flag <code>--asm final</code> to view the generated assembly:</p>
<pre><code class="language-console">$ forc build --asm final
...
.program:
ji   i4
noop
DATA_SECTION_OFFSET[0..32]
DATA_SECTION_OFFSET[32..64]
lw   $ds $is 1
add  $$ds $$ds $is
lw   $r0 $fp i73              ; load input function selector
lw   $r1 data_0               ; load fn selector for comparison
eq   $r2 $r0 $r1              ; function selector comparison
jnzi $r2 i12                  ; jump to selected function
movi $$tmp i123               ; special code for mismatched selector
rvrt $$tmp                    ; revert if no selectors matched
ret  $one
.data:
data_0 .word 559005003

  Compiled contract "my-fuel-project".
  Bytecode size is 60 bytes.
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="standard-library"><a class="header" href="#standard-library">Standard Library</a></h1>
<!-- This section should explain what the std-lib is -->
<!-- std_lib:example:start -->
<p>Similar to Rust, Sway comes with its own standard library.</p>
<p>The Sway Standard Library is the foundation of portable Sway software, a set of minimal shared abstractions for the broader Sway ecosystem. It offers core types, like <code>Result&lt;T, E&gt;</code> and <code>Option&lt;T&gt;</code>, library-defined operations on language primitives, native asset management, blockchain contextual operations, access control, storage management, and support for types from other VMs, among many other things.</p>
<!-- std_lib:example:end -->
<p>The entire Sway standard library is a Forc project called <code>std</code>, and is available directly <a href="https://github.com/FuelLabs/sway/tree/master/sway-lib-std">here</a>. Navigate to the appropriate tagged release if the latest <code>master</code> is not compatible. You can find the latest <code>std</code> documentation <a href="https://fuellabs.github.io/sway/master/std/">here</a>.</p>
<h2 id="using-the-standard-library"><a class="header" href="#using-the-standard-library">Using the Standard Library</a></h2>
<p>The standard library is made implicitly available to all Forc projects created using <a href="introduction/../forc/commands/forc_new.html"><code>forc new</code></a>. In other words, it is not required to manually specify <code>std</code> as an explicit dependency. Forc will automatically use the version of <code>std</code> that matches its version.</p>
<p>Importing items from the standard library can be done using the <code>use</code> keyword, just as importing items from any Sway project. For example:</p>
<pre><code class="language-sway">use std::storage::storage_vec::*;
</code></pre>
<p>This imports the <code>StorageVec</code> type into the current namespace.</p>
<h2 id="standard-library-prelude"><a class="header" href="#standard-library-prelude">Standard Library Prelude</a></h2>
<!-- This section should explain what the std-lib prelude is -->
<!-- prelude:example:start -->
<p>Sway comes with a variety of things in its standard library. However, if you had to manually import every single thing that you used, it would be very verbose. But importing a lot of things that a program never uses isn't good either. A balance needs to be struck.</p>
<p>The prelude is the list of things that Sway automatically imports into every Sway program. It's kept as small as possible, and is focused on things which are used in almost every single Sway program.</p>
<p>The current version of the prelude lives in <a href="https://github.com/FuelLabs/sway/blob/master/sway-lib-std/src/prelude.sw"><code>std::prelude</code></a>, and re-exports the following:</p>
<ul>
<li><a href="https://github.com/FuelLabs/sway/blob/master/sway-lib-std/src/address.sw"><code>std::address::Address</code></a>, a wrapper around the <code>b256</code> type representing a wallet address.</li>
<li><a href="https://github.com/FuelLabs/sway/blob/master/sway-lib-std/src/contract_id.sw"><code>std::contract_id::ContractId</code></a>, a wrapper around the <code>b256</code> type representing the ID of a contract.</li>
<li><a href="https://github.com/FuelLabs/sway/blob/master/sway-lib-std/src/identity.sw"><code>std::identity::Identity</code></a>, an enum with two possible variants: <code>Address: Address</code> and <code>ContractId: ContractId</code>.</li>
<li><a href="https://github.com/FuelLabs/sway/blob/master/sway-lib-std/src/vec.sw"><code>std::vec::Vec</code></a>, a growable, heap-allocated vector.</li>
<li><a href="https://github.com/FuelLabs/sway/blob/master/sway-lib-std/src/storage/storage_key.sw"><code>std::storage::storage_key::*</code></a>, contains the API for accessing a <code>std::storage::StorageKey</code> which describes a location in storage.</li>
<li><a href="https://github.com/FuelLabs/sway/blob/master/sway-lib-std/src/storage/storage_map.sw"><code>std::storage::storage_map::*</code></a>, a key-value mapping in contract storage.</li>
<li><a href="https://github.com/FuelLabs/sway/blob/master/sway-lib-std/src/option.sw"><code>std::option::Option</code></a>, an enum which expresses the presence or absence of a value.</li>
<li><a href="https://github.com/FuelLabs/sway/blob/master/sway-lib-std/src/result.sw"><code>std::result::Result</code></a>, an enum for functions that may succeed or fail.</li>
<li><a href="https://github.com/FuelLabs/sway/blob/master/sway-lib-std/src/assert.sw"><code>std::assert::assert</code></a>, a function that reverts the VM if the condition provided to it is <code>false</code>.</li>
<li><a href="https://github.com/FuelLabs/sway/blob/master/sway-lib-std/src/assert.sw"><code>std::assert::assert_eq</code></a>, a function that reverts the VM and logs its two inputs <code>v1</code> and <code>v2</code> if the condition <code>v1</code> == <code>v2</code> is <code>false</code>.</li>
<li><a href="https://github.com/FuelLabs/sway/blob/master/sway-lib-std/src/assert.sw"><code>std::assert::assert_ne</code></a>, a function that reverts the VM and logs its two inputs <code>v1</code> and <code>v2</code> if the condition <code>v1</code> != <code>v2</code> is <code>false</code>.</li>
<li><a href="https://github.com/FuelLabs/sway/blob/master/sway-lib-std/src/revert.sw"><code>std::revert::require</code></a>, a function that reverts the VM and logs a given value if the condition provided to it is <code>false</code>.</li>
<li><a href="https://github.com/FuelLabs/sway/blob/master/sway-lib-std/src/revert.sw"><code>std::revert::revert</code></a>, a function that reverts the VM.</li>
<li><a href="https://github.com/FuelLabs/sway/blob/master/sway-lib-std/src/logging.sw"><code>std::logging::log</code></a>, a function that logs arbitrary stack types.</li>
<li><a href="https://github.com/FuelLabs/sway/blob/master/sway-lib-std/src/auth.sw"><code>std::auth::msg_sender</code></a>, a function that gets the <code>Identity</code> from which a call was made.</li>
<li><a href="https://github.com/FuelLabs/sway/blob/master/sway-lib-std/src/primitives.sw"><code>std::primitives::*</code></a>, methods on primitive types.</li>
<li><a href="https://github.com/FuelLabs/sway/blob/master/sway-lib-std/src/primitive_conversions.sw"><code>std::primitive_conversions::*</code></a>, methods for converting between primitive types.</li>
<li><a href="https://github.com/FuelLabs/sway/blob/master/sway-lib-std/src/raw_ptr.sw"><code>std::raw_ptr::*</code></a>, functions for working with raw pointers.</li>
<li><a href="https://github.com/FuelLabs/sway/blob/master/sway-lib-std/src/raw_slice.sw"><code>std::raw_slice::*</code></a>, functions for working with raw slices.</li>
<li><a href="https://github.com/FuelLabs/sway/blob/master/sway-lib-std/src/ops.sw"><code>std::ops::*</code></a>, mathematical operations such as addition, subtraction, multiplication, and division.</li>
<li><a href="https://github.com/FuelLabs/sway/blob/master/sway-lib-std/src/str.sw"><code>std::str::*</code></a>, methods for working with strings.</li>
<li><a href="https://github.com/FuelLabs/sway/blob/master/sway-lib-std/src/codec.sw"><code>std::codec::*</code></a>, automatic serialization and deserialization of types.</li>
</ul>
<!-- prelude:example:end -->
<div style="break-before: page; page-break-before: always;"></div><h1 id="sway-standards"><a class="header" href="#sway-standards">Sway Standards</a></h1>
<p>Just like many other smart contract languages, usage standards have been developed to enable cross compatibility between smart contracts.</p>
<p>For more information on using a Sway Standard, please refer to the <a href="https://github.com/FuelLabs/sway-standards">Sway-Standards Repository</a>.</p>
<h2 id="standards"><a class="header" href="#standards">Standards</a></h2>
<h3 id="native-asset-standards"><a class="header" href="#native-asset-standards">Native Asset Standards</a></h3>
<ul>
<li><a href="https://github.com/FuelLabs/sway-standards/blob/master/docs/src/src-20-native-asset.md">SRC-20; Native Asset Standard</a> defines the implementation of a standard API for <a href="introduction/../blockchain-development/native_assets.html">Native Assets</a> using the Sway Language.</li>
<li><a href="https://github.com/FuelLabs/sway-standards/blob/master/docs/src/src-3-minting-and-burning.md">SRC-3; Mint and Burn</a> is used to enable mint and burn functionality for Native Assets.</li>
<li><a href="https://github.com/FuelLabs/sway-standards/blob/master/docs/src/src-7-asset-metadata.md">SRC-7; Arbitrary Asset Metadata Standard</a> is used to store metadata for <a href="introduction/../blockchain-development/native_assets.html">Native Assets</a>, usually as NFTs.</li>
<li><a href="https://github.com/FuelLabs/sway-standards/blob/master/docs/src/src-9-metadata-keys.md">SRC-9; Metadata Keys Standard</a> is used to store standardized metadata keys for <a href="introduction/../blockchain-development/native_assets.html">Native Assets</a> in combination with the SRC-7 standard.</li>
<li><a href="https://github.com/FuelLabs/sway-standards/blob/master/docs/src/src-6-vault.md">SRC-6; Vault Standard</a> defines the implementation of a standard API for asset vaults developed in Sway.</li>
</ul>
<h3 id="predicate-standards"><a class="header" href="#predicate-standards">Predicate Standards</a></h3>
<ul>
<li><a href="https://github.com/FuelLabs/sway-standards/blob/master/docs/src/src-13-soulbound-address.md">SRC-13; Soulbound Address Standard</a> defines a specific <code>Address</code> as a Soulbound Address for Soulbound Assets to become non-transferable.</li>
</ul>
<h3 id="access-control-standards"><a class="header" href="#access-control-standards">Access Control Standards</a></h3>
<ul>
<li><a href="https://github.com/FuelLabs/sway-standards/blob/master/docs/src/src-5-ownership.md">SRC-5; Ownership Standard</a> is used to restrict function calls to admin users in contracts.</li>
</ul>
<h3 id="contract-standards"><a class="header" href="#contract-standards">Contract Standards</a></h3>
<ul>
<li><a href="https://github.com/FuelLabs/sway-standards/blob/master/docs/src/src-12-contract-factory.md">SRC-12; Contract Factory</a> defines the implementation of a standard API for contract factories.</li>
</ul>
<h3 id="bridge-standards"><a class="header" href="#bridge-standards">Bridge Standards</a></h3>
<ul>
<li><a href="https://github.com/FuelLabs/sway-standards/blob/master/docs/src/src-8-bridged-asset.md">SRC-8; Bridged Asset</a> defines the metadata required for an asset bridged to the Fuel Network.</li>
<li><a href="https://github.com/FuelLabs/sway-standards/blob/master/docs/src/src-10-native-bridge.md">SRC-10; Native Bridge Standard</a> defines the standard API for the Native Bridge between the Fuel Chain and the canonical base chain.</li>
</ul>
<h3 id="documentation-standards"><a class="header" href="#documentation-standards">Documentation Standards</a></h3>
<ul>
<li><a href="https://github.com/FuelLabs/sway-standards/blob/master/docs/src/src-2-inline-documentation.md">SRC-2; Inline Documentation</a> defines how to document your Sway files.</li>
</ul>
<h2 id="standards-support"><a class="header" href="#standards-support">Standards Support</a></h2>
<p>Libraries have also been developed to support Sway Standards. These can be in <a href="introduction/../reference/sway_libs.html">Sway-Libs</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="example"><a class="header" href="#example">Example</a></h1>
<p>Some basic example contracts to see how Sway and Forc work.</p>
<ul>
<li><a href="examples/./counter.html">Counter</a></li>
<li><a href="examples/./fizzbuzz.html"><code>FizzBuzz</code></a></li>
<li><a href="examples/./wallet_smart_contract.html">Wallet Smart Contract</a></li>
<li><a href="examples/./wallet_smart_contract.html">Liquidity Pool</a></li>
</ul>
<p>Additional examples can be found in the <a href="https://github.com/FuelLabs/sway-applications/tree/master">Sway Applications</a> repository.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="counter"><a class="header" href="#counter">Counter</a></h1>
<p>The following is a simple example of a contract which implements a counter. Both the <code>initialize_counter()</code> and <code>increment_counter()</code> ABI methods return the currently set value.</p>
<pre><code class="language-bash">forc template --template-name counter my_counter_project
</code></pre>
<pre><code class="language-sway">contract;

abi TestContract {
    #[storage(write)]
    fn initialize_counter(value: u64) -&gt; u64;

    #[storage(read, write)]
    fn increment_counter(amount: u64) -&gt; u64;
}

storage {
    counter: u64 = 0,
}

impl TestContract for Contract {
    #[storage(write)]
    fn initialize_counter(value: u64) -&gt; u64 {
        storage.counter.write(value);
        value
    }

    #[storage(read, write)]
    fn increment_counter(amount: u64) -&gt; u64 {
        let incremented = storage.counter.read() + amount;
        storage.counter.write(incremented);
        incremented
    }
}
</code></pre>
<h2 id="build-and-deploy"><a class="header" href="#build-and-deploy">Build and deploy</a></h2>
<p>The following commands can be used to build and deploy the contract. For a detailed tutorial, refer to <a href="https://docs.fuel.network/guides/contract-quickstart/#building-the-contract">Building and Deploying</a>.</p>
<pre><code class="language-bash"># Build the contract
forc build

# Deploy the contract
forc deploy --testnet
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="fizzbuzz"><a class="header" href="#fizzbuzz"><code>FizzBuzz</code></a></h1>
<p>This example is not the traditional <a href="https://en.wikipedia.org/wiki/Fizz_buzz#Programming"><code>FizzBuzz</code></a>; instead it is the smart contract version! A script can call the <code>fizzbuzz</code> ABI method of this contract with some <code>u64</code> value and receive back the result as an <code>enum</code>.</p>
<p>The format for custom structs and enums such as <code>FizzBuzzResult</code> will be automatically included in the ABI JSON so that off-chain code can handle the encoded form of the returned data.</p>
<pre><code class="language-sway">contract;

enum FizzBuzzResult {
    Fizz: (),
    Buzz: (),
    FizzBuzz: (),
    Other: u64,
}

abi FizzBuzz {
    fn fizzbuzz(input: u64) -&gt; FizzBuzzResult;
}

impl FizzBuzz for Contract {
    fn fizzbuzz(input: u64) -&gt; FizzBuzzResult {
        if input % 15 == 0 {
            FizzBuzzResult::FizzBuzz
        } else if input % 3 == 0 {
            FizzBuzzResult::Fizz
        } else if input % 5 == 0 {
            FizzBuzzResult::Buzz
        } else {
            FizzBuzzResult::Other(input)
        }
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="wallet-smart-contract"><a class="header" href="#wallet-smart-contract">Wallet Smart Contract</a></h1>
<p>The ABI declaration is a separate project from your ABI implementation. The project structure for the code should be organized as follows with the <code>wallet_abi</code> treated as an external library:</p>
<pre><code class="language-sh">.
â”œâ”€â”€ wallet_abi
â”‚   â”œâ”€â”€ Forc.toml
â”‚   â””â”€â”€ src
â”‚       â””â”€â”€ main.sw
â””â”€â”€ wallet_smart_contract
    â”œâ”€â”€ Forc.toml
    â””â”€â”€ src
        â””â”€â”€ main.sw
</code></pre>
<p>It's also important to specify the source of the dependency within the project's <code>Forc.toml</code> file when using external libraries. Inside the <code>wallet_smart_contract</code> project, it requires a declaration like this:</p>
<pre><code class="language-sh">[dependencies]
wallet_abi = { path = "../wallet_abi/" }
</code></pre>
<h2 id="abi-declaration"><a class="header" href="#abi-declaration">ABI Declaration</a></h2>
<pre><code class="language-sway">library;

abi Wallet {
    #[storage(read, write), payable]
    fn receive_funds();

    #[storage(read, write)]
    fn send_funds(amount_to_send: u64, recipient_address: Address);
}
</code></pre>
<h2 id="abi-implementation"><a class="header" href="#abi-implementation">ABI Implementation</a></h2>
<pre><code class="language-sway">contract;

use std::{asset::transfer, call_frames::msg_asset_id, context::msg_amount};

use wallet_abi::Wallet;
const OWNER_ADDRESS = Address::from(0x8900c5bec4ca97d4febf9ceb4754a60d782abbf3cd815836c1872116f203f861);

storage {
    balance: u64 = 0,
}

impl Wallet for Contract {
    #[storage(read, write), payable]
    fn receive_funds() {
        if msg_asset_id() == AssetId::base() {
            // If we received the base asset then keep track of the balance.
            // Otherwise, we're receiving other native assets and don't care
            // about our balance of coins.
            storage.balance.write(storage.balance.read() + msg_amount());
        }
    }

    #[storage(read, write)]
    fn send_funds(amount_to_send: u64, recipient_address: Address) {
        let sender = msg_sender().unwrap();
        match sender {
            Identity::Address(addr) =&gt; assert(addr == OWNER_ADDRESS),
            _ =&gt; revert(0),
        };

        let current_balance = storage.balance.read();
        assert(current_balance &gt;= amount_to_send);

        storage.balance.write(current_balance - amount_to_send);

        // Note: `transfer()` is not a call and thus not an
        // interaction. Regardless, this code conforms to
        // checks-effects-interactions to avoid re-entrancy.
        transfer(
            Identity::Address(recipient_address),
            AssetId::base(),
            amount_to_send,
        );
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="liquidity-pool-example"><a class="header" href="#liquidity-pool-example">Liquidity Pool Example</a></h1>
<p>All contracts in Fuel can mint and burn their own native asset. Contracts can also receive and transfer any native asset including their own. Internal balances of all native assets pushed through calls or minted by the contract are tracked by the FuelVM and can be queried at any point using the <code>balance_of</code> function from the <code>std</code> library. Therefore, there is no need for any manual accounting of the contract's balances using persistent storage.</p>
<p>The <code>std</code> library provides handy methods for accessing Fuel's native asset operations.</p>
<p>In this example, we show a basic liquidity pool contract minting its own native asset LP asset.</p>
<pre><code class="language-sway">contract;

use std::{
    asset::{
        mint_to,
        transfer,
    },
    call_frames::msg_asset_id,
    constants::DEFAULT_SUB_ID,
    context::msg_amount,
    hash::*,
};

abi LiquidityPool {
    fn deposit(recipient: Address);
    fn withdraw(recipient: Address);
}

const BASE_ASSET: AssetId = AssetId::from(0x9ae5b658754e096e4d681c548daf46354495a437cc61492599e33fc64dcdc30c);

impl LiquidityPool for Contract {
    fn deposit(recipient: Address) {
        assert(msg_asset_id() == BASE_ASSET);
        assert(msg_amount() &gt; 0);

        // Mint two times the amount.
        let amount_to_mint = msg_amount() * 2;

        // Mint some LP assets based upon the amount of the base asset.
        mint_to(Identity::Address(recipient), DEFAULT_SUB_ID, amount_to_mint);
    }

    fn withdraw(recipient: Address) {
        let asset_id = AssetId::default();
        assert(msg_asset_id() == asset_id);
        assert(msg_amount() &gt; 0);

        // Amount to withdraw.
        let amount_to_transfer = msg_amount() / 2;

        // Transfer base asset to recipient.
        transfer(Identity::Address(recipient), BASE_ASSET, amount_to_transfer);
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sway-applications"><a class="header" href="#sway-applications">Sway Applications</a></h1>
<p>The <a href="https://github.com/FuelLabs/sway-applications">Sway-Applications</a> Repository contains end-to-end example applications that are written in Sway in order to demonstrate what can be built.</p>
<h2 id="asset-management"><a class="header" href="#asset-management">Asset Management</a></h2>
<ul>
<li><a href="https://github.com/FuelLabs/sway-applications/tree/master/airdrop">Airdrop</a> is an asset distribution program where users are able to claim assets given a valid merkle proof.</li>
<li><a href="https://github.com/FuelLabs/sway-applications/tree/master/escrow">Escrow</a> is a third party that keeps an asset on behalf of multiple parties.</li>
<li><a href="https://github.com/FuelLabs/sway-applications/tree/master/NFT">Non-Fungible Native Asset (NFT)</a> is an asset contract which provides unique collectibles, identified and differentiated by IDs, where assets contain metadata giving them distinctive characteristics.</li>
<li><a href="https://github.com/FuelLabs/sway-applications/tree/master/fractional-NFT">Fractional Non-Fungible Token (F-NFT)</a> is a token contract which issues shares or partial ownership upon locking an NFT into a vault.</li>
<li><a href="https://github.com/FuelLabs/sway-applications/tree/master/timelock">Timelock</a> is a contract which restricts the execution of a transaction to a specified time range.</li>
<li><a href="https://github.com/FuelLabs/sway-applications/tree/master/native-asset">Native Asset</a> is a basic asset contract that enables the use of Native Assets on Fuel using existing standards and libraries.</li>
</ul>
<h2 id="decentralized-finance"><a class="header" href="#decentralized-finance">Decentralized Finance</a></h2>
<ul>
<li><a href="https://github.com/FuelLabs/sway-applications/tree/master/english-auction">English Auction</a> is an auction where users bid up the price of an asset until the bidding period has ended or a reserve has been met.</li>
<li><a href="https://github.com/FuelLabs/sway-applications/tree/master/fundraiser">Fundraiser</a> is a program allowing users to pledge towards a goal.</li>
<li><a href="https://github.com/FuelLabs/sway-applications/tree/master/OTC-swap-predicate">OTC Swap Predicate</a> is a predicate that can be used to propose and execute an atomic swap between two parties without requiring any on-chain state.</li>
</ul>
<h2 id="governance"><a class="header" href="#governance">Governance</a></h2>
<ul>
<li><a href="https://github.com/FuelLabs/sway-applications/tree/master/DAO">Decentralized Autonomous Organization (DAO)</a> is an organization where users get to vote on governance proposals using governance assets.</li>
<li><a href="https://github.com/FuelLabs/sway-applications/tree/master/multisig-wallet">Multi-Signature Wallet</a> is a wallet that requires multiple signatures to execute a transaction.</li>
</ul>
<h2 id="games"><a class="header" href="#games">Games</a></h2>
<ul>
<li><a href="https://github.com/FuelLabs/sway-applications/tree/master/TicTacToe">TicTacToe</a> is a game where two players compete to align three markers in a row.</li>
</ul>
<h2 id="other"><a class="header" href="#other">Other</a></h2>
<ul>
<li><a href="https://github.com/FuelLabs/sway-applications/tree/master/counter-script">Counter-Script</a> is a script that calls a contract to increment a counter.</li>
<li><a href="https://github.com/FuelLabs/sway-applications/tree/master/name-registry">Name-Registry</a> allows users to perform transactions with human readable names instead of addresses.</li>
<li><a href="https://github.com/FuelLabs/sway-applications/tree/master/oracle">Oracle</a> is a smart contract that provides off-chain data to on-chain applications.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sway-program-types"><a class="header" href="#sway-program-types">Sway Program Types</a></h1>
<!-- This section should explain program types -->
<!-- programs:example:start -->
<p>A Sway program itself has a type: it is either a <em>contract</em>, a <em>predicate</em>, a <em>script</em>, or a <em>library</em>. The first three of these things are all deployable to the blockchain. A <em>library</em> is simply a project designed for code reuse and is never directly deployed to the chain.</p>
<p>Every Sway file <em>must</em> begin with a declaration of what type of program it is. A project can have many libraries within it, but only one contract, script, or predicate. Scripts and predicates require <code>main</code> functions to serve as entry points, while contracts instead publish an ABI. This chapter will go into detail about all of these various types of programs and what purposes they serve.</p>
<!-- programs:example:end -->
<p>Contracts are used primarily for protocols or systems that operate within a fixed set of rules. A good example would be a staking contract or a decentralized exchange (also called a DEX).</p>
<p>Scripts are used for complex on-chain interactions that won't persist. An example of this may be using a DEX and Lender to create a leveraged position (borrow, swap, re-collateralize) which is a complex transaction that would usually take multiple steps.</p>
<p>Libraries are for code that is reusable and useful for handling common situations. A good example of this would be a library to handle fixed-point math or big number math.</p>
<ul>
<li><a href="sway-program-types/./smart_contracts.html">Contracts</a></li>
<li><a href="sway-program-types/./libraries.html">Libraries</a></li>
<li><a href="sway-program-types/./scripts.html">Scripts</a></li>
<li><a href="sway-program-types/./predicates.html">Predicates</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="what-is-a-smart-contract"><a class="header" href="#what-is-a-smart-contract">What is a Smart Contract?</a></h1>
<!-- This section should explain what is a smart contract -->
<!-- contract:example:start -->
<p>A smart contract is no different than a script or predicate in that it is a piece of bytecode that is deployed to the blockchain via a <a href="https://fuellabs.github.io/fuel-specs/master/protocol/tx_format">transaction</a>. The main features of a smart contract that differentiate it from scripts or predicates are that it is <em>callable</em> and <em>stateful</em>. Put another way, a smart contract is analogous to a deployed API with some database state.</p>
<!-- contract:example:end -->
<p>The interface of a smart contract, also just called a contract, can be explicitly defined with an <a href="sway-program-types/smart_contracts.html#the-abi-declaration">ABI declaration</a> or implicitly with an <a href="sway-program-types/smart_contracts.html#impl-self-contracts">impl Self</a> item for the special type "Contract". See <a href="sway-program-types/../examples/wallet_smart_contract.html">this contract</a> for an example on using ABIs.</p>
<h2 id="syntax-of-a-smart-contract"><a class="header" href="#syntax-of-a-smart-contract">Syntax of a Smart Contract</a></h2>
<p>As with any Sway program, the program starts with a declaration of what <a href="sway-program-types/./index.html">program type</a> it is. When using ABIs, a contract must either define or import an <a href="sway-program-types/smart_contracts.html#the-abi-declaration">ABI declaration</a> and implement it.</p>
<!-- This section should explain best practices for ABIs -->
<!-- ABI:example:start -->
<p>It is considered good practice to define your ABI in a separate library and import it into your contract. This allows callers of your contract to simply import the ABI directly and use it in their scripts to call your contract.</p>
<!-- ABI:example:end -->
<p>Let's take a look at an ABI declaration in a library:</p>
<pre><code class="language-sway">library;

abi Wallet {
    #[storage(read, write), payable]
    fn receive_funds();

    #[storage(read, write)]
    fn send_funds(amount_to_send: u64, recipient_address: Address);
}
</code></pre>
<p>Let's focus on the ABI declaration and inspect it line-by-line.</p>
<h3 id="the-abi-declaration"><a class="header" href="#the-abi-declaration">The ABI Declaration</a></h3>
<pre><code class="language-sway">abi Wallet {
    #[storage(read, write), payable]
    fn receive_funds();

    #[storage(read, write)]
    fn send_funds(amount_to_send: u64, recipient_address: Address);
}
</code></pre>
<hr />
<p>In the first line, <code>abi Wallet {</code>, we declare the name of this <em>Application Binary Interface</em>, or ABI. We are naming this ABI <code>Wallet</code>. To import this ABI into either a script for calling or a contract for implementing, you would use</p>
<pre><code class="language-sway">use wallet_abi::Wallet;
</code></pre>
<hr />
<p>In the second line,</p>
<pre><code class="language-sway">    #[storage(read, write), payable]
    fn receive_funds();
</code></pre>
<p>we are declaring an ABI method called <code>receive_funds</code> which, when called, should receive funds into this wallet. Note that we are simply defining an interface here, so there is no <em>function body</em> or implementation of the function. We only need to define the interface itself. In this way, ABI declarations are similar to <a href="sway-program-types/../advanced/traits.html">trait declarations</a>. This particular ABI method does not take any parameters.</p>
<hr />
<p>In the third line,</p>
<pre><code class="language-sway">    #[storage(read, write)]
    fn send_funds(amount_to_send: u64, recipient_address: Address);
</code></pre>
<p>we are declaring another ABI method, this time called <code>send_funds</code>. It takes two parameters: the amount to send, and the address to send the funds to.</p>
<blockquote>
<p><strong>Note</strong>: The ABI methods <code>receive_funds</code> and <code>send_funds</code> also require the annotation <code>#[storage(read, write)]</code> because their implementations require reading and writing a storage variable that keeps track of the wallet balance, as we will see shortly. Refer to <a href="sway-program-types/../blockchain-development/purity.html#Purity">Purity</a> for more information on storage annotations.</p>
</blockquote>
<h2 id="implementing-an-abi-for-a-smart-contract"><a class="header" href="#implementing-an-abi-for-a-smart-contract">Implementing an ABI for a Smart Contract</a></h2>
<p>Now that we've discussed how to define the interface, let's discuss how to use it. We will start by implementing the above ABI for a specific contract.</p>
<p>Implementing an ABI for a contract is accomplished with <code>impl &lt;ABI name&gt; for Contract</code> syntax. The <code>for Contract</code> syntax can only be used to implement an ABI for a contract; implementing methods for a struct should use <code>impl Foo</code> syntax.</p>
<pre><code class="language-sway">impl Wallet for Contract {
    #[storage(read, write), payable]
    fn receive_funds() {
        if msg_asset_id() == AssetId::base() {
            // If we received the base asset then keep track of the balance.
            // Otherwise, we're receiving other native assets and don't care
            // about our balance of coins.
            storage.balance.write(storage.balance.read() + msg_amount());
        }
    }

    #[storage(read, write)]
    fn send_funds(amount_to_send: u64, recipient_address: Address) {
        let sender = msg_sender().unwrap();
        match sender {
            Identity::Address(addr) =&gt; assert(addr == OWNER_ADDRESS),
            _ =&gt; revert(0),
        };

        let current_balance = storage.balance.read();
        assert(current_balance &gt;= amount_to_send);

        storage.balance.write(current_balance - amount_to_send);

        // Note: `transfer()` is not a call and thus not an
        // interaction. Regardless, this code conforms to
        // checks-effects-interactions to avoid re-entrancy.
        transfer(
            Identity::Address(recipient_address),
            AssetId::base(),
            amount_to_send,
        );
    }
}
</code></pre>
<p>You may notice once again the similarities between <a href="sway-program-types/../advanced/traits.html">traits</a> and ABIs. And, indeed, as a bonus, you can define methods in addition to the interface surface of an ABI, just like a trait. These pre-implemented ABI methods automatically become available as part of the contract interface that implements the corresponding ABI.</p>
<p>Note that the above implementation of the ABI follows the <a href="https://docs.soliditylang.org/en/v0.6.11/security-considerations.html#re-entrancy">Checks, Effects, Interactions</a> pattern.</p>
<h2 id="the-contractid-type"><a class="header" href="#the-contractid-type">The <code>ContractId</code> type</a></h2>
<p>Contracts have an associated <code>ContractId</code> type in Sway. The <code>ContractId</code> type allows for Sway programs to refer to contracts in the Sway language. Please refer to the <a href="sway-program-types/../basics/blockchain_types.html#contractid-type">ContractId</a> section of the book for more information on <code>ContractId</code>s.</p>
<h2 id="calling-a-smart-contract-from-a-script"><a class="header" href="#calling-a-smart-contract-from-a-script">Calling a Smart Contract from a Script</a></h2>
<blockquote>
<p><strong>Note</strong>: In most cases, calling a contract should be done from the <a href="sway-program-types/../testing/testing-with-rust.html">Rust SDK</a> or the <a href="https://docs.fuel.network/docs/fuels-ts">TypeScript SDK</a> which provide a more ergonomic UI for interacting with a contract. However, there are situations where manually writing a script to call a contract is required.</p>
</blockquote>
<p>Now that we have defined our interface and implemented it for our contract, we need to know how to actually <em>call</em> our contract. Let's take a look at a contract call:</p>
<pre><code class="language-sway">script;

use wallet_abi::Wallet;

fn main() {
    let contract_address = 0x9299da6c73e6dc03eeabcce242bb347de3f5f56cd1c70926d76526d7ed199b8b;
    let caller = abi(Wallet, contract_address);
    let amount_to_send = 200;
    let recipient_address = Address::from(0x9299da6c73e6dc03eeabcce242bb347de3f5f56cd1c70926d76526d7ed199b8b);
    caller
        .send_funds {
            gas: 10000,
            coins: 0,
            asset_id: b256::zero(),
        }(amount_to_send, recipient_address);
}
</code></pre>
<p>The main new concept is the <code>abi cast</code>: <code>abi(AbiName, contract_address)</code>. This returns a <code>ContractCaller</code> type which can be used to call contracts. The methods of the ABI become the methods available on this contract caller: <code>send_funds</code> and <code>receive_funds</code>. We then directly call the contract ABI method as if it was just a regular method. You also have the option of specifying the following special parameters inside curly braces right before the main list of parameters:</p>
<ol>
<li><code>gas</code>: a <code>u64</code> that represents the gas being forwarded to the contract when it is called.</li>
<li><code>coins</code>: a <code>u64</code> that represents how many coins are being forwarded with this call.</li>
<li><code>asset_id</code>: a <code>b256</code> that represents the ID of the <em>asset type</em> of the coins being forwarded.</li>
</ol>
<p>Each special parameter is optional and assumes a default value when skipped:</p>
<ol>
<li>The default value for <code>gas</code> is the context gas (i.e. the content of the special register <code>$cgas</code>). Refer to the <a href="https://fuellabs.github.io/fuel-specs/master/vm">FuelVM specifications</a> for more information about context gas.</li>
<li>The default value for <code>coins</code> is 0.</li>
<li>The default value for <code>asset_id</code> is <code>b256::zero()</code>.</li>
</ol>
<h2 id="impl-self-contracts"><a class="header" href="#impl-self-contracts">Impl Self Contracts</a></h2>
<p>In some cases, it may be more convenient to avoid declaring an ABI and implement the contract directly, as shown in the example below.</p>
<p>Notice how there is no ABI specified in the <code>impl</code> item. In this case, the compiler will automatically create an ABI named as the package containing this <code>impl Contract</code> item, and will include each function in the ABI.</p>
<pre><code class="language-sway">impl Contract {
    #[storage(read, write), payable]
    fn receive_funds() {
        if msg_asset_id() == AssetId::base() {
            // If we received the base asset then keep track of the balance.
            // Otherwise, we're receiving other native assets and don't care
            // about our balance of coins.
            storage.balance.write(storage.balance.read() + msg_amount());
        }
    }

    #[storage(read, write)]
    fn send_funds(amount_to_send: u64, recipient_address: Address) {
        let sender = msg_sender().unwrap();
        match sender {
            Identity::Address(addr) =&gt; assert(addr == OWNER_ADDRESS),
            _ =&gt; revert(0),
        };

        let current_balance = storage.balance.read();
        assert(current_balance &gt;= amount_to_send);

        storage.balance.write(current_balance - amount_to_send);

        // Note: `transfer()` is not a call and thus not an
        // interaction. Regardless, this code conforms to
        // checks-effects-interactions to avoid re-entrancy.
        transfer(
            Identity::Address(recipient_address),
            AssetId::base(),
            amount_to_send,
        );
    }
}
</code></pre>
<p>Without an ABI, there is no way for scripts and other contracts to use <code>abi(...)</code> and call this contract, but it can still be tested and called using any of available SDKs, as any other contract.</p>
<p>The ABI name will be the "upper camel case" version of the package name containing the "impl Contract" item. <code>CONTRACT_ID</code> is a compiler special constant that references the contract being implemented in this file.</p>
<pre><code class="language-sway">#[test]
fn tests() {
    let w = abi(WalletSmartContractSelfImpl, CONTRACT_ID);
    w.receive_funds();
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="libraries"><a class="header" href="#libraries">Libraries</a></h1>
<!-- This section should explain what a library is -->
<!-- library:example:start -->
<p>Libraries in Sway are files used to define new common behavior.</p>
<!-- library:example:end -->
<p>The most prominent example of this is the <a href="sway-program-types/../introduction/standard_library.html">Sway Standard Library</a> that is made implicitly available to all Forc projects created using <code>forc new</code>.</p>
<h2 id="writing-libraries"><a class="header" href="#writing-libraries">Writing Libraries</a></h2>
<!-- This section should explain how libraries are defined -->
<!-- def_lib:example:start -->
<p>Libraries are defined using the <code>library</code> keyword at the beginning of a file, followed by a name so that they can be imported.</p>
<!-- def_lib:example:end -->
<pre><code class="language-sway">library;

// library code
</code></pre>
<p>A good reference library to use when learning library design is the <a href="sway-program-types/../introduction/standard_library.html">Sway Standard Library</a>. For example, the standard library offers an <a href="https://github.com/FuelLabs/sway/blob/master/sway-lib-std/src/option.sw">implementation</a> of <code>enum Option&lt;T&gt;</code> which is a generic type that represents either the existence of a value using the variant <code>Some(..)</code> or a value's absence using the variant <code>None</code>. The <a href="https://github.com/FuelLabs/sway/blob/master/sway-lib-std/src/option.sw">Sway file implementing <code>Option&lt;T&gt;</code></a> has the following structure:</p>
<ul>
<li>The <code>library</code> keyword:</li>
</ul>
<pre><code class="language-sway">library;
</code></pre>
<ul>
<li>A <code>use</code> statement that imports <code>revert</code> from another library <em>inside</em> the standard library:</li>
</ul>
<pre><code class="language-sway">use ::revert::revert;
</code></pre>
<ul>
<li>The <code>enum</code> definition which starts with the keyword <code>pub</code> to indicate that this <code>Option&lt;T&gt;</code> is publicly available <em>outside</em> the <code>option</code> library:</li>
</ul>
<pre><code class="language-sway">pub enum Option&lt;T&gt; {
    // variants
}
</code></pre>
<ul>
<li>An <code>impl</code> block that implements some methods for <code>Option&lt;T&gt;</code>:</li>
</ul>
<pre><code class="language-sway">impl&lt;T&gt; Option&lt;T&gt; {

    fn is_some(self) -&gt; bool {
        // body of is_some
    }

    // other methods
}
</code></pre>
<p>Now that the library <code>option</code> is fully written, and because <code>Option&lt;T&gt;</code> is defined with the <code>pub</code> keyword, we are now able to import <code>Option&lt;T&gt;</code> using <code>use std::option::Option;</code> from any Sway project and have access to all of its variants and methods. That being said, <code>Option</code> is automatically available in the <a href="sway-program-types/../introduction/standard_library.html#standard-library-prelude">standard library prelude</a> so you never actually have to import it manually.</p>
<p>Libraries are composed of just a <code>Forc.toml</code> file and a <code>src</code> directory, unlike contracts which usually contain a <code>tests</code> directory and a <code>Cargo.toml</code> file as well. An example of a library's <code>Forc.toml</code>:</p>
<pre><code class="language-toml">[project]
authors = ["Fuel Labs &lt;contact@fuel.sh&gt;"]
entry = "lib.sw"
license = "Apache-2.0"
name = "my_library"

[dependencies]
</code></pre>
<p>which denotes the authors, an entry file, the name by which it can be imported, and any dependencies.</p>
<p>For large libraries, it is recommended to have a <code>lib.sw</code> entry point re-export all other sub-libraries.</p>
<!-- This section should explain the `mod` keyword -->
<!-- mod:example:start -->
<p>The <code>mod</code> keyword registers a submodule, making its items (such as functions and structs) accessible from the parent library.
If used at the top level it will refer to a file in the <code>src</code> folder and in other cases in a folder named after the library in which it is defined.</p>
<!-- mod:example:end -->
<p>For example, the <code>lib.sw</code> of the standard library looks like:</p>
<pre><code class="language-sway">library;

mod block;
mod storage;
mod constants;
mod vm;
// .. Other deps
</code></pre>
<p>with other libraries contained in the <code>src</code> folder, like the <code>vm</code> library (inside of <code>src/vm.sw</code>):</p>
<pre><code class="language-sway">library;

mod evm;
// ...
</code></pre>
<p>and it's own sub-library <code>evm</code> located in <code>src/vm/evm.sw</code>:</p>
<pre><code class="language-sway">library;

// ...
</code></pre>
<h2 id="using-libraries"><a class="header" href="#using-libraries">Using Libraries</a></h2>
<p>There are two types of Sway libraries, based on their location and how they can be imported.</p>
<h3 id="internal-libraries"><a class="header" href="#internal-libraries">Internal Libraries</a></h3>
<p>Internal libraries are located within the project's <code>src</code> directory alongside
<code>main.sw</code> or in the appropriate folders as shown below:</p>
<pre><code class="language-bash">$ tree
.
â”œâ”€â”€ Cargo.toml
â”œâ”€â”€ Forc.toml
â””â”€â”€ src
    â”œâ”€â”€ internal_lib.sw
    â”œâ”€â”€ main.sw
    â””â”€â”€ internal_lib
        â””â”€â”€ nested_lib.sw
</code></pre>
<p>As <code>internal_lib</code> is an internal library, it can be imported into <code>main.sw</code> as follows:</p>
<ul>
<li>Use the <code>mod</code> keyword followed by the library name to make the internal library a dependency</li>
<li>Use the <code>use</code> keyword with a <code>::</code> separating the name of the library and the imported item(s)</li>
</ul>
<pre><code class="language-sway">mod internal_lib; // Assuming the library name in `internal_lib.sw` is `internal_lib`

use internal_lib::mint;

// `mint` from `internal_library` is now available in this file
</code></pre>
<h3 id="external-libraries"><a class="header" href="#external-libraries">External Libraries</a></h3>
<p>External libraries are located outside the main <code>src</code> directory as shown below:</p>
<pre><code class="language-bash">$ tree
.
â”œâ”€â”€ my_project
â”‚   â”œâ”€â”€ Cargo.toml
â”‚   â”œâ”€â”€ Forc.toml
â”‚   â””â”€â”€â”€ src
â”‚       â””â”€â”€ main.sw
â”‚
â””â”€â”€ external_lib
    â”œâ”€â”€ Cargo.toml
    â”œâ”€â”€ Forc.toml
    â””â”€â”€â”€ src
        â””â”€â”€ lib.sw
</code></pre>
<p>As <code>external_lib</code> is outside the <code>src</code> directory of <code>my_project</code>, it needs to be added as a dependency in the <code>Forc.toml</code> file of <code>my_project</code>, by adding the library path in the <code>dependencies</code> section as shown below, before it can be imported:</p>
<pre><code class="language-toml">[dependencies]
external_library = { path = "../external_library" }
</code></pre>
<p>Once the library dependency is added to the <code>toml</code> file, you can import items from it as follows:</p>
<ul>
<li>Make sure the item you want imported are declared with the <code>pub</code> keyword (if applicable, for instance: <code>pub fn mint() {}</code>)</li>
<li>Use the <code>use</code> keyword to selectively import items from the library</li>
</ul>
<pre><code class="language-sway">use external_library::mint;

// `mint` from `external_library` is now available in this file
</code></pre>
<p>Wildcard imports using <code>*</code> are supported, but it is generally recommended to use explicit imports where possible.</p>
<blockquote>
<p><strong>Note</strong>: the standard library is implicitly available to all Forc projects, that is, you are not required to manually specify <code>std</code> as an explicit dependency in <code>Forc.toml</code>.</p>
</blockquote>
<h2 id="reference-sway-libraries"><a class="header" href="#reference-sway-libraries">Reference Sway Libraries</a></h2>
<p>The repository <a href="https://github.com/FuelLabs/sway-libs/"><code>sway-libs</code></a> is a collection of external libraries that you can import and make use of in your Fuel applications. These libraries are meant to be implementations of common use-cases valuable for dapp development.</p>
<p>Some Sway Libraries to try out:</p>
<ul>
<li><a href="https://docs.fuel.network/docs/sway-libs/merkle/">Binary Merkle Proof</a></li>
<li><a href="https://docs.fuel.network/docs/sway-libs/signed_integers/">Signed Integers</a></li>
<li><a href="https://fuellabs.github.io/sway-libs/book/ownership/index.html">Ownership</a></li>
</ul>
<h3 id="example-1"><a class="header" href="#example-1">Example</a></h3>
<p>You can import and use a Sway Library such as the <a href="https://fuellabs.github.io/sway-libs/book/ownership/index.html">Ownership</a> library just like any other external library.</p>
<pre><code class="language-sway">use ownership::Ownership;
</code></pre>
<p>Once imported, you can use the following basic functionality of the library in your smart contract:</p>
<ul>
<li>Declaring an owner</li>
<li>Changing ownership</li>
<li>Renouncing ownership</li>
<li>Ensuring a function may only be called by the owner</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="scripts"><a class="header" href="#scripts">Scripts</a></h1>
<p>A script is runnable bytecode on the chain which executes once to perform some task. It does not represent ownership of any resources and it cannot be called by a contract. A script can return a single value of any type.</p>
<p>Scripts are state-aware in that while they have no persistent storage (because they only exist during the transaction) they can call contracts and act based upon the returned values and results.</p>
<p>This example script calls a contract:</p>
<pre><code class="language-sway">script;

use wallet_abi::Wallet;

fn main() {
    let contract_address = 0x9299da6c73e6dc03eeabcce242bb347de3f5f56cd1c70926d76526d7ed199b8b;
    let caller = abi(Wallet, contract_address);
    let amount_to_send = 200;
    let recipient_address = Address::from(0x9299da6c73e6dc03eeabcce242bb347de3f5f56cd1c70926d76526d7ed199b8b);
    caller
        .send_funds {
            gas: 10000,
            coins: 0,
            asset_id: b256::zero(),
        }(amount_to_send, recipient_address);
}
</code></pre>
<p>Scripts, similar to predicates, rely on a <code>main()</code> function as an entry point. You can call other functions defined in a script from the <code>main()</code> function or call another contract via an <a href="sway-program-types/./smart_contracts.html#calling-a-smart-contract-from-a-script">ABI cast</a>.</p>
<p>An example use case for a script would be a router that trades funds through multiple decentralized exchanges to get the price for the input asset, or a script to re-adjust a Collateralized Debt Position via a flash loan.</p>
<h2 id="scripts-and-the-sdks"><a class="header" href="#scripts-and-the-sdks">Scripts and the SDKs</a></h2>
<p>Unlike EVM transactions which can call a contract directly (but can only call a single contract), Fuel transactions execute a script, which may call zero or more contracts. The Rust and TypeScript SDKs provide functions to call contract methods as if they were calling contracts directly. Under the hood, the SDKs wrap all contract calls with scripts that contain minimal code to simply make the call and forward script data as call parameters.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="predicates"><a class="header" href="#predicates">Predicates</a></h1>
<p>From the perspective of Sway, predicates are programs that return a Boolean value and which represent ownership of some resource upon execution to true. They have no access to contract storage. Here is a trivial predicate, which always evaluates to true:</p>
<pre><code class="language-sway">predicate;

// All predicates require a main function which returns a Boolean value.
fn main() -&gt; bool {
    true
}
</code></pre>
<p>The address of this predicate is <code>0xd19a5fe4cb9baf41ad9813f1a6fef551107c8e8e3f499a6e32bccbb954a74764</code>. Any assets sent to this address can be unlocked or claimed by executing the predicate above as it always evaluates to true.</p>
<p>It does not need to be deployed to a blockchain because it only exists during a transaction. That being said, the predicate address is on-chain as the owner of one or more UTXOs.</p>
<h2 id="transfer-coins-to-a-predicate"><a class="header" href="#transfer-coins-to-a-predicate">Transfer Coins to a Predicate</a></h2>
<p>In Fuel, coins can be sent to a predicate's address(the bytecode root, calculated <a href="https://github.com/FuelLabs/fuel-specs/blob/master/src/identifiers/predicate-id.md">here</a>).</p>
<h2 id="spending-predicate-coins"><a class="header" href="#spending-predicate-coins">Spending Predicate Coins</a></h2>
<p>The coin UTXOs become spendable not on the provision of a valid signature, but rather if the supplied predicate both has a root that matches their owner, and <a href="https://github.com/FuelLabs/fuel-specs/blob/master/src/fuel-vm/index.md#predicate-verification">evaluates</a> to <code>true</code>.</p>
<p>If a predicate reverts, or tries to access impure VM opcodes, the evaluation is automatically <code>false</code>.</p>
<p>An analogy for predicates is rather than a traditional 12 or 24 word seed phrase that generates a private key and creates a valid signature, a predicate's code can be viewed as the private key. Anyone with the code may execute a predicate, but only when the predicate evaluates to true may the assets owned by that address be released.</p>
<h2 id="spending-conditions"><a class="header" href="#spending-conditions">Spending Conditions</a></h2>
<p>Predicates may introspect the transaction spending their coins (inputs, outputs, script bytecode, etc.) and may take runtime arguments, either or both of which may affect the evaluation of the predicate.</p>
<p>It is important to note that predicates cannot read or write memory. They may however check the inputs and outputs of a transaction. For example in the <a href="https://github.com/FuelLabs/sway-applications/tree/master/OTC-swap-predicate">OTC Predicate Swap Example</a>, a user may specify they would like to swap <code>asset1</code> for <code>asset2</code> and with amount of <code>5</code>. The user would then send <code>asset1</code> to the predicate. Only when the predicate can verify that the outputs include <code>5</code> coins of <code>asset2</code> being sent to the original user, may <code>asset1</code> be transferred out of the predicate.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sway-language-basics"><a class="header" href="#sway-language-basics">Sway Language Basics</a></h1>
<p>Sway is a programming language designed for the FuelVM. It is a statically typed, compiled language with type inference and traits. Sway aims to make smart contract development safer and more efficient through the use of strong static analysis and compiler feedback.</p>
<p>Get started with the basics of Sway:</p>
<ul>
<li><a href="basics/./variables.html">Variables</a></li>
<li><a href="basics/./built_in_types.html">Built-in Types</a></li>
<li><a href="basics/./commonly_used_library_types.html">Commonly Used Library Types</a></li>
<li><a href="basics/./blockchain_types.html">Blockchain Types</a></li>
<li><a href="basics/./functions.html">Functions</a></li>
<li><a href="basics/./structs_tuples_and_enums.html">Structs, Tuples, and Enums</a></li>
<li><a href="basics/./methods_and_associated_functions.html">Methods and Associated Functions</a></li>
<li><a href="basics/./constants.html">Constants</a></li>
<li><a href="basics/./comments_and_logging.html">Comments and Logging</a></li>
<li><a href="basics/./control_flow.html">Control Flow</a></li>
<li><a href="basics/./error_handling.html">Error Handling</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="variables"><a class="header" href="#variables">Variables</a></h1>
<!-- This section should explain how variables are immutable -->
<!-- immutable_vars:example:start -->
<p>Variables in Sway are <em>immutable by default</em>. This means that, by default, once a variable is declared, its value cannot change. This is one of the ways how Sway encourages safe programming, and many modern languages have this same default.</p>
<!-- immutable_vars:example:end -->
<p>Let's take a look at variables in detail.</p>
<h2 id="declaring-a-variable"><a class="header" href="#declaring-a-variable">Declaring a Variable</a></h2>
<p>Let's look at a variable declaration:</p>
<pre><code class="language-sway">let foo = 5;
</code></pre>
<p>Great! We have just declared a variable, <code>foo</code>. What do we know about <code>foo</code>?</p>
<ol>
<li>It is immutable.</li>
<li>Its value is <code>5</code>.</li>
<li>Its type is <code>u64</code>, a 64-bit unsigned integer.</li>
</ol>
<p><code>u64</code> is the default numeric type, and represents a 64-bit unsigned integer. See the section <a href="basics/./built_in_types.html">Built-in Types</a> for more details.</p>
<p>We can also make a mutable variable. Let's take a look:</p>
<pre><code class="language-sway">let mut foo = 5;
foo = 6;
</code></pre>
<p>Now, <code>foo</code> is mutable, and the reassignment to the number <code>6</code> is valid. That is, we are allowed to <em>mutate</em> the variable <code>foo</code> to change its value.</p>
<p>When assigning to a mutable variable, the right-hand side of the assignment is evaluated before the left-hand side. In the below example, the mutable variable <code>i</code> will first be increased and the resulting value of <code>1</code> will be stored to <code>array[1]</code>, thus resulting in <code>array</code> being changed to <code>[0, 1, 0]</code>.</p>
<pre><code class="language-sway">let mut array = [0, 0, 0];
let mut i = 0;

array[i] = {
    i += 1;
    i
};
</code></pre>
<h2 id="type-annotations"><a class="header" href="#type-annotations">Type Annotations</a></h2>
<!-- This section should explain type annotations -->
<!-- type_annotations:example:start -->
<p>A variable declaration can contain a <em>type annotation</em>. A type annotation serves the purpose of declaring the type, in addition to the value, of a variable.</p>
<!-- type_annotations:example:end -->
<p>Let's take a look:</p>
<pre><code class="language-sway">let foo: u32 = 5;
</code></pre>
<p>We have just declared the <em>type</em> of the variable <code>foo</code> as a <code>u32</code>, which is an unsigned 32-bit integer. Let's take a look at a few other type annotations:</p>
<pre><code class="language-sway">let bar: str[4] = __to_str_array("sway");
let baz: bool = true;
</code></pre>
<!-- This section should explain what happens if there is a type conflict -->
<!-- type_conflict:example:start -->
<p>If the value declared cannot be assigned to the declared type, there will be an error generated by the compiler.</p>
<!-- type_conflict:example:end -->
<div style="break-before: page; page-break-before: always;"></div><h1 id="built-in-types"><a class="header" href="#built-in-types">Built-in Types</a></h1>
<p>Every value in Sway is of a certain type. Although deep down, all values are just ones and zeroes in the underlying virtual machine, Sway needs to know what those ones and zeroes actually mean. This is accomplished with <em>types</em>.</p>
<!-- This section should explain how Sway types are inferred -->
<!-- sway_types:example:start -->
<p>Sway is a statically typed language. At compile time, the types of every value must be known. This does not mean you need to specify every single type: usually, the type can be reasonably inferred by the compiler.</p>
<!-- sway_types:example:end -->
<h2 id="primitive-types"><a class="header" href="#primitive-types">Primitive Types</a></h2>
<!-- This section should list the primitive types in Sway -->
<!-- prim_types:example:start -->
<p>Sway has the following primitive types:</p>
<ol>
<li><code>()</code> (unit type)</li>
<li><code>u8</code> (8-bit unsigned integer)</li>
<li><code>u16</code> (16-bit unsigned integer)</li>
<li><code>u32</code> (32-bit unsigned integer)</li>
<li><code>u64</code> (64-bit unsigned integer)</li>
<li><code>u256</code> (256-bit unsigned integer)</li>
<li><code>str[]</code> (fixed-length string)</li>
<li><code>str</code> (string slices)</li>
<li><code>bool</code> (Boolean <code>true</code> or <code>false</code>)</li>
<li><code>b256</code> (256 bits (32 bytes), i.e. a hash)</li>
</ol>
<p>All other types in Sway are built up of these primitive types, or references to these primitive types. You may notice that there are no signed integersâ€”this is by design. In the blockchain domain that Sway occupies, floating-point values and negative numbers have smaller utility, so their implementation has been left up to libraries for specific use cases.</p>
<!-- prim_types:example:end -->
<h2 id="unit-type"><a class="header" href="#unit-type">Unit Type</a></h2>
<p>The unit type, <code>()</code>, is a type that allows only one value, and thus, represents a value with no information. It is used to indicate the absence of a meaningful value, or the result of a function that performs an action, but does not return any data. The value of the unit type, called simply unit, has the same symbol as the unit type, <code>()</code>. Unit type in Sway serves a similar purpose as <code>void</code> in imperative languages like C or Java.</p>
<p>For example:</p>
<pre><code class="language-Sway">fn returns_unit() -&gt; () { // Here, `()` represent the unit type.
    ()                    // Here, `()` represents the single unit value of the unit type.
}
</code></pre>
<p>In Sway, if the function return type is not specified, it is <code>()</code> by default. Thus, the above example is semantically same as the following:</p>
<pre><code class="language-Sway">fn returns_unit() {
}
</code></pre>
<h2 id="numeric-types"><a class="header" href="#numeric-types">Numeric Types</a></h2>
<p>All of the unsigned integer types are numeric types.</p>
<p>Numbers can be declared with binary syntax, hexadecimal syntax, base-10 syntax, and underscores for delineation. Let's take a look at the following valid numeric primitives:</p>
<pre><code class="language-sway">0xffffff    // hexadecimal
0b10101010  // binary
10          // base-10
100_000     // underscore delineated base-10
0x1111_0000 // underscore delineated binary
0xfff_aaa   // underscore delineated hexadecimal
</code></pre>
<!-- This section should explain the default numeric type in Sway -->
<!-- default_num:example:start -->
<p>The default numeric type is <code>u64</code>. The FuelVM's word size is 64 bits, and the cases where using a smaller numeric type saves space are minimal.</p>
<p>If a 64-bit or 256-bit arithmetic operation produces an overflow or an underflow,
computation gets reverted automatically by FuelVM.</p>
<p>8/16/32-bit arithmetic operations are emulated using their 64-bit analogues with
additional overflow/underflow checks inserted, which generally results in
somewhat higher gas consumption.</p>
<p>The same does not happen with 256-bit operations, including <code>b256</code>, which uses specialized operations and are as efficient as possible.</p>
<!-- default_num:example:end -->
<h2 id="boolean-type"><a class="header" href="#boolean-type">Boolean Type</a></h2>
<!-- This section should explain the `bool` type -->
<!-- bool:example:start -->
<p>The boolean type (<code>bool</code>) has two potential values: <code>true</code> or <code>false</code>. Boolean values are typically used for conditional logic or validation, for example in <code>if</code> expressions. Booleans can be negated, or flipped, with the unary negation operator <code>!</code>.</p>
<!-- bool:example:end -->
<p>For example:</p>
<pre><code class="language-sway">fn returns_false() -&gt; bool {
    let boolean_value: bool = true;
    !boolean_value
}
</code></pre>
<h2 id="string-slices"><a class="header" href="#string-slices">String Slices</a></h2>
<!-- This section should explain the string type in Sway -->
<!-- str:example:start -->
<p>In Sway, string literals are stored as variable length string slices. Which means that they are stored as a pointer to the actual string data and its length.</p>
<!-- str:example:end -->
<pre><code class="language-sway">let my_string: str = "fuel";
</code></pre>
<p>String slices, because they contain pointers have limited usage. They cannot be used as constants, storage fields, or configurable constants, nor as main function arguments or returns.</p>
<p>For these cases one must use string arrays, as described below.</p>
<h2 id="string-arrays"><a class="header" href="#string-arrays">String Arrays</a></h2>
<!-- This section should explain the string type in Sway -->
<!-- str:example:start -->
<p>In Sway, static-length strings are a primitive type. This means that when you declare a string array, its size is a part of its type. This is necessary for the compiler to know how much memory to give for the storage of that data. The size of the string is denoted with square brackets.</p>
<!-- str:example:end -->
<p>Let's take a look:</p>
<pre><code class="language-sway">let my_string: str[4] = __to_str_array("fuel");
</code></pre>
<p>Because the string literal <code>"fuel"</code> is four letters, the type is <code>str[4]</code>, denoting a static length of 4 characters. Strings default to UTF-8 in Sway.</p>
<p>As above, string literals are typed as string slices. So that is why the need for <code>__to_str_array</code> that convert them to string arrays at compile time.</p>
<p>Conversion during runtime can be done with <code>from_str_array</code> and <code>try_as_str_array</code>. The latter can fail, given that the specified string array must be big enough for the string slice content.</p>
<pre><code class="language-sway">let a: str = "abcd";
let b: str[4] = a.try_as_str_array().unwrap();
let c: str = from_str_array(b);
</code></pre>
<h2 id="compound-types"><a class="header" href="#compound-types">Compound Types</a></h2>
<p><em>Compound types</em> are types that group multiple values into one type. In Sway, we have arrays and tuples.</p>
<h2 id="tuple-types"><a class="header" href="#tuple-types">Tuple Types</a></h2>
<!-- This section should explain what a tuple is -->
<!-- tuple:example:start -->
<p>A tuple is a general-purpose static-length aggregation of types. In more plain terms, a tuple is a single type that consists of an aggregate of zero or more types. The internal types that make up a tuple, and the tuple's arity, define the tuple's type.</p>
<!-- tuple:example:end -->
<p>Let's take a look at some examples.</p>
<pre><code class="language-sway">let x: (u64, u64) = (0, 0);
</code></pre>
<p>This is a tuple, denoted by parenthesized, comma-separated values. Note that the type annotation, <code>(u64, u64)</code>, is similar in syntax to the expression which instantiates that type, <code>(0, 0)</code>.</p>
<pre><code class="language-sway">let x: (u64, bool) = (42, true);
assert(x.1);
</code></pre>
<p>In this example, we have created a new tuple type, <code>(u64, bool)</code>, which is a composite of a <code>u64</code> and a <code>bool</code>.</p>
<!-- This section should explain how to access a value in a tuple -->
<!-- tuple_val:example:start -->
<p>To access a value within a tuple, we use <em>tuple indexing</em>: <code>x.1</code> stands for the first (zero-indexed, so the <code>bool</code>) value of the tuple. Likewise, <code>x.0</code> would be the zeroth, <code>u64</code> value of the tuple. Tuple values can also be accessed via destructuring.</p>
<!-- tuple_val:example:end -->
<pre><code class="language-sway">struct Foo {}
let x: (u64, Foo, bool) = (42, Foo {}, true);
let (number, foo, boolean) = x;
</code></pre>
<p>To create one-arity tuples, we will need to add a trailing comma:</p>
<pre><code class="language-sway">let x: u64 = (42);     // x is of type u64
let y: (u64) = (42);   // y is of type u64
let z: (u64,) = (42,); // z is of type (u64), i.e. a one-arity tuple
let w: (u64) = (42,);  // type error
</code></pre>
<h2 id="arrays"><a class="header" href="#arrays">Arrays</a></h2>
<!-- This section should explain what an array is -->
<!-- array:example:start -->
<p>An array is similar to a tuple, but an array's values must all be of the same type. Arrays can hold arbitrary types including non-primitive types.</p>
<!-- array:example:end -->
<p>An array is written as a comma-separated list inside square brackets:</p>
<pre><code class="language-sway">let x = [1, 2, 3, 4, 5];
</code></pre>
<!-- This section should explain arrays in depth -->
<!-- array_details:example:start -->
<p>Arrays are allocated on the stack since their size is known. An array's size is <em>always</em> static, i.e. it cannot change. An array of five elements cannot become an array of six elements.</p>
<p>Arrays can be iterated over, unlike tuples. An array's type is written as the type the array contains followed by the number of elements, semicolon-separated and within square brackets, e.g., <code>[u64; 5]</code>. To access an element in an array, use the <em>array indexing syntax</em>, i.e. square brackets.</p>
<!-- array_details:example:end -->
<p>Array elements can also be mutated if the underlying array is declared as mutable:</p>
<pre><code class="language-sway">let mut x = [1, 2, 3, 4, 5];
x[0] = 0;
</code></pre>
<pre><code class="language-sway">script;

struct Foo {
    f1: u32,
    f2: b256,
}

fn main() {
    // Array of integers with type ascription
    let array_of_integers: [u8; 5] = [1, 2, 3, 4, 5];

    // Array of strings
    let array_of_strings = ["Bob", "Jan", "Ron"];

    // Array of structs
    let array_of_structs: [Foo; 2] = [
        Foo {
            f1: 11,
            f2: 0x1111111111111111111111111111111111111111111111111111111111111111,
        },
        Foo {
            f1: 22,
            f2: 0x2222222222222222222222222222222222222222222222222222222222222222,
        },
    ];

    // Accessing an element of an array
    let mut array_of_bools: [bool; 2] = [true, false];
    assert(array_of_bools[0]);

    // Mutating the element of an array
    array_of_bools[1] = true;
    assert(array_of_bools[1]);
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="commonly-used-library-types"><a class="header" href="#commonly-used-library-types">Commonly Used Library Types</a></h1>
<p>The Sway Standard Library is the foundation of portable Sway software, a set of minimal shared abstractions for the broader Sway ecosystem. It offers core types, library-defined operations on language primitives, native asset management, blockchain contextual operations, access control, storage management, and support for types from other VMs, among many other things. Reference the standard library docs <a href="https://fuellabs.github.io/sway/master/std/index.html">here</a>.</p>
<h2 id="resultt-e"><a class="header" href="#resultt-e"><code>Result&lt;T, E&gt;</code></a></h2>
<!-- This section should explain what the `Result` type is -->
<!-- result:example:start -->
<p>Type <code>Result</code> is the type used for returning and propagating recoverable errors. It is an <code>enum</code> with two variants: <code>Ok(T)</code>, representing success and containing a value, and <code>Err(E)</code>, representing error and containing an error value. The <code>T</code> and <code>E</code> in this definition are type parameters, allowing <code>Result</code> to be generic and to be used with any types.</p>
<!-- result:example:end -->
<pre><code class="language-sway">/// `Result` is a type that represents either success (`Ok`) or failure (`Err`).
pub enum Result&lt;T, E&gt; {
    /// Contains the success value.
    Ok: T,
    /// Contains the error value.
    Err: E,
}
</code></pre>
<!-- This section should explain when to use the `Result` type -->
<!-- use_result:example:start -->
<p>Functions return <code>Result</code> whenever errors are expected and recoverable.</p>
<!-- use_result:example:end -->
<p>Take the following example:</p>
<pre><code class="language-sway">script;

enum MyContractError {
    DivisionByZero: (),
}

fn divide(numerator: u64, denominator: u64) -&gt; Result&lt;u64, MyContractError&gt; {
    if (denominator == 0) {
        return Err(MyContractError::DivisionByZero);
    } else {
        Ok(numerator / denominator)
    }
}

fn main() -&gt; Result&lt;u64, str[4]&gt; {
    let result = divide(20, 2);
    match result {
        Ok(value) =&gt; Ok(value),
        Err(MyContractError::DivisionByZero) =&gt; Err(__to_str_array("Fail")),
    }
}
</code></pre>
<p>To learn more about expressing irrecoverable errors in Sway, see the chapter on <a href="basics/error_handling.html">Error Handling</a>.</p>
<h2 id="optiont"><a class="header" href="#optiont"><code>Option&lt;T&gt;</code></a></h2>
<!-- This section should explain the `Option` type -->
<!-- option:example:start -->
<p>Type <code>Option</code> represents an optional value: every <code>Option</code> is either <code>Some</code> and contains a value, or <code>None</code>, and does not. <code>Option</code> types are very common in Sway code, as they have a number of uses:</p>
<ul>
<li>Initial values where <code>None</code> can be used as an initializer.</li>
<li>Return value for otherwise reporting simple errors, where <code>None</code> is returned on error.</li>
</ul>
<p>The implementation of <code>Option</code> matches on the variant: if it's <code>Ok</code> it returns the inner value, if it's <code>None</code>, it <a href="https://github.com/FuelLabs/fuel-specs/blob/master/src/fuel-vm/instruction-set.md#rvrt-revert">reverts</a>.</p>
<!-- option:example:end -->
<pre><code class="language-sway">/// A type that represents an optional value, either `Some(val)` or `None`.
pub enum Option&lt;T&gt; {
    /// No value.
    None: (),
    /// Some value of type `T`.
    Some: T,
}
</code></pre>
<!-- This section should explain when to use the `Option` type -->
<!-- use_option:example:start -->
<p><code>Option</code> is commonly paired with pattern matching to query the presence of a value and take action, allowing developers to choose how to handle the <code>None</code> case.</p>
<!-- use_option:example:end -->
<p>Below is an example that uses pattern matching to handle invalid divisions by 0 by returning an <code>Option</code>:</p>
<pre><code class="language-sway">script;

fn divide(numerator: u64, denominator: u64) -&gt; Option&lt;u64&gt; {
    if denominator == 0 {
        None
    } else {
        Some(numerator / denominator)
    }
}

fn main() {
    let result = divide(6, 2);
    // Pattern match to retrieve the value
    match result {
        // The division was valid
        Some(x) =&gt; std::logging::log(x),
        // The division was invalid
        None =&gt; std::logging::log("Cannot divide by 0"),
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="blockchain-types"><a class="header" href="#blockchain-types">Blockchain Types</a></h1>
<p>Sway is fundamentally a blockchain language, and it offers a selection of types tailored for the blockchain use case.</p>
<p>These are provided via the standard library (<a href="https://github.com/FuelLabs/sway/tree/master/sway-lib-std"><code>lib-std</code></a>) which both add a degree of type-safety, as well as make the intention of the developer more clear.</p>
<h2 id="address-type"><a class="header" href="#address-type"><code>Address</code> Type</a></h2>
<!-- This section should explain the `Address` type -->
<!-- address:example:start -->
<p>The <code>Address</code> type is a type-safe wrapper around the primitive <code>b256</code> type. Unlike the EVM, an address <strong>never</strong> refers to a deployed smart contract (see the <code>ContractId</code> type below). An <code>Address</code> can be either the hash of a public key (effectively an <a href="https://ethereum.org/en/whitepaper/#ethereum-accounts">externally owned account</a> if you're coming from the EVM) or the hash of a <a href="basics/../sway-program-types/predicates.html">predicate</a>. Addresses own UTXOs.</p>
<!-- address:example:end -->
<p>An <code>Address</code> is implemented as follows.</p>
<pre><code class="language-sway">pub struct Address {
    value: b256,
}
</code></pre>
<p>Casting between the <code>b256</code> and <code>Address</code> types must be done explicitly:</p>
<pre><code class="language-sway">let my_number: b256 = 0x000000000000000000000000000000000000000000000000000000000000002A;
let my_address: Address = Address::from(my_number);
let forty_two: b256 = my_address.into();
</code></pre>
<h2 id="contractid-type"><a class="header" href="#contractid-type"><code>ContractId</code> Type</a></h2>
<!-- This section should explain the `ContractId` type -->
<!-- contract_id:example:start -->
<p>The <code>ContractId</code> type is a type-safe wrapper around the primitive <code>b256</code> type. A contract's ID is a unique, deterministic identifier analogous to a contract's address in the EVM. Contracts cannot own UTXOs but can own assets.</p>
<!-- contract_id:example:end -->
<p>A <code>ContractId</code> is implemented as follows.</p>
<pre><code class="language-sway">pub struct ContractId {
    value: b256,
}
</code></pre>
<p>Casting between the <code>b256</code> and <code>ContractId</code> types must be done explicitly:</p>
<pre><code class="language-sway">let my_number: b256 = 0x000000000000000000000000000000000000000000000000000000000000002A;
let my_contract_id: ContractId = ContractId::from(my_number);
let forty_two: b256 = my_contract_id.into();
</code></pre>
<h3 id="getting-a-contracts-contractid"><a class="header" href="#getting-a-contracts-contractid">Getting a Contract's <code>ContractId</code></a></h3>
<p>To get the <code>ContractId</code> of a contract in an internal context use the <code>ContractId::this()</code> function:</p>
<pre><code class="language-sway">impl MyContract for Contract {
    fn foo() {
        let this_contract_id: ContractId = ContractId::this();
    }
}
</code></pre>
<h2 id="identity-type"><a class="header" href="#identity-type"><code>Identity</code> Type</a></h2>
<!-- This section should explain the `Identity` type -->
<!-- identity:example:start -->
<p>The <code>Identity</code> type is an enum that allows for the handling of both <code>Address</code> and <code>ContractId</code> types. This is useful in cases where either type is accepted, e.g., receiving funds from an identified sender, but not caring if the sender is an address or a contract.</p>
<!-- identity:example:end -->
<p>An <code>Identity</code> is implemented as follows.</p>
<pre><code class="language-sway">pub enum Identity {
    Address: Address,
    ContractId: ContractId,
}
</code></pre>
<p>Casting to an <code>Identity</code> must be done explicitly:</p>
<pre><code class="language-sway">        let raw_address: b256 = 0xddec0e7e6a9a4a4e3e57d08d080d71a299c628a46bc609aab4627695679421ca;
        let my_identity: Identity = Identity::Address(Address::from(raw_address));
</code></pre>
<p>A <code>match</code> statement can be used to return to an <code>Address</code> or <code>ContractId</code> as well as handle cases in which their execution differs.</p>
<pre><code class="language-sway">        let my_contract_id: ContractId = match my_identity {
            Identity::ContractId(identity) =&gt; identity,
            _ =&gt; revert(0),
        };
</code></pre>
<pre><code class="language-sway">        match my_identity {
            Identity::Address(address) =&gt; takes_address(address),
            Identity::ContractId(contract_id) =&gt; takes_contract_id(contract_id),
        };
</code></pre>
<!-- This section should explain the use case for the `Identity` type -->
<!-- use_identity:example:start -->
<p>A common use case for <code>Identity</code> is for access control. The use of <code>Identity</code> uniquely allows both <code>ContractId</code> and <code>Address</code> to have access control inclusively.</p>
<!-- use_identity:example:end -->
<pre><code class="language-sway">        let sender = msg_sender().unwrap();
        require(
            sender == storage
                .owner
                .read(),
            MyError::UnauthorizedUser(sender),
        );
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="converting-types"><a class="header" href="#converting-types">Converting Types</a></h1>
<p>Below are some common type conversions in Sway:</p>
<ul>
<li><a href="basics/converting_types.html#identity-conversions">Identity Conversions</a></li>
<li><a href="basics/converting_types.html#string-conversions">String Conversions</a></li>
<li><a href="basics/converting_types.html#number-conversions">Number Conversions</a></li>
<li><a href="basics/converting_types.html#byte-array-conversions">Byte Array Conversions</a></li>
</ul>
<h2 id="identity-conversions"><a class="header" href="#identity-conversions">Identity Conversions</a></h2>
<h3 id="convert-to-identity"><a class="header" href="#convert-to-identity">Convert to <code>Identity</code></a></h3>
<pre><code class="language-sway">    let identity_from_b256: Identity = Identity::Address(Address::from(b256_address));
    let identity_from_address: Identity = Identity::Address(address);
    let identity_from_contract_id: Identity = Identity::ContractId(contract_id);
</code></pre>
<h3 id="convert-identity-to-contractid-or-address"><a class="header" href="#convert-identity-to-contractid-or-address">Convert <code>Identity</code> to <code>ContractId</code> or <code>Address</code></a></h3>
<pre><code class="language-sway">    match my_identity {
        Identity::Address(address) =&gt; log(address),
        Identity::ContractId(contract_id) =&gt; log(contract_id),
    };
</code></pre>
<h3 id="convert-contractid-or-address-to-b256"><a class="header" href="#convert-contractid-or-address-to-b256">Convert <code>ContractId</code> or <code>Address</code> to <code>b256</code></a></h3>
<pre><code class="language-sway">    let b256_from_address: b256 = address.into();
    let b256_from_contract_id: b256 = contract_id.into();
</code></pre>
<h3 id="convert-b256-to-contractid-or-address"><a class="header" href="#convert-b256-to-contractid-or-address">Convert <code>b256</code> to <code>ContractId</code> or <code>Address</code></a></h3>
<pre><code class="language-sway">    let address_from_b256: Address = Address::from(b256_address);
    let contract_id_from_b256: ContractId = ContractId::from(b256_address);
</code></pre>
<h2 id="string-conversions"><a class="header" href="#string-conversions">String Conversions</a></h2>
<h3 id="convert-str-to-str"><a class="header" href="#convert-str-to-str">Convert <code>str</code> to <code>str[]</code></a></h3>
<pre><code class="language-sway">    let fuel_str: str = "fuel";
    let fuel_str_array: str[4] = fuel_str.try_as_str_array().unwrap();
</code></pre>
<h3 id="convert-str-to-str-1"><a class="header" href="#convert-str-to-str-1">Convert <code>str[]</code> to <code>str</code></a></h3>
<pre><code class="language-sway">    let fuel_str_array: str[4] = __to_str_array("fuel");
    let fuel_str: str = from_str_array(fuel_str_array);
</code></pre>
<h2 id="number-conversions"><a class="header" href="#number-conversions">Number Conversions</a></h2>
<h3 id="convert-to-u256"><a class="header" href="#convert-to-u256">Convert to <code>u256</code></a></h3>
<pre><code class="language-sway">    let u8_1: u8 = 2u8;
    let u16_1: u16 = 2u16;
    let u32_1: u32 = 2u32;
    let u64_1: u64 = 2u64;
    let b256_1: b256 = 0x0102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f20;

    let u256_from_u8: u256 = u8_1.as_u256();
    let u256_from_u16: u256 = u16_1.as_u256();
    let u256_from_u32: u256 = u32_1.as_u256();
    let u256_from_u64: u256 = u64_1.as_u256();
    let u256_from_b256: u256 = b256_1.as_u256();
</code></pre>
<h3 id="convert-to-u64"><a class="header" href="#convert-to-u64">Convert to <code>u64</code></a></h3>
<pre><code class="language-sway">    let u8_1: u8 = 2u8;
    let u16_1: u16 = 2u16;
    let u32_1: u32 = 2u32;
    let u256_1: u256 = 0x0000000000000000000000000000000000000000000000000000000000000002u256;

    let u64_from_u8: u64 = u8_1.as_u64();

    let u64_from_u16: u64 = u16_1.as_u64();

    let u64_from_u32: u64 = u32_1.as_u64();

    let u64_from_u256: Option&lt;u64&gt; = &lt;u64 as TryFrom&lt;u256&gt;&gt;::try_from(u256_1);
</code></pre>
<h3 id="convert-to-u32"><a class="header" href="#convert-to-u32">Convert to <code>u32</code></a></h3>
<pre><code class="language-sway">    let u8_1: u8 = 2u8;
    let u16_1: u16 = 2u16;
    let u64_1: u64 = 2;
    let u256_1: u256 = 0x0000000000000000000000000000000000000000000000000000000000000002u256;

    let u32_from_u8: u32 = u8_1.as_u32();

    let u32_from_u16: u32 = u16_1.as_u32();

    let u32_from_u64_1: Option&lt;u32&gt; = u64_1.try_as_u32();
    let u32_from_u64_2: Option&lt;u32&gt; = &lt;u32 as TryFrom&lt;u64&gt;&gt;::try_from(u64_1);

    let u32_from_u256: Option&lt;u32&gt; = &lt;u32 as TryFrom&lt;u256&gt;&gt;::try_from(u256_1);
</code></pre>
<h3 id="convert-to-u16"><a class="header" href="#convert-to-u16">Convert to <code>u16</code></a></h3>
<pre><code class="language-sway">    let u8_1: u8 = 2u8;
    let u32_1: u32 = 2u32;
    let u64_1: u64 = 2;
    let u256_1: u256 = 0x0000000000000000000000000000000000000000000000000000000000000002u256;

    let u16_from_u8: u16 = u8_1.as_u16();

    let u16_from_u32_1: Option&lt;u16&gt; = u32_1.try_as_u16();
    let u16_from_u32_2: Option&lt;u16&gt; = &lt;u16 as TryFrom&lt;u32&gt;&gt;::try_from(u32_1);

    let u16_from_u64_1: Option&lt;u16&gt; = u64_1.try_as_u16();
    let u16_from_u64_2: Option&lt;u16&gt; = &lt;u16 as TryFrom&lt;u64&gt;&gt;::try_from(u64_1);

    let u16_from_u256: Option&lt;u16&gt; = &lt;u16 as TryFrom&lt;u256&gt;&gt;::try_from(u256_1);
</code></pre>
<h3 id="convert-to-u8"><a class="header" href="#convert-to-u8">Convert to <code>u8</code></a></h3>
<pre><code class="language-sway">    let u16_1: u16 = 2u16;
    let u32_1: u32 = 2u32;
    let u64_1: u64 = 2;
    let u256_1: u256 = 0x0000000000000000000000000000000000000000000000000000000000000002u256;

    let u8_from_u16_1: Option&lt;u8&gt; = u16_1.try_as_u8();
    let u8_from_u16_2: Option&lt;u8&gt; = &lt;u8 as TryFrom&lt;u16&gt;&gt;::try_from(u16_1);

    let u8_from_u32_1: Option&lt;u8&gt; = u32_1.try_as_u8();
    let u8_from_u32_2: Option&lt;u8&gt; = &lt;u8 as TryFrom&lt;u32&gt;&gt;::try_from(u32_1);

    let u8_from_u64_1: Option&lt;u8&gt; = u64_1.try_as_u8();
    let u8_from_u64_2: Option&lt;u8&gt; = &lt;u8 as TryFrom&lt;u64&gt;&gt;::try_from(u64_1);

    let u8_from_u256: Option&lt;u8&gt; = &lt;u8 as TryFrom&lt;u256&gt;&gt;::try_from(u256_1);
</code></pre>
<h3 id="convert-to-bytes"><a class="header" href="#convert-to-bytes">Convert to <code>Bytes</code></a></h3>
<pre><code class="language-sway">use std::{bytes::Bytes, bytes_conversions::{b256::*, u16::*, u256::*, u32::*, u64::*}};
</code></pre>
<pre><code class="language-sway">    let num = 5;
    let little_endian_bytes: Bytes = num.to_le_bytes();
    let big_endian_bytes: Bytes = num.to_be_bytes();
</code></pre>
<h3 id="convert-from-bytes"><a class="header" href="#convert-from-bytes">Convert from <code>Bytes</code></a></h3>
<pre><code class="language-sway">use std::{bytes::Bytes, bytes_conversions::{b256::*, u16::*, u256::*, u32::*, u64::*}};
</code></pre>
<pre><code class="language-sway">    let u16_from_le_bytes: u16 = u16::from_le_bytes(little_endian_bytes);
    let u16_from_be_bytes: u16 = u16::from_be_bytes(big_endian_bytes);

    let u32_from_le_bytes: u32 = u32::from_le_bytes(little_endian_bytes);
    let u32_from_be_bytes: u32 = u32::from_be_bytes(big_endian_bytes);

    let u64_from_le_bytes: u64 = u64::from_le_bytes(little_endian_bytes);
    let u64_from_be_bytes: u64 = u64::from_be_bytes(big_endian_bytes);

    let u256_from_le_bytes = u256::from_le_bytes(little_endian_bytes);
    let u256_from_be_bytes = u256::from_be_bytes(big_endian_bytes);

    let b256_from_le_bytes = b256::from_le_bytes(little_endian_bytes);
    let b256_from_be_bytes = b256::from_be_bytes(big_endian_bytes);
</code></pre>
<h2 id="byte-array-conversions"><a class="header" href="#byte-array-conversions">Byte Array Conversions</a></h2>
<h3 id="convert-to-a-byte-array"><a class="header" href="#convert-to-a-byte-array">Convert to a Byte Array</a></h3>
<pre><code class="language-sway">use std::array_conversions::{b256::*, u16::*, u256::*, u32::*, u64::*};
</code></pre>
<pre><code class="language-sway">    let u16_1: u16 = 2u16;
    let u32_1: u32 = 2u32;
    let u64_1: u64 = 2u64;
    let u256_1: u256 = 0x0000000000000000000000000000000000000000000000000000000000000002u256;
    let b256_1: b256 = 0x000000000000000000000000000000000000000000000000000000000000002A;
    // little endian
    let le_byte_array_from_u16: [u8; 2] = u16_1.to_le_bytes();
    let le_byte_array_from_u32: [u8; 4] = u32_1.to_le_bytes();
    let le_byte_array_from_u64: [u8; 8] = u64_1.to_le_bytes();
    let le_byte_array_from_u256: [u8; 32] = u256_1.to_le_bytes();
    let le_byte_array_from_b256: [u8; 32] = b256_1.to_le_bytes();
    // big endian
    let be_byte_array_from_u16: [u8; 2] = u16_1.to_be_bytes();
    let be_byte_array_from_u32: [u8; 4] = u32_1.to_be_bytes();
    let be_byte_array_from_u64: [u8; 8] = u64_1.to_be_bytes();
    let be_byte_array_from_u256: [u8; 32] = u256_1.to_be_bytes();
    let be_byte_array_from_b256: [u8; 32] = b256_1.to_be_bytes();
</code></pre>
<h3 id="convert-from-a-byte-array"><a class="header" href="#convert-from-a-byte-array">Convert from a Byte Array</a></h3>
<pre><code class="language-sway">use std::array_conversions::{b256::*, u16::*, u256::*, u32::*, u64::*};
</code></pre>
<pre><code class="language-sway">    let u16_byte_array: [u8; 2] = [2_u8, 1_u8];
    let u32_byte_array: [u8; 4] = [4_u8, 3_u8, 2_u8, 1_u8];
    let u64_byte_array: [u8; 8] = [8_u8, 7_u8, 6_u8, 5_u8, 4_u8, 3_u8, 2_u8, 1_u8];
    let u256_byte_array: [u8; 32] = [
        32_u8, 31_u8, 30_u8, 29_u8, 28_u8, 27_u8, 26_u8, 25_u8, 24_u8, 23_u8, 22_u8,
        21_u8, 20_u8, 19_u8, 18_u8, 17_u8, 16_u8, 15_u8, 14_u8, 13_u8, 12_u8, 11_u8,
        10_u8, 9_u8, 8_u8, 7_u8, 6_u8, 5_u8, 4_u8, 3_u8, 2_u8, 1_u8,
    ];
    // little endian
    let le_u16_from_byte_array: u16 = u16::from_le_bytes(u16_byte_array);
    let le_u32_from_byte_array: u32 = u32::from_le_bytes(u32_byte_array);
    let le_u64_from_byte_array: u64 = u64::from_le_bytes(u64_byte_array);
    let le_u256_from_byte_array: u256 = u256::from_le_bytes(u256_byte_array);
    let le_b256_from_byte_array: b256 = b256::from_le_bytes(u256_byte_array);
    // big endian
    let be_u16_from_byte_array: u16 = u16::from_be_bytes(u16_byte_array);
    let be_u32_from_byte_array: u32 = u32::from_be_bytes(u32_byte_array);
    let be_u64_from_byte_array: u64 = u64::from_be_bytes(u64_byte_array);
    let be_u256_from_byte_array: u256 = u256::from_be_bytes(u256_byte_array);
    let be_b256_from_byte_array: b256 = b256::from_be_bytes(u256_byte_array);
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="functions"><a class="header" href="#functions">Functions</a></h1>
<p>Functions in Sway are declared with the <code>fn</code> keyword. Let's take a look:</p>
<pre><code class="language-sway">fn equals(first_param: u64, second_param: u64) -&gt; bool {
    first_param == second_param
}
</code></pre>
<p>We have just declared a function named <code>equals</code> which takes two parameters: <code>first_param</code> and <code>second_param</code>. The parameters must both be 64-bit unsigned integers.</p>
<p>This function also returns a <code>bool</code> value, i.e. either <code>true</code> or <code>false</code>. This function returns <code>true</code> if the two given parameters are equal, and <code>false</code> if they are not. If we want to use this function, we can do so like this:</p>
<pre><code class="language-sway">fn main() {
    equals(5, 5); // evaluates to `true`
    equals(5, 6); // evaluates to `false`
}
</code></pre>
<h2 id="mutable-parameters"><a class="header" href="#mutable-parameters">Mutable Parameters</a></h2>
<!-- This section should explain how/when to use `ref mut` -->
<!-- ref_mut:example:start -->
<p>We can make a function parameter mutable by adding <code>ref mut</code> before the parameter name. This allows mutating the argument passed into the function when the function is called.</p>
<!-- ref_mut:example:end -->
<p>For example:</p>
<pre><code class="language-sway">fn increment(ref mut num: u32) {
    let prev = num;
    num = prev + 1u32;
}
</code></pre>
<p>This function is allowed to mutate its parameter <code>num</code> because of the <code>mut</code> keyword. In addition, the <code>ref</code> keyword instructs the function to modify the argument passed to it when the function is called, instead of modifying a local copy of it.</p>
<pre><code class="language-sway">    let mut num: u32 = 0;
    increment(num);
    assert(num == 1u32); // The function `increment()` modifies `num`
</code></pre>
<p>Note that the variable <code>num</code> itself has to be declared as mutable for the above to compile.</p>
<blockquote>
<p><strong>Note</strong>
It is not currently allowed to use <code>mut</code> without <code>ref</code> or vice versa for a function parameter.</p>
</blockquote>
<p>Similarly, <code>ref mut</code> can be used with more complex data types such as:</p>
<pre><code class="language-sway">fn swap_tuple(ref mut pair: (u64, u64)) {
    let temp = pair.0;
    pair.0 = pair.1;
    pair.1 = temp;
}

fn update_color(ref mut color: Color, new_color: Color) {
    color = new_color;
}
</code></pre>
<p>We can then call these functions as shown below:</p>
<pre><code class="language-sway">    let mut tuple = (42, 24);
    swap_tuple(tuple);
    assert(tuple.0 == 24); // The function `swap_tuple()` modifies `tuple.0`
    assert(tuple.1 == 42); // The function `swap_tuple()` modifies `tuple.1`
    let mut color = Color::Red;
    update_color(color, Color::Blue);
    assert(match color {
        Color::Blue =&gt; true,
        _ =&gt; false,
    }); // The function `update_color()` modifies the color to Blue
</code></pre>
<blockquote>
<p><strong>Note</strong>
The only place, in a Sway program, where the <code>ref</code> keyword is valid is before a mutable function parameter.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="structs-tuples-and-enums"><a class="header" href="#structs-tuples-and-enums">Structs, Tuples, and Enums</a></h1>
<h2 id="structs"><a class="header" href="#structs">Structs</a></h2>
<!-- This section should explain structs in Sway -->
<!-- structs:example:start -->
<p>Structs in Sway are a named grouping of types. You may also be familiar with structs via another name: <em>product types</em>. Sway does not make any significantly unique usages of structs; they are similar to most other languages which have structs. If you're coming from an object-oriented background, a struct is like the data attributes of an object.</p>
<p>Those data attributes are called <em>fields</em> and can be either public or private.</p>
<p>Private struct fields can be accessed only within the module in which their struct is declared. Public fields are accessible everywhere where the struct is accessible. This access control on the field level allows more fine grained encapsulation of data.</p>
<!-- structs:example:end -->
<p>To explain these concepts, let's take a look at the following example, in which we have a module called <em>data_structures</em>.</p>
<p>In that module, we declare a struct named <code>Foo</code> with two fields. The first field is named <code>bar</code>, it is public and it accepts values of type <code>u64</code>. The second field is named <code>baz</code>, it is also public and it accepts <code>bool</code> values.</p>
<p>In a similar way, we define the structs <code>Point</code>, <code>Line</code>, and <code>TupleInStruct</code>. Since all those structs are public, and all their fields are public, they can be instantiated in other modules using the <em>struct instantiation syntax</em> as shown below.</p>
<p>On the other hand, the struct <code>StructWithPrivateFields</code> can be instantiated only within the <em>data_structures</em> module, because it contains private fields. To be able to create instances of such structs outside of the module in which they are declared, the struct must offer <a href="basics/methods_and_associated_functions.html#constructors">constructor associated functions</a>.</p>
<pre><code class="language-sway">// the _data_structures_ module
library;

// Declare a struct type
pub struct Foo {
    pub bar: u64,
    pub baz: bool,
}

// Struct types for destructuring
pub struct Point {
    pub x: u64,
    pub y: u64,
}

pub struct Line {
    pub p1: Point,
    pub p2: Point,
}

pub struct TupleInStruct {
    pub nested_tuple: (u64, (u32, (bool, str))),
}

// Struct type instantiable only in the module _data_structures_
pub struct StructWithPrivateFields {
    pub public_field: u64,
    private_field: u64,
    other_private_field: u64,
}
</code></pre>
<!-- This section should explain how to instantiate a struct in Sway -->
<!-- new_struct:example:start -->
<p>In order to instantiate the struct we use <em>struct instantiation syntax</em>, which is very similar to the declaration syntax except with expressions in place of types.</p>
<p>There are three ways to instantiate the struct.</p>
<ul>
<li>Hard coding values for the fields</li>
<li>Passing in variables with names different than the struct fields</li>
<li>Using a shorthand notation via variables that are the same as the field names</li>
</ul>
<!-- new_struct:example:end -->
<pre><code class="language-sway">library;

mod data_structures;
use data_structures::{Foo, Line, Point, TupleInStruct};

fn hardcoded_instantiation() -&gt; Foo {
    // Instantiate `foo` as `Foo`
    let mut foo = Foo {
        bar: 42,
        baz: false,
    };

    // Access and write to "baz"
    foo.baz = true;

    // Return the struct
    foo
}

fn variable_instantiation() -&gt; Foo {
    // Declare variables with the same names as the fields in `Foo`
    let number = 42;
    let truthness = false;

    // Instantiate `foo` as `Foo`
    let mut foo = Foo {
        bar: number,
        baz: truthness,
    };

    // Access and write to "baz"
    foo.baz = true;

    // Return the struct
    foo
}

fn shorthand_instantiation() -&gt; Foo {
    // Declare variables with the same names as the fields in `Foo`
    let bar = 42;
    let baz = false;

    // Instantiate `foo` as `Foo`
    let mut foo = Foo { bar, baz };

    // Access and write to "baz"
    foo.baz = true;

    // Return the struct
    foo
}

fn struct_destructuring() {
    let point1 = Point { x: 0, y: 0 };
    // Destructure the values from the struct into variables
    let Point { x, y } = point1;

    let point2 = Point { x: 1, y: 1 };
    // If you do not care about specific struct fields then use ".." at the end of your variable list
    let Point { x, .. } = point2;

    let line = Line {
        p1: point1,
        p2: point2,
    };
    // Destructure the values from the nested structs into variables
    let Line {
        p1: Point { x: x0, y: y0 },
        p2: Point { x: x1, y: y1 },
    } = line;
    // You may also destructure tuples nested in structs and structs nested in tuples
    let tuple_in_struct = TupleInStruct {
        nested_tuple: (42u64, (42u32, (true, "ok"))),
    };
    let TupleInStruct {
        nested_tuple: (a, (b, (c, d))),
    } = tuple_in_struct;

    let struct_in_tuple = (Point { x: 2, y: 4 }, Point { x: 3, y: 6 });
    let (Point { x: x0, y: y0 }, Point { x: x1, y: y1 }) = struct_in_tuple;
}
</code></pre>
<blockquote>
<p><strong>Note</strong>
You can mix and match all 3 ways to instantiate the struct at the same time.
Moreover, the order of the fields does not matter when instantiating however we encourage declaring the fields in alphabetical order and instantiating them in the same alphabetical order</p>
</blockquote>
<p>Furthermore, multiple variables can be extracted from a struct using the destructuring syntax.</p>
<h3 id="struct-memory-layout"><a class="header" href="#struct-memory-layout">Struct Memory Layout</a></h3>
<blockquote>
<p><strong>Note</strong>
This information is not vital if you are new to the language, or programming in general</p>
</blockquote>
<p>Structs have zero memory overhead. What that means is that in memory, each struct field is laid out sequentially. No metadata regarding the struct's name or other properties is preserved at runtime. In other words, structs are compile-time constructs. This is the same in Rust, but different in other languages with runtimes like Java.</p>
<h2 id="tuples"><a class="header" href="#tuples">Tuples</a></h2>
<!-- This section should explain what tuples are and how to access tuple values -->
<!-- tuples:example:start -->
<p>Tuples are a <a href="basics/./built_in_types.html#tuple-types">basic static-length type</a> which contain multiple different types within themselves. The type of a tuple is defined by the types of the values within it, and a tuple can contain basic types as well as structs and enums.</p>
<p>You can access values directly by using the <code>.</code> syntax. Moreover, multiple variables can be extracted from a tuple using the destructuring syntax.</p>
<!-- tuples:example:end -->
<pre><code class="language-sway">library;

fn tuple() {
    // You can declare the types yourself
    let tuple1: (u8, bool, u64) = (100, false, 10000);

    // Or have the types be inferred
    let mut tuple2 = (5, true, ("Sway", 8));

    // Retrieve values from tuples
    let number = tuple1.0;
    let sway = tuple2.2.1;

    // Destructure the values from the tuple into variables
    let (n1, truthness, n2) = tuple1;

    // If you do not care about specific values then use "_"
    let (_, truthness, _) = tuple2;

    // Internally mutate the tuple
    tuple2.1 = false;

    // Or change the values all at once (must keep the same data types)
    tuple2 = (9, false, ("Fuel", 99));
}
</code></pre>
<h2 id="enums"><a class="header" href="#enums">Enums</a></h2>
<!-- This section should explain what enums are -->
<!-- enums:example:start -->
<p><em>Enumerations</em>, or <em>enums</em>, are also known as <em>sum types</em>. An enum is a type that could be one of several variants. To declare an enum, you enumerate all potential variants.</p>
<!-- enums:example:end -->
<p>Here, we have defined five potential colors. Each enum variant is just the color name. As there is no extra data associated with each variant, we say that each variant is of type <code>()</code>, or unit.</p>
<pre><code class="language-sway">library;

// Declare the enum
enum Color {
    Blue: (),
    Green: (),
    Red: (),
    Silver: (),
    Grey: (),
}

fn main() {
    // To instantiate a variable with the value of an enum the syntax is
    let blue = Color::Blue;
    let silver = Color::Silver;
}
</code></pre>
<h3 id="enums-of-structs"><a class="header" href="#enums-of-structs">Enums of Structs</a></h3>
<p>It is also possible to have an enum variant contain extra data. Take a look at this more substantial example, which combines struct declarations with enum variants:</p>
<pre><code class="language-sway">library;

struct Item {
    price: u64,
    amount: u64,
    id: u64,
}

enum MyEnum {
    Item: Item,
}

fn main() {
    let my_enum = MyEnum::Item(Item {
        price: 5,
        amount: 2,
        id: 42,
    });
}
</code></pre>
<h3 id="enums-of-enums"><a class="header" href="#enums-of-enums">Enums of Enums</a></h3>
<p>It is possible to define enums of enums:</p>
<pre><code class="language-sway">library;

pub enum Error {
    StateError: StateError,
    UserError: UserError,
}

pub enum StateError {
    Void: (),
    Pending: (),
    Completed: (),
}

pub enum UserError {
    InsufficientPermissions: (),
    Unauthorized: (),
}
</code></pre>
<h4 id="preferred-usage"><a class="header" href="#preferred-usage">Preferred usage</a></h4>
<p>The preferred way to use enums is to use the individual (not nested) enums directly because they are easy to follow and the lines are short:</p>
<pre><code class="language-sway">library;

use ::enum_of_enums::{StateError, UserError};

fn preferred() {
    let error1 = StateError::Void;
    let error2 = UserError::Unauthorized;
}
</code></pre>
<h4 id="inadvisable"><a class="header" href="#inadvisable">Inadvisable</a></h4>
<p>If you wish to use the nested form of enums via the <code>Error</code> enum from the example above, then you can instantiate them into variables using the following syntax:</p>
<pre><code class="language-sway">library;

use ::enum_of_enums::{Error, StateError, UserError};

fn avoid() {
    let error1 = Error::StateError(StateError::Void);
    let error2 = Error::UserError(UserError::Unauthorized);
}
</code></pre>
<p>Key points to note:</p>
<ul>
<li>You must import all of the enums you need instead of just the <code>Error</code> enum</li>
<li>The lines may get unnecessarily long (depending on the names)</li>
<li>The syntax is not the most ergonomic</li>
</ul>
<h3 id="enum-memory-layout"><a class="header" href="#enum-memory-layout">Enum Memory Layout</a></h3>
<blockquote>
<p><strong>Note</strong>
This information is not vital if you are new to the language, or programming in general.</p>
</blockquote>
<p>Enums do have some memory overhead. To know which variant is being represented, Sway stores a one-word (8-byte) tag for the enum variant. The space reserved after the tag is equivalent to the size of the <em>largest</em> enum variant. So, to calculate the size of an enum in memory, add 8 bytes to the size of the largest variant. For example, in the case of <code>Color</code> above, where the variants are all <code>()</code>, the size would be 8 bytes since the size of the largest variant is 0 bytes.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="methods-and-associated-functions"><a class="header" href="#methods-and-associated-functions">Methods and Associated Functions</a></h1>
<!-- This section should explain methods & associated functions in Sway -->
<!-- methods_af:example:start -->
<h2 id="methods"><a class="header" href="#methods">Methods</a></h2>
<p>Methods are similar to <a href="basics/functions.html">functions</a> in that we declare them with the <code>fn</code> keyword and they have parameters and return a value. However, unlike functions, <em>Methods</em> are defined within the context of a struct (or enum), and either refers to that type or mutates it. The first parameter of a method is always <code>self</code>, which represents the instance of the struct (or enum) the method is being called on.</p>
<h2 id="associated-functions"><a class="header" href="#associated-functions">Associated Functions</a></h2>
<p><em>Associated functions</em> are very similar to <em>methods</em>, in that they are also defined in the context of a struct or enum, but they do not actually use any of the data in the struct and as a result do not take <em>self</em> as a parameter. Associated functions could be standalone functions, but they are included in a specific type for organizational or semantic reasons.</p>
<h3 id="constructors"><a class="header" href="#constructors">Constructors</a></h3>
<p>Constructors are associated functions that construct, or in other words instantiate, new instances of a type. Their return type is always the type itself. E.g., public structs that have private fields must provide a public constructor, or otherwise they cannot be instantiated outside of the module in which they are declared.</p>
<h2 id="declaring-methods-and-associated-functions"><a class="header" href="#declaring-methods-and-associated-functions">Declaring Methods and Associated Functions</a></h2>
<p>To declare methods and associated functions for a struct or enum, use an <code>impl</code> block. Here, <code>impl</code> is short for implementation.</p>
<!-- methods_af:example:end -->
<pre><code class="language-sway">script;

struct Foo {
    bar: u64,
    baz: bool,
}

impl Foo {
    // this is a _method_, as it takes `self` as a parameter.
    fn is_baz_true(self) -&gt; bool {
        self.baz
    }

    // this is an _associated function_, since it does not take `self` as a parameter.
    // it is at the same time a _constructor_ because it instantiates and returns
    // a new instance of `Foo`.
    fn new_foo(number: u64, boolean: bool) -&gt; Foo {
        Foo {
            bar: number,
            baz: boolean,
        }
    }
}

fn main() {
    let foo = Foo::new_foo(42, true);
    assert(foo.is_baz_true());
}
</code></pre>
<!-- This section should explain how to call a method -->
<!-- call_method:example:start -->
<p>To call a method, simply use dot syntax: <code>foo.iz_baz_true()</code>.</p>
<!-- call_method:example:end -->
<!-- This section should explain how methods + assoc. fns can accept `ref mut` params -->
<!-- ref_mut:example:start -->
<p>Similarly to <a href="basics/functions.html">free functions</a>, methods and associated functions may accept <code>ref mut</code> parameters.</p>
<!-- ref_mut:example:end -->
<p>For example:</p>
<pre><code class="language-sway">struct Coordinates {
    x: u64,
    y: u64,
}

impl Coordinates {
    fn move_right(ref mut self, distance: u64) {
        self.x += distance;
    }
}
</code></pre>
<p>and when called:</p>
<pre><code class="language-sway">    let mut point = Coordinates { x: 1, y: 1 };
    point.move_right(5);
    assert(point.x == 6);
    assert(point.y == 1);
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="constants"><a class="header" href="#constants">Constants</a></h1>
<!-- This section should explain what constants are in Sway -->
<!-- constants:example:start -->
<p>Constants are similar to variables; however, there are a few differences:</p>
<ul>
<li>Constants are always evaluated at compile-time.</li>
<li>Constants can be declared both inside of a <a href="basics/../index.html">function</a> and at global / <code>impl</code> scope.</li>
<li>The <code>mut</code> keyword cannot be used with constants.</li>
</ul>
<!-- constants:example:end -->
<pre><code class="language-sway">const ID: u32 = 0;
</code></pre>
<p>Constant initializer expressions can be quite complex, but they cannot use, for
instance, assembly instructions, storage access, mutable variables, loops and
<code>return</code> statements. Although, function calls, primitive types and compound data
structures are perfectly fine to use:</p>
<pre><code class="language-sway">fn bool_to_num(b: bool) -&gt; u64 {
    if b {
        1
    } else {
        0
    }
}

fn arr_wrapper(a: u64, b: u64, c: u64) -&gt; [u64; 3] {
    [a, b, c]
}

const ARR2 = arr_wrapper(bool_to_num(1) + 42, 2, 3);
</code></pre>
<h2 id="associated-constants"><a class="header" href="#associated-constants">Associated Constants</a></h2>
<!-- This section should explain what associated constants are -->
<!-- assoc_constants:example:start -->
<p>Associated constants are constants associated with a type and can be declared in an <code>impl</code> block or in a <code>trait</code> definition.</p>
<p>Associated constants declared inside a <code>trait</code> definition may omit their initializers to indicate that each implementation of the trait must specify those initializers.</p>
<p>The identifier is the name of the constant used in the path. The type is the type that the
definition has to implement.</p>
<!-- assoc_constants:example:end -->
<p>You can <em>define</em> an associated <code>const</code> directly in the interface surface of a trait:</p>
<pre><code class="language-sway">script;

trait ConstantId {
    const ID: u32 = 0;
}
</code></pre>
<p>Alternatively, you can also <em>declare</em> it in the trait, and implement it in the interface of the
types implementing the trait.</p>
<pre><code class="language-sway">script;

trait ConstantId {
    const ID: u32;
}

struct Struct {}

impl ConstantId for Struct {
    const ID: u32 = 1;
}

fn main() -&gt; u32 {
    Struct::ID
}
</code></pre>
<h3 id="impl-self-constants"><a class="header" href="#impl-self-constants"><code>impl self</code> Constants</a></h3>
<p>Constants can also be declared inside non-trait <code>impl</code> blocks.</p>
<pre><code class="language-sway">script;

struct Point {
    x: u64,
    y: u64,
}

impl Point {
    const ZERO: Point = Point { x: 0, y: 0 };
}

fn main() -&gt; u64  {
    Point::ZERO.x
}
</code></pre>
<h2 id="configurable-constants"><a class="header" href="#configurable-constants">Configurable Constants</a></h2>
<!-- This section should explain what configurable constants are in Sway -->
<!-- config_constants:example:start -->
<p>Configurable constants are special constants that behave like regular constants in the sense that they cannot change during program execution, but they can be configured <em>after</em> the Sway program has been built. The Rust and TS SDKs allow updating the values of these constants by injecting new values for them directly in the bytecode without having to build the program again. These are useful for contract factories and behave somewhat similarly to <code>immutable</code> variables from languages like Solidity.</p>
<!-- config_constants:example:end -->
<p>Configurable constants are declared inside a <code>configurable</code> block and require a type ascription and an initializer as follows:</p>
<pre><code class="language-sway">configurable {
    U8: u8 = 8u8,
    BOOL: bool = true,
    ARRAY: [u32; 3] = [253u32, 254u32, 255u32],
    STR_4: str[4] = __to_str_array("fuel"),
    STRUCT: StructWithGeneric&lt;u8&gt; = StructWithGeneric {
        field_1: 8u8,
        field_2: 16,
    },
    ENUM: EnumWithGeneric&lt;bool&gt; = EnumWithGeneric::VariantOne(true),
}
</code></pre>
<p>At most one <code>configurable</code> block is allowed in a Sway project. Moreover, <code>configurable</code> blocks are not allowed in libraries.</p>
<p>Configurable constants can be read directly just like regular constants:</p>
<pre><code class="language-sway">    fn return_configurables() -&gt; (u8, bool, [u32; 3], str[4], StructWithGeneric&lt;u8&gt;) {
        (U8, BOOL, ARRAY, STR_4, STRUCT)
    }
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="comments-and-logging"><a class="header" href="#comments-and-logging">Comments and Logging</a></h1>
<h2 id="comments"><a class="header" href="#comments">Comments</a></h2>
<!-- This section should explain how to add comments in Sway -->
<!-- comments:example:start -->
<p>Comments in Sway start with two slashes and continue until the end of the line. For comments that extend beyond a single line, you'll need to include <code>//</code> on each line.</p>
<!-- comments:example:end -->
<pre><code class="language-sway">// hello world
</code></pre>
<pre><code class="language-sway">// let's make a couple of lines
// commented.
</code></pre>
<p>You can also place comments at the ends of lines containing code.</p>
<pre><code class="language-sway">fn main() {
    let baz = 8; // Eight is a lucky number
}
</code></pre>
<p>You can also do block comments</p>
<pre><code class="language-sway">fn main() {
    /*
    You can write on multiple lines
    like this if you want
    */
    let baz = 8;
}
</code></pre>
<h2 id="logging"><a class="header" href="#logging">Logging</a></h2>
<!-- This section should explain logging in Sway -->
<!-- logging:example:start -->
<p>The <code>logging</code> library provides a generic <code>log</code> function that can be imported using <code>use std::logging::log</code> and used to log variables of any type. Each call to <code>log</code> appends a <code>receipt</code> to the list of receipts. There are two types of receipts that a <code>log</code> can generate: <code>Log</code> and <code>LogData</code>.</p>
<!-- logging:example:end -->
<pre><code class="language-sway">fn log_values(){
  // Generates a Log receipt
  log(42);

  // Generates a LogData receipt
  let string = "sway";
  log(string);
}
</code></pre>
<h3 id="log-receipt"><a class="header" href="#log-receipt"><code>Log</code> Receipt</a></h3>
<!-- This section should explain when `Log` receipts are produced -->
<!-- log_rec:example:start -->
<p>The <code>Log</code> receipt is generated for <em>non-reference</em> types, namely <code>bool</code>, <code>u8</code>, <code>u16</code>, <code>u32</code>, and <code>u64</code>.</p>
<!-- log_rec:example:end -->
<p>For example, logging an integer variable <code>x</code> that holds the value <code>42</code> using <code>log(x)</code> may generate the following receipt:</p>
<pre><code class="language-console">"Log": {
  "id": "0000000000000000000000000000000000000000000000000000000000000000",
  "is": 10352,
  "pc": 10404,
  "ra": 42,
  "rb": 1018205,
  "rc": 0,
  "rd": 0
}
</code></pre>
<p>Note that <code>ra</code> will include the value being logged. The additional registers <code>rc</code> and <code>rd</code> will be zero when using <code>log</code> while <code>rb</code> may include a non-zero value representing a unique ID for the <code>log</code> instance. The unique ID is not meaningful on its own but allows the Rust and the TS SDKs to know the type of the data being logged, by looking up the log ID in the JSON ABI file.</p>
<h3 id="logdata-receipt"><a class="header" href="#logdata-receipt"><code>LogData</code> Receipt</a></h3>
<!-- This section should explain when `LogData` receipts are produced -->
<!-- log_data_rec:example:start -->
<p><code>LogData</code> is generated for <em>reference</em> types which include all types except for <em>non_reference</em> types; and for  <em>non-reference</em> types bigger than 64-bit integers, for example, <code>u256</code>;</p>
<!-- log_data_rec:example:end -->
<p>For example, logging a <code>b256</code> variable <code>b</code> that holds the value <code>0x1111111111111111111111111111111111111111111111111111111111111111</code> using <code>log(b)</code> may generate the following receipt:</p>
<pre><code class="language-console">"LogData": {
  "data": "1111111111111111111111111111111111111111111111111111111111111111",
  "digest": "02d449a31fbb267c8f352e9968a79e3e5fc95c1bbeaa502fd6454ebde5a4bedc",
  "id": "0000000000000000000000000000000000000000000000000000000000000000",
  "is": 10352,
  "len": 32,
  "pc": 10444,
  "ptr": 10468,
  "ra": 0,
  "rb": 1018194
}
</code></pre>
<p>Note that <code>data</code> in the receipt above will include the value being logged as a hexadecimal. Similarly to the <code>Log</code> receipt, additional registers are written: <code>ra</code> will always be zero when using <code>log</code>, while <code>rb</code> will contain a unique ID for the <code>log</code> instance.</p>
<blockquote>
<p><strong>Note</strong>
The Rust SDK exposes <a href="https://fuellabs.github.io/fuels-rs/master/calling-contracts/logs.html#logs">APIs</a> that allow you to retrieve the logged values and display them nicely based on their types as indicated in the JSON ABI file.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="control-flow"><a class="header" href="#control-flow">Control Flow</a></h1>
<h2 id="if-expressions"><a class="header" href="#if-expressions"><code>if</code> expressions</a></h2>
<!-- This section should explain `if` expressions in Sway -->
<!-- if:example:start -->
<p>Sway supports <em>if</em>, <em>else</em>, and <em>else if</em> expressions that allow you to branch your code depending on conditions.</p>
<!-- if:example:end -->
<p>For example:</p>
<pre><code class="language-sway">fn main() {
    let number = 6;

    if number % 4 == 0 {
        // do something
    } else if number % 3 == 0 {
        // do something else
    } else {
        // do something else
    }
}
</code></pre>
<h3 id="using-if-in-a-let-statement"><a class="header" href="#using-if-in-a-let-statement">Using <code>if</code> in a <code>let</code> statement</a></h3>
<p>Like Rust, <code>if</code>s are expressions in Sway. What this means is you can use <code>if</code> expressions on the right side of a <code>let</code> statement to assign the outcome to a variable.</p>
<pre><code class="language-sway">let my_data = if some_bool &lt; 10 { foo() } else { bar() };
</code></pre>
<p>Note that all branches of the <code>if</code> expression must return a value of the same type.</p>
<h3 id="match-expressions"><a class="header" href="#match-expressions"><code>match</code> expressions</a></h3>
<!-- This section should explain `match` expressions in Sway -->
<!-- match:example:start -->
<p>Sway supports advanced pattern matching through exhaustive <code>match</code> expressions. Unlike an <code>if</code> expression, a <code>match</code> expression asserts <strong>at compile time</strong> that all possible patterns have been matched. If you don't handle all the patterns, you will get compiler error indicating that your <code>match</code> expression is non-exhaustive.</p>
<!-- match:example:end -->
<p>The basic syntax of a <code>match</code> expression is as follows:</p>
<pre><code class="language-sway">let result = match expression {
    pattern1 =&gt; code_to_execute_if_expression_matches_pattern1,
    pattern2 =&gt; code_to_execute_if_expression_matches_pattern2,
    pattern3 | pattern4 =&gt; code_to_execute_if_expression_matches_pattern3_or_pattern4
    ...
    _ =&gt; code_to_execute_if_expression_matches_no_pattern,
}
</code></pre>
<p>Some examples of how you can use a <code>match</code> expression:</p>
<pre><code class="language-sway">script;

// helper functions for our example
fn on_even(num: u64) {
    // do something with even numbers
}
fn on_odd(num: u64) {
    // do something with odd numbers
}

fn main(num: u64) -&gt; u64 {
    // Match as an expression
    let is_even = match num % 2 {
        0 =&gt; true,
        _ =&gt; false,
    };

    // Match as control flow
    let x = 12;
    match x {
        5 =&gt; on_odd(x),
        _ =&gt; on_even(x),
    };

    // Match an enum
    enum Weather {
        Sunny: (),
        Rainy: (),
        Cloudy: (),
        Snowy: (),
    }
    let current_weather = Weather::Sunny;
    let avg_temp = match current_weather {
        Weather::Sunny =&gt; 80,
        Weather::Rainy =&gt; 50,
        Weather::Cloudy =&gt; 60,
        Weather::Snowy =&gt; 20,
    };

    let is_sunny = match current_weather {
        Weather::Sunny =&gt; true,
        Weather::Rainy | Weather::Cloudy | Weather::Snowy =&gt; false,
    };

    // match expression used for a return
    let outside_temp = Weather::Sunny;
    match outside_temp {
        Weather::Sunny =&gt; 80,
        Weather::Rainy =&gt; 50,
        Weather::Cloudy =&gt; 60,
        Weather::Snowy =&gt; 20,
    }
}
</code></pre>
<h2 id="loops"><a class="header" href="#loops">Loops</a></h2>
<h3 id="while"><a class="header" href="#while"><code>while</code></a></h3>
<p>This is what a <code>while</code> loop looks like:</p>
<pre><code class="language-sway">while counter &lt; 10 {
    counter = counter + 1;
}
</code></pre>
<p>You need the <code>while</code> keyword, some condition (<code>value &lt; 10</code> in this case) which will be evaluated each iteration, and a block of code inside the curly braces (<code>{...}</code>) to execute each iteration.</p>
<h3 id="for"><a class="header" href="#for"><code>for</code></a></h3>
<p>This is what a <code>for</code> loop that computes the sum of a vector of numbers looks like:</p>
<pre><code class="language-sway">for element in vector.iter() {
    sum += element;
}
</code></pre>
<p>You need the <code>for</code> keyword, some pattern that contains variable names such as <code>element</code> in this case, the <code>Ã¬n</code> keyword followed by an iterator, and a block of code inside the curly braces (<code>{...}</code>) to execute each iteration. <code>vector.iter()</code> in the example above returns an iterator for the <code>vector</code>. In each iteration, the value of <code>element</code> is updated with the next value in the iterator until the end of the vector is reached and the <code>for</code> loop iteration ends.</p>
<p>Modifying the <code>vector</code> during iteration, by e.g. adding or removing elements, is a logical error and results in an <a href="basics/../reference/undefined_behavior.html">undefined behavior</a>:</p>
<pre><code class="language-sway">// The behavior of this `for` loop is undefined because
// the `vector` gets modified within the loop.
for element in vector.iter() {
    if element == 3 {
        vector.push(6); // Modification of the vector!
    }
}
</code></pre>
<h3 id="break-and-continue"><a class="header" href="#break-and-continue"><code>break</code> and <code>continue</code></a></h3>
<p><code>break</code> and <code>continue</code> keywords are available to use inside the body of a <code>while</code> or <code>for</code> loop. The purpose of the <code>break</code> statement is to break out of a loop early:</p>
<pre><code class="language-sway">fn break_example() -&gt; u64 {
    let mut counter = 1;
    let mut sum = 0;
    let num = 10;
    while true {
        if counter &gt; num {
            break;
        }
        sum += counter;
        counter += 1;
    }
    sum // 1 + 2 + .. + 10 = 55
}
</code></pre>
<p>The purpose of the <code>continue</code> statement is to skip a portion of a loop in an iteration and jump directly into the next iteration:</p>
<pre><code class="language-sway">fn continue_example() -&gt; u64 {
    let mut counter = 0;
    let mut sum = 0;
    let num = 10;
    while counter &lt; num {
        counter += 1;
        if counter % 2 == 0 {
            continue;
        }
        sum += counter;
    }
    sum // 1 + 3 + .. + 9 = 25
}
</code></pre>
<h3 id="nested-loops"><a class="header" href="#nested-loops">Nested loops</a></h3>
<p>You can also use nested <code>while</code> loops if needed:</p>
<pre><code class="language-sway">while condition_1 == true {
    // do stuff...
    while condition_2 == true {
        // do more stuff...
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-handling"><a class="header" href="#error-handling">Error Handling</a></h1>
<h2 id="recoverable-errors"><a class="header" href="#recoverable-errors">Recoverable Errors</a></h2>
<p>Recoverable errors represent expected faults. Similar to Rust, Sway expresses recoverable errors by using the <code>std::result::Result</code> enum, letting you propagate or transform the error without immediately reverting the transaction.</p>
<p>To learn more about expressing and handling recoverable errors, see the chapter on <a href="basics/commonly_used_library_types.html#resultt-e"><code>Result&lt;T, E&gt;</code> enum</a>.</p>
<h2 id="irrecoverable-errors"><a class="header" href="#irrecoverable-errors">Irrecoverable Errors</a></h2>
<p>Irrecoverable errors indicate bugs or violated invariants. They trigger a VM-wide revert that atomically rolls back every state change in the transaction, and it cannot be caught or handled in Sway code, signaling that the program cannot sensibly continue.</p>
<h3 id="panic-expression"><a class="header" href="#panic-expression"><code>panic</code> Expression</a></h3>
<p>The recommended way of expressing an irrecoverable errors is to use the <code>panic</code> expression:</p>
<pre><code class="language-sway">if some_error_occurred {
    panic "Some error has occurred.";
}
</code></pre>
<p>At runtime, the <code>panic</code> expression aborts and reverts the execution of the entire program. At compile time, for each <code>panic</code> encountered in code, Sway compiler will generate a unique revert code and create an entry in the ABI JSON <code>errorCodes</code> section. The generated <code>errorCodes</code> entry will contain the information about source location at which the <code>panic</code> occurs, as well as the error message.</p>
<p><strong>This mechanism allows for getting a rich troubleshooting information, without an additional on-chain cost.</strong> The generated bytecode will contain only the revert instruction, and the remaining information, the error message and the error location, are stored off-chain, in the ABI JSON file.</p>
<p>For example, let's assume that the above code is situated in the module <code>some_module</code>, contained within the version <code>v1.2.3</code> of the package <code>some_package</code>.</p>
<p>At runtime, the <code>panic</code> will result in a compiler generated revert code, e.g., 18446744069414584323. At compile time, an entry similar to this will be added to the ABI JSON <code>errorCodes</code> section:</p>
<pre><code class="language-json">"errorCodes": {
    "18446744069414584323": {
        "pos": {
          "pkg": "some_package@1.2.3",
          "file": "some_module.sw",
          "line": 13,
          "column": 9
        },
        "logId": null,
        "msg": "Some error has occurred."
    },
}
</code></pre>
<p>Rust and TypeScript SDK, as well as <code>forc test</code>, recognize revert codes generated from <code>panic</code> expressions. E.g., if a Sway unit test fails because of a revert caused by the above <code>panic</code> line, the <code>forc test</code> will display the following:</p>
<pre><code class="language-console">test some_test, "path/to/failing/test.sw":42
    revert code: ffffffff00000003
    â”œâ”€ panic message: Some error has occurred.
    â””â”€ panicked in:   some_package@1.2.3, src/some_module.sw:13:9
</code></pre>
<h3 id="error-types"><a class="header" href="#error-types">Error Types</a></h3>
<p>Passing textual error messages directly as a <code>panic</code> argument is the most convenient way to provide a helpful error message. It is sufficient for many use-cases. However, often we want:</p>
<ul>
<li>to provide an additional runtime information about the error.</li>
<li>group a certain family of errors together.</li>
</ul>
<p>For these use-cases, you can use <em>error types</em>. Error types are enums annotated with the <code>#[error_type]</code> attribute, whose all variants are attributed with the <code>#[error(m = "&lt;error message&gt;")]</code> attributes. Each variant represent a particular error, and the enum itself the family of errors. The convention is to postfix the names of error type enums with <code>Error</code>.</p>
<p>For example, let's assume we are checking if a provided <code>Identity</code> has certain access rights to our contract. The error type enum representing access rights violations could look like:</p>
<pre><code class="language-sway">#[error_type]
pub enum AccessRightError {
    #[error(m = "The provided identity is not an administrator.")]
    NotAnAdmin: Identity,
    #[error(m = "The provided identity is not an owner.")]
    NotAnOwner: Identity,
    #[error(m = "The provided identity does not have write access.")]
    NoWriteAccess: Identity,
}
</code></pre>
<p>where each <code>Identity</code> represents the actual, provided identity.</p>
<p>In code, we can now check for access rights and panic if they are violated:</p>
<pre><code class="language-sway">fn do_something_that_requires_admin_access(admin: Identity) {
    if !is_admin(admin) {
        panic AccessRightError::NotAnAdmin(admin);
    }

    // ...
}
</code></pre>
<p>Assuming we have a failing test for the above function, the test output will show the error message, but also the provided <code>Identity</code>. E.g.:</p>
<pre><code class="language-console">test some_test_for_admin_access, "path/to/failing/test.sw":42
    revert code: ffffffff00000007
    â”œâ”€ panic message: The provided identity is not an administrator.
    â”œâ”€ panic value:   NotAnAdmin(Address(Address()))
    â””â”€ panicked in:   some_other_package@0.1.0, src/admin_module.sw:11:9
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="blockchain-development-with-sway"><a class="header" href="#blockchain-development-with-sway">Blockchain Development with Sway</a></h1>
<p>Sway is fundamentally a blockchain language. Because of this, it has some features and requirements that you may not have seen in general-purpose programming languages.</p>
<p>These are also some concepts related to the FuelVM and Fuel ecosystem that you may utilize when writing Sway.</p>
<ul>
<li><a href="blockchain-development/./hashing_and_cryptography.html">Hashing and Cryptography</a></li>
<li><a href="blockchain-development/./storage.html">Contract Storage</a></li>
<li><a href="blockchain-development/./purity.html">Function Purity</a></li>
<li><a href="blockchain-development/./identifiers.html">Identifiers</a></li>
<li><a href="blockchain-development/./native_assets.html">Native Assets</a></li>
<li><a href="blockchain-development/./access_control.html">Access Control</a></li>
<li><a href="blockchain-development/./calling_contracts.html">Calling Contracts</a></li>
<li><a href="blockchain-development/./external_code.html">External Code Execution</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hashing-and-cryptography"><a class="header" href="#hashing-and-cryptography">Hashing and Cryptography</a></h1>
<p>The Sway standard library provides easy access to a selection of cryptographic hash functions (<code>sha256</code> and EVM-compatible <code>keccak256</code>), and EVM-compatible <code>secp256k1</code>-based signature recovery operations.</p>
<h2 id="hashing"><a class="header" href="#hashing">Hashing</a></h2>
<pre><code class="language-sway">script;

use std::hash::*;

impl Hash for Location {
    fn hash(self, ref mut state: Hasher) {
        match self {
            Location::Earth =&gt; {
                0_u8.hash(state);
            }
            Location::Mars =&gt; {
                1_u8.hash(state);
            }
        }
    }
}

impl Hash for Stats {
    fn hash(self, ref mut state: Hasher) {
        self.strength.hash(state);
        self.agility.hash(state);
    }
}

impl Hash for Person {
    fn hash(self, ref mut state: Hasher) {
        self.name.hash(state);
        self.age.hash(state);
        self.alive.hash(state);
        self.location.hash(state);
        self.stats.hash(state);
        self.some_tuple.hash(state);
        self.some_array.hash(state);
        self.some_b256.hash(state);
    }
}

const VALUE_A = 0x9280359a3b96819889d30614068715d634ad0cf9bba70c0f430a8c201138f79f;

enum Location {
    Earth: (),
    Mars: (),
}

struct Person {
    name: str,
    age: u64,
    alive: bool,
    location: Location,
    stats: Stats,
    some_tuple: (bool, u64),
    some_array: [u64; 2],
    some_b256: b256,
}

struct Stats {
    strength: u64,
    agility: u64,
}

fn main() {
    let zero = b256::min();
    // Use the generic sha256 to hash some integers
    let sha_hashed_u8 = sha256(u8::max());
    let sha_hashed_u16 = sha256(u16::max());
    let sha_hashed_u32 = sha256(u32::max());
    let sha_hashed_u64 = sha256(u64::max());

    // Or hash a b256
    let sha_hashed_b256 = sha256(VALUE_A);

    // You can hash booleans too
    let sha_hashed_bool = sha256(true);

    // Strings are not a problem either
    let sha_hashed_str = sha256("Fastest Modular Execution Layer!");

    // Tuples of any size work too
    let sha_hashed_tuple = sha256((true, 7));

    // As do arrays
    let sha_hashed_array = sha256([4, 5, 6]);

    // Enums work too
    let sha_hashed_enum = sha256(Location::Earth);

    // Complex structs are not a problem
    let sha_hashed_struct = sha256(Person {
        name: "John",
        age: 9000,
        alive: true,
        location: Location::Mars,
        stats: Stats {
            strength: 10,
            agility: 9,
        },
        some_tuple: (true, 8),
        some_array: [17, 76],
        some_b256: zero,
    });

    log(sha_hashed_u8);
    log(sha_hashed_u16);
    log(sha_hashed_u32);
    log(sha_hashed_u64);
    log(sha_hashed_b256);
    log(sha_hashed_bool);
    log(sha_hashed_str);
    log(sha_hashed_tuple);
    log(sha_hashed_array);
    log(sha_hashed_enum);
    log(sha_hashed_struct);

    // Use the generic keccak256 to hash some integers
    let keccak_hashed_u8 = keccak256(u8::max());
    let keccak_hashed_u16 = keccak256(u16::max());
    let keccak_hashed_u32 = keccak256(u32::max());
    let keccak_hashed_u64 = keccak256(u64::max());

    // Or hash a b256
    let keccak_hashed_b256 = keccak256(VALUE_A);

    // You can hash booleans too
    let keccak_hashed_bool = keccak256(true);

    // Strings are not a problem either
    let keccak_hashed_str = keccak256("Fastest Modular Execution Layer!");

    // Tuples of any size work too
    let keccak_hashed_tuple = keccak256((true, 7));

    // As do arrays
    let keccak_hashed_array = keccak256([4, 5, 6]);

    // Enums work too
    let keccak_hashed_enum = keccak256(Location::Earth);

    // Complex structs are not a problem
    let keccak_hashed_struct = keccak256(Person {
        name: "John",
        age: 9000,
        alive: true,
        location: Location::Mars,
        stats: Stats {
            strength: 10,
            agility: 9,
        },
        some_tuple: (true, 8),
        some_array: [17, 76],
        some_b256: zero,
    });

    log(keccak_hashed_u8);
    log(keccak_hashed_u16);
    log(keccak_hashed_u32);
    log(keccak_hashed_u64);
    log(keccak_hashed_b256);
    log(keccak_hashed_bool);
    log(keccak_hashed_str);
    log(keccak_hashed_tuple);
    log(keccak_hashed_array);
    log(keccak_hashed_enum);
    log(keccak_hashed_struct);
}
</code></pre>
<h2 id="cryptographic-signature-recovery-and-verification"><a class="header" href="#cryptographic-signature-recovery-and-verification">Cryptographic Signature Recovery and Verification</a></h2>
<p>Fuel supports 3 asymmetric cryptographic signature schemes; <code>Secp256k1</code>, <code>Secp256r1</code>, and <code>Ed25519</code>.</p>
<h3 id="public-key-recovery"><a class="header" href="#public-key-recovery">Public Key Recovery</a></h3>
<p>Given a <code>Signature</code> and a sign <code>Message</code>, you can recover a <code>PublicKey</code>.</p>
<pre><code class="language-sway">    // Secp256rk1 Public Key Recovery
    let secp256k1_signature: Signature = Signature::Secp256k1(Secp256k1::from((
        0x61f3caf4c0912cec69ff0b226638d397115c623a7f057914d48a7e4daf1cf6d8,
        0x2555de81cd3a40382d3d64eb1c77e463eea5a76d65ec85f283e0b3d568352678,
    )));
    let signed_message = Message::from(0xa13f4ab54057ce064d3dd97ac3ff30ed704e73956896c03650fe59b1a561fe15);
    // A recovered public key pair.
    let secp256k1_public_key = secp256k1_signature.recover(signed_message);
    assert(secp256k1_public_key.is_ok());
    assert(
        secp256k1_public_key
            .unwrap() == PublicKey::from((
            0x41a55558a3486b6ee3878f55f16879c0798afd772c1506de44aba90d29b6e65c,
            0x341ca2e0a3d5827e78d838e35b29bebe2a39ac30b58999e1138c9467bf859965,
        )),
    );

    // Secp256r1 Public Key Recovery
    let secp256r1_signature = Signature::Secp256r1(Secp256r1::from((
        0xbd0c9b8792876712afadbff382e1bf31c44437823ed761cc3600d0016de511ac,
        0x44ac566bd156b4fc71a4a4cb2655d3da360c695edb27dc3b64d621e122fea23d,
    )));
    let signed_message = Message::from(0x1e45523606c96c98ba970ff7cf9511fab8b25e1bcd52ced30b81df1e4a9c4323);
    // A recovered public key pair.
    let secp256r1_public_key = secp256r1_signature.recover(signed_message);
    assert(secp256r1_public_key.is_ok());
    assert(
        secp256r1_public_key
            .unwrap() == PublicKey::from((
            0xd6ea577a54ae42411fbc78d686d4abba2150ca83540528e4b868002e346004b2,
            0x62660ecce5979493fe5684526e8e00875b948e507a89a47096bc84064a175452,
        )),
    );
</code></pre>
<h3 id="signed-message-address-recovery"><a class="header" href="#signed-message-address-recovery">Signed Message Address Recovery</a></h3>
<p>Given a <code>Signature</code> and signed <code>Message</code>, you can recover a Fuel <code>Address</code>.</p>
<pre><code class="language-sway">    // Secp256k1 Address Recovery
    let secp256k1_signature = Signature::Secp256k1(Secp256k1::from((
        0x61f3caf4c0912cec69ff0b226638d397115c623a7f057914d48a7e4daf1cf6d8,
        0x2555de81cd3a40382d3d64eb1c77e463eea5a76d65ec85f283e0b3d568352678,
    )));
    let signed_message = Message::from(0xa13f4ab54057ce064d3dd97ac3ff30ed704e73956896c03650fe59b1a561fe15);
    // A recovered Fuel address.
    let secp256k1_address = secp256k1_signature.address(signed_message);
    assert(secp256k1_address.is_ok());
    assert(
        secp256k1_address
            .unwrap() == Address::from(0x02844f00cce0f608fa3f0f7408bec96bfd757891a6fda6e1fa0f510398304881),
    );

    // Secp256r1 Address Recovery
    let secp256r1_signature = Signature::Secp256r1(Secp256r1::from((
        0xbd0c9b8792876713afa8bf3383eebf31c43437823ed761cc3600d0016de5110c,
        0x44ac566bd156b4fc71a4a4cb2655d3dd360c695edb17dc3b64d611e122fea23d,
    )));
    let signed_message = Message::from(0xee45573606c96c98ba970ff7cf9511f1b8b25e6bcd52ced30b89df1e4a9c4323);
    // A recovered Fuel address.
    let secp256r1_address = secp256r1_signature.address(signed_message);
    assert(secp256r1_address.is_ok());
    assert(
        secp256r1_address
            .unwrap() == Address::from(0xb4a5fabee8cc852084b71f17107e9c18d682033a58967027af0ab01edf2f9a6a),
    );

</code></pre>
<h4 id="signed-message-evm-address-recovery"><a class="header" href="#signed-message-evm-address-recovery">Signed Message EVM Address Recovery</a></h4>
<p>Recovery of EVM addresses is also supported.</p>
<pre><code class="language-sway">    // Secp256k1 EVM Address Recovery
    let secp256k1_signature = Signature::Secp256k1(Secp256k1::from((
        0xbd0c9b8792876713afa8bff383eebf31c43437823ed761cc3600d0016de5110c,
        0x44ac566bd156b4fc71a4a4cb2655d3dd360c695edb17dc3b64d611e122fea23d,
    )));
    let signed_message = Message::from(0xee45573606c96c98ba970ff7cf9511f1b8b25e6bcd52ced30b89df1e4a9c4323);
    // A recovered EVM address.
    let secp256k1_evm_address = secp256k1_signature.evm_address(signed_message);
    assert(secp256k1_evm_address.is_ok());
    assert(
        secp256k1_evm_address
            .unwrap() == EvmAddress::from(0x0000000000000000000000000ec44cf95ce5051ef590e6d420f8e722dd160ecb),
    );

    // Secp256r1 EVM Address Recovery
    let secp256r1_signature = Signature::Secp256r1(Secp256r1::from((
        0x62CDC20C0AB6AA7B91E63DA9917792473F55A6F15006BC99DD4E29420084A3CC,
        0xF4D99AF28F9D6BD96BDAAB83BFED99212AC3C7D06810E33FBB14C4F29B635414,
    )));
    let signed_message = Message::from(0x290decd9548b62a8d60345a988386fc84ba6bc95484008f6362f93160ef3e563);
    // A recovered EVM address.
    let secp256r1_evm_address = secp256r1_signature.evm_address(signed_message);
    assert(secp256r1_evm_address.is_ok());
    assert(
        secp256r1_evm_address
            .unwrap() == EvmAddress::from(0x000000000000000000000000408eb2d97ef0beda0a33848d9e052066667cb00a),
    );
</code></pre>
<h3 id="public-key-signature-verification"><a class="header" href="#public-key-signature-verification">Public Key Signature Verification</a></h3>
<p>Given a <code>Signature</code>, <code>PublicKey</code>, and <code>Message</code>, you can verify that the message was signed using the public key.</p>
<pre><code class="language-sway">    // Secp256k1 Signature Verification
    let secp256k1_signature = Signature::Secp256k1(Secp256k1::from((
        0x61f3caf4c0912cec69ff0b226638d397115c623a7f057914d48a7e4daf1cf6d8,
        0x2555de81cd3a40382d3d64eb1c77e463eea5a76d65ec85f283e0b3d568352678,
    )));
    let secp256k1_public_key = PublicKey::from((
        0x41a55558a3486b6ee3878f55f16879c0798afd772c1506de44aba90d29b6e65c,
        0x341ca2e0a3d5827e78d838e35b29bebe2a39ac30b58999e1138c9467bf859965,
    ));
    let signed_message = Message::from(0xa13f4ab54057ce064d3dd97ac3ff30ed704e73956896c03650fe59b1a561fe15);
    // A verified public key
    let secp256k1_verified = secp256k1_signature.verify(secp256k1_public_key, signed_message);
    assert(secp256k1_verified.is_ok());

    // Secp256r1 Signature Verification
    let secp256r1_signature = Signature::Secp256r1(Secp256r1::from((
        0xbd0c9b8792876712afadbff382e1bf31c44437823ed761cc3600d0016de511ac,
        0x44ac566bd156b4fc71a4a4cb2655d3da360c695edb27dc3b64d621e122fea23d,
    )));
    let secp256r1_public_key = PublicKey::from((
        0xd6ea577a54ae42411fbc78d686d4abba2150ca83540528e4b868002e346004b2,
        0x62660ecce5979493fe5684526e8e00875b948e507a89a47096bc84064a175452,
    ));
    let signed_message = Message::from(0x1e45523606c96c98ba970ff7cf9511fab8b25e1bcd52ced30b81df1e4a9c4323);
    // A verified public key 
    let secp256r1_verified = secp256r1_signature.verify(secp256r1_public_key, signed_message);
    assert(secp256r1_verified.is_ok());

    // Ed25519 Signature Verification
    let ed25519_public_key = PublicKey::from(0x314fa58689bbe1da2430517de2d772b384a1c1d2e9cb87e73c6afcf246045b10);
    let ed25519_signature = Signature::Ed25519(Ed25519::from((
        0xf38cef9361894be6c6e0eddec28a663d099d7ddff17c8077a1447d7ecb4e6545,
        0xf5084560039486d3462dd65a40c80a74709b2f06d450ffc5dc00345c6b2cdd00,
    )));
    let hashed_message = Message::from(sha256(b256::zero()));
    // A verified public key  
    let ed25519_verified = ed25519_signature.verify(ed25519_public_key, hashed_message);
    assert(ed25519_verified.is_ok());
</code></pre>
<h3 id="address-signature-verification"><a class="header" href="#address-signature-verification">Address Signature Verification</a></h3>
<p>Given a <code>Signature</code>, <code>Address</code>, and <code>Message</code>, you can verify that the message was signed by the address.</p>
<pre><code class="language-sway">    // Secp256k1 Address Verification
    let secp256k1_address = Address::from(0x02844f00cce0f608fa3f0f7408bec96bfd757891a6fda6e1fa0f510398304881);
    let secp256k1_signature = Secp256k1::from((
        0x61f3caf4c0912cec69ff0b226638d397115c623a7f057914d48a7e4daf1cf6d8,
        0x2555de81cd3a40382d3d64eb1c77e463eea5a76d65ec85f283e0b3d568352678,
    ));
    let signed_message = Message::from(0xa13f4ab54057ce064d3dd97ac3ff30ed704e73956896c03650fe59b1a561fe15);
    // A verified address
    let secp256k1_verified = secp256k1_signature.verify_address(secp256k1_address, signed_message);
    assert(secp256k1_verified.is_ok());

    // Secp256r1 Address Verification
    let secp256r1_address = Address::from(0xb4a5fabee8cc852084b71f17107e9c18d682033a58967027af0ab01edf2f9a6a);
    let secp256r1_signature = Signature::Secp256r1(Secp256r1::from((
        0xbd0c9b8792876713afa8bf3383eebf31c43437823ed761cc3600d0016de5110c,
        0x44ac566bd156b4fc71a4a4cb2655d3dd360c695edb17dc3b64d611e122fea23d,
    )));
    let signed_message = Message::from(0xee45573606c96c98ba970ff7cf9511f1b8b25e6bcd52ced30b89df1e4a9c4323);
    // A verified address
    let secp256r1_verified = secp256r1_signature.verify_address(secp256r1_address, signed_message);
    assert(secp256r1_verified.is_ok());

</code></pre>
<h4 id="evm-address-signature-verification"><a class="header" href="#evm-address-signature-verification">EVM Address Signature Verification</a></h4>
<p>Recovery of EVM addresses verification is also supported.</p>
<pre><code class="language-sway">    // Secp256k1 Address Verification
    let secp256k1_evm_address = EvmAddress::from(0x0000000000000000000000000ec44cf95ce5051ef590e6d420f8e722dd160ecb);
    let secp256k1_signature = Signature::Secp256k1(Secp256k1::from((
        0xbd0c9b8792876713afa8bff383eebf31c43437823ed761cc3600d0016de5110c,
        0x44ac566bd156b4fc71a4a4cb2655d3dd360c695edb17dc3b64d611e122fea23d,
    )));
    let signed_message = Message::from(0xee45573606c96c98ba970ff7cf9511f1b8b25e6bcd52ced30b89df1e4a9c4323);
    // A recovered EVM address.
    let secp256k1_verified = secp256k1_signature.verify_evm_address(secp256k1_evm_address, signed_message);
    assert(secp256k1_verified.is_ok());

    // Secp256r1 Address Verification
    let secp256r1_evm_address = EvmAddress::from(0x000000000000000000000000408eb2d97ef0beda0a33848d9e052066667cb00a);
    let secp256r1_signature = Signature::Secp256r1(Secp256r1::from((
        0x62CDC20C0AB6AA7B91E63DA9917792473F55A6F15006BC99DD4E29420084A3CC,
        0xF4D99AF28F9D6BD96BDAAB83BFED99212AC3C7D06810E33FBB14C4F29B635414,
    )));
    let signed_message = Message::from(0x290decd9548b62a8d60345a988386fc84ba6bc95484008f6362f93160ef3e563);
    // A recovered EVM address.
    let secp256r1_verified = secp256r1_signature.verify_evm_address(secp256r1_evm_address, signed_message);
    assert(secp256r1_verified.is_ok());
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="storage"><a class="header" href="#storage">Storage</a></h1>
<!-- This section should explain storage in Sway -->
<!-- storage:example:start -->
<p>When developing a <a href="blockchain-development/../sway-program-types/smart_contracts.html">smart contract</a>, you will typically need some sort of persistent storage. In this case, persistent storage, often just called <em>storage</em> in this context, is a place where you can store values that are persisted inside the contract itself. This is in contrast to a regular value in <em>memory</em>, which disappears after the contract exits.</p>
<p>Put in conventional programming terms, contract storage is like saving data to a hard drive. That data is saved even after the program that saved it exits. That data is persistent. Using memory is like declaring a variable in a program: it exists for the duration of the program and is non-persistent.</p>
<p>Some basic use cases of storage include declaring an owner address for a contract and saving balances in a wallet.</p>
<!-- storage:example:end -->
<h2 id="storage-accesses-via-the-storage-keyword"><a class="header" href="#storage-accesses-via-the-storage-keyword">Storage Accesses Via the <code>storage</code> Keyword</a></h2>
<p>Declaring variables in storage requires a <code>storage</code> block that contains a list of all your variables, their types, and their initial values. The initial value can be any expression that can be evaluated to a constant during compilation, as follows:</p>
<pre><code class="language-sway">storage {
    var1: u64 = 1,
    var2: b256 = b256::zero(),
    var3: Address = Address::zero(),
    var4: Option&lt;u8&gt; = None,
}
</code></pre>
<p>To write into a storage variable, you need to use the <code>storage</code> keyword as follows:</p>
<pre><code class="language-sway">        storage.var1.write(42);
        storage
            .var2
            .write(0x1111111111111111111111111111111111111111111111111111111111111111);
        storage
            .var3
            .write(Address::from(0x1111111111111111111111111111111111111111111111111111111111111111));
        storage.var4.write(Some(2u8));
</code></pre>
<p>To read a storage variable, you also need to use the <code>storage</code> keyword. You may use <code>read()</code> or <code>try_read()</code>, however we recommend using <code>try_read()</code> for additional safety.</p>
<pre><code class="language-sway">        let var1: u64 = storage.var1.read();
        let var2: b256 = storage.var2.try_read().unwrap_or(b256::zero());
        let var3: Address = storage.var3.try_read().unwrap_or(Address::zero());
        let var4: Option&lt;u8&gt; = storage.var4.try_read().unwrap_or(None);
</code></pre>
<h2 id="storing-structs"><a class="header" href="#storing-structs">Storing Structs</a></h2>
<p>To store a struct in storage, each variable must be assigned in the <code>storage</code> block. This can be either my assigning the fields individually or using a public <a href="blockchain-development/../basics/methods_and_associated_functions.html#constructors">constructor</a> that can be evaluated to a constant during compilation.</p>
<pre><code class="language-sway">struct Type1 {
    x: u64,
    y: u64,
}

struct Type2 {
    w: b256,
    z: bool,
}

impl Type2 {
    // a constructor that evaluates to a constant during compilation
    fn default() -&gt; Self {
        Self {
            w: 0x0000000000000000000000000000000000000000000000000000000000000000,
            z: true,
        }
    }
}

storage {
    var1: Type1 = Type1 { x: 0, y: 0 },
    var2: Type2 = Type2::default(),
}
</code></pre>
<p>You may write to both fields of a struct and the entire struct as follows:</p>
<pre><code class="language-sway">        // Store individual fields
        storage.var1.x.write(42);
        storage.var1.y.write(77);

        // Store an entire struct
        let new_struct = Type2 {
            w: 0x1111111111111111111111111111111111111111111111111111111111111111,
            z: false,
        };
        storage.var2.write(new_struct);
</code></pre>
<p>The same applies to reading structs from storage, where both the individual and struct as a whole may be read as follows:</p>
<pre><code class="language-sway">        let var1_x: u64 = storage.var1.x.try_read().unwrap_or(0);
        let var1_y: u64 = storage.var1.y.try_read().unwrap_or(0);
        let var2: Type2 = storage.var2.try_read().unwrap_or(Type2::default());
</code></pre>
<h2 id="common-storage-collections"><a class="header" href="#common-storage-collections">Common Storage Collections</a></h2>
<p>We support the following common storage collections:</p>
<ul>
<li><code>StorageMap&lt;K, V&gt;</code></li>
<li><code>StorageVec&lt;T&gt;</code></li>
<li><code>StorageBytes</code></li>
<li><code>StorageString</code></li>
</ul>
<p>Please note that these types are not initialized during compilation. This means that if you try to access a key from a storage map before the storage has been set, for example, the call will revert.</p>
<p>Declaring these variables in storage requires a <code>storage</code> block as follows:</p>
<pre><code class="language-sway">storage {
    storage_map: StorageMap&lt;u64, bool&gt; = StorageMap {},
    storage_vec: StorageVec&lt;b256&gt; = StorageVec {},
    storage_string: StorageString = StorageString {},
    storage_bytes: StorageBytes = StorageBytes {},
}
</code></pre>
<h3 id="storagemapsk-v"><a class="header" href="#storagemapsk-v"><code>StorageMaps&lt;K, V&gt;</code></a></h3>
<p>Generic storage maps are available in the standard library as <code>StorageMap&lt;K, V&gt;</code> which have to be defined inside a <code>storage</code> block and allow you to call <code>insert()</code> and <code>get()</code> to insert values at specific keys and get those values respectively. Refer to <a href="blockchain-development/../common-collections/storage_map.html">Storage Maps</a> for more information about <code>StorageMap&lt;K, V&gt;</code>.</p>
<p><strong>Warning</strong> While the <code>StorageMap&lt;K, V&gt;</code> is currently included in the prelude, to use it the <code>Hash</code> trait must still be imported. This is a known issue and will be resolved.</p>
<pre><code class="language-sway">use std::hash::Hash;

use std::storage::storage_vec::*;

use std::storage::storage_bytes::*;

use std::storage::storage_string::*;

storage {
    storage_map: StorageMap&lt;u64, bool&gt; = StorageMap {},
    storage_vec: StorageVec&lt;b256&gt; = StorageVec {},
    storage_string: StorageString = StorageString {},
    storage_bytes: StorageBytes = StorageBytes {},
}

abi StorageExample {
    #[storage(write)]
    fn store_map();
    #[storage(read)]
    fn get_map();
    #[storage(write)]
    fn store_vec();
    #[storage(read, write)]
    fn get_vec();
    #[storage(write)]
    fn store_string();
    #[storage(read)]
    fn get_string();
    #[storage(write)]
    fn store_bytes();
    #[storage(read)]
    fn get_bytes();
}

impl StorageExample for Contract {
    #[storage(write)]
    fn store_map() {
        storage.storage_map.insert(12, true);
        storage.storage_map.insert(59, false);

        // try_insert() will only insert if a value does not already exist for a key.
        let result = storage.storage_map.try_insert(103, true);
        assert(result.is_ok());
    }
    #[storage(read)]
    fn get_map() {
        // Access directly
        let stored_val1: bool = storage.storage_map.get(12).try_read().unwrap_or(false);

        // First get the storage key and then access the value.
        let storage_key2: StorageKey&lt;bool&gt; = storage.storage_map.get(59);
        let stored_val2: bool = storage_key2.try_read().unwrap_or(false);

        // Unsafely access the value.
        let stored_val3: bool = storage.storage_map.get(103).read();
    }

    #[storage(write)]
    fn store_vec() {
        storage
            .storage_vec
            .push(0x1111111111111111111111111111111111111111111111111111111111111111);
        storage
            .storage_vec
            .push(0x0000000000000000000000000000000000000000000000000000000000000001);
        storage
            .storage_vec
            .push(0x0000000000000000000000000000000000000000000000000000000000000002);

        // Set will overwrite the element stored at the given index.
        storage.storage_vec.set(2, b256::zero());
    }
    #[storage(read, write)]
    fn get_vec() {
        // Method 1: Access the element directly
        // Note: get() does not remove the element from the vec.
        let stored_val1: b256 = storage.storage_vec.get(0).unwrap().try_read().unwrap_or(b256::zero());

        // Method 2: First get the storage key and then access the value.
        let storage_key2: StorageKey&lt;b256&gt; = storage.storage_vec.get(1).unwrap();
        let stored_val2: b256 = storage_key2.try_read().unwrap_or(b256::zero());

        // pop() will remove the last element from the vec.
        let length: u64 = storage.storage_vec.len();
        let stored_val3: b256 = storage.storage_vec.pop().unwrap();
        assert(length != storage.storage_vec.len());
    }

    #[storage(write)]
    fn store_string() {
        let my_string = String::from_ascii_str("Fuel is blazingly fast");
        storage.storage_string.write_slice(my_string);
    }
    #[storage(read)]
    fn get_string() {
        let stored_string: String = storage.storage_string.read_slice().unwrap();
    }

    #[storage(write)]
    fn store_bytes() {
        // Setup Bytes
        let mut my_bytes = Bytes::new();
        my_bytes.push(1u8);
        my_bytes.push(2u8);
        my_bytes.push(3u8);

        // Write to storage
        storage.storage_bytes.write_slice(my_bytes);
    }
    #[storage(read)]
    fn get_bytes() {
        let stored_bytes: Bytes = storage.storage_bytes.read_slice().unwrap();
    }
}
</code></pre>
<p>To write to a storage map, call either the <code>insert()</code> or <code>try_insert()</code> functions as follows:</p>
<pre><code class="language-sway">        storage.storage_map.insert(12, true);
        storage.storage_map.insert(59, false);

        // try_insert() will only insert if a value does not already exist for a key.
        let result = storage.storage_map.try_insert(103, true);
        assert(result.is_ok());
</code></pre>
<p>The following demonstrates how to read from a storage map:</p>
<pre><code class="language-sway">        // Access directly
        let stored_val1: bool = storage.storage_map.get(12).try_read().unwrap_or(false);

        // First get the storage key and then access the value.
        let storage_key2: StorageKey&lt;bool&gt; = storage.storage_map.get(59);
        let stored_val2: bool = storage_key2.try_read().unwrap_or(false);

        // Unsafely access the value.
        let stored_val3: bool = storage.storage_map.get(103).read();
</code></pre>
<h3 id="storagevect"><a class="header" href="#storagevect"><code>StorageVec&lt;T&gt;</code></a></h3>
<p>Generic storage vectors are available in the standard library as <code>StorageVec&lt;T&gt;</code> which have to be defined inside a <code>storage</code> block and allow you to call <code>push()</code> and <code>pop()</code> to push and pop values from a vector respectively. Refer to <a href="blockchain-development/../common-collections/storage_vec.html">Storage Vector</a> for more information about <code>StorageVec&lt;T&gt;</code>.</p>
<p>The following demonstrates how to import <code>StorageVec&lt;T&gt;</code>:</p>
<pre><code class="language-sway">use std::storage::storage_vec::*;

use std::storage::storage_bytes::*;

use std::storage::storage_string::*;

storage {
    storage_map: StorageMap&lt;u64, bool&gt; = StorageMap {},
    storage_vec: StorageVec&lt;b256&gt; = StorageVec {},
    storage_string: StorageString = StorageString {},
    storage_bytes: StorageBytes = StorageBytes {},
}

abi StorageExample {
    #[storage(write)]
    fn store_map();
    #[storage(read)]
    fn get_map();
    #[storage(write)]
    fn store_vec();
    #[storage(read, write)]
    fn get_vec();
    #[storage(write)]
    fn store_string();
    #[storage(read)]
    fn get_string();
    #[storage(write)]
    fn store_bytes();
    #[storage(read)]
    fn get_bytes();
}

impl StorageExample for Contract {
    #[storage(write)]
    fn store_map() {
        storage.storage_map.insert(12, true);
        storage.storage_map.insert(59, false);

        // try_insert() will only insert if a value does not already exist for a key.
        let result = storage.storage_map.try_insert(103, true);
        assert(result.is_ok());
    }
    #[storage(read)]
    fn get_map() {
        // Access directly
        let stored_val1: bool = storage.storage_map.get(12).try_read().unwrap_or(false);

        // First get the storage key and then access the value.
        let storage_key2: StorageKey&lt;bool&gt; = storage.storage_map.get(59);
        let stored_val2: bool = storage_key2.try_read().unwrap_or(false);

        // Unsafely access the value.
        let stored_val3: bool = storage.storage_map.get(103).read();
    }

    #[storage(write)]
    fn store_vec() {
        storage
            .storage_vec
            .push(0x1111111111111111111111111111111111111111111111111111111111111111);
        storage
            .storage_vec
            .push(0x0000000000000000000000000000000000000000000000000000000000000001);
        storage
            .storage_vec
            .push(0x0000000000000000000000000000000000000000000000000000000000000002);

        // Set will overwrite the element stored at the given index.
        storage.storage_vec.set(2, b256::zero());
    }
    #[storage(read, write)]
    fn get_vec() {
        // Method 1: Access the element directly
        // Note: get() does not remove the element from the vec.
        let stored_val1: b256 = storage.storage_vec.get(0).unwrap().try_read().unwrap_or(b256::zero());

        // Method 2: First get the storage key and then access the value.
        let storage_key2: StorageKey&lt;b256&gt; = storage.storage_vec.get(1).unwrap();
        let stored_val2: b256 = storage_key2.try_read().unwrap_or(b256::zero());

        // pop() will remove the last element from the vec.
        let length: u64 = storage.storage_vec.len();
        let stored_val3: b256 = storage.storage_vec.pop().unwrap();
        assert(length != storage.storage_vec.len());
    }

    #[storage(write)]
    fn store_string() {
        let my_string = String::from_ascii_str("Fuel is blazingly fast");
        storage.storage_string.write_slice(my_string);
    }
    #[storage(read)]
    fn get_string() {
        let stored_string: String = storage.storage_string.read_slice().unwrap();
    }

    #[storage(write)]
    fn store_bytes() {
        // Setup Bytes
        let mut my_bytes = Bytes::new();
        my_bytes.push(1u8);
        my_bytes.push(2u8);
        my_bytes.push(3u8);

        // Write to storage
        storage.storage_bytes.write_slice(my_bytes);
    }
    #[storage(read)]
    fn get_bytes() {
        let stored_bytes: Bytes = storage.storage_bytes.read_slice().unwrap();
    }
}
</code></pre>
<blockquote>
<p><strong>NOTE</strong>: When importing the <code>StorageVec&lt;T&gt;</code>, please be sure to use the glob operator: <code>use std::storage::storage_vec::*</code>.</p>
</blockquote>
<p>The following demonstrates how to write to a <code>StorageVec&lt;T&gt;</code>:</p>
<pre><code class="language-sway">        storage
            .storage_vec
            .push(0x1111111111111111111111111111111111111111111111111111111111111111);
        storage
            .storage_vec
            .push(0x0000000000000000000000000000000000000000000000000000000000000001);
        storage
            .storage_vec
            .push(0x0000000000000000000000000000000000000000000000000000000000000002);

        // Set will overwrite the element stored at the given index.
        storage.storage_vec.set(2, b256::zero());
</code></pre>
<p>The following demonstrates how to read from a <code>StorageVec&lt;T&gt;</code>:</p>
<pre><code class="language-sway">        // Method 1: Access the element directly
        // Note: get() does not remove the element from the vec.
        let stored_val1: b256 = storage.storage_vec.get(0).unwrap().try_read().unwrap_or(b256::zero());

        // Method 2: First get the storage key and then access the value.
        let storage_key2: StorageKey&lt;b256&gt; = storage.storage_vec.get(1).unwrap();
        let stored_val2: b256 = storage_key2.try_read().unwrap_or(b256::zero());

        // pop() will remove the last element from the vec.
        let length: u64 = storage.storage_vec.len();
        let stored_val3: b256 = storage.storage_vec.pop().unwrap();
        assert(length != storage.storage_vec.len());
</code></pre>
<h3 id="storagebytes"><a class="header" href="#storagebytes"><code>StorageBytes</code></a></h3>
<p>Storage of <code>Bytes</code> is available in the standard library as <code>StorageBytes</code> which have to be defined inside a <code>storage</code> block. <code>StorageBytes</code> cannot be manipulated in the same way a <code>StorageVec&lt;T&gt;</code> or <code>StorageMap&lt;K, V&gt;</code> can but stores bytes more efficiently thus reducing gas. Only the entirety of a <code>Bytes</code> may be read/written to storage. This means any changes would require loading the entire <code>Bytes</code> to the heap, making changes, and then storing it once again. If frequent changes are needed, a <code>StorageVec&lt;u8&gt;</code> is recommended.</p>
<p>The following demonstrates how to import <code>StorageBytes</code>:</p>
<pre><code class="language-sway">use std::storage::storage_bytes::*;

use std::storage::storage_string::*;

storage {
    storage_map: StorageMap&lt;u64, bool&gt; = StorageMap {},
    storage_vec: StorageVec&lt;b256&gt; = StorageVec {},
    storage_string: StorageString = StorageString {},
    storage_bytes: StorageBytes = StorageBytes {},
}

abi StorageExample {
    #[storage(write)]
    fn store_map();
    #[storage(read)]
    fn get_map();
    #[storage(write)]
    fn store_vec();
    #[storage(read, write)]
    fn get_vec();
    #[storage(write)]
    fn store_string();
    #[storage(read)]
    fn get_string();
    #[storage(write)]
    fn store_bytes();
    #[storage(read)]
    fn get_bytes();
}

impl StorageExample for Contract {
    #[storage(write)]
    fn store_map() {
        storage.storage_map.insert(12, true);
        storage.storage_map.insert(59, false);

        // try_insert() will only insert if a value does not already exist for a key.
        let result = storage.storage_map.try_insert(103, true);
        assert(result.is_ok());
    }
    #[storage(read)]
    fn get_map() {
        // Access directly
        let stored_val1: bool = storage.storage_map.get(12).try_read().unwrap_or(false);

        // First get the storage key and then access the value.
        let storage_key2: StorageKey&lt;bool&gt; = storage.storage_map.get(59);
        let stored_val2: bool = storage_key2.try_read().unwrap_or(false);

        // Unsafely access the value.
        let stored_val3: bool = storage.storage_map.get(103).read();
    }

    #[storage(write)]
    fn store_vec() {
        storage
            .storage_vec
            .push(0x1111111111111111111111111111111111111111111111111111111111111111);
        storage
            .storage_vec
            .push(0x0000000000000000000000000000000000000000000000000000000000000001);
        storage
            .storage_vec
            .push(0x0000000000000000000000000000000000000000000000000000000000000002);

        // Set will overwrite the element stored at the given index.
        storage.storage_vec.set(2, b256::zero());
    }
    #[storage(read, write)]
    fn get_vec() {
        // Method 1: Access the element directly
        // Note: get() does not remove the element from the vec.
        let stored_val1: b256 = storage.storage_vec.get(0).unwrap().try_read().unwrap_or(b256::zero());

        // Method 2: First get the storage key and then access the value.
        let storage_key2: StorageKey&lt;b256&gt; = storage.storage_vec.get(1).unwrap();
        let stored_val2: b256 = storage_key2.try_read().unwrap_or(b256::zero());

        // pop() will remove the last element from the vec.
        let length: u64 = storage.storage_vec.len();
        let stored_val3: b256 = storage.storage_vec.pop().unwrap();
        assert(length != storage.storage_vec.len());
    }

    #[storage(write)]
    fn store_string() {
        let my_string = String::from_ascii_str("Fuel is blazingly fast");
        storage.storage_string.write_slice(my_string);
    }
    #[storage(read)]
    fn get_string() {
        let stored_string: String = storage.storage_string.read_slice().unwrap();
    }

    #[storage(write)]
    fn store_bytes() {
        // Setup Bytes
        let mut my_bytes = Bytes::new();
        my_bytes.push(1u8);
        my_bytes.push(2u8);
        my_bytes.push(3u8);

        // Write to storage
        storage.storage_bytes.write_slice(my_bytes);
    }
    #[storage(read)]
    fn get_bytes() {
        let stored_bytes: Bytes = storage.storage_bytes.read_slice().unwrap();
    }
}
</code></pre>
<blockquote>
<p><strong>NOTE</strong>: When importing the <code>StorageBytes</code>, please be sure to use the glob operator: <code>use std::storage::storage_bytes::*</code>.</p>
</blockquote>
<p>The following demonstrates how to write to a <code>StorageBytes</code>:</p>
<pre><code class="language-sway">        // Setup Bytes
        let mut my_bytes = Bytes::new();
        my_bytes.push(1u8);
        my_bytes.push(2u8);
        my_bytes.push(3u8);

        // Write to storage
        storage.storage_bytes.write_slice(my_bytes);
</code></pre>
<p>The following demonstrates how to read from a <code>StorageBytes</code>:</p>
<pre><code class="language-sway">        let stored_bytes: Bytes = storage.storage_bytes.read_slice().unwrap();
</code></pre>
<h3 id="storagestring"><a class="header" href="#storagestring"><code>StorageString</code></a></h3>
<p>Storage of <code>String</code> is available in the standard library as <code>StorageString</code> which have to be defined inside a <code>storage</code> block. <code>StorageString</code> cannot be manipulated in the same way a <code>StorageVec&lt;T&gt;</code> or <code>StorageMap&lt;K, V&gt;</code>. Only the entirety of a <code>String</code> may be read/written to storage.</p>
<p>The following demonstrates how to import <code>StorageString</code>:</p>
<pre><code class="language-sway">use std::storage::storage_string::*;

storage {
    storage_map: StorageMap&lt;u64, bool&gt; = StorageMap {},
    storage_vec: StorageVec&lt;b256&gt; = StorageVec {},
    storage_string: StorageString = StorageString {},
    storage_bytes: StorageBytes = StorageBytes {},
}

abi StorageExample {
    #[storage(write)]
    fn store_map();
    #[storage(read)]
    fn get_map();
    #[storage(write)]
    fn store_vec();
    #[storage(read, write)]
    fn get_vec();
    #[storage(write)]
    fn store_string();
    #[storage(read)]
    fn get_string();
    #[storage(write)]
    fn store_bytes();
    #[storage(read)]
    fn get_bytes();
}

impl StorageExample for Contract {
    #[storage(write)]
    fn store_map() {
        storage.storage_map.insert(12, true);
        storage.storage_map.insert(59, false);

        // try_insert() will only insert if a value does not already exist for a key.
        let result = storage.storage_map.try_insert(103, true);
        assert(result.is_ok());
    }
    #[storage(read)]
    fn get_map() {
        // Access directly
        let stored_val1: bool = storage.storage_map.get(12).try_read().unwrap_or(false);

        // First get the storage key and then access the value.
        let storage_key2: StorageKey&lt;bool&gt; = storage.storage_map.get(59);
        let stored_val2: bool = storage_key2.try_read().unwrap_or(false);

        // Unsafely access the value.
        let stored_val3: bool = storage.storage_map.get(103).read();
    }

    #[storage(write)]
    fn store_vec() {
        storage
            .storage_vec
            .push(0x1111111111111111111111111111111111111111111111111111111111111111);
        storage
            .storage_vec
            .push(0x0000000000000000000000000000000000000000000000000000000000000001);
        storage
            .storage_vec
            .push(0x0000000000000000000000000000000000000000000000000000000000000002);

        // Set will overwrite the element stored at the given index.
        storage.storage_vec.set(2, b256::zero());
    }
    #[storage(read, write)]
    fn get_vec() {
        // Method 1: Access the element directly
        // Note: get() does not remove the element from the vec.
        let stored_val1: b256 = storage.storage_vec.get(0).unwrap().try_read().unwrap_or(b256::zero());

        // Method 2: First get the storage key and then access the value.
        let storage_key2: StorageKey&lt;b256&gt; = storage.storage_vec.get(1).unwrap();
        let stored_val2: b256 = storage_key2.try_read().unwrap_or(b256::zero());

        // pop() will remove the last element from the vec.
        let length: u64 = storage.storage_vec.len();
        let stored_val3: b256 = storage.storage_vec.pop().unwrap();
        assert(length != storage.storage_vec.len());
    }

    #[storage(write)]
    fn store_string() {
        let my_string = String::from_ascii_str("Fuel is blazingly fast");
        storage.storage_string.write_slice(my_string);
    }
    #[storage(read)]
    fn get_string() {
        let stored_string: String = storage.storage_string.read_slice().unwrap();
    }

    #[storage(write)]
    fn store_bytes() {
        // Setup Bytes
        let mut my_bytes = Bytes::new();
        my_bytes.push(1u8);
        my_bytes.push(2u8);
        my_bytes.push(3u8);

        // Write to storage
        storage.storage_bytes.write_slice(my_bytes);
    }
    #[storage(read)]
    fn get_bytes() {
        let stored_bytes: Bytes = storage.storage_bytes.read_slice().unwrap();
    }
}
</code></pre>
<blockquote>
<p><strong>NOTE</strong>: When importing the <code>StorageString</code>, please be sure to use the glob operator: <code>use std::storage::storage_string::*</code>.</p>
</blockquote>
<p>The following demonstrates how to write to a <code>StorageString</code>:</p>
<pre><code class="language-sway">        let my_string = String::from_ascii_str("Fuel is blazingly fast");
        storage.storage_string.write_slice(my_string);
</code></pre>
<p>The following demonstrates how to read from a <code>StorageString</code>:</p>
<pre><code class="language-sway">        let stored_string: String = storage.storage_string.read_slice().unwrap();
</code></pre>
<h2 id="advanced-storage"><a class="header" href="#advanced-storage">Advanced Storage</a></h2>
<p>For more advanced storage techniques please refer to the <a href="blockchain-development/../advanced/advanced_storage.html">Advanced Storage</a> page.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="purity"><a class="header" href="#purity">Purity</a></h1>
<!-- This section should explain pure functions in Sway -->
<!-- pure:example:start -->
<p>A function is <em>pure</em> if it does not access any <a href="blockchain-development/./storage.html">persistent storage</a>. Conversely, the function is <em>impure</em> if it does access any storage. Naturally, as storage is only available in smart contracts, impure functions cannot be used in predicates, scripts, or libraries. A pure function cannot call an impure function.</p>
<p>In Sway, functions are pure by default but can be opted into impurity via the <code>storage</code> function attribute. The <code>storage</code> attribute may take <code>read</code> and/or <code>write</code> arguments indicating which type of access the function requires.</p>
<p>The <code>storage</code> attribute without any arguments, <code>#[storage()]</code>, indicates a pure function, and has the same effect as not having the attribute at all.</p>
<!-- pure:example:end -->
<pre><code class="language-sway">#[storage(read)]
fn get_amount() -&gt; u64 {
    ...
}

#[storage(read, write)]
fn increment_amount(increment: u64) -&gt; u64 {
    ...
}

fn a_pure_function() {
    ...
}

#[storage()]
fn also_a_pure_function() {
    ...
}
</code></pre>
<blockquote>
<p><strong>Note</strong>: the <code>#[storage(write)]</code> attribute also permits a function to read from storage. This is due to the fact that partially writing a storage slot requires first reading the slot.</p>
</blockquote>
<!-- This section should explain impure functions in Sway -->
<!-- impure:example:start -->
<p>Impure functions which call other impure functions must have at least the same storage privileges or a superset of those for the function called. For example, to call a function with write access a caller must also have write access, or both read and write access. To call a function with read and write access the caller must also have both privileges.</p>
<!-- impure:example:end -->
<p>The <code>storage</code> attribute may also be applied to <a href="blockchain-development/../basics/methods_and_associated_functions.html">methods and associated functions</a>, <a href="blockchain-development/../advanced/traits.html">trait</a> and <a href="blockchain-development/../sway-program-types/smart_contracts.html#the-abi-declaration">ABI</a> declarations.</p>
<!-- This section should explain the benefits of using pure functions in Sway -->
<!-- pure_benefits:example:start -->
<p>A pure function gives you some guarantees: you will not incur excessive storage gas costs, the compiler can apply additional optimizations, and they are generally easy to reason about and audit.</p>
<blockquote>
<p><strong>Note</strong>: Purity does not provide an absolute guarantee that a storage access will not happen as a result of calling a pure function. E.g., it is possible for a pure function to call another contract, which can then call a write function in the original contract. The guarantee that the purity gives in this example is, that the original pure function itself does not change the storage, as well as that any function later called, that accesses storage, is clearly marked as impure.</p>
</blockquote>
<!-- pure_benefits:example:end -->
<p><a href="https://docs.soliditylang.org/en/v0.8.10/contracts.html#pure-functions">A similar concept exists in Solidity</a>. Note that Solidity refers to contract storage as <em>contract state</em>, and in the Sway/Fuel ecosystem, these two terms are largely interchangeable.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="identifiers"><a class="header" href="#identifiers">Identifiers</a></h1>
<p>Addresses in Sway are similar to EVM addresses. The two major differences are:</p>
<ol>
<li>Sway addresses are 32 bytes long (instead of 20)</li>
<li>Sway addresses are computed with the SHA-256 hash of the public key instead of the keccak-256 hash.</li>
</ol>
<p>Contracts, on the other hand, are uniquely identified with a contract ID rather than an address. A contract's ID is also 32 bytes long and is calculated <a href="https://fuellabs.github.io/fuel-specs/master/protocol/id/contract">here</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="native-assets"><a class="header" href="#native-assets">Native Assets</a></h1>
<!-- This section should explain native assets in Sway -->
<!-- native_assets:example:start -->
<p>The FuelVM has built-in support for working with multiple assets.</p>
<h2 id="key-differences-between-evm-and-fuelvm-assets"><a class="header" href="#key-differences-between-evm-and-fuelvm-assets">Key Differences Between EVM and FuelVM Assets</a></h2>
<h3 id="erc-20-vs-native-asset"><a class="header" href="#erc-20-vs-native-asset">ERC-20 vs Native Asset</a></h3>
<p>On the EVM, Ether is the native asset. As such, sending ETH to an address or contract is an operation built into the EVM, meaning it doesn't rely on the existence of a smart contract to update balances to track ownership as with ERC-20 tokens.</p>
<p>On the FuelVM, <em>all</em> assets are native and the process for sending <em>any</em> native asset is the same.</p>
<p>While you would still need a smart contract to handle the minting and burning of assets, the sending and receiving of these assets can be done independently of the asset contract.</p>
<p>Just like the EVM however, Fuel has a standard that describes a standard API for Native Assets using the Sway Language. The ERC-20 equivalent for the Sway Language is the <a href="https://github.com/FuelLabs/sway-standards/blob/master/docs/src/src-20-native-asset.md">SRC-20; Native Asset Standard</a>.</p>
<blockquote>
<p><strong>NOTE</strong> It is important to note that Fuel does not have tokens.</p>
</blockquote>
<h3 id="erc-721-vs-native-asset"><a class="header" href="#erc-721-vs-native-asset">ERC-721 vs Native Asset</a></h3>
<p>On the EVM, an ERC-721 token or NFT is a contract that contains multiple tokens which are non-fungible with one another.</p>
<p>On the FuelVM, the ERC-721 equivalent is a Native Asset where each asset has a supply of one. This is defined in the <a href="https://github.com/FuelLabs/sway-standards/blob/master/docs/src/src-20-native-asset.md#non-fungible-asset-restrictions">SRC-20; Native Asset Standard</a> under the Non-Fungible Asset Restrictions.</p>
<p>In practice, this means all NFTs are treated the same as any other Native Asset on Fuel. When writing Sway code, no additional cases for handling non-fungible and fungible assets are required.</p>
<h3 id="no-token-approvals"><a class="header" href="#no-token-approvals">No Token Approvals</a></h3>
<p>An advantage Native Assets bring is that there is no need for token approvals; as with Ether on the EVM. With millions of dollars hacked every year due to misused token approvals, the FuelVM eliminates this attack vector.</p>
<h3 id="asset-vs-coin-vs-token"><a class="header" href="#asset-vs-coin-vs-token">Asset vs Coin vs Token</a></h3>
<p>An "Asset" is a Native Asset on Fuel and has the associated <code>AssetId</code> type. Assets are distinguishable from one another. A "Coin" represents a singular unit of an Asset. Coins of the same Asset are not distinguishable from one another.</p>
<p>Fuel does not use tokens like other ecosystems such as Ethereum and uses Native Assets with a UTXO design instead.</p>
<h2 id="the-assetid-type"><a class="header" href="#the-assetid-type">The <code>AssetId</code> type</a></h2>
<p>The <code>AssetId</code> type represents any Native Asset on Fuel. An <code>AssetId</code> is used for interacting with an asset on the network.</p>
<p>The <code>AssetId</code> of any Native Asset on Fuel is calculated by taking the SHA256 hash digest of the originating <code>ContractId</code> that minted the asset and a <code>SubId</code> i.e. <code>sha256((contract_id, sub_id))</code>.</p>
<h3 id="creating-a-new-assetid"><a class="header" href="#creating-a-new-assetid">Creating a New <code>AssetId</code></a></h3>
<p>There are 3 ways to instantiate a new <code>AssetId</code>:</p>
<h4 id="default"><a class="header" href="#default">Default</a></h4>
<p>When a contract will only ever mint a single asset, it is recommended to use the <code>DEFAULT_ASSET_ID</code> sub id. This is referred to as the default asset of a contract.</p>
<p>To get the default asset from an internal contract call, call the <code>default()</code> function:</p>
<pre><code class="language-sway">    let asset_id: AssetId = AssetId::default();
</code></pre>
<h4 id="new"><a class="header" href="#new">New</a></h4>
<p>If a contract mints multiple assets or if the asset has been minted by an external contract, the <code>new()</code> function will be needed. The <code>new()</code> function takes the <code>ContractId</code> of the contract which minted the token as well as a <code>SubId</code>.</p>
<p>To create a new <code>AssetId</code> using a <code>ContractId</code> and <code>SubId</code>, call the <code>new()</code> function:</p>
<pre><code class="language-sway">    let my_contract_id: ContractId = ContractId::from(0x1000000000000000000000000000000000000000000000000000000000000000);
    let my_sub_id: SubId = 0x2000000000000000000000000000000000000000000000000000000000000000;

    let asset_id: AssetId = AssetId::new(my_contract_id, my_sub_id);
</code></pre>
<h4 id="from"><a class="header" href="#from">From</a></h4>
<p>In the case where the <code>b256</code> value of an asset is already known, you may call the <code>from()</code> function with the <code>b256</code> value.</p>
<pre><code class="language-sway">    let asset_id: AssetId = AssetId::from(0x0000000000000000000000000000000000000000000000000000000000000000);
</code></pre>
<h2 id="the-subid-type"><a class="header" href="#the-subid-type">The <code>SubId</code> type</a></h2>
<p>The SubId is used to differentiate between different assets that are created by the same contract. The <code>SubId</code> is a <code>b256</code> value.</p>
<p>When creating a single new asset on Fuel, we recommend using the <code>DEFAULT_SUB_ID</code> or <code>SubId::zero()</code>.</p>
<h2 id="the-base-asset"><a class="header" href="#the-base-asset">The Base Asset</a></h2>
<p>On the Fuel Network, the base asset is Ether. This is the only asset on the Fuel Network that does not have a <code>SubId</code>.</p>
<p>The Base Asset can be returned anytime by calling the <code>base()</code> function of the <code>AssetId</code> type.</p>
<pre><code class="language-sway">    let base_asset: AssetId = AssetId::base();
</code></pre>
<h2 id="basic-native-asset-functionality"><a class="header" href="#basic-native-asset-functionality">Basic Native Asset Functionality</a></h2>
<h3 id="minting-a-native-asset"><a class="header" href="#minting-a-native-asset">Minting A Native Asset</a></h3>
<p>To mint a new asset, the <code>std::asset::mint()</code> function must be called internally within a contract. A <code>SubId</code> and amount of coins must be provided. These newly minted coins will be owned by the contract which minted them. To mint another asset from the same contract, replace the <code>DEFAULT_SUB_ID</code> with your desired <code>SubId</code>.</p>
<pre><code class="language-sway">        mint(DEFAULT_SUB_ID, mint_amount);
</code></pre>
<p>You may also mint an asset to a specific entity with the <code>std::asset::mint_to()</code> function. Be sure to provide a target <code>Identity</code> that will own the newly minted coins.</p>
<pre><code class="language-sway">        mint_to(target_identity, DEFAULT_SUB_ID, mint_amount);
</code></pre>
<p>If you intend to allow external users to mint assets using your contract, the <a href="https://github.com/FuelLabs/sway-standards/blob/master/docs/src/src-3-minting-and-burning.md#fn-mintrecipient-identity-vault_sub_id-subid-amount-u64">SRC-3; Mint and Burn Standard</a> defines a standard API for minting assets. The <a href="https://fuellabs.github.io/sway-libs/book/asset/supply.html">Sway-Libs Asset Library</a> also provides an additional library to support implementations of the SRC-3 Standard into your contract.</p>
<h3 id="burning-a-native-asset"><a class="header" href="#burning-a-native-asset">Burning a Native Asset</a></h3>
<p>To burn an asset, the <code>std::asset::burn()</code> function must be called internally from the contract which minted them. The <code>SubId</code> used to mint the coins and amount must be provided. The burned coins must be owned by the contract. When an asset is burned it doesn't exist anymore.</p>
<pre><code class="language-sway">        burn(DEFAULT_SUB_ID, burn_amount);
</code></pre>
<p>If you intend to allow external users to burn assets using your contract, the <a href="https://github.com/FuelLabs/sway-standards/blob/master/docs/src/src-3-minting-and-burning.md#fn-mintrecipient-identity-vault_sub_id-subid-amount-u64">SRC-3; Mint and Burn Standard</a> defines a standard API for burning assets. The <a href="https://fuellabs.github.io/sway-libs/book/asset/supply.html">Sway-Libs Asset Library</a> also provides an additional library to support implementations of the SRC-3 Standard into your contract.</p>
<h3 id="transfer-a-native-asset"><a class="header" href="#transfer-a-native-asset">Transfer a Native Asset</a></h3>
<p>To internally transfer a Native Asset, the <code>std::asset::transfer()</code> function must be called. A target <code>Identity</code> or user must be provided as well as the <code>AssetId</code> of the asset and an amount.</p>
<pre><code class="language-sway">        transfer(target, asset_id, coins);
</code></pre>
<h3 id="native-asset-and-transactions"><a class="header" href="#native-asset-and-transactions">Native Asset And Transactions</a></h3>
<h4 id="getting-the-transaction-asset"><a class="header" href="#getting-the-transaction-asset">Getting The Transaction Asset</a></h4>
<p>To query for the Native Asset sent in a transaction, you may call the <code>std::call_frames::msg_asset_id()</code> function.</p>
<pre><code class="language-sway">        let amount = msg_asset_id();
</code></pre>
<h4 id="getting-the-transaction-amount"><a class="header" href="#getting-the-transaction-amount">Getting The Transaction Amount</a></h4>
<p>To query for the amount of coins sent in a transaction, you may call the <code>std::context::msg_amount()</code> function.</p>
<pre><code class="language-sway">        let amount = msg_amount();
</code></pre>
<h3 id="native-assets-and-contracts"><a class="header" href="#native-assets-and-contracts">Native Assets and Contracts</a></h3>
<h4 id="checking-a-contracts-balance"><a class="header" href="#checking-a-contracts-balance">Checking A Contract's Balance</a></h4>
<p>To internally check a contract's balance, call the <code>std::context::this_balance()</code> function with the corresponding <code>AssetId</code>.</p>
<pre><code class="language-sway">        this_balance(asset_id)
</code></pre>
<p>To check the balance of an external contract, call the <code>std::context::balance_of()</code> function with the corresponding <code>AssetId</code>.</p>
<pre><code class="language-sway">        balance_of(target_contract, asset_id)
</code></pre>
<blockquote>
<p><strong>NOTE</strong> Due to the FuelVM's UTXO design, balances of <code>Address</code>'s cannot be returned in the Sway Language. This must be done off-chain using the SDK.</p>
</blockquote>
<h4 id="receiving-native-assets-in-a-contract"><a class="header" href="#receiving-native-assets-in-a-contract">Receiving Native Assets In A Contract</a></h4>
<p>By default, a contract may not receive a Native Asset in a contract call. To allow transferring of assets to the contract, add the <code>#[payable]</code> attribute to the function.</p>
<pre><code class="language-sway">    #[payable]
    fn deposit() {
        assert(msg_amount() &gt; 0);
    }
</code></pre>
<h2 id="native-asset-standards-1"><a class="header" href="#native-asset-standards-1">Native Asset Standards</a></h2>
<p>There are a number of standards developed to enable further functionality for Native Assets and help cross contract functionality. Information on standards can be found in the <a href="https://github.com/FuelLabs/sway-standards">Sway Standards Repo</a>.</p>
<p>We currently have the following standards for Native Assets:</p>
<ul>
<li><a href="https://github.com/FuelLabs/sway-standards/blob/master/docs/src/src-20-native-asset.md">SRC-20; Native Asset Standard</a> defines the implementation of a standard API for Native Assets using the Sway Language.</li>
<li><a href="https://github.com/FuelLabs/sway-standards/blob/master/docs/src/src-3-minting-and-burning.md">SRC-3; Mint and Burn Standard</a> is used to enable mint and burn functionality for Native Assets.</li>
<li><a href="https://github.com/FuelLabs/sway-standards/blob/master/docs/src/src-7-asset-metadata.md">SRC-7; Arbitrary Asset Metadata Standard</a> is used to store metadata for Native Assets.</li>
<li><a href="https://github.com/FuelLabs/sway-standards/blob/master/docs/src/src-6-vault.md">SRC-6; Vault Standard</a> defines the implementation of a standard API for asset vaults developed in Sway.</li>
</ul>
<h2 id="native-asset-libraries"><a class="header" href="#native-asset-libraries">Native Asset Libraries</a></h2>
<p>Additional Libraries have been developed to allow you to quickly create an deploy dApps that follow the <a href="https://github.com/FuelLabs/sway-standards">Sway Standards</a>.</p>
<ul>
<li><a href="https://fuellabs.github.io/sway-libs/book/asset/index.html">Asset Library</a> provides functionality to implement the <a href="https://github.com/FuelLabs/sway-standards/blob/master/docs/src/src-20-native-asset.md">SRC-20; Native Asset Standard</a>, <a href="https://github.com/FuelLabs/sway-standards/blob/master/docs/src/src-3-minting-and-burning.md">SRC-3; Mint and Burn Standard</a>, and <a href="https://github.com/FuelLabs/sway-standards/blob/master/docs/src/src-7-asset-metadata.md">SRC-7; Arbitrary Asset Metadata Standard</a> standards.</li>
</ul>
<!-- native_assets:example:end -->
<h2 id="single-native-asset-example"><a class="header" href="#single-native-asset-example">Single Native Asset Example</a></h2>
<p>In this fully fleshed out example, we show a native asset contract which mints a single asset. This is the equivalent to the ERC-20 Standard use in Ethereum. Note there are no token approval functions.</p>
<p>It implements the <a href="https://github.com/FuelLabs/sway-standards/blob/master/docs/src/src-20-native-asset.md">SRC-20; Native Asset</a>, <a href="https://github.com/FuelLabs/sway-standards/blob/master/docs/src/src-3-minting-and-burning.md">SRC-3; Mint and Burn</a>, and <a href="https://github.com/FuelLabs/sway-standards/blob/master/docs/src/src-5-ownership.md">SRC-5; Ownership</a> standards. It does not use any external libraries.</p>
<pre><code class="language-sway">// ERC20 equivalent in Sway.
contract;

use standards::{
    src3::SRC3,
    src5::{
        SRC5, 
        State, 
        AccessError,
    },
    src20::{
        SetDecimalsEvent, 
        SetNameEvent, 
        SetSymbolEvent, 
        SRC20, 
        TotalSupplyEvent,
    },
};
use std::{
    asset::{
        burn,
        mint_to,
    },
    call_frames::msg_asset_id,
    constants::DEFAULT_SUB_ID,
    context::msg_amount,
    string::String,
    contract_id::ContractId
};

configurable {
    DECIMALS: u8 = 9u8,
    NAME: str[7] = __to_str_array("MyAsset"),
    SYMBOL: str[5] = __to_str_array("MYTKN"),
}

storage {
    total_supply: u64 = 0,
    owner: State = State::Uninitialized,
}

// Native Asset Standard
impl SRC20 for Contract {
    #[storage(read)]
    fn total_assets() -&gt; u64 {
        1
    }

    #[storage(read)]
    fn total_supply(asset: AssetId) -&gt; Option&lt;u64&gt; {
        if asset == AssetId::default() {
            Some(storage.total_supply.read())
        } else {
            None
        }
    }

    #[storage(read)]
    fn name(asset: AssetId) -&gt; Option&lt;String&gt; {
        if asset == AssetId::default() {
            Some(String::from_ascii_str(from_str_array(NAME)))
        } else {
            None
        }
    }

    #[storage(read)]
    fn symbol(asset: AssetId) -&gt; Option&lt;String&gt; {
        if asset == AssetId::default() {
            Some(String::from_ascii_str(from_str_array(SYMBOL)))
        } else {
            None
        }
    }

    #[storage(read)]
    fn decimals(asset: AssetId) -&gt; Option&lt;u8&gt; {
        if asset == AssetId::default() {
            Some(DECIMALS)
        } else {
            None
        }
    }
}

// Ownership Standard
impl SRC5 for Contract {
    #[storage(read)]
    fn owner() -&gt; State {
        storage.owner.read()
    }
}

// Mint and Burn Standard
impl SRC3 for Contract {
    #[storage(read, write)]
    fn mint(recipient: Identity, sub_id: Option&lt;SubId&gt;, amount: u64) {
        require(sub_id.is_some() &amp;&amp; sub_id.unwrap() == DEFAULT_SUB_ID, "incorrect-sub-id");
        require_access_owner();

        let new_supply = storage.total_supply.read() + amount;
        storage
            .total_supply
            .write(new_supply);
        mint_to(recipient, DEFAULT_SUB_ID, amount);
        
        TotalSupplyEvent::new(
            AssetId::default(), 
            new_supply, 
            msg_sender().unwrap()
        ).log();
    }

    #[storage(read, write)]
    fn burn(sub_id: SubId, amount: u64) {
        require(sub_id == DEFAULT_SUB_ID, "incorrect-sub-id");
        require(msg_amount() &gt;= amount, "incorrect-amount-provided");
        require(
            msg_asset_id() == AssetId::default(),
            "incorrect-asset-provided",
        );
        require_access_owner();

        let new_supply = storage.total_supply.read() - amount;
        storage
            .total_supply
            .write(new_supply);
        burn(DEFAULT_SUB_ID, amount);
        
        TotalSupplyEvent::new(
            AssetId::default(), 
            new_supply, 
            msg_sender().unwrap()
        ).log();
    }
}

abi SingleAsset {
    #[storage(read, write)]
    fn constructor(owner_: Identity);
}

impl SingleAsset for Contract {
    #[storage(read, write)]
    fn constructor(owner_: Identity) {
        require(storage.owner.read() == State::Uninitialized, "owner-initialized");
        storage.owner.write(State::Initialized(owner_));
    }
}

#[storage(read)]
fn require_access_owner() {
    require(
        storage.owner.read() == State::Initialized(msg_sender().unwrap()),
        AccessError::NotOwner,
    );
}

abi EmitSRC20Events {
    fn emit_src20_events();
}

impl EmitSRC20Events for Contract {
    fn emit_src20_events() {
        // Metadata that is stored as a configurable should only be emitted once.
        let asset = AssetId::default();
        let sender = msg_sender().unwrap();
        let name = Some(String::from_ascii_str(from_str_array(NAME)));
        let symbol = Some(String::from_ascii_str(from_str_array(SYMBOL)));

        SetNameEvent::new(asset, name, sender).log();
        SetSymbolEvent::new(asset, symbol, sender).log();
        SetDecimalsEvent::new(asset, DECIMALS, sender).log();
    }
}
</code></pre>
<h2 id="multi-native-asset-example"><a class="header" href="#multi-native-asset-example">Multi Native Asset Example</a></h2>
<p>In this fully fleshed out example, we show a native asset contract which mints multiple assets. This is the equivalent to the ERC-1155 Standard use in Ethereum. Note there are no token approval functions.</p>
<p>It implements the <a href="https://github.com/FuelLabs/sway-standards/blob/master/docs/src/src-20-native-asset.md">SRC-20; Native Asset</a>, <a href="https://github.com/FuelLabs/sway-standards/blob/master/docs/src/src-3-minting-and-burning.md">SRC-3; Mint and Burn</a>, and <a href="https://github.com/FuelLabs/sway-standards/blob/master/docs/src/src-5-ownership.md">SRC-5; Ownership</a> standards. It does not use any external libraries.</p>
<pre><code class="language-sway">// ERC1155 equivalent in Sway.
contract;

use standards::{
    src5::{
        SRC5, 
        State, 
        AccessError
    },
    src20::{
        SetDecimalsEvent, 
        SetNameEvent, 
        SetSymbolEvent, 
        SRC20, 
        TotalSupplyEvent,
    }
    src3::SRC3,
};
use std::{
    asset::{
        burn,
        mint_to,
    },
    call_frames::msg_asset_id,
    hash::{
        Hash,
    },
    context::this_balance,
    storage::storage_string::*,
    string::String,
    contract_id::ContractId
};

storage {
    total_assets: u64 = 0,
    total_supply: StorageMap&lt;AssetId, u64&gt; = StorageMap {},
    name: StorageMap&lt;AssetId, StorageString&gt; = StorageMap {},
    symbol: StorageMap&lt;AssetId, StorageString&gt; = StorageMap {},
    decimals: StorageMap&lt;AssetId, u8&gt; = StorageMap {},
    owner: State = State::Uninitialized,
}

// Native Asset Standard
impl SRC20 for Contract {
    #[storage(read)]
    fn total_assets() -&gt; u64 {
        storage.total_assets.read()
    }

    #[storage(read)]
    fn total_supply(asset: AssetId) -&gt; Option&lt;u64&gt; {
        storage.total_supply.get(asset).try_read()
    }

    #[storage(read)]
    fn name(asset: AssetId) -&gt; Option&lt;String&gt; {
        storage.name.get(asset).read_slice()
    }
    
    #[storage(read)]
    fn symbol(asset: AssetId) -&gt; Option&lt;String&gt; {
        storage.symbol.get(asset).read_slice()
    }

    #[storage(read)]
    fn decimals(asset: AssetId) -&gt; Option&lt;u8&gt; {
        storage.decimals.get(asset).try_read()
    }
}

// Mint and Burn Standard
impl SRC3 for Contract {
    #[storage(read, write)]
    fn mint(recipient: Identity, sub_id: Option&lt;SubId&gt;, amount: u64) {
        require(sub_id.is_some(), "Error: SubId is None");
        require_access_owner();

        let asset_id = AssetId::new(ContractId::this(), sub_id.unwrap());
        let supply = storage.total_supply.get(asset_id).try_read();
        if supply.is_none() {
            storage.total_assets.write(storage.total_assets.try_read().unwrap_or(0) + 1);
        }
        let new_supply = supply.unwrap_or(0) + amount;
        storage.total_supply.insert(asset_id, new_supply);
        mint_to(recipient, sub_id, amount);
        
        TotalSupplyEvent::new(
            asset_id, 
            new_supply, 
            msg_sender().unwrap()
        ).log();
    }
    
    #[storage(read, write)]
    fn burn(sub_id: SubId, amount: u64) {
        require_access_owner();
        let asset_id = AssetId::new(ContractId::this(), sub_id);
        require(this_balance(asset_id) &gt;= amount, "not-enough-coins");
        
        let supply = storage.total_supply.get(asset_id).try_read();
        let new_supply = supply.unwrap_or(0) - amount;
        storage.total_supply.insert(asset_id, new_supply);
        burn(sub_id, amount);

        TotalSupplyEvent::new(
            asset_id, 
            new_supply, 
            msg_sender().unwrap()
        ).log();
    }
}

abi MultiAsset {
    #[storage(read, write)]
    fn constructor(owner_: Identity);
    
    #[storage(read, write)]
    fn set_name(asset: AssetId, name: Option&lt;String&gt;);

    #[storage(read, write)]
    fn set_symbol(asset: AssetId, symbol: Option&lt;String&gt;);

    #[storage(read, write)]
    fn set_decimals(asset: AssetId, decimals: u8);
}

impl MultiAsset for Contract {
    #[storage(read, write)]
    fn constructor(owner_: Identity) {
        require(storage.owner.read() == State::Uninitialized, "owner-initialized");
        storage.owner.write(State::Initialized(owner_));
    }
    
    #[storage(read, write)]
    fn set_name(asset: AssetId, name: Option&lt;String&gt;) {
        require_access_owner();
        storage.name.insert(asset, StorageString {});
        storage.name.get(asset).write_slice(name);

        SetNameEvent::new(asset, name, msg_sender().unwrap()).log();
    }

    #[storage(read, write)]
    fn set_symbol(asset: AssetId, symbol: Option&lt;String&gt;) {
        require_access_owner();
        storage.symbol.insert(asset, StorageString {});
        storage.symbol.get(asset).write_slice(symbol);

        SetSymbolEvent::new(asset, symbol, msg_sender().unwrap()).log();
    }

    #[storage(read, write)]
    fn set_decimals(asset: AssetId, decimals: u8) {
        require_access_owner();
        storage.decimals.insert(asset, decimals);

        SetDecimalsEvent::new(asset, decimals, msg_sender().unwrap()).log();
    }
}

#[storage(read)]
fn require_access_owner() {
    require(
        storage.owner.read() == State::Initialized(msg_sender().unwrap()),
        AccessError::NotOwner,
    );
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="access-control"><a class="header" href="#access-control">Access Control</a></h1>
<!-- This section should explain access control in Sway -->
<!-- access_control:example:start -->
<p>Smart contracts require the ability to restrict access to and identify certain users or contracts. Unlike account-based blockchains, transactions in UTXO-based blockchains (i.e. Fuel) do not necessarily have a unique transaction sender. Additional logic is needed to handle this difference, and is provided by the standard library.</p>
<!-- access_control:example:end -->
<h2 id="msg_sender"><a class="header" href="#msg_sender"><code>msg_sender</code></a></h2>
<!-- This section should explain what the `msg_sender` method is -->
<!-- msg_sender:example:start -->
<p>To deliver an experience akin to the EVM's access control, the <code>std</code> library provides a <code>msg_sender</code> function, which identifies a unique caller based upon the call and/or transaction input data.</p>
<!-- msg_sender:example:end -->
<pre><code class="language-sway">contract;

abi MyOwnedContract {
    fn receive(field_1: u64) -&gt; bool;
}

const OWNER = Address::from(0x9ae5b658754e096e4d681c548daf46354495a437cc61492599e33fc64dcdc30c);

impl MyOwnedContract for Contract {
    fn receive(field_1: u64) -&gt; bool {
        let sender = msg_sender().unwrap();
        if let Identity::Address(addr) = sender {
            assert(addr == OWNER);
        } else {
            revert(0);
        }

        true
    }
}
</code></pre>
<!-- This section should explain how the `msg_sender` method works -->
<!-- msg_sender_details:example:start -->
<p>The <code>msg_sender</code> function works as follows:</p>
<ul>
<li>If the caller is a contract, then <code>Ok(Sender)</code> is returned with the <code>ContractId</code> sender variant.</li>
<li>If the caller is external (i.e. from a script), then all coin input owners in the transaction are checked. If all owners are the same, then <code>Ok(Sender)</code> is returned with the <code>Address</code> sender variant.</li>
<li>If the caller is external and coin input owners are different, then the caller cannot be determined and a <code>Err(AuthError)</code> is returned.</li>
</ul>
<!-- msg_sender_details:example:end -->
<h2 id="contract-ownership"><a class="header" href="#contract-ownership">Contract Ownership</a></h2>
<p>Many contracts require some form of ownership for access control. The <a href="https://github.com/FuelLabs/sway-standards/blob/master/docs/src/src-5-ownership.md">SRC-5 Ownership Standard</a> has been defined to provide an interoperable interface for ownership within contracts.</p>
<p>To accomplish this, use the <a href="https://fuellabs.github.io/sway-libs/book/ownership/index.html">Ownership Library</a> to keep track of the owner. This allows setting and revoking ownership using the variants <code>Some(..)</code> and <code>None</code> respectively. This is better, safer, and more readable than using the <code>Identity</code> type directly where revoking ownership has to be done using some magic value such as <code>b256::zero()</code> or otherwise.</p>
<ul>
<li>The following is an example of how to properly lock a function such that only the owner may call a function:</li>
</ul>
<pre><code class="language-sway">    #[storage(read)]
    fn only_owner() {
        storage.owner.only_owner();
        // Do stuff here
    }
</code></pre>
<p>Setting ownership can be done in one of two ways; During compile time or run time.</p>
<ul>
<li>The following is an example of how to properly set ownership of a contract during compile time:</li>
</ul>
<pre><code class="language-sway">storage {
    owner: Ownership = Ownership::initialized(Identity::Address(Address::zero())),
}
</code></pre>
<ul>
<li>The following is an example of how to properly set ownership of a contract during run time:</li>
</ul>
<pre><code class="language-sway">    #[storage(write)]
    fn set_owner(identity: Identity) {
        storage.owner.set_ownership(identity);
    }
</code></pre>
<ul>
<li>The following is an example of how to properly revoke ownership of a contract:</li>
</ul>
<pre><code class="language-sway">    #[storage(write)]
    fn revoke_ownership() {
        storage.owner.renounce_ownership();
    }
</code></pre>
<ul>
<li>The following is an example of how to properly retrieve the state of ownership:</li>
</ul>
<pre><code class="language-sway">    #[storage(read)]
    fn owner() -&gt; State {
        storage.owner.owner()
    }
</code></pre>
<h2 id="access-control-libraries"><a class="header" href="#access-control-libraries">Access Control Libraries</a></h2>
<p><a href="blockchain-development/../reference/sway_libs.html">Sway-Libs</a> provides the following libraries to enable further access control.</p>
<ul>
<li><a href="https://fuellabs.github.io/sway-libs/book/ownership/index.html">Ownership Library</a>; used to apply restrictions on functions such that only a <strong>single</strong> user may call them. This library provides helper functions for the <a href="https://github.com/FuelLabs/sway-standards/blob/master/docs/src/src-5-ownership.md">SRC-5; Ownership Standard</a>.</li>
<li><a href="https://fuellabs.github.io/sway-libs/book/admin/index.html">Admin Library</a>; used to apply restrictions on functions such that only a select few users may call them like a whitelist.</li>
<li><a href="https://fuellabs.github.io/sway-libs/book/pausable/index.html">Pausable Library</a>; allows contracts to implement an emergency stop mechanism.</li>
<li><a href="https://fuellabs.github.io/sway-libs/book/reentrancy/index.html">Reentrancy Guard Library</a>; used to detect and prevent reentrancy attacks.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="calling-contracts"><a class="header" href="#calling-contracts">Calling Contracts</a></h1>
<p>Smart contracts can be <em>called</em> by other contracts or scripts. In the FuelVM, this is done primarily with the <a href="https://fuellabs.github.io/fuel-specs/master/vm/instruction_set#call-call-contract"><code>call</code></a> instruction.</p>
<p>Sway provides a nice way to manage callable interfaces with its ABI system. The Fuel ABI specification can be found <a href="https://fuellabs.github.io/fuel-specs/master/protocol/abi">here</a>.</p>
<h2 id="example-2"><a class="header" href="#example-2">Example</a></h2>
<p>Here is an example of a contract calling another contract in Sway. A script can call a contract in the same way.</p>
<pre><code class="language-sway">// ./contract_a.sw
contract;

abi ContractA {
    fn receive(field_1: bool, field_2: u64) -&gt; u64;
}

impl ContractA for Contract {
    fn receive(field_1: bool, field_2: u64) -&gt; u64 {
        assert(field_1 == true);
        assert(field_2 &gt; 0);
        return_45()
    }
}

fn return_45() -&gt; u64 {
  45
}
</code></pre>
<pre><code class="language-sway">// ./contract_b.sw
contract;

use contract_a::ContractA;

abi ContractB {
    fn make_call();
}

const contract_id = 0x79fa8779bed2f36c3581d01c79df8da45eee09fac1fd76a5a656e16326317ef0;

impl ContractB for Contract {
    fn make_call() {
      let x = abi(ContractA, contract_id);
      let return_value = x.receive(true, 3); // will be 45
    }
}
</code></pre>
<blockquote>
<p><strong>Note</strong>: The ABI is for external calls only therefore you cannot define a method in the ABI and call it in the same contract. If you want to define a function for a contract, but keep it private so that only your contract can call it, you can define it outside of the <code>impl</code> and call it inside the contract, similar to the <code>return_45()</code> function above.</p>
</blockquote>
<h2 id="advanced-calls"><a class="header" href="#advanced-calls">Advanced Calls</a></h2>
<p>All calls forward a gas stipend, and may additionally forward one native asset with the call.</p>
<p>Here is an example of how to specify the amount of gas (<code>gas</code>), the asset ID of the native asset (<code>asset_id</code>), and the amount of the native asset (<code>coins</code>) to forward:</p>
<pre><code class="language-sway">script;

abi MyContract {
    fn foo(field_1: bool, field_2: u64);
}

fn main() {
    let x = abi(MyContract, 0x79fa8779bed2f36c3581d01c79df8da45eee09fac1fd76a5a656e16326317ef0);
    let asset_id = 0x7777_7777_7777_7777_7777_7777_7777_7777_7777_7777_7777_7777_7777_7777_7777_7777;
    x.foo {
        gas: 5000, asset_id: asset_id, coins: 5000
    }
    (true, 3);
}
</code></pre>
<h2 id="handling-re-entrancy"><a class="header" href="#handling-re-entrancy">Handling Re-entrancy</a></h2>
<p>A common attack vector for smart contracts is <a href="https://docs.soliditylang.org/en/v0.8.4/security-considerations.html#re-entrancy">re-entrancy</a>. Similar to the EVM, the FuelVM allows for re-entrancy.</p>
<p>A <em>stateless</em> re-entrancy guard is included in the <a href="https://fuellabs.github.io/sway-libs/book/reentrancy/index.html"><code>sway-libs</code></a> library. The guard will panic (revert) at run time if re-entrancy is detected.</p>
<pre><code class="language-sway">contract;

use reentrancy::reentrancy_guard;

abi MyContract {
    fn some_method();
}

impl ContractB for Contract {
    fn some_method() {
        reentrancy_guard();
        // do something
    }
}
</code></pre>
<h3 id="cei-pattern-violation-static-analysis"><a class="header" href="#cei-pattern-violation-static-analysis">CEI pattern violation static analysis</a></h3>
<p>Another way of avoiding re-entrancy-related attacks is to follow the so-called
<em>CEI</em> pattern. CEI stands for "Checks, Effects, Interactions", meaning that the
contract code should first perform safety checks, also known as
"pre-conditions", then perform effects, i.e. modify or read the contract storage
and execute external contract calls (interaction) only at the very end of the
function/method.</p>
<p>Please see this <a href="https://fravoll.github.io/solidity-patterns/checks_effects_interactions.html">blog post</a>
for more detail on some vulnerabilities in case of storage modification after
interaction and this <a href="https://chainsecurity.com/curve-lp-oracle-manipulation-post-mortem">blog post</a> for
more information on storage reads after interaction.</p>
<p>The Sway compiler implements a check that the CEI pattern is not violated in the
user contract and issues warnings if that's the case.</p>
<p>For example, in the following contract the CEI pattern is violated, because an
external contract call is executed before a storage write.</p>
<pre><code class="language-sway">contract;

mod other_contract;

use other_contract::*;
use std::hash::*;

abi MyContract {
    #[storage(read, write)]
    fn withdraw(external_contract_id: ContractId);
}

storage {
    balances: StorageMap&lt;Identity, u64&gt; = StorageMap::&lt;Identity, u64&gt; {},
}

impl MyContract for Contract {
    #[storage(read, write)]
    fn withdraw(external_contract_id: ContractId) {
        let sender = msg_sender().unwrap();
        let bal = storage.balances.get(sender).try_read().unwrap_or(0);

        assert(bal &gt; 0);

        // External call
        let caller = abi(OtherContract, external_contract_id.into());
        caller.external_call {
            coins: bal,
        }();

        // Storage update _after_ external call
        storage.balances.insert(sender, 0);
    }
}
</code></pre>
<p>Here, <code>other_contract</code> is defined as follows:</p>
<pre><code class="language-sway">library;

abi OtherContract {
    #[payable]
    fn external_call();
}
</code></pre>
<p>The CEI pattern analyzer issues a warning as follows, pointing to the
interaction before a storage modification:</p>
<pre><code class="language-sh">warning
  --&gt; /path/to/contract/main.sw:28:9
   |
26 |
27 |           let caller = abi(OtherContract, external_contract_id.into());
28 |           caller.external_call { coins: bal }();
   |  _________-
29 | |
30 | |         // Storage update _after_ external call
31 | |         storage.balances.insert(sender, 0);
   | |__________________________________________- Storage write after external contract interaction in function or method "withdraw". Consider making all storage writes before calling another contract
32 |       }
33 |   }
   |
____
</code></pre>
<p>In case there is a storage read after an interaction, the CEI analyzer will issue a similar warning.</p>
<p>In addition to storage reads and writes after an interaction, the CEI analyzer reports analogous warnings about:</p>
<ul>
<li>balance tree updates, i.e. balance tree reads with subsequent writes, which may be produced by the <code>tr</code> and <code>tro</code> ASM instructions or library functions using them under the hood;</li>
<li>balance trees reads with <code>bal</code> instruction;</li>
<li>changes to the output messages that can be produced by the <code>__smo</code> intrinsic function or the <code>smo</code> ASM instruction.</li>
</ul>
<h2 id="differences-from-the-evm"><a class="header" href="#differences-from-the-evm">Differences from the EVM</a></h2>
<p>While the Fuel contract calling paradigm is similar to the EVM's (using an ABI, forwarding gas and data), it differs in <em>two</em> key ways:</p>
<ol>
<li>
<p><a href="blockchain-development/./native_assets.html"><strong>Native assets</strong></a>: FuelVM calls can forward any native asset not just base asset.</p>
</li>
<li>
<p><strong>No data serialization</strong>: Contract calls in the FuelVM do not need to serialize data to pass it between contracts; instead they simply pass a pointer to the data. This is because the FuelVM has a shared global memory which all call frames can read from.</p>
</li>
</ol>
<h2 id="fallback"><a class="header" href="#fallback">Fallback</a></h2>
<p>When a contract is compiled, a special section called "contract selection" is also generated. This section checks if the contract call method matches any of the available ABI methods. If this fails, one of two possible actions will happen:</p>
<p>1 - if no fallback function was specified, the contract will revert;
2 - otherwise, the fallback function will be called.</p>
<p>For all intents and purposes the fallback function is considered a contract method, which means that it has all the limitations that other contract methods have. As for the fallback function signature, the function cannot have arguments, but it can return anything.</p>
<p>If for some reason the fallback function needs to returns different types, the intrinsic <code>__contract_ret</code> can be used.</p>
<pre><code class="language-sway">contract;

abi MyContract {
    fn some_method();
}

impl MyContract for Contract {
    fn some_method() {
    }
}

#[fallback]
fn fallback() {
}
</code></pre>
<p>You may still access the method selector and call arguments in the fallback function.
For instance, let's assume a function <code>fn foobar(bool, u64) {}</code> gets called on a contract that doesn't have it, with arguments <code>true</code> and <code>42</code>.
It can execute the following fallback:</p>
<pre><code class="language-sway">#[fallback]
fn fallback() {
    // the method selector is the first four bytes of sha256("foobar(bool,u64)")
    // per https://fuellabs.github.io/fuel-specs/master/protocol/abi#function-selector-encoding
    let method_selector = std::call_frames::first_param::&lt;u64&gt;();

    // the arguments tuple is (true, 42)
    let arguments = std::call_frames::second_param::&lt;(bool, u64)&gt;();
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="external-code-execution"><a class="header" href="#external-code-execution">External Code Execution</a></h1>
<p>The <code>std-lib</code> includes a function called <code>run_external</code> that allows Sway contracts to execute arbitrary external Sway code.</p>
<p>This functionality enables features like upgradeable contracts and
proxies.</p>
<h2 id="upgradeable-contracts"><a class="header" href="#upgradeable-contracts">Upgradeable Contracts</a></h2>
<p>Upgradeable contracts are designed to allow the logic of a smart contract to be updated after deployment.</p>
<p>Consider this example proxy contract:</p>
<pre><code class="language-sway">#[namespace(my_storage_namespace)]
storage {
    target_contract: Option&lt;ContractId&gt; = None,
}

impl Proxy for Contract {
    #[storage(write)]
    fn set_target_contract(id: ContractId) {
        storage.target_contract.write(Some(id));
    }

    #[storage(read)]
    fn double_input(_value: u64) -&gt; u64 {
        let target = storage.target_contract.read().unwrap();
        run_external(target)
    }
}
</code></pre>
<p>The contract has two functions:</p>
<ul>
<li><code>set_target_contract</code> updates the <code>target_contract</code> variable in storage with the <code>ContractId</code> of an external contract.</li>
<li><code>double_input</code> reads the <code>target_contract</code> from storage and uses it to run external code. If the <code>target_contract</code> has a function with the same name (<code>double_input</code>), the code in the external <code>double_input</code> function will run.
In this case, the function will return a <code>u64</code>.</li>
</ul>
<p>Notice in the <code>Proxy</code> example above, the storage block has a <code>namespace</code> attribute. Using this attribute is considered a best practice for all proxy contracts in Sway, because it will prevent storage collisions with the implementation contract, as the implementation contract has access to both storage contexts.</p>
<p>Below is what an implementation contract could look like for this:</p>
<pre><code class="language-sway">storage {
    value: u64 = 0,
    // to stay compatible, this has to stay the same in the next version
}

impl Implementation for Contract {
    #[storage(write)]
    fn double_input(value: u64) -&gt; u64 {
        let new_value = value * 2;
        storage.value.write(new_value);
        new_value
    }
}
</code></pre>
<p>This contract has one function called <code>double_input</code>, which calculates the input value times two, updates the <code>value</code> variable in storage, and returns the new value.</p>
<h2 id="how-does-this-differ-from-calling-a-contract"><a class="header" href="#how-does-this-differ-from-calling-a-contract">How does this differ from calling a contract?</a></h2>
<p>There are a couple of major differences between calling a contract directly and using the <code>run_external</code> method.</p>
<p>First, to use <code>run_external</code>, the ABI of the external contract is not required. The proxy contract has no knowledge of the external contract except for its <code>ContractId</code>.</p>
<h3 id="upgradeable-contract-storage"><a class="header" href="#upgradeable-contract-storage">Upgradeable Contract Storage</a></h3>
<p>Second, the storage context of the proxy contract is retained for the loaded code.
This means that in the examples above, the <code>value</code> variable gets updated in the storage for the <em>proxy</em> contract.</p>
<p>For example, if you were to read the <code>value</code> variable by directly calling the implementation contract, you would get a different result than if you read it through the proxy contract.
The proxy contract loads the code and executes it in its own context.</p>
<h2 id="fallback-functions"><a class="header" href="#fallback-functions">Fallback functions</a></h2>
<p>If the function name doesn't exist in the target contract but a <code>fallback</code> function does, the <code>fallback</code> function will be triggered.</p>
<blockquote>
<p>If there is no fallback function, the transaction will revert.</p>
</blockquote>
<p>You can access function parameters for fallback functions using the <code>call_frames</code> module in the <code>std-lib</code>.
For example, to access the <code>_foo</code> input parameter in the proxy function below, you can use the <code>called_args</code> method in the <code>fallback</code> function:</p>
<pre><code class="language-sway">    fn does_not_exist_in_the_target(_foo: u64) -&gt; u64 {
        run_external(TARGET)
    }
</code></pre>
<pre><code class="language-sway">#[fallback]
fn fallback() -&gt; u64 {
    use std::call_frames::*;
    __log(3);
    __log(called_method());
    __log("double_value");
    __log(called_method() == "double_value");
    let foo = called_args::&lt;u64&gt;();
    foo * 3
}
</code></pre>
<p>In this case, the <code>does_not_exist_in_the_target</code> function will return <code>_foo * 3</code>.</p>
<h2 id="limitations"><a class="header" href="#limitations">Limitations</a></h2>
<p>Some limitations of <code>run_external</code> function are:</p>
<ul>
<li>It can only be used with other contracts. Scripts, predicates, and library code cannot be run externally.</li>
<li>If you change the implementation contract, you must maintain the same order of previous storage variables and types, as this is what has been stored in the proxy storage.</li>
<li>You can't use the call stack in another call frame before you use <code>run_external</code>. You can only use the call stack within the call frame that contains <code>run_external</code>.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="time-library"><a class="header" href="#time-library">Time Library</a></h1>
<p>The <code>std::time</code> library provides utilities for handling time durations and timestamps in Sway smart contracts.</p>
<h2 id="duration"><a class="header" href="#duration">Duration</a></h2>
<p>Represents a span of time in seconds.</p>
<h3 id="creating-durations"><a class="header" href="#creating-durations">Creating Durations</a></h3>
<pre><code class="language-sway">fn create_durations() {
    // Using constants
    let zero = Duration::ZERO;
    let second = Duration::SECOND;
    let minute = Duration::MINUTE;
    let hour = Duration::HOUR;
    let day = Duration::DAY;
    let week = Duration::WEEK;

    // Using constructor methods
    let thirty_seconds = Duration::seconds(30);
    let two_hours = Duration::hours(2);
    let three_days = Duration::days(3);
}
</code></pre>
<h3 id="converting-durations"><a class="header" href="#converting-durations">Converting Durations</a></h3>
<p>Time <code>std::time</code> library supports conversion between different time scales such as <code>seconds</code>, <code>minutes</code>, <code>hours</code>, <code>days</code>, and <code>weeks</code>.</p>
<pre><code class="language-sway">fn convert_durations() {
    let two_days = Duration::days(2);

    assert(two_days.as_seconds() == 172800); // 2 * 86400
    assert(two_days.as_minutes() == 2880); // 2 * 1440
    assert(two_days.as_hours() == 48); // 2 * 24
    assert(two_days.as_days() == 2);
    assert(two_days.as_weeks() == 0); // Truncated value
}
</code></pre>
<h3 id="operations"><a class="header" href="#operations">Operations</a></h3>
<p>The <code>std::time</code> supports operations on the <code>Duration</code> type.</p>
<pre><code class="language-sway">fn duration_operations() {
    let day1 = Duration::DAY;
    let day2 = Duration::days(1);

    // Equality
    assert(day1 == day2);

    // Addition
    let two_days = day1 + day2;
    assert(two_days.as_days() == 2);

    // Subtraction
    let half_day = two_days - Duration::days(1).add(Duration::hours(12));
    assert(half_day.as_hours() == 12);

    // Comparison
    assert(Duration::MINUTE &lt; Duration::HOUR);
}
</code></pre>
<h2 id="time"><a class="header" href="#time">Time</a></h2>
<p>Represents a UNIX timestamp (seconds since Jan 1, 1970).</p>
<h3 id="creating-timestamps"><a class="header" href="#creating-timestamps">Creating Timestamps</a></h3>
<p>There are 3 major ways to create a new timestamp.</p>
<pre><code class="language-sway">fn create_timestamps() {
    // Current block time
    let now = Time::now();

    // Specific block time
    let block_time = Time::block(12345);

    // From UNIX timestamp
    let custom_time = Time::new(1672531200); // Jan 1, 2023 00:00:00 UTC
}
</code></pre>
<h3 id="time-operations"><a class="header" href="#time-operations">Time Operations</a></h3>
<p>Operations on the <code>Time</code> type are supported with conjunction of the <code>Duration</code> type.</p>
<pre><code class="language-sway">fn time_operations() {
    let now = Time::now();
    let yesterday = now.subtract(Duration::DAY);
    let tomorrow = now.add(Duration::DAY);

    // Duration calculations
    let elapsed = now.duration_since(yesterday).unwrap();
    assert(elapsed.as_days() == 1);

    // Comparison
    assert(yesterday &lt; now);
    assert(tomorrow &gt; now);
}
</code></pre>
<h3 id="tai64-conversion"><a class="header" href="#tai64-conversion">TAI64 Conversion</a></h3>
<p>The Fuel VM internally uses TAI64 time. Conversions between UNIX and TAI64 are maintained with the <code>Time</code> type.</p>
<pre><code class="language-sway">fn tai64_conversion() {
    let now = Time::now();

    // Convert to TAI64
    let tai64 = now.as_tai64();

    // Convert back to UNIX time
    let converted = Time::from_tai64(tai64);
    assert(now == converted);
}
</code></pre>
<h3 id="tai64-vs-unix-time"><a class="header" href="#tai64-vs-unix-time">TAI64 vs UNIX Time</a></h3>
<h4 id="conversion-details"><a class="header" href="#conversion-details">Conversion Details</a></h4>
<p>The library uses:</p>
<pre><code class="language-sway">const TAI_64_CONVERTER: u64 = 10 + (1 &lt;&lt; 62);
</code></pre>
<p>(1 &lt;&lt; 62) (0x4000000000000000) marks value as TAI64. 10 accounts for initial TAI-UTC offset in 1970.</p>
<p>Conversion formulas:</p>
<p><code>UNIX â†’ TAI64: tai64 = unix + TAI_64_CONVERTER</code></p>
<p><code>TAI64 â†’ UNIX: unix = tai64 - TAI_64_CONVERTER</code></p>
<h4 id="key-differences"><a class="header" href="#key-differences">Key Differences</a></h4>
<div class="table-wrapper"><table><thead><tr><th>Feature</th><th>TAI64</th><th>UNIX</th></tr></thead><tbody>
<tr><td>Epoch</td><td>1970-01-01 00:00:00 TAI</td><td>1970-01-01 00:00:00 UTC</td></tr>
<tr><td>Leap Seconds</td><td>No leap seconds</td><td>Includes leap seconds</td></tr>
<tr><td>Stability</td><td>Continuous time scale</td><td>Discontinuous adjustments</td></tr>
<tr><td>Value Range</td><td>(1 &lt;&lt; 62) + offset (10s)</td><td>Seconds since epoch</td></tr>
</tbody></table>
</div>
<h4 id="why-tai64"><a class="header" href="#why-tai64">Why TAI64?</a></h4>
<ul>
<li>Deterministic execution: No leap second ambiguities</li>
<li>Monotonic time: Always increases steadily</li>
<li>Blockchain-friendly: Aligns with Fuel's timestamp mechanism</li>
</ul>
<h2 id="best-practices"><a class="header" href="#best-practices">Best Practices</a></h2>
<ol>
<li>Use <code>Duration</code> for time spans instead of raw seconds</li>
<li>Always handle <code>TimeError</code> results from <code>duration_since()</code> and <code>elapsed()</code></li>
<li>Convert to TAI64 when interacting with blockchain primitives</li>
<li>Use <code>Time::block()</code> for historical time comparisons</li>
<li>Prefer duration constants (<code>SECOND</code>, <code>HOUR</code>, etc.) for readability</li>
</ol>
<h2 id="limitations-1"><a class="header" href="#limitations-1">Limitations</a></h2>
<ol>
<li>Durations only support second-level precision</li>
<li>Time comparisons are limited to u64 range (584 billion years)</li>
<li>No calendar/date functionality (only timestamps)</li>
<li>Duration conversions truncate fractional units</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="advanced-concepts"><a class="header" href="#advanced-concepts">Advanced Concepts</a></h1>
<p>Advanced concepts.</p>
<ul>
<li><a href="advanced/./advanced_types.html">Advanced Types</a></li>
<li><a href="advanced/./advanced_storage.html">Advanced Storage</a></li>
<li><a href="advanced/./generic_types.html">Generic Types</a></li>
<li><a href="advanced/./traits.html">Traits</a></li>
<li><a href="advanced/./associated_types.html">Associated Types</a></li>
<li><a href="advanced/./generics_and_trait_constraints.html">Generics and Trait Constraints</a></li>
<li><a href="advanced/./assembly.html">Assembly</a></li>
<li><a href="advanced/./never_type.html">Never Type</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="advanced-types"><a class="header" href="#advanced-types">Advanced Types</a></h1>
<h2 id="creating-type-synonyms-with-type-aliases"><a class="header" href="#creating-type-synonyms-with-type-aliases">Creating Type Synonyms with Type Aliases</a></h2>
<p>Sway provides the ability to declare a type alias to give an existing type another name. For this we use the <code>type</code> keyword. For example, we can create the alias <code>Kilometers</code> to <code>u64</code> like so:</p>
<pre><code class="language-sway">type Kilometers = u64;
</code></pre>
<p>Now, the alias <code>Kilometers</code> is a <em>synonym</em> for <code>u64</code>. Note that <code>Kilometers</code> is <strong>not</strong> a separate new type. Values that have the type <code>Kilometers</code> will be treated the same as values of type <code>u64</code>:</p>
<pre><code class="language-sway">    let x: u64 = 5;
    let y: Kilometers = 5;
    assert(x + y == 10);
</code></pre>
<p>Because <code>Kilometers</code> and <code>u64</code> are the same type, we can add values of both types and we can pass <code>Kilometers</code> values to functions that take <code>u64</code> parameters. However, using this method, we donâ€™t get the type checking benefits that we get from introducing a <em>separate</em> new type called <code>Kilometers</code>. In other words, if we mix up <code>Kilometers</code> and <code>i32</code> values somewhere, the compiler will not give us an error.</p>
<p>The main use case for type synonyms is to reduce repetition. For example, we might have a lengthy array type like this:</p>
<pre><code class="language-sway">[MyStruct&lt;u64, b256&gt;; 5]
</code></pre>
<p>Writing this lengthy type in function signatures and as type annotations all over the code can be tiresome and error prone. Imagine having a project full of code like this:</p>
<pre><code class="language-sway">fn foo_long(array: [MyStruct&lt;u64, b256&gt;; 5]) -&gt; [MyStruct&lt;u64, b256&gt;; 5] {
    array
}
</code></pre>
<p>A type alias makes this code more manageable by reducing the repetition. Below, weâ€™ve introduced an alias named <code>MyArray</code> for the verbose type and can replace all uses of the type with the shorter alias <code>MyArray</code>:</p>
<pre><code class="language-sway">type MyArray = [MyStruct&lt;u64, b256&gt;; 5];

fn foo_shorter(array: MyArray) -&gt; MyArray {
    array
}
</code></pre>
<p>This code is much easier to read and write! Choosing a meaningful name for a type alias can help communicate your intent as well.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="advanced-storage-1"><a class="header" href="#advanced-storage-1">Advanced Storage</a></h1>
<h2 id="nested-storage-collections"><a class="header" href="#nested-storage-collections">Nested Storage Collections</a></h2>
<p>Through the use of <code>StorageKey</code>s, you may have nested storage collections such as storing a <code>StorageString</code> in a <code>StorageMap&lt;K, V&gt;</code>.</p>
<p>For example, here we have a few common nested storage types declared in a <code>storage</code> block:</p>
<pre><code class="language-sway">storage {
    nested_map_vec: StorageMap&lt;u64, StorageVec&lt;u8&gt;&gt; = StorageMap {},
    nested_map_string: StorageMap&lt;u64, StorageString&gt; = StorageMap {},
    nested_vec_bytes: StorageVec&lt;StorageBytes&gt; = StorageVec {},
}
</code></pre>
<p>Please note that storage initialization is needed to do this.</p>
<blockquote>
<p><strong>NOTE</strong>: When importing a storage type, please be sure to use the glob operator i.e. <code>use std::storage::storage_vec::*</code>.</p>
</blockquote>
<h3 id="storing-a-storagevect-in-a-storagemapk-v"><a class="header" href="#storing-a-storagevect-in-a-storagemapk-v">Storing a <code>StorageVec&lt;T&gt;</code> in a <code>StorageMap&lt;K, V&gt;</code></a></h3>
<p>The following demonstrates how to write to a <code>StorageVec&lt;T&gt;</code> that is nested in a <code>StorageMap&lt;T, V&gt;</code>:</p>
<pre><code class="language-sway">        // Setup and initialize storage for the StorageVec.
        storage.nested_map_vec.try_insert(10, StorageVec {});

        // Method 1: Push to the vec directly
        storage.nested_map_vec.get(10).push(1u8);
        storage.nested_map_vec.get(10).push(2u8);
        storage.nested_map_vec.get(10).push(3u8);

        // Method 2: First get the storage key and then push the values.
        let storage_key_vec: StorageKey&lt;StorageVec&lt;u8&gt;&gt; = storage.nested_map_vec.get(10);
        storage_key_vec.push(4u8);
        storage_key_vec.push(5u8);
        storage_key_vec.push(6u8);
</code></pre>
<p>The following demonstrates how to read from a <code>StorageVec&lt;T&gt;</code> that is nested in a <code>StorageMap&lt;T, V&gt;</code>:</p>
<pre><code class="language-sway">        // Method 1: Access the StorageVec directly.
        let stored_val1: u8 = storage.nested_map_vec.get(10).pop().unwrap();
        let stored_val2: u8 = storage.nested_map_vec.get(10).pop().unwrap();
        let stored_val3: u8 = storage.nested_map_vec.get(10).pop().unwrap();

        // Method 2: First get the storage key and then access the value.
        let storage_key: StorageKey&lt;StorageVec&lt;u8&gt;&gt; = storage.nested_map_vec.get(10);
        let stored_val4: u8 = storage_key.pop().unwrap();
        let stored_val5: u8 = storage_key.pop().unwrap();
        let stored_val6: u8 = storage_key.pop().unwrap();
</code></pre>
<h3 id="storing-a-storagestring-in-a-storagemapk-v"><a class="header" href="#storing-a-storagestring-in-a-storagemapk-v">Storing a <code>StorageString</code> in a <code>StorageMap&lt;K, V&gt;</code></a></h3>
<p>The following demonstrates how to write to a <code>StorageString</code> that is nested in a <code>StorageMap&lt;T, V&gt;</code>:</p>
<pre><code class="language-sway">        // Setup and initialize storage for the StorageString.
        storage.nested_map_string.try_insert(10, StorageString {});

        // Method 1: Store the string directly.
        let my_string = String::from_ascii_str("Fuel is blazingly fast");
        storage.nested_map_string.get(10).write_slice(my_string);

        // Method 2: First get the storage key and then write the value.
        let my_string = String::from_ascii_str("Fuel is modular");
        let storage_key: StorageKey&lt;StorageString&gt; = storage.nested_map_string.get(10);
        storage_key.write_slice(my_string);
</code></pre>
<p>The following demonstrates how to read from a <code>StorageString</code> that is nested in a <code>StorageMap&lt;T, V&gt;</code>:</p>
<pre><code class="language-sway">        // Method 1: Access the string directly.
        let stored_string: String = storage.nested_map_string.get(10).read_slice().unwrap();

        // Method 2: First get the storage key and then access the value.
        let storage_key: StorageKey&lt;StorageString&gt; = storage.nested_map_string.get(10);
        let stored_string: String = storage_key.read_slice().unwrap();
</code></pre>
<h3 id="storing-a-storagebytes-in-a-storagevect"><a class="header" href="#storing-a-storagebytes-in-a-storagevect">Storing a <code>StorageBytes</code> in a <code>StorageVec&lt;T&gt;</code></a></h3>
<p>The following demonstrates how to write to a <code>StorageBytes</code> that is nested in a <code>StorageVec&lt;T&gt;</code>:</p>
<pre><code class="language-sway">        // Setup and initialize storage for the StorageVec.
        storage.nested_map_vec.try_insert(10, StorageVec {});

        // Method 1: Push to the vec directly
        storage.nested_map_vec.get(10).push(1u8);
        storage.nested_map_vec.get(10).push(2u8);
        storage.nested_map_vec.get(10).push(3u8);

        // Method 2: First get the storage key and then push the values.
        let storage_key_vec: StorageKey&lt;StorageVec&lt;u8&gt;&gt; = storage.nested_map_vec.get(10);
        storage_key_vec.push(4u8);
        storage_key_vec.push(5u8);
        storage_key_vec.push(6u8);
</code></pre>
<p>The following demonstrates how to read from a <code>StorageBytes</code> that is nested in a <code>StorageVec&lt;T&gt;</code>:</p>
<pre><code class="language-sway">        // Method 1: Access the StorageVec directly.
        let stored_val1: u8 = storage.nested_map_vec.get(10).pop().unwrap();
        let stored_val2: u8 = storage.nested_map_vec.get(10).pop().unwrap();
        let stored_val3: u8 = storage.nested_map_vec.get(10).pop().unwrap();

        // Method 2: First get the storage key and then access the value.
        let storage_key: StorageKey&lt;StorageVec&lt;u8&gt;&gt; = storage.nested_map_vec.get(10);
        let stored_val4: u8 = storage_key.pop().unwrap();
        let stored_val5: u8 = storage_key.pop().unwrap();
        let stored_val6: u8 = storage_key.pop().unwrap();
</code></pre>
<h2 id="storage-namespace"><a class="header" href="#storage-namespace">Storage Namespace</a></h2>
<p>If you want the values in storage to be positioned differently, for instance to avoid collisions with storage from another contract when loading code, you can use the namespace annotation to add a salt to the slot calculations.</p>
<pre><code class="language-sway">storage {
    example_namespace {
        foo: u64 = 0,
    },
</code></pre>
<h2 id="manual-storage-management"><a class="header" href="#manual-storage-management">Manual Storage Management</a></h2>
<p>It is possible to leverage FuelVM storage operations directly using the <code>std::storage::storage_api::write</code> and <code>std::storage::storage_api::read</code> functions provided in the standard library. With this approach, you will have to manually assign the internal key used for storage. An example is as follows:</p>
<pre><code class="language-sway">contract;

use std::storage::storage_api::{read, write};

abi StorageExample {
    #[storage(write)]
    fn store_something(amount: u64);

    #[storage(read)]
    fn get_something() -&gt; u64;
}

const STORAGE_KEY: b256 = 0x0000000000000000000000000000000000000000000000000000000000000000;

impl StorageExample for Contract {
    #[storage(write)]
    fn store_something(amount: u64) {
        write(STORAGE_KEY, 0, amount);
    }

    #[storage(read)]
    fn get_something() -&gt; u64 {
        let value: Option&lt;u64&gt; = read::&lt;u64&gt;(STORAGE_KEY, 0);
        value.unwrap_or(0)
    }
}
</code></pre>
<blockquote>
<p><strong>Note</strong>: Though these functions can be used for any data type, they should mostly be used for arrays because arrays are not yet supported in <code>storage</code> blocks. Note, however, that <em>all</em> data types can be used as types for keys and/or values in <code>StorageMap&lt;K, V&gt;</code> without any restrictions.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="generic-types"><a class="header" href="#generic-types">Generic Types</a></h1>
<h2 id="basics"><a class="header" href="#basics">Basics</a></h2>
<p>In Sway, generic types follow a very similar pattern to those in Rust. Let's look at some example syntax,
starting with a generic function:</p>
<pre><code class="language-sway">fn noop&lt;T&gt;(argument: T) -&gt; T {
    argument
}
</code></pre>
<p>Here, the <code>noop()</code> function trivially returns exactly what was given to it. <code>T</code> is a <em>type parameter</em>, and it says
that this function exists for all types T. More formally, this function could be typed as:</p>
<pre><code class="language-math">noop :: âˆ€T. T -&gt; T
</code></pre>
<p>Generic types are a way to refer to types <em>in general</em>, meaning without specifying a single type. Our <code>noop</code> function
would work with any type in the language, so we don't need to specify <code>noop(argument: u8) -&gt; u8</code>, <code>noop(argument: u16) -&gt; u16</code>, etc.</p>
<h2 id="code-generation"><a class="header" href="#code-generation">Code Generation</a></h2>
<p>One question that arises when dealing with generic types is: how does the assembly handle this? There are a few approaches to handling
generic types at the lowest level. Sway uses a technique called <a href="https://en.wikipedia.org/wiki/Monomorphization">monomorphization</a>. This
means that the generic function is compiled to a non-generic version for every type it is called on. In this way, generic functions are
purely shorthand for the sake of ergonomics.</p>
<h2 id="trait-constraints"><a class="header" href="#trait-constraints">Trait Constraints</a></h2>
<p>An important background to know before diving into trait constraints is that the <code>where</code> clause can be used to specify the required traits for the generic argument. So, when writing something like a <code>HashMap</code> you may
want to specify that the generic argument implements a <code>Hash</code> trait.</p>
<pre><code class="language-sway">fn get_hashmap_key&lt;T&gt;(key: T) -&gt; b256
    where T: Hash
{
    // Code within here can then call methods associated with the Hash trait on Key
}
</code></pre>
<p>Of course, our <code>noop()</code> function is not useful. Often, a programmer will want to declare functions over types which satisfy certain traits.
For example, let's try to implement the successor function, <code>successor()</code>, for all numeric types.</p>
<pre><code class="language-sway">fn successor&lt;T&gt;(argument: T)
    where T: Add
{
    argument + 1
}
</code></pre>
<p>Run <code>forc build</code>, and you will get:</p>
<pre><code class="language-console">.. |
 9 |   where T: Add
10 |   {
11 |       argument + 1                                        
   |                  ^ Mismatched types: expected type "T" but saw type "u64"
12 |   }
13 |
</code></pre>
<p>This is because we don't know for a fact that <code>1</code>, which in this case defaulted to <code>1u64</code>, actually can be added to <code>T</code>. What if <code>T</code> is <code>f64</code>? Or <code>b256</code>? What does it mean to add <code>1u64</code> in these cases?</p>
<p>We can solve this problem with another trait constraint. We can only find the successor of some value of type <code>T</code> if that type <code>T</code> defines some incrementor. Let's make a trait:</p>
<pre><code class="language-sway">trait Incrementable {
    /// Returns the value to add when calculating the successor of a value.
    fn incrementor() -&gt; Self;
}
</code></pre>
<p>Now, we can modify our <code>successor()</code> function:</p>
<pre><code class="language-sway">fn successor&lt;T&gt;(argument: T)
    where T: Add,
          T: Incrementable
{
    argument + T::incrementor()
}
</code></pre>
<h2 id="generic-structs-and-enums"><a class="header" href="#generic-structs-and-enums">Generic Structs and Enums</a></h2>
<p>Just like functions, structs and enums can be generic. Let's take a look at the standard library version of <code>Option&lt;T&gt;</code>:</p>
<pre><code class="language-sway">enum Option&lt;T&gt; {
    Some: T,
    None: (),
}
</code></pre>
<p>Just like an unconstrained generic function, this type exists for all (âˆ€) types <code>T</code>. <code>Result&lt;T, E&gt;</code> is another example:</p>
<pre><code class="language-sway">enum Result&lt;T, E&gt; {
    Ok: T,
    Err: E,
}
</code></pre>
<p>Both generic enums and generic structs can be trait constrained, as well. Consider this struct:</p>
<pre><code class="language-sway">struct Foo&lt;T&gt;
    where T: Add
{
    field_one: T,
}
</code></pre>
<h2 id="type-arguments"><a class="header" href="#type-arguments">Type Arguments</a></h2>
<p>Similar to Rust, Sway has what is colloquially known as the <a href="https://github.com/rust-lang/rust/blob/e98309298d927307c5184f4869604bd068d26183/src/test/ui/parser/bastion-of-the-turbofish.rs">turbofish</a>. The turbofish looks like this: <code>::&lt;&gt;</code> (see the little fish with bubbles behind it?). The turbofish is used to annotate types in a generic context. Say you have the following function:</p>
<pre><code class="language-sway">fn foo&lt;T, E&gt;(t: T) -&gt; Result&lt;T, E&gt; {
    Ok(t)
}
</code></pre>
<p>In this code example, which is admittedly asinine, you can't possibly know what type <code>E</code> is. You'd need to provide the type manually, with a turbofish:</p>
<pre><code class="language-sway">fn foo&lt;T, E&gt;(t: T) -&gt; Result&lt;T, E&gt; {
    Ok::&lt;T, MyErrorType&gt;(t)
}
</code></pre>
<p>It is also common to see the turbofish used on the function itself:</p>
<pre><code class="language-sway">fn main() {
    foo::&lt;Bar, Baz&gt;()
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="traits"><a class="header" href="#traits">Traits</a></h1>
<h2 id="declaring-a-trait"><a class="header" href="#declaring-a-trait">Declaring a Trait</a></h2>
<p>A <em>trait</em> opts a type into a certain type of behavior or functionality that can be shared among types. This allows for easy reuse of code and generic programming. If you have ever used a typeclass in Haskell, a trait in Rust, or even an interface in Java, these are similar concepts.</p>
<p>Let's take a look at some code:</p>
<pre><code class="language-sway">trait Compare {
    fn equals(self, b: Self) -&gt; bool;
} {
    fn not_equals(self, b: Self) -&gt; bool {
        !self.equals(b)
    }
}
</code></pre>
<p>We have just declared a trait called <code>Compare</code>. After the name of the trait, there are two <em>blocks</em> of code (a <em>block</em> is code enclosed in <code>{</code> curly brackets <code>}</code>). The first block is the <em>interface surface</em>. The second block is the <em>methods</em> provided by the trait. If a type can provide the methods in the interface surface, then it gets access to the methods in the trait for free! What the above trait is saying is: if you can determine if two values are equal, then for free, you can determine that they are not equal. Note that trait methods have access to the methods defined in the interface surface.</p>
<h2 id="implementing-a-trait"><a class="header" href="#implementing-a-trait">Implementing a Trait</a></h2>
<p>The example below implements a <code>Compare</code> trait for <code>u64</code> to check if two numbers are equal. Let's take a look at how that is done:</p>
<pre><code class="language-sway">impl Compare for u64 {
    fn equals(self, b: Self) -&gt; bool {
        self == b
    }
}
</code></pre>
<p>The above snippet declares all of the methods in the trait <code>Compare</code> for the type <code>u64</code>. Now, we have access to both the <code>equals</code> and <code>not_equals</code> methods for <code>u64</code>, as long as the trait <code>Compare</code> is in scope.</p>
<h2 id="supertraits"><a class="header" href="#supertraits">Supertraits</a></h2>
<p>When using multiple traits, scenarios often come up where one trait may require functionality from another trait. This is where supertraits come in as they allow you to require a trait when implementing another trait, i.e., a trait with a trait.
A good example of this is the <code>Ord</code> trait of the <code>std</code> library of Sway. The <code>Ord</code> trait requires the <code>Eq</code> trait, so <code>Eq</code> is kept as a separate trait as one may decide to implement <code>Eq</code>
without implementing other parts of the <code>Ord</code> trait.</p>
<pre><code class="language-sway">
trait Eq {
    fn equals(self, b: Self) -&gt; bool;
}

trait Ord: Eq {
    fn gte(self, b: Self) -&gt; bool;
}

impl Ord for u64 {
    fn gte(self, b: Self) -&gt; bool {
        // As `Eq` is a supertrait of `Ord`, `Ord` can access the equals method
        self.equals(b) || self.gt(b)
    }
}
</code></pre>
<p>To require a supertrait, add a <code>:</code> after the trait name and then list the traits you would like to require and separate them with a <code>+</code>.</p>
<h3 id="abi-supertraits"><a class="header" href="#abi-supertraits">ABI supertraits</a></h3>
<p>ABIs can also have supertrait annotations:</p>
<pre><code class="language-sway">contract;

struct Foo {}
impl ABIsupertrait for Foo {
    fn foo() {}
}

trait ABIsupertrait {
    fn foo();
}

abi MyAbi : ABIsupertrait {
    fn bar();
} {
    fn baz() {
        Self::foo() // supertrait method usage
    }
}

impl ABIsupertrait for Contract {
    fn foo() {}
}

// The implementation of MyAbi for Contract must also implement ABIsupertrait
impl MyAbi for Contract {
    fn bar() {
        Self::foo() // supertrait method usage
    }
}
</code></pre>
<p>The implementation of <code>MyAbi</code> for <code>Contract</code> must also implement the <code>ABIsupertrait</code> trait. Methods in <code>ABIsupertrait</code> are not available externally, i.e. they're not actually contract methods, but they can be used in the actual contract methods, as shown in the example above.</p>
<p>ABI supertraits are intended to make contract implementations compositional, allowing combining orthogonal contract features using, for instance, libraries.</p>
<h3 id="superabis"><a class="header" href="#superabis">SuperABIs</a></h3>
<p>In addition to supertraits, ABIs can have <em>superABI</em> annotations:</p>
<pre><code class="language-sway">contract;

abi MySuperAbi {
    fn foo();
}

abi MyAbi : MySuperAbi {
    fn bar();
}

impl MySuperAbi for Contract {
    fn foo() {}
}

// The implementation of MyAbi for Contract must also implement MySuperAbi
impl MyAbi for Contract {
    fn bar() {}
}
</code></pre>
<p>The implementation of <code>MyAbi</code> for <code>Contract</code> must also implement the <code>MySuperAbi</code> superABI. Methods in <code>MySuperAbi</code> will be part of the <code>MyAbi</code> contract interface, i.e. will be available externally (and hence cannot be called from other <code>MyAbi</code> contract methods).</p>
<p>SuperABIs are intended to make contract implementations compositional, allowing combining orthogonal contract features using, for instance, libraries.</p>
<h2 id="associated-items"><a class="header" href="#associated-items">Associated Items</a></h2>
<p>Traits can declare different kinds of associated items in their interface surface:</p>
<ul>
<li><a href="advanced/traits.html#associated-functions">Functions</a></li>
<li><a href="advanced/traits.html#associated-constants">Constants</a></li>
<li><a href="advanced/traits.html#associated-types">Types</a></li>
</ul>
<h3 id="associated-functions-1"><a class="header" href="#associated-functions-1">Associated functions</a></h3>
<p>Associated functions in traits consist of just function signatures. This indicates that each implementation of the trait for a given type must define all the trait functions.</p>
<pre><code class="language-sway">trait Trait {
    fn associated_fn(self, b: Self) -&gt; bool;
}
</code></pre>
<h3 id="associated-constants-1"><a class="header" href="#associated-constants-1">Associated constants</a></h3>
<p>Associated constants are constants associated with a type.</p>
<pre><code class="language-sway">trait Trait {
    const ID: u32 = 0;
}
</code></pre>
<p>The initializer expression of an <a href="advanced/../basics/constants.html#associated-constants">associated constants</a> in a trait definition may be omitted to indicate that each implementation of the <code>trait</code> for a given type must specify an initializer:</p>
<pre><code class="language-sway">trait Trait {
    const ID: u32;
}
</code></pre>
<p>Check the <code>associated consts</code> section on <a href="advanced/../basics/constants.html">constants</a> page.</p>
<h3 id="associated-types"><a class="header" href="#associated-types">Associated types</a></h3>
<p>Associated types in Sway allow you to define placeholder types within a trait, which can be customized by concrete
implementations of that trait. These associated types are used to specify the return types of trait methods or to
define type relationships within the trait.</p>
<pre><code class="language-sway">trait MyTrait {
    type AssociatedType;
}
</code></pre>
<p>Check the <code>associated types</code> section on <a href="advanced/./associated_types.html">associated types</a> page.</p>
<h2 id="trait-constraints-1"><a class="header" href="#trait-constraints-1">Trait Constraints</a></h2>
<p>When writing generic code, you can constraint the choice of types for a generic argument by using the <code>where</code> keyword. The <code>where</code> keyword specifies which traits the concrete generic parameter must implement. In the below example, the function <code>expects_some_trait</code> can be called only if the parameter <code>t</code> is of a type that has <code>SomeTrait</code> implemented. To call the <code>expects_both_traits</code>, parameter <code>t</code> must be of a type that implements <em>both</em> <code>SomeTrait</code> and <code>SomeOtherTrait</code>.</p>
<pre><code class="language-sway">trait SomeTrait { }
trait SomeOtherTrait { }

fn expects_some_trait&lt;T&gt;(t: T) where T: SomeTrait {
    // ...
}

fn expects_some_other_trait&lt;T&gt;(t: T) where T: SomeOtherTrait {
    // ...
}

fn expects_both_traits&lt;T&gt;(t: T) where T: SomeTrait + SomeOtherTrait {
    // ...
}
</code></pre>
<h2 id="marker-traits"><a class="header" href="#marker-traits">Marker Traits</a></h2>
<p>Sway types can be classified in various ways according to their intrinsic properties. These classifications are represented as marker traits. Marker traits are implemented by the compiler and cannot be explicitly implemented in code.</p>
<p>E.g., all types whose instances can be used in the <code>panic</code> expression automatically implement the <code>Error</code> marker trait. We can use that trait, e.g., to specify that a generic argument must be compatible with the <code>panic</code> expression:</p>
<pre><code class="language-sway">fn panic_with_error&lt;E&gt;(err: E) where E: Error {
    panic err;
}
</code></pre>
<p>All marker traits are defined in the <code>std::marker</code> module.</p>
<h2 id="use-cases"><a class="header" href="#use-cases">Use Cases</a></h2>
<h3 id="custom-types-structs-enums"><a class="header" href="#custom-types-structs-enums">Custom Types (structs, enums)</a></h3>
<p>Often, libraries and APIs have interfaces that are abstracted over a type that implements a certain trait. It is up to the consumer of the interface to implement that trait for the type they wish to use with the interface. For example, let's take a look at a trait and an interface built off of it.</p>
<pre><code class="language-sway">library;

pub enum Suit {
    Hearts: (),
    Diamonds: (),
    Clubs: (),
    Spades: (),
}

pub trait Card {
    fn suit(self) -&gt; Suit;
    fn value(self) -&gt; u8;
}

fn play_game_with_deck&lt;T&gt;(a: Vec&lt;T&gt;) where T: Card {
    // insert some creative card game here
}
</code></pre>
<p>Now, if you want to use the function <code>play_game_with_deck</code> with your struct, you must implement <code>Card</code> for your struct. Note that the following code example assumes a dependency <em>games</em> has been included in the <code>Forc.toml</code> file.</p>
<pre><code class="language-sway">script;

use games::*;

struct MyCard {
    suit: Suit,
    value: u8
}

impl Card for MyCard {
    fn suit(self) -&gt; Suit {
        self.suit
    }
    fn value(self) -&gt; u8 {
        self.value
    }
}

fn main() {
    let mut i = 52;
    let mut deck: Vec&lt;MyCard&gt; = Vec::with_capacity(50);
    while i &gt; 0 {
        i = i - 1;
        deck.push(MyCard { suit: generate_random_suit(), value: i % 4}
    }
    play_game_with_deck(deck);
}

fn generate_random_suit() -&gt; Suit {
  [ ... ]
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="associated-types-1"><a class="header" href="#associated-types-1">Associated Types</a></h1>
<p>Associated types in Sway allow you to define placeholder types within a trait, which can be customized by concrete
implementations of that trait. These associated types are used to specify the return types of trait methods or to
define type relationships within the trait.</p>
<p>Associated types are a powerful feature of Sway's trait system, enabling generic programming and abstraction over
types. They help improve code clarity and maintainability by allowing you to define generic traits without committing
to specific types.</p>
<h2 id="declaring-associated-types"><a class="header" href="#declaring-associated-types">Declaring Associated Types</a></h2>
<p>Associated types are declared within a trait using the type keyword. Here's the syntax for declaring an associated type:</p>
<pre><code class="language-sway">trait MyTrait {
    type AssociatedType;
}
</code></pre>
<h2 id="implementing-associated-types"><a class="header" href="#implementing-associated-types">Implementing Associated Types</a></h2>
<p>Concrete implementations of a trait with associated types must provide a specific type for each associated type
defined in the trait. Here's an example of implementing a trait with an associated type:</p>
<pre><code class="language-sway">struct MyStruct;

impl MyTrait for MyStruct {
    type AssociatedType = u32; // Implementing the associated type with u32
}
</code></pre>
<p>In this example, <code>MyStruct</code> implements <code>MyTrait</code> and specifies that the associated type <code>AssociatedType</code> is <code>u32</code>.</p>
<h2 id="using-associated-types"><a class="header" href="#using-associated-types">Using Associated Types</a></h2>
<p>Associated types are used within trait methods or where the trait is used as a bound for generic functions or
structs. You can use the associated type like any other type. Here's an example:</p>
<pre><code class="language-sway">trait MyTrait {
    type AssociatedType;
    
    fn get_value(self) -&gt; Self::AssociatedType;
}

struct MyStruct;

impl MyTrait for MyStruct {
    type AssociatedType = u32;

    fn get_value(self) -&gt; Self::AssociatedType {
        42
    }
}
</code></pre>
<p>In this example, <code>get_value</code> is a trait method that returns an associated type <code>AssociatedType</code>.</p>
<h2 id="use-cases-1"><a class="header" href="#use-cases-1">Use Cases</a></h2>
<p>Associated types are particularly useful in scenarios where you want to define traits that work with different
types of data structures or abstractions, allowing the implementer to specify the concrete types. Some common use cases include:</p>
<ul>
<li>Collections: Traits for generic collections that allow users to specify the type of elements.</li>
<li>Iterator Patterns: Traits for implementing iterators with varying element types.</li>
<li>Serialization and Deserialization: Traits for serializing and deserializing data with different data formats.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="generics-and-trait-constraints"><a class="header" href="#generics-and-trait-constraints">Generics and Trait Constraints</a></h1>
<h2 id="generics-as-constraints"><a class="header" href="#generics-as-constraints">Generics as Constraints</a></h2>
<p>At a high level, Sway allows you to define constraints, or restrictions, that
allow you to strike a balance between writing abstract and reusable code and
enforcing compile-time checks to determine if the abstract code that you've
written is correct.</p>
<p>The "abstract and reusable" part largely comes from <a href="advanced/./generic_types.html">generic types</a> and the
"enforcing compile-time checks" part largely comes from trait constraints.
Generic types can be used with functions, structs, and enums (as we have seen in
this book), but they can also be used with traits.</p>
<h2 id="generic-traits"><a class="header" href="#generic-traits">Generic Traits</a></h2>
<p>Combining generic types with traits allows you to write abstract and reusable
traits that can be implemented for any number of data types.</p>
<p>For example, imagine that you want to write a trait for converting between
different types. This would be similar to Rust's <code>Into</code> and <code>From</code> traits. In
Sway your conversion trait would look something like:</p>
<pre><code class="language-sway">trait Convert&lt;T&gt; {
    fn from(t: T) -&gt; Self;
}
</code></pre>
<p>The trait <code>Convert</code> takes a generic type <code>T</code>. <code>Convert</code> has one method
<code>from</code>, which takes one parameter of type <code>T</code> and returns a <code>Self</code>. This means
that when you implement <code>Convert</code> for a data type, <code>from</code> will return the type
of that data type but will take as input the type that you define as <code>T</code>. Here
is an example:</p>
<pre><code class="language-sway">struct Square {
    width: u64,
}

struct Rectangle {
    width: u64,
    length: u64,
}

impl Convert&lt;Square&gt; for Rectangle {
    fn from(t: Square) -&gt; Self {
        Self {
            width: t.width,
            length: t.width,
        }
    }
}
</code></pre>
<p>In this example, you have two different data types, <code>Square</code> and <code>Rectangle</code>.
You know that all squares are rectangles and thus <code>Square</code> can convert into <code>Rectangle</code> (but not vice
versa) and thus you can implement the conversion trait for those types.</p>
<p>If we want to call these methods we can do so by:</p>
<pre><code class="language-sway">fn main() {
    let s = Square { width: 5 };
    let r = Rectangle::from(s);
}
</code></pre>
<h2 id="trait-constraints-2"><a class="header" href="#trait-constraints-2">Trait Constraints</a></h2>
<p>Trait constraints allow you to use generic types and traits to place constraints
on what abstract code you are willing to accept in your program as correct.
These constraints take the form of compile-time checks for correctness.</p>
<p>If we wanted to use trait constraints with our <code>Convert</code> trait from the previous
section we could do so like so:</p>
<pre><code class="language-sway">fn into_rectangle&lt;T&gt;(t: T) -&gt; Rectangle
where
    Rectangle: Convert&lt;T&gt;,
{
    Rectangle::from(t)
}
</code></pre>
<p>This function allows you to take any generic data type <code>T</code> and convert it to the
type <code>Rectangle</code> <em>as long as <code>Convert&lt;T&gt;</code> is implemented for <code>Rectangle</code></em>.
Calling this function with a type <code>T</code> for which <code>Convert&lt;T&gt;</code> is not implemented
for <code>Rectangle</code> will fail Sway's compile-time checks.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="inline-assembly-in-sway"><a class="header" href="#inline-assembly-in-sway">Inline Assembly in Sway</a></h1>
<p>While many users will never have to touch assembly language while writing Sway code, it is a powerful tool that enables many advanced use-cases (e.g., optimizations, building libraries, etc).</p>
<h2 id="asm-block"><a class="header" href="#asm-block">ASM Block</a></h2>
<p>In Sway, the way we use assembly inline is to declare an <code>asm</code> block like this:</p>
<pre><code class="language-sway">asm() {...}
</code></pre>
<p>Declaring an <code>asm</code> block is similar to declaring a function.
We can specify register names to operate on as arguments, we can perform assembly instructions within the block, and we can return a value by specifying a return register.
Here's an example showing what this might look like:</p>
<pre><code class="language-sway">pub fn add_1(num: u32) -&gt; u32 {
    asm(r1: num, r2) {
        add r2 r1 one;
        r2: u32
    }
}
</code></pre>
<p>The return register is specified at the end of the <code>asm</code> block, after all the assembly instructions. It consists of the register name and an optional return type. In the above example, the return register name is <code>r2</code> and the return type is <code>u32</code>.
If the return type is omitted, it is <code>u64</code> by default.</p>
<p>The return register itself is optional. If it is not specified, similar to functions, the returned value from the <code>asm</code> block will be <a href="advanced/../basics/built_in_types.html#unit-type">unit</a>, <code>()</code>.</p>
<p>An <code>asm</code> block can only return a single register. If you really need to return more than one value, you can modify a tuple. Here's an example showing how you can implement this for <code>(u64, u64)</code>:</p>
<pre><code class="language-sway">script;

fn adder(a: u64, b: u64, c: u64) -&gt; (u64, u64) {
    let empty_tuple = (0u64, 0u64);
    asm(output: empty_tuple, r1: a, r2: b, r3: c, r4, r5) {
        add r4 r1 r2; // add a &amp; b and put the result in r4
        add r5 r2 r3; // add b &amp; c and put the result in r5
        sw output r4 i0; // store the word in r4 in output + 0 words
        sw output r5 i1; // store the word in r5 in output + 1 word
        output: (u64, u64) // return both values
    }
}

fn main() -&gt; bool {
    let (first, second) = adder(1, 2, 3);
    assert(first == 3);
    assert(second == 5);
    true
}
</code></pre>
<p>Note that this is contrived example meant to demonstrate the syntax; there's absolutely no need to use assembly to add integers!</p>
<p>Note that in the above example:</p>
<ul>
<li>we initialized the register <code>r1</code> with the value of <code>num</code>.</li>
<li>we declared a second register <code>r2</code> (you may choose any register names you want).</li>
<li>we use the <code>add</code> opcode to add <code>one</code> to the value of <code>r1</code> and store it in <code>r2</code>.</li>
<li><code>one</code> is an example of a "reserved register", of which there are 16 in total. Further reading on this is linked below under "Semantics".</li>
<li>we return <code>r2</code> and specify the return type as being <code>u32</code>.</li>
</ul>
<p>An important note is that the <code>ji</code> and <code>jnei</code> opcodes are not available within an <code>asm</code> block. For those looking to introduce control flow to <code>asm</code> blocks, it is recommended to surround smaller chunks of <code>asm</code> with control flow (<code>if</code>, <code>else</code>, and <code>while</code>).</p>
<h2 id="helpful-links"><a class="header" href="#helpful-links">Helpful Links</a></h2>
<p>For examples of assembly in action, check out the <a href="https://github.com/FuelLabs/sway/tree/master/sway-lib-std">Sway standard library</a>.</p>
<p>For a complete list of all instructions supported in the FuelVM: <a href="https://fuellabs.github.io/fuel-specs/master/vm/instruction_set">Instructions</a>.</p>
<p>And to learn more about the FuelVM semantics: <a href="https://fuellabs.github.io/fuel-specs/master/vm#semantics">Semantics</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="never-type"><a class="header" href="#never-type">Never Type</a></h1>
<p>The Never type <code>!</code> represents the type of computations which never resolve to any value at all.</p>
<h2 id="additional-information"><a class="header" href="#additional-information">Additional Information</a></h2>
<p><code>break</code>, <code>continue</code> and <code>return</code> expressions also have type <code>!</code>. For example we are allowed to
write:</p>
<pre><code class="language-sway">let x: ! = {
    return 123
};
</code></pre>
<p>Although the <code>let</code> is pointless here, it illustrates the meaning of <code>!</code>. Since <code>x</code> is never
assigned a value (because <code>return</code> returns from the entire function), <code>x</code> can be given type
<code>Never</code>. We could also replace <code>return 123</code> with a <code>revert()</code> or a never-ending <code>loop</code> and this code
would still be valid.</p>
<p>A more realistic usage of <code>Never</code> is in this code:</p>
<pre><code class="language-sway">let num: u32 = match get_a_number() {
    Some(num) =&gt; num,
    None =&gt; break,
};
</code></pre>
<p>Both match arms must produce values of type [<code>u32</code>], but since <code>break</code> never produces a value
at all we know it can never produce a value which isn't a [<code>u32</code>]. This illustrates another
behaviour of the <code>!</code> type - expressions with type <code>!</code> will coerce into any other type.</p>
<p>Note that <code>!</code> type coerces into any other type, another example of this would be:</p>
<pre><code class="language-sway">let x: u32 = {
    return 123
};
</code></pre>
<p>Regardless of the type of <code>x</code>, the return block of type <code>Never</code> will always coerce into <code>x</code> type.</p>
<h2 id="examples"><a class="header" href="#examples">Examples</a></h2>
<pre><code class="language-sway">fn foo() {
    let num: u64 = match Option::None::&lt;u64&gt; {
        Some(num) =&gt; num,
        None =&gt; return,
    };
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="common-collections"><a class="header" href="#common-collections">Common Collections</a></h1>
<p>Swayâ€™s standard library includes a number of very useful data structures called collections. Most other data types represent one specific value, but collections can contain multiple values. Unlike the built-in array and tuple types which are allocated on the "stack" and cannot grow in size, the data these collections point to is stored either on the "heap" or in contract "storage", which means the amount of data does not need to be known at compile time and can grow as the program runs. Each kind of collection has different capabilities and costs, and choosing an appropriate one for your current situation is a skill youâ€™ll develop over time. In this chapter, weâ€™ll discuss three collections that are used very often in Sway programs:</p>
<p>A vector on the heap allows you to store a variable number of values next to each other.</p>
<p>A <code>StorageVec</code> is similar to a vector on the heap but uses persistent storage.</p>
<p>A <code>StorageMap</code> allows you to associate a value with a particular key.</p>
<p>Weâ€™ll discuss how to create and update a vector, <code>StorageVec</code>, and <code>StorageMap</code>, as well as what makes each special.</p>
<ul>
<li><a href="common-collections/./vec.html">Vectors on the Heap</a></li>
<li><a href="common-collections/./storage_vec.html"><code>StorageVec</code></a></li>
<li><a href="common-collections/./storage_map.html"><code>StorageMap</code></a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="vectors-on-the-heap"><a class="header" href="#vectors-on-the-heap">Vectors on the Heap</a></h1>
<p>The first collection type weâ€™ll look at is <code>Vec&lt;T&gt;</code>, also known as a vector. Vectors allow you to store more than one value in a single data structure that puts all the values next to each other in memory. Vectors can only store values of the same type. They are useful when you have a list of items, such as the lines of text in a file or the prices of items in a shopping cart.</p>
<p><code>Vec&lt;T&gt;</code> is included in the <a href="common-collections/../introduction/standard_library.html#standard-library-prelude">standard library prelude</a> which means that there is no need to import it manually.</p>
<h2 id="creating-a-new-vector"><a class="header" href="#creating-a-new-vector">Creating a New Vector</a></h2>
<p>To create a new empty vector, we call the <code>Vec::new</code> function, as shown below:</p>
<pre><code class="language-sway">    let v: Vec&lt;u64&gt; = Vec::new();
</code></pre>
<p>Note that we added a type annotation here. Because we arenâ€™t inserting any values into this vector, the Sway compiler doesnâ€™t know what kind of elements we intend to store. Vectors are implemented using generics which means that the <code>Vec&lt;T&gt;</code> type provided by the standard library can hold any type. When we create a vector to hold a specific type, we can specify the type within angle brackets. In the example above, weâ€™ve told the Sway compiler that the <code>Vec&lt;T&gt;</code> in <code>v</code> will hold elements of the <code>u64</code> type.</p>
<h2 id="updating-a-vector"><a class="header" href="#updating-a-vector">Updating a Vector</a></h2>
<p>To create a vector and then add elements to it, we can use the <code>push</code> method, as shown below:</p>
<pre><code class="language-sway">    let mut v = Vec::new();

    v.push(5);
    v.push(6);
    v.push(7);
    v.push(8);
</code></pre>
<p>As with any variable, if we want to be able to change its value, we need to make it mutable using the <code>mut</code> keyword, as discussed in the section <a href="common-collections/../basics/variables.html#declaring-a-variable">Declaring a Variable</a>. The numbers we place inside are all of type <code>u64</code>, and the Sway compiler infers this from the data, so we donâ€™t need the <code>Vec&lt;u64&gt;</code> annotation.</p>
<h2 id="reading-elements-of-vectors"><a class="header" href="#reading-elements-of-vectors">Reading Elements of Vectors</a></h2>
<p>To read a value stored in a vector at a particular index, you can use the <code>get</code> method as shown below:</p>
<pre><code class="language-sway">    let third = v.get(2);
    match third {
        Some(third) =&gt; log(third),
        None =&gt; revert(42),
    }
</code></pre>
<p>Note two details here. First, we use the index value of <code>2</code> to get the third element because vectors are indexed by number, starting at zero. Second, we get the third element by using the <code>get</code> method with the index passed as an argument, which gives us an <code>Option&lt;T&gt;</code>.</p>
<p>When the <code>get</code> method is passed an index that is outside the vector, it returns <code>None</code> without panicking. This is particularly useful if accessing an element beyond the range of the vector may happen occasionally under normal circumstances. Your code will then have logic to handle having either <code>Some(element)</code> or <code>None</code>. For example, the index could be coming as a contract method argument. If the argument passed is too large, the method <code>get</code> will return a <code>None</code> value, and the contract method may then decide to revert when that happens or return a meaningful error that tells the user how many items are in the current vector and give them another chance to pass a valid value.</p>
<h2 id="iterating-over-the-values-in-a-vector"><a class="header" href="#iterating-over-the-values-in-a-vector">Iterating over the Values in a Vector</a></h2>
<p>To access elements of a vector, we can iterate through the valid indices using a <code>while</code> loop and the <code>len</code> method as shown below:</p>
<pre><code class="language-sway">    let mut i = 0;
    while i &lt; v.len() {
        log(v.get(i).unwrap());
        i += 1;
    }
</code></pre>
<p>Note two details here. First, we use the method <code>len</code> which returns the length of the vector. Second, we call the method <code>unwrap</code> to extract the <code>Option</code> returned by <code>get</code>. We know that <code>unwrap</code> will not fail (i.e. will not cause a revert) because each index <code>i</code> passed to <code>get</code> is known to be smaller than the length of the vector.</p>
<p>The idiomatic and convenient way to access each element in a vector in turn, is to use the <code>for</code> loop in the combination with the <code>iter</code> method. The <code>iter</code> method returns an iterator that iterates over all the elements of the vector sequentially.</p>
<pre><code class="language-sway">    for elem in v.iter() {
        log(elem);
    }
</code></pre>
<p>Note that <strong>modifying a vector during iteration, by e.g. adding or removing elements, is a logical error and results in an <a href="common-collections/../reference/undefined_behavior.html">undefined behavior</a></strong>:</p>
<pre><code class="language-sway">    for elem in v.iter() {
        log(elem);
        if elem == 3 {
            v.push(6); // Modification causes undefined behavior!
        }
    }
</code></pre>
<p>Accessing vector elements via <code>while</code> loop should be used only when more control over traversal is needed. E.g., in the below example we iterate the vector backwards, accessing only every second element.</p>
<pre><code class="language-sway">    // Start from the end
    let mut i = v.len() - 1;
    while 0 &lt;= i {
        log(v.get(i).unwrap());
        // Access every second element
        i -= 2;
    }
</code></pre>
<h2 id="using-an-enum-to-store-multiple-types"><a class="header" href="#using-an-enum-to-store-multiple-types">Using an Enum to store Multiple Types</a></h2>
<p>Vectors can only store values that are the same type. This can be inconvenient; there are definitely use cases for needing to store a list of items of different types. Fortunately, the variants of an enum are defined under the same enum type, so when we need one type to represent elements of different types, we can define and use an enum!</p>
<p>For example, say we want to get values from a row in a table in which some of the columns in the row contain integers, some <code>b256</code> values, and some Booleans. We can define an enum whose variants will hold the different value types, and all the enum variants will be considered the same type: that of the enum. Then we can create a vector to hold that enum and so, ultimately, holds different types. Weâ€™ve demonstrated this below:</p>
<pre><code class="language-sway">    enum TableCell {
        Int: u64,
        B256: b256,
        Boolean: bool,
    }

    let mut row = Vec::new();
    row.push(TableCell::Int(3));
    row.push(TableCell::B256(0x0101010101010101010101010101010101010101010101010101010101010101));
    row.push(TableCell::Boolean(true));
</code></pre>
<p>Now that weâ€™ve discussed some of the most common ways to use vectors, be sure to review the API documentation for all the many useful methods defined on <code>Vec&lt;T&gt;</code> by the standard library. For now, these can be found in the <a href="https://github.com/FuelLabs/sway/blob/master/sway-lib-std/src/vec.sw">source code for <code>Vec&lt;T&gt;</code></a>. For example, in addition to <code>push</code>, a <code>pop</code> method removes and returns the last element, a <code>remove</code> method removes and returns the element at some chosen index within the vector, an <code>insert</code> method inserts an element at some chosen index within the vector, etc.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="storage-vectors"><a class="header" href="#storage-vectors">Storage Vectors</a></h1>
<p>The second collection type weâ€™ll look at is <code>StorageVec&lt;T&gt;</code>. Just like vectors on the heap (i.e. <code>Vec&lt;T&gt;</code>), storage vectors allow you to store more than one value in a single data structure where each value is assigned an index and can only store values of the same type. However, unlike <code>Vec&lt;T&gt;</code>, the elements of a <code>StorageVec</code> are stored in <em>persistent storage</em>, and consecutive elements are not necessarily stored in storage slots that have consecutive keys.</p>
<p>In order to use <code>StorageVec&lt;T&gt;</code>, you must first import <code>StorageVec</code> as follows:</p>
<pre><code class="language-sway">use std::storage::storage_vec::*;
</code></pre>
<p>Another major difference between <code>Vec&lt;T&gt;</code> and <code>StorageVec&lt;T&gt;</code> is that <code>StorageVec&lt;T&gt;</code> can only be used in a contract because only contracts are allowed to access persistent storage.</p>
<h2 id="creating-a-new-storagevec"><a class="header" href="#creating-a-new-storagevec">Creating a New <code>StorageVec</code></a></h2>
<p>To create a new empty <code>StorageVec</code>, we have to declare the vector in a <code>storage</code> block as follows:</p>
<pre><code class="language-sway">    v: StorageVec&lt;u64&gt; = StorageVec {},
</code></pre>
<p>Just like any other storage variable, two things are required when declaring a <code>StorageVec</code>: a type annotation and an initializer. The initializer is just an empty struct of type <code>StorageVec</code> because <code>StorageVec&lt;T&gt;</code> itself is an empty struct! Everything that is interesting about <code>StorageVec&lt;T&gt;</code> is implemented in its methods.</p>
<p>Storage vectors, just like <code>Vec&lt;T&gt;</code>, are implemented using generics which means that the <code>StorageVec&lt;T&gt;</code> type provided by the standard library can hold any type. When we create a <code>StorageVec</code> to hold a specific type, we can specify the type within angle brackets. In the example above, weâ€™ve told the Sway compiler that the <code>StorageVec&lt;T&gt;</code> in <code>v</code> will hold elements of the <code>u64</code> type.</p>
<h2 id="updating-a-storagevec"><a class="header" href="#updating-a-storagevec">Updating a <code>StorageVec</code></a></h2>
<p>To add elements to a <code>StorageVec</code>, we can use the <code>push</code> method, as shown below:</p>
<pre><code class="language-sway">    #[storage(read, write)]
    fn push_to_storage_vec() {
        storage.v.push(5);
        storage.v.push(6);
        storage.v.push(7);
        storage.v.push(8);
    }
</code></pre>
<p>Note two details here. First, in order to use <code>push</code>, we need to first access the vector using the <code>storage</code> keyword. Second, because <code>push</code> requires accessing storage, a <code>storage</code> annotation is required on the ABI function that calls <code>push</code>. While it may seem that <code>#[storage(write)]</code> should be enough here, the <code>read</code> annotation is also required because each call to <code>push</code> requires <em>reading</em> (and then updating) the length of the <code>StorageVec</code> which is also stored in persistent storage.</p>
<blockquote>
<p><strong>Note</strong>
The storage annotation is also required for any private function defined in the contract that tries to push into the vector.</p>
</blockquote>
<!-- markdownlint-disable-line MD028 -->
<blockquote>
<p><strong>Note</strong>
There is no need to add the <code>mut</code> keyword when declaring a <code>StorageVec&lt;T&gt;</code>. All storage variables are mutable by default.</p>
</blockquote>
<h2 id="reading-elements-of-storage-vectors"><a class="header" href="#reading-elements-of-storage-vectors">Reading Elements of Storage Vectors</a></h2>
<p>To read a value stored in a vector at a particular index, you can use the <code>get</code> method as shown below:</p>
<pre><code class="language-sway">    #[storage(read)]
    fn read_from_storage_vec() {
        let third = storage.v.get(2);
        match third {
            Some(third) =&gt; log(third.read()),
            None =&gt; revert(42),
        }
    }
</code></pre>
<p>Note three details here. First, we use the index value of <code>2</code> to get the third element because vectors are indexed by number, starting at zero. Second, we get the third element by using the <code>get</code> method with the index passed as an argument, which gives us an <code>Option&lt;StorageKey&lt;T&gt;&gt;</code>. Third, the ABI function calling <code>get</code> only requires the annotation <code>#[storage(read)]</code> as one might expect because <code>get</code> does not write to storage.</p>
<p>When the <code>get</code> method is passed an index that is outside the vector, it returns <code>None</code> without panicking. This is particularly useful if accessing an element beyond the range of the vector may happen occasionally under normal circumstances. Your code will then have logic to handle having either <code>Some(element)</code> or <code>None</code>. For example, the index could be coming as a contract method argument. If the argument passed is too large, the method <code>get</code> will return a <code>None</code> value, and the contract method may then decide to revert when that happens or return a meaningful error that tells the user how many items are in the current vector and give them another chance to pass a valid value.</p>
<h2 id="iterating-over-the-values-in-a-vector-1"><a class="header" href="#iterating-over-the-values-in-a-vector-1">Iterating over the Values in a Vector</a></h2>
<p>Iterating over a storage vector is conceptually the same as <a href="common-collections/./vec.html">iterating over a <code>Vec&lt;T&gt;</code></a>. The only difference is an additional call to <code>read()</code> to actually read the stored value.</p>
<pre><code class="language-sway">    #[storage(read)]
    fn iterate_over_a_storage_vec() {
        // Iterate over all the elements
        // in turn using the `while` loop.
        // **This approach is not recommended.**
        // For iterating over all the elements
        // in turn use the `for` loop instead.
        let mut i = 0;
        while i &lt; storage.v.len() {
            log(storage.v.get(i).unwrap().read());
            i += 1;
        }

        // The preferred and most performant way
        // to iterate over all the elements in turn is
        // to use the `for` loop.
        for elem in storage.v.iter() {
            log(elem.read());
        }

        // Use the `while` loop only when more
        // control over traversal is needed.
        // E.g., in the below example we iterate
        // the vector backwards, accessing only
        // every second element.
        let mut i = storage.v.len() - 1;
        while 0 &lt;= i {
            log(storage.v.get(i).unwrap().read());
            i -= 2;
        }
    }
</code></pre>
<p>Note that <strong>modifying a vector during iteration, by e.g. adding or removing elements, is a logical error and results in an <a href="common-collections/../reference/undefined_behavior.html">undefined behavior</a></strong>:</p>
<h2 id="using-an-enum-to-store-multiple-types-1"><a class="header" href="#using-an-enum-to-store-multiple-types-1">Using an Enum to store Multiple Types</a></h2>
<p>Storage vectors, just like <code>Vec&lt;T&gt;</code>, can only store values that are the same type. Similarly to what we did for <code>Vec&lt;T&gt;</code> in the section <a href="common-collections/./vec.html#using-an-enum-to-store-multiple-types">Using an Enum to store Multiple Types</a>, we can define an enum whose variants will hold the different value types, and all the enum variants will be considered the same type: that of the enum. This is shown below:</p>
<pre><code class="language-sway">enum TableCell {
    Int: u64,
    B256: b256,
    Boolean: bool,
}
</code></pre>
<p>Then we can declare a <code>StorageVec</code> in a <code>storage</code> block to hold that enum and so, ultimately, holds different types:</p>
<pre><code class="language-sway">    row: StorageVec&lt;TableCell&gt; = StorageVec {},
</code></pre>
<p>We can now push different enum variants to the <code>StorageVec</code> as follows:</p>
<pre><code class="language-sway">    #[storage(read, write)]
    fn push_to_multiple_types_storage_vec() {
        storage.row.push(TableCell::Int(3));
        storage
            .row
            .push(TableCell::B256(0x0101010101010101010101010101010101010101010101010101010101010101));
        storage.row.push(TableCell::Boolean(true));
    }
</code></pre>
<p>Now that weâ€™ve discussed some of the most common ways to use storage vectors, be sure to review the API documentation for all the many useful methods defined on <code>StorageVec&lt;T&gt;</code> by the standard library. For now, these can be found in the <a href="https://github.com/FuelLabs/sway/blob/master/sway-lib-std/src/storage.sw">source code for <code>StorageVec&lt;T&gt;</code></a>. For example, in addition to <code>push</code>, a <code>pop</code> method removes and returns the last element, a <code>remove</code> method removes and returns the element at some chosen index within the vector, an <code>insert</code> method inserts an element at some chosen index within the vector, etc.</p>
<h2 id="nested-storage-vectors"><a class="header" href="#nested-storage-vectors">Nested Storage Vectors</a></h2>
<p>It is possible to nest storage vectors as follows:</p>
<pre><code class="language-sway">    nested_vec: StorageVec&lt;StorageVec&lt;u64&gt;&gt; = StorageVec {},
</code></pre>
<p>The nested vector can then be accessed as follows:</p>
<pre><code class="language-sway">    #[storage(read, write)]
    fn access_nested_vec() {
        storage.nested_vec.push(StorageVec {});
        storage.nested_vec.push(StorageVec {});

        let mut inner_vec0 = storage.nested_vec.get(0).unwrap();
        let mut inner_vec1 = storage.nested_vec.get(1).unwrap();

        inner_vec0.push(0);
        inner_vec0.push(1);

        inner_vec1.push(2);
        inner_vec1.push(3);
        inner_vec1.push(4);

        assert(inner_vec0.len() == 2);
        assert(inner_vec0.get(0).unwrap().read() == 0);
        assert(inner_vec0.get(1).unwrap().read() == 1);
        assert(inner_vec0.get(2).is_none());

        assert(inner_vec1.len() == 3);
        assert(inner_vec1.get(0).unwrap().read() == 2);
        assert(inner_vec1.get(1).unwrap().read() == 3);
        assert(inner_vec1.get(2).unwrap().read() == 4);
        assert(inner_vec1.get(3).is_none());
    }
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="storage-maps"><a class="header" href="#storage-maps">Storage Maps</a></h1>
<p>Another important common collection is the storage map.</p>
<!-- This section should explain storage maps in Sway -->
<!-- storage_map:example:start -->
<p>The type <code>StorageMap&lt;K, V&gt;</code> from the standard library stores a mapping of keys of type <code>K</code> to values of type <code>V</code> using a hashing function, which determines how it places these keys and values into <em>storage slots</em>. This is similar to <a href="https://doc.rust-lang.org/std/collections/struct.HashMap.html">Rust's <code>HashMap&lt;K, V&gt;</code></a> but with a few differences.</p>
<p>Storage maps are useful when you want to look up data not by using an index, as you can with vectors, but by using a key that can be of any type. For example, when building a ledger-based sub-currency smart contract, you could keep track of the balance of each wallet in a storage map in which each key is a walletâ€™s <code>Address</code> and the values are each walletâ€™s balance. Given an <code>Address</code>, you can retrieve its balance.</p>
<p>Similarly to <code>StorageVec&lt;T&gt;</code>, <code>StorageMap&lt;K, V&gt;</code> can only be used in a contract because only contracts are allowed to access persistent storage.</p>
<p><code>StorageMap&lt;T&gt;</code> is included in the <a href="common-collections/../introduction/standard_library.html#standard-library-prelude">standard library prelude</a> which means that there is no need to import it manually.</p>
<!-- storage_map:example:end -->
<h2 id="creating-a-new-storage-map"><a class="header" href="#creating-a-new-storage-map">Creating a New Storage Map</a></h2>
<p>To create a new empty storage map, we have to declare the map in a <code>storage</code> block as follows:</p>
<pre><code class="language-sway">    map: StorageMap&lt;Address, u64&gt; = StorageMap::&lt;Address, u64&gt; {},
</code></pre>
<!-- This section should explain how to implement storage maps in Sway -->
<!-- use_storage_maps:example:start -->
<p>Just like any other storage variable, two things are required when declaring a <code>StorageMap</code>: a type annotation and an initializer. The initializer is just an empty struct of type <code>StorageMap</code> because <code>StorageMap&lt;K, V&gt;</code> itself is an empty struct! Everything that is interesting about <code>StorageMap&lt;K, V&gt;</code> is implemented in its methods.</p>
<p>Storage maps, just like <code>Vec&lt;T&gt;</code> and <code>StorageVec&lt;T&gt;</code>, are implemented using generics which means that the <code>StorageMap&lt;K, V&gt;</code> type provided by the standard library can map keys of any type <code>K</code> to values of any type <code>V</code>. In the example above, weâ€™ve told the Sway compiler that the <code>StorageMap&lt;K, V&gt;</code> in <code>map</code> will map keys of type <code>Address</code> to values of type <code>u64</code>.</p>
<!-- use_storage_maps:example:end -->
<h2 id="updating-a-storage-map"><a class="header" href="#updating-a-storage-map">Updating a Storage Map</a></h2>
<!-- This section should explain how to update storage maps in Sway -->
<!-- update_storage_maps:example:start -->
<p>To insert key-value pairs into a storage map, we can use the <code>insert</code> method.</p>
<!-- update_storage_maps:example:end -->
<p>For example:</p>
<pre><code class="language-sway">    #[storage(write)]
    fn insert_into_storage_map() {
        let addr1 = Address::from(0x0101010101010101010101010101010101010101010101010101010101010101);
        let addr2 = Address::from(0x0202020202020202020202020202020202020202020202020202020202020202);

        storage.map.insert(addr1, 42);
        storage.map.insert(addr2, 77);
    }
</code></pre>
<p>Note two details here. First, in order to use <code>insert</code>, we need to first access the storage map using the <code>storage</code> keyword. Second, because <code>insert</code> requires <em>writing</em> into storage, a <code>#[storage(write)]</code> annotation is required on the ABI function that calls <code>insert</code>.</p>
<blockquote>
<p><strong>Note</strong>
The storage annotation is also required for any private function defined in the contract that tries to insert into the map.</p>
</blockquote>
<!-- markdownlint-disable-line MD028 -->
<blockquote>
<p><strong>Note</strong>
There is no need to add the <code>mut</code> keyword when declaring a <code>StorageMap&lt;K, V&gt;</code>. All storage variables are mutable by default.</p>
</blockquote>
<h2 id="accessing-values-in-a-storage-map"><a class="header" href="#accessing-values-in-a-storage-map">Accessing Values in a Storage Map</a></h2>
<!-- This section should explain how to access storage map values in Sway -->
<!-- access_storage_maps:example:start -->
<p>We can get a value out of the storage map by providing its <code>key</code> to the <code>get</code> method.</p>
<!-- access_storage_maps:example:end -->
<p>For example:</p>
<pre><code class="language-sway">    #[storage(read, write)]
    fn get_from_storage_map() {
        let addr1 = Address::from(0x0101010101010101010101010101010101010101010101010101010101010101);
        let addr2 = Address::from(0x0202020202020202020202020202020202020202020202020202020202020202);

        storage.map.insert(addr1, 42);
        storage.map.insert(addr2, 77);

        let value1 = storage.map.get(addr1).try_read().unwrap_or(0);
    }
</code></pre>
<p>Here, <code>value1</code> will have the value that's associated with the first address, and the result will be <code>42</code>. The <code>get</code> method returns an <code>Option&lt;V&gt;</code>; if thereâ€™s no value for that key in the storage map, <code>get</code> will return <code>None</code>. This program handles the <code>Option</code> by calling <code>unwrap_or</code> to set <code>value1</code> to zero if <code>map</code> doesn't have an entry for the key.</p>
<h2 id="storage-maps-with-multiple-keys"><a class="header" href="#storage-maps-with-multiple-keys">Storage Maps with Multiple Keys</a></h2>
<p>Maps with multiple keys can be implemented using tuples as keys. For example:</p>
<pre><code class="language-sway">    map_two_keys: StorageMap&lt;(b256, bool), b256&gt; = StorageMap::&lt;(b256, bool), b256&gt; {},
</code></pre>
<h2 id="nested-storage-maps"><a class="header" href="#nested-storage-maps">Nested Storage Maps</a></h2>
<p>It is possible to nest storage maps as follows:</p>
<pre><code class="language-sway">    nested_map: StorageMap&lt;u64, StorageMap&lt;u64, u64&gt;&gt; = StorageMap::&lt;u64, StorageMap&lt;u64, u64&gt;&gt; {},
</code></pre>
<p>The nested map can then be accessed as follows:</p>
<pre><code class="language-sway">    #[storage(read, write)]
    fn access_nested_map() {
        storage.nested_map.get(0).insert(1, 42);
        storage.nested_map.get(2).insert(3, 24);

        assert(storage.nested_map.get(0).get(1).read() == 42);
        assert(storage.nested_map.get(0).get(0).try_read().is_none()); // Nothing inserted here
        assert(storage.nested_map.get(2).get(3).read() == 24);
        assert(storage.nested_map.get(2).get(2).try_read().is_none()); // Nothing inserted here
    }
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="testing"><a class="header" href="#testing">Testing</a></h1>
<p>Sway aims to provide facilities for both unit testing and integration testing.</p>
<p><strong>Unit testing</strong> refers to "in-language" test functions annotated with <code>#[test]</code>.</p>
<p><strong>Integration testing</strong> refers to the testing of your Sway project's integration
within some wider application. You can add integration testing to your Sway+Rust
projects today using the cargo generate template and Rust SDK.</p>
<ul>
<li><a href="testing/./unit-testing.html">Unit Testing</a></li>
<li><a href="testing/./testing-with-rust.html">Testing with Rust</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="unit-testing"><a class="header" href="#unit-testing">Unit Testing</a></h1>
<!-- This section should explain unit testing in Sway -->
<!-- unit_test:example:start -->
<p>Forc provides built-in support for building and executing tests for a package.</p>
<p>Tests are written as free functions with the <code>#[test]</code> attribute.</p>
<!-- unit_test:example:end -->
<p>For example:</p>
<pre><code class="language-sway">#[test]
fn test_meaning_of_life() {
    assert(6 * 7 == 42);
}
</code></pre>
<p>Each test function is ran as if it were the entry point for a
<a href="testing/../sway-program-types/scripts.html">script</a>. Tests "pass" if they return
successfully, and "fail" if they revert or vice versa while <a href="testing/unit-testing.html#testing-failure">testing failure</a>.</p>
<p>If the project has failing tests <code>forc test</code> will exit with exit status <code>101</code>.</p>
<h2 id="building-and-running-tests"><a class="header" href="#building-and-running-tests">Building and Running Tests</a></h2>
<p>We can build and execute all tests within a package with the following:</p>
<pre><code class="language-console">forc test
</code></pre>
<p>The output should look similar to this:</p>
<pre><code class="language-console">  Compiled library "std".
  Compiled library "lib_single_test".
  Bytecode size is 92 bytes.
   Running 1 tests
      test test_meaning_of_life ... ok (170.652Âµs)
   Result: OK. 1 passed. 0 failed. Finished in 1.564996ms.
</code></pre>
<p>Visit the <a href="testing/../forc/commands/forc_test.html"><code>forc test</code></a> command reference to find
the options available for <code>forc test</code>.</p>
<h2 id="testing-failure"><a class="header" href="#testing-failure">Testing Failure</a></h2>
<!-- This section should explain support for failing unit tests in Sway -->
<!-- unit_test_fail:example:start -->
<p>Forc supports testing failing cases for test functions declared with <code>#[test(should_revert)]</code>.</p>
<!-- unit_test_fail:example:end -->
<p>For example:</p>
<pre><code class="language-sway">#[test(should_revert)]
fn test_meaning_of_life() {
    assert_eq(6 * 6, 42);
}
</code></pre>
<p>It is also possible to specify an expected revert code, like the following example.</p>
<pre><code class="language-sway">#[test(should_revert = "18446744073709486084")]
fn test_meaning_of_life() {
    assert_eq(6 * 6, 42);
}
</code></pre>
<p>Tests with <code>#[test(should_revert)]</code> are considered to be passing if they are reverting.</p>
<p>Available information about reverts is not shown by default in passing tests that have <code>should_revert</code>. To see revert information, use the <code>--reverts</code> flag, <code>forc test --reverts</code>:</p>
<pre><code class="language-console">  test test_meaning_of_life ... ok (52.432Âµs, 508 gas)
       revert code: ffffffffffff0003
        â””â”€ error message: Failing call to `std::assert::assert_eq`
</code></pre>
<h2 id="calling-contracts-1"><a class="header" href="#calling-contracts-1">Calling Contracts</a></h2>
<p>Unit tests can call contract functions. An example for such calls can be seen below.</p>
<pre><code class="language-sway">contract;

abi MyContract {
    fn test_function() -&gt; bool;
}

impl MyContract for Contract {
    fn test_function() -&gt; bool {
        true
    }
}
</code></pre>
<p>To test the <code>test_function()</code>, a unit test like the following can be written.</p>
<pre><code class="language-sway">#[test]
fn test_success() {
    let caller = abi(MyContract, CONTRACT_ID);
    let result = caller.test_function {}();
    assert(result == true);
}
</code></pre>
<p>It is also possible to test failure with contract calls as well.</p>
<pre><code class="language-sway">#[test(should_revert)]
fn test_fail() {
    let caller = abi(MyContract, CONTRACT_ID);
    let result = caller.test_function {}();
    assert(result == false);
}
</code></pre>
<!-- This section should explain how the `CONTRACT_ID` variable works in Sway unit tests -->
<!-- contract_id:example:start -->
<blockquote>
<p><strong>Note:</strong> When running <code>forc test</code>, your contract will be built twice: first <em>without</em> unit tests in order to determine the contract's ID, then a second time <em>with</em> unit tests with the <code>CONTRACT_ID</code> provided to their namespace. This <code>CONTRACT_ID</code> can be used with the <code>abi</code> cast to enable contract calls within unit tests.</p>
</blockquote>
<!-- contract_id:example:end -->
<p>Unit tests can call methods of external contracts if those contracts are added as contract dependencies, i.e. in the <a href="testing/../forc/manifest_reference.html#the-contract-dependencies-section"><code>contract-dependencies</code></a> section of the manifest file. An example of such calls is shown below:</p>
<pre><code class="language-sway">contract;

abi CallerContract {
    fn test_false() -&gt; bool;
}

impl CallerContract for Contract {
    fn test_false() -&gt; bool {
        false
    }
}

abi CalleeContract {
    fn test_true() -&gt; bool;
}

#[test]
fn test_multi_contract_calls() {
    let caller = abi(CallerContract, CONTRACT_ID);
    let callee = abi(CalleeContract, callee::CONTRACT_ID);

    let should_be_false = caller.test_false();
    let should_be_true = callee.test_true();
    assert(!should_be_false);
    assert(should_be_true);
}
</code></pre>
<p>Example <code>Forc.toml</code> for contract above:</p>
<pre><code class="language-toml">[project]
authors = ["Fuel Labs &lt;contact@fuel.sh&gt;"]
entry = "main.sw"
license = "Apache-2.0"
name = "caller"

[dependencies]
std = { path = "../../../sway-lib-std/" }

[contract-dependencies]
callee = { path = "../callee" }
</code></pre>
<h2 id="running-tests-in-parallel-or-serially"><a class="header" href="#running-tests-in-parallel-or-serially">Running Tests in Parallel or Serially</a></h2>
<!-- This section should explain how unit tests do not share storage -->
<!-- storage:example:start -->
<p>By default, all unit tests in your project are run in parallel. Note that this does not lead to any data races in storage because each unit test has its own storage space that is not shared by any other unit test.</p>
<!-- storage:example:end -->
<p>By default, <code>forc test</code> will use all the available threads in your system. To request that a specific number of threads be used, the flag <code>--test-threads &lt;val&gt;</code> can be provided to <code>forc test</code>.</p>
<pre><code class="language-console">forc test --test-threads 1
</code></pre>
<h2 id="logs-inside-tests"><a class="header" href="#logs-inside-tests">Logs Inside Tests</a></h2>
<!-- This section should explain how log decoding works with Sway unit tests -->
<!-- unit_test_log::example::start -->
<p>Forc has some capacity to help decode logs returned from the unit tests. You can use this feature to decode raw logs into a human readable format.</p>
<pre><code class="language-sway">script;

fn main() {}

#[test]
fn test_fn() {
    let a = 10;
    log(a);
    let b = 30;
    log(b);
    assert_eq(a, 10);
    assert_eq(b, 30);
}
</code></pre>
<p>The above example shows a passing test that is logging two different variables, <code>a</code> and <code>b</code>, and their values are <code>10</code> and <code>30</code>, respectively. Logs are silenced by default in passing tests, and can be enabled using the <code>--logs</code> flag, <code>forc test --logs</code>:</p>
<pre><code class="language-console">     Running 1 test, filtered 0 tests
      test test_fn ... ok (58.842Âµs, 0 gas)
Decoded log value: 10, log rb: 1515152261580153489
Decoded log value: 30, log rb: 1515152261580153489
</code></pre>
<p>The <code>--logs</code> flag prints decoded log values. If you want to see pretty-printed raw log receipts you can use the <code>--raw-logs --pretty</code> flags, <code>forc test --raw-logs --pretty</code>:</p>
<pre><code class="language-console">      test test_fn ... ok (54.042Âµs, 0 gas)
Raw logs:
[
  {
    "LogData": {
      "data": "000000000000000a",
      "digest": "8d85f8467240628a94819b26bee26e3a9b2804334c63482deacec8d64ab4e1e7",
      "id": "0000000000000000000000000000000000000000000000000000000000000000",
      "is": 10368,
      "len": 8,
      "pc": 11212,
      "ptr": 67107840,
      "ra": 0,
      "rb": 1515152261580153489
    }
  },
  {
    "LogData": {
      "data": "000000000000001e",
      "digest": "48a97e421546f8d4cae1cf88c51a459a8c10a88442eed63643dd263cef880c1c",
      "id": "0000000000000000000000000000000000000000000000000000000000000000",
      "is": 10368,
      "len": 8,
      "pc": 11212,
      "ptr": 67106816,
      "ra": 0,
      "rb": 1515152261580153489
    }
  }
]
</code></pre>
<p>The <code>--logs</code> and <code>--raw-logs</code> flags can be combined to print both the decoded and raw logs.</p>
<!-- unit_test_log::example::end -->
<div style="break-before: page; page-break-before: always;"></div><h1 id="testing-with-rust"><a class="header" href="#testing-with-rust">Testing with Rust</a></h1>
<p>A common use of Sway is for writing contracts or scripts that exist as part of a
wider Rust application. In order to test the interaction between our Sway code
and our Rust code we can add integration testing.</p>
<h2 id="adding-rust-integration-testing"><a class="header" href="#adding-rust-integration-testing">Adding Rust Integration Testing</a></h2>
<p>To add Rust integration testing to a Forc project we can use <a href="https://github.com/FuelLabs/sway/tree/master/templates/sway-test-rs">the <code>sway-test-rs</code>
cargo generate
template</a>.
This template makes it easier for Sway developers to add the boilerplate required when
setting up their Rust integration testing.</p>
<p>Let's add a Rust integration test to <a href="testing/../introduction/forc_project.html">the fresh project we created in the introduction</a>.</p>
<h3 id="1-enter-the-project"><a class="header" href="#1-enter-the-project">1. Enter the project</a></h3>
<p>To recap, here's what our empty project looks like:</p>
<pre><code class="language-console">$ cd my-fuel-project
$ tree .
â”œâ”€â”€ Forc.toml
â””â”€â”€ src
 Â Â  â””â”€â”€ main.sw
</code></pre>
<h3 id="2-install-cargo-generate"><a class="header" href="#2-install-cargo-generate">2. Install <code>cargo generate</code></a></h3>
<p>We're going to add a Rust integration test harness using a cargo generate
template. Let's make sure we have the <code>cargo generate</code> command installed!</p>
<pre><code class="language-console">cargo install cargo-generate
</code></pre>
<blockquote>
<p><em><strong>Note</strong>: You can learn more about cargo generate by visiting the
<a href="https://github.com/cargo-generate/cargo-generate">cargo-generate repository</a>.</em></p>
</blockquote>
<h3 id="3-generate-the-test-harness"><a class="header" href="#3-generate-the-test-harness">3. Generate the test harness</a></h3>
<p>Let's generate the default test harness with the following:</p>
<pre><code class="language-console">cargo generate --init fuellabs/sway templates/sway-test-rs --name my-fuel-project --force
</code></pre>
<p><code>--force</code> forces your <code>--name</code> input to retain your desired casing for the <code>{{project-name}}</code>
placeholder in the template. Otherwise, <code>cargo-generate</code> automatically converts it to <code>kebab-case</code>.
With <code>--force</code>, this means that both <code>my_fuel_project</code> and <code>my-fuel-project</code> are valid project names,
depending on your needs.</p>
<blockquote>
<p>_<strong>Note</strong>: <code>templates/sway-test-rs</code> can be replaced with <code>templates/sway-script-test-rs</code> or <code>templates/sway-predicate-test-rs</code> to generate a test
harness for scripts and predicates respectively.</p>
</blockquote>
<p>If all goes well, the output should look as follows:</p>
<pre><code class="language-console">âš ï¸   Favorite `fuellabs/sway` not found in config, using it as a git repository: https://github.com/fuellabs/sway
ðŸ¤·   Project Name : my-fuel-project
ðŸ”§   Destination: /home/user/path/to/my-fuel-project ...
ðŸ”§   Generating template ...
[1/3]   Done: Cargo.toml
[2/3]   Done: tests/harness.rs
[3/3]   Done: tests
ðŸ”§   Moving generated files into: `/home/user/path/to/my-fuel-project`...
âœ¨   Done! New project created /home/user/path/to/my-fuel-project
</code></pre>
<p>Let's have a look at the result:</p>
<pre><code class="language-console">$ tree .
â”œâ”€â”€ Cargo.toml
â”œâ”€â”€ Forc.toml
â”œâ”€â”€ build.rs
â”œâ”€â”€ src
â”‚Â Â  â””â”€â”€ main.sw
â””â”€â”€ tests
    â””â”€â”€ harness.rs
</code></pre>
<p>We have three new files!</p>
<ul>
<li>The <code>Cargo.toml</code> is the manifest for our new test harness and specifies the
required dependencies including <code>fuels</code> the Fuel Rust SDK.</li>
<li>The <code>tests/harness.rs</code> contains some boilerplate test code to get us started,
though doesn't call any contract methods just yet.</li>
<li>The <code>build.rs</code> is a build script that compiles the Sway project with <code>forc build</code>
whenever <code>cargo test</code> is run.</li>
</ul>
<h3 id="4-build-the-forc-project"><a class="header" href="#4-build-the-forc-project">4. Build the forc project</a></h3>
<p>Before running the tests, we need to build our contract so that the necessary
ABI, storage and bytecode artifacts are available. We can do so with <code>forc build</code>:</p>
<pre><code class="language-console">$ forc build
  Creating a new `Forc.lock` file. (Cause: lock file did not exist)
    Adding std git+https://github.com/fuellabs/sway?tag=v0.24.5#e695606d8884a18664f6231681333a784e623bc9
   Created new lock file at /home/user/path/to/my-fuel-project/Forc.lock
  Compiled library "std".
  Compiled contract "my-fuel-project".
  Bytecode size is 60 bytes.
</code></pre>
<p>At this point, our project should look like the following:</p>
<pre><code class="language-console">$ tree
â”œâ”€â”€ Cargo.toml
â”œâ”€â”€ Forc.lock
â”œâ”€â”€ Forc.toml
â”œâ”€â”€ build.rs
â”œâ”€â”€ out
â”‚Â Â  â””â”€â”€ debug
â”‚Â Â      â”œâ”€â”€ my-fuel-project-abi.json
â”‚Â Â      â”œâ”€â”€ my-fuel-project.bin
â”‚Â Â      â””â”€â”€ my-fuel-project-storage_slots.json
â”œâ”€â”€ src
â”‚Â Â  â””â”€â”€ main.sw
â””â”€â”€ tests
    â””â”€â”€ harness.rs
</code></pre>
<p>We now have an <code>out</code> directory with our required JSON files!</p>
<blockquote>
<p><em><strong>Note</strong>: This step may no longer be required in the future as we plan to
enable the integration testing to automatically build the artifacts as
necessary so that files like the ABI JSON are always up to date.</em></p>
</blockquote>
<h3 id="5-build-and-run-the-tests"><a class="header" href="#5-build-and-run-the-tests">5. Build and run the tests</a></h3>
<p>Now we're ready to build and run the default integration test.</p>
<pre><code class="language-console">$ cargo test
    Updating crates.io index
   Compiling version_check v0.9.4
   Compiling proc-macro2 v1.0.46
   Compiling quote v1.0.21
   ...
   Compiling fuels v0.24.0
   Compiling my-fuel-project v0.1.0 (/home/user/path/to/my-fuel-project)
    Finished test [unoptimized + debuginfo] target(s) in 1m 03s
     Running tests/harness.rs (target/debug/deps/integration_tests-373971ac377845f7)

running 1 test
test can_get_contract_id ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.36s
</code></pre>
<blockquote>
<p><em><strong>Note</strong>: The first time we run <code>cargo test</code>, cargo will spend some time
fetching and building the dependencies for Fuel's Rust SDK. This might take a
while, but only the first time!</em></p>
</blockquote>
<p>If all went well, we should see some output that looks like the above!</p>
<h2 id="writing-tests"><a class="header" href="#writing-tests">Writing Tests</a></h2>
<p>Now that we've learned how to setup Rust integration testing in our project,
let's try to write some of our own tests!</p>
<p>First, let's update our contract code with a simple counter example:</p>
<pre><code class="language-sway">contract;

abi TestContract {
    #[storage(write)]
    fn initialize_counter(value: u64) -&gt; u64;

    #[storage(read, write)]
    fn increment_counter(amount: u64) -&gt; u64;
}

storage {
    counter: u64 = 0,
}

impl TestContract for Contract {
    #[storage(write)]
    fn initialize_counter(value: u64) -&gt; u64 {
        storage.counter.write(value);
        value
    }

    #[storage(read, write)]
    fn increment_counter(amount: u64) -&gt; u64 {
        let incremented = storage.counter.read() + amount;
        storage.counter.write(incremented);
        incremented
    }
}
</code></pre>
<p>To test our <code>initialize_counter</code> and <code>increment_counter</code> contract methods from
the Rust test harness, we could update our <code>tests/harness.rs</code> file with the
following:</p>
<!--TODO add test here once examples are tested-->
<pre><code class="language-rust ignore">use fuels::{prelude::*, types::ContractId};

// Load abi from json
abigen!(Contract(
    name = "MyContract",
    abi = "out/debug/my-fuel-project-abi.json"
));

async fn get_contract_instance() -&gt; (MyContract&lt;WalletUnlocked&gt;, ContractId) {
    // Launch a local network and deploy the contract
    let mut wallets = launch_custom_provider_and_get_wallets(
        WalletsConfig::new(
            Some(1),             /* Single wallet */
            Some(1),             /* Single coin (UTXO) */
            Some(1_000_000_000), /* Amount per coin */
        ),
        None,
        None,
    )
    .await
    .unwrap();
    let wallet = wallets.pop().unwrap();

    let id = Contract::load_from(
        "./out/debug/my-fuel-project.bin",
        LoadConfiguration::default().set_storage_configuration(
            StorageConfiguration::load_from(
                "./out/debug/my-fuel-project-storage_slots.json",
            )
            .unwrap(),
        ),
    )
    .unwrap()
    .deploy(&amp;wallet, TxPolicies::default())
    .await
    .unwrap();

    let instance = MyContract::new(id.clone(), wallet);

    (instance, id.into())
}

#[tokio::test]
async fn initialize_and_increment() {
    let (contract_instance, _id) = get_contract_instance().await;
    // Now you have an instance of your contract you can use to test each function

    let result = contract_instance
        .methods()
        .initialize_counter(42)
        .call()
        .await
        .unwrap();

    assert_eq!(42, result.value);

    // Call `increment_counter()` method in our deployed contract.
    let result = contract_instance
        .methods()
        .increment_counter(10)
        .call()
        .await
        .unwrap();

    assert_eq!(52, result.value);
}</code></pre>
<p>Let's build our project once more and run the test:</p>
<pre><code class="language-console">forc build
</code></pre>
<pre><code class="language-console">$ cargo test
   Compiling my-fuel-project v0.1.0 (/home/mindtree/programming/sway/my-fuel-project)
    Finished test [unoptimized + debuginfo] target(s) in 11.61s
     Running tests/harness.rs (target/debug/deps/integration_tests-373971ac377845f7)

running 1 test
test initialize_and_increment ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 1.25s
</code></pre>
<p>When cargo runs our test, our test uses the SDK to spin up a local in-memory
Fuel network, deploy our contract to it, and call the contract methods via the
ABI.</p>
<p>You can add as many functions decorated with <code>#[tokio::test]</code> as you like, and
<code>cargo test</code> will automatically test each of them!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="forc-call"><a class="header" href="#forc-call">Forc Call</a></h1>
<p><code>forc-call</code> is a command-line tool for interacting with deployed Fuel contracts. It allows you to make contract calls, query contract state, and interact with any deployed contract on the Fuel network - all from your command line!</p>
<p>The <code>forc call</code> command is part of the Forc toolchain and is installed alongside other Forc tools.</p>
<h2 id="getting-started-1"><a class="header" href="#getting-started-1">Getting Started</a></h2>
<p>Here are a few examples of what you can do with <code>forc call</code>:</p>
<pre><code class="language-sway">contract;

abi ContractABI {
  fn add(a: u64, b: u64) -&gt; u64;
}

impl ContractABI for Contract {
  fn add(a: u64, b: u64) -&gt; u64 {
    a + b
  }
}
</code></pre>
<h3 id="list-callable-functions-of-a-contract-given-its-abi-file"><a class="header" href="#list-callable-functions-of-a-contract-given-its-abi-file">List callable functions of a contract given it's ABI file</a></h3>
<pre><code class="language-bash">forc call 0xe18de7c7c8c61a1c706dccb3533caa00ba5c11b5230da4428582abf1b6831b4d \
  --abi ./out/debug/counter-contract-abi.json \
  --list-functions
</code></pre>
<p>Output:</p>
<pre><code class="language-log">Available functions in contract: 0xe18de7c7c8c61a1c706dccb3533caa00ba5c11b5230da4428582abf1b6831b4d

add(a: u64, b: u64) -&gt; u64
  forc call \
    --abi ./out/debug/counter-contract-abi.json \
    0xe18de7c7c8c61a1c706dccb3533caa00ba5c11b5230da4428582abf1b6831b4d \
    add "0" "0"
</code></pre>
<h3 id="list-functions-from-multiple-contracts-with-additional-abis"><a class="header" href="#list-functions-from-multiple-contracts-with-additional-abis">List functions from multiple contracts with additional ABIs</a></h3>
<pre><code class="language-bash">forc call 0xe18de7c7c8c61a1c706dccb3533caa00ba5c11b5230da4428582abf1b6831b4d \
  --abi ./out/debug/counter-contract-abi.json \
  --contract-abi 0xf8f8b6283d7fa5b672b530cbb84fcccb4ff8dc40f8176ef4544ddb1f1952ad07:./token-abi.json \
  --contract-abi 0x1234567890abcdef:https://example.com/pool-abi.json \
  --list-functions
</code></pre>
<h3 id="call-a-simple-addition-function-on-a-deployed-contract-in-dry-run-mode"><a class="header" href="#call-a-simple-addition-function-on-a-deployed-contract-in-dry-run-mode">Call a simple addition function on a deployed contract (in dry-run mode)</a></h3>
<pre><code class="language-bash">forc call 0xe18de7c7c8c61a1c706dccb3533caa00ba5c11b5230da4428582abf1b6831b4d \
  --abi ./out/debug/counter-contract-abi.json \
  add 1 2
</code></pre>
<h3 id="call-a-contract-with-labeled-addresses-for-better-trace-readability"><a class="header" href="#call-a-contract-with-labeled-addresses-for-better-trace-readability">Call a contract with labeled addresses for better trace readability</a></h3>
<pre><code class="language-bash">forc call 0xe18de7c7c8c61a1c706dccb3533caa00ba5c11b5230da4428582abf1b6831b4d \
  --abi ./out/debug/counter-contract-abi.json \
  transfer 0xf8f8b6283d7fa5b672b530cbb84fcccb4ff8dc40f8176ef4544ddb1f1952ad07 \
  --label 0xe18de7c7c8c61a1c706dccb3533caa00ba5c11b5230da4428582abf1b6831b4d:MainContract \
  --label 0xf8f8b6283d7fa5b672b530cbb84fcccb4ff8dc40f8176ef4544ddb1f1952ad07:TokenContract \
  -vvv
</code></pre>
<h3 id="directly-send-funds-to-an-address"><a class="header" href="#directly-send-funds-to-an-address">Directly send funds to an address</a></h3>
<pre><code class="language-bash">forc call 0x2c7Fd852EF2BaE281e90ccaDf18510701989469f7fc4b042F779b58a39919Eec --amount 2 --mode=live
</code></pre>
<h3 id="query-the-owner-of-a-deployed-dex-contract-on-testnet"><a class="header" href="#query-the-owner-of-a-deployed-dex-contract-on-testnet">Query the owner of a deployed <a href="https://github.com/mira-amm/mira-v1-core">DEX contract</a> on testnet</a></h3>
<pre><code class="language-bash">forc call \
  --testnet \
  --abi https://raw.githubusercontent.com/mira-amm/mira-v1-periphery/refs/heads/main/fixtures/mira-amm/mira_amm_contract-abi.json \
  0xd5a716d967a9137222219657d7877bd8c79c64e1edb5de9f2901c98ebe74da80 \
  owner
</code></pre>
<h2 id="usage"><a class="header" href="#usage">Usage</a></h2>
<p>Forc call has <strong>3</strong> usage modes:</p>
<h3 id="list-functions"><a class="header" href="#list-functions">List functions</a></h3>
<p>Syntax for <code>forc call</code> for listing supported functions from the ABI - with example command to perform call operation:</p>
<pre><code class="language-bash">forc call --abi &lt;ABI-PATH/URL&gt; &lt;CONTRACT_ID&gt; --list-functions
</code></pre>
<p>You can also list functions from multiple contracts by providing additional contract ABIs:</p>
<pre><code class="language-bash">forc call --abi &lt;MAIN-ABI-PATH/URL&gt; &lt;MAIN-CONTRACT_ID&gt; \
  --contract-abi &lt;CONTRACT_ID&gt;:&lt;ABI-PATH/URL&gt; \
  --contract-abi &lt;ANOTHER-CONTRACT_ID&gt;:&lt;ABI-PATH/URL&gt; \
  --list-functions
</code></pre>
<p>Where the following arguments are required:</p>
<ul>
<li><code>ABI-PATH/URL</code> is the path or URL to the contract's JSON ABI file</li>
<li><code>CONTRACT_ID</code> is the ID of the deployed contract you want to interact with</li>
<li><code>--contract-abi</code> (optional) allows you to specify additional contracts and their ABIs to list functions from multiple contracts at once</li>
</ul>
<h3 id="transfer-assets"><a class="header" href="#transfer-assets">Transfer assets</a></h3>
<p>Syntax for <code>forc call</code> for transferring assets:</p>
<pre><code class="language-bash">forc call &lt;RECEIVER_ADDRESS&gt; --amount &lt;AMOUNT&gt; --mode=live
</code></pre>
<p>Where the following arguments are required:</p>
<ul>
<li><code>RECEIVER_ADDRESS</code> is address of the receiver (identity or contract).</li>
<li><code>AMOUNT</code> is the amount of assets to transfer.</li>
</ul>
<p>Note: only live mode <code>--mode=live</code> is supported; transfers cannot be simulated.</p>
<h3 id="call-contracts"><a class="header" href="#call-contracts">Call contracts</a></h3>
<p>Syntax for <code>forc call</code> for contract calls:</p>
<pre><code class="language-bash">forc call [OPTIONS] --abi &lt;ABI-PATH/URL&gt; &lt;CONTRACT_ID&gt; &lt;SELECTOR&gt; [ARGS]...
</code></pre>
<p>Where the following arguments are required:</p>
<ul>
<li><code>CONTRACT_ID</code> is the ID of the deployed contract you want to interact with</li>
<li><code>ABI-PATH/URL</code> is the path or URL to the contract's JSON ABI file</li>
<li><code>SELECTOR</code> is the function name (selector) you want to call</li>
<li><code>ARGS</code> are the arguments to pass to the function</li>
</ul>
<h2 id="type-encoding"><a class="header" href="#type-encoding">Type Encoding</a></h2>
<p>When passing arguments to contract functions, values are encoded according to their Sway types.
Here's how to format different types:</p>
<div class="table-wrapper"><table><thead><tr><th>Types</th><th>Example input</th><th>Notes</th></tr></thead><tbody>
<tr><td>bool</td><td><code>true</code> or <code>false</code></td><td></td></tr>
<tr><td>u8, u16, u32, u64, u128, u256</td><td><code>42</code></td><td></td></tr>
<tr><td>b256</td><td><code>0x0000000000000000000000000000000000000000000000000000000000000042</code> or <code>0000000000000000000000000000000000000000000000000000000000000042</code></td><td><code>0x</code> prefix is optional</td></tr>
<tr><td>bytes, RawSlice</td><td><code>0x42</code> or <code>42</code></td><td><code>0x</code> prefix is optional</td></tr>
<tr><td>String, StringSlice, StringArray (Fixed-size)</td><td><code>"abc"</code></td><td></td></tr>
<tr><td>Tuple</td><td><code>(42, true)</code></td><td>The types in tuple can be different</td></tr>
<tr><td>Array (Fixed-size), Vector (Dynamic)</td><td><code>[42, 128]</code></td><td>The types in array or vector must be the same; i.e. you cannot have <code>[42, true]</code></td></tr>
<tr><td>Struct</td><td><code>{42, 128}</code></td><td>Since structs are packed encoded, the attribute names are not encoded; i.e. <code>{42, 128}</code>; this could represent the following <code>struct Polygon { x: u64, y: u64 }</code></td></tr>
<tr><td>Enum</td><td><code>(Active: true)</code> or <code>(1: true)</code></td><td>Enums are key-val pairs with keys as being variant name (case-sensitive) or variant index (starting from 0) and values as being the variant value; this could represent the following <code>enum MyEnum { Inactive, Active(bool) }</code></td></tr>
</tbody></table>
</div>
<h2 id="abi-support"><a class="header" href="#abi-support">ABI Support</a></h2>
<p>The ABI (Application Binary Interface) can be provided in two ways.</p>
<h3 id="local-file"><a class="header" href="#local-file">Local file</a></h3>
<pre><code class="language-bash">forc call &lt;CONTRACT_ID&gt; --abi ./path/to/abi.json &lt;FUNCTION&gt; [ARGS...]
</code></pre>
<h3 id="remote-abi-fileurl"><a class="header" href="#remote-abi-fileurl">Remote ABI file/URL</a></h3>
<pre><code class="language-bash">forc call &lt;CONTRACT_ID&gt; --abi https://example.com/abi.json &lt;FUNCTION&gt; [ARGS...]
</code></pre>
<h2 id="network-configuration"><a class="header" href="#network-configuration">Network Configuration</a></h2>
<pre><code class="language-bash">forc call --node-url http://127.0.0.1:4000 ...
# or
forc call --target local ...
</code></pre>
<h2 id="advanced-usage"><a class="header" href="#advanced-usage">Advanced Usage</a></h2>
<h3 id="using-wallets"><a class="header" href="#using-wallets">Using Wallets</a></h3>
<pre><code class="language-sh"># utilising the forc-wallet
forc call &lt;CONTRACT_ID&gt; --abi &lt;PATH&gt; &lt;FUNCTION&gt; --wallet
</code></pre>
<pre><code class="language-sh"># with an explicit signing key
forc call &lt;CONTRACT_ID&gt; --abi &lt;PATH&gt; &lt;FUNCTION&gt; --signing-key &lt;KEY&gt;
</code></pre>
<h3 id="asset-transfers"><a class="header" href="#asset-transfers">Asset Transfers</a></h3>
<pre><code class="language-sh"># Native asset transfer
forc call &lt;CONTRACT_ID&gt; --abi &lt;PATH&gt; &lt;FUNCTION&gt; --amount 100 --live
</code></pre>
<pre><code class="language-sh"># Custom asset transfer
forc call &lt;CONTRACT_ID&gt; --abi &lt;PATH&gt; &lt;FUNCTION&gt; \
    --amount 100 \
    --asset-id 0x1234... \
    --live
</code></pre>
<h3 id="gas-configuration"><a class="header" href="#gas-configuration">Gas Configuration</a></h3>
<pre><code class="language-sh"># Set gas price
forc call &lt;CONTRACT_ID&gt; --abi &lt;PATH&gt; &lt;FUNCTION&gt; --gas-price 1

# Forward gas to contract
forc call &lt;CONTRACT_ID&gt; --abi &lt;PATH&gt; &lt;FUNCTION&gt; --gas-forwarded 1000

# Set maximum fee
forc call &lt;CONTRACT_ID&gt; --abi &lt;PATH&gt; &lt;FUNCTION&gt; --max-fee 5000
</code></pre>
<h3 id="transaction-tracing"><a class="header" href="#transaction-tracing">Transaction Tracing</a></h3>
<p>When you need to debug contract interactions or understand the execution flow, <code>forc call</code> provides detailed transaction traces with verbosity level 2 or higher (<code>-vv</code> or <code>-v=2</code>).</p>
<pre><code class="language-sh"># Enable transaction tracing
forc call &lt;CONTRACT_ID&gt; --abi &lt;PATH&gt; &lt;FUNCTION&gt; -vv
</code></pre>
<p>The transaction trace provides a hierarchical view of all contract calls, showing:</p>
<ul>
<li>Gas consumption for each call (<code>[gas_amount]</code>)</li>
<li>Contract addresses being called</li>
<li>Return values and data</li>
<li>Emitted logs and events</li>
<li>Nested contract calls with proper indentation</li>
<li>Overall transaction result and gas usage</li>
</ul>
<h4 id="enhancing-traces-with-labels"><a class="header" href="#enhancing-traces-with-labels">Enhancing Traces with Labels</a></h4>
<p>For better readability, you can label contract addresses in transaction traces using the <code>--label</code> flag:</p>
<pre><code class="language-sh"># Add human-readable labels to contract addresses
forc call &lt;CONTRACT_ID&gt; \
  --abi &lt;PATH&gt; \
  &lt;FUNCTION&gt; \
  --label &lt;CONTRACT_ID&gt;:MainContract \
  --label &lt;OTHER_CONTRACT_ID&gt;:TokenContract \
  -vv
</code></pre>
<p><strong>Without labels:</strong></p>
<pre><code class="language-log">â”œâ”€ [8793] 0x2af09151f8276611ba65f14650970657bc42c1503d6502ffbb4d085ec37065dd::transfer(100, 0x123)
â”‚    â””â”€ â† ()
</code></pre>
<p><strong>With labels:</strong></p>
<pre><code class="language-log">â”œâ”€ [8793] TokenContract::transfer(100, 0x123)
â”‚    â””â”€ â† ()
</code></pre>
<h4 id="improving-trace-decoding-with-additional-abis"><a class="header" href="#improving-trace-decoding-with-additional-abis">Improving Trace Decoding with Additional ABIs</a></h4>
<p>For complex multi-contract interactions, you can provide additional contract ABIs to improve function signature and return data decoding:</p>
<pre><code class="language-sh"># Add additional contract ABIs for better trace decoding
forc call &lt;CONTRACT_ID&gt; \
  --abi &lt;MAIN_ABI_PATH&gt; \
  &lt;FUNCTION&gt; \
  --contract-abi &lt;OTHER_CONTRACT_ID&gt;:./external-abi.json \
  --contract-abi &lt;THIRD_CONTRACT_ID&gt;:https://example.com/abi.json \
  -vv
</code></pre>
<p>This helps decode:</p>
<ul>
<li>Function names</li>
<li>Function parameters in readable format</li>
<li>Return values in structured format instead of raw hex</li>
</ul>
<h4 id="example-transaction-trace-output"><a class="header" href="#example-transaction-trace-output">Example Transaction Trace Output</a></h4>
<pre><code class="language-bash">forc call 0x9275a76531bce733cfafdbcb6727ea533ebbdc358d685152169b3c4eaa47b965 \
  --abi ./demo/demo-caller-abi.json \
  call_increment_count \
  --label 0x9275a76531bce733cfafdbcb6727ea533ebbdc358d685152169b3c4eaa47b965:DemoCaller \
  --label 0xb792b1e233a2c06bccec611711acc3bb61bdcb28f16abdde86d1478ee02f6e42:Counter \
  --contract-abi 0xb792b1e233a2c06bccec611711acc3bb61bdcb28f16abdde86d1478ee02f6e42:./counter-abi.json \
  -vv
</code></pre>
<p><strong>Output:</strong></p>
<pre><code class="language-log">Traces:
  [Script]
    â”œâ”€ [124116] DemoCaller::call_increment_count()
    â”‚    â”œâ”€ [111500] Counter::increment()
    â”‚    â”‚    â””â”€ â† ()
    â”‚    â”œâ”€ emit AsciiString { data: "incremented count" }
    â”‚    â”œâ”€ [86284] Counter::get_count()
    â”‚    â”‚    â””â”€ â† 0x0000000000000002
    â”‚    â”œâ”€ emit 2
    â”‚    â”œâ”€ emit AsciiString { data: "done" }
    â”‚    â”œâ”€ [72699] Counter::increment()
    â”‚    â”‚    â””â”€ â† ()
    â”‚    â”œâ”€ [48287] Counter::get_count()
    â”‚    â”‚    â””â”€ â† 0x0000000000000003
    â”‚    â””â”€ â† 0x0000000000000003
    â””â”€ â† [Return] val: 1
  [ScriptResult] result: Success, gas_used: 89279

Transaction successfully executed.
Gas used: 160676
</code></pre>
<h4 id="understanding-the-trace-format"><a class="header" href="#understanding-the-trace-format">Understanding the Trace Format</a></h4>
<ul>
<li><code>[Script]</code> - The root transaction script</li>
<li><code>â”œâ”€ [gas_amount] ContractLabel::function_name(args)</code> - A contract call with gas consumption and decoded function info</li>
<li><code>â”‚    â””â”€ â† value</code> - Return value from the contract call</li>
<li><code>emit data</code> - Log/event emitted by the contract</li>
<li>Indentation shows the call hierarchy (nested calls are indented further)</li>
<li><code>[ScriptResult]</code> - Final transaction result with gas used by the script</li>
<li><code>Gas used: &lt;gas_used&gt;</code> - Total gas used by the transaction</li>
</ul>
<p>This tracing feature is particularly useful for:</p>
<ul>
<li>Debugging failed transactions</li>
<li>Understanding gas consumption patterns</li>
<li>Analyzing complex multi-contract interactions</li>
<li>Verifying expected contract behavior</li>
</ul>
<h3 id="common-use-cases"><a class="header" href="#common-use-cases">Common Use Cases</a></h3>
<h4 id="contract-state-queries"><a class="header" href="#contract-state-queries">Contract State Queries</a></h4>
<pre><code class="language-sh"># Read contract state
forc call &lt;CONTRACT_ID&gt; --abi &lt;PATH&gt; get_balance

# Query with parameters
forc call &lt;CONTRACT_ID&gt; --abi &lt;PATH&gt; get_user_info 0x1234...

# Update contract state
forc call &lt;CONTRACT_ID&gt; --abi &lt;PATH&gt; update_state 42 --live
</code></pre>
<h4 id="token-operations"><a class="header" href="#token-operations">Token Operations</a></h4>
<pre><code class="language-sh"># Transfer assets/tokens to an address
forc call &lt;ADDRESS&gt; --amount 100 --live
</code></pre>
<h4 id="multi-contract-debugging"><a class="header" href="#multi-contract-debugging">Multi-Contract Debugging</a></h4>
<pre><code class="language-sh"># Debug complex multi-contract interactions
forc call &lt;MAIN_CONTRACT_ID&gt; \
  --abi &lt;MAIN_ABI_PATH&gt; \
  complex_operation \
  --label &lt;MAIN_CONTRACT_ID&gt;:MainContract \
  --label &lt;TOKEN_CONTRACT_ID&gt;:TokenContract \
  --label &lt;POOL_CONTRACT_ID&gt;:LiquidityPool \
  --contract-abi &lt;TOKEN_CONTRACT_ID&gt;:./token-abi.json \
  --contract-abi &lt;POOL_CONTRACT_ID&gt;:./pool-abi.json \
  -vv
</code></pre>
<h3 id="cli-parameters-reference"><a class="header" href="#cli-parameters-reference">CLI Parameters Reference</a></h3>
<h4 id="trace-enhancement-options"><a class="header" href="#trace-enhancement-options">Trace Enhancement Options</a></h4>
<ul>
<li>
<p><code>--label &lt;contract_id&gt;:&lt;label&gt;</code> - Add human-readable labels for contract addresses in traces</p>
<ul>
<li>Can be used multiple times</li>
<li>Contract ID can include or omit <code>0x</code> prefix</li>
<li>Example: <code>--label 0x123:MainContract</code></li>
</ul>
</li>
<li>
<p><code>--contract-abi &lt;contract_id&gt;:&lt;abi_path&gt;</code> - Specify additional contract ABIs for better trace decoding</p>
<ul>
<li>Can be used multiple times</li>
<li>Supports both local files and URLs</li>
<li>Contract ID can include or omit <code>0x</code> prefix</li>
<li>Example: <code>--contract-abi 0x123:./abi.json</code> or <code>--contract-abi 0x456:https://example.com/abi.json</code></li>
</ul>
</li>
<li>
<p><code>-v, -vv, -vvv</code> - Verbosity levels for trace output</p>
<ul>
<li><code>-v</code>: Show decoded logs</li>
<li><code>-vv</code>: Additionally show transaction traces</li>
<li><code>-vvv</code>: Additionally show receipts and script JSON</li>
</ul>
</li>
</ul>
<h2 id="tips-and-tricks"><a class="header" href="#tips-and-tricks">Tips and Tricks</a></h2>
<ul>
<li>Use <code>--mode simulate</code> to estimate gas costs before making live transactions</li>
<li>External contracts are automatically detected (via internal simulations), but can be manually specified with <code>--external-contracts</code></li>
<li>For complex parameter types (tuples, structs, enums), refer to the parameter types table above</li>
<li>Always verify contract addresses and ABIs before making live calls</li>
<li>Use environment variables for sensitive data like signing keys: <code>SIGNING_KEY=&lt;key&gt;</code></li>
<li><strong>Use labels for better trace readability</strong>: Add <code>--label</code> flags to replace long contract addresses with meaningful names in traces</li>
<li><strong>Provide additional ABIs for multi-contract calls</strong>: Use <code>--contract-abi</code> to decode function calls and return values from external contracts</li>
<li><strong>Combine labels and ABIs</strong>: Use both together for the most readable and informative transaction traces</li>
</ul>
<h2 id="troubleshooting"><a class="header" href="#troubleshooting">Troubleshooting</a></h2>
<h3 id="common-issues-and-solutions"><a class="header" href="#common-issues-and-solutions">Common issues and solutions</a></h3>
<ul>
<li>
<p><strong>ABI Mismatch</strong>:</p>
<ul>
<li>Ensure the ABI matches the deployed contract</li>
<li>Verify function selectors match exactly</li>
<li>Check that additional contract ABIs match their respective contracts</li>
</ul>
</li>
<li>
<p><strong>Parameter Type Errors</strong>:</p>
<ul>
<li>Check parameter formats in the types table</li>
<li>Ensure correct number of parameters</li>
</ul>
</li>
<li>
<p><strong>Network Issues</strong>:</p>
<ul>
<li>Verify node connection</li>
<li>Check network selection (testnet/mainnet)</li>
</ul>
</li>
<li>
<p><strong>Transaction Failures</strong>:</p>
<ul>
<li>Use simulation mode to debug</li>
<li>Check gas settings</li>
<li>Verify wallet has sufficient balance</li>
</ul>
</li>
<li>
<p><strong>Trace Decoding Issues</strong>:</p>
<ul>
<li>Ensure contract ABIs are correctly specified</li>
<li>Verify contract addresses in labels match deployed contracts</li>
<li>Check that ABI files are accessible (for both local files and URLs)</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="debugging"><a class="header" href="#debugging">Debugging</a></h1>
<p>Forc provides tools for debugging both live transactions as well as Sway unit tests.
Debugging can be done via CLI or using the VSCode IDE.</p>
<p><strong>Unit testing</strong> refers to "in-language" test functions annotated with <code>#[test]</code>. Line-by-line
debugging is available within the VSCode IDE.</p>
<p><strong>Live transaction</strong> refers to the testing sending a transaction to a running Fuel Client
node to exercise your Sway code. Instruction-by-instruction debugging is available in the <code>forc debug</code> CLI.</p>
<ul>
<li><a href="debugging/./debugging_with_cli.html">Debugging with CLI</a></li>
<li><a href="debugging/./debugging_with_ide.html">Debugging with IDE</a></li>
</ul>
<h2 id="__dbg-intrinsic-function"><a class="header" href="#__dbg-intrinsic-function"><code>__dbg</code> intrinsic function</a></h2>
<p>Sway also offers the <code>__dbg</code> intrinsic function to help debug all applications types: scripts, contracts and predicates.
When called, this intrinsic function will print the current file, line and column, together with a customizable print of the specified value.</p>
<pre><code class="language-sway">script;
fn main() -&gt; u64 {
    __dbg(1u64)
}
</code></pre>
<p>The application above will print:</p>
<pre><code class="language-terminal">[src/main.sw:3:5] = 1
</code></pre>
<p>Structs can be customized by implementing the <code>Debug</code> trait.</p>
<pre><code class="language-sway">script;
struct S { }
impl Debug for S {
    fn fmt(self, ref mut f: Formatter) {
        f.debug_struct("S2")
            .field("field1", 1)
            .field("field2", "Hello")
            .finish();
    }
}
fn main() -&gt; u64 {
    let _ = __dbg(S {});
    __dbg(1u64)
}
</code></pre>
<p>This code is very similar to what the Sway compiler generates by default for all declared types.
And this is what is printed:</p>
<pre><code class="language-terminal">[src/main.sw:12:13] = S2 { field1: 1, field2: "Hello" }
[src/main.sw:13:5] = 1
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="debugging-with-cli"><a class="header" href="#debugging-with-cli">Debugging with CLI</a></h1>
<p>The <code>forc debug</code> CLI enables debugging a live transaction on a running Fuel Client node.</p>
<h2 id="an-example-project"><a class="header" href="#an-example-project">An example project</a></h2>
<p>First, we need a project to debug, so create a new project using</p>
<pre><code class="language-bash">forc new --script dbg_example &amp;&amp; cd dbg_example
</code></pre>
<p>And then add some content to <code>src/main.sw</code>, for example:</p>
<pre><code class="language-sway">script;

use std::logging::log;

fn factorial(n: u64) -&gt; u64 {
    let mut result = 1;
    let mut counter = 0;
    while counter &lt; n {
        counter = counter + 1;
        result = result * counter;
    }
    return result;
}

fn main() {
    log::&lt;u64&gt;(factorial(5)); // 120
}
</code></pre>
<h2 id="building-and-bytecode-output"><a class="header" href="#building-and-bytecode-output">Building and bytecode output</a></h2>
<p>Now we are ready to build the project.</p>
<pre><code class="language-bash">forc build
</code></pre>
<p>After this the resulting binary should be located at <code>out/debug/dbg_example.bin</code>. Because we are interested in the resulting bytecode, we can read that with:</p>
<pre><code class="language-bash">forc parse-bytecode out/debug/dbg_example.bin
</code></pre>
<p>We can recognize the main loop by observing the control flow. Looking around halfword 58-60, we can see:</p>
<pre><code class="language-text">  half-word   byte    op                                                 raw
          58   232    MOVI { dst: 0x11, val: 5 }                         72 44 00 05                                 
          59   236    LT { dst: 0x10, lhs: 0x10, rhs: 0x11 }             16 41 04 40                                 
          60   240    JNZF { cond_nz: 0x10, dynamic: 0x0, fixed: 81 }    76 40 00 51
</code></pre>
<p>Here we can see our <code>factorial(5)</code> being set up with <code>MOVI</code> setting the value 5, followed by the <code>LT</code> comparison and conditional jump <code>JNZF</code>. The multiplication for our factorial happens at halfword 147 with <code>MUL { dst: 0x10, lhs: 0x10, rhs: 0x11 }</code>. Finally, we can spot our log statement at halfword 139 with the <code>LOGD</code> instruction.</p>
<h2 id="setting-up-the-debugging"><a class="header" href="#setting-up-the-debugging">Setting up the debugging</a></h2>
<p>We can start up the debug infrastructure. On a new terminal session run <code>fuel-core run --db-type in-memory --debug</code>; we need to have that running because it actually executes the program. Now we can fire up the debugger itself: <code>forc-debug</code>. Now if everything is set up correctly, you should see the debugger prompt (<code>&gt;&gt;</code>). You can use <code>help</code> command to list available commands.</p>
<p>The debugger supports tab completion to help you discover files in your current working directory (and its subdirectories):</p>
<ul>
<li>Type <code>tx</code> and press tab to recursively search for valid transaction JSON files</li>
<li>After selecting a transaction file, press tab again to search for ABI files</li>
<li>You can keep pressing tab to cycle through the found files</li>
<li>Of course, you can also manually type the full path to any transaction or ABI file, they don't have to be in your current directory</li>
</ul>
<p>Now we would like to inspect the program while it's running. To do this, we first need to send the script to the executor, i.e. <code>fuel-core</code>. To do so, we need a <em>transaction specification</em>, <code>tx.json</code>. It looks something like this:</p>
<pre><code class="language-json">{
  "Script": {
    "body": {
      "script_gas_limit": 1000000,
      "script": [
        26, 240, 48, 0, 116, 0, 0, 2, 0, 0, 0, 0, 0, 0, 3, 96, 93, 255, 192, 1, 16, 255, 255, 0, 26, 236, 80, 0, 145, 0, 0, 184, 80, 67, 176, 80, 32, 248, 51, 0, 88, 251, 224, 2, 80, 251, 224, 4, 116, 0, 0, 37, 80, 71, 176, 40, 26, 233, 16, 0, 32, 248, 51, 0, 88, 251, 224, 2, 80, 251, 224, 4, 116, 0, 0, 136, 26, 71, 208, 0, 114, 72, 0, 24, 40, 237, 20, 128, 80, 79, 176, 120, 114, 68, 0, 24, 40, 79, 180, 64, 80, 71, 176, 160, 114, 72, 0, 24, 40, 69, 52, 128, 80, 71, 176, 96, 114, 72, 0, 24, 40, 69, 52, 128, 80, 75, 176, 64, 26, 233, 16, 0, 26, 229, 32, 0, 32, 248, 51, 0, 88, 251, 224, 2, 80, 251, 224, 4, 116, 0, 0, 144, 26, 71, 208, 0, 80, 75, 176, 24, 114, 76, 0, 16, 40, 73, 20, 192, 80, 71, 176, 144, 114, 76, 0, 16, 40, 69, 36, 192, 114, 72, 0, 16, 40, 65, 20, 128, 93, 69, 0, 1, 93, 65, 0, 0, 37, 65, 16, 0, 149, 0, 0, 63, 150, 8, 0, 0, 26, 236, 80, 0, 145, 0, 1, 88, 26, 87, 224, 0, 95, 236, 16, 42, 95, 236, 0, 41, 93, 67, 176, 41, 114, 68, 0, 5, 22, 65, 4, 64, 118, 64, 0, 81, 93, 67, 176, 42, 80, 71, 176, 200, 26, 233, 16, 0, 32, 248, 51, 0, 88, 251, 224, 2, 80, 251, 224, 4, 116, 0, 0, 87, 26, 71, 208, 0, 114, 72, 0, 24, 40, 237, 20, 128, 80, 71, 176, 160, 114, 72, 0, 24, 40, 71, 180, 128, 80, 75, 176, 24, 114, 76, 0, 24, 40, 73, 20, 192, 80, 71, 176, 88, 114, 76, 0, 24, 40, 69, 36, 192, 93, 83, 176, 11, 93, 79, 176, 12, 93, 71, 176, 13, 114, 72, 0, 8, 16, 73, 20, 128, 21, 73, 36, 192, 118, 72, 0, 1, 116, 0, 0, 7, 114, 72, 0, 2, 27, 73, 52, 128, 114, 76, 0, 8, 16, 77, 36, 192, 38, 76, 0, 0, 40, 29, 68, 64, 26, 80, 112, 0, 16, 73, 68, 64, 95, 73, 0, 0, 114, 64, 0, 8, 16, 65, 20, 0, 80, 71, 176, 112, 95, 237, 64, 14, 95, 237, 48, 15, 95, 237, 0, 16, 80, 67, 176, 48, 114, 72, 0, 24, 40, 65, 20, 128, 80, 71, 176, 136, 114, 72, 0, 24, 40, 69, 4, 128, 80, 67, 177, 8, 114, 72, 0, 24, 40, 65, 20, 128, 80, 71, 177, 48, 114, 72, 0, 24, 40, 69, 4, 128, 80, 67, 177, 48, 80, 71, 176, 240, 114, 72, 0, 24, 40, 69, 4, 128, 80, 67, 176, 224, 26, 233, 16, 0, 26, 229, 0, 0, 32, 248, 51, 0, 88, 251, 224, 2, 80, 251, 224, 4, 116, 0, 0, 56, 26, 67, 208, 0, 80, 71, 176, 72, 114, 72, 0, 16, 40, 69, 4, 128, 80, 67, 177, 32, 114, 72, 0, 16, 40, 65, 20, 128, 80, 71, 176, 184, 114, 72, 0, 16, 40, 69, 4, 128, 93, 67, 240, 0, 93, 71, 176, 23, 93, 75, 176, 24, 52, 1, 4, 82, 26, 244, 0, 0, 116, 0, 0, 8, 93, 67, 176, 41, 16, 65, 0, 64, 95, 237, 0, 41, 93, 67, 176, 42, 93, 71, 176, 41, 27, 65, 4, 64, 95, 237, 0, 42, 117, 0, 0, 91, 146, 0, 1, 88, 26, 249, 80, 0, 152, 8, 0, 0, 151, 0, 0, 63, 74, 248, 0, 0, 149, 0, 0, 15, 150, 8, 0, 0, 26, 236, 80, 0, 145, 0, 0, 72, 26, 67, 160, 0, 26, 71, 224, 0, 114, 72, 4, 0, 38, 72, 0, 0, 26, 72, 112, 0, 80, 79, 176, 24, 95, 237, 32, 3, 114, 72, 4, 0, 95, 237, 32, 4, 95, 236, 0, 5, 114, 72, 0, 24, 40, 237, 52, 128, 80, 75, 176, 48, 114, 76, 0, 24, 40, 75, 180, 192, 114, 76, 0, 24, 40, 65, 36, 192, 26, 245, 0, 0, 146, 0, 0, 72, 26, 249, 16, 0, 152, 8, 0, 0, 151, 0, 0, 15, 74, 248, 0, 0, 149, 0, 0, 63, 150, 8, 0, 0, 26, 236, 80, 0, 145, 0, 0, 104, 26, 67, 160, 0, 26, 71, 144, 0, 26, 75, 224, 0, 80, 79, 176, 80, 114, 80, 0, 24, 40, 77, 5, 0, 114, 64, 0, 24, 40, 237, 52, 0, 80, 67, 176, 40, 114, 76, 0, 24, 40, 67, 180, 192, 93, 79, 176, 5, 80, 65, 0, 16, 80, 83, 176, 64, 95, 237, 48, 8, 80, 77, 64, 8, 114, 84, 0, 8, 40, 77, 5, 64, 80, 67, 176, 24, 114, 76, 0, 16, 40, 65, 68, 192, 114, 76, 0, 16, 40, 69, 4, 192, 26, 245, 16, 0, 146, 0, 0, 104, 26, 249, 32, 0, 152, 8, 0, 0, 151, 0, 0, 63, 74, 248, 0, 0, 71, 0, 0, 0, 21, 6, 230, 244, 76, 29, 98, 145
      ],
      "script_data": [],
      "receipts_root": "0000000000000000000000000000000000000000000000000000000000000000"
    },
    "policies": {
      "bits": "MaxFee",
      "values": [0, 0, 0, 0]
    },
    "inputs": [
      {
        "CoinSigned": {
          "utxo_id": {
            "tx_id": "c49d65de61cf04588a764b557d25cc6c6b4bc0d7429227e2a21e61c213b3a3e2",
            "output_index": 18
          },
          "owner": "f1e92c42b90934aa6372e30bc568a326f6e66a1a0288595e6e3fbd392a4f3e6e",
          "amount": 10599410012256088000,
          "asset_id": "2cafad611543e0265d89f1c2b60d9ebf5d56ad7e23d9827d6b522fd4d6e44bc3",
          "tx_pointer": {
            "block_height": 0,
            "tx_index": 0
          },
          "witness_index": 0,
          "maturity": 0,
          "predicate_gas_used": null,
          "predicate": null,
          "predicate_data": null
        }
      }
    ],
    "outputs": [],
    "witnesses": [
      {
        "data": [156, 254, 34, 102, 65, 96, 133, 170, 254, 105, 147, 35, 196, 199, 179, 133, 132, 240, 208, 149, 11, 46, 30, 96, 44, 91, 121, 195, 145, 184, 159, 235, 117, 82, 135, 41, 84, 154, 102, 61, 61, 16, 99, 123, 58, 173, 75, 226, 219, 139, 62, 33, 41, 176, 16, 18, 132, 178, 8, 125, 130, 169, 32, 108]
      }
    ]
  }
}
</code></pre>
<p>However, the key <code>script</code> should contain the actual bytecode to execute, i.e. the contents of <code>out/debug/dbg_example.bin</code> as a JSON array. The following command can be used to generate it:</p>
<pre><code class="language-bash">python3 -c 'print(list(open("out/debug/dbg_example.bin", "rb").read()))'
</code></pre>
<p>So now we replace the script array with the result, and save it as <code>tx.json</code>.</p>
<h2 id="using-the-debugger"><a class="header" href="#using-the-debugger">Using the debugger</a></h2>
<p>Now we can actually execute the script with an ABI to decode the log values:</p>
<pre><code class="language-text">&gt;&gt; start_tx tx.json out/debug/dbg_example-abi.json

Receipt: LogData { id: 0000000000000000000000000000000000000000000000000000000000000000, ra: 0, rb: 1515152261580153489, ptr: 67107840, len: 8, digest: d2b80ebb9ce633ad49a9ccfcc58ac7ad33a9ab4741529ae4247a3b07e8fa1c74, pc: 10924, is: 10368, data: Some(0000000000000078) }
Decoded log value: 120, from contract: 0000000000000000000000000000000000000000000000000000000000000000
Receipt: ReturnData { id: 0000000000000000000000000000000000000000000000000000000000000000, ptr: 67106816, len: 0, digest: e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855, pc: 10564, is: 10368, data: Some() }
Receipt: ScriptResult { result: Success, gas_used: 1273 }
Terminated
</code></pre>
<p>Looking at the output, we can see our <code>factorial(5)</code> result as the decoded log value of 120. The ABI has helped us decode the raw bytes <code>(0000000000000078)</code> into a meaningful value. It also tells us that the execution terminated without hitting any breakpoints. That's unsurprising, because we haven't set up any. We can do so with <code>breakpoint</code> command:</p>
<pre><code class="language-text">&gt;&gt; breakpoint 0

&gt;&gt; start_tx tx.json out/debug/dbg_example-abi.json

Receipt: ScriptResult { result: Success, gas_used: 0 }
Stopped on breakpoint at address 0 of contract 0x0000000000000000000000000000000000000000000000000000000000000000
</code></pre>
<p>Now we have stopped execution at the breakpoint on entry (address <code>0</code>). We can now inspect the initial state of the VM.</p>
<pre><code class="language-text">&gt;&gt; register ggas

reg[0x9] = 1000000  # ggas

&gt;&gt; memory 0x10 0x8

 000010: db f3 63 c9 1c 7f ec 95
</code></pre>
<p>However, that's not too interesting either, so let's just execute until the end, and then reset the VM to remove the breakpoints.</p>
<pre><code class="language-text">&gt;&gt; continue

Receipt: LogData { id: 0000000000000000000000000000000000000000000000000000000000000000, ra: 0, rb: 1515152261580153489, ptr: 67107840, len: 8, digest: d2b80ebb9ce633ad49a9ccfcc58ac7ad33a9ab4741529ae4247a3b07e8fa1c74, pc: 10924, is: 10368, data: Some(0000000000000078) }
Decoded log value: 120, from contract: 0000000000000000000000000000000000000000000000000000000000000000
Receipt: ReturnData { id: 0000000000000000000000000000000000000000000000000000000000000000, ptr: 67106816, len: 0, digest: e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855, pc: 10564, is: 10368, data: Some() }
Terminated

&gt;&gt; reset
</code></pre>
<p>Next, we will setup a breakpoint to check the state on each iteration of the <code>while</code> loop. For instance, if we'd like to see what numbers get multiplied together, we could set up a breakpoint before the operation. Looking at our bytecode we can see the main multiplication for our factorial happens at:</p>
<pre><code class="language-text">  half-word   byte   op                                        raw
        147   588    MUL { dst: 0x10, lhs: 0x10, rhs: 0x11 }   1b 41 04 40
</code></pre>
<p>We can set a breakpoint on its address, at halfword-offset <code>147</code>.</p>
<pre><code class="language-text">&gt;&gt;&gt; breakpoint 147

&gt;&gt; start_tx tx.json out/debug/dbg_example-abi.json

Receipt: ScriptResult { result: Success, gas_used: 82 }
Stopped on breakpoint at address 588 of contract 0x0000000000000000000000000000000000000000000000000000000000000000
</code></pre>
<p>Now we can inspect the inputs to multiply. Looking at <a href="https://github.com/FuelLabs/fuel-specs/blob/master/src/fuel-vm/instruction-set.md#mul-multiply">the specification</a> tells us that the instruction <code>MUL { dst: 0x10, lhs: 0x10, rhs: 0x11 }</code> means <code>reg[0x10] = reg[0x10] * reg[0x11]</code>. So inspecting the inputs:</p>
<pre><code class="language-text">&gt;&gt; r 0x10 0x11
reg[0x10] = 1        # reg16
reg[0x11] = 1        # reg17
</code></pre>
<p>So on the first round the numbers are 1 and 1, so we can continue to the next iteration with the <code>c</code> command:</p>
<pre><code class="language-text">&gt;&gt; c
Stopped on breakpoint at address 588 of contract 0x0000000000000000000000000000000000000000000000000000000000000000

&gt;&gt; r 0x10 0x11
reg[0x10] = 1        # reg16
reg[0x11] = 2        # reg17
</code></pre>
<p>And the next one:</p>
<pre><code class="language-text">&gt;&gt; c
Stopped on breakpoint at address 588 of contract 0x0000000000000000000000000000000000000000000000000000000000000000

&gt;&gt; r 0x10 0x11
reg[0x10] = 2        # reg16
reg[0x11] = 3        # reg17
</code></pre>
<p>And fourth one:</p>
<pre><code class="language-text">&gt;&gt; c
Stopped on breakpoint at address 588 of contract 0x0000000000000000000000000000000000000000000000000000000000000000

&gt;&gt; r 0x10 0x11
reg[0x10] = 6        # reg16
reg[0x11] = 4        # reg17
</code></pre>
<p>And round 5:</p>
<pre><code class="language-text">&gt;&gt; c
Stopped on breakpoint at address 588 of contract 0x0000000000000000000000000000000000000000000000000000000000000000

&gt;&gt; r 0x10 0x11
reg[0x10] = 24       # reg16
reg[0x11] = 5        # reg17
</code></pre>
<p>At this point we can look at the values</p>
<div class="table-wrapper"><table><thead><tr><th>0x10</th><th>0x11</th></tr></thead><tbody>
<tr><td>1</td><td>1</td></tr>
<tr><td>1</td><td>2</td></tr>
<tr><td>2</td><td>3</td></tr>
<tr><td>6</td><td>4</td></tr>
<tr><td>24</td><td>5</td></tr>
</tbody></table>
</div>
<p>From this we can clearly see that the left side, register <code>0x10</code> is the <code>result</code> variable which accumulates the factorial calculation (1, 1, 2, 6, 24), and register <code>0x11</code> is the <code>counter</code> which increments from 1 to 5. Now the counter equals the given factorial function argument <code>5</code>, and the loop terminates. So when we continue, the program finishes without encountering any more breakpoints:</p>
<pre><code class="language-text">&gt;&gt; c

Receipt: LogData { id: 0000000000000000000000000000000000000000000000000000000000000000, ra: 0, rb: 1515152261580153489, ptr: 67107840, len: 8, digest: d2b80ebb9ce633ad49a9ccfcc58ac7ad33a9ab4741529ae4247a3b07e8fa1c74, pc: 10924, is: 10368, data: Some(0000000000000078) }
Decoded log value: 120, from contract: 0000000000000000000000000000000000000000000000000000000000000000
Receipt: ReturnData { id: 0000000000000000000000000000000000000000000000000000000000000000, ptr: 67106816, len: 0, digest: e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855, pc: 10564, is: 10368, data: Some() }
Terminated
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="debugging-with-ide"><a class="header" href="#debugging-with-ide">Debugging with IDE</a></h1>
<p>The <code>forc debug</code> plugin also enables line-by-line debugging of Sway unit tests in VSCode.</p>
<h2 id="installation"><a class="header" href="#installation">Installation</a></h2>
<ol>
<li>Install the Sway VSCode extension from the <a href="https://marketplace.visualstudio.com/items?itemName=FuelLabs.sway-vscode-plugin">marketplace</a>.</li>
<li>Ensure you have the forc-debug binary installed. <code>which forc-debug</code>.
It can be installed with <code>fuelup component add forc-debug</code>.</li>
<li>Create a <code>.vscode/launch.json</code> file with the following contents:</li>
</ol>
<pre><code class="language-json">{
    "version": "0.2.0",
    "configurations": [
        {
        "type": "sway",
        "request": "launch",
        "name": "Debug Sway",
        "program": "${file}"
    }]
}
</code></pre>
<h2 id="an-example-project-1"><a class="header" href="#an-example-project-1">An example project</a></h2>
<p>Given this example contract:</p>
<pre><code class="language-sway">contract;

abi CallerContract {
    fn test_false() -&gt; bool;
}

impl CallerContract for Contract {
    fn test_false() -&gt; bool {
        false
    }
}

abi CalleeContract {
    fn test_true() -&gt; bool;
}

#[test]
fn test_multi_contract_calls() {
    let caller = abi(CallerContract, CONTRACT_ID);
    let callee = abi(CalleeContract, callee::CONTRACT_ID);

    let should_be_false = caller.test_false();
    let should_be_true = callee.test_true();
    assert(!should_be_false);
    assert(should_be_true);
}
</code></pre>
<p>Within the sway file open in VSCode, you can set breakpoints on lines within the test or functions that it calls, and click Run -&gt; Start Debugging to begin debugging the unit test.</p>
<p>This will build the sway project and run it in debug mode. The debugger will stop the VM execution when a breakpoint is hit.</p>
<p>The debug panel will show VM registers under the Variables tab, as well as the current VM opcode where execution is suspended. You can continue execution, or use the Step Over function to step forward, instruction by instruction.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="debugging-with-forc-call"><a class="header" href="#debugging-with-forc-call">Debugging with Forc Call</a></h1>
<p>The <code>forc call</code> command includes interactive debugging capabilities through the <code>--debug</code> flag, enabling developers to debug contract function calls step-by-step after transaction execution.</p>
<h2 id="overview"><a class="header" href="#overview">Overview</a></h2>
<p>When you add the <code>--debug</code> flag to any <code>forc call</code> command, it will:</p>
<ol>
<li>Execute the contract function call as normal</li>
<li>Automatically launch an interactive debugging session</li>
<li>Allow you to step through the execution, inspect values, and set breakpoints</li>
<li>Provide full access to the <code>forc-debug</code> interface</li>
</ol>
<p>This integration seamlessly combines contract interaction with debugging, making it easy to understand what happens during contract execution.</p>
<h2 id="basic-usage"><a class="header" href="#basic-usage">Basic Usage</a></h2>
<p>Simply add the <code>--debug</code> flag to any existing <code>forc call</code> command:</p>
<pre><code class="language-bash">forc call &lt;CONTRACT_ID&gt; \
    --abi &lt;ABI_PATH&gt; \
    &lt;FUNCTION_NAME&gt; [ARGS...] \
    --debug
</code></pre>
<h2 id="example-debugging-a-contract-call"><a class="header" href="#example-debugging-a-contract-call">Example: Debugging a Contract Call</a></h2>
<p>Let's say you have a contract with a function that performs some calculations:</p>
<pre><code class="language-sway">contract;

abi Calculator {
    fn factorial(n: u64) -&gt; u64;
}

impl Calculator for Contract {
    fn factorial(n: u64) -&gt; u64 {
        let mut result = 1;
        let mut counter = 0;
        while counter &lt; n {
            counter = counter + 1;
            result = result * counter;
        }
        result
    }
}
</code></pre>
<h3 id="debugging-the-factorial-function"><a class="header" href="#debugging-the-factorial-function">Debugging the Factorial Function</a></h3>
<pre><code class="language-bash">forc call 0x1234567890abcdef1234567890abcdef12345678 \
    --abi ./out/debug/calculator-abi.json \
    factorial 5 \
    --debug
</code></pre>
<p>This command will:</p>
<ol>
<li>Execute <code>factorial(5)</code> on the deployed contract</li>
<li>Show the transaction result (return value: 120)</li>
<li>Launch the interactive debugger with the transaction data pre-loaded</li>
</ol>
<h3 id="interactive-debugging-session"><a class="header" href="#interactive-debugging-session">Interactive Debugging Session</a></h3>
<p>Once the debugger launches, you'll see the pre-buffered debugger prompt to start the transaction:</p>
<pre><code class="language-text">Welcome to the Sway Debugger! Type "help" for a list of commands.
&gt;&gt; start_tx /var/folders/xz/5djvk4596k5c1fj2prcd0d880000gn/T/.tmpexrnFE.json /var/folders/xz/5djvk4596k5c1fj2prcd0d880000gn/T/.tmpuaPRtF.json
</code></pre>
<p>You can now use all the <a href="debugging/./debugging_with_cli.html#using-the-debugger">standard debugging commands</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sway-lsp"><a class="header" href="#sway-lsp">Sway LSP</a></h1>
<p>Welcome to the documentation for Sway LSP, the language server designed specifically for the Sway programming language. This documentation serves as a comprehensive guide to help you understand and utilize the powerful features provided by Sway LSP.</p>
<p>Sway LSP is built on the <a href="https://microsoft.github.io/language-server-protocol/">Language Server Protocol</a> (LSP), a standardized protocol for enabling rich programming language support in editor and IDE environments. It acts as a bridge between your favorite code editor or integrated development environment and the Sway programming language, offering advanced semantic analysis and a wide range of features to enhance your development experience.</p>
<p>With Sway LSP, you can expect a seamless and efficient coding experience while working with the Sway programming language. It provides intelligent code completion, precise symbol navigation, type information, and other smart features that empower you to write clean and error-free code. By leveraging the power of Sway LSP, you can increase productivity, reduce debugging time, and write high-quality code with confidence.</p>
<p>In this documentation, you will find detailed information about how to set up Sway LSP in your preferred code editor or IDE, configure its settings to match your coding style, and take advantage of its various features. We will guide you through the installation process, provide examples of typical configuration setups, and walk you through the usage of each feature supported by Sway LSP.</p>
<p>Whether you are a beginner or an experienced Sway developer, this documentation aims to be your go-to resource for understanding and maximizing the capabilities of Sway LSP. So let's dive in and unlock the full potential of the Sway programming language with Sway LSP!</p>
<ul>
<li><a href="lsp/./installation.html">Installation</a></li>
<li><a href="lsp/./features.html">Features</a></li>
<li><a href="lsp/./troubleshooting.html">Troubleshooting</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="installation-1"><a class="header" href="#installation-1">Installation</a></h1>
<p>The Sway language server is contained in the <a href="lsp/../forc/plugins/forc_lsp.html"><code>forc-lsp</code></a> binary, which is installed as part of the <a href="lsp/../introduction/fuel_toolchain.html">Fuel toolchain</a>. Once installed, it can be used with a variety of IDEs. It must be installed for any of the IDE plugins to work.</p>
<blockquote>
<p><strong>Note</strong>: There is no need to manually run <code>forc-lsp</code> (the plugin will automatically start it), however both <code>forc</code> and <code>forc-lsp</code> must be in your <code>$PATH</code>. To check if <code>forc</code> is in your <code>$PATH</code>, type <code>forc --help</code> in your terminal.</p>
</blockquote>
<h2 id="vscode"><a class="header" href="#vscode">VSCode</a></h2>
<p>This is the best supported editor at the moment.</p>
<p>You can install the latest release of the plugin from the <a href="https://marketplace.visualstudio.com/items?itemName=FuelLabs.sway-vscode-plugin">marketplace</a>.</p>
<p>Note that we only support the most recent version of VS Code.</p>
<h2 id="code-oss-vscode-on-linux"><a class="header" href="#code-oss-vscode-on-linux">Code OSS (VSCode on Linux)</a></h2>
<ol>
<li>Install <a href="https://aur.archlinux.org/packages/code-marketplace">code-marketplace</a> to get access to all of the extensions in the VSCode marketplace.</li>
<li>Install the <a href="https://marketplace.visualstudio.com/items?itemName=FuelLabs.sway-vscode-plugin">Sway</a> extension.</li>
</ol>
<h2 id="vim--neovim"><a class="header" href="#vim--neovim">vim / neovim</a></h2>
<p>Follow the documentation for <a href="https://github.com/FuelLabs/sway.vim">sway.vim</a> to install.</p>
<h2 id="helix"><a class="header" href="#helix">helix</a></h2>
<p><a href="https://docs.helix-editor.com/install.html">Install helix</a> and Sway LSP will work out of the box.</p>
<p>Sway support is built into helix using <a href="https://github.com/FuelLabs/tree-sitter-sway">tree-sitter-sway</a>.</p>
<h2 id="emacs"><a class="header" href="#emacs">Emacs</a></h2>
<p>Coming soon! Feel free to <a href="https://github.com/FuelLabs/sway/issues/3527">contribute</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="features"><a class="header" href="#features">Features</a></h1>
<h2 id="code-actions"><a class="header" href="#code-actions">Code Actions</a></h2>
<p><em>Source:</em> <a href="https://github.com/FuelLabs/sway/tree/master/sway-lsp/src/capabilities/code_actions">code_actions</a></p>
<p>Quickly generate boilerplate code and code comments for functions, structs, and ABIs.</p>
<h2 id="completion"><a class="header" href="#completion">Completion</a></h2>
<p><em>Source:</em> <a href="https://github.com/FuelLabs/sway/blob/master/sway-lsp/src/capabilities/completion.rs">completion.rs</a></p>
<p>Suggests code to follow partially written statements for functions and variables.</p>
<h2 id="go-to-definition"><a class="header" href="#go-to-definition">Go to Definition</a></h2>
<p>Jumps to the definition of a symbol from its usage.</p>
<h2 id="find-all-references"><a class="header" href="#find-all-references">Find All References</a></h2>
<p>Locates all occurrences of a symbol throughout the project.</p>
<h2 id="hover"><a class="header" href="#hover">Hover</a></h2>
<p><em>Source:</em> <a href="https://github.com/FuelLabs/sway/tree/master/sway-lsp/src/capabilities/hover">hover</a></p>
<p>Provides documentation, compiler diagnostics, and reference links when hovering over functions and variables.</p>
<h2 id="inlay-hints"><a class="header" href="#inlay-hints">Inlay Hints</a></h2>
<p><em>Source:</em> <a href="https://github.com/FuelLabs/sway/blob/master/sway-lsp/src/capabilities/inlay_hints.rs">inlay_hints.rs</a></p>
<p>Displays the implied type of a variable next to the variable name. Configurable in Settings.</p>
<h2 id="rename"><a class="header" href="#rename">Rename</a></h2>
<p><em>Source:</em> <a href="https://github.com/FuelLabs/sway/blob/master/sway-lsp/src/capabilities/rename.rs">rename.rs</a></p>
<p>Renames a symbol everywhere in the workspace.</p>
<h2 id="diagnostics"><a class="header" href="#diagnostics">Diagnostics</a></h2>
<p><em>Source:</em> <a href="https://github.com/FuelLabs/sway/blob/master/sway-lsp/src/capabilities/diagnostic.rs">diagnostic.rs</a></p>
<p>Displays compiler warnings and errors inline.</p>
<h2 id="syntax-highlighting"><a class="header" href="#syntax-highlighting">Syntax Highlighting</a></h2>
<p><em>Source:</em> <a href="https://github.com/FuelLabs/sway/blob/master/sway-lsp/src/capabilities/highlight.rs">highlight.rs</a></p>
<p>Highlights code based on type and context.</p>
<h2 id="run"><a class="header" href="#run">Run</a></h2>
<p><em>Source:</em> <a href="https://github.com/FuelLabs/sway/blob/master/sway-lsp/src/capabilities/runnable.rs">runnable.rs</a></p>
<p>Shows a button above a runnable function or test.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="troubleshooting-1"><a class="header" href="#troubleshooting-1">Troubleshooting</a></h1>
<p>First, confirm you are running the most recent version:</p>
<pre><code class="language-sh">fuelup toolchain install latest
fuelup update
forc-lsp --version
</code></pre>
<p>Second, confirm that your <code>$PATH</code> resolves to the <code>forc-lsp</code> binary in <code>$HOME/.fuelup/bin</code>.</p>
<pre><code class="language-sh">which forc-lsp
</code></pre>
<h2 id="slow-performance"><a class="header" href="#slow-performance">Slow Performance</a></h2>
<p>If you are experiencing slow performance, you can try the following:</p>
<p>Follow <a href="lsp/troubleshooting.html#troubleshooting">the steps above</a> to ensure you are running the most recent version.</p>
<p>Then, make sure you only have the most recent version of the LSP server running.</p>
<pre><code class="language-sh">pkill forc-lsp
</code></pre>
<h3 id="large-projects"><a class="header" href="#large-projects">Large projects</a></h3>
<p>Sway projects with ten or more Sway files are likely to have slower LSP performance. We are working on better support for large projects.</p>
<p>In the meantime, if it's too slow, you can disable the LSP server entirely with the <code>sway-lsp.diagnostic.disableLsp</code> setting. The extension will still provide basic syntax highlighting, command palettes, as well as the Sway debugger, but all other language features will be disabled.</p>
<h2 id="server-logs"><a class="header" href="#server-logs">Server Logs</a></h2>
<p>You can enable verbose logging of the LSP server.</p>
<p>In VSCode, this is under the setting:</p>
<pre><code class="language-json">"sway-lsp.trace.server": "verbose"
</code></pre>
<p>Once enabled, you can find this in the output window under Sway Language Server.</p>
<p>For other editors, see <a href="lsp/./installation.html">Installation</a> for links to documentation.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sway-reference"><a class="header" href="#sway-reference">Sway Reference</a></h1>
<ul>
<li><a href="reference/./compiler_intrinsics.html">Compiler Intrinsics</a></li>
<li><a href="reference/./attributes.html">Attributes</a></li>
<li><a href="reference/./style_guide.html">Style Guide</a></li>
<li><a href="reference/./known_issues_and_workarounds.html">Known Issues and Workarounds</a></li>
<li><a href="reference/./rust_differences.html">Differences from Rust</a></li>
<li><a href="reference/./solidity_differences.html">Differences from Solidity</a></li>
<li><a href="reference/./contributing_to_sway.html">Contributing to Sway</a></li>
<li><a href="reference/./keywords.html">Keywords</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sway-libraries"><a class="header" href="#sway-libraries">Sway Libraries</a></h1>
<p>The purpose of Sway Libraries is to contain libraries which users can import and use that are not part of the standard library.</p>
<p>These libraries contain helper functions and other tools valuable to blockchain development.</p>
<p>For more information on how to use a Sway-Libs library, please refer to the <a href="https://fuellabs.github.io/sway-libs/book/getting_started/index.html">Sway-Libs Book</a>.</p>
<h2 id="assets-libraries"><a class="header" href="#assets-libraries">Assets Libraries</a></h2>
<p>Asset Libraries are any libraries that use <a href="reference/../blockchain-development/native_assets.html">Native Assets</a> on the Fuel Network.</p>
<ul>
<li><a href="https://fuellabs.github.io/sway-libs/book/asset/index.html">Asset Library</a>; provides helper functions for the <a href="https://github.com/FuelLabs/sway-standards/blob/master/docs/src/src-20-native-asset.md">SRC-20</a>, <a href="https://github.com/FuelLabs/sway-standards/blob/master/docs/src/src-3-minting-and-burning.md">SRC-3</a>, and <a href="https://github.com/FuelLabs/sway-standards/blob/master/docs/src/src-7-asset-metadata.md">SRC-7</a> standards.</li>
</ul>
<h2 id="access-control-and-security-libraries"><a class="header" href="#access-control-and-security-libraries">Access Control and Security Libraries</a></h2>
<p>Access Control and Security Libraries are any libraries that are built and intended to provide additional safety when developing smart contracts.</p>
<ul>
<li><a href="https://fuellabs.github.io/sway-libs/book/ownership/index.html">Ownership Library</a>; used to apply restrictions on functions such that only a <strong>single</strong> user may call them. This library provides helper functions for the <a href="https://github.com/FuelLabs/sway-standards/blob/master/docs/src/src-5-ownership.md">SRC-5; Ownership Standard</a>.</li>
<li><a href="https://fuellabs.github.io/sway-libs/book/admin/index.html">Admin Library</a>; used to apply restrictions on functions such that only a select few users may call them like a whitelist.</li>
<li><a href="https://fuellabs.github.io/sway-libs/book/pausable/index.html">Pausable Library</a>; allows contracts to implement an emergency stop mechanism.</li>
<li><a href="https://fuellabs.github.io/sway-libs/book/reentrancy/index.html">Reentrancy Guard Library</a>; used to detect and prevent reentrancy attacks.</li>
</ul>
<h2 id="cryptography-libraries"><a class="header" href="#cryptography-libraries">Cryptography Libraries</a></h2>
<p>Cryptography Libraries are any libraries that provided cryptographic functionality beyond what the std-lib provides.</p>
<ul>
<li><a href="https://fuellabs.github.io/sway-libs/book/bytecode/index.html">Bytecode Library</a>; used for on-chain verification and computation of bytecode roots for contracts and predicates.</li>
<li><a href="https://fuellabs.github.io/sway-libs/book/merkle/index.html">Merkle Proof Library</a>; used to verify Binary Merkle Trees computed off-chain.</li>
</ul>
<h2 id="math-libraries"><a class="header" href="#math-libraries">Math Libraries</a></h2>
<p>Math Libraries are libraries which provide mathematic functions or number types that are outside of the std-lib's scope.</p>
<ul>
<li><a href="https://fuellabs.github.io/sway-libs/book/signed_integers/index.html">Signed Integers Library</a>; an interface to implement signed integers.</li>
</ul>
<h2 id="data-structures-libraries"><a class="header" href="#data-structures-libraries">Data Structures Libraries</a></h2>
<p>Data Structure Libraries are libraries which provide complex data structures which unlock additional functionality for Smart Contracts.</p>
<ul>
<li><a href="https://fuellabs.github.io/sway-libs/book/queue/index.html">Queue Library</a>; a linear data structure that provides First-In-First-Out (FIFO) operations.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="compiler-intrinsics"><a class="header" href="#compiler-intrinsics">Compiler Intrinsics</a></h1>
<p>The Sway compiler supports a list of intrinsics that perform various low level operations that are useful for building libraries. Compiler intrinsics should rarely be used but are preferred over <code>asm</code> blocks because they are type-checked and are safer overall. Below is a list of all available compiler intrinsics:</p>
<hr />
<pre><code class="language-sway">__size_of_val&lt;T&gt;(val: T) -&gt; u64
</code></pre>
<p><strong>Description:</strong> Return the size of type <code>T</code> in bytes.</p>
<p><strong>Constraints:</strong> None.</p>
<hr />
<pre><code class="language-sway">__size_of&lt;T&gt;() -&gt; u64
</code></pre>
<p><strong>Description:</strong> Return the size of type <code>T</code> in bytes.</p>
<p><strong>Constraints:</strong> None.</p>
<hr />
<pre><code class="language-sway">__size_of_str_array&lt;T&gt;() -&gt; u64
</code></pre>
<p><strong>Description:</strong> Return the size of type <code>T</code> in bytes. This intrinsic differs from <code>__size_of</code> in the case of "string arrays" where the actual length in bytes of the string is returned without padding the byte size to the next word alignment. When <code>T</code> is not a "string array" <code>0</code> is returned.</p>
<p><strong>Constraints:</strong> None.</p>
<hr />
<pre><code class="language-sway">__assert_is_str_array&lt;T&gt;()
</code></pre>
<p><strong>Description:</strong> Throws a compile error if type <code>T</code> is not a "string array".</p>
<p><strong>Constraints:</strong> None.</p>
<hr />
<pre><code class="language-sway">__to_str_array(s: str) -&gt; str[N]
</code></pre>
<p><strong>Description:</strong> Converts a "string slice" to "string array" at compile time. Parameter "s" must be a string literal.</p>
<p><strong>Constraints:</strong> None.</p>
<hr />
<pre><code class="language-sway">__is_reference_type&lt;T&gt;() -&gt; bool
</code></pre>
<p><strong>Description:</strong> Returns <code>true</code> if <code>T</code> is a <em>reference type</em> and <code>false</code> otherwise.</p>
<p><strong>Constraints:</strong> None.</p>
<hr />
<pre><code class="language-sway">__is_str_array&lt;T&gt;() -&gt; bool
</code></pre>
<p><strong>Description:</strong> Returns <code>true</code> if <code>T</code> is a string array and <code>false</code> otherwise.</p>
<p><strong>Constraints:</strong> None.</p>
<hr />
<pre><code class="language-sway">__eq&lt;T&gt;(lhs: T, rhs: T) -&gt; bool
</code></pre>
<p><strong>Description:</strong> Returns whether <code>lhs</code> and <code>rhs</code> are equal.</p>
<p><strong>Constraints:</strong> <code>T</code> is <code>bool</code>, <code>u8</code>, <code>u16</code>, <code>u32</code>, <code>u64</code>, <code>u256</code>, <code>b256</code> or <code>raw_ptr</code>.</p>
<hr />
<pre><code class="language-sway">__gt&lt;T&gt;(lhs: T, rhs: T) -&gt; bool
</code></pre>
<p><strong>Description:</strong> Returns whether <code>lhs</code> is greater than <code>rhs</code>.</p>
<p><strong>Constraints:</strong> <code>T</code> is <code>u8</code>, <code>u16</code>, <code>u32</code>, <code>u64</code>, <code>u256</code>, <code>b256</code>.</p>
<hr />
<pre><code class="language-sway">__lt&lt;T&gt;(lhs: T, rhs: T) -&gt; bool
</code></pre>
<p><strong>Description:</strong> Returns whether <code>lhs</code> is less than <code>rhs</code>.</p>
<p><strong>Constraints:</strong> <code>T</code> is <code>u8</code>, <code>u16</code>, <code>u32</code>, <code>u64</code>, <code>u256</code>, <code>b256</code>.</p>
<hr />
<pre><code class="language-sway">__gtf&lt;T&gt;(index: u64, tx_field_id: u64) -&gt; T
</code></pre>
<p><strong>Description:</strong> Returns transaction field with ID <code>tx_field_id</code> at index <code>index</code>, if applicable. This is a wrapper around FuelVM's <a href="https://fuellabs.github.io/fuel-specs/master/vm/instruction_set#gtf-get-transaction-fields"><code>gtf</code> instruction</a>. The resulting field is cast to <code>T</code>.</p>
<p><strong>Constraints:</strong> None.</p>
<hr />
<pre><code class="language-sway">__addr_of&lt;T&gt;(val: T) -&gt; raw_ptr
</code></pre>
<p><strong>Description:</strong> Returns the address in memory where <code>val</code> is stored.</p>
<p><strong>Constraints:</strong> None.</p>
<hr />
<pre><code class="language-sway">__state_load_word(key: b256) -&gt; u64
</code></pre>
<p><strong>Description:</strong> Reads and returns a single word from storage at key <code>key</code>.</p>
<p><strong>Constraints:</strong> None.</p>
<hr />
<pre><code class="language-sway">__state_load_quad(key: b256, ptr: raw_ptr, slots: u64) -&gt; bool
</code></pre>
<p><strong>Description:</strong> Reads <code>slots</code> number of slots (<code>b256</code> each) from storage starting at key <code>key</code> and stores them in memory starting at address <code>ptr</code>. Returns a Boolean describing whether all the storage slots were previously set.</p>
<p><strong>Constraints:</strong> None.</p>
<hr />
<pre><code class="language-sway">__state_store_word(key: b256, val: u64) -&gt; bool
</code></pre>
<p><strong>Description:</strong> Stores a single word <code>val</code> into storage at key <code>key</code>. Returns a Boolean describing whether the store slot was previously set.</p>
<p><strong>Constraints:</strong> None.</p>
<hr />
<pre><code class="language-sway">__state_store_quad(key: b256, ptr: raw_ptr, slots: u64) -&gt; bool
</code></pre>
<p><strong>Description:</strong> Stores <code>slots</code> number of slots (<code>b256</code> each) starting at address <code>ptr</code> in memory into storage starting at key <code>key</code>. Returns a Boolean describing whether the first storage slot was previously set.</p>
<p><strong>Constraints:</strong> None.</p>
<hr />
<pre><code class="language-sway">__log&lt;T&gt;(val: T) where T: AbiEncode
</code></pre>
<p><strong>Description:</strong> Logs value <code>val</code>.</p>
<p><strong>Constraints:</strong></p>
<ul>
<li><code>T</code> must implement AbiEncode</li>
</ul>
<hr />
<pre><code class="language-sway">__add&lt;T&gt;(lhs: T, rhs: T) -&gt; T
</code></pre>
<p><strong>Description:</strong> Adds <code>lhs</code> and <code>rhs</code> and returns the result.</p>
<p><strong>Constraints:</strong> <code>T</code> is an integer type, i.e. <code>u8</code>, <code>u16</code>, <code>u32</code>, <code>u64</code>, <code>u256</code>.</p>
<hr />
<pre><code class="language-sway">__sub&lt;T&gt;(lhs: T, rhs: T) -&gt; T
</code></pre>
<p><strong>Description:</strong> Subtracts <code>rhs</code> from <code>lhs</code>.</p>
<p><strong>Constraints:</strong> <code>T</code> is an integer type, i.e. <code>u8</code>, <code>u16</code>, <code>u32</code>, <code>u64</code>, <code>u256</code>.</p>
<hr />
<pre><code class="language-sway">__mul&lt;T&gt;(lhs: T, rhs: T) -&gt; T
</code></pre>
<p><strong>Description:</strong> Multiplies <code>lhs</code> by <code>rhs</code>.</p>
<p><strong>Constraints:</strong> <code>T</code> is an integer type, i.e. <code>u8</code>, <code>u16</code>, <code>u32</code>, <code>u64</code>, <code>u256</code>.</p>
<hr />
<pre><code class="language-sway">__div&lt;T&gt;(lhs: T, rhs: T) -&gt; T
</code></pre>
<p><strong>Description:</strong> Divides <code>lhs</code> by <code>rhs</code>.</p>
<p><strong>Constraints:</strong> <code>T</code> is an integer type, i.e. <code>u8</code>, <code>u16</code>, <code>u32</code>, <code>u64</code>, <code>u256</code>.</p>
<hr />
<pre><code class="language-sway">__and&lt;T&gt;(lhs: T, rhs: T) -&gt; T
</code></pre>
<p><strong>Description:</strong> Bitwise AND <code>lhs</code> and <code>rhs</code>.</p>
<p><strong>Constraints:</strong> <code>T</code> is an integer type, i.e. <code>u8</code>, <code>u16</code>, <code>u32</code>, <code>u64</code>, <code>u256</code>, <code>b256</code>.</p>
<hr />
<pre><code class="language-sway">__or&lt;T&gt;(lhs: T, rhs: T) -&gt; T
</code></pre>
<p><strong>Description:</strong> Bitwise OR <code>lhs</code> and <code>rhs</code>.</p>
<p><strong>Constraints:</strong> <code>T</code> is an integer type, i.e. <code>u8</code>, <code>u16</code>, <code>u32</code>, <code>u64</code>, <code>u256</code>, <code>b256</code>.</p>
<hr />
<pre><code class="language-sway">__xor&lt;T&gt;(lhs: T, rhs: T) -&gt; T
</code></pre>
<p><strong>Description:</strong> Bitwise XOR <code>lhs</code> and <code>rhs</code>.</p>
<p><strong>Constraints:</strong> <code>T</code> is an integer type, i.e. <code>u8</code>, <code>u16</code>, <code>u32</code>, <code>u64</code>, <code>u256</code>, <code>b256</code>.</p>
<hr />
<pre><code class="language-sway">__mod&lt;T&gt;(lhs: T, rhs: T) -&gt; T
</code></pre>
<p><strong>Description:</strong> Modulo of <code>lhs</code> by <code>rhs</code>.</p>
<p><strong>Constraints:</strong> <code>T</code> is an integer type, i.e. <code>u8</code>, <code>u16</code>, <code>u32</code>, <code>u64</code>, <code>u256</code>.</p>
<hr />
<pre><code class="language-sway">__rsh&lt;T&gt;(lhs: T, rhs: u64) -&gt; T
</code></pre>
<p><strong>Description:</strong> Logical right shift of <code>lhs</code> by <code>rhs</code>.</p>
<p><strong>Constraints:</strong> <code>T</code> is an integer type, i.e. <code>u8</code>, <code>u16</code>, <code>u32</code>, <code>u64</code>, <code>u256</code>, <code>b256</code>.</p>
<hr />
<pre><code class="language-sway">__lsh&lt;T&gt;(lhs: T, rhs: u64) -&gt; T
</code></pre>
<p><strong>Description:</strong> Logical left shift of <code>lhs</code> by <code>rhs</code>.</p>
<p><strong>Constraints:</strong> <code>T</code> is an integer type, i.e. <code>u8</code>, <code>u16</code>, <code>u32</code>, <code>u64</code>, <code>u256</code>, <code>b256</code>.</p>
<hr />
<pre><code class="language-sway">__revert(code: u64)
</code></pre>
<p><strong>Description:</strong> Reverts with error code <code>code</code>.</p>
<p><strong>Constraints:</strong> None.</p>
<hr />
<pre><code class="language-sway">__ptr_add(ptr: raw_ptr, offset: u64)
</code></pre>
<p><strong>Description:</strong> Adds <code>offset</code> to the raw value of pointer <code>ptr</code>.</p>
<p><strong>Constraints:</strong> None.</p>
<hr />
<pre><code class="language-sway">__ptr_sub(ptr: raw_ptr, offset: u64)
</code></pre>
<p><strong>Description:</strong> Subtracts <code>offset</code> to the raw value of pointer <code>ptr</code>.</p>
<p><strong>Constraints:</strong> None.</p>
<hr />
<pre><code class="language-sway">__smo&lt;T&gt;(recipient: b256, data: T, coins: u64)
</code></pre>
<p><strong>Description:</strong> Sends a message <code>data</code> of arbitrary type <code>T</code> and <code>coins</code> amount of the base asset to address <code>recipient</code>.</p>
<p><strong>Constraints:</strong> None.</p>
<hr />
<pre><code class="language-sway">__not(op: T) -&gt; T
</code></pre>
<p><strong>Description:</strong> Bitwise NOT of <code>op</code></p>
<p><strong>Constraints:</strong> <code>T</code> is an integer type, i.e. <code>u8</code>, <code>u16</code>, <code>u32</code>, <code>u64</code>, <code>u256</code>, <code>b256</code>.</p>
<hr />
<pre><code class="language-sway">__jmp_mem()
</code></pre>
<p><strong>Description:</strong> Jumps to <code>MEM[$hp]</code>.</p>
<p><strong>Constraints:</strong> None.</p>
<hr />
<pre><code class="language-sway">__slice&lt;T&gt;(item: &amp;[T; N], start: u64, end: u64) -&gt; &amp;[T]
__slice&lt;T&gt;(item: &amp;[T], start: u64, end: u64) -&gt; &amp;[T]
__slice&lt;T&gt;(item: &amp;mut [T; N], start: u64, end: u64) -&gt; &amp;mut [T]
__slice&lt;T&gt;(item: &amp;mut [T], start: u64, end: u64) -&gt; &amp;mut [T]
</code></pre>
<p><strong>Description:</strong> Slices an array or another slice.</p>
<p>This intrinsic returns a reference to a slice containing the range of elements inside <code>item</code>.
The mutability of reference is defined by the first parameter mutability.</p>
<p>Runtime bound checks are not generated, and must be done manually when and where appropriated. Compile time bound checks are done when possible.</p>
<p><strong>Constraints:</strong></p>
<ul>
<li><code>item</code> is an array or a slice;</li>
<li>when <code>start</code> is a literal, it must be smaller than <code>item</code> length;</li>
<li>when <code>end</code> is a literal, it must be smaller than or equal to <code>item</code> length;</li>
<li><code>end</code> must be greater than or equal to <code>start</code></li>
</ul>
<hr />
<pre><code class="language-sway">__elem_at&lt;T&gt;(item: &amp;[T; N], index: u64) -&gt; &amp;T
__elem_at&lt;T&gt;(item: &amp;[T], index: u64) -&gt; &amp;T
__elem_at&lt;T&gt;(item: &amp;mut [T; N], index: u64) -&gt; &amp;mut T
__elem_at&lt;T&gt;(item: &amp;mut [T], index: u64) -&gt; &amp;mut T
</code></pre>
<p><strong>Description:</strong> Returns a reference to the indexed element. The mutability of reference is defined by the first parameter mutability.</p>
<p>Runtime bound checks are not generated, and must be done manually when and where appropriated. Compile time bound checks are done when possible.</p>
<p><strong>Constraints:</strong></p>
<ul>
<li><code>item</code> is a reference to an array or a reference to a slice;</li>
<li>when <code>index</code> is a literal, it must be smaller than <code>item</code> length;</li>
</ul>
<hr />
<pre><code class="language-sway">__dbg&lt;T&gt;(value: T) -&gt; T where T: Debug
</code></pre>
<p><strong>Description:</strong> Automatically calls the <code>Debug</code> trait on the passed <code>value</code>, with file, line and column information. The passed value is returned without any modification, allowing <code>__dbg(...)</code> to be used inside of any expression.</p>
<p>The code generated by this intrinsic function varies with the compilation mode. For example:</p>
<pre><code class="language-terminal">forc build            &lt;- will print everything as expected
forc build --release  &lt;- nothing will be printed
</code></pre>
<p>To enable code generation even on <code>Release</code> builds, the flag <code>force-dbg-in-release</code> needs to be enabled inside <code>forc.toml</code>.
Example:</p>
<pre><code class="language-toml">[project]
authors = ["Fuel Labs &lt;contact@fuel.sh&gt;"]
license = "Apache-2.0"
entry = "main.sw"
name = "some-project"
force-dbg-in-release = true
</code></pre>
<p>It is strongly suggested to always remove this flag before publishing binaries as it will not have any effect when running
on real nodes and it only increases gas usage.</p>
<p><strong>Constraints:</strong></p>
<ul>
<li><code>T</code> must implement Debug</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="attributes"><a class="header" href="#attributes">Attributes</a></h1>
<p>Attributes are a form of metadata that can additionally instruct Sway compiler or other tools like <code>forc test</code>. Attributes can annotate different language elements, like, e.g., items, enum variants, struct fields, etc.</p>
<p>Below is the list of attributes supported by the Sway compiler, ordered alphabetically:</p>
<ul>
<li><a href="reference/attributes.html#abi-name">ABI Name</a></li>
<li><a href="reference/attributes.html#allow">Allow</a></li>
<li><a href="reference/attributes.html#cfg">Cfg</a></li>
<li><a href="reference/attributes.html#deprecated">Deprecated</a></li>
<li><a href="reference/attributes.html#error">Error</a></li>
<li><a href="reference/attributes.html#error-type">Error Type</a></li>
<li><a href="reference/attributes.html#fallback">Fallback</a></li>
<li><a href="reference/attributes.html#inline">Inline</a></li>
<li><a href="reference/attributes.html#payable">Payable</a></li>
<li><a href="reference/attributes.html#payable">Storage</a></li>
<li><a href="reference/attributes.html#test">Test</a></li>
</ul>
<h2 id="abi-name"><a class="header" href="#abi-name">ABI Name</a></h2>
<p>The <code>#[abi_name]</code> attribute allows to specify the ABI name for an item.
This means that when an ABI JSON file is generated, the name that is output is the one specified
by the attribute. This can be useful to allow renaming items, while allowing for keeping backwards
compatibility at the contract ABI level.</p>
<blockquote>
<p><strong>Note</strong>: At the moment, only enum and struct types support the attribute.</p>
</blockquote>
<p>In the example that follows, we originally had <code>MyStruct</code> and <code>MyEnum</code> types, which we, later on, renamed to <code>RenamedMyStruct</code> and <code>RenamedMyEnum</code> in code. To keep the backward compatibility of the ABI, we annotate the types with the <code>#[abi_name]</code> attribute and give them the original names:</p>
<pre><code class="language-sway">contract;

#[abi_name(name = "MyStruct")]
struct RenamedMyStruct {}

#[abi_name(name = "MyEnum")]
enum RenamedMyEnum {
  A: ()
}

abi MyAbi {
    fn my_struct() -&gt; RenamedMyStruct;
    fn my_enum() -&gt; RenamedMyEnum;
}

impl MyAbi for Contract {
  fn my_struct() -&gt; RenamedMyStruct { RenamedMyStruct{} }
  fn my_enum() -&gt; RenamedMyEnum { RenamedMyEnum::A }
}
</code></pre>
<p>This generates the following JSON ABI:</p>
<pre><code class="language-json">{
  "concreteTypes": [
    {
      "concreteTypeId": "215af2bca9e1aa8fec647dab22a0cd36c63ce5ed051a132d51323807e28c0d67",
      "metadataTypeId": 1,
      "type": "enum MyEnum"
    },
    {
      "concreteTypeId": "d31db280ac133d726851d8003bd2f06ec2d3fc76a46f1007d13914088fbd0791",
      "type": "struct MyStruct"
    }
  ],
  ...
}
</code></pre>
<p>We get the same JSON ABI output both before and after renaming the types, due to attributing them with
<code>#[abi_name(name = ...)]</code>, which forces them to be generated with their previous Sway names.
This means consumers of this contract will still get the original names, keeping compatibility at the ABI level.</p>
<h2 id="allow"><a class="header" href="#allow">Allow</a></h2>
<p>The <code>#[allow(...)]</code> attribute disables compiler checks so that certain warnings will go unreported. The following warnings can be disabled:</p>
<ul>
<li><code>#[allow(dead_code)]</code> disables warnings for dead code;</li>
<li><code>#[allow(deprecated)]</code> disables warnings for usage of deprecated elements, like, e.g., structs, functions, enum variants, etc.</li>
</ul>
<h2 id="cfg"><a class="header" href="#cfg">Cfg</a></h2>
<p>The <code>#[cfg(...)]</code> attribute allows conditional compilation. The annotated code element will be compiled only if the condition in to the <code>cfg</code> attribute evaluates to true. The following conditions can be expressed:</p>
<ul>
<li><code>#[cfg(target = "&lt;target&gt;")]</code> where <code>&lt;target&gt;</code> can be either "evm" or "fuel";</li>
<li><code>#[cfg(program_type = "&lt;program_type&gt;")]</code> where <code>&lt;program_type&gt;</code> can be either "predicate", "script", "contract", or "library";</li>
<li><code>#[cfg(experimental_&lt;feature_flag&gt; = true/false)]</code> where <code>&lt;feature_flag&gt;</code> is one of the known experimental feature flags.</li>
</ul>
<h2 id="deprecated"><a class="header" href="#deprecated">Deprecated</a></h2>
<p>The <code>#[deprecated]</code> attribute marks an item as deprecated and makes the compiler emit a warning for every usage of the deprecated item. This warning can be disabled using <code>#[allow(deprecated)]</code>.</p>
<p>It is possible to improve the warning message with <code>#[deprecated(note = "Your deprecation message.")]</code></p>
<h2 id="error"><a class="header" href="#error">Error</a></h2>
<p>The <code>#[error]</code> defines an error message for an error type enum variant:</p>
<pre><code class="language-sway">#[error_type]
enum SomeErrors {
    #[error(m = "An unexpected error occurred.")]
    UnexpectedError: (),
}
</code></pre>
<h2 id="error-type"><a class="header" href="#error-type">Error Type</a></h2>
<p>The <code>#[error_type]</code> marks an enum as error type enum:</p>
<pre><code class="language-sway">#[error_type]
enum SomeErrors {
    ...
}
</code></pre>
<p>All variants of an error type enum must be annotated with the <a href="reference/attributes.html#error"><code>#[error]</code> attribute</a>. Error type enums are meant to be use in <code>panic</code> expressions for rich error reporting.</p>
<h2 id="fallback-1"><a class="header" href="#fallback-1">Fallback</a></h2>
<p>The <code>#[fallback]</code> attribute makes the compiler use the marked function as the contract call fallback function. This means that, when a contract method is called, and the contract method selection fails, the fallback function will be called instead.</p>
<p>More details in <a href="reference/../blockchain-development/calling_contracts.html#fallback">Calling Contracts</a>.</p>
<h2 id="inline"><a class="header" href="#inline">Inline</a></h2>
<p>The inline attribute <em>suggests</em> to the compiler if a copy of the annotated function should be placed in the caller, rather than generating code to call the function where it is defined.</p>
<p>The <code>#[inline(never)]</code> attribute <em>suggests</em> that an inline expansion should never be performed.</p>
<p>The <code>#[inline(always)]</code> attribute <em>suggests</em> that an inline expansion should always be performed.</p>
<blockquote>
<p><strong>Note</strong>: <code>#[inline(..)]</code> in every form is a hint, with no <em>requirements</em> on the compiler to place a copy of the annotated function in the caller. The Sway compiler automatically inlines functions based on internal heuristics. Incorrectly inlining functions can make the program slower, so this attribute should be used with care.</p>
</blockquote>
<h2 id="payable"><a class="header" href="#payable">Payable</a></h2>
<p>The lack of <code>#[payable]</code> implies the method is non-payable. When calling an ABI method that is non-payable, the compiler emits an error if the amount of coins forwarded with the call is not guaranteed to be zero. Note that this is strictly a compile-time check and does not incur any runtime cost.</p>
<h2 id="storage-1"><a class="header" href="#storage-1">Storage</a></h2>
<p>In Sway, functions are pure by default but can be opted into impurity via the <code>storage</code> function attribute. The <code>storage</code> attribute may take <code>read</code> and/or <code>write</code> arguments indicating which type of access the function requires.</p>
<p>The <code>#[storage(read)]</code> attribute indicates that a function requires read access to the storage.</p>
<p>The <code>#[storage(write)]</code> attribute indicates that a function requires write access to the storage.</p>
<p>More details in <a href="reference/../blockchain-development/purity.html">Purity</a>.</p>
<h2 id="test"><a class="header" href="#test">Test</a></h2>
<p>The <code>#[test]</code> attribute marks a function to be executed as a test.</p>
<p>The <code>#[test(should_revert)]</code> attribute marks a function to be executed as a test that should revert.</p>
<p>More details in <a href="reference/../testing/unit-testing.html">Unit Testing</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="style-guide"><a class="header" href="#style-guide">Style Guide</a></h1>
<h2 id="capitalization"><a class="header" href="#capitalization">Capitalization</a></h2>
<!-- This section should explain the capitalization style guide -->
<!-- cap:example:start -->
<p>In Sway, structs, traits, and enums are <code>CapitalCase</code>. Modules, variables, and functions are <code>snake_case</code>, constants are <code>SCREAMING_SNAKE_CASE</code>. The compiler will warn you if your capitalization is ever unidiomatic.</p>
<!-- cap:example:end -->
<div style="break-before: page; page-break-before: always;"></div><h1 id="known-issues-and-workarounds"><a class="header" href="#known-issues-and-workarounds">Known Issues and Workarounds</a></h1>
<h2 id="known-issues"><a class="header" href="#known-issues">Known Issues</a></h2>
<ul>
<li><a href="https://github.com/FuelLabs/sway/issues/870">#870</a>: All <code>impl</code> blocks need to be defined before any of the functions they define can be called.  This includes sibling functions in the same <code>impl</code> declaration, i.e., functions in an <code>impl</code> can't call each other yet.</li>
</ul>
<h2 id="missing-features"><a class="header" href="#missing-features">Missing Features</a></h2>
<ul>
<li><a href="https://github.com/FuelLabs/sway/issues/1182">#1182</a> Arrays in a <code>storage</code> block are not yet supported. See the <a href="reference/../advanced/advanced_storage.html#manual-storage-management">Manual Storage Management</a> section for details on how to use <code>store</code> and <code>get</code> from the standard library to manage storage slots directly. Note, however, that <code>StorageMap&lt;K, V&gt;</code> <em>does</em> support arbitrary types for <code>K</code> and <code>V</code> without any limitations.</li>
</ul>
<h2 id="general"><a class="header" href="#general">General</a></h2>
<ul>
<li>No compiler optimization passes have been implemented yet, therefore bytecode will be more expensive and larger than it would be in production. Note that eventually the optimizer will support zero-cost abstractions, avoiding the need for developers to go down to inline assembly to produce optimal code.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="behavior-considered-undefined"><a class="header" href="#behavior-considered-undefined">Behavior Considered Undefined</a></h1>
<p>Sway code that contains any of the following behavior is considered undefined.
The compiler is allowed to treat undefined Sway code however it desires,
including removing it or replacing it with any other Sway code.</p>
<p>This is not an exhaustive list, it may grow or shrink, there is no formal model
of Sway's semantics so there may be more behavior considered undefined. We
reserve the right to make some of the listed behavior defined in the future.</p>
<ul>
<li>Invalid arithmetic operations (overflows, underflows, division by zero, etc.).</li>
<li>Misuse of compiler intrinsics.</li>
<li>Incorrect use of inline assembly.</li>
<li>Reading and writing <code>raw_ptr</code> and <code>raw_slice</code>.</li>
<li>Slicing and indexing out of bounds by directly using compiler intrinsics.</li>
<li>Modifying collections while iterating over them using <code>Iterator</code>s.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="differences-from-solidity"><a class="header" href="#differences-from-solidity">Differences From Solidity</a></h1>
<p>This page outlines some of the critical differences between Sway and Solidity, and between the FuelVM and the EVM.</p>
<h2 id="underlying-virtual-machine"><a class="header" href="#underlying-virtual-machine">Underlying Virtual Machine</a></h2>
<p>The underlying virtual machine targeted by Sway is the FuelVM, specified <a href="https://github.com/FuelLabs/fuel-specs">here</a>. Solidity targets the Ethereum Virtual Machine (EVM), specified <a href="https://ethereum.github.io/yellowpaper/paper.pdf">here</a>.</p>
<h2 id="word-size"><a class="header" href="#word-size">Word Size</a></h2>
<p>Words in the FuelVM are 64 bits (8 bytes), rather than the 256 bits (32 bytes) of the EVM. Therefore, all primitive integers smaller and including <code>u64</code> are stored in registers; <code>u256</code>, being bigger than the registers, and hashes (the <code>b256</code> type) are not stored in registers but rather in memory. They are therefore pointers to a 32-byte memory region containing their data.</p>
<h2 id="unsigned-integers-only"><a class="header" href="#unsigned-integers-only">Unsigned Integers Only</a></h2>
<p>Only unsigned integers are provided as primitives: <code>u8</code>, <code>u16</code>, <code>u32</code>, <code>u64</code>, and <code>u256</code>. Signed integer arithmetic is not available in the FuelVM. Signed integers and signed integer arithmetic can be implemented in high-level libraries if needed.</p>
<h2 id="global-revert"><a class="header" href="#global-revert">Global Revert</a></h2>
<p>Panics in the FuelVM (called "reverts" in Solidity and the EVM) are global, i.e. they cannot be caught. A panic will completely and unconditionally revert the stateful effects of a transaction, minus gas used.</p>
<h2 id="default-safe-math"><a class="header" href="#default-safe-math">Default Safe Math</a></h2>
<!-- This section should explain safe math in Fuel vs EVM -->
<!-- safe_math:example:start -->
<p>Math in the FuelVM is by default safe (i.e. any overflow or exception is a panic). Safety checks are performed natively in the VM implementation, rather than at the bytecode level like <a href="https://docs.soliditylang.org/en/latest/080-breaking-changes.html#silent-changes-of-the-semantics">Solidity's default safe math</a>.</p>
<!-- safe_math:example:end -->
<h2 id="no-code-size-limit"><a class="header" href="#no-code-size-limit">No* Code Size Limit</a></h2>
<p>There is no practical code size limit to Sway contracts. The physical limit is governed by the <a href="https://fuellabs.github.io/fuel-specs/master/vm#parameters"><code>VM_MAX_RAM</code> VM parameter</a>, which at the time of writing is 64 MiB.</p>
<h2 id="account-types"><a class="header" href="#account-types">Account Types</a></h2>
<p>Account types in the FuelVM have type-safe wrappers around primitive <code>b256</code> hashes to clearly distinguish their respective types. The wrapper <code>Address</code> mirrors that of an EOA (Externally Owned Account) and has the ability to hold UTXOs in the context of the EVM. The other wrapper, <code>ContractId</code>, reflects that of a deployed contract in the EVM but cannot hold UTXOs.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="differences-from-rust"><a class="header" href="#differences-from-rust">Differences From Rust</a></h1>
<p>Sway shares a lot with Rust, especially its syntax. Because they are so similar, you may be surprised or caught off guard when they differ. This page serves to outline, from a high level, some of the syntactic <em>gotchas</em> that you may encounter.</p>
<h2 id="enum-variant-syntax"><a class="header" href="#enum-variant-syntax">Enum Variant Syntax</a></h2>
<p>In Rust, enums generally take one of three forms: <em>unit</em> variants, which have no inner data, <em>struct</em> variants, which contain named fields, and <em>tuple</em> variants, which contain within them a tuple of data. If you are unfamiliar with these terms, this is what they look like:</p>
<pre><code class="language-rust ignore">// note to those skimming the docs: this is Rust syntax! Not Sway! Don't copy/paste this into a Sway program.

enum Foo {
    UnitVariant,
    TupleVariant(u32, u64, bool),
    StructVariant {
        field_one: bool,
        field_two: bool
    }
}</code></pre>
<p>In Sway, enums are simplified. Enums variants must all specify exactly one type. This type represents their interior data. This is actually isomorphic to what Rust offers, but with a different syntax. You can see the above enum but with Sway syntax below:</p>
<pre><code class="language-sway">// This is equivalent Sway syntax for the above Rust enum.
enum Foo {
    UnitVariant: (),
    TupleVariant: (u32, u64, bool),
    StructVariant: MyStruct,
}

struct MyStruct {
    field_one: bool,
    field_two: bool,
}
</code></pre>
<h2 id="memory-allocation"><a class="header" href="#memory-allocation">Memory Allocation</a></h2>
<p>In Rust, the borrow checker implements Rust's <a href="https://doc.rust-lang.org/1.8.0/book/ownership.html">ownership system</a></p>
<p>In Sway, there is no borrow checker.  This means there is no concept of ownership, borrowing, or lifetimes.  Instead, objects are copied and moved similar to C++.  Also Sway does not have any destructors nor <code>Drop</code> traits.  This means allocated memory lives for the entire transaction and is not deallocated until the end of the transaction.  A transaction may allocate up to <a href="https://github.com/FuelLabs/fuel-vm/blob/a80f82ed7c793763de6a73ca72d946b311b0fd0b/fuel-vm/src/consts.rs#L26">64 MB</a> of memory.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="contributing-to-sway"><a class="header" href="#contributing-to-sway">Contributing To Sway</a></h1>
<p>Thanks for your interest in contributing to Sway! This document outlines the process for installing and setting up the Sway toolchain for development, as well as some conventions on contributing to Sway.</p>
<p>If you run into any difficulties getting started, you can always ask questions on our <a href="https://forum.fuel.network/">Discourse</a>.</p>
<h2 id="building-and-setting-up-a-development-workspace"><a class="header" href="#building-and-setting-up-a-development-workspace">Building and setting up a development workspace</a></h2>
<p>See the <a href="reference/../introduction/index.html">introduction</a> section for instructions on installing and setting up the Sway toolchain.</p>
<h2 id="getting-the-repository"><a class="header" href="#getting-the-repository">Getting the repository</a></h2>
<ol>
<li>Visit the <a href="https://github.com/FuelLabs/sway">Sway</a> repo and fork the project.</li>
<li>Then clone your forked copy to your local machine and get to work.</li>
</ol>
<pre><code class="language-sh">git clone https://github.com/FuelLabs/sway
cd sway
</code></pre>
<h2 id="building-and-testing"><a class="header" href="#building-and-testing">Building and testing</a></h2>
<p>The following steps will run the sway test suite and ensure that everything is set up correctly.</p>
<p>First, open a new terminal and start <code>fuel-core</code> with:</p>
<pre><code class="language-sh">fuel-core
</code></pre>
<p>Then open a second terminal, <code>cd</code> into the <code>sway</code> repo and run:</p>
<pre><code class="language-sh">cargo run --bin test
</code></pre>
<p>After the test suite runs, you should see:</p>
<pre><code class="language-console">Tests passed.
_n_ tests run (0 skipped)
</code></pre>
<p>Congratulations! You've now got everything setup and are ready to start making contributions.</p>
<h2 id="finding-something-to-work-on"><a class="header" href="#finding-something-to-work-on">Finding something to work on</a></h2>
<p>There are many ways in which you may contribute to the Sway project, some of which involve coding knowledge and some which do not. A few examples include:</p>
<ul>
<li>Reporting bugs</li>
<li>Adding documentation to the Sway book</li>
<li>Adding new features or bug fixes for which there is already an open issue</li>
<li>Making feature requests</li>
</ul>
<p>Check out our <a href="https://github.com/FuelLabs/sway/issues?q=is%3Aopen+is%3Aissue+label%3A%22help+wanted%22">Help Wanted</a>, <a href="https://github.com/FuelLabs/sway/issues?q=is%3Aopen+is%3Aissue+label%3A%22The+Sway+Book%22">Sway Book</a> or <a href="https://github.com/FuelLabs/sway/issues?q=is%3Aopen+is%3Aissue+label%3A%22good+first+issue%22">Good First Issue</a> issues to find a suitable task.</p>
<p>If you are planning something big, for example, related to multiple components or changes current behaviors, make sure to open an issue to discuss with us before starting on the implementation.</p>
<h2 id="contribution-flow"><a class="header" href="#contribution-flow">Contribution flow</a></h2>
<p>This is a rough outline of what a contributor's workflow looks like:</p>
<ul>
<li>Make sure what you want to contribute is already tracked as an issue.
<ul>
<li>We may discuss the problem and solution in the issue.</li>
</ul>
</li>
<li>Create a Git branch from where you want to base your work. This is usually master.</li>
<li>Write code, add test cases, and commit your work.</li>
<li>Run tests and make sure all tests pass.</li>
<li>If the PR contains any breaking changes, add the breaking label to your PR.</li>
<li>Push your changes to a branch in your fork of the repository and submit a pull request.
<ul>
<li>Make sure to mention the issue, which is created at step 1, in the commit message.</li>
</ul>
</li>
<li>Your PR will be reviewed and some changes may be requested.
<ul>
<li>Once you've made changes, your PR must be re-reviewed and approved.</li>
<li>If the PR becomes out of date, you can use GitHub's 'update branch' button.</li>
<li>If there are conflicts, you can merge and resolve them locally. Then push to your PR branch.
Any changes to the branch will require a re-review.</li>
</ul>
</li>
<li>Our CI system (Github Actions) automatically tests all authorized pull requests.</li>
<li>Use Github to merge the PR once approved.</li>
</ul>
<p>Thanks for your contributions!</p>
<h3 id="linking-issues"><a class="header" href="#linking-issues">Linking issues</a></h3>
<p>Pull requests should be linked to at least one issue in the same repo.</p>
<p>If the pull request resolves the relevant issues, and you want GitHub to close these issues automatically after it merged into the default branch, you can use the syntax (<code>KEYWORD #ISSUE-NUMBER</code>) like this:</p>
<pre><code class="language-markdown">close #123
</code></pre>
<p>If the pull request links an issue but does not close it, you can use the keyword <code>ref</code> like this:</p>
<pre><code class="language-markdown">ref #456
</code></pre>
<p>Multiple issues should use full syntax for each issue and separate by a comma, like:</p>
<pre><code class="language-markdown">close #123, ref #456
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="keywords"><a class="header" href="#keywords">Keywords</a></h1>
<p>The following list contains keywords that are reserved for current or
future use by the Sway language. As such, <strong>they cannot be used as
identifiers</strong>. Identifiers are names of functions, variables,
parameters, modules, constants, attributes, types or
traits, etc.</p>
<h2 id="keywords-currently-in-use"><a class="header" href="#keywords-currently-in-use">Keywords Currently in Use</a></h2>
<p>The following is an alphabetically sorted list of keywords currently in use, with their
functionality shortly described.</p>
<ul>
<li><code>as</code> - rename items in <code>use</code> statements, e.g., <code>use type::type_name as alias_name;</code></li>
<li><a href="reference/../sway-program-types/smart_contracts.html#the-abi-declaration"><code>abi</code></a> - define a smart contract ABI in a syntactically similar way to traits</li>
<li><a href="reference/../advanced/assembly.html"><code>asm</code></a> - define an assembly block</li>
<li><a href="reference/../basics/control_flow.html#break-and-continue"><code>break</code></a> - exit a loop immediately</li>
<li><code>configurable</code> - define configurable constants</li>
<li><a href="reference/../basics/constants.html"><code>const</code></a> - define constant</li>
<li><a href="reference/../basics/control_flow.html#break-and-continue"><code>continue</code></a> - continue to the next loop iteration</li>
<li><a href="reference/../sway-program-types/smart_contracts.html"><code>contract</code></a> - define contract program type</li>
<li><code>else</code> - used in conjunction with <code>if</code> conditions for control flow constructs</li>
<li><a href="reference/../basics/structs_tuples_and_enums.html#enums"><code>enum</code></a> - define an enum</li>
<li><code>false</code> - Boolean false literal</li>
<li><a href="reference/../basics/control_flow.html#for"><code>for</code></a> - loop based on iterators</li>
<li><a href="reference/../basics/functions.html"><code>fn</code></a>- define a function</li>
<li><a href="reference/../basics/control_flow.html#if-expressions"><code>if</code></a> - branch based on the result of a conditional expression</li>
<li><code>impl</code> - implement inherent or trait functionality</li>
<li><code>let</code> - bind a variable</li>
<li><a href="reference/../sway-program-types/libraries.html"><code>library</code></a> - define library program type</li>
<li><a href="reference/../basics/control_flow.html#match-expressions"><code>match</code></a> - exhaustively match a value to patterns</li>
<li><code>mod</code> - define a module</li>
<li><code>mut</code> - denote mutability</li>
<li><code>pub</code> - denote public visibility</li>
<li><a href="reference/../sway-program-types/predicates.html"><code>predicate</code></a> - define predicate program type</li>
<li><code>ref</code> - bind by reference</li>
<li><code>return</code> - return early from a function</li>
<li><a href="reference/../sway-program-types/scripts.html"><code>script</code></a> - define script program type</li>
<li><code>Self</code> - a type alias for the type we are defining or implementing</li>
<li><code>self</code> - method call target</li>
<li><a href="reference/../blockchain-development/storage.html"><code>storage</code></a> - define a storage declaration</li>
<li><code>str</code>- string slice</li>
<li><a href="reference/../basics/structs_tuples_and_enums.html#structs"><code>struct</code></a> - define a structure</li>
<li><a href="reference/../advanced/traits.html#declaring-a-trait"><code>trait</code></a> - define a trait</li>
<li><code>true</code> - Boolean true literal</li>
<li><a href="reference/../advanced/advanced_types.html#creating-type-synonyms-with-type-aliases"><code>type</code></a> - define a type alias or associated type</li>
<li><code>use</code> - bring symbols into scope</li>
<li><code>where</code> - specifies trait constraints for generic type arguments</li>
<li><a href="reference/../basics/control_flow.html#while"><code>while</code></a> - loop conditionally based on the result of an expression</li>
</ul>
<h2 id="keywords-reserved-for-possible-future-use"><a class="header" href="#keywords-reserved-for-possible-future-use">Keywords Reserved for Possible Future Use</a></h2>
<ul>
<li><code>abstract</code></li>
<li><code>async</code></li>
<li><code>await</code></li>
<li><code>become</code></li>
<li><code>box</code></li>
<li><code>do</code></li>
<li><code>dyn</code></li>
<li><code>extern</code></li>
<li><code>for</code></li>
<li><code>in</code></li>
<li><code>loop</code></li>
<li><code>macro</code></li>
<li><code>move</code></li>
<li><code>override</code></li>
<li><code>priv</code></li>
<li><code>static</code></li>
<li><code>super</code></li>
<li><code>try</code></li>
<li><code>typeof</code></li>
<li><code>unsafe</code></li>
<li><code>unsized</code></li>
<li><code>virtual</code></li>
<li><code>yield</code></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="forc-reference"><a class="header" href="#forc-reference">Forc Reference</a></h1>
<p>Forc stands for Fuel Orchestrator. Forc provides a variety of tools and commands for developers working with the Fuel ecosystem, such as scaffolding a new project, formatting, running scripts, deploying contracts, testing contracts, and more. If you're coming from a Rust background, forc is similar to cargo.</p>
<p>If you are new to Forc, see the <a href="https://docs.fuel.network/docs/sway/introduction/forc_project/">Forc Project</a> introduction section.</p>
<p>For a comprehensive overview of the Forc CLI commands, see the <a href="forc/./commands/index.html">Commands</a> section.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="manifest-reference"><a class="header" href="#manifest-reference">Manifest Reference</a></h1>
<p>The <code>Forc.toml</code> (the <em>manifest</em> file) is a compulsory file for each package and it is written in [TOML] format. <code>Forc.toml</code> consists of the following fields:</p>
<ul>
<li>
<p><a href="forc/manifest_reference.html#the-project-section"><code>[project]</code></a> â€” Defines a sway project.</p>
<ul>
<li><code>name</code> â€” The name of the project.</li>
<li><code>version</code> â€” The version of the project.</li>
<li><code>description</code> â€” A description of the project.</li>
<li><code>authors</code> â€” The authors of the project.</li>
<li><code>organization</code> â€” The organization of the project.</li>
<li><code>license</code> â€” The project license.</li>
<li><code>homepage</code> â€” URL of the project homepage.</li>
<li><code>repository</code> â€” URL of the project source repository.</li>
<li><code>documentation</code> â€” URL of the project documentation.</li>
<li><code>categories</code> â€”  Categories of the project.</li>
<li><code>keywords</code> â€”  Keywords the project.</li>
<li><code>entry</code> â€” The entry point for the compiler to start parsing from.
<ul>
<li>For the recommended way of selecting an entry point of large libraries please take a look at: <a href="forc/./../sway-program-types/libraries.html">Libraries</a></li>
</ul>
</li>
<li><code>implicit-std</code> -  Controls whether provided <code>std</code> version (with the current <code>forc</code> version) will get added as a dependency <em>implicitly</em>. <em>Unless you know what you are doing, leave this as default.</em></li>
<li><code>forc-version</code> - The minimum forc version required for this project to work properly.</li>
<li><code>metadata</code> - Metadata for the project; can be used by tools which would like to store package configuration in <code>Forc.toml</code>.</li>
</ul>
</li>
<li>
<p><a href="forc/manifest_reference.html#the-dependencies-section"><code>[dependencies]</code></a> â€” Defines the dependencies.</p>
</li>
<li>
<p><code>[network]</code> â€” Defines a network for forc to interact with.</p>
<ul>
<li><code>url</code> â€” URL of the network.</li>
</ul>
</li>
<li>
<p><a href="forc/manifest_reference.html#the-build-profile-section"><code>[build-profile]</code></a> - Defines the build profiles.</p>
</li>
<li>
<p><a href="forc/manifest_reference.html#the-patch-section"><code>[patch]</code></a> - Defines the patches.</p>
</li>
<li>
<p><a href="forc/manifest_reference.html#the-contract-dependencies-section"><code>[contract-dependencies]</code></a> - Defines the contract dependencies.</p>
</li>
</ul>
<h2 id="the-project-section"><a class="header" href="#the-project-section">The <code>[project]</code> section</a></h2>
<p>An example <code>Forc.toml</code> is shown below. Under <code>[project]</code> the following fields are optional:</p>
<ul>
<li><code>authors</code></li>
<li><code>organization</code></li>
<li><code>version</code></li>
<li><code>description</code></li>
<li><code>homepage</code></li>
<li><code>repository</code></li>
<li><code>documentation</code></li>
<li><code>categories</code></li>
<li><code>keywords</code></li>
</ul>
<p>Also for the following fields, a default value is provided so omitting them is allowed:</p>
<ul>
<li><code>entry</code> - (default : <code>main.sw</code> )</li>
<li><code>implicit-std</code> - (default : <code>true</code> )</li>
</ul>
<pre><code class="language-toml">[project]
authors = ["user"]
entry = "main.sw"
description = "Wallet contract"
version = "1.0.0"
homepage = "https://example.com/"
repository = "https://example.com/"
documentation = "https://example.com/"
organization = "Fuel_Labs"
license = "Apache-2.0"
name = "wallet_contract"
categories = ["example"]
keywords = ["example"]

[project.metadata]
indexing = { namespace = "counter-contract", schema_path = "out/release/counter-contract-abi.json" }
</code></pre>
<h3 id="metadata-section-in-forctoml"><a class="header" href="#metadata-section-in-forctoml">Metadata Section in <code>Forc.toml</code></a></h3>
<p>The <code>[project.metadata]</code> section provides a dedicated space for external tools and plugins to store their configuration in <code>Forc.toml</code>. The metadata key names are arbitrary and do not need to match the tool's name.</p>
<h4 id="workspace-vs-project-metadata"><a class="header" href="#workspace-vs-project-metadata">Workspace vs Project Metadata</a></h4>
<p>Metadata can be defined at two levels:</p>
<p>Workspace level - defined in the workspace's root <code>Forc.toml</code>:</p>
<pre><code class="language-toml">[workspace.metadata]
my_tool = { shared_setting = "value" }
</code></pre>
<p>Project level - defined in individual project's <code>Forc.toml</code>:</p>
<pre><code class="language-toml">[project.metadata.any_name_here]
option1 = "value"
option2 = "value"

[project.metadata.my_custom_config]
setting1 = "value"
setting2 = "value"
</code></pre>
<p>Example for an indexing tool:</p>
<pre><code class="language-toml">[project.metadata.indexing]
namespace = "counter-contract"
schema_path = "out/release/counter-contract-abi.json"
</code></pre>
<p>When both workspace and project metadata exist:</p>
<ul>
<li>Project-level metadata should take precedence over workspace metadata</li>
<li>Tools can choose to merge workspace and project settings</li>
<li>Consider documenting your tool's metadata inheritance behavior</li>
</ul>
<h4 id="guidelines-for-plugin-developers"><a class="header" href="#guidelines-for-plugin-developers">Guidelines for Plugin Developers</a></h4>
<p>Best Practices</p>
<ul>
<li>Choose clear, descriptive metadata key names</li>
<li>Document the exact metadata key name your tool expects</li>
<li>Don't require <code>Forc.toml</code> if tool can function without it</li>
<li>Consider using TOML format for dedicated config files</li>
<li>Specify how your tool handles workspace vs project metadata</li>
</ul>
<p>Implementation Notes</p>
<ul>
<li>The metadata section is optional</li>
<li>Forc does not parse metadata contents</li>
<li>Plugin developers handle their own configuration parsing</li>
<li>Choose unique metadata keys to avoid conflicts with other tools</li>
</ul>
<h4 id="example-use-cases"><a class="header" href="#example-use-cases">Example Use Cases</a></h4>
<ul>
<li>Documentation generation settings</li>
<li>Formatter configurations</li>
<li>Debugger options</li>
<li>Wallet integration</li>
<li>Contract indexing</li>
<li>Testing frameworks</li>
</ul>
<p>This allows for a streamlined developer experience while maintaining clear separation between core Forc functionality and third-party tools.</p>
<h4 id="external-tooling-examples"><a class="header" href="#external-tooling-examples">External Tooling Examples</a></h4>
<ul>
<li><a href="https://github.com/FuelLabs/example-forc-plugins/tree/master/forc-index-ts">forc-index-ts</a>: A TypeScript CLI tool for parsing <code>Forc.toml</code> metadata to read contract ABI JSON file.</li>
<li><a href="https://github.com/FuelLabs/example-forc-plugins/tree/master/forc-index-rs">forc-index-rs</a>: A Rust CLI tool for parsing <code>Forc.toml</code> metadata to read contract ABI JSON file.</li>
</ul>
<h2 id="the-dependencies-section"><a class="header" href="#the-dependencies-section">The <code>[dependencies]</code> section</a></h2>
<p>The following fields can be provided with a dependency:</p>
<ul>
<li><code>version</code> - Desired version of the dependency</li>
<li><code>namespace</code> - If the specified registry source (by its version) also has a namespace associated with it (optional)</li>
<li><code>path</code> - The path of the dependency (if it is local)</li>
<li><code>git</code> - The URL of the git repo hosting the dependency</li>
<li><code>branch</code> - The desired branch to fetch from the git repo</li>
<li><code>tag</code> - The desired tag to fetch from the git repo</li>
<li><code>rev</code> - The desired rev (i.e. commit hash) reference</li>
</ul>
<p>Please see <a href="forc/./dependencies.html">dependencies</a> for details</p>
<h2 id="the-network-section"><a class="header" href="#the-network-section">The <code>[network]</code> section</a></h2>
<p>For the following fields, a default value is provided so omitting them is allowed:</p>
<ul>
<li><code>URL</code> - (default: <em><a href="http://127.0.0.1:4000">http://127.0.0.1:4000</a></em>)</li>
</ul>
<h2 id="the-build-profile-section"><a class="header" href="#the-build-profile-section">The <code>[build-profile.*]</code> section</a></h2>
<p>The <code>[build-profile]</code> tables provide a way to customize compiler settings such as debug options.</p>
<p>The following fields can be provided for a build-profile:</p>
<ul>
<li><code>print-ast</code> - Whether to print out the generated AST or not, defaults to false.</li>
<li><code>print-dca-graph</code> - Whether to print out the computed Dead Code Analysis (DCA) graph (in GraphViz DOT format), defaults to false.</li>
<li><code>print-dca-graph-url-format</code> - The URL format to be used in the generated DOT file, an example for VS Code would be: <code>vscode://file/{path}:{line}:{col}</code>.</li>
<li><code>print-ir</code> - Whether to print out the generated Sway IR (Intermediate Representation) or not, defaults to false.</li>
<li><code>print-asm</code> - Whether to print out the generated ASM (assembler), defaults to false.</li>
<li><code>terse</code> - Terse mode. Limited warning and error output, defaults to false.</li>
<li><code>time_phases</code> - Whether to output the time elapsed over each part of the compilation process, defaults to false.</li>
<li><code>include_tests</code> -  Whether or not to include test functions in parsing, type-checking, and code generation. This is set to true by invocations like <code>forc test</code>, but defaults to false.</li>
<li><code>error_on_warnings</code> - Whether to treat errors as warnings, defaults to false.</li>
</ul>
<p>There are two default <code>[build-profile]</code> available with every manifest file. These are <code>debug</code> and <code>release</code> profiles. If you want to override these profiles, you can provide them explicitly in the manifest file like the following example:</p>
<pre><code class="language-toml">[project]
authors = ["user"]
entry = "main.sw"
organization = "Fuel_Labs"
license = "Apache-2.0"
name = "wallet_contract"

[build-profile.debug]
print-asm = { virtual = false, allocated = false, final = true }
print-ir = { initial = false, final = true, modified = false, passes = []}
terse = false

[build-profile.release]
print-asm = { virtual = true, allocated = false, final = true }
print-ir = { initial = true, final = false, modified = true, passes = ["dce", "sroa"]}
terse = true
</code></pre>
<p>Since <code>release</code> and <code>debug</code> are implicitly included in every manifest file, you can use them by just passing <code>--release</code> or by not passing anything (<code>debug</code> is default). For using a user defined build profile there is <code>--build-profile &lt;profile name&gt;</code> option available to the relevant commands. (For an example see <a href="forc/../forc/commands/forc_build.html">forc-build</a>)</p>
<p>Note that providing the corresponding CLI options (like <code>--asm</code>) will override the selected build profile. For example if you pass both <code>--release</code> and <code>--asm all</code>, <code>release</code> build profile is overridden and resulting build profile would have a structure like the following:</p>
<pre><code class="language-toml">print-ast = false
print-ir = { initial = false, final = false, modified = false, passes = []}
print-asm = { virtual = true, allocated = true, final = true }
terse = false
time-phases = false
include-tests = false
error-on-warnings = false
experimental-private-modules = false
</code></pre>
<h2 id="the-patch-section"><a class="header" href="#the-patch-section">The <code>[patch]</code> section</a></h2>
<p>The [patch] section of <code>Forc.toml</code> can be used to override dependencies with other copies. The example provided below patches <code>https://github.com/fuellabs/sway</code> with the <code>test</code> branch of the same repo.</p>
<pre><code class="language-toml">[project]
authors = ["user"]
entry = "main.sw"
organization = "Fuel_Labs"
license = "Apache-2.0"
name = "wallet_contract"

[dependencies]

[patch.'https://github.com/fuellabs/sway']
std = { git = "https://github.com/fuellabs/sway", branch = "test" }
</code></pre>
<p>In the example above, <code>std</code> is patched with the <code>test</code> branch from <code>std</code> repo. You can also patch git dependencies with dependencies defined with a path.</p>
<pre><code class="language-toml">[patch.'https://github.com/fuellabs/sway']
std = { path = "/path/to/local_std_version" }
</code></pre>
<p>Just like <code>std</code> you can also patch dependencies you declared with a git repo.</p>
<pre><code class="language-toml">[project]
authors = ["user"]
entry = "main.sw"
organization = "Fuel_Labs"
license = "Apache-2.0"
name = "wallet_contract"

[dependencies]
foo = { git = "https://github.com/foo/foo", branch = "master" }

[patch.'https://github.com/foo']
foo = { git = "https://github.com/foo/foo", branch = "test" }
</code></pre>
<p>Note that each key after the <code>[patch]</code> is a URL of the source that is being patched.</p>
<h2 id="the-contract-dependencies-section"><a class="header" href="#the-contract-dependencies-section">The <code>[contract-dependencies]</code> section</a></h2>
<p>The <code>[contract-dependencies]</code> table can be used to declare contract dependencies for a Sway contract or script. Contract dependencies are the set of contracts that our contract or script may interact with. Declaring <code>[contract-dependencies]</code> makes it easier to refer to contracts in your Sway source code without having to manually update IDs each time a new version is deployed. Instead, we can use forc to pin and update contract dependencies just like we do for regular library dependencies.</p>
<p>Contracts declared under <code>[contract-dependencies]</code> are built and pinned just like regular <code>[dependencies]</code> however rather than importing each contract dependency's entire public namespace we instead import their respective contract IDs as <code>CONTRACT_ID</code> constants available via each contract dependency's namespace root. This means you can use a contract dependency's ID as if it were declared as a <code>pub const</code> in the root of the contract dependency package as demonstrated in the example below.</p>
<p>Entries under <code>[contract-dependencies]</code> can be declared in the same way that <code>[dependencies]</code> can be declared. That is, they can refer to the <code>path</code> or <code>git</code> source of another contract. Note that entries under <code>[contract-dependencies]</code> must refer to contracts and will otherwise produce an error.</p>
<p>Example <code>Forc.toml</code>:</p>
<pre><code class="language-toml">[project]
authors = ["user"]
entry = "main.sw"
organization = "Fuel_Labs"
license = "Apache-2.0"
name = "wallet_contract"

[contract-dependencies]
foo = { path = "../foo" }
</code></pre>
<p>Example usage:</p>
<pre><code class="language-sway">script;

fn main() {
  let foo_id = foo::CONTRACT_ID;
}
</code></pre>
<p>Because the ID of a contract is computed deterministically, rebuilding the same contract would always result in the same contract ID. Since two contracts with the same contract ID cannot be deployed on the blockchain, a "salt" factor is needed to modify the contract ID. For each contract dependency declared under <code>[contract-dependencies]</code>, <code>salt</code> can be specified. An example is shown below:</p>
<pre><code class="language-toml">[contract-dependencies]
foo = { path = "../foo", salt = "0x1000000000000000000000000000000000000000000000000000000000000000" }
</code></pre>
<p>For contract dependencies that do not specify any value for <code>salt</code>, a default of all zeros for <code>salt</code> is implicitly applied.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="workspaces"><a class="header" href="#workspaces">Workspaces</a></h1>
<p>A <em>workspace</em> is a collection of one or more packages, namely <em>workspace members</em>, that are managed together.</p>
<p>The key points for workspaces are:</p>
<ul>
<li>Common <code>forc</code> commands available for a single package can also be used for a workspace, like <code>forc build</code> or <code>forc deploy</code>.</li>
<li>All packages share a common <code>Forc.lock</code> file which resides in the root directory of the workspace.</li>
</ul>
<p>Workspace manifests are declared within <code>Forc.toml</code> files and support the following fields:</p>
<ul>
<li><a href="forc/workspaces.html#the-members-field"><code>members</code></a> - Packages to include in the workspace.</li>
<li><a href="forc/workspaces.html#the-patch-section"><code>[patch]</code></a> - Defines the patches.</li>
</ul>
<p>An empty workspace can be created with <code>forc new --workspace</code> or <code>forc init --workspace</code>.</p>
<h2 id="the-members-field"><a class="header" href="#the-members-field">The <code>members</code> field</a></h2>
<p>The <code>members</code> field defines which packages are members of the workspace:</p>
<pre><code class="language-toml">[workspace]
members = ["member1", "path/to/member2"]
</code></pre>
<p>The <code>members</code> field accepts entries to be given in relative path with respect to the workspace root.
Packages that are located within a workspace directory but are <em>not</em> contained within the <code>members</code> set are ignored.</p>
<h2 id="the-patch-section-1"><a class="header" href="#the-patch-section-1">The <code>[patch]</code> section</a></h2>
<p>The <code>[patch]</code> section can be used to override any dependency in the workspace dependency graph. The usage is the same with package level <code>[patch]</code> section and details can be seen <a href="forc/./manifest_reference.html#the-patch-section">here</a>.</p>
<p>It is not allowed to declare patch table in member of a workspace if the workspace manifest file contains a patch table.</p>
<p>Example:</p>
<pre><code class="language-toml">[workspace]
members = ["member1", "path/to/member2"]


[patch.'https://github.com/fuellabs/sway']
std = { git = "https://github.com/fuellabs/sway", branch = "test" }
</code></pre>
<p>In the above example each occurrence of <code>std</code> as a dependency in the workspace will be changed with <code>std</code> from <code>test</code> branch of sway repo.</p>
<h2 id="some-forc-commands-that-support-workspaces"><a class="header" href="#some-forc-commands-that-support-workspaces">Some <code>forc</code> commands that support workspaces</a></h2>
<ul>
<li><code>forc build</code> - Builds an entire workspace.</li>
<li><code>forc deploy</code> - Builds and deploys all deployable members (i.e, contracts) of the workspace in the correct order.</li>
<li><code>forc run</code> - Builds and runs all scripts of the workspace.</li>
<li><code>forc check</code> - Checks all members of the workspace.</li>
<li><code>forc update</code> - Checks and updates workspace level <code>Forc.lock</code> file that is shared between workspace members.</li>
<li><code>forc clean</code> - Cleans all output artifacts for each member of the workspace.</li>
<li><code>forc fmt</code> - Formats all members of a workspace.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="dependencies"><a class="header" href="#dependencies">Dependencies</a></h1>
<p>Forc has a dependency management system which can pull packages using <code>git</code>, <code>ipfs</code>, <code>path</code>, or the community <code>registry</code>. This allows users to build and share Forc libraries.</p>
<h2 id="adding-dependencies"><a class="header" href="#adding-dependencies">Adding Dependencies</a></h2>
<p>You can add dependencies manually in your <code>Forc.toml</code>, or by using the <code>forc add</code> command.</p>
<h3 id="using-forc-add"><a class="header" href="#using-forc-add">Using <code>forc add</code></a></h3>
<p>The <code>forc add</code> CLI supports various sources and optional flags:</p>
<pre><code class="language-bash">forc add &lt;dep&gt; [--path &lt;PATH&gt;] [--git &lt;URL&gt; --tag &lt;TAG&gt;] [--ipfs &lt;CID&gt;] [--contract-dep]
</code></pre>
<h4 id="add-examples"><a class="header" href="#add-examples">Add Examples</a></h4>
<ul>
<li>
<p>From a Git branch:</p>
<pre><code class="language-bash">forc add custom_lib --git https://github.com/FuelLabs/custom_lib --branch master
</code></pre>
</li>
<li>
<p>From a local path:</p>
<pre><code class="language-bash">forc add custom_lib --path ../custom_lib
</code></pre>
</li>
<li>
<p>From IPFS:</p>
<pre><code class="language-bash">forc add custom_lib --ipfs QmYwAPJzv5CZsnA...
</code></pre>
</li>
<li>
<p>From registry (forc.pub):</p>
<pre><code class="language-bash">forc add custom_lib@0.0.1
</code></pre>
</li>
<li>
<p>Add as a contract dependency:</p>
<pre><code class="language-bash">forc add my_contract --git https://github.com/example/contract --contract-dep
</code></pre>
</li>
</ul>
<p>Optional:</p>
<ul>
<li><code>--salt &lt;HEX&gt;</code> for custom contract salt.</li>
<li><code>--package &lt;NAME&gt;</code> to target a specific package in a workspace.</li>
<li><code>--manifest-path &lt;PATH&gt;</code> to specify a manifest file.</li>
</ul>
<blockquote>
<p>âš ï¸ <strong>Note:</strong>
We do not currently support offline mode for projects that use <strong>registry</strong> sources.
Also wildcard declarations <code>(ex: custom_lib = *)</code> to get the latest version available for that package or caret declarations <code>(ex: custom_lib = ^0.1)</code> to get <code>SemVer</code> compatible latest available option for a given dependency is not supported yet.</p>
</blockquote>
<p>Once the package is added, running <code>forc build</code> will automatically fetch and resolve the dependencies.</p>
<h3 id="manually-editing-forctoml"><a class="header" href="#manually-editing-forctoml">Manually Editing <code>Forc.toml</code></a></h3>
<p>If your <code>Forc.toml</code> doesn't already have a <code>[dependencies]</code> or <code>[contract-dependencies]</code> table, add one. Below, list the package name and its source.</p>
<h4 id="local-path"><a class="header" href="#local-path">Local Path</a></h4>
<pre><code class="language-toml">[dependencies]
custom_lib = { path = "../custom_lib" }
</code></pre>
<h4 id="ipfs-source"><a class="header" href="#ipfs-source">IPFS Source</a></h4>
<pre><code class="language-toml">[dependencies]
custom_lib = { ipfs = "QmYwAPJzv5CZsnA..." }
</code></pre>
<h4 id="registry-source-forcpub"><a class="header" href="#registry-source-forcpub">Registry Source (forc.pub)</a></h4>
<pre><code class="language-toml">[dependencies]
custom_lib = "0.0.1"
</code></pre>
<h2 id="removing-dependencies"><a class="header" href="#removing-dependencies">Removing Dependencies</a></h2>
<p>You can remove one or more dependencies using the <code>forc remove</code> command:</p>
<pre><code class="language-bash">forc remove &lt;dep&gt; [--contract-dep] [--package &lt;NAME&gt;] [--manifest-path &lt;PATH&gt;]
</code></pre>
<h3 id="remove-examples"><a class="header" href="#remove-examples">Remove Examples</a></h3>
<ul>
<li>
<p>Remove from <code>[dependencies]</code>:</p>
<pre><code class="language-bash">forc remove custom_lib
</code></pre>
</li>
<li>
<p>Remove from <code>[contract-dependencies]</code>:</p>
<pre><code class="language-bash">forc remove my_contract --contract-dep
</code></pre>
</li>
<li>
<p>Target a specific package in a workspace:</p>
<pre><code class="language-bash">forc remove custom_lib --package my_project
</code></pre>
</li>
</ul>
<h2 id="updating-dependencies"><a class="header" href="#updating-dependencies">Updating Dependencies</a></h2>
<p>To update dependencies in your Forc directory you can run:</p>
<pre><code class="language-bash">forc update
</code></pre>
<p>For path and ipfs dependencies this will have no effect. For git dependencies with a branch reference, this will update the project to use the latest commit for the given branch.</p>
<div style="break-before: page; page-break-before: always;"></div><!-- markdownlint-disable MD041 -->
<p>Here are a list of commands available to forc:</p>
<ul>
<li><a href="forc/commands/./forc_add.html">forc add</a></li>
<li><a href="forc/commands/./forc_remove.html">forc remove</a></li>
<li><a href="forc/commands/./forc_addr2line.html">forc addr2line</a></li>
<li><a href="forc/commands/./forc_build.html">forc build</a></li>
<li><a href="forc/commands/./forc_check.html">forc check</a></li>
<li><a href="forc/commands/./forc_clean.html">forc clean</a></li>
<li><a href="forc/commands/./forc_completions.html">forc completions</a></li>
<li><a href="forc/commands/./forc_contract-id.html">forc contract-id</a></li>
<li><a href="forc/commands/./forc_init.html">forc init</a></li>
<li><a href="forc/commands/./forc_new.html">forc new</a></li>
<li><a href="forc/commands/./forc_parse-bytecode.html">forc parse-bytecode</a></li>
<li><a href="forc/commands/./forc_plugins.html">forc plugins</a></li>
<li><a href="forc/commands/./forc_predicate-root.html">forc predicate-root</a></li>
<li><a href="forc/commands/./forc_test.html">forc test</a></li>
<li><a href="forc/commands/./forc_update.html">forc update</a></li>
<li><a href="forc/commands/./forc_template.html">forc template</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="usage-1"><a class="header" href="#usage-1">Usage:</a></h1>
<p>Arguments:</p>
<p>&lt;<em>DEP_SPEC</em>&gt;</p>
<p>..
List of dependencies to add in the format "name[@version]"</p>
<p>Options:</p>
<p><code>--dry-run</code></p>
<p>Print the changes that would be made without actually making them</p>
<p><code>-v</code>, <code>--verbose...</code></p>
<p>Use verbose output</p>
<p><code>-s</code>, <code>--silent</code></p>
<p>Silence all output</p>
<p><code>-L</code>, <code>--log-level</code> &lt;<em>LOG_LEVEL</em>&gt;</p>
<p>Set the log level</p>
<p><code>-h</code>, <code>--help</code></p>
<p>Print help (see a summary with '-h')</p>
<p><code>-V</code>, <code>--version</code></p>
<p>Print version</p>
<p>Manifest Options:</p>
<p><code>--manisfest-path</code> &lt;<em>PATH</em>&gt;</p>
<p>Path to the manifest file</p>
<p>Package Selection:</p>
<p><code>-p</code>, <code>--package</code> &lt;<em>SPEC</em>&gt;</p>
<p>Package to perform action on</p>
<p>Source:</p>
<p><code>--path</code> &lt;<em>PATH</em>&gt;</p>
<p>Local path to the package</p>
<p><code>--git</code> &lt;<em>URI</em>&gt;</p>
<p>Git URI for the package</p>
<p><code>--branch</code> &lt;<em>BRANCH</em>&gt;</p>
<p>The branch to use</p>
<p><code>--tag</code> &lt;<em>TAG</em>&gt;</p>
<p>The tag to use</p>
<p><code>--rev</code> &lt;<em>REV</em>&gt;</p>
<p>The specific revision to use</p>
<p><code>--ipfs</code> &lt;<em>CID</em>&gt;</p>
<p>IPFS CID for the package</p>
<p>Section:</p>
<p><code>--contract-dep</code></p>
<p>Treats dependency as contract dependencies</p>
<p><code>--salt</code> &lt;<em>SALT</em>&gt;</p>
<p>Salt value for contract deployment</p>
<p><code>--offline</code></p>
<p>Offline mode.</p>
<p>Prevents Forc from using the network when managing dependencies.</p>
<p><code>--ipfs-node</code> &lt;<em>IPFS_NODE</em>&gt;</p>
<p>The IPFS Node to use for fetching IPFS sources.</p>
<p>Possible values: FUEL, PUBLIC, LOCAL, &lt;GATEWAY_URL&gt;</p>
<p>EXAMPLES:</p>
<h1 id="add-a-dependencies"><a class="header" href="#add-a-dependencies">Add a dependencies</a></h1>
<p>forc add <DEP>[@<VERSION>]</p>
<h1 id="add-a-contract-dependency"><a class="header" href="#add-a-contract-dependency">Add a contract dependency</a></h1>
<p>forc add <DEP>[@<VERSION>] --contract-dep</p>
<h1 id="dry-run"><a class="header" href="#dry-run">Dry run</a></h1>
<p>forc add <DEP>[@<VERSION>] --dry-run</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="usage-2"><a class="header" href="#usage-2">Usage:</a></h1>
<p>Arguments:</p>
<p>&lt;<em>DEP_SPEC</em>&gt;</p>
<p>..
List of dependencies to remove in the format "name[@version]"</p>
<p>Options:</p>
<p><code>--dry-run</code></p>
<p>Print the changes that would be made without actually making them</p>
<p><code>-v</code>, <code>--verbose...</code></p>
<p>Use verbose output</p>
<p><code>-s</code>, <code>--silent</code></p>
<p>Silence all output</p>
<p><code>-L</code>, <code>--log-level</code> &lt;<em>LOG_LEVEL</em>&gt;</p>
<p>Set the log level</p>
<p><code>-h</code>, <code>--help</code></p>
<p>Print help (see a summary with '-h')</p>
<p><code>-V</code>, <code>--version</code></p>
<p>Print version</p>
<p>Manifest Options:</p>
<p><code>--manisfest-path</code> &lt;<em>PATH</em>&gt;</p>
<p>Path to the manifest file</p>
<p>Package Selection:</p>
<p><code>-p</code>, <code>--package</code> &lt;<em>SPEC</em>&gt;</p>
<p>Package to perform action on</p>
<p>Section:</p>
<p><code>--contract-dep</code></p>
<p>Treats dependency as contract dependencies</p>
<p><code>--salt</code> &lt;<em>SALT</em>&gt;</p>
<p>Salt value for contract deployment</p>
<p><code>--offline</code></p>
<p>Offline mode.</p>
<p>Prevents Forc from using the network when managing dependencies.</p>
<p><code>--ipfs-node</code> &lt;<em>IPFS_NODE</em>&gt;</p>
<p>The IPFS Node to use for fetching IPFS sources.</p>
<p>Possible values: FUEL, PUBLIC, LOCAL, &lt;GATEWAY_URL&gt;</p>
<p>EXAMPLES:</p>
<h1 id="add-a-dependencies-1"><a class="header" href="#add-a-dependencies-1">Add a dependencies</a></h1>
<p>forc remove <DEP></p>
<h1 id="add-a-contract-dependency-1"><a class="header" href="#add-a-contract-dependency-1">Add a contract dependency</a></h1>
<p>forc remove <DEP> --contract-dep</p>
<h1 id="dry-run-1"><a class="header" href="#dry-run-1">Dry run</a></h1>
<p>forc remove <DEP> --dry-run</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="show"><a class="header" href="#show">Show</a></h1>
<p>Usage: forc addr2line [OPTIONS] --sourcemap-path &lt;SOURCEMAP_PATH&gt; --opcode-index &lt;OPCODE_INDEX&gt;</p>
<p>Options:</p>
<p><code>-S</code>, <code>--search-dir</code> &lt;<em>SEARCH_DIR</em>&gt;</p>
<p>Where to search for the project root [default: .]</p>
<p><code>-g</code>, <code>--sourcemap-path</code> &lt;<em>SOURCEMAP_PATH</em>&gt;</p>
<p>Source file mapping in JSON format</p>
<p><code>-c</code>, <code>--context</code> &lt;<em>CONTEXT</em>&gt;</p>
<p>How many lines of context to show [default: 2]</p>
<p><code>-i</code>, <code>--opcode-index</code> &lt;<em>OPCODE_INDEX</em>&gt;</p>
<p>Opcode index</p>
<p><code>-v</code>, <code>--verbose...</code></p>
<p>Use verbose output</p>
<p><code>-s</code>, <code>--silent</code></p>
<p>Silence all output</p>
<p><code>-L</code>, <code>--log-level</code> &lt;<em>LOG_LEVEL</em>&gt;</p>
<p>Set the log level</p>
<p><code>-h</code>, <code>--help</code></p>
<p>Print help</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="compile"><a class="header" href="#compile">Compile</a></h1>
<p>The output produced will depend on the project's program type.</p>
<ul>
<li>
<p><code>script</code>, <code>predicate</code> and <code>contract</code> projects will produce their bytecode in binary format <code>&lt;project-name&gt;.bin</code>.</p>
</li>
<li>
<p><code>script</code> projects will also produce a file containing the hash of the bytecode binary <code>&lt;project-name&gt;-bin-hash</code> (using <code>fuel_cypto::Hasher</code>).</p>
</li>
<li>
<p><code>predicate</code> projects will also produce a file containing the <strong>root</strong> hash of the bytecode binary <code>&lt;project-name&gt;-bin-root</code> (using <code>fuel_tx::Contract::root_from_code</code>).</p>
</li>
<li>
<p><code>contract</code> and <code>library</code> projects will also produce the public ABI in JSON format <code>&lt;project-name&gt;-abi.json</code>.</p>
</li>
</ul>
<p>Usage: forc build [OPTIONS]</p>
<p>Options:</p>
<p><code>-p</code>, <code>--path</code> &lt;<em>PATH</em>&gt;</p>
<p>Path to the project.</p>
<p>If not specified, current working directory will be used.</p>
<p><code>--offline</code></p>
<p>Offline mode.</p>
<p>Prevents Forc from using the network when managing dependencies. Meaning it will only try to use previously downloaded dependencies.</p>
<p><code>-t</code>, <code>--terse</code></p>
<p>Terse mode.</p>
<p>Limited warning and error output.</p>
<p><code>--output-directory</code> &lt;<em>OUTPUT_DIRECTORY</em>&gt;</p>
<p>The directory in which Forc output artifacts are placed.</p>
<p>By default, this is <code>&lt;project-root&gt;/out</code>.</p>
<p><code>--locked</code></p>
<p>Requires that the Forc.lock file is up-to-date.</p>
<p>If the lock file is missing, or it needs to be updated, Forc will exit with an error.</p>
<p><code>--ipfs-node</code> &lt;<em>IPFS_NODE</em>&gt;</p>
<p>The IPFS node to use for fetching IPFS sources.</p>
<p>[possible values: FUEL, PUBLIC, LOCAL, &lt;GATEWAY_URL&gt;]</p>
<p><code>--ast</code></p>
<p>Print the generated Sway AST (Abstract Syntax Tree)</p>
<p><code>--dca-graph</code> &lt;<em>DCA_GRAPH</em>&gt;</p>
<p>Print the computed Sway DCA (Dead Code Analysis) graph.</p>
<p>DCA graph is printed to the specified path. If specified '' graph is printed to the stdout.</p>
<p><code>--dca-graph-url-format</code> &lt;<em>DCA_GRAPH_URL_FORMAT</em>&gt;</p>
<p>URL format to be used in the generated DCA graph .dot file.</p>
<p>Variables {path}, {line}, and {col} can be used in the provided format.
An example for vscode would be:
"vscode://file/{path}:{line}:{col}"</p>
<p><code>--asm</code> &lt;<em>ASM&gt;..</em>&gt;</p>
<p>Print the generated ASM (assembler).</p>
<p>Values that can be combined:</p>
<ul>
<li>virtual:   initial ASM with virtual registers and abstract control flow.</li>
<li>allocated: ASM with registers allocated, but still with abstract control flow.</li>
<li>abstract:  short for both virtual and allocated ASM.</li>
<li>final:     final ASM that gets serialized to the target VM bytecode.</li>
<li>all:       short for virtual, allocated, and final ASM.</li>
</ul>
<p>[possible values: virtual, allocated, abstract, final, all]</p>
<p><code>--bytecode</code></p>
<p>Print the bytecode.</p>
<p>This is the final output of the compiler.</p>
<p><code>--ir</code> &lt;<em>IR&gt;..</em>&gt;</p>
<p>Print the generated Sway IR (Intermediate Representation).</p>
<p>Values that can be combined:</p>
<ul>
<li>initial:     initial IR prior to any optimization passes.</li>
<li>final:       final IR after applying all optimization passes.</li>
<li><pass name>: the name of an optimization pass. Prints the IR state after that pass.</li>
<li>all:         short for initial, final, and all the optimization passes.</li>
<li>modified:    print a requested optimization pass only if it has modified the IR.</li>
</ul>
<p>[possible values: initial, final, all, modified, inline, simplify-cfg, sroa, dce, globals-dce, fn-dedup-release, fn-dedup-debug, mem2reg, memcpyopt, const-folding, arg-demotion, const-demotion, ret-demotion, misc-demotion]</p>
<p><code>--time-phases</code></p>
<p>Output the time elapsed over each part of the compilation process</p>
<p><code>--profile</code></p>
<p>Profile the compilation process</p>
<p><code>--reverse-order</code></p>
<p>Output build errors and warnings in reverse order</p>
<p><code>--metrics-outfile</code> &lt;<em>METRICS_OUTFILE</em>&gt;</p>
<p>Output compilation metrics into the specified file</p>
<p><code>--json-abi</code></p>
<p>Minify JSON ABI files.</p>
<p>By default the JSON for ABIs is formatted for human readability. By using this option JSON output will be "minified", i.e. all on one line without whitespace.</p>
<p><code>-v</code>, <code>--verbose...</code></p>
<p>Use verbose output</p>
<p><code>--json-storage-slots</code></p>
<p>Minify JSON storage slot files.</p>
<p>By default the JSON for initial storage slots is formatted for human readability. By using this option JSON output will be "minified", i.e. all on one line without whitespace.</p>
<p><code>-s</code>, <code>--silent</code></p>
<p>Silence all output</p>
<p><code>-L</code>, <code>--log-level</code> &lt;<em>LOG_LEVEL</em>&gt;</p>
<p>Set the log level</p>
<p><code>-o</code>, <code>--output-bin</code> &lt;<em>BIN_FILE</em>&gt;</p>
<p>Create a binary file at the provided path representing the final bytecode</p>
<p><code>-g</code>, <code>--output-debug</code> &lt;<em>DEBUG_FILE</em>&gt;</p>
<p>Create a file at the provided path containing debug information.</p>
<p>If the file extension is .json, JSON format is used. Otherwise, an .elf file containing DWARF format is emitted.</p>
<p><code>--output-hexfile</code> &lt;<em>HEX_FILE</em>&gt;</p>
<p>Generates a JSON file containing the hex-encoded script binary</p>
<p><code>--build-profile</code> &lt;<em>BUILD_PROFILE</em>&gt;</p>
<p>The name of the build profile to use</p>
<p>[default: debug]</p>
<p><code>--release</code></p>
<p>Use the release build profile.</p>
<p>The release profile can be customized in the manifest file.</p>
<p><code>--error-on-warnings</code></p>
<p>Treat warnings as errors</p>
<p><code>--build-target</code> &lt;<em>BUILD_TARGET</em>&gt;</p>
<p>Build target to use for code generation</p>
<p>[default: fuel]
[possible values: fuel, evm]</p>
<p><code>--dump-impls</code> &lt;<em>TYPE</em>&gt;</p>
<p>Dump all trait implementations for the given type name</p>
<p><code>--tests</code></p>
<p>Also build all tests within the project</p>
<p><code>--experimental</code> &lt;<em>EXPERIMENTAL</em>&gt;</p>
<p>Comma separated list of all experimental features that will be enabled</p>
<p>[possible values: new_encoding, references, const_generics, new_hashing]</p>
<p><code>--no-experimental</code> &lt;<em>NO_EXPERIMENTAL</em>&gt;</p>
<p>Comma separated list of all experimental features that will be disabled</p>
<p>[possible values: new_encoding, references, const_generics, new_hashing]</p>
<p><code>-h</code>, <code>--help</code></p>
<p>Print help (see a summary with '-h')</p>
<p><code>-V</code>, <code>--version</code></p>
<p>Print version</p>
<p>EXAMPLES:</p>
<h1 id="compile-the-current-projectx"><a class="header" href="#compile-the-current-projectx">Compile the current projectx</a></h1>
<p>forc build</p>
<h1 id="compile-the-current-project-from-a-different-path"><a class="header" href="#compile-the-current-project-from-a-different-path">Compile the current project from a different path</a></h1>
<p>forc build --path <PATH></p>
<h1 id="compile-the-current-project-without-updating-dependencies"><a class="header" href="#compile-the-current-project-without-updating-dependencies">Compile the current project without updating dependencies</a></h1>
<p>forc build --path <PATH> --locked<!-- markdownlint-disable MD041 --></p>
<h2 id="example-3"><a class="header" href="#example-3">EXAMPLE</a></h2>
<p>Compile the sway files of the current project.</p>
<pre><code class="language-console">$ forc build
Compiled script "my-fuel-project".
Bytecode size is 28 bytes.
</code></pre>
<p>The output produced will depend on the project's program type. Building script, predicate and contract projects will produce their bytecode in binary format <code>&lt;project-name&gt;.bin</code>. Building contracts and libraries will also produce the public ABI in JSON format <code>&lt;project-name&gt;-abi.json</code>.</p>
<p>By default, these artifacts are placed in the <code>out/</code> directory.</p>
<p>If a <code>Forc.lock</code> file did not yet exist, it will be created in order to pin each of the dependencies listed in <code>Forc.toml</code> to a specific commit or version.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="check"><a class="header" href="#check">Check</a></h1>
<p>This will essentially compile the packages without performing the final step of code generation, which is faster than running forc build.</p>
<p>Usage: forc check [OPTIONS] [BUILD_TARGET]</p>
<p>Arguments:
[BUILD_TARGET]
Build target to use for code generation</p>
<p>[default: fuel]
[possible values: fuel, evm]</p>
<p>Options:</p>
<p><code>-p</code>, <code>--path</code> &lt;<em>PATH</em>&gt;</p>
<p>Path to the project, if not specified, current working directory will be used</p>
<p><code>--offline</code></p>
<p>Offline mode, prevents Forc from using the network when managing dependencies. Meaning it will only try to use previously downloaded dependencies</p>
<p><code>--locked</code></p>
<p>Requires that the Forc.lock file is up-to-date. If the lock file is missing, or it needs to be updated, Forc will exit with an error</p>
<p><code>-t</code>, <code>--terse</code></p>
<p>Terse mode. Limited warning and error output</p>
<p><code>--disable-tests</code></p>
<p>Disable checking unit tests</p>
<p><code>--ipfs-node</code> &lt;<em>IPFS_NODE</em>&gt;</p>
<p>The IPFS Node to use for fetching IPFS sources.</p>
<p>Possible values: FUEL, PUBLIC, LOCAL, &lt;GATEWAY_URL&gt;</p>
<p><code>--dump-impls</code> &lt;<em>TYPE</em>&gt;</p>
<p>Dump all trait implementations for the given type name</p>
<p><code>--experimental</code> &lt;<em>EXPERIMENTAL</em>&gt;</p>
<p>Comma separated list of all experimental features that will be enabled</p>
<p>[possible values: new_encoding, references, const_generics, new_hashing]</p>
<p><code>--no-experimental</code> &lt;<em>NO_EXPERIMENTAL</em>&gt;</p>
<p>Comma separated list of all experimental features that will be disabled</p>
<p>[possible values: new_encoding, references, const_generics, new_hashing]</p>
<p><code>-v</code>, <code>--verbose...</code></p>
<p>Use verbose output</p>
<p><code>-s</code>, <code>--silent</code></p>
<p>Silence all output</p>
<p><code>-L</code>, <code>--log-level</code> &lt;<em>LOG_LEVEL</em>&gt;</p>
<p>Set the log level</p>
<p><code>-h</code>, <code>--help</code></p>
<p>Print help (see a summary with '-h')</p>
<p><code>-V</code>, <code>--version</code></p>
<p>Print version</p>
<p>EXAMPLES:</p>
<h1 id="check-the-current-project"><a class="header" href="#check-the-current-project">Check the current project</a></h1>
<p>forc check</p>
<h1 id="check-the-current-project-with-a-different-path"><a class="header" href="#check-the-current-project-with-a-different-path">Check the current project with a different path</a></h1>
<p>forc check --path <PATH></p>
<h1 id="check-the-current-project-without-updating-dependencies"><a class="header" href="#check-the-current-project-without-updating-dependencies">Check the current project without updating dependencies</a></h1>
<p>forc check --locked</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="removes"><a class="header" href="#removes">Removes</a></h1>
<p>Usage: forc clean [OPTIONS]</p>
<p>Options:</p>
<p><code>-p</code>, <code>--path</code> &lt;<em>PATH</em>&gt;</p>
<p>Path to the project, if not specified, current working directory will be used</p>
<p><code>-v</code>, <code>--verbose...</code></p>
<p>Use verbose output</p>
<p><code>-s</code>, <code>--silent</code></p>
<p>Silence all output</p>
<p><code>-L</code>, <code>--log-level</code> &lt;<em>LOG_LEVEL</em>&gt;</p>
<p>Set the log level</p>
<p><code>-h</code>, <code>--help</code></p>
<p>Print help</p>
<p><code>-V</code>, <code>--version</code></p>
<p>Print version</p>
<p>EXAMPLES:</p>
<h1 id="clean-project"><a class="header" href="#clean-project">Clean project</a></h1>
<p>forc clean</p>
<h1 id="clean-project-with-a-custom-path"><a class="header" href="#clean-project-with-a-custom-path">Clean project with a custom path</a></h1>
<p>forc clean --path <PATH></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="generate"><a class="header" href="#generate">Generate</a></h1>
<p>Usage: forc completions [OPTIONS] --target <TARGET></p>
<p>Options:</p>
<p><code>-T</code>, <code>--target</code> &lt;<em>TARGET</em>&gt;</p>
<p>Specify shell to enable tab-completion for</p>
<p>[possible values: zsh, bash, fish, powershell, elvish]</p>
<p>For more info: https://fuellabs.github.io/sway/latest/forc/commands/forc_completions.html</p>
<p>Possible values:</p>
<ul>
<li>bash:        Bourne Again Shell (bash)</li>
<li>elvish:      Elvish shell</li>
<li>fish:        Friendly Interactive Shell (fish)</li>
<li>power-shell: PowerShell</li>
<li>zsh:         Z Shell (zsh)</li>
<li>fig:         Fig</li>
</ul>
<p><code>-v</code>, <code>--verbose...</code></p>
<p>Use verbose output</p>
<p><code>-s</code>, <code>--silent</code></p>
<p>Silence all output</p>
<p><code>-L</code>, <code>--log-level</code> &lt;<em>LOG_LEVEL</em>&gt;</p>
<p>Set the log level</p>
<p><code>-h</code>, <code>--help</code></p>
<p>Print help (see a summary with '-h')<!-- markdownlint-disable MD041 --></p>
<h2 id="discussion"><a class="header" href="#discussion">DISCUSSION</a></h2>
<p>Enable tab completion for Bash, Fish, Zsh, or PowerShell
The script is output on <code>stdout</code>, allowing one to re-direct the
output to the file of their choosing. Where you place the file
will depend on which shell, and which operating system you are
using. Your particular configuration may also determine where
these scripts need to be placed.</p>
<p>Here are some common set ups for the three supported shells under
Unix and similar operating systems (such as GNU/Linux).</p>
<h3 id="bash"><a class="header" href="#bash">BASH</a></h3>
<p>Completion files are commonly stored in <code>/etc/bash_completion.d/</code> for
system-wide commands, but can be stored in
<code>~/.local/share/bash-completion/completions</code> for user-specific commands.
Run the command:</p>
<pre><code class="language-sh">mkdir -p ~/.local/share/bash-completion/completions
forc completions --shell=bash &gt;&gt; ~/.local/share/bash-completion/completions/forc
</code></pre>
<p>This installs the completion script. You may have to log out and
log back in to your shell session for the changes to take effect.</p>
<h3 id="bash-macoshomebrew"><a class="header" href="#bash-macoshomebrew">BASH (macOS/Homebrew)</a></h3>
<p>Homebrew stores bash completion files within the Homebrew directory.
With the <code>bash-completion</code> brew formula installed, run the command:</p>
<pre><code class="language-sh">mkdir -p $(brew --prefix)/etc/bash_completion.d
forc completions --shell=bash &gt; $(brew --prefix)/etc/bash_completion.d/forc.bash-completion
</code></pre>
<h3 id="fish"><a class="header" href="#fish">FISH</a></h3>
<p>Fish completion files are commonly stored in
<code>$HOME/.config/fish/completions</code>. Run the command:</p>
<pre><code class="language-sh">mkdir -p ~/.config/fish/completions
forc completions --shell=fish &gt; ~/.config/fish/completions/forc.fish
</code></pre>
<p>This installs the completion script. You may have to log out and
log back in to your shell session for the changes to take effect.</p>
<h3 id="zsh"><a class="header" href="#zsh">ZSH</a></h3>
<p>ZSH completions are commonly stored in any directory listed in
your <code>$fpath</code> variable. To use these completions, you must either
add the generated script to one of those directories, or add your
own to this list.</p>
<p>Adding a custom directory is often the safest bet if you are
unsure of which directory to use. First create the directory; for
this example we'll create a hidden directory inside our <code>$HOME</code>
directory:</p>
<pre><code class="language-sh">mkdir ~/.zfunc
</code></pre>
<p>Then add the following lines to your <code>.zshrc</code> just before
<code>compinit</code>:</p>
<pre><code class="language-sh">fpath+=~/.zfunc
</code></pre>
<p>Now you can install the completions script using the following
command:</p>
<pre><code class="language-sh">forc completions --shell=zsh &gt; ~/.zfunc/_forc
</code></pre>
<p>You must then either log out and log back in, or simply run</p>
<pre><code class="language-sh">exec zsh
</code></pre>
<p>for the new completions to take effect.</p>
<h3 id="custom-locations"><a class="header" href="#custom-locations">CUSTOM LOCATIONS</a></h3>
<p>Alternatively, you could save these files to the place of your
choosing, such as a custom directory inside your $HOME. Doing so
will require you to add the proper directives, such as <code>source</code>ing
inside your login script. Consult your shells documentation for
how to add such directives.</p>
<h3 id="powershell"><a class="header" href="#powershell">POWERSHELL</a></h3>
<p>The powershell completion scripts require PowerShell v5.0+ (which
comes with Windows 10, but can be downloaded separately for windows 7
or 8.1).</p>
<p>First, check if a profile has already been set</p>
<pre><code class="language-sh">Test-Path $profile
</code></pre>
<p>If the above command returns <code>False</code> run the following</p>
<pre><code class="language-sh">New-Item -path $profile -type file -force
</code></pre>
<p>Now open the file provided by <code>$profile</code> (if you used the
<code>New-Item</code> command it will be
<code>${env:USERPROFILE}\Documents\WindowsPowerShell\Microsoft.PowerShell_profile.ps1</code></p>
<p>Next, we either save the completions file into our profile, or
into a separate file and source it inside our profile. To save the
completions into our profile simply use</p>
<pre><code class="language-sh">forc completions --shell=powershell &gt;&gt; ${env:USERPROFILE}\Documents\WindowsPowerShell\Microsoft.PowerShell_profile.ps1
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="determine"><a class="header" href="#determine">Determine</a></h1>
<p>Usage: forc contract-id [OPTIONS]</p>
<p>Options:</p>
<p><code>-p</code>, <code>--path</code> &lt;<em>PATH</em>&gt;</p>
<p>Path to the project.</p>
<p>If not specified, current working directory will be used.</p>
<p><code>--offline</code></p>
<p>Offline mode.</p>
<p>Prevents Forc from using the network when managing dependencies. Meaning it will only try to use previously downloaded dependencies.</p>
<p><code>-t</code>, <code>--terse</code></p>
<p>Terse mode.</p>
<p>Limited warning and error output.</p>
<p><code>--output-directory</code> &lt;<em>OUTPUT_DIRECTORY</em>&gt;</p>
<p>The directory in which Forc output artifacts are placed.</p>
<p>By default, this is <code>&lt;project-root&gt;/out</code>.</p>
<p><code>--locked</code></p>
<p>Requires that the Forc.lock file is up-to-date.</p>
<p>If the lock file is missing, or it needs to be updated, Forc will exit with an error.</p>
<p><code>--ipfs-node</code> &lt;<em>IPFS_NODE</em>&gt;</p>
<p>The IPFS node to use for fetching IPFS sources.</p>
<p>[possible values: FUEL, PUBLIC, LOCAL, &lt;GATEWAY_URL&gt;]</p>
<p><code>--json-abi</code></p>
<p>Minify JSON ABI files.</p>
<p>By default the JSON for ABIs is formatted for human readability. By using this option JSON output will be "minified", i.e. all on one line without whitespace.</p>
<p><code>--json-storage-slots</code></p>
<p>Minify JSON storage slot files.</p>
<p>By default the JSON for initial storage slots is formatted for human readability. By using this option JSON output will be "minified", i.e. all on one line without whitespace.</p>
<p><code>--ast</code></p>
<p>Print the generated Sway AST (Abstract Syntax Tree)</p>
<p><code>--dca-graph</code> &lt;<em>DCA_GRAPH</em>&gt;</p>
<p>Print the computed Sway DCA (Dead Code Analysis) graph.</p>
<p>DCA graph is printed to the specified path. If specified '' graph is printed to the stdout.</p>
<p><code>--dca-graph-url-format</code> &lt;<em>DCA_GRAPH_URL_FORMAT</em>&gt;</p>
<p>URL format to be used in the generated DCA graph .dot file.</p>
<p>Variables {path}, {line}, and {col} can be used in the provided format.
An example for vscode would be:
"vscode://file/{path}:{line}:{col}"</p>
<p><code>--asm</code> &lt;<em>ASM&gt;..</em>&gt;</p>
<p>Print the generated ASM (assembler).</p>
<p>Values that can be combined:</p>
<ul>
<li>virtual:   initial ASM with virtual registers and abstract control flow.</li>
<li>allocated: ASM with registers allocated, but still with abstract control flow.</li>
<li>abstract:  short for both virtual and allocated ASM.</li>
<li>final:     final ASM that gets serialized to the target VM bytecode.</li>
<li>all:       short for virtual, allocated, and final ASM.</li>
</ul>
<p>[possible values: virtual, allocated, abstract, final, all]</p>
<p><code>--bytecode</code></p>
<p>Print the bytecode.</p>
<p>This is the final output of the compiler.</p>
<p><code>--ir</code> &lt;<em>IR&gt;..</em>&gt;</p>
<p>Print the generated Sway IR (Intermediate Representation).</p>
<p>Values that can be combined:</p>
<ul>
<li>initial:     initial IR prior to any optimization passes.</li>
<li>final:       final IR after applying all optimization passes.</li>
<li><pass name>: the name of an optimization pass. Prints the IR state after that pass.</li>
<li>all:         short for initial, final, and all the optimization passes.</li>
<li>modified:    print a requested optimization pass only if it has modified the IR.</li>
</ul>
<p>[possible values: initial, final, all, modified, inline, simplify-cfg, sroa, dce, globals-dce, fn-dedup-release, fn-dedup-debug, mem2reg, memcpyopt, const-folding, arg-demotion, const-demotion, ret-demotion, misc-demotion]</p>
<p><code>--time-phases</code></p>
<p>Output the time elapsed over each part of the compilation process</p>
<p><code>--profile</code></p>
<p>Profile the compilation process</p>
<p><code>--reverse-order</code></p>
<p>Output build errors and warnings in reverse order</p>
<p><code>-v</code>, <code>--verbose...</code></p>
<p>Use verbose output</p>
<p><code>--metrics-outfile</code> &lt;<em>METRICS_OUTFILE</em>&gt;</p>
<p>Output compilation metrics into the specified file</p>
<p><code>-s</code>, <code>--silent</code></p>
<p>Silence all output</p>
<p><code>-L</code>, <code>--log-level</code> &lt;<em>LOG_LEVEL</em>&gt;</p>
<p>Set the log level</p>
<p><code>-o</code>, <code>--output-bin</code> &lt;<em>BIN_FILE</em>&gt;</p>
<p>Create a binary file at the provided path representing the final bytecode</p>
<p><code>-g</code>, <code>--output-debug</code> &lt;<em>DEBUG_FILE</em>&gt;</p>
<p>Create a file at the provided path containing debug information.</p>
<p>If the file extension is .json, JSON format is used. Otherwise, an .elf file containing DWARF format is emitted.</p>
<p><code>--output-hexfile</code> &lt;<em>HEX_FILE</em>&gt;</p>
<p>Generates a JSON file containing the hex-encoded script binary</p>
<p><code>--build-profile</code> &lt;<em>BUILD_PROFILE</em>&gt;</p>
<p>The name of the build profile to use</p>
<p>[default: debug]</p>
<p><code>--release</code></p>
<p>Use the release build profile.</p>
<p>The release profile can be customized in the manifest file.</p>
<p><code>--error-on-warnings</code></p>
<p>Treat warnings as errors</p>
<p><code>--salt</code> &lt;<em>SALT</em>&gt;</p>
<p>Added salt used to derive the contract ID.</p>
<p>By default, this is <code>0x0000000000000000000000000000000000000000000000000000000000000000</code>.</p>
<p><code>--experimental</code> &lt;<em>EXPERIMENTAL</em>&gt;</p>
<p>Comma separated list of all experimental features that will be enabled</p>
<p>[possible values: new_encoding, references, const_generics, new_hashing]</p>
<p><code>--no-experimental</code> &lt;<em>NO_EXPERIMENTAL</em>&gt;</p>
<p>Comma separated list of all experimental features that will be disabled</p>
<p>[possible values: new_encoding, references, const_generics, new_hashing]</p>
<p><code>-h</code>, <code>--help</code></p>
<p>Print help (see a summary with '-h')</p>
<p><code>-V</code>, <code>--version</code></p>
<p>Print version</p>
<p>EXAMPLES:</p>
<h1 id="get-contract-id"><a class="header" href="#get-contract-id">Get contract id</a></h1>
<p>forc contract-id</p>
<h1 id="get-contract-id-from-a-different-path"><a class="header" href="#get-contract-id-from-a-different-path">Get contract id from a different path</a></h1>
<p>forc contract-id --path <PATH></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="create"><a class="header" href="#create">Create</a></h1>
<p>Usage: forc init [OPTIONS]</p>
<p>Options:</p>
<p><code>--path</code> &lt;<em>PATH</em>&gt;</p>
<p>The directory in which the forc project will be initialized</p>
<p><code>--contract</code></p>
<p>The default program type, excluding all flags or adding this flag creates a basic contract program</p>
<p><code>--script</code></p>
<p>Create a package with a script target (src/main.sw)</p>
<p><code>--predicate</code></p>
<p>Create a package with a predicate target (src/predicate.rs)</p>
<p><code>--library</code></p>
<p>Create a package with a library target (src/lib.sw)</p>
<p><code>--workspace</code></p>
<p>Adding this flag creates an empty workspace</p>
<p><code>--name</code> &lt;<em>NAME</em>&gt;</p>
<p>Set the package name. Defaults to the directory name</p>
<p><code>-v</code>, <code>--verbose...</code></p>
<p>Use verbose output</p>
<p><code>-s</code>, <code>--silent</code></p>
<p>Silence all output</p>
<p><code>-L</code>, <code>--log-level</code> &lt;<em>LOG_LEVEL</em>&gt;</p>
<p>Set the log level</p>
<p><code>-h</code>, <code>--help</code></p>
<p>Print help</p>
<p><code>-V</code>, <code>--version</code></p>
<p>Print version</p>
<p>EXAMPLES:</p>
<h1 id="initialize-a-new-forc-project"><a class="header" href="#initialize-a-new-forc-project">Initialize a new Forc project</a></h1>
<p>forc init --path <PATH></p>
<h1 id="initialize-a-new-forc-project-as-workspace"><a class="header" href="#initialize-a-new-forc-project-as-workspace">Initialize a new Forc project as workspace</a></h1>
<p>forc init --path <PATH> --workspace</p>
<h1 id="initialize-a-new-forc-project-with-a-predicate"><a class="header" href="#initialize-a-new-forc-project-with-a-predicate">Initialize a new Forc project with a predicate</a></h1>
<p>forc init --path <PATH> --predicate</p>
<h1 id="initialize-a-new-forc-library-project"><a class="header" href="#initialize-a-new-forc-library-project">Initialize a new Forc library project</a></h1>
<p>forc init --path <PATH> --library<!-- markdownlint-disable MD041 --></p>
<h2 id="example-4"><a class="header" href="#example-4">EXAMPLE</a></h2>
<pre><code class="language-console">$ mkdir my-fuel-project
$ cd my-fuel-project
$ forc init
$ tree
.
â”œâ”€â”€ Forc.toml
â””â”€â”€ src
    â””â”€â”€ main.sw
</code></pre>
<p><code>Forc.toml</code> is the Forc manifest file, containing information about the project and dependencies.</p>
<p>A <code>src/</code> directory is created, with a single <code>main.sw</code> Sway file in it.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="create-1"><a class="header" href="#create-1">Create</a></h1>
<p>Usage: forc new [OPTIONS] <PATH></p>
<p>Arguments:</p>
<p>&lt;<em>PATH</em>&gt;</p>
<p>The path at which the project directory will be created</p>
<p>Options:</p>
<p><code>--contract</code></p>
<p>The default program type. Excluding all flags or adding this flag creates a basic contract program</p>
<p><code>--script</code></p>
<p>Adding this flag creates an empty script program</p>
<p><code>--predicate</code></p>
<p>Adding this flag creates an empty predicate program</p>
<p><code>--library</code></p>
<p>Adding this flag creates an empty library program</p>
<p><code>--workspace</code></p>
<p>Adding this flag creates an empty workspace</p>
<p><code>--name</code> &lt;<em>NAME</em>&gt;</p>
<p>Set the package name. Defaults to the directory name</p>
<p><code>-v</code>, <code>--verbose...</code></p>
<p>Use verbose output</p>
<p><code>-s</code>, <code>--silent</code></p>
<p>Silence all output</p>
<p><code>-L</code>, <code>--log-level</code> &lt;<em>LOG_LEVEL</em>&gt;</p>
<p>Set the log level</p>
<p><code>-h</code>, <code>--help</code></p>
<p>Print help</p>
<p><code>-V</code>, <code>--version</code></p>
<p>Print version</p>
<p>EXAMPLES:</p>
<h1 id="create-a-new-project"><a class="header" href="#create-a-new-project">Create a new project</a></h1>
<p>forc new --contract --name my_project <PATH></p>
<h1 id="create-a-new-workspace"><a class="header" href="#create-a-new-workspace">Create a new workspace</a></h1>
<p>forc new --workspace --name my_workspace <PATH></p>
<h1 id="create-a-new-forc-project-with-a-predicate"><a class="header" href="#create-a-new-forc-project-with-a-predicate">Create a new Forc project with a predicate</a></h1>
<p>forc new <PATH> --predicate</p>
<h1 id="create-a-new-forc-library-project"><a class="header" href="#create-a-new-forc-library-project">Create a new Forc library project</a></h1>
<p>forc new <PATH> --library<!-- markdownlint-disable MD041 --></p>
<h2 id="example-5"><a class="header" href="#example-5">EXAMPLE</a></h2>
<pre><code class="language-console">$ forc new my-fuel-project
$ cd my-fuel-project
$ tree
.
â”œâ”€â”€ Forc.toml
â””â”€â”€ src
    â””â”€â”€ main.sw
</code></pre>
<p><code>Forc.toml</code> is the Forc manifest file, containing information about the project and dependencies.</p>
<p>A <code>src/</code> directory is created, with a single <code>main.sw</code> Sway file in it.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="parse"><a class="header" href="#parse">Parse</a></h1>
<p>Usage: forc parse-bytecode [OPTIONS] &lt;FILE_PATH&gt;</p>
<p>Arguments:</p>
<p>&lt;<em>FILE_PATH</em>&gt;</p>
<p>Options:</p>
<p><code>-v</code>, <code>--verbose...</code></p>
<p>Use verbose output</p>
<p><code>-s</code>, <code>--silent</code></p>
<p>Silence all output</p>
<p><code>-L</code>, <code>--log-level</code> &lt;<em>LOG_LEVEL</em>&gt;</p>
<p>Set the log level</p>
<p><code>-h</code>, <code>--help</code></p>
<p>Print help</p>
<p><code>-V</code>, <code>--version</code></p>
<p>Print version</p>
<p>EXAMPLES:</p>
<h1 id="parse-bytecode"><a class="header" href="#parse-bytecode">Parse bytecode</a></h1>
<p>forc parse-bytecode <PATH><!-- markdownlint-disable MD041 --></p>
<h2 id="example-6"><a class="header" href="#example-6">EXAMPLE</a></h2>
<p>We can try this command with the initial project created using <code>forc init</code>, with the counter template:</p>
<pre><code class="language-sh">forc new --template counter counter
cd counter
forc build -o obj
</code></pre>
<pre><code class="language-console">counter$ forc parse-bytecode obj

  half-word   byte   op                   raw           notes
          0   0      JI(4)                90 00 00 04   conditionally jumps to byte 16
          1   4      NOOP                 47 00 00 00
          2   8      Undefined            00 00 00 00   data section offset lo (0)
          3   12     Undefined            00 00 00 c8   data section offset hi (200)
          4   16     LW(63, 12, 1)        5d fc c0 01
          5   20     ADD(63, 63, 12)      10 ff f3 00
         ...
         ...
         ...
         60   240    Undefined            00 00 00 00
         61   244    Undefined            fa f9 0d d3
         62   248    Undefined            00 00 00 00
         63   252    Undefined            00 00 00 c8
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="find"><a class="header" href="#find">Find</a></h1>
<p>Prints information about each discovered plugin.</p>
<p>Usage: forc plugins [OPTIONS]</p>
<p>Options:</p>
<p><code>-p</code>, <code>--paths</code></p>
<p>Prints the absolute path to each discovered plugin</p>
<p><code>-d</code>, <code>--describe</code></p>
<p>Prints the long description associated with each listed plugin</p>
<p><code>-v</code>, <code>--verbose...</code></p>
<p>Use verbose output</p>
<p><code>-s</code>, <code>--silent</code></p>
<p>Silence all output</p>
<p><code>-L</code>, <code>--log-level</code> &lt;<em>LOG_LEVEL</em>&gt;</p>
<p>Set the log level</p>
<p><code>-h</code>, <code>--help</code></p>
<p>Print help (see a summary with '-h')</p>
<p><code>-V</code>, <code>--version</code></p>
<p>Print version</p>
<p>EXAMPLES:</p>
<h1 id="list-all-plugins"><a class="header" href="#list-all-plugins">List all plugins</a></h1>
<p>forc plugins</p>
<h1 id="list-all-plugins-with-their-paths"><a class="header" href="#list-all-plugins-with-their-paths">List all plugins with their paths</a></h1>
<p>forc plugins --paths</p>
<h1 id="list-all-plugins-with-their-descriptions"><a class="header" href="#list-all-plugins-with-their-descriptions">List all plugins with their descriptions</a></h1>
<p>forc plugins --describe</p>
<h1 id="list-all-plugins-with-their-paths-and-descriptions"><a class="header" href="#list-all-plugins-with-their-paths-and-descriptions">List all plugins with their paths and descriptions</a></h1>
<p>forc plugins --paths --describe</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="determine-1"><a class="header" href="#determine-1">Determine</a></h1>
<p>Usage: forc predicate-root [OPTIONS]</p>
<p>Options:</p>
<p><code>-p</code>, <code>--path</code> &lt;<em>PATH</em>&gt;</p>
<p>Path to the project.</p>
<p>If not specified, current working directory will be used.</p>
<p><code>--offline</code></p>
<p>Offline mode.</p>
<p>Prevents Forc from using the network when managing dependencies. Meaning it will only try to use previously downloaded dependencies.</p>
<p><code>-t</code>, <code>--terse</code></p>
<p>Terse mode.</p>
<p>Limited warning and error output.</p>
<p><code>--output-directory</code> &lt;<em>OUTPUT_DIRECTORY</em>&gt;</p>
<p>The directory in which Forc output artifacts are placed.</p>
<p>By default, this is <code>&lt;project-root&gt;/out</code>.</p>
<p><code>--locked</code></p>
<p>Requires that the Forc.lock file is up-to-date.</p>
<p>If the lock file is missing, or it needs to be updated, Forc will exit with an error.</p>
<p><code>--ipfs-node</code> &lt;<em>IPFS_NODE</em>&gt;</p>
<p>The IPFS node to use for fetching IPFS sources.</p>
<p>[possible values: FUEL, PUBLIC, LOCAL, &lt;GATEWAY_URL&gt;]</p>
<p><code>--json-abi</code></p>
<p>Minify JSON ABI files.</p>
<p>By default the JSON for ABIs is formatted for human readability. By using this option JSON output will be "minified", i.e. all on one line without whitespace.</p>
<p><code>--json-storage-slots</code></p>
<p>Minify JSON storage slot files.</p>
<p>By default the JSON for initial storage slots is formatted for human readability. By using this option JSON output will be "minified", i.e. all on one line without whitespace.</p>
<p><code>--ast</code></p>
<p>Print the generated Sway AST (Abstract Syntax Tree)</p>
<p><code>--dca-graph</code> &lt;<em>DCA_GRAPH</em>&gt;</p>
<p>Print the computed Sway DCA (Dead Code Analysis) graph.</p>
<p>DCA graph is printed to the specified path. If specified '' graph is printed to the stdout.</p>
<p><code>--dca-graph-url-format</code> &lt;<em>DCA_GRAPH_URL_FORMAT</em>&gt;</p>
<p>URL format to be used in the generated DCA graph .dot file.</p>
<p>Variables {path}, {line}, and {col} can be used in the provided format.
An example for vscode would be:
"vscode://file/{path}:{line}:{col}"</p>
<p><code>--asm</code> &lt;<em>ASM&gt;..</em>&gt;</p>
<p>Print the generated ASM (assembler).</p>
<p>Values that can be combined:</p>
<ul>
<li>virtual:   initial ASM with virtual registers and abstract control flow.</li>
<li>allocated: ASM with registers allocated, but still with abstract control flow.</li>
<li>abstract:  short for both virtual and allocated ASM.</li>
<li>final:     final ASM that gets serialized to the target VM bytecode.</li>
<li>all:       short for virtual, allocated, and final ASM.</li>
</ul>
<p>[possible values: virtual, allocated, abstract, final, all]</p>
<p><code>--bytecode</code></p>
<p>Print the bytecode.</p>
<p>This is the final output of the compiler.</p>
<p><code>--ir</code> &lt;<em>IR&gt;..</em>&gt;</p>
<p>Print the generated Sway IR (Intermediate Representation).</p>
<p>Values that can be combined:</p>
<ul>
<li>initial:     initial IR prior to any optimization passes.</li>
<li>final:       final IR after applying all optimization passes.</li>
<li><pass name>: the name of an optimization pass. Prints the IR state after that pass.</li>
<li>all:         short for initial, final, and all the optimization passes.</li>
<li>modified:    print a requested optimization pass only if it has modified the IR.</li>
</ul>
<p>[possible values: initial, final, all, modified, inline, simplify-cfg, sroa, dce, globals-dce, fn-dedup-release, fn-dedup-debug, mem2reg, memcpyopt, const-folding, arg-demotion, const-demotion, ret-demotion, misc-demotion]</p>
<p><code>--time-phases</code></p>
<p>Output the time elapsed over each part of the compilation process</p>
<p><code>--profile</code></p>
<p>Profile the compilation process</p>
<p><code>--reverse-order</code></p>
<p>Output build errors and warnings in reverse order</p>
<p><code>-v</code>, <code>--verbose...</code></p>
<p>Use verbose output</p>
<p><code>--metrics-outfile</code> &lt;<em>METRICS_OUTFILE</em>&gt;</p>
<p>Output compilation metrics into the specified file</p>
<p><code>-s</code>, <code>--silent</code></p>
<p>Silence all output</p>
<p><code>-L</code>, <code>--log-level</code> &lt;<em>LOG_LEVEL</em>&gt;</p>
<p>Set the log level</p>
<p><code>-o</code>, <code>--output-bin</code> &lt;<em>BIN_FILE</em>&gt;</p>
<p>Create a binary file at the provided path representing the final bytecode</p>
<p><code>-g</code>, <code>--output-debug</code> &lt;<em>DEBUG_FILE</em>&gt;</p>
<p>Create a file at the provided path containing debug information.</p>
<p>If the file extension is .json, JSON format is used. Otherwise, an .elf file containing DWARF format is emitted.</p>
<p><code>--output-hexfile</code> &lt;<em>HEX_FILE</em>&gt;</p>
<p>Generates a JSON file containing the hex-encoded script binary</p>
<p><code>--build-profile</code> &lt;<em>BUILD_PROFILE</em>&gt;</p>
<p>The name of the build profile to use</p>
<p>[default: debug]</p>
<p><code>--release</code></p>
<p>Use the release build profile.</p>
<p>The release profile can be customized in the manifest file.</p>
<p><code>--error-on-warnings</code></p>
<p>Treat warnings as errors</p>
<p><code>--experimental</code> &lt;<em>EXPERIMENTAL</em>&gt;</p>
<p>Comma separated list of all experimental features that will be enabled</p>
<p>[possible values: new_encoding, references, const_generics, new_hashing]</p>
<p><code>--no-experimental</code> &lt;<em>NO_EXPERIMENTAL</em>&gt;</p>
<p>Comma separated list of all experimental features that will be disabled</p>
<p>[possible values: new_encoding, references, const_generics, new_hashing]</p>
<p><code>-h</code>, <code>--help</code></p>
<p>Print help (see a summary with '-h')</p>
<p><code>-V</code>, <code>--version</code></p>
<p>Print version</p>
<p>EXAMPLES:</p>
<h1 id="get-predicate-root"><a class="header" href="#get-predicate-root">Get predicate root</a></h1>
<p>forc predicate-root</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="run-1"><a class="header" href="#run-1">Run</a></h1>
<p>NOTE: Previously this command was used to support Rust integration testing, however the provided behaviour served no benefit over running <code>cargo test</code> directly. The proposal to change the behaviour to support unit testing can be found at the following link: https://github.com/FuelLabs/sway/issues/1833</p>
<p>Sway unit tests are functions decorated with the <code>#[test]</code> attribute. Each test is compiled as a unique entry point for a single program and has access to the namespace of the module in which it is declared.</p>
<p>Unit tests decorated with the <code>#[test(script)]</code> attribute that are declared within <code>contract</code> projects may also call directly into their associated contract's ABI.</p>
<p>Upon successful compilation, test scripts are executed to their completion. A test is considered a failure in the case that a revert (<code>rvrt</code>) instruction is encountered during execution. Otherwise, it is considered a success.</p>
<p>Usage: forc test [OPTIONS] [FILTER]</p>
<p>Arguments:
[FILTER]
When specified, only tests containing the given string will be executed</p>
<p>Options:</p>
<p><code>-p</code>, <code>--path</code> &lt;<em>PATH</em>&gt;</p>
<p>Path to the project.</p>
<p>If not specified, current working directory will be used.</p>
<p><code>--offline</code></p>
<p>Offline mode.</p>
<p>Prevents Forc from using the network when managing dependencies. Meaning it will only try to use previously downloaded dependencies.</p>
<p><code>-t</code>, <code>--terse</code></p>
<p>Terse mode.</p>
<p>Limited warning and error output.</p>
<p><code>--output-directory</code> &lt;<em>OUTPUT_DIRECTORY</em>&gt;</p>
<p>The directory in which Forc output artifacts are placed.</p>
<p>By default, this is <code>&lt;project-root&gt;/out</code>.</p>
<p><code>--locked</code></p>
<p>Requires that the Forc.lock file is up-to-date.</p>
<p>If the lock file is missing, or it needs to be updated, Forc will exit with an error.</p>
<p><code>--ipfs-node</code> &lt;<em>IPFS_NODE</em>&gt;</p>
<p>The IPFS node to use for fetching IPFS sources.</p>
<p>[possible values: FUEL, PUBLIC, LOCAL, &lt;GATEWAY_URL&gt;]</p>
<p><code>--ast</code></p>
<p>Print the generated Sway AST (Abstract Syntax Tree)</p>
<p><code>--dca-graph</code> &lt;<em>DCA_GRAPH</em>&gt;</p>
<p>Print the computed Sway DCA (Dead Code Analysis) graph.</p>
<p>DCA graph is printed to the specified path. If specified '' graph is printed to the stdout.</p>
<p><code>--dca-graph-url-format</code> &lt;<em>DCA_GRAPH_URL_FORMAT</em>&gt;</p>
<p>URL format to be used in the generated DCA graph .dot file.</p>
<p>Variables {path}, {line}, and {col} can be used in the provided format.
An example for vscode would be:
"vscode://file/{path}:{line}:{col}"</p>
<p><code>--asm</code> &lt;<em>ASM&gt;..</em>&gt;</p>
<p>Print the generated ASM (assembler).</p>
<p>Values that can be combined:</p>
<ul>
<li>virtual:   initial ASM with virtual registers and abstract control flow.</li>
<li>allocated: ASM with registers allocated, but still with abstract control flow.</li>
<li>abstract:  short for both virtual and allocated ASM.</li>
<li>final:     final ASM that gets serialized to the target VM bytecode.</li>
<li>all:       short for virtual, allocated, and final ASM.</li>
</ul>
<p>[possible values: virtual, allocated, abstract, final, all]</p>
<p><code>--bytecode</code></p>
<p>Print the bytecode.</p>
<p>This is the final output of the compiler.</p>
<p><code>--ir</code> &lt;<em>IR&gt;..</em>&gt;</p>
<p>Print the generated Sway IR (Intermediate Representation).</p>
<p>Values that can be combined:</p>
<ul>
<li>initial:     initial IR prior to any optimization passes.</li>
<li>final:       final IR after applying all optimization passes.</li>
<li><pass name>: the name of an optimization pass. Prints the IR state after that pass.</li>
<li>all:         short for initial, final, and all the optimization passes.</li>
<li>modified:    print a requested optimization pass only if it has modified the IR.</li>
</ul>
<p>[possible values: initial, final, all, modified, inline, simplify-cfg, sroa, dce, globals-dce, fn-dedup-release, fn-dedup-debug, mem2reg, memcpyopt, const-folding, arg-demotion, const-demotion, ret-demotion, misc-demotion]</p>
<p><code>--time-phases</code></p>
<p>Output the time elapsed over each part of the compilation process</p>
<p><code>--profile</code></p>
<p>Profile the compilation process</p>
<p><code>--reverse-order</code></p>
<p>Output build errors and warnings in reverse order</p>
<p><code>--metrics-outfile</code> &lt;<em>METRICS_OUTFILE</em>&gt;</p>
<p>Output compilation metrics into the specified file</p>
<p><code>--json-abi</code></p>
<p>Minify JSON ABI files.</p>
<p>By default the JSON for ABIs is formatted for human readability. By using this option JSON output will be "minified", i.e. all on one line without whitespace.</p>
<p><code>-v</code>, <code>--verbose...</code></p>
<p>Use verbose output</p>
<p><code>--json-storage-slots</code></p>
<p>Minify JSON storage slot files.</p>
<p>By default the JSON for initial storage slots is formatted for human readability. By using this option JSON output will be "minified", i.e. all on one line without whitespace.</p>
<p><code>-s</code>, <code>--silent</code></p>
<p>Silence all output</p>
<p><code>-L</code>, <code>--log-level</code> &lt;<em>LOG_LEVEL</em>&gt;</p>
<p>Set the log level</p>
<p><code>-o</code>, <code>--output-bin</code> &lt;<em>BIN_FILE</em>&gt;</p>
<p>Create a binary file at the provided path representing the final bytecode</p>
<p><code>-g</code>, <code>--output-debug</code> &lt;<em>DEBUG_FILE</em>&gt;</p>
<p>Create a file at the provided path containing debug information.</p>
<p>If the file extension is .json, JSON format is used. Otherwise, an .elf file containing DWARF format is emitted.</p>
<p><code>--output-hexfile</code> &lt;<em>HEX_FILE</em>&gt;</p>
<p>Generates a JSON file containing the hex-encoded script binary</p>
<p><code>--build-profile</code> &lt;<em>BUILD_PROFILE</em>&gt;</p>
<p>The name of the build profile to use</p>
<p>[default: debug]</p>
<p><code>--release</code></p>
<p>Use the release build profile.</p>
<p>The release profile can be customized in the manifest file.</p>
<p><code>--error-on-warnings</code></p>
<p>Treat warnings as errors</p>
<p><code>--build-target</code> &lt;<em>BUILD_TARGET</em>&gt;</p>
<p>Build target to use for code generation</p>
<p>[default: fuel]
[possible values: fuel, evm]</p>
<p><code>--dump-impls</code> &lt;<em>TYPE</em>&gt;</p>
<p>Dump all trait implementations for the given type name</p>
<p><code>--pretty</code></p>
<p>Pretty-print the logs emitted from tests</p>
<p><code>-l</code>, <code>--logs</code></p>
<p>Print decoded <code>Log</code> and <code>LogData</code> receipts for tests</p>
<p><code>--raw-logs</code></p>
<p>Print the raw logs for tests</p>
<p><code>--reverts</code></p>
<p>Print the revert information for tests</p>
<p><code>--dbgs</code></p>
<p>Print the output of debug ecals for tests</p>
<p><code>--filter-exact</code></p>
<p>When specified, only the test exactly matching the given string will be executed</p>
<p><code>--test-threads</code> &lt;<em>TEST_THREADS</em>&gt;</p>
<p>Number of threads to utilize when running the tests. By default, this is the number of threads available in your system</p>
<p><code>--experimental</code> &lt;<em>EXPERIMENTAL</em>&gt;</p>
<p>Comma separated list of all experimental features that will be enabled</p>
<p>[possible values: new_encoding, references, const_generics, new_hashing]</p>
<p><code>--no-experimental</code> &lt;<em>NO_EXPERIMENTAL</em>&gt;</p>
<p>Comma separated list of all experimental features that will be disabled</p>
<p>[possible values: new_encoding, references, const_generics, new_hashing]</p>
<p><code>-h</code>, <code>--help</code></p>
<p>Print help (see a summary with '-h')</p>
<p><code>-V</code>, <code>--version</code></p>
<p>Print version</p>
<p>EXAMPLES:</p>
<h1 id="run-test"><a class="header" href="#run-test">Run test</a></h1>
<p>forc test</p>
<h1 id="run-test-with-a-filter"><a class="header" href="#run-test-with-a-filter">Run test with a filter</a></h1>
<p>forc test $filter</p>
<h1 id="run-test-without-any-output"><a class="header" href="#run-test-without-any-output">Run test without any output</a></h1>
<p>forc test --silent</p>
<h1 id="run-test-without-creating-or-update-the-lock-file"><a class="header" href="#run-test-without-creating-or-update-the-lock-file">Run test without creating or update the lock file</a></h1>
<p>forc test --locked</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="update"><a class="header" href="#update">Update</a></h1>
<p>Usage: forc update [OPTIONS]</p>
<p>Options:</p>
<p><code>-p</code>, <code>--path</code> &lt;<em>PATH</em>&gt;</p>
<p>Path to the project, if not specified, current working directory will be used</p>
<p><code>-d</code> &lt;<em>TARGET_DEPENDENCY</em>&gt;</p>
<p>Dependency to be updated. If not set, all dependencies will be updated</p>
<p><code>-c</code>, <code>--check</code></p>
<p>Checks if the dependencies have newer versions. Won't actually perform the update, will output which ones are up-to-date and outdated</p>
<p><code>--ipfs-node</code> &lt;<em>IPFS_NODE</em>&gt;</p>
<p>The IPFS Node to use for fetching IPFS sources.</p>
<p>Possible values: FUEL, PUBLIC, LOCAL, &lt;GATEWAY_URL&gt;</p>
<p><code>-v</code>, <code>--verbose...</code></p>
<p>Use verbose output</p>
<p><code>-s</code>, <code>--silent</code></p>
<p>Silence all output</p>
<p><code>-L</code>, <code>--log-level</code> &lt;<em>LOG_LEVEL</em>&gt;</p>
<p>Set the log level</p>
<p><code>-h</code>, <code>--help</code></p>
<p>Print help (see a summary with '-h')</p>
<p><code>-V</code>, <code>--version</code></p>
<p>Print version</p>
<p>EXAMPLES:</p>
<h1 id="update-dependencies"><a class="header" href="#update-dependencies">Update dependencies</a></h1>
<p>forc update</p>
<h1 id="update-a-specific-dependency"><a class="header" href="#update-a-specific-dependency">Update a specific dependency</a></h1>
<p>forc update -d std</p>
<h1 id="check-if-dependencies-have-newer-versions"><a class="header" href="#check-if-dependencies-have-newer-versions">Check if dependencies have newer versions</a></h1>
<p>forc update --check</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="create-2"><a class="header" href="#create-2">Create</a></h1>
<p>Usage: forc template [OPTIONS] &lt;PROJECT_NAME&gt;</p>
<p>Arguments:</p>
<p>&lt;<em>PROJECT_NAME</em>&gt;</p>
<p>The name of the project that will be created</p>
<p>Options:</p>
<p><code>-u</code>, <code>--url</code> &lt;<em>URL</em>&gt;</p>
<p>The template url, should be a git repo [default: https://github.com/fuellabs/sway]</p>
<p><code>-t</code>, <code>--template-name</code> &lt;<em>TEMPLATE_NAME</em>&gt;</p>
<p>The name of the template that needs to be fetched and used from git repo provided</p>
<p><code>-v</code>, <code>--verbose...</code></p>
<p>Use verbose output</p>
<p><code>-s</code>, <code>--silent</code></p>
<p>Silence all output</p>
<p><code>-L</code>, <code>--log-level</code> &lt;<em>LOG_LEVEL</em>&gt;</p>
<p>Set the log level</p>
<p><code>-h</code>, <code>--help</code></p>
<p>Print help</p>
<p><code>-V</code>, <code>--version</code></p>
<p>Print version</p>
<p>EXAMPLES:</p>
<h1 id="create-a-new-forc-project-from-an-option-template"><a class="header" href="#create-a-new-forc-project-from-an-option-template">Create a new Forc project from an option template</a></h1>
<p>forc template new-path --template-name option<!-- markdownlint-disable MD041 --></p>
<h2 id="example-7"><a class="header" href="#example-7">EXAMPLE</a></h2>
<pre><code class="language-sh">forc template --url https://github.com/owner/template/ --project_name my_example_project
</code></pre>
<p>The command above fetches the <code>HEAD</code> of the <code>template</code> repo and searches for <code>Forc.toml</code> at the root of the fetched repo. It will fetch the repo and prepare a new <code>Forc.toml</code> with the new project name. Outputs everything to <code>current_dir/project_name</code>.</p>
<pre><code class="language-sh">forc template --url https://github.com/FuelLabs/sway --template_name counter --project_name my_example_project
</code></pre>
<p>The command above fetches the HEAD of the <code>sway</code> repo and searches for <code>counter</code> example inside it (there is an example called <code>counter</code> under <code>sway/examples</code>). It will fetch the <code>counter</code> example and prepare a new <code>Forc.toml</code> with the new project name. Outputs everything to <code>current_dir/project_name</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="plugins"><a class="header" href="#plugins">Plugins</a></h1>
<p>Plugins can be used to extend <code>forc</code> with new commands that go beyond the native commands mentioned in the previous chapter. While the Fuel ecosystem provides a few commonly useful plugins (<code>forc-fmt</code>, <code>forc-client</code>, <code>forc-lsp</code>, <code>forc-migrate</code>), anyone can write their own!</p>
<p>Let's install a plugin, <code>forc-install</code>, and see what's underneath the plugin:</p>
<pre><code class="language-sh">git clone https://github.com/darthbenro008/forc-install
cd forc-install
cargo install --path .
</code></pre>
<p>Check that we have installed <code>forc-install</code>:</p>
<pre><code class="language-console">$ forc plugins
Installed Plugins:
forc-install
</code></pre>
<p><code>forc-install</code> is a tool to manage GitHub dependencies in your Forc.toml file: For example, to install a sway library hosted on github:</p>
<pre><code class="language-console">forc install https://github.com/user/sway-library
</code></pre>
<p>Note that some plugin crates can also provide more than one command. For example, installing the <code>forc-client</code> plugin provides the <code>forc deploy</code> and <code>forc run</code> commands. This is achieved by specifying multiple <code>[[bin]]</code> targets within the <code>forc-client</code> manifest.</p>
<h2 id="writing-your-own-plugin"><a class="header" href="#writing-your-own-plugin">Writing your own plugin</a></h2>
<p>We encourage anyone to write and publish their own <code>forc</code> plugin to enhance their development experience.</p>
<p>Your plugin must be named in the format <code>forc-&lt;MY_PLUGIN&gt;</code> and you may use the above template as a starting point. You can use <a href="https://docs.rs/clap/latest/clap/">clap</a> and add more subcommands, options and configurations to suit your plugin's needs.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="forc-client"><a class="header" href="#forc-client">forc-client</a></h1>
<p>The forc plugin for interacting with a Fuel node.</p>
<p>Since transactions are going to require some gas, you need to sign them with an account that has enough coins to pay for them.</p>
<p>We offer multiple ways to sign the transaction:</p>
<ol>
<li>Sign the transaction via your local wallet using <code>forc-client</code> which integrates with our CLI wallet, <code>forc-wallet</code>.</li>
<li>Use the default signer to deploy to a local node</li>
<li>Use <code>forc-wallet</code> to manually sign transactions, and copy the signed transaction back to <code>forc-client</code>.</li>
</ol>
<p>The easiest and recommended way to interact with deployed networks such as our testnets is option 1, using <code>forc-client</code> to sign your transactions which reads your default <code>forc-wallet</code> vault. For interacting with local node, we recommend using the second option, which leads <code>forc-client</code> to sign transactions with the private key that comes pre-funded in local environments.</p>
<h2 id="option-1-sign-transactions-via-forc-client-using-your-local-forc-wallet-vault"><a class="header" href="#option-1-sign-transactions-via-forc-client-using-your-local-forc-wallet-vault">Option 1: Sign transactions via forc-client using your local forc-wallet vault</a></h2>
<p>If you've used <code>forc-wallet</code> before, you'll already have a secure, password-protected vault holding your private key written to your file-system. <code>forc-client</code> is compatible with <code>forc-wallet</code> such that it can read that vault by asking you your password and use your account to sign transactions.</p>
<p>Example:</p>
<pre><code class="language-console">&gt; forc deploy

    Building /Users/yourname/test-projects/test-contract
    Finished release [optimized + fuel] target(s) in 11.39s
  Confirming transactions [deploy impl-contract]
             Network: https://testnet.fuel.network
             Wallet: /Users/yourname/.fuel/wallets/.wallet
âœ” Wallet password Â· ********
? Wallet account â€º
â¯ [0] fuel12pls73y9hnqdqthvduy2x44x48zt8s50pkerf32kq26f2afeqdwq6rj9ar - 0.002197245 ETH
  [1] fuel1vzrm6kw9s3tv85gl25lpptsxrdguyzfhq6c8rk07tr6ft5g45nwqqh0uty - 0.001963631 ETH
? Do you agree to sign 1 transaction? (y/n) â€º yes
     Finished deploying impl-contract https://app.fuel.network/contract/0x94b712901f04332682d14c998a5fc5a078ed15321438f46d58d0383200cde43d
     Deployed in block https://app.fuel.network/block/5958351
</code></pre>
<p>As it can be seen from the example, <code>forc-client</code> asks for your password to decrypt the <code>forc-wallet</code> vault, and list your accounts so that you can select the one you want to fund the transaction with.</p>
<h2 id="option-2-using-default-signer"><a class="header" href="#option-2-using-default-signer">Option 2: Using default signer</a></h2>
<p>If you are not interacting with a deployed network, such as testnets, your local <code>fuel-core</code> environment can be structured such that it funds an account by default. Using <code>--default-signer</code> flag with <code>forc-client</code> binaries (run, deploy) will instruct <code>forc-client</code> to sign transactions with this pre-funded account. This makes it a useful command while working against a local node.</p>
<p>Example:</p>
<pre><code class="language-console">&gt; forc deploy --default-signer

    Building /Users/test/test-projects/test-contract
    Finished release [optimized + fuel] target(s) in 11.40s
  Confirming transactions [deploy impl-contract]
             Network: http://127.0.0.1:4000
    Finished deploying impl-contract 0xf9fb08ef18ce226954270d6d4f67677d484b8782a5892b3d436572b405407544
    Deployed in block 00000001
</code></pre>
<h2 id="option-3-manually-signing-through-forc-wallet-deprecated"><a class="header" href="#option-3-manually-signing-through-forc-wallet-deprecated">Option 3: Manually signing through forc-wallet (Deprecated)</a></h2>
<p>This option is for creating the transaction first, signing it manually, and supplying the signed transaction back to forc-client. Since it requires multiple steps, it is more error-prone and not recommended for general use cases. Also this will be deprecated soon.</p>
<ol>
<li>Construct the transaction by using either <code>forc deploy</code> or <code>forc run</code>. To do so simply run <code>forc deploy --manual-sign</code> or <code>forc run --manual-sign</code> with your desired parameters. For a list of parameters please refer to the <a href="forc/plugins/forc_client/./forc_deploy.html">forc-deploy</a> or <a href="forc/plugins/forc_client/./forc_run.html">forc-run</a> section of the book. Once you run either command you will be asked the address of the wallet you are going to be signing with. After the address is given the transaction will be generated and you will be given a transaction ID. At this point CLI will actively wait for you to insert the signature.</li>
<li>Take the transaction ID generated in the first step and sign it with <code>forc wallet sign --account &lt;account_index&gt; tx-id &lt;transaction_id&gt;</code>. This will generate a signature.</li>
<li>Take the signature generated in the second step and provide it to <code>forc-deploy</code> (or <code>forc-run</code>). Once the signature is provided, the signed transaction will be submitted.</li>
</ol>
<h2 id="other-useful-commands-of-forc-wallet"><a class="header" href="#other-useful-commands-of-forc-wallet">Other useful commands of <code>forc-wallet</code></a></h2>
<ul>
<li>You can see a list of existing accounts with <code>accounts</code> command.</li>
</ul>
<pre><code class="language-sh">forc wallet accounts
</code></pre>
<ul>
<li>If you want to retrieve the address for an account by its index you can use <code>account</code> command.</li>
</ul>
<pre><code class="language-sh">forc wallet account &lt;account_index&gt;
</code></pre>
<blockquote>
<p>If you want to sign the transaction generated by <code>forc-deploy</code> or <code>forc-run</code> with an account funded by default once you start your local node, you can pass <code>--default-signer</code> to them. Please note that this will only work against your local node.</p>
<pre><code class="language-sh">forc-deploy --default-signer
</code></pre>
<pre><code class="language-sh">forc-run --default-signer
</code></pre>
</blockquote>
<p>By default <code>--default-signer</code> flag would sign your transactions with the following private-key:</p>
<pre><code class="language-sh">0xde97d8624a438121b86a1956544bd72ed68cd69f2c99555b08b1e8c51ffd511c
</code></pre>
<h2 id="selecting-a-target-network"><a class="header" href="#selecting-a-target-network">Selecting a target network</a></h2>
<p>By default, <code>local</code> is used for the target network. To interact with the latest testnet, use the <code>--testnet</code> flag. When this flag is passed, transactions created by <code>forc-deploy</code> will be sent to the latest <code>testnet</code>:</p>
<pre><code class="language-sh">forc-deploy --testnet
</code></pre>
<p>The same can be done to target mainnet:</p>
<pre><code class="language-sh">forc-deploy --mainnet
</code></pre>
<p>It is also possible to pass the exact node URL while using <code>forc-deploy</code> or <code>forc-run</code> which can be done using <code>--node-url</code> flag:</p>
<pre><code class="language-sh">forc-deploy --node-url https://mainnet.fuel.network
</code></pre>
<p>Another alternative is the <code>--target</code> option, which provides useful aliases to all targets. For example if you want to deploy to <code>testnet</code> you can use:</p>
<pre><code class="language-sh">forc-deploy --target testnet
</code></pre>
<p>Since deploying and running projects on the testnet cost gas, you will need coins to pay for them. You can get some using the <a href="https://faucet-testnet.fuel.network/">testnet faucet</a>.</p>
<h2 id="delayed-transactions"><a class="header" href="#delayed-transactions">Delayed transactions</a></h2>
<p>For delayed transactions, you can use the <code>--submit-only</code> flag. This flag allows you to submit the transaction without waiting for its finalization.</p>
<p>One use case for this is multisig transactions, where a deployment transaction may stay in a pending state while waiting for all signatures.</p>
<pre><code class="language-sh">forc-deploy --submit-only
</code></pre>
<h2 id="deployment-artifacts"><a class="header" href="#deployment-artifacts">Deployment Artifacts</a></h2>
<p>forc-deploy saves the details of each deployment in the <code>out/deployments</code> folder within the project's root directory. Below is an example of a deployment artifact:</p>
<pre><code class="language-json">{
  "transaction_id": "0xec27bb7a4c8a3b8af98070666cf4e6ea22ca4b9950a0862334a1830520012f5d",
  "salt": "0x9e35d1d5ef5724f29e649a3465033f5397d3ebb973c40a1d76bb35c253f0dec7",
  "network_endpoint": "http://127.0.0.1:4000",
  "chain_id": 0,
  "contract_id": "0x767eeaa7af2621e637f9785552620e175d4422b17d4cf0d76335c38808608a7b",
  "deployment_size": 68,
  "deployed_block_id": "0x915c6f372252be6bc54bd70df6362dae9bf750ba652bf5582d9b31c7023ca6cf"
}
</code></pre>
<h2 id="proxy-contracts"><a class="header" href="#proxy-contracts">Proxy Contracts</a></h2>
<p><code>forc-deploy</code> supports deploying proxy contracts automatically if it is enabled in the <code>Forc.toml</code> of the contract. This feature enables upgradeable contracts by deploying a proxy that forwards calls to an implementation contract, allowing you to upgrade the implementation without changing the proxy address.</p>
<h3 id="configuration"><a class="header" href="#configuration">Configuration</a></h3>
<p>To enable proxy deployment, add a <code>[proxy]</code> table to your <code>Forc.toml</code>:</p>
<pre><code class="language-TOML">[project]
name = "test_contract"
authors = ["Fuel Labs &lt;contact@fuel.sh&gt;"]
entry = "main.sw"
license = "Apache-2.0"
implicit-std = false

[proxy]
enabled = true
</code></pre>
<p>The proxy configuration supports two fields:</p>
<ul>
<li><code>enabled</code> (boolean, required): Whether to deploy a proxy contract</li>
<li><code>address</code> (string, optional): Address of an existing proxy contract to update</li>
</ul>
<h3 id="fresh-proxy-deployment"><a class="header" href="#fresh-proxy-deployment">Fresh Proxy Deployment</a></h3>
<p>If there is no <code>address</code> field present under the proxy table, like the example above, <code>forc</code> will automatically create a proxy contract based on the <a href="https://github.com/FuelLabs/sway-standards/blob/master/docs/src/src-14-simple-upgradeable-proxies.md">SRC-14</a> implementation from <a href="https://github.com/FuelLabs/sway-standards">sway-standards</a>. The deployment process:</p>
<ol>
<li><strong>Deploy Implementation Contract</strong>: Your contract is deployed as the implementation</li>
<li><strong>Generate Proxy Contract</strong>: A standard SRC-14 proxy contract is generated</li>
<li><strong>Deploy Proxy Contract</strong>: The proxy is deployed with your implementation as the target</li>
<li><strong>Initialize Proxy</strong>: The proxy is initialized with the deploying account as the owner</li>
<li><strong>Update Manifest</strong>: The proxy address is automatically added to your <code>Forc.toml</code></li>
</ol>
<p>After deployment, you'll see output similar to:</p>
<pre><code class="language-console">Deploying contract test_contract chunks
Finished deploying test_contract 0x440b...925
Finished deploying proxy contract for test_contract 0x19d4...f7
Initialized proxy contract for test_contract
</code></pre>
<p>The <code>Forc.toml</code> will be automatically updated with the proxy address:</p>
<pre><code class="language-TOML">[proxy]
enabled = true
address = "0x19d465200575ebd085300242002efcda38db99e22449a5c1346588efe9ced7f7"
</code></pre>
<h3 id="updating-existing-proxy"><a class="header" href="#updating-existing-proxy">Updating Existing Proxy</a></h3>
<p>If you want to update the target of an existing <a href="https://github.com/FuelLabs/sway-standards/blob/master/docs/src/src-14-simple-upgradeable-proxies.md">SRC-14</a> compliant proxy contract, specify its address in the <code>address</code> field:</p>
<pre><code class="language-TOML">[project]
name = "test_contract"
authors = ["Fuel Labs &lt;contact@fuel.sh&gt;"]
entry = "main.sw"
license = "Apache-2.0"
implicit-std = false

[proxy]
enabled = true
address = "0xd8c4b07a0d1be57b228f4c18ba7bca0c8655eb6e9d695f14080f2cf4fc7cd946" # example proxy contract address
</code></pre>
<p>When an <code>address</code> is present, <code>forc</code> will:</p>
<ol>
<li>Deploy the new implementation contract</li>
<li>Call the existing proxy's <code>set_proxy_target</code> method to update the target</li>
<li>The proxy address remains the same, providing seamless upgrades</li>
</ol>
<h3 id="transaction-details"><a class="header" href="#transaction-details">Transaction Details</a></h3>
<p>When deploying with proxy enabled, you'll see multiple transactions in the confirmation:</p>
<ul>
<li>One transaction to deploy the implementation contract</li>
<li>One additional transaction to deploy the proxy (for fresh deployments) or update the target (for existing proxies)</li>
</ul>
<p>Example output:</p>
<pre><code class="language-console">Confirming transactions [deploy test_contract + deploy proxy]
Network: https://testnet.fuel.network
</code></pre>
<h3 id="storage-slots"><a class="header" href="#storage-slots">Storage Slots</a></h3>
<p>The proxy contract includes both its own storage slots and preserves the storage slots from your implementation contract, ensuring that contract state is properly maintained across upgrades.</p>
<h3 id="important-notes"><a class="header" href="#important-notes">Important Notes</a></h3>
<ul>
<li>The proxy owner (initially set to the deploying account) has exclusive rights to update the proxy target</li>
<li>Once a proxy is deployed, the address in your <code>Forc.toml</code> allows for automatic target updates on subsequent deployments</li>
<li>Proxy contracts work with both regular and <a href="forc/plugins/forc_client/index.html#large-contracts">chunked contracts</a> (contracts over 100<!-- markdownlint-disable-line MD032 -->kB)</li>
<li>The implementation uses the SRC-14 standard for maximum compatibility with the Fuel ecosystem</li>
</ul>
<h2 id="large-contracts"><a class="header" href="#large-contracts">Large Contracts</a></h2>
<p>For contracts over the maximum contract size limit (currently <code>100&lt;!-- markdownlint-disable-line --&gt;kB</code>) defined by the network, <code>forc-deploy</code> will split the contract into chunks and deploy the contract with multiple transactions using the Rust SDK's <a href="https://github.com/FuelLabs/fuels-rs/blob/master/docs/src/deploying/large_contracts.md">loader contract</a> functionality. Chunks that have already been deployed will be reused on subsequent deployments.</p>
<h2 id="deploying-scripts-and-predicates"><a class="header" href="#deploying-scripts-and-predicates">Deploying Scripts and Predicates</a></h2>
<p><code>forc deploy</code> now supports deploying scripts and predicates in addition to contracts. These are deployed as blobs with generated loaders for efficiency.</p>
<p>Scripts and predicates are deployed automatically when you run <code>forc deploy</code> on a project that contains them. The deployment process differs slightly from contract deployment:</p>
<ol>
<li>For scripts and predicates, the bytecode is uploaded as a blob.</li>
<li>A loader is generated that can load and execute the blob.</li>
<li>The loader bytecode is saved in the project's output directory.</li>
</ol>
<p>After deployment, you'll find new files in your project's output directory:</p>
<ul>
<li>For scripts: <code>&lt;script_name&gt;-loader.bin</code></li>
<li>For predicates: <code>&lt;predicate_name&gt;-loader.bin</code> and <code>&lt;predicate_name&gt;-loader-root</code></li>
</ul>
<p>The loader files contain the bytecode necessary to load and execute your script or predicate from the deployed blob.</p>
<p>This new deployment method allows for more efficient storage and execution of scripts and predicates on the Fuel network.</p>
<p>Note: Contracts are still deployed directly, not as blobs given that the contract size is under the maximum contract size limit defined by network (currently <code>100&lt;!-- markdownlint-disable-line --&gt;kB</code>).</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="build"><a class="header" href="#build">Build</a></h1>
<p>Usage: forc deploy [OPTIONS] [SIGNING_KEY]</p>
<p>Arguments:
[SIGNING_KEY]
Set the key to be used for signing</p>
<p>Options:</p>
<p><code>-p</code>, <code>--path</code> &lt;<em>PATH</em>&gt;</p>
<p>Path to the project.</p>
<p>If not specified, current working directory will be used.</p>
<p><code>--offline</code></p>
<p>Offline mode.</p>
<p>Prevents Forc from using the network when managing dependencies. Meaning it will only try to use previously downloaded dependencies.</p>
<p><code>-t</code>, <code>--terse</code></p>
<p>Terse mode.</p>
<p>Limited warning and error output.</p>
<p><code>--output-directory</code> &lt;<em>OUTPUT_DIRECTORY</em>&gt;</p>
<p>The directory in which Forc output artifacts are placed.</p>
<p>By default, this is <code>&lt;project-root&gt;/out</code>.</p>
<p><code>--locked</code></p>
<p>Requires that the Forc.lock file is up-to-date.</p>
<p>If the lock file is missing, or it needs to be updated, Forc will exit with an error.</p>
<p><code>--ipfs-node</code> &lt;<em>IPFS_NODE</em>&gt;</p>
<p>The IPFS node to use for fetching IPFS sources.</p>
<p>[possible values: FUEL, PUBLIC, LOCAL, &lt;GATEWAY_URL&gt;]</p>
<p><code>--json-abi</code></p>
<p>Minify JSON ABI files.</p>
<p>By default the JSON for ABIs is formatted for human readability. By using this option JSON output will be "minified", i.e. all on one line without whitespace.</p>
<p><code>--json-storage-slots</code></p>
<p>Minify JSON storage slot files.</p>
<p>By default the JSON for initial storage slots is formatted for human readability. By using this option JSON output will be "minified", i.e. all on one line without whitespace.</p>
<p><code>--ast</code></p>
<p>Print the generated Sway AST (Abstract Syntax Tree)</p>
<p><code>--dca-graph</code> &lt;<em>DCA_GRAPH</em>&gt;</p>
<p>Print the computed Sway DCA (Dead Code Analysis) graph.</p>
<p>DCA graph is printed to the specified path. If specified '' graph is printed to the stdout.</p>
<p><code>--dca-graph-url-format</code> &lt;<em>DCA_GRAPH_URL_FORMAT</em>&gt;</p>
<p>URL format to be used in the generated DCA graph .dot file.</p>
<p>Variables {path}, {line}, and {col} can be used in the provided format.
An example for vscode would be:
"vscode://file/{path}:{line}:{col}"</p>
<p><code>--asm</code> &lt;<em>ASM&gt;..</em>&gt;</p>
<p>Print the generated ASM (assembler).</p>
<p>Values that can be combined:</p>
<ul>
<li>virtual:   initial ASM with virtual registers and abstract control flow.</li>
<li>allocated: ASM with registers allocated, but still with abstract control flow.</li>
<li>abstract:  short for both virtual and allocated ASM.</li>
<li>final:     final ASM that gets serialized to the target VM bytecode.</li>
<li>all:       short for virtual, allocated, and final ASM.</li>
</ul>
<p>[possible values: virtual, allocated, abstract, final, all]</p>
<p><code>--bytecode</code></p>
<p>Print the bytecode.</p>
<p>This is the final output of the compiler.</p>
<p><code>--ir</code> &lt;<em>IR&gt;..</em>&gt;</p>
<p>Print the generated Sway IR (Intermediate Representation).</p>
<p>Values that can be combined:</p>
<ul>
<li>initial:     initial IR prior to any optimization passes.</li>
<li>final:       final IR after applying all optimization passes.</li>
<li><pass name>: the name of an optimization pass. Prints the IR state after that pass.</li>
<li>all:         short for initial, final, and all the optimization passes.</li>
<li>modified:    print a requested optimization pass only if it has modified the IR.</li>
</ul>
<p>[possible values: initial, final, all, modified, inline, simplify-cfg, sroa, dce, globals-dce, fn-dedup-release, fn-dedup-debug, mem2reg, memcpyopt, const-folding, arg-demotion, const-demotion, ret-demotion, misc-demotion]</p>
<p><code>--time-phases</code></p>
<p>Output the time elapsed over each part of the compilation process</p>
<p><code>--profile</code></p>
<p>Profile the compilation process</p>
<p><code>--reverse-order</code></p>
<p>Output build errors and warnings in reverse order</p>
<p><code>--metrics-outfile</code> &lt;<em>METRICS_OUTFILE</em>&gt;</p>
<p>Output compilation metrics into the specified file</p>
<p><code>--gas-price</code> &lt;<em>PRICE</em>&gt;</p>
<p>Gas price for the transaction</p>
<p><code>--script-gas-limit</code> &lt;<em>SCRIPT_GAS_LIMIT</em>&gt;</p>
<p>Gas limit for the transaction</p>
<p><code>--max-fee</code> &lt;<em>MAX_FEE</em>&gt;</p>
<p>Max fee for the transaction</p>
<p><code>--tip</code> &lt;<em>TIP</em>&gt;</p>
<p>The tip for the transaction</p>
<p><code>--maturity</code> &lt;<em>MATURITY</em>&gt;</p>
<p>Block height until which tx cannot be included</p>
<p>[default: 0]</p>
<p><code>--node-url</code> &lt;<em>NODE_URL</em>&gt;</p>
<p>The URL of the Fuel node to which we're submitting the transaction. If unspecified, checks the manifest's <code>network</code> table, then falls back to <code>http://127.0.0.1:4000</code></p>
<p>You can also use <code>--target</code>, <code>--devnet</code>, <code>--testnet</code>, or <code>--mainnet</code> to specify the Fuel node.</p>
<p>[env: FUEL_NODE_URL=]</p>
<p><code>--target</code> &lt;<em>TARGET</em>&gt;</p>
<p>Preset configurations for using a specific target.</p>
<p>You can also use <code>--node-url</code>, <code>--devnet</code>, <code>--testnet</code>, or <code>--mainnet</code> to specify the Fuel node.</p>
<p>Possible values are: [local, testnet, mainnet]</p>
<p><code>--mainnet</code></p>
<p>Use preset configuration for mainnet.</p>
<p>You can also use <code>--node-url</code>, <code>--target</code>, or <code>--testnet</code> to specify the Fuel node.</p>
<p><code>--testnet</code></p>
<p>Use preset configuration for testnet.</p>
<p>You can also use <code>--node-url</code>, <code>--target</code>, or <code>--mainnet</code> to specify the Fuel node.</p>
<p><code>--devnet</code></p>
<p>Use preset configuration for devnet.</p>
<p>You can also use <code>--node-url</code>, <code>--target</code>, or <code>--testnet</code> to specify the Fuel node.</p>
<p><code>--salt</code> &lt;<em>SALT</em>&gt;</p>
<p>Optional 256-bit hexadecimal literal(s) to redeploy contracts.</p>
<p>For a single contract, use <code>--salt &lt;SALT&gt;</code>, eg.: forc deploy --salt 0x0000000000000000000000000000000000000000000000000000000000000001</p>
<p>For a workspace with multiple contracts, use <code>--salt &lt;CONTRACT_NAME&gt;:&lt;SALT&gt;</code> to specify a salt for each contract, eg.:</p>
<p>forc deploy --salt contract_a:0x0000000000000000000000000000000000000000000000000000000000000001 --salt contract_b:0x0000000000000000000000000000000000000000000000000000000000000002</p>
<p><code>--default-salt</code></p>
<p>Generate a default salt (0x0000000000000000000000000000000000000000000000000000000000000000) for the contract. Useful for CI, to create reproducible deployments</p>
<p><code>-o</code>, <code>--output-bin</code> &lt;<em>BIN_FILE</em>&gt;</p>
<p>Create a binary file at the provided path representing the final bytecode</p>
<p><code>-g</code>, <code>--output-debug</code> &lt;<em>DEBUG_FILE</em>&gt;</p>
<p>Create a file at the provided path containing debug information.</p>
<p>If the file extension is .json, JSON format is used. Otherwise, an .elf file containing DWARF format is emitted.</p>
<p><code>--output-hexfile</code> &lt;<em>HEX_FILE</em>&gt;</p>
<p>Generates a JSON file containing the hex-encoded script binary</p>
<p><code>--build-profile</code> &lt;<em>BUILD_PROFILE</em>&gt;</p>
<p>The name of the build profile to use</p>
<p>[default: release]</p>
<p><code>--default-signer</code></p>
<p>Sign the transaction with default signer that is pre-funded by fuel-core. Useful for testing against local node</p>
<p><code>--unsigned</code></p>
<p>Deprecated in favor of <code>--default-signer</code></p>
<p><code>--submit-only</code></p>
<p>Submit the deployment transaction(s) without waiting for execution to complete</p>
<p><code>--manual-signing</code></p>
<p>Sign the deployment transaction manually</p>
<p><code>--override-storage-slots</code> &lt;<em>JSON_FILE_PATH</em>&gt;</p>
<p>Override storage slot initialization.</p>
<p>By default, storage slots are initialized with the values defined in the storage block in
the contract. You can override the initialization by providing the file path to a JSON file
containing the overridden values.</p>
<p>The file format and key values should match the compiler-generated <code>*-storage_slots.json</code> file in the output
directory of the compiled contract.</p>
<p>Example: <code>forc deploy --override-storage-slots my_override.json</code></p>
<p>my_override.json:
[
{
"key": "&lt;key from out/debug/storage_slots.json&gt;",
"value": "0000000000000000000000000000000000000000000000000000000000000001"
}
]</p>
<p><code>--experimental</code> &lt;<em>EXPERIMENTAL</em>&gt;</p>
<p>Comma separated list of all experimental features that will be enabled</p>
<p>[possible values: new_encoding, references, const_generics, new_hashing]</p>
<p><code>--no-experimental</code> &lt;<em>NO_EXPERIMENTAL</em>&gt;</p>
<p>Comma separated list of all experimental features that will be disabled</p>
<p>[possible values: new_encoding, references, const_generics, new_hashing]</p>
<p><code>--aws-kms-signer</code> &lt;<em>AWS_KMS_SIGNER</em>&gt;</p>
<p>AWS KMS signer arn. If present forc-deploy will automatically use AWS KMS signer instead of forc-wallet</p>
<p><code>-h</code>, <code>--help</code></p>
<p>Print help (see a summary with '-h')</p>
<p><code>-V</code>, <code>--version</code></p>
<p>Print version</p>
<p>EXAMPLES:</p>
<h1 id="deploy-a-single-contract"><a class="header" href="#deploy-a-single-contract">Deploy a single contract</a></h1>
<p>forc deploy bc09bfa7a11a04ce42b0a5abf04fd437387ee49bf4561d575177e2946468b408</p>
<h1 id="deploy-a-single-contract-from-a-different-path"><a class="header" href="#deploy-a-single-contract-from-a-different-path">Deploy a single contract from a different path</a></h1>
<p>forc deploy bc09bfa7a11a04ce42b0a5abf04fd437387ee49bf4561d575177e2946468b408 --path {path}</p>
<h1 id="deploy-to-a-custom-network"><a class="header" href="#deploy-to-a-custom-network">Deploy to a custom network</a></h1>
<p>forc deploy --node-url https://testnet.fuel.network/graphql<!-- markdownlint-disable MD041 --></p>
<h2 id="example-8"><a class="header" href="#example-8">EXAMPLE</a></h2>
<p>You can use <code>forc deploy</code>, which triggers a contract deployment transaction and sends it to a running node.</p>
<p>Alternatively, you can deploy your Sway contract programmatically using <a href="https://github.com/FuelLabs/fuels-rs">fuels-rs</a>, our Rust SDK.</p>
<p>You can find an example within our <a href="https://rust.fuel.network/latest/">fuels-rs book</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="run-2"><a class="header" href="#run-2">Run</a></h1>
<p>Usage: forc run [OPTIONS] [SIGNING_KEY]</p>
<p>Arguments:
[SIGNING_KEY]
Set the key to be used for signing</p>
<p>Options:</p>
<p><code>-p</code>, <code>--path</code> &lt;<em>PATH</em>&gt;</p>
<p>Path to the project.</p>
<p>If not specified, current working directory will be used.</p>
<p><code>--offline</code></p>
<p>Offline mode.</p>
<p>Prevents Forc from using the network when managing dependencies. Meaning it will only try to use previously downloaded dependencies.</p>
<p><code>-t</code>, <code>--terse</code></p>
<p>Terse mode.</p>
<p>Limited warning and error output.</p>
<p><code>--output-directory</code> &lt;<em>OUTPUT_DIRECTORY</em>&gt;</p>
<p>The directory in which Forc output artifacts are placed.</p>
<p>By default, this is <code>&lt;project-root&gt;/out</code>.</p>
<p><code>--locked</code></p>
<p>Requires that the Forc.lock file is up-to-date.</p>
<p>If the lock file is missing, or it needs to be updated, Forc will exit with an error.</p>
<p><code>--ipfs-node</code> &lt;<em>IPFS_NODE</em>&gt;</p>
<p>The IPFS node to use for fetching IPFS sources.</p>
<p>[possible values: FUEL, PUBLIC, LOCAL, &lt;GATEWAY_URL&gt;]</p>
<p><code>--json-abi</code></p>
<p>Minify JSON ABI files.</p>
<p>By default the JSON for ABIs is formatted for human readability. By using this option JSON output will be "minified", i.e. all on one line without whitespace.</p>
<p><code>--json-storage-slots</code></p>
<p>Minify JSON storage slot files.</p>
<p>By default the JSON for initial storage slots is formatted for human readability. By using this option JSON output will be "minified", i.e. all on one line without whitespace.</p>
<p><code>--ast</code></p>
<p>Print the generated Sway AST (Abstract Syntax Tree)</p>
<p><code>--dca-graph</code> &lt;<em>DCA_GRAPH</em>&gt;</p>
<p>Print the computed Sway DCA (Dead Code Analysis) graph.</p>
<p>DCA graph is printed to the specified path. If specified '' graph is printed to the stdout.</p>
<p><code>--dca-graph-url-format</code> &lt;<em>DCA_GRAPH_URL_FORMAT</em>&gt;</p>
<p>URL format to be used in the generated DCA graph .dot file.</p>
<p>Variables {path}, {line}, and {col} can be used in the provided format.
An example for vscode would be:
"vscode://file/{path}:{line}:{col}"</p>
<p><code>--asm</code> &lt;<em>ASM&gt;..</em>&gt;</p>
<p>Print the generated ASM (assembler).</p>
<p>Values that can be combined:</p>
<ul>
<li>virtual:   initial ASM with virtual registers and abstract control flow.</li>
<li>allocated: ASM with registers allocated, but still with abstract control flow.</li>
<li>abstract:  short for both virtual and allocated ASM.</li>
<li>final:     final ASM that gets serialized to the target VM bytecode.</li>
<li>all:       short for virtual, allocated, and final ASM.</li>
</ul>
<p>[possible values: virtual, allocated, abstract, final, all]</p>
<p><code>--bytecode</code></p>
<p>Print the bytecode.</p>
<p>This is the final output of the compiler.</p>
<p><code>--ir</code> &lt;<em>IR&gt;..</em>&gt;</p>
<p>Print the generated Sway IR (Intermediate Representation).</p>
<p>Values that can be combined:</p>
<ul>
<li>initial:     initial IR prior to any optimization passes.</li>
<li>final:       final IR after applying all optimization passes.</li>
<li><pass name>: the name of an optimization pass. Prints the IR state after that pass.</li>
<li>all:         short for initial, final, and all the optimization passes.</li>
<li>modified:    print a requested optimization pass only if it has modified the IR.</li>
</ul>
<p>[possible values: initial, final, all, modified, inline, simplify-cfg, sroa, dce, globals-dce, fn-dedup-release, fn-dedup-debug, mem2reg, memcpyopt, const-folding, arg-demotion, const-demotion, ret-demotion, misc-demotion]</p>
<p><code>--time-phases</code></p>
<p>Output the time elapsed over each part of the compilation process</p>
<p><code>--profile</code></p>
<p>Profile the compilation process</p>
<p><code>--reverse-order</code></p>
<p>Output build errors and warnings in reverse order</p>
<p><code>--metrics-outfile</code> &lt;<em>METRICS_OUTFILE</em>&gt;</p>
<p>Output compilation metrics into the specified file</p>
<p><code>--gas-price</code> &lt;<em>PRICE</em>&gt;</p>
<p>Gas price for the transaction</p>
<p><code>--script-gas-limit</code> &lt;<em>SCRIPT_GAS_LIMIT</em>&gt;</p>
<p>Gas limit for the transaction</p>
<p><code>--max-fee</code> &lt;<em>MAX_FEE</em>&gt;</p>
<p>Max fee for the transaction</p>
<p><code>--tip</code> &lt;<em>TIP</em>&gt;</p>
<p>The tip for the transaction</p>
<p><code>--maturity</code> &lt;<em>MATURITY</em>&gt;</p>
<p>Block height until which tx cannot be included</p>
<p>[default: 0]</p>
<p><code>-o</code>, <code>--output-bin</code> &lt;<em>BIN_FILE</em>&gt;</p>
<p>Create a binary file at the provided path representing the final bytecode</p>
<p><code>-g</code>, <code>--output-debug</code> &lt;<em>DEBUG_FILE</em>&gt;</p>
<p>Create a file at the provided path containing debug information.</p>
<p>If the file extension is .json, JSON format is used. Otherwise, an .elf file containing DWARF format is emitted.</p>
<p><code>--output-hexfile</code> &lt;<em>HEX_FILE</em>&gt;</p>
<p>Generates a JSON file containing the hex-encoded script binary</p>
<p><code>--build-profile</code> &lt;<em>BUILD_PROFILE</em>&gt;</p>
<p>The name of the build profile to use</p>
<p>[default: debug]</p>
<p><code>--release</code></p>
<p>Use the release build profile.</p>
<p>The release profile can be customized in the manifest file.</p>
<p><code>--error-on-warnings</code></p>
<p>Treat warnings as errors</p>
<p><code>--node-url</code> &lt;<em>NODE_URL</em>&gt;</p>
<p>The URL of the Fuel node to which we're submitting the transaction. If unspecified, checks the manifest's <code>network</code> table, then falls back to <code>http://127.0.0.1:4000</code></p>
<p>You can also use <code>--target</code>, <code>--devnet</code>, <code>--testnet</code>, or <code>--mainnet</code> to specify the Fuel node.</p>
<p>[env: FUEL_NODE_URL=]</p>
<p><code>--target</code> &lt;<em>TARGET</em>&gt;</p>
<p>Preset configurations for using a specific target.</p>
<p>You can also use <code>--node-url</code>, <code>--devnet</code>, <code>--testnet</code>, or <code>--mainnet</code> to specify the Fuel node.</p>
<p>Possible values are: [local, testnet, mainnet]</p>
<p><code>--mainnet</code></p>
<p>Use preset configuration for mainnet.</p>
<p>You can also use <code>--node-url</code>, <code>--target</code>, or <code>--testnet</code> to specify the Fuel node.</p>
<p><code>--testnet</code></p>
<p>Use preset configuration for testnet.</p>
<p>You can also use <code>--node-url</code>, <code>--target</code>, or <code>--mainnet</code> to specify the Fuel node.</p>
<p><code>--devnet</code></p>
<p>Use preset configuration for devnet.</p>
<p>You can also use <code>--node-url</code>, <code>--target</code>, or <code>--testnet</code> to specify the Fuel node.</p>
<p><code>-d</code>, <code>--data</code> &lt;<em>DATA</em>&gt;</p>
<p>Hex string of data to input to script</p>
<p><code>--dry-run</code></p>
<p>Only craft transaction and print it out</p>
<p><code>-r</code>, <code>--pretty-print</code></p>
<p>Pretty-print the outputs from the node</p>
<p><code>--contract</code> &lt;<em>CONTRACT</em>&gt;</p>
<p>32-byte contract ID that will be called during the transaction</p>
<p><code>--simulate</code></p>
<p>Execute the transaction and return the final mutated transaction along with receipts (which includes whether the transaction reverted or not). The transaction is not inserted in the node's view of the blockchain, (i.e. it does not affect the chain state)</p>
<p><code>--default-signer</code></p>
<p>Sign the transaction with default signer that is pre-funded by fuel-core. Useful for testing against local node</p>
<p><code>--unsigned</code></p>
<p>Deprecated in favor of <code>--default-signer</code></p>
<p><code>--args</code> &lt;<em>ARGS</em>&gt;</p>
<p>Arguments to pass into main function with forc run</p>
<p><code>--experimental</code> &lt;<em>EXPERIMENTAL</em>&gt;</p>
<p>Comma separated list of all experimental features that will be enabled</p>
<p>[possible values: new_encoding, references, const_generics, new_hashing]</p>
<p><code>--no-experimental</code> &lt;<em>NO_EXPERIMENTAL</em>&gt;</p>
<p>Comma separated list of all experimental features that will be disabled</p>
<p>[possible values: new_encoding, references, const_generics, new_hashing]</p>
<p><code>-h</code>, <code>--help</code></p>
<p>Print help (see a summary with '-h')</p>
<p><code>-V</code>, <code>--version</code></p>
<p>Print version</p>
<p>DEBUG:</p>
<p><code>--debug</code></p>
<p>Start interactive debugger after transaction execution</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="a"><a class="header" href="#a">A</a></h1>
<p>Usage: forc-submit [OPTIONS] &lt;TX_PATH&gt;</p>
<p>Arguments:</p>
<p>&lt;<em>TX_PATH</em>&gt;
Path to the Transaction that is to be submitted to the Fuel node.</p>
<p>Paths to files ending with <code>.json</code> will be deserialized from JSON. Paths to files ending with <code>.bin</code> will be deserialized from bytes using the <code>fuel_tx::Transaction::try_from_bytes</code> constructor.</p>
<p>Options:</p>
<p><code>--node-url</code> &lt;<em>NODE_URL</em>&gt;</p>
<p>The URL of the Fuel node to which we're submitting the transaction. If unspecified, checks the manifest's <code>network</code> table, then falls back to <code>http://127.0.0.1:4000</code></p>
<p>You can also use <code>--target</code>, <code>--devnet</code>, <code>--testnet</code>, or <code>--mainnet</code> to specify the Fuel node.</p>
<p>[env: FUEL_NODE_URL=]</p>
<p><code>--target</code> &lt;<em>TARGET</em>&gt;</p>
<p>Preset configurations for using a specific target.</p>
<p>You can also use <code>--node-url</code>, <code>--devnet</code>, <code>--testnet</code>, or <code>--mainnet</code> to specify the Fuel node.</p>
<p>Possible values are: [local, testnet, mainnet]</p>
<p><code>--mainnet</code></p>
<p>Use preset configuration for mainnet.</p>
<p>You can also use <code>--node-url</code>, <code>--target</code>, or <code>--testnet</code> to specify the Fuel node.</p>
<p><code>--testnet</code></p>
<p>Use preset configuration for testnet.</p>
<p>You can also use <code>--node-url</code>, <code>--target</code>, or <code>--mainnet</code> to specify the Fuel node.</p>
<p><code>--devnet</code></p>
<p>Use preset configuration for devnet.</p>
<p>You can also use <code>--node-url</code>, <code>--target</code>, or <code>--testnet</code> to specify the Fuel node.</p>
<p><code>--await</code> &lt;<em>AWAIT</em>&gt;</p>
<p>Whether or not to await confirmation that the transaction has been committed.</p>
<p>When <code>true</code>, await commitment and output the transaction status. When <code>false</code>, do not await confirmation and simply output the transaction ID.</p>
<p>[default: true]
[possible values: true, false]</p>
<p><code>--tx-status-json</code> &lt;<em>JSON</em>&gt;</p>
<p>Output the resulting transaction status as JSON rather than the default output</p>
<p>[default: false]
[possible values: true, false]</p>
<p><code>-h</code>, <code>--help</code></p>
<p>Print help (see a summary with '-h')</p>
<p><code>-V</code>, <code>--version</code></p>
<p>Print version</p>
<p>EXAMPLES:</p>
<h1 id="submit-a-transaction-from-a-json-file"><a class="header" href="#submit-a-transaction-from-a-json-file">Submit a transaction from a json file</a></h1>
<p>forc submit {path}/mint.json</p>
<h1 id="submit-a-transaction-from-a-json-file-and-wait-for-confirmation"><a class="header" href="#submit-a-transaction-from-a-json-file-and-wait-for-confirmation">Submit a transaction from a json file and wait for confirmation</a></h1>
<p>forc submit {path}/mint.json --await true</p>
<h1 id="submit-a-transaction-from-a-json-file-and-get-output-in-json"><a class="header" href="#submit-a-transaction-from-a-json-file-and-get-output-in-json">Submit a transaction from a json file and get output in json</a></h1>
<p>forc submit {path}/mint.json --tx-status-json true</p>
<h1 id="submit-a-transaction-from-a-json-file-to-testnet"><a class="header" href="#submit-a-transaction-from-a-json-file-to-testnet">Submit a transaction from a json file to testnet</a></h1>
<p>forc submit {path}/mint.json --testnet</p>
<h1 id="submit-a-transaction-from-a-json-file-to-a-local-net"><a class="header" href="#submit-a-transaction-from-a-json-file-to-a-local-net">Submit a transaction from a json file to a local net</a></h1>
<p>forc submit {path}/mint.json --target local</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="perform"><a class="header" href="#perform">Perform</a></h1>
<p>Usage: forc call [OPTIONS] <ADDRESS> [FUNCTION] [FUNCTION_ARGS]...</p>
<p>Options:</p>
<p><code>--abi</code> &lt;<em>ABI</em>&gt;</p>
<p>Path, URI, or raw JSON string for the ABI Required when making function calls or listing functions Can be a file path, HTTP/HTTPS URL, or raw JSON string</p>
<p><code>--node-url</code> &lt;<em>NODE_URL</em>&gt;</p>
<p>The URL of the Fuel node to which we're submitting the transaction. If unspecified, checks the manifest's <code>network</code> table, then falls back to <code>http://127.0.0.1:4000</code></p>
<p>You can also use <code>--target</code>, <code>--devnet</code>, <code>--testnet</code>, or <code>--mainnet</code> to specify the Fuel node.</p>
<p>[env: FUEL_NODE_URL=]</p>
<p><code>--target</code> &lt;<em>TARGET</em>&gt;</p>
<p>Preset configurations for using a specific target.</p>
<p>You can also use <code>--node-url</code>, <code>--devnet</code>, <code>--testnet</code>, or <code>--mainnet</code> to specify the Fuel node.</p>
<p>Possible values are: [local, testnet, mainnet]</p>
<p><code>--mainnet</code></p>
<p>Use preset configuration for mainnet.</p>
<p>You can also use <code>--node-url</code>, <code>--target</code>, or <code>--testnet</code> to specify the Fuel node.</p>
<p><code>--testnet</code></p>
<p>Use preset configuration for testnet.</p>
<p>You can also use <code>--node-url</code>, <code>--target</code>, or <code>--mainnet</code> to specify the Fuel node.</p>
<p><code>--devnet</code></p>
<p>Use preset configuration for devnet.</p>
<p>You can also use <code>--node-url</code>, <code>--target</code>, or <code>--testnet</code> to specify the Fuel node.</p>
<p><code>--gas-price</code> &lt;<em>PRICE</em>&gt;</p>
<p>Gas price for the transaction</p>
<p><code>--script-gas-limit</code> &lt;<em>SCRIPT_GAS_LIMIT</em>&gt;</p>
<p>Gas limit for the transaction</p>
<p><code>--max-fee</code> &lt;<em>MAX_FEE</em>&gt;</p>
<p>Max fee for the transaction</p>
<p><code>--tip</code> &lt;<em>TIP</em>&gt;</p>
<p>The tip for the transaction</p>
<p><code>-h</code>, <code>--help</code></p>
<p>Print help (see a summary with '-h')</p>
<p><code>-V</code>, <code>--version</code></p>
<p>Print version</p>
<p>CONTRACT:</p>
<p><code>--contract-abi</code> &lt;<em>CONTRACT_ABIS</em>&gt;</p>
<p>Additional contract IDs and their ABI paths for better tracing and debugging. Format: contract_id:abi_path (can be used multiple times) Example: --contract-abi 0x123:./abi1.json --contract-abi 0x456:https://example.com/abi2.json Contract IDs can be provided with or without 0x prefix</p>
<p><code>--external-contracts</code> &lt;<em>EXTERNAL_CONTRACTS</em>&gt;</p>
<p>The external contract addresses to use for the call If none are provided, the call will automatically populate external contracts by making dry-run calls to the node, and extract the contract addresses based on the revert reason. Use an empty string '' to explicitly specify no external contracts. Multiple contract IDs can be provided separated by commas</p>
<p>&lt;<em>ADDRESS</em>&gt;
The contract ID to call</p>
<p>OUTPUT:</p>
<p><code>--label</code> &lt;<em>LABEL</em>&gt;</p>
<p>Label addresses in the trace output for better readability. Format: address:label (can be used multiple times) Example: --label 0x123:MainContract --label 0x456:TokenContract Addresses can be provided with or without 0x prefix</p>
<p><code>-o</code>, <code>--output</code> &lt;<em>OUTPUT</em>&gt;</p>
<p>Output format for the call result</p>
<p>[default: default]</p>
<p>Possible values:</p>
<ul>
<li>default: Default formatted output</li>
<li>raw:     Raw unformatted output</li>
<li>json:    JSON output with full tracing information (logs, errors, and result)</li>
</ul>
<p><code>-v...</code></p>
<p>Set verbosity levels; currently only supports max 2 levels - <code>-v=1</code>: Print decoded logs - <code>-v=2</code>: Additionally print receipts and script json</p>
<p>FUNCTION:
[FUNCTION]
The function selector to call. The function selector is the name of the function to call (e.g. "transfer"). Not required when --list-functions is specified or when --amount is provided for direct transfer</p>
<p>[FUNCTION_ARGS]...
Arguments to pass to the function</p>
<p>ACCOUNT OPTIONS:</p>
<p><code>--signing-key</code> &lt;<em>SIGNING_KEY</em>&gt;</p>
<p>Derive an account from a secret key to make the call</p>
<p>[env: SIGNING_KEY=]</p>
<p><code>--wallet</code></p>
<p>Use forc-wallet to make the call</p>
<p>CALL PARAMETERS:</p>
<p><code>--amount</code> &lt;<em>AMOUNT</em>&gt;</p>
<p>Amount of native assets to forward with the call</p>
<p>[default: 0]</p>
<p><code>--asset-id</code> &lt;<em>ASSET_ID</em>&gt;</p>
<p>Asset ID to forward with the call</p>
<p><code>--gas-forwarded</code> &lt;<em>GAS_FORWARDED</em>&gt;</p>
<p>Amount of gas to forward with the call</p>
<p>EXECUTION:</p>
<p><code>--mode</code> &lt;<em>MODE</em>&gt;</p>
<p>Execution mode - determines if state changes are applied - <code>dry-run</code>: No state changes, no gas fees, wallet is not used or validated - <code>simulate</code>: No state changes, estimates gas, wallet is used but not validated - <code>live</code>: State changes, gas fees apply, wallet is used and validated</p>
<p>[default: dry-run]</p>
<p>Possible values:</p>
<ul>
<li>dry-run:  Execute a dry run - no state changes, no gas fees, wallet is not used or validated</li>
<li>simulate: Execute in simulation mode - no state changes, estimates gas, wallet is used but not validated</li>
<li>live:     Execute live on chain - state changes, gas fees apply, wallet is used and validated</li>
</ul>
<p>OPERATION:</p>
<p><code>--list-functions</code></p>
<p>List all available functions in the contract</p>
<p>VARIABLE OUTPUT:</p>
<p><code>--variable-output</code> &lt;<em>VARIABLE_OUTPUT</em>&gt;</p>
<p>Contract call variable output count</p>
<p>DEBUG:</p>
<p><code>-d</code>, <code>--debug</code></p>
<p>Start interactive debugger after transaction execution</p>
<h2 id="examples-1"><a class="header" href="#examples-1">EXAMPLES:</a></h2>
<h3 id="call-a-contract-with-function-parameters"><a class="header" href="#call-a-contract-with-function-parameters">Call a contract with function parameters</a></h3>
<pre><code class="language-sh">forc call 0x0dcba78d7b09a1f77353f51367afd8b8ab94b5b2bb6c9437d9ba9eea47dede97 \

`--abi` 

./contract-abi.json \
get_balance 0x0087675439e10a8351b1d5e4cf9d0ea6da77675623ff6b16470b5e3c58998423
</code></pre>
<h3 id="call-a-contract-with-function-parameters-additionally-print-logs-receipts-and-script-json"><a class="header" href="#call-a-contract-with-function-parameters-additionally-print-logs-receipts-and-script-json">Call a contract with function parameters; additionally print logs, receipts and script json</a></h3>
<pre><code class="language-sh">forc call 0x0dcba78d7b09a1f77353f51367afd8b8ab94b5b2bb6c9437d9ba9eea47dede97 \

`--abi` 

./contract-abi.json \
get_balance 0x0087675439e10a8351b1d5e4cf9d0ea6da77675623ff6b16470b5e3c58998423 \

`-vv` 


</code></pre>
<h3 id="call-a-contract-with-address-labels-for-better-trace-readability"><a class="header" href="#call-a-contract-with-address-labels-for-better-trace-readability">Call a contract with address labels for better trace readability</a></h3>
<pre><code class="language-sh">forc call 0x0dcba78d7b09a1f77353f51367afd8b8ab94b5b2bb6c9437d9ba9eea47dede97 \

`--abi` 

./contract-abi.json \
transfer 0xf8f8b6283d7fa5b672b530cbb84fcccb4ff8dc40f8176ef4544ddb1f1952ad07 \

`--label` 

0x0dcba78d7b09a1f77353f51367afd8b8ab94b5b2bb6c9437d9ba9eea47dede97:MainContract \

`--label` 

0xf8f8b6283d7fa5b672b530cbb84fcccb4ff8dc40f8176ef4544ddb1f1952ad07:TokenContract \

`-vv` 


</code></pre>
<h3 id="call-a-contract-without-function-parameters"><a class="header" href="#call-a-contract-without-function-parameters">Call a contract without function parameters</a></h3>
<pre><code class="language-sh">forc call 0x0dcba78d7b09a1f77353f51367afd8b8ab94b5b2bb6c9437d9ba9eea47dede97 \

`--abi` 

./contract-abi.json \
get_name
</code></pre>
<h3 id="call-a-contract-that-makes-external-contract-calls"><a class="header" href="#call-a-contract-that-makes-external-contract-calls">Call a contract that makes external contract calls</a></h3>
<pre><code class="language-sh">forc call 0x0dcba78d7b09a1f77353f51367afd8b8ab94b5b2bb6c9437d9ba9eea47dede97 \

`--abi` 

./contract-abi.json \
transfer 0xf8f8b6283d7fa5b672b530cbb84fcccb4ff8dc40f8176ef4544ddb1f1952ad07 \

`--contracts` 

0xf8f8b6283d7fa5b672b530cbb84fcccb4ff8dc40f8176ef4544ddb1f1952ad07
</code></pre>
<h3 id="call-a-contract-with-additional-contract-abis-for-better-tracing"><a class="header" href="#call-a-contract-with-additional-contract-abis-for-better-tracing">Call a contract with additional contract ABIs for better tracing</a></h3>
<pre><code class="language-sh">forc call 0x0dcba78d7b09a1f77353f51367afd8b8ab94b5b2bb6c9437d9ba9eea47dede97 \

`--abi` 

./contract-abi.json \
transfer 0xf8f8b6283d7fa5b672b530cbb84fcccb4ff8dc40f8176ef4544ddb1f1952ad07 \

`--contract-abi` 

0xf8f8b6283d7fa5b672b530cbb84fcccb4ff8dc40f8176ef4544ddb1f1952ad07:./external-abi.json \

`--contract-abi` 

0x1234:https://example.com/abi.json
</code></pre>
<h3 id="call-a-contract-in-simulation-mode"><a class="header" href="#call-a-contract-in-simulation-mode">Call a contract in simulation mode</a></h3>
<pre><code class="language-sh">forc call 0x0dcba78d7b09a1f77353f51367afd8b8ab94b5b2bb6c9437d9ba9eea47dede97 \

`--abi` 

./contract-abi.json \
add 1 2 \

`--mode` 

simulate
</code></pre>
<h3 id="call-a-contract-in-dry-run-mode-on-custom-node-url-using-explicit-signing-key"><a class="header" href="#call-a-contract-in-dry-run-mode-on-custom-node-url-using-explicit-signing-key">Call a contract in dry-run mode on custom node URL using explicit signing-key</a></h3>
<pre><code class="language-sh">forc call 0x0dcba78d7b09a1f77353f51367afd8b8ab94b5b2bb6c9437d9ba9eea47dede97 \

`--node-url` 

"http://127.0.0.1:4000/v1/graphql" \

`--signing-key` 

0x... \

`--abi` 

./contract-abi.json \
add 1 2 \

`--mode` 

dry-run
</code></pre>
<h3 id="call-a-contract-in-live-mode-which-performs-state-changes-on-testnet-using-forc-wallet"><a class="header" href="#call-a-contract-in-live-mode-which-performs-state-changes-on-testnet-using-forc-wallet">Call a contract in live mode which performs state changes on testnet using forc-wallet</a></h3>
<pre><code class="language-sh">forc call 0x0dcba78d7b09a1f77353f51367afd8b8ab94b5b2bb6c9437d9ba9eea47dede97 \

`--testnet` 

\

`--wallet` 

\

`--abi` 

./contract-abi.json \
add 1 2 \

`--mode` 

live
</code></pre>
<h3 id="call-a-contract-payable-function-which-transfers-value-of-native-asset-on-mainnet"><a class="header" href="#call-a-contract-payable-function-which-transfers-value-of-native-asset-on-mainnet">Call a contract payable function which transfers value of native asset on mainnet</a></h3>
<pre><code class="language-sh">forc call 0x0dcba78d7b09a1f77353f51367afd8b8ab94b5b2bb6c9437d9ba9eea47dede97 \

`--abi` 

./contract-abi.json \
transfer 0xf8f8b6283d7fa5b672b530cbb84fcccb4ff8dc40f8176ef4544ddb1f1952ad07 \

`--mode` 

live \

`--amount` 

100
</code></pre>
<h3 id="call-a-contract-payable-function-which-transfers-value-of-custom-asset"><a class="header" href="#call-a-contract-payable-function-which-transfers-value-of-custom-asset">Call a contract payable function which transfers value of custom asset</a></h3>
<pre><code class="language-sh">forc call 0x0dcba78d7b09a1f77353f51367afd8b8ab94b5b2bb6c9437d9ba9eea47dede97 \

`--abi` 

./contract-abi.json \
transfer 0xf8f8b6283d7fa5b672b530cbb84fcccb4ff8dc40f8176ef4544ddb1f1952ad07 \

`--amount` 

100 \

`--asset-id` 

0x0087675439e10a8351b1d5e4cf9d0ea6da77675623ff6b16470b5e3c58998423 \

`--live` 


</code></pre>
<h3 id="list-all-available-functions-in-a-contract"><a class="header" href="#list-all-available-functions-in-a-contract">List all available functions in a contract</a></h3>
<pre><code class="language-sh">forc call 0x0dcba78d7b09a1f77353f51367afd8b8ab94b5b2bb6c9437d9ba9eea47dede97 \

`--abi` 

./contract-abi.json \

`--list-functions` 


</code></pre>
<h3 id="call-a-contract-with-inline-abi-json-string"><a class="header" href="#call-a-contract-with-inline-abi-json-string">Call a contract with inline ABI JSON string</a></h3>
<pre><code class="language-sh">forc call 0x0dcba78d7b09a1f77353f51367afd8b8ab94b5b2bb6c9437d9ba9eea47dede97 \

`--abi` 

'{"functions":[{"inputs":[],"name":"get_balance","output":{"name":"","type":"u64","typeArguments":null}}]}' \
get_balance
</code></pre>
<h3 id="direct-transfer-of-asset-to-a-contract-or-address"><a class="header" href="#direct-transfer-of-asset-to-a-contract-or-address">Direct transfer of asset to a contract or address</a></h3>
<pre><code class="language-sh">forc call 0x0dcba78d7b09a1f77353f51367afd8b8ab94b5b2bb6c9437d9ba9eea47dede97 \

`--amount` 

100 \

`--mode` 

live
</code></pre>
<h3 id="call-a-contract-with-interactive-debugger-after-transaction"><a class="header" href="#call-a-contract-with-interactive-debugger-after-transaction">Call a contract with interactive debugger after transaction</a></h3>
<pre><code class="language-sh">forc call 0x0dcba78d7b09a1f77353f51367afd8b8ab94b5b2bb6c9437d9ba9eea47dede97 \

`--abi` 

./contract-abi.json \
get_balance 0x0087675439e10a8351b1d5e4cf9d0ea6da77675623ff6b16470b5e3c58998423 \

`--debug` 


</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="forc"><a class="header" href="#forc">Forc</a></h1>
<p>Usage: forc-crypto <COMMAND></p>
<p>Commands:
keccak256       Hashes the argument or file with this algorithm
sha256          Hashes the argument or file with this algorithm
address         Converts an address to another format
get-public-key  Get the public key from a message and its signature
new-key         Creates a new key for use with fuel-core
parse-secret    Parses a private key to view the associated public key
vanity          Generate a vanity address
help            Print this message or the help of the given subcommand(s)</p>
<p>Options:</p>
<p><code>-h</code>, <code>--help</code></p>
<p>Print help</p>
<p><code>-V</code>, <code>--version</code></p>
<p>Print version</p>
<p>EXAMPLES:</p>
<h1 id="hashes-an-argument-with-sha256"><a class="header" href="#hashes-an-argument-with-sha256">Hashes an argument with SHA256</a></h1>
<p>forc crypto sha256 test</p>
<h1 id="hashes-an-argument-with-keccak256"><a class="header" href="#hashes-an-argument-with-keccak256">Hashes an argument with Keccak256</a></h1>
<p>forc crypto keccak256 test</p>
<h1 id="hashes-a-file-path-with-sha256"><a class="header" href="#hashes-a-file-path-with-sha256">Hashes a file path with SHA256</a></h1>
<p>forc crypto sha256 {file}</p>
<h1 id="hashes-a-file-path-with-keccak256"><a class="header" href="#hashes-a-file-path-with-keccak256">Hashes a file path with Keccak256</a></h1>
<p>forc crypto keccak256 {file}</p>
<h1 id="convert-an-address-to-another-format"><a class="header" href="#convert-an-address-to-another-format">Convert an address to another format</a></h1>
<p>forc crypto address fuel12e0xwx34nfp7jrzvn9mp5qkac3yvp7h8fx37ghl7klf82vv2wkys6wd523</p>
<h1 id="creates-a-new-key-default-for-block-production"><a class="header" href="#creates-a-new-key-default-for-block-production">Creates a new key default for block production</a></h1>
<p>forc crypto new-key</p>
<h1 id="creates-a-new-key-for-peering"><a class="header" href="#creates-a-new-key-for-peering">Creates a new key for peering</a></h1>
<p>forc crypto new-key -k peering</p>
<h1 id="creates-a-new-key-for-block-production"><a class="header" href="#creates-a-new-key-for-block-production">Creates a new key for block production</a></h1>
<p>forc crypto new-key -k block-production</p>
<h1 id="parses-the-secret-of-a-block-production"><a class="header" href="#parses-the-secret-of-a-block-production">Parses the secret of a block production</a></h1>
<p>forc crypto parse-secret "f5204427d0ab9a311266c96a377f7c329cb8a41b9088225b6fcf40eefb423e28"</p>
<h1 id="parses-the-secret-of-a-peering"><a class="header" href="#parses-the-secret-of-a-peering">Parses the secret of a peering</a></h1>
<p>forc crypto parse-secret -k peering "f5204427d0ab9a311266c96a377f7c329cb8a41b9088225b6fcf40eefb423e28"</p>
<h1 id="get-the-public-key-from-a-message-and-its-signature"><a class="header" href="#get-the-public-key-from-a-message-and-its-signature">Get the public key from a message and its signature</a></h1>
<p>forc crypto get-public-key <br />
0x1eff08081394b72239a0cf7ff6b499213dcb7a338bedbd75d072d504588ef27a1f74d5ceb2f111ec02ede097fb09ed00aa9867922ed39299dae0b1afc0fa8661 <br />
"This is a message that is signed"</p>
<h1 id="generate-a-checksummed-vanity-address-with-a-given-prefix"><a class="header" href="#generate-a-checksummed-vanity-address-with-a-given-prefix">Generate a checksummed vanity address with a given prefix</a></h1>
<p>forc crypto vanity --starts-with "aaa"</p>
<h1 id="generate-a-checksummed-vanity-address-with-a-given-suffix"><a class="header" href="#generate-a-checksummed-vanity-address-with-a-given-suffix">Generate a checksummed vanity address with a given suffix</a></h1>
<p>forc crypto vanity --ends-with "aaa"</p>
<h1 id="generate-a-checksummed-vanity-address-with-a-given-prefix-and-suffix"><a class="header" href="#generate-a-checksummed-vanity-address-with-a-given-prefix-and-suffix">Generate a checksummed vanity address with a given prefix and suffix</a></h1>
<p>forc crypto vanity --starts-with "00" --ends-with "ff"</p>
<h1 id="generate-a-checksummed-vanity-address-with-a-given-regex-pattern"><a class="header" href="#generate-a-checksummed-vanity-address-with-a-given-regex-pattern">Generate a checksummed vanity address with a given regex pattern</a></h1>
<p>forc crypto vanity --regex "^00.*ff$"</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="forc-1"><a class="header" href="#forc-1">Forc</a></h1>
<p>Usage: forc-debug [OPTIONS] [API_URL]</p>
<p>Arguments:
[API_URL]  The URL of the Fuel Client GraphQL API [default: http://127.0.0.1:4000/graphql]</p>
<p>Options:</p>
<p><code>-s</code>, <code>--serve</code></p>
<p>Start the DAP server</p>
<p><code>-h</code>, <code>--help</code></p>
<p>Print help</p>
<p><code>-V</code>, <code>--version</code></p>
<p>Print version</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="forc-2"><a class="header" href="#forc-2">Forc</a></h1>
<p>Usage: forc-doc [OPTIONS]</p>
<p>Options:</p>
<p><code>-p</code>, <code>--path</code> &lt;<em>PATH</em>&gt;</p>
<p>Path to the project.</p>
<p>If not specified, current working directory will be used.</p>
<p><code>--document-private-items</code></p>
<p>Include non-public items in the documentation</p>
<p><code>--open</code></p>
<p>Open the docs in a browser after building them</p>
<p><code>--offline</code></p>
<p>Offline mode, prevents Forc from using the network when managing dependencies. Meaning it
will only try to use previously downloaded dependencies</p>
<p><code>--locked</code></p>
<p>Requires that the Forc.lock file is up-to-date. If the lock file is missing, or it needs
to be updated, Forc will exit with an error</p>
<p><code>--no-deps</code></p>
<p>Do not build documentation for dependencies</p>
<p><code>--ipfs-node</code> &lt;<em>IPFS_NODE</em>&gt;</p>
<p>The IPFS Node to use for fetching IPFS sources.</p>
<p>Possible values: FUEL, PUBLIC, LOCAL, &lt;GATEWAY_URL&gt;</p>
<p><code>--doc-path</code> &lt;<em>DOC_PATH</em>&gt;</p>
<p>The path to the documentation output directory.</p>
<p>If not specified, the default documentation output directory will be used.</p>
<p><code>--experimental</code> &lt;<em>EXPERIMENTAL</em>&gt;</p>
<p>Comma separated list of all experimental features that will be enabled</p>
<p>[possible values: new_encoding, references, const_generics, new_hashing]</p>
<p><code>--no-experimental</code> &lt;<em>NO_EXPERIMENTAL</em>&gt;</p>
<p>Comma separated list of all experimental features that will be disabled</p>
<p>[possible values: new_encoding, references, const_generics, new_hashing]</p>
<p><code>-s</code>, <code>--silent</code></p>
<p>Silent mode. Don't output any warnings or errors to the command line</p>
<p><code>-h</code>, <code>--help</code></p>
<p>Print help (see a summary with '-h')</p>
<p><code>-V</code>, <code>--version</code></p>
<p>Print version</p>
<p>EXAMPLES:</p>
<h1 id="build-the-docs-for-a-project-or-workspace-in-the-current-path"><a class="header" href="#build-the-docs-for-a-project-or-workspace-in-the-current-path">Build the docs for a project or workspace in the current path</a></h1>
<p>forc doc</p>
<h1 id="build-the-docs-for-a-project-or-workspace-in-the-current-path-and-open-it-in"><a class="header" href="#build-the-docs-for-a-project-or-workspace-in-the-current-path-and-open-it-in">Build the docs for a project or workspace in the current path and open it in</a></h1>
<p>the browser
forc doc --open</p>
<h1 id="build-the-docs-for-a-project-located-in-another-path"><a class="header" href="#build-the-docs-for-a-project-located-in-another-path">Build the docs for a project located in another path</a></h1>
<p>forc doc --path {path}</p>
<h1 id="build-the-docs-for-the-current-project-exporting-private-types"><a class="header" href="#build-the-docs-for-the-current-project-exporting-private-types">Build the docs for the current project exporting private types</a></h1>
<p>forc doc --document-private-items</p>
<h1 id="build-the-docs-offline-without-downloading-any-dependencies"><a class="header" href="#build-the-docs-offline-without-downloading-any-dependencies">Build the docs offline without downloading any dependencies</a></h1>
<p>forc doc --offline</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="forc-3"><a class="header" href="#forc-3">Forc</a></h1>
<p>Usage: forc-fmt [OPTIONS]</p>
<p>Options:</p>
<p><code>-c</code>, <code>--check</code></p>
<p>Run in 'check' mode.</p>
<ul>
<li>Exits with <code>0</code> if input is formatted correctly. - Exits with <code>1</code> and prints a diff if formatting is required.</li>
</ul>
<p><code>-p</code>, <code>--path</code> &lt;<em>PATH</em>&gt;</p>
<p>Path to the project.</p>
<p>If not specified, current working directory will be used.</p>
<p><code>-f</code>, <code>--file</code> &lt;<em>FILE</em>&gt;</p>
<p>Formats a single .sw file with the default settings. If not specified, current working directory will be formatted using a Forc.toml configuration</p>
<p><code>--experimental</code> &lt;<em>EXPERIMENTAL</em>&gt;</p>
<p>Comma separated list of all experimental features that will be enabled</p>
<p>[possible values: new_encoding, references, const_generics, new_hashing]</p>
<p><code>--no-experimental</code> &lt;<em>NO_EXPERIMENTAL</em>&gt;</p>
<p>Comma separated list of all experimental features that will be disabled</p>
<p>[possible values: new_encoding, references, const_generics, new_hashing]</p>
<p><code>-h</code>, <code>--help</code></p>
<p>Print help (see a summary with '-h')</p>
<p><code>-V</code>, <code>--version</code></p>
<p>Print version</p>
<p>EXAMPLES:</p>
<h1 id="run-the-formatter-in-check-mode-on-the-current-directory"><a class="header" href="#run-the-formatter-in-check-mode-on-the-current-directory">Run the formatter in check mode on the current directory</a></h1>
<p>forc fmt --check</p>
<h1 id="run-the-formatter-in-check-mode-on-the-current-directory-with-short-format"><a class="header" href="#run-the-formatter-in-check-mode-on-the-current-directory-with-short-format">Run the formatter in check mode on the current directory with short format</a></h1>
<p>forc fmt -c</p>
<h1 id="run-formatter-against-a-given-file"><a class="header" href="#run-formatter-against-a-given-file">Run formatter against a given file</a></h1>
<p>forc fmt --file {path}/src/main.sw</p>
<h1 id="run-formatter-against-a-given-file-with-short-format"><a class="header" href="#run-formatter-against-a-given-file-with-short-format">Run formatter against a given file with short format</a></h1>
<p>forc fmt -f {path}/src/main.sw</p>
<h1 id="run-formatter-against-a-given-dir"><a class="header" href="#run-formatter-against-a-given-dir">Run formatter against a given dir</a></h1>
<p>forc fmt --path {path}</p>
<h1 id="run-formatter-against-a-given-dir-with-short-format"><a class="header" href="#run-formatter-against-a-given-dir-with-short-format">Run formatter against a given dir with short format</a></h1>
<p>forc fmt -p {path}</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="forc-4"><a class="header" href="#forc-4">Forc</a></h1>
<p>Usage: forc-lsp</p>
<p>Options:</p>
<p><code>-h</code>, <code>--help</code></p>
<p>Print help</p>
<p><code>-V</code>, <code>--version</code></p>
<p>Print version</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mcp"><a class="header" href="#mcp">MCP</a></h1>
<p>Usage: forc-mcp [COMMAND]</p>
<p>Commands:
stdio  Run MCP server in STDIO mode
sse    Run MCP server in SSE mode
http   Run MCP server in HTTP streamable mode
help   Print this message or the help of the given subcommand(s)</p>
<p>Options:</p>
<p><code>-h</code>, <code>--help</code></p>
<p>Print help</p>
<p><code>-V</code>, <code>--version</code></p>
<p>Print version</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="forc-call-mcp"><a class="header" href="#forc-call-mcp">forc-call mcp</a></h1>
<p>The forc-call module provides MCP tools for interacting with deployed Fuel contracts, enabling AI assistants to call functions, inspect ABIs, transfer assets, and analyze execution traces.</p>
<h2 id="forc-call-mcp-tools"><a class="header" href="#forc-call-mcp-tools">forc-call mcp tools</a></h2>
<h3 id="call_contract"><a class="header" href="#call_contract">call_contract</a></h3>
<p>Call functions on deployed Fuel contracts with full support for complex types and execution modes.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>contract_id</code> (string) - Contract address to call</li>
<li><code>abi</code> (string) - Contract ABI (JSON string or URL)</li>
<li><code>function</code> (string) - Function name to call</li>
<li><code>function_args</code> (array) - Function arguments as encoded strings</li>
<li><code>mode</code> (string) - Execution mode: <code>dry-run</code> (default), <code>simulate</code>, or <code>live</code></li>
<li><code>node_url</code> (string, optional) - Custom node URL</li>
<li><code>signing_key</code> (string, optional) - Private key for live transactions</li>
<li><code>amount</code> (number, optional) - Asset amount for payable functions</li>
<li><code>asset_id</code> (string, optional) - Asset ID for transfers (default: native asset)</li>
<li><code>gas_price</code> (number, optional) - Gas price setting</li>
<li><code>verbosity</code> (number, optional) - Output verbosity level (0-3)</li>
</ul>
<p><strong>Example:</strong></p>
<pre><code class="language-json">{
  "tool": "call_contract",
  "parameters": {
    "contract_id": "0x1234567890abcdef...",
    "abi": "{\"functions\":[{\"name\":\"get_balance\",\"outputs\":[{\"type\":\"u64\"}]}]}",
    "function": "get_balance",
    "mode": "dry-run"
  }
}
</code></pre>
<h3 id="list_contract_functions"><a class="header" href="#list_contract_functions">list_contract_functions</a></h3>
<p>List all callable functions in a contract's ABI with example usage commands.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>contract_id</code> (string) - Contract address</li>
<li><code>abi</code> (string) - Contract ABI (JSON string or URL)</li>
</ul>
<p><strong>Example:</strong></p>
<pre><code class="language-json">{
  "tool": "list_contract_functions", 
  "parameters": {
    "contract_id": "0x1234567890abcdef...",
    "abi": "https://api.fuel.network/contract-abi.json"
  }
}
</code></pre>
<h3 id="transfer_assets"><a class="header" href="#transfer_assets">transfer_assets</a></h3>
<p>Transfer assets directly to addresses or contracts (live mode only).</p>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>signing_key</code> (string) - Private key for transaction signing</li>
<li><code>recipient</code> (string) - Recipient address or contract ID</li>
<li><code>amount</code> (number) - Transfer amount</li>
<li><code>asset_id</code> (string, optional) - Asset ID (default: native asset)</li>
<li><code>node_url</code> (string, optional) - Custom node URL</li>
<li><code>verbosity</code> (number, optional) - Output verbosity level</li>
</ul>
<p><strong>Example:</strong></p>
<pre><code class="language-json">{
  "tool": "transfer_assets",
  "parameters": {
    "recipient": "0x5678901234abcdef...",
    "amount": 1000,
    "signing_key": "your-private-key"
  }
}
</code></pre>
<h3 id="get_execution_trace"><a class="header" href="#get_execution_trace">get_execution_trace</a></h3>
<p>Generate human-readable execution traces from contract call results.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>trace_events</code> (array) - Trace events from CallResponse</li>
<li><code>total_gas</code> (number) - Total gas used</li>
<li><code>labels</code> (object, optional) - Contract address to name mappings</li>
</ul>
<p><strong>Example:</strong></p>
<pre><code class="language-json">{
  "tool": "get_execution_trace",
  "parameters": {
    "trace_events": [/* events from call result */],
    "total_gas": 50000,
    "labels": {
      "0x1234...": "MainContract",
      "0x5678...": "TokenContract"
    }
  }
}
</code></pre>
<h2 id="forc-call-mcp-resources"><a class="header" href="#forc-call-mcp-resources">forc-call mcp resources</a></h2>
<p>The forc-call module provides comprehensive documentation resources accessible through the MCP protocol:</p>
<ul>
<li>
<p><strong>Type Encoding Reference</strong> (<code>forc-call://type-encoding-reference</code>)</p>
<ul>
<li>Complete guide for encoding Sway types for function arguments</li>
<li>See: <a href="forc/plugins/forc_mcp/forc_call_tool/./type_encoding_reference.html">type_encoding_reference.md</a></li>
</ul>
</li>
<li>
<p><strong>Common Commands</strong> (<code>forc-call://examples/common-commands</code>)</p>
<ul>
<li>Examples of typical usage patterns and tool invocations</li>
<li>See: <a href="forc/plugins/forc_mcp/forc_call_tool/./common_commands.html">common_commands.md</a></li>
</ul>
</li>
<li>
<p><strong>Contract Samples</strong> (<code>forc-call://examples/contract-samples</code>)</p>
<ul>
<li>Real contract examples with MCP tool commands</li>
<li>See: <a href="forc/plugins/forc_mcp/forc_call_tool/./contract_samples.html">contract_samples.md</a></li>
</ul>
</li>
</ul>
<h3 id="accessing-resources"><a class="header" href="#accessing-resources">Accessing resources</a></h3>
<p>Resources can be accessed through the MCP resources API:</p>
<ol>
<li>Use <code>list_resources</code> to see all available resources</li>
<li>Use <code>read_resource</code> with the URIs above to access specific documentation</li>
<li>Resources are served by the MCP server at runtime for AI assistants</li>
</ol>
<h2 id="execution-modes"><a class="header" href="#execution-modes">Execution Modes</a></h2>
<p>The forc-call module supports three execution modes:</p>
<h3 id="dry-run-default"><a class="header" href="#dry-run-default">dry-run (default)</a></h3>
<ul>
<li>Validates the transaction without executing</li>
<li>Returns expected outputs without modifying state</li>
<li>No signing key required</li>
<li>Useful for testing and validation</li>
</ul>
<h3 id="simulate"><a class="header" href="#simulate">simulate</a></h3>
<ul>
<li>Executes the transaction in a simulated environment</li>
<li>Shows state changes and gas usage</li>
<li>No signing key required</li>
<li>Provides detailed execution trace</li>
</ul>
<h3 id="live"><a class="header" href="#live">live</a></h3>
<ul>
<li>Executes the transaction on the blockchain</li>
<li>Requires a signing key</li>
<li>Modifies blockchain state permanently</li>
<li>Returns transaction ID and receipts</li>
</ul>
<h2 id="type-encoding-1"><a class="header" href="#type-encoding-1">Type Encoding</a></h2>
<p>When calling contract functions, arguments must be encoded according to their Sway types. Refer to the Type Encoding Reference resource for detailed information on encoding various types including:</p>
<ul>
<li>Basic types (bool, integers)</li>
<li>Addresses and ContractId</li>
<li>Arrays and vectors</li>
<li>Strings</li>
<li>Structs and enums</li>
<li>Complex nested types</li>
</ul>
<h2 id="error-handling-1"><a class="header" href="#error-handling-1">Error Handling</a></h2>
<p>The module provides detailed error messages for common issues:</p>
<ul>
<li>Invalid contract addresses</li>
<li>ABI parsing errors</li>
<li>Type encoding mismatches</li>
<li>Network connectivity issues</li>
<li>Insufficient funds or gas</li>
<li>Function not found in ABI</li>
</ul>
<h2 id="best-practices-1"><a class="header" href="#best-practices-1">Best Practices</a></h2>
<ol>
<li>Always use <code>dry-run</code> mode first to validate calls</li>
<li>Check function signatures with <code>list_contract_functions</code> before calling</li>
<li>Use the type encoding reference for complex arguments</li>
<li>Provide descriptive labels in execution traces for better readability</li>
<li>Handle errors gracefully and provide meaningful feedback</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="forc-5"><a class="header" href="#forc-5">Forc</a></h1>
<p>Usage: forc-migrate <COMMAND></p>
<p>Commands:
show   Show the upcoming breaking change features and their migration steps
check  Check the project for code that needs to be migrated
run    Migrate the project
help   Print this message or the help of the given subcommand(s)</p>
<p>Options:</p>
<p><code>-h</code>, <code>--help</code></p>
<p>Print help</p>
<p><code>-V</code>, <code>--version</code></p>
<p>Print version</p>
<p>Examples:</p>
<h1 id="show-the-upcoming-breaking-change-features-and-their-migration-steps"><a class="header" href="#show-the-upcoming-breaking-change-features-and-their-migration-steps">Show the upcoming breaking change features and their migration steps</a></h1>
<p>forc migrate show</p>
<h1 id="check-the-project-in-the-current-path"><a class="header" href="#check-the-project-in-the-current-path">Check the project in the current path</a></h1>
<p>forc migrate check</p>
<h1 id="check-the-project-located-in-another-path"><a class="header" href="#check-the-project-located-in-another-path">Check the project located in another path</a></h1>
<p>forc migrate check --path {path}</p>
<h1 id="migrate-the-project-in-the-current-path"><a class="header" href="#migrate-the-project-in-the-current-path">Migrate the project in the current path</a></h1>
<p>forc migrate run</p>
<h1 id="migrate-the-project-located-in-another-path"><a class="header" href="#migrate-the-project-located-in-another-path">Migrate the project located in another path</a></h1>
<p>forc migrate run --path {path}</p>
<h1 id="migrate-the-project-offline-without-downloading-any-dependencies"><a class="header" href="#migrate-the-project-offline-without-downloading-any-dependencies">Migrate the project offline without downloading any dependencies</a></h1>
<p>forc migrate run --offline<!-- markdownlint-disable MD041 --></p>
<h1 id="migrating-sway-projects"><a class="header" href="#migrating-sway-projects">Migrating Sway projects</a></h1>
<p><code>forc-migrate</code> guides you through breaking changes between Sway versions. It fully or semiautomatically adapts your code, making it compatible with the next breaking change version of Sway.</p>
<p><code>forc-migrate</code> migrates the code to the <em>next</em> breaking change version of Sway. That means, if you want to migrate to, e.g., Sway v0.<strong>67</strong>.0, you will need to use the <em>latest v0.<strong>66</strong>.x</em> version of the <code>forc-migrate</code>.</p>
<p>For example, let's say that your Sway project is on version <em>v0.66.1</em>, and that the latest v0.66 version is <em>v0.66.42</em>. You should first update your Fuel toolchain to version <em>v0.66.42</em> of <code>forc</code>, and compile your project with that version:</p>
<pre><code class="language-text">fuelup component add forc@0.66.42
</code></pre>
<p>Sway guarantees that all the versions with the same minor version, <em>0.66</em> in the above example, are compatible. That means that the latest patch version, <em>0.66.42</em> in the example, will correctly compile your project.</p>
<h2 id="showing-the-breaking-changes"><a class="header" href="#showing-the-breaking-changes">Showing the breaking changes</a></h2>
<p>Once you've installed the latest non-breaking version of <code>forc-migrate</code>, use the <code>show</code> command to make yourself familiar with the upcoming breaking changes:</p>
<pre><code class="language-text">forc migrate show
</code></pre>
<p>A typical output of the <code>show</code> command will look like this:</p>
<pre><code class="language-text">Breaking change features:
  - storage_domains    (https://github.com/FuelLabs/sway/issues/6701)
  - references         (https://github.com/FuelLabs/sway/issues/5063)

Migration steps (1 manual and 1 semiautomatic):
storage_domains
  [M] Review explicitly defined slot keys in storage declarations (`in` keywords)

references
  [S] Replace `ref mut` function parameters with `&amp;mut`

Experimental feature flags:
- for Forc.toml:  experimental = { storage_domains = true, references = true }
- for CLI:        --experimental storage_domains,references
</code></pre>
<p>The output will contain:</p>
<ul>
<li>the upcoming breaking change features, <code>storage_domains</code> and <code>references</code> in this example,</li>
<li>their tracking issues on GitHub, with detailed migration guides,</li>
<li>and the migration steps potentially required to migrate existing code.</li>
</ul>
<p>The migration steps can be <em>manual</em>, <em>semiautomatic</em>, or fully <em>automatic</em>. They are marked in the output with <code>[M]</code>, <code>[S]</code>, and <code>[A]</code>, respectively.</p>
<p>The <code>show</code> command will also provide experimental feature flags that will be needed during the migration, as explained in the next chapter.</p>
<h2 id="migrating-a-single-sway-project"><a class="header" href="#migrating-a-single-sway-project">Migrating a single Sway project</a></h2>
<p>Let's assume that we want to migrate a Sway project called <code>my_project</code> that depends on <code>std</code> and a <code>third_party_lib</code>.</p>
<p>First, we will go to the folder that contains <code>my_project</code>, e.g.: <code>cd my_project</code>. All of the upcoming CLI commands assume that we are running the <code>forc-migrate</code> tool within the <code>my_project</code> folder.</p>
<p>Before migrating the code, make sure that the project builds without any errors by running:</p>
<pre><code class="language-text">forc build
</code></pre>
<h3 id="check-the-migration-summary"><a class="header" href="#check-the-migration-summary">Check the migration summary</a></h3>
<p>Next, let's <code>check</code> the project first. The <code>check</code> command will dry-run the migration steps. It will not do any changes in code, but will provide a detailed information of all the places in code that need to be either reviewed or changed during the migration process. The <code>check</code> command will also provide a rough time estimate for the migration.</p>
<pre><code class="language-text">forc migrate check
</code></pre>
<p>The output of the <code>check</code> command will end in a summary of the migration effort, containing:</p>
<ul>
<li>the number of occurrences of a particular migration step in the project's code,</li>
<li>the rough migration effort estimate for each migration step,</li>
<li>and the rough total migration effort.</li>
</ul>
<pre><code class="language-text">Migration effort:

storage_domains
  [M] Review explicitly defined slot keys in storage declarations (`in` keywords)
      Occurrences:     3    Migration effort (hh::mm): ~00:06

references
  [S] Replace `ref mut` function parameters with `&amp;mut`
      Occurrences:    18    Migration effort (hh::mm): ~01:30

Total migration effort (hh::mm): ~01:36
</code></pre>
<p>Before the summary, instructions will be shown for each migration step. A typical instruction output for a single migration step will contain:</p>
<ul>
<li>the name of the step,</li>
<li>the places in code affected by the migration step,</li>
<li>and the short help with a link to the detailed migration guide.</li>
</ul>
<pre><code class="language-text">info: [references] Replace `ref mut` function parameters with `&amp;mut`
  --&gt; my_project/src/main.sw:30:51
   |
...
30 | fn ref_mut_fn(ref mut x: u64) {}
   |               ---------
...
35 | fn another_ref_mut_fn(ref mut arg: S) {}
   |                       -----------
   |
   = help: Migration will replace `ref mut` function parameters with `&amp;mut`.
   = help: E.g., `ref mut x: u64` will become `x: &amp;mut u64`.
   = help:  
   = help: After the migration, you will still need to:
   = help: - change function callers, by adding `&amp;mut` to passed parameters.
   = help: - change function bodies, by dereferencing (`*`) parameters where needed.
   = help:  
   = help: For a detailed migration guide see: https://github.com/FuelLabs/sway/issues/5063
</code></pre>
<h3 id="update-dependencies-1"><a class="header" href="#update-dependencies-1">Update dependencies</a></h3>
<p>Before running the migrations on the project itself, <strong>first update the project dependencies to the versions that use the next Sway breaking change version</strong>.</p>
<p>In our example, the <code>my_project</code>'s <code>Forc.toml</code> file will have the <code>[dependencies]</code> section similar to this one:</p>
<pre><code class="language-toml">[dependencies]
std = { git = "https://github.com/FuelLabs/sway", tag = "v0.66.1" }
third_party_lib = { git = "https://github.com/ThirdParty/swaylib", tag = "v1.0.0" }
</code></pre>
<p>Assuming that the <code>third_party_lib</code> version compatible with Sway v0.67.0 is the version v2.0.0 we will end up in the following changes:</p>
<pre><code class="language-toml">[dependencies]
# Changed v0.66.1 -&gt; v0.67.0
std = { git = "https://github.com/FuelLabs/sway", tag = "v0.67.0" }
# Changed v1.0.0  -&gt; v2.0.0
third_party_lib = { git = "https://github.com/ThirdParty/swaylib", tag = "v2.0.0" }
</code></pre>
<p>Run <code>forc build</code> to make sure that the project still compiles. <strong>At this point, it is very likely that you will need to compile the project with the experimental features turned on.</strong> The reason is the likelihood that either the new <code>std</code> or the <code>third_party_lib</code> uses the new Sway features.</p>
<p>To compile the project with experimental features, you can take the feature flags from the <code>forc migrate show</code> output, and place them either in the <code>[build-profile]</code> section of the projects <code>Forc.toml</code> file, or pass them to <code>forc build</code> via the command line.</p>
<pre><code class="language-text">Experimental feature flags:
- for Forc.toml:  experimental = { storage_domains = true, references = true }
- for CLI:        --experimental storage_domains,references
</code></pre>
<p>In the remaining part of this tutorial, we will be passing the feature flags via the command line. E.g.:</p>
<pre><code class="language-text">forc build --experimental storage_domains,references
</code></pre>
<h3 id="run-the-migrations"><a class="header" href="#run-the-migrations">Run the migrations</a></h3>
<p>Once the <code>my_project</code> successfully builds with updated dependencies, we can <code>run</code> the migration steps on it. E.g.:</p>
<pre><code class="language-text">forc migrate run --experimental storage_domains,references
</code></pre>
<p>The <code>run</code> command will execute the migration steps, and guide you through the migration process. For each migration step, the output of the step can be one of the following:</p>
<div class="table-wrapper"><table><thead><tr><th>Step output</th><th>Meaning</th></tr></thead><tbody>
<tr><td>Checked</td><td>The step is executed and does not require any changes in code. No action needed.</td></tr>
<tr><td>Review</td><td>The step suggests a manual code review.</td></tr>
<tr><td>Changing</td><td>The step is automatically changing the code. There might be additional manual actions needed.</td></tr>
</tbody></table>
</div>
<p>At the end of the <code>run</code>, the migration will either guide you to:</p>
<ul>
<li><code>Continue</code> the migration process by performing the manual actions and re-running the <code>forc migrate run</code> afterwards,</li>
<li>or will mark the migration process as <code>Finished</code>. At this point, your project will be compatible with the next breaking change version of Sway.</li>
</ul>
<p><code>forc migrate</code>, same like <code>forc fmt</code>, does its best to preserve the positions of comments in the modified code. This is a challenging task, especially if migration steps remove parts of the code. <strong>It is a good practice to always <code>diff</code> the changes done within migration steps and check if the comments are placed where expected.</strong></p>
<h2 id="migrating-workspaces"><a class="header" href="#migrating-workspaces">Migrating workspaces</a></h2>
<p>To migrate a workspace, you will need to migrate each workspace member separately, following the above procedure. The projects should be migrated in order of their dependencies.</p>
<blockquote>
<p><strong>Note</strong>: There is a know limitation when running <code>forc migrate</code> on projects that are listed as workspace members. <code>forc migrate</code> will run, but possibly not find all the occurrences in code that need to be migrated. Therefore, <strong>before running migrations on projects that are workspace members, remove them temporarily from the list of workspace <code>members</code></strong>.</p>
</blockquote>
<h2 id="additional-after-migration-steps"><a class="header" href="#additional-after-migration-steps">Additional after-migration steps</a></h2>
<p>There are some additional manual steps that might be needed after the migration.</p>
<p>E.g., if tests use hardcoded contract IDs, those need to be changed, because the new version of Sway will, very likely, produce different bytecode.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="forc-6"><a class="header" href="#forc-6">Forc</a></h1>
<p>Usage: forc-node [OPTIONS] <COMMAND></p>
<p>Commands:
local     Starts a local node for development purposes
testnet   Starts a node that will connect to latest testnet
ignition  Starts a node that will connect to ignition network
help      Print this message or the help of the given subcommand(s)</p>
<p>Options:</p>
<p><code>--dry-run</code></p>
<p>Print the fuel-core command without running it</p>
<p><code>-h</code>, <code>--help</code></p>
<p>Print help</p>
<p><code>-V</code>, <code>--version</code></p>
<p>Print version</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="forc-7"><a class="header" href="#forc-7">Forc</a></h1>
<p>Usage: forc-publish [OPTIONS]</p>
<p>Options:</p>
<p><code>--token</code> &lt;<em>TOKEN</em>&gt;</p>
<p>Token to use when uploading</p>
<p><code>--registry-url</code> &lt;<em>REGISTRY_URL</em>&gt;</p>
<p>The registry URL to use [default: https://api.forc.pub]</p>
<p><code>-h</code>, <code>--help</code></p>
<p>Print help</p>
<p><code>-V</code>, <code>--version</code></p>
<p>Print version</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
