<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>The Sway Programming Language</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="index.html">The Sway Programming Language</a></li><li class="chapter-item expanded "><a href="introduction/index.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="introduction/getting_started.html"><strong aria-hidden="true">1.1.</strong> Getting Started</a></li><li class="chapter-item expanded "><a href="introduction/fuel_toolchain.html"><strong aria-hidden="true">1.2.</strong> The Fuel Toolchain</a></li><li class="chapter-item expanded "><a href="introduction/forc_project.html"><strong aria-hidden="true">1.3.</strong> A Forc Project</a></li><li class="chapter-item expanded "><a href="introduction/standard_library.html"><strong aria-hidden="true">1.4.</strong> Standard Library</a></li><li class="chapter-item expanded "><a href="introduction/core_library.html"><strong aria-hidden="true">1.5.</strong> Core Library</a></li><li class="chapter-item expanded "><a href="introduction/sway_standards.html"><strong aria-hidden="true">1.6.</strong> Sway Language Standards</a></li></ol></li><li class="chapter-item expanded "><a href="examples/index.html"><strong aria-hidden="true">2.</strong> Examples</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="examples/counter.html"><strong aria-hidden="true">2.1.</strong> Counter</a></li><li class="chapter-item expanded "><a href="examples/fizzbuzz.html"><strong aria-hidden="true">2.2.</strong> FizzBuzz</a></li><li class="chapter-item expanded "><a href="examples/wallet_smart_contract.html"><strong aria-hidden="true">2.3.</strong> Wallet Smart Contract</a></li><li class="chapter-item expanded "><a href="examples/liquidity_pool.html"><strong aria-hidden="true">2.4.</strong> Liquidity Pool</a></li><li class="chapter-item expanded "><a href="examples/sway_applications.html"><strong aria-hidden="true">2.5.</strong> Sway Applications</a></li></ol></li><li class="chapter-item expanded "><a href="sway-program-types/index.html"><strong aria-hidden="true">3.</strong> Program Types</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="sway-program-types/smart_contracts.html"><strong aria-hidden="true">3.1.</strong> Contracts</a></li><li class="chapter-item expanded "><a href="sway-program-types/libraries.html"><strong aria-hidden="true">3.2.</strong> Libraries</a></li><li class="chapter-item expanded "><a href="sway-program-types/scripts.html"><strong aria-hidden="true">3.3.</strong> Scripts</a></li><li class="chapter-item expanded "><a href="sway-program-types/predicates.html"><strong aria-hidden="true">3.4.</strong> Predicates</a></li></ol></li><li class="chapter-item expanded "><a href="basics/index.html"><strong aria-hidden="true">4.</strong> Sway Language Basics</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="basics/variables.html"><strong aria-hidden="true">4.1.</strong> Variables</a></li><li class="chapter-item expanded "><a href="basics/built_in_types.html"><strong aria-hidden="true">4.2.</strong> Built-in Types</a></li><li class="chapter-item expanded "><a href="basics/commonly_used_library_types.html"><strong aria-hidden="true">4.3.</strong> Commonly Used Library Types</a></li><li class="chapter-item expanded "><a href="basics/blockchain_types.html"><strong aria-hidden="true">4.4.</strong> Blockchain Types</a></li><li class="chapter-item expanded "><a href="basics/converting_types.html"><strong aria-hidden="true">4.5.</strong> Converting Types</a></li><li class="chapter-item expanded "><a href="basics/functions.html"><strong aria-hidden="true">4.6.</strong> Functions</a></li><li class="chapter-item expanded "><a href="basics/structs_tuples_and_enums.html"><strong aria-hidden="true">4.7.</strong> Structs, Tuples, and Enums</a></li><li class="chapter-item expanded "><a href="basics/methods_and_associated_functions.html"><strong aria-hidden="true">4.8.</strong> Methods and Associated Functions</a></li><li class="chapter-item expanded "><a href="basics/constants.html"><strong aria-hidden="true">4.9.</strong> Constants</a></li><li class="chapter-item expanded "><a href="basics/comments_and_logging.html"><strong aria-hidden="true">4.10.</strong> Comments and Logging</a></li><li class="chapter-item expanded "><a href="basics/control_flow.html"><strong aria-hidden="true">4.11.</strong> Control Flow</a></li></ol></li><li class="chapter-item expanded "><a href="blockchain-development/index.html"><strong aria-hidden="true">5.</strong> Blockchain Development with Sway</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="blockchain-development/hashing_and_cryptography.html"><strong aria-hidden="true">5.1.</strong> Hashing and Cryptography</a></li><li class="chapter-item expanded "><a href="blockchain-development/storage.html"><strong aria-hidden="true">5.2.</strong> Contract Storage</a></li><li class="chapter-item expanded "><a href="blockchain-development/purity.html"><strong aria-hidden="true">5.3.</strong> Function Purity</a></li><li class="chapter-item expanded "><a href="blockchain-development/identifiers.html"><strong aria-hidden="true">5.4.</strong> Identifiers</a></li><li class="chapter-item expanded "><a href="blockchain-development/native_assets.html"><strong aria-hidden="true">5.5.</strong> Native Assets</a></li><li class="chapter-item expanded "><a href="blockchain-development/access_control.html"><strong aria-hidden="true">5.6.</strong> Access Control</a></li><li class="chapter-item expanded "><a href="blockchain-development/calling_contracts.html"><strong aria-hidden="true">5.7.</strong> Calling Contracts</a></li><li class="chapter-item expanded "><a href="blockchain-development/external_code.html"><strong aria-hidden="true">5.8.</strong> External Code</a></li></ol></li><li class="chapter-item expanded "><a href="advanced/index.html"><strong aria-hidden="true">6.</strong> Advanced Concepts</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="advanced/advanced_types.html"><strong aria-hidden="true">6.1.</strong> Advanced Types</a></li><li class="chapter-item expanded "><a href="advanced/advanced_storage.html"><strong aria-hidden="true">6.2.</strong> Advanced Storage</a></li><li class="chapter-item expanded "><a href="advanced/generic_types.html"><strong aria-hidden="true">6.3.</strong> Generic Types</a></li><li class="chapter-item expanded "><a href="advanced/traits.html"><strong aria-hidden="true">6.4.</strong> Traits</a></li><li class="chapter-item expanded "><a href="advanced/associated_types.html"><strong aria-hidden="true">6.5.</strong> Associated Types</a></li><li class="chapter-item expanded "><a href="advanced/generics_and_trait_constraints.html"><strong aria-hidden="true">6.6.</strong> Generics and Trait Constraints</a></li><li class="chapter-item expanded "><a href="advanced/assembly.html"><strong aria-hidden="true">6.7.</strong> Assembly</a></li><li class="chapter-item expanded "><a href="advanced/never_type.html"><strong aria-hidden="true">6.8.</strong> Never Type</a></li></ol></li><li class="chapter-item expanded "><a href="common-collections/index.html"><strong aria-hidden="true">7.</strong> Common Collections</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="common-collections/vec.html"><strong aria-hidden="true">7.1.</strong> Vectors on the Heap</a></li><li class="chapter-item expanded "><a href="common-collections/storage_vec.html"><strong aria-hidden="true">7.2.</strong> Storage Vectors</a></li><li class="chapter-item expanded "><a href="common-collections/storage_map.html"><strong aria-hidden="true">7.3.</strong> Storage Maps</a></li></ol></li><li class="chapter-item expanded "><a href="testing/index.html"><strong aria-hidden="true">8.</strong> Testing</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="testing/unit-testing.html"><strong aria-hidden="true">8.1.</strong> Unit Testing</a></li><li class="chapter-item expanded "><a href="testing/testing-with-rust.html"><strong aria-hidden="true">8.2.</strong> Testing with Rust</a></li></ol></li><li class="chapter-item expanded "><a href="debugging/index.html"><strong aria-hidden="true">9.</strong> Debugging</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="debugging/debugging_with_cli.html"><strong aria-hidden="true">9.1.</strong> Debugging with CLI</a></li><li class="chapter-item expanded "><a href="debugging/debugging_with_ide.html"><strong aria-hidden="true">9.2.</strong> Debugging with IDE</a></li></ol></li><li class="chapter-item expanded "><a href="lsp/index.html"><strong aria-hidden="true">10.</strong> Sway LSP</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="lsp/installation.html"><strong aria-hidden="true">10.1.</strong> Installation</a></li><li class="chapter-item expanded "><a href="lsp/features.html"><strong aria-hidden="true">10.2.</strong> Features</a></li><li class="chapter-item expanded "><a href="lsp/troubleshooting.html"><strong aria-hidden="true">10.3.</strong> Troubleshooting</a></li></ol></li><li class="chapter-item expanded "><a href="reference/index.html"><strong aria-hidden="true">11.</strong> Sway Reference</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="reference/sway_libs.html"><strong aria-hidden="true">11.1.</strong> Sway Libraries</a></li><li class="chapter-item expanded "><a href="reference/compiler_intrinsics.html"><strong aria-hidden="true">11.2.</strong> Compiler Intrinsics</a></li><li class="chapter-item expanded "><a href="reference/attributes.html"><strong aria-hidden="true">11.3.</strong> Attributes</a></li><li class="chapter-item expanded "><a href="reference/style_guide.html"><strong aria-hidden="true">11.4.</strong> Style Guide</a></li><li class="chapter-item expanded "><a href="reference/known_issues_and_workarounds.html"><strong aria-hidden="true">11.5.</strong> Known Issues and Workarounds</a></li><li class="chapter-item expanded "><a href="reference/undefined_behavior.html"><strong aria-hidden="true">11.6.</strong> Behavior Considered Undefined</a></li><li class="chapter-item expanded "><a href="reference/solidity_differences.html"><strong aria-hidden="true">11.7.</strong> Differences From Solidity</a></li><li class="chapter-item expanded "><a href="reference/rust_differences.html"><strong aria-hidden="true">11.8.</strong> Differences From Rust</a></li><li class="chapter-item expanded "><a href="reference/contributing_to_sway.html"><strong aria-hidden="true">11.9.</strong> Contributing To Sway</a></li><li class="chapter-item expanded "><a href="reference/keywords.html"><strong aria-hidden="true">11.10.</strong> Keywords</a></li></ol></li><li class="chapter-item expanded "><a href="forc/index.html"><strong aria-hidden="true">12.</strong> Forc Reference</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="forc/manifest_reference.html"><strong aria-hidden="true">12.1.</strong> Manifest Reference</a></li><li class="chapter-item expanded "><a href="forc/workspaces.html"><strong aria-hidden="true">12.2.</strong> Workspaces</a></li><li class="chapter-item expanded "><a href="forc/dependencies.html"><strong aria-hidden="true">12.3.</strong> Dependencies</a></li><li class="chapter-item expanded "><a href="forc/commands/index.html"><strong aria-hidden="true">12.4.</strong> Commands</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="forc/commands/forc_addr2line.html"><strong aria-hidden="true">12.4.1.</strong> forc addr2line</a></li><li class="chapter-item expanded "><a href="forc/commands/forc_build.html"><strong aria-hidden="true">12.4.2.</strong> forc build</a></li><li class="chapter-item expanded "><a href="forc/commands/forc_check.html"><strong aria-hidden="true">12.4.3.</strong> forc check</a></li><li class="chapter-item expanded "><a href="forc/commands/forc_clean.html"><strong aria-hidden="true">12.4.4.</strong> forc clean</a></li><li class="chapter-item expanded "><a href="forc/commands/forc_completions.html"><strong aria-hidden="true">12.4.5.</strong> forc completions</a></li><li class="chapter-item expanded "><a href="forc/commands/forc_contract-id.html"><strong aria-hidden="true">12.4.6.</strong> forc contract-id</a></li><li class="chapter-item expanded "><a href="forc/commands/forc_init.html"><strong aria-hidden="true">12.4.7.</strong> forc init</a></li><li class="chapter-item expanded "><a href="forc/commands/forc_new.html"><strong aria-hidden="true">12.4.8.</strong> forc new</a></li><li class="chapter-item expanded "><a href="forc/commands/forc_parse-bytecode.html"><strong aria-hidden="true">12.4.9.</strong> forc parse-bytecode</a></li><li class="chapter-item expanded "><a href="forc/commands/forc_plugins.html"><strong aria-hidden="true">12.4.10.</strong> forc plugins</a></li><li class="chapter-item expanded "><a href="forc/commands/forc_predicate-root.html"><strong aria-hidden="true">12.4.11.</strong> forc predicate-root</a></li><li class="chapter-item expanded "><a href="forc/commands/forc_test.html"><strong aria-hidden="true">12.4.12.</strong> forc test</a></li><li class="chapter-item expanded "><a href="forc/commands/forc_update.html"><strong aria-hidden="true">12.4.13.</strong> forc update</a></li><li class="chapter-item expanded "><a href="forc/commands/forc_template.html"><strong aria-hidden="true">12.4.14.</strong> forc template</a></li></ol></li><li class="chapter-item expanded "><a href="forc/plugins/index.html"><strong aria-hidden="true">12.5.</strong> Plugins</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="forc/plugins/forc_client/index.html"><strong aria-hidden="true">12.5.1.</strong> forc client</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="forc/plugins/forc_client/forc_deploy.html"><strong aria-hidden="true">12.5.1.1.</strong> forc deploy</a></li><li class="chapter-item expanded "><a href="forc/plugins/forc_client/forc_run.html"><strong aria-hidden="true">12.5.1.2.</strong> forc run</a></li><li class="chapter-item expanded "><a href="forc/plugins/forc_client/forc_submit.html"><strong aria-hidden="true">12.5.1.3.</strong> forc submit</a></li></ol></li><li class="chapter-item expanded "><a href="forc/plugins/forc_crypto.html"><strong aria-hidden="true">12.5.2.</strong> forc crypto</a></li><li class="chapter-item expanded "><a href="forc/plugins/forc_debug.html"><strong aria-hidden="true">12.5.3.</strong> forc debug</a></li><li class="chapter-item expanded "><a href="forc/plugins/forc_doc.html"><strong aria-hidden="true">12.5.4.</strong> forc doc</a></li><li class="chapter-item expanded "><a href="forc/plugins/forc_explore.html"><strong aria-hidden="true">12.5.5.</strong> forc explore</a></li><li class="chapter-item expanded "><a href="forc/plugins/forc_fmt.html"><strong aria-hidden="true">12.5.6.</strong> forc fmt</a></li><li class="chapter-item expanded "><a href="forc/plugins/forc_lsp.html"><strong aria-hidden="true">12.5.7.</strong> forc lsp</a></li></ol></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Sway Programming Language</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/FuelLabs/sway" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="the-sway-programming-language"><a class="header" href="#the-sway-programming-language">The Sway Programming Language</a></h1>
<p>Welcome to the Sway programming language book ðŸŒ´.</p>
<p><strong>Q: Hi! What is Sway?</strong></p>
<p>Sway is a domain-specific programming language for implementing smart contracts on blockchain platforms, most notably for the <a href="https://docs.fuel.network/docs/specs/fuel-vm/">Fuel Virtual Machine (Fuel VM)</a>.</p>
<p>Heavily inspired by <a href="https://doc.rust-lang.org/book/">Rust</a>'s approach to systems programming, Sway aims to bring modern programming language features and tooling to smart contract development whilst retaining performance, fine grained control and making extensive use of static analysis to prevent common security issues.</p>
<p><strong>Q: What does &quot;domain-specific&quot; mean?</strong></p>
<p>Sway is specifically made to be used within a blockchain environment, which behaves very differently than traditional computers.
This domain specific design permits it to make the right decisions about trade-offs at every level of the stack, enabling you to write fast, secure and cost effective smart contracts with features suited to your specific needs.</p>
<p><strong>Q: Why not use Solidity?</strong></p>
<p>Solidity is a venerable pioneer but it suffers from being tied to a lot of the historical quirks of the EVM.
It lacks common features programmers have come to expect, has a relatively inexpressive type system, and it lacks a unified tooling ecosystem.</p>
<p>In Sway, we let you design smart contracts with a full modern box of tools.
You get a fully featured language with generics, algebraic types and trait based polymorphism.
You also get an integrated, unified and easy to use toolchain with code completion LSP server, formatter, documentation generation and everything you need to run and deploy your contracts so that nothing comes between you and implementing what you want.</p>
<p>Our expressive type system allows you to catch semantic mistakes, we provide good defaults and we do extensive static analysis checks (such as enforcing the <a href="./blockchain-development/calling_contracts.html#cei-pattern-violation-static-analysis">Checks, Effects, Interactions</a> pattern) so that you can make sure you write secure and correct code at compile time.</p>
<p><strong>Q: Why not use Rust?</strong></p>
<p>Whilst Rust is a great systems programming language (and Sway itself is written in Rust), it isn't suited for smart contract development.</p>
<p>Rust shines because it can use zero-cost abstractions and its sophisticated borrow-checker memory model to achieve impressive runtime performance for complex programs without a garbage collector.</p>
<p>On a blockchain, cost of execution and deployment is the scarce resource.
Memory usage is low and execution time is short.
This makes complex memory management in general much too expensive to be worthwhile and Rust's borrow checker a burden with no upside.</p>
<p>General purpose programming languages in general are ill suited to this environment because their design has to assume execution on a general-purpose computing environment.</p>
<p>Sway attempts to bring all the other advantages of Rust, including its modern type system, approach to safety and good defaults to smart contract developers by providing familiar syntax and features adapted to the specific needs of the blockchain environment.</p>
<p><strong>Q: I don't know Rust or Solidity. Can I still learn Sway?</strong></p>
<p>Yes! If you are familiar with the basics of programming, blockchain, and using a terminal you can build with Sway.</p>
<p><strong>Q: What can I build with Sway?</strong></p>
<p>You can build smart contracts and their components and libraries for them.
You can learn more about the different program types and how they fit together in the <a href="./sway-program-types/index.html">Program Types</a> section.</p>
<p><strong>Q: Do I need to install anything?</strong></p>
<p>If you want to develop with Sway in your local environment, you need to install <a href="https://docs.fuel.network/guides/installation/"><code>fuelup</code></a> and your editor of choice that supports LSP, such as <a href="https://code.visualstudio.com/">VSCode</a>.</p>
<p>If you don't want to install anything just yet, you can use the <a href="https://www.sway-playground.org/">Sway Playground</a> to edit, compile, and deploy Sway code.</p>
<p><strong>Q: Where can I find example Sway code?</strong></p>
<p>You can find example applications built with Sway in the <a href="https://github.com/FuelLabs/sway-applications">Sway Applications repository</a> on GitHub. You can also find projects building on Fuel in the <a href="https://app.fuel.network/ecosystem">Fuel ecosystem home</a>.</p>
<p><strong>Q: What is the standard library?</strong></p>
<p>The <a href="./introduction/standard_library.html">standard library</a>, also referred to as <code>std</code>, is a library that offers core functions and helpers for developing in Sway. The standard library has it's own <a href="https://fuellabs.github.io/sway/master/std/">reference documentation</a> that has detailed information about each module in <code>std</code>.</p>
<p><strong>Q: What are Sway standards?</strong></p>
<p>Similar to ERC standards for Ethereum and Solidity, Sway has it's own SRC standards that help enable cross compatibility across different smart contracts. For more information on using a Sway Standard, you can check out the <a href="https://github.com/FuelLabs/sway-standards">Sway-Standards Repository</a>.</p>
<p><strong>Q: How can I make a token?</strong></p>
<p>Sway has multiple native assets. To mint a new native asset, check out the <a href="./blockchain-development/native_assets.html">native assets</a> page.</p>
<p><strong>Q: How can I make an NFT?</strong></p>
<p>You can find an example of an NFT contract in Sway in the <a href="https://github.com/FuelLabs/sway-applications/tree/master/NFT">Sway Applications repo</a>.</p>
<p><strong>Q: How can I test Sway code?</strong></p>
<p>Sway provides <a href="./testing/unit-testing.html">unit testing</a>, so you can test your Sway code with Sway. You can also use the Fuel <a href="https://docs.fuel.network/docs/fuels-rs/testing/">Rust SDK</a> or <a href="https://docs.fuel.network/docs/fuels-ts/testing/">TypeScript SDK</a> to test your Sway programs.</p>
<p><strong>Q: How can I deploy a contract?</strong></p>
<p>You can use the <code>forc deploy</code> command to deploy a contract. For a detailed guide on how to deploy a contract, refer to the <a href="https://docs.fuel.network/docs/intro/quickstart-contract/">quickstart guide</a>.</p>
<p><strong>Q: Is there a way to convert Solidity code to Sway?</strong></p>
<p>Yes! You can use the Solidity to Sway transpiler built in to the <a href="https://www.sway-playground.org/">Sway Playground</a> to convert Solidity code into Sway code. Note that the transpiler is still experimental, and may not work in every case.</p>
<p><strong>Q: How can I get help with Sway?</strong></p>
<p>If you run into an issue or have a question, post it on the <a href="https://forum.fuel.network/">Fuel forum</a> so someone in the Fuel community can help.</p>
<p><strong>Q: Where should I get started?</strong></p>
<p><em>Ready to build?</em> You can find step-by-step guides for how to build an application with Sway in the <a href="https://docs.fuel.network/guides/">Fuel Developer Guides</a>.</p>
<p><em>Want to read?</em> Get started by reading the <a href="./introduction/index.html">Introduction</a> and <a href="./basics/index.html">Basics</a> sections of this book.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p>To get started with Forc and Sway smart contract development, install the Fuel toolchain and Fuel full node and set up your first project.</p>
<ul>
<li><a href="introduction/./getting_started.html">Getting Started</a></li>
<li><a href="introduction/./fuel_toolchain.html">The Fuel Toolchain</a></li>
<li><a href="introduction/./forc_project.html">A Forc Project</a></li>
<li><a href="introduction/./standard_library.html">Standard Library</a></li>
<li><a href="introduction/./core_library.html">Core Library</a></li>
<li><a href="introduction/./sway_standards.html">Sway Language Standards</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="getting-started"><a class="header" href="#getting-started">Getting Started</a></h1>
<h2 id="installing-the-fuel-toolchain"><a class="header" href="#installing-the-fuel-toolchain">Installing the <code>Fuel</code> toolchain</a></h2>
<p>Please visit the Fuel <a href="https://docs.fuel.network/guides/installation">Installation Guide</a> to install the Fuel toolchain binaries and prerequisites.</p>
<h2 id="sway-quickstart"><a class="header" href="#sway-quickstart">Sway Quickstart</a></h2>
<p>Check out the <a href="https://docs.fuel.network/guides/quickstart/">Developer Quickstart Guide</a> for a step-by-step guide on building a fullstack dapp on Fuel. The guide will walk you through writing a smart contract, setting up a wallet, and building a frontend to interact with your contract.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-fuel-toolchain"><a class="header" href="#the-fuel-toolchain">The Fuel Toolchain</a></h1>
<p>The Fuel toolchain consists of several components.</p>
<h2 id="forc-forc"><a class="header" href="#forc-forc">Forc (<code>forc</code>)</a></h2>
<p>The &quot;Fuel Orchestrator&quot; <a href="https://github.com/FuelLabs/sway/tree/master/forc">Forc</a> is our equivalent of Rust's <a href="https://doc.rust-lang.org/cargo/">Cargo</a>. It is the primary entry point for creating, building, testing, and deploying Sway projects.</p>
<h2 id="sway-language-server-forc-lsp"><a class="header" href="#sway-language-server-forc-lsp">Sway Language Server (<code>forc-lsp</code>)</a></h2>
<p>The Sway Language Server <code>forc-lsp</code> is provided to expose features to IDEs. <a href="introduction/../lsp/installation.html">Installation instructions</a>.</p>
<h2 id="sway-formatter-forc-fmt"><a class="header" href="#sway-formatter-forc-fmt">Sway Formatter (<code>forc-fmt</code>)</a></h2>
<p>A canonical formatter is provided with <code>forc-fmt</code>. <a href="introduction/./getting_started.html">Installation instructions</a>. It can be run manually with</p>
<pre><code class="language-sh">forc fmt
</code></pre>
<p>The <a href="https://marketplace.visualstudio.com/items?itemName=FuelLabs.sway-vscode-plugin">Visual Studio Code plugin</a> will
automatically format Sway files with <code>forc-fmt</code> on save, though you might have to explicitly set the Sway plugin as the
default formatter, like this:</p>
<pre><code class="language-json">&quot;[sway]&quot;: {
  &quot;editor.defaultFormatter&quot;: &quot;FuelLabs.sway-vscode-plugin&quot;
}
</code></pre>
<h2 id="fuel-core-fuel-core"><a class="header" href="#fuel-core-fuel-core">Fuel Core (<code>fuel-core</code>)</a></h2>
<p>An implementation of the Fuel protocol, <a href="https://github.com/FuelLabs/fuel-core">Fuel Core</a>, is provided together with the <em>Sway toolchain</em> to form the <em>Fuel toolchain</em>. <a href="https://github.com/FuelLabs/fuels-rs">The Rust SDK</a> will automatically start and stop an instance of the node during tests, so there is no need to manually run a node unless using Forc directly without the SDK.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="a-forc-project"><a class="header" href="#a-forc-project">A Forc Project</a></h1>
<p>To initialize a new project with Forc, use <code>forc new</code>:</p>
<pre><code class="language-sh">forc new my-fuel-project
</code></pre>
<p>Here is the project that Forc has initialized:</p>
<!-- This section should show the tree for a new forc project -->
<!-- tree:example:start -->
<pre><code class="language-console">$ cd my-fuel-project
$ tree .
â”œâ”€â”€ Forc.toml
â””â”€â”€ src
 Â Â  â””â”€â”€ main.sw
</code></pre>
<!-- tree:example:end -->
<!-- This section should explain the `Forc.toml` file -->
<!-- forc_toml:example:start -->
<p><code>Forc.toml</code> is the <em>manifest file</em> (similar to <code>Cargo.toml</code> for Cargo or <code>package.json</code> for Node), and defines project metadata such as the project name and dependencies.</p>
<!-- forc_toml:example:end -->
<p>For additional information on dependency management, see: <a href="introduction/../forc/dependencies.html">here</a>.</p>
<pre><code class="language-toml">[project]
authors = [&quot;User&quot;]
entry = &quot;main.sw&quot;
license = &quot;Apache-2.0&quot;
name = &quot;my-fuel-project&quot;

[dependencies]
</code></pre>
<p>Here are the contents of the only Sway file in the project, and the main entry point, <code>src/main.sw</code>:</p>
<pre><code class="language-sway">contract;

abi MyContract {
    fn test_function() -&gt; bool;
}

impl MyContract for Contract {
    fn test_function() -&gt; bool {
        true
    }
}
</code></pre>
<p>The project is a <em>contract</em>, one of four different project types. For additional information on different project types, see <a href="introduction/../sway-program-types/index.html">here</a>.</p>
<p>We now compile our project with <code>forc build</code>, passing the flag <code>--asm final</code> to view the generated assembly:</p>
<pre><code class="language-console">$ forc build --asm final
...
.program:
ji   i4
noop
DATA_SECTION_OFFSET[0..32]
DATA_SECTION_OFFSET[32..64]
lw   $ds $is 1
add  $$ds $$ds $is
lw   $r0 $fp i73              ; load input function selector
lw   $r1 data_0               ; load fn selector for comparison
eq   $r2 $r0 $r1              ; function selector comparison
jnzi $r2 i12                  ; jump to selected function
movi $$tmp i123               ; special code for mismatched selector
rvrt $$tmp                    ; revert if no selectors matched
ret  $one
.data:
data_0 .word 559005003

  Compiled contract &quot;my-fuel-project&quot;.
  Bytecode size is 60 bytes.
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="standard-library"><a class="header" href="#standard-library">Standard Library</a></h1>
<!-- This section should explain what the std-lib is -->
<!-- std_lib:example:start -->
<p>Similar to Rust, Sway comes with its own standard library.</p>
<p>The Sway Standard Library is the foundation of portable Sway software, a set of minimal shared abstractions for the broader Sway ecosystem. It offers core types, like <code>Result&lt;T, E&gt;</code> and <code>Option&lt;T&gt;</code>, library-defined operations on language primitives, native asset management, blockchain contextual operations, access control, storage management, and support for types from other VMs, among many other things.</p>
<!-- std_lib:example:end -->
<p>The entire Sway standard library is a Forc project called <code>std</code>, and is available directly <a href="https://github.com/FuelLabs/sway/tree/master/sway-lib-std">here</a>. Navigate to the appropriate tagged release if the latest <code>master</code> is not compatible. You can find the latest <code>std</code> documentation <a href="https://fuellabs.github.io/sway/master/std/">here</a>.</p>
<h2 id="using-the-standard-library"><a class="header" href="#using-the-standard-library">Using the Standard Library</a></h2>
<p>The standard library is made implicitly available to all Forc projects created using <a href="introduction/../forc/commands/forc_new.html"><code>forc new</code></a>. In other words, it is not required to manually specify <code>std</code> as an explicit dependency. Forc will automatically use the version of <code>std</code> that matches its version.</p>
<p>Importing items from the standard library can be done using the <code>use</code> keyword, just as importing items from any Sway project. For example:</p>
<pre><code class="language-sway">use std::storage::storage_vec::*;
</code></pre>
<p>This imports the <code>StorageVec</code> type into the current namespace.</p>
<h2 id="standard-library-prelude"><a class="header" href="#standard-library-prelude">Standard Library Prelude</a></h2>
<!-- This section should explain what the std-lib prelude is -->
<!-- prelude:example:start -->
<p>Sway comes with a variety of things in its standard library. However, if you had to manually import every single thing that you used, it would be very verbose. But importing a lot of things that a program never uses isn't good either. A balance needs to be struck.</p>
<p>The prelude is the list of things that Sway automatically imports into every Sway program. It's kept as small as possible, and is focused on things which are used in almost every single Sway program.</p>
<p>The current version of the prelude lives in <a href="https://github.com/FuelLabs/sway/blob/master/sway-lib-std/src/prelude.sw"><code>std::prelude</code></a>, and re-exports the following:</p>
<ul>
<li><a href="https://github.com/FuelLabs/sway/blob/master/sway-lib-std/src/address.sw"><code>std::address::Address</code></a>, a wrapper around the <code>b256</code> type representing a wallet address.</li>
<li><a href="https://github.com/FuelLabs/sway/blob/master/sway-lib-std/src/contract_id.sw"><code>std::contract_id::ContractId</code></a>, a wrapper around the <code>b256</code> type representing the ID of a contract.</li>
<li><a href="https://github.com/FuelLabs/sway/blob/master/sway-lib-std/src/identity.sw"><code>std::identity::Identity</code></a>, an enum with two possible variants: <code>Address: Address</code> and <code>ContractId: ContractId</code>.</li>
<li><a href="https://github.com/FuelLabs/sway/blob/master/sway-lib-std/src/vec.sw"><code>std::vec::Vec</code></a>, a growable, heap-allocated vector.</li>
<li><a href="https://github.com/FuelLabs/sway/blob/master/sway-lib-std/src/storage/storage_key.sw"><code>std::storage::storage_key::*</code></a>, contains the API for accessing a <code>core::storage::StorageKey</code> which describes a location in storage.</li>
<li><a href="https://github.com/FuelLabs/sway/blob/master/sway-lib-std/src/storage/storage_map.sw"><code>std::storage::storage_map::*</code></a>, a key-value mapping in contract storage.</li>
<li><a href="https://github.com/FuelLabs/sway/blob/master/sway-lib-std/src/option.sw"><code>std::option::Option</code></a>, an enum which expresses the presence or absence of a value.</li>
<li><a href="https://github.com/FuelLabs/sway/blob/master/sway-lib-std/src/result.sw"><code>std::result::Result</code></a>, an enum for functions that may succeed or fail.</li>
<li><a href="https://github.com/FuelLabs/sway/blob/master/sway-lib-std/src/assert.sw"><code>std::assert::assert</code></a>, a function that reverts the VM if the condition provided to it is <code>false</code>.</li>
<li><a href="https://github.com/FuelLabs/sway/blob/master/sway-lib-std/src/assert.sw"><code>std::assert::assert_eq</code></a>, a function that reverts the VM and logs its two inputs <code>v1</code> and <code>v2</code> if the condition <code>v1</code> == <code>v2</code> is <code>false</code>.</li>
<li><a href="https://github.com/FuelLabs/sway/blob/master/sway-lib-std/src/assert.sw"><code>std::assert::assert_ne</code></a>, a function that reverts the VM and logs its two inputs <code>v1</code> and <code>v2</code> if the condition <code>v1</code> != <code>v2</code> is <code>false</code>.</li>
<li><a href="https://github.com/FuelLabs/sway/blob/master/sway-lib-std/src/revert.sw"><code>std::revert::require</code></a>, a function that reverts the VM and logs a given value if the condition provided to it is <code>false</code>.</li>
<li><a href="https://github.com/FuelLabs/sway/blob/master/sway-lib-std/src/revert.sw"><code>std::revert::revert</code></a>, a function that reverts the VM.</li>
<li><a href="https://github.com/FuelLabs/sway/blob/master/sway-lib-std/src/logging.sw"><code>std::logging::log</code></a>, a function that logs arbitrary stack types.</li>
<li><a href="https://github.com/FuelLabs/sway/blob/master/sway-lib-std/src/auth.sw"><code>std::auth::msg_sender</code></a>, a function that gets the <code>Identity</code> from which a call was made.</li>
</ul>
<!-- prelude:example:end -->
<div style="break-before: page; page-break-before: always;"></div><h1 id="core-library"><a class="header" href="#core-library">Core Library</a></h1>
<p>The Sway Core Library, like the name suggests contains core operators and logic for the primitive types of the Sway programming language. These traits and methods are an extension of the <a href="https://docs.fuel.network/docs/sway/basics/built_in_types/#primitive-types">primitive types</a> <code>u8</code>, <code>u16</code>, <code>u32</code>, <code>u64</code>, <code>u256</code>, <code>str[]</code>, <code>str</code>, <code>bool</code> and , <code>b256</code> and can be used where appropriate.</p>
<p>The latest core library documentation can be found <a href="https://fuellabs.github.io/sway/master/core/">here</a>. If the latest version is not compatible please refer to the appropriate tagged release.</p>
<h2 id="using-the-core-library"><a class="header" href="#using-the-core-library">Using the Core Library</a></h2>
<p>Core library functionalities do not need to be explicitly imported and will work out of the box after creating any new Sway project with <a href="introduction/../forc/commands/forc_new.html"><code>forc new</code></a>. The <code>use</code> keyword is simply not required.</p>
<p>Consider this example of using the modulo function for two like value types:</p>
<pre><code class="language-sway">let val_1 = 10;
let val_2 = 2;
let result = val_1 % val_2;
</code></pre>
<h2 id="core-library-prelude"><a class="header" href="#core-library-prelude">Core Library Prelude</a></h2>
<p>The prelude contains a list of operations essential to all Sway programs. The latest version of the prelude can be found <a href="https://github.com/FuelLabs/sway/blob/master/sway-lib-core/src/prelude.sw">here</a>.</p>
<ul>
<li><a href="https://github.com/FuelLabs/sway/blob/master/sway-lib-core/src/primitives.sw"><code>core::primitives::*</code></a></li>
<li><a href="https://github.com/FuelLabs/sway/blob/master/sway-lib-core/src/primitive_conversions.sw"><code>core::primitive_conversions::*</code></a></li>
<li><a href="https://github.com/FuelLabs/sway/blob/master/sway-lib-core/src/raw_ptr.sw"><code>core::raw_ptr::*</code></a></li>
<li><a href="https://github.com/FuelLabs/sway/blob/master/sway-lib-core/src/raw_slice.sw"><code>core::raw_slice::*</code></a></li>
<li><a href="https://github.com/FuelLabs/sway/blob/master/sway-lib-core/src/ops.sw"><code>core::ops::*</code></a></li>
<li><a href="https://github.com/FuelLabs/sway/blob/master/sway-lib-core/src/storage.sw"><code>core::storage::*</code></a></li>
<li><a href="https://github.com/FuelLabs/sway/blob/master/sway-lib-core/src/str.sw"><code>core::str::*</code></a></li>
<li><a href="https://github.com/FuelLabs/sway/blob/master/sway-lib-core/src/codec.sw"><code>core::codec::*</code></a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sway-standards"><a class="header" href="#sway-standards">Sway Standards</a></h1>
<p>Just like many other smart contract languages, usage standards have been developed to enable cross compatibility between smart contracts.</p>
<p>For more information on using a Sway Standard, please refer to the <a href="https://github.com/FuelLabs/sway-standards">Sway-Standards Repository</a>.</p>
<h2 id="standards"><a class="header" href="#standards">Standards</a></h2>
<h3 id="native-asset-standards"><a class="header" href="#native-asset-standards">Native Asset Standards</a></h3>
<ul>
<li><a href="https://github.com/FuelLabs/sway-standards/blob/master/docs/src/src-20-native-asset.md">SRC-20; Native Asset Standard</a> defines the implementation of a standard API for <a href="introduction/../blockchain-development/native_assets.html">Native Assets</a> using the Sway Language.</li>
<li><a href="https://github.com/FuelLabs/sway-standards/blob/master/docs/src/src-3-minting-and-burning.md">SRC-3; Mint and Burn</a> is used to enable mint and burn functionality for Native Assets.</li>
<li><a href="https://github.com/FuelLabs/sway-standards/blob/master/docs/src/src-7-asset-metadata.md">SRC-7; Arbitrary Asset Metadata Standard</a> is used to store metadata for <a href="introduction/../blockchain-development/native_assets.html">Native Assets</a>, usually as NFTs.</li>
<li><a href="https://github.com/FuelLabs/sway-standards/blob/master/docs/src/src-9-metadata-keys.md">SRC-9; Metadata Keys Standard</a> is used to store standardized metadata keys for <a href="introduction/../blockchain-development/native_assets.html">Native Assets</a> in combination with the SRC-7 standard.</li>
<li><a href="https://github.com/FuelLabs/sway-standards/blob/master/docs/src/src-6-vault.md">SRC-6; Vault Standard</a> defines the implementation of a standard API for asset vaults developed in Sway.</li>
</ul>
<h3 id="predicate-standards"><a class="header" href="#predicate-standards">Predicate Standards</a></h3>
<ul>
<li><a href="https://github.com/FuelLabs/sway-standards/blob/master/docs/src/src-13-soulbound-address.md">SRC-13; Soulbound Address Standard</a> defines a specific <code>Address</code> as a Soulbound Address for Soulbound Assets to become non-transferable.</li>
</ul>
<h3 id="access-control-standards"><a class="header" href="#access-control-standards">Access Control Standards</a></h3>
<ul>
<li><a href="https://github.com/FuelLabs/sway-standards/blob/master/docs/src/src-5-ownership.md">SRC-5; Ownership Standard</a> is used to restrict function calls to admin users in contracts.</li>
</ul>
<h3 id="contract-standards"><a class="header" href="#contract-standards">Contract Standards</a></h3>
<ul>
<li><a href="https://github.com/FuelLabs/sway-standards/blob/master/docs/src/src-12-contract-factory.md">SRC-12; Contract Factory</a> defines the implementation of a standard API for contract factories.</li>
</ul>
<h3 id="bridge-standards"><a class="header" href="#bridge-standards">Bridge Standards</a></h3>
<ul>
<li><a href="https://github.com/FuelLabs/sway-standards/blob/master/docs/src/src-8-bridged-asset.md">SRC-8; Bridged Asset</a> defines the metadata required for an asset bridged to the Fuel Network.</li>
<li><a href="https://github.com/FuelLabs/sway-standards/blob/master/docs/src/src-10-native-bridge.md">SRC-10; Native Bridge Standard</a> defines the standard API for the Native Bridge between the Fuel Chain and the canonical base chain.</li>
</ul>
<h3 id="documentation-standards"><a class="header" href="#documentation-standards">Documentation Standards</a></h3>
<ul>
<li><a href="https://github.com/FuelLabs/sway-standards/blob/master/docs/src/src-2-inline-documentation.md">SRC-2; Inline Documentation</a> defines how to document your Sway files.</li>
</ul>
<h2 id="standards-support"><a class="header" href="#standards-support">Standards Support</a></h2>
<p>Libraries have also been developed to support Sway Standards. These can be in <a href="introduction/../reference/sway_libs.html">Sway-Libs</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="example"><a class="header" href="#example">Example</a></h1>
<p>Some basic example contracts to see how Sway and Forc work.</p>
<ul>
<li><a href="examples/./counter.html">Counter</a></li>
<li><a href="examples/./fizzbuzz.html"><code>FizzBuzz</code></a></li>
<li><a href="examples/./wallet_smart_contract.html">Wallet Smart Contract</a></li>
<li><a href="examples/./wallet_smart_contract.html">Liquidity Pool</a></li>
</ul>
<p>Additional examples can be found in the <a href="https://github.com/FuelLabs/sway-applications/tree/master">Sway Applications</a> repository.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="counter"><a class="header" href="#counter">Counter</a></h1>
<p>The following is a simple example of a contract which implements a counter. Both the <code>initialize_counter()</code> and <code>increment_counter()</code> ABI methods return the currently set value.</p>
<pre><code class="language-bash">forc template --template-name counter my_counter_project
</code></pre>
<pre><code class="language-sway">contract;

abi TestContract {
    #[storage(write)]
    fn initialize_counter(value: u64) -&gt; u64;

    #[storage(read, write)]
    fn increment_counter(amount: u64) -&gt; u64;
}

storage {
    counter: u64 = 0,
}

impl TestContract for Contract {
    #[storage(write)]
    fn initialize_counter(value: u64) -&gt; u64 {
        storage.counter.write(value);
        value
    }

    #[storage(read, write)]
    fn increment_counter(amount: u64) -&gt; u64 {
        let incremented = storage.counter.read() + amount;
        storage.counter.write(incremented);
        incremented
    }
}
</code></pre>
<h2 id="build-and-deploy"><a class="header" href="#build-and-deploy">Build and deploy</a></h2>
<p>The following commands can be used to build and deploy the contract. For a detailed tutorial, refer to <a href="https://docs.fuel.network/guides/contract-quickstart/#building-the-contract">Building and Deploying</a>.</p>
<pre><code class="language-bash"># Build the contract
forc build

# Deploy the contract
forc deploy --testnet
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="fizzbuzz"><a class="header" href="#fizzbuzz"><code>FizzBuzz</code></a></h1>
<p>This example is not the traditional <a href="https://en.wikipedia.org/wiki/Fizz_buzz#Programming"><code>FizzBuzz</code></a>; instead it is the smart contract version! A script can call the <code>fizzbuzz</code> ABI method of this contract with some <code>u64</code> value and receive back the result as an <code>enum</code>.</p>
<p>The format for custom structs and enums such as <code>FizzBuzzResult</code> will be automatically included in the ABI JSON so that off-chain code can handle the encoded form of the returned data.</p>
<pre><code class="language-sway">contract;

enum FizzBuzzResult {
    Fizz: (),
    Buzz: (),
    FizzBuzz: (),
    Other: u64,
}

abi FizzBuzz {
    fn fizzbuzz(input: u64) -&gt; FizzBuzzResult;
}

impl FizzBuzz for Contract {
    fn fizzbuzz(input: u64) -&gt; FizzBuzzResult {
        if input % 15 == 0 {
            FizzBuzzResult::FizzBuzz
        } else if input % 3 == 0 {
            FizzBuzzResult::Fizz
        } else if input % 5 == 0 {
            FizzBuzzResult::Buzz
        } else {
            FizzBuzzResult::Other(input)
        }
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="wallet-smart-contract"><a class="header" href="#wallet-smart-contract">Wallet Smart Contract</a></h1>
<p>The ABI declaration is a separate project from your ABI implementation. The project structure for the code should be organized as follows with the <code>wallet_abi</code> treated as an external library:</p>
<pre><code class="language-sh">.
â”œâ”€â”€ wallet_abi
â”‚   â”œâ”€â”€ Forc.toml
â”‚   â””â”€â”€ src
â”‚       â””â”€â”€ main.sw
â””â”€â”€ wallet_smart_contract
    â”œâ”€â”€ Forc.toml
    â””â”€â”€ src
        â””â”€â”€ main.sw
</code></pre>
<p>It's also important to specify the source of the dependency within the project's <code>Forc.toml</code> file when using external libraries. Inside the <code>wallet_smart_contract</code> project, it requires a declaration like this:</p>
<pre><code class="language-sh">[dependencies]
wallet_abi = { path = &quot;../wallet_abi/&quot; }
</code></pre>
<h2 id="abi-declaration"><a class="header" href="#abi-declaration">ABI Declaration</a></h2>
<pre><code class="language-sway">library;

abi Wallet {
    #[storage(read, write), payable]
    fn receive_funds();

    #[storage(read, write)]
    fn send_funds(amount_to_send: u64, recipient_address: Address);
}
</code></pre>
<h2 id="abi-implementation"><a class="header" href="#abi-implementation">ABI Implementation</a></h2>
<pre><code class="language-sway">contract;

use std::{asset::transfer, call_frames::msg_asset_id, context::msg_amount,};

use wallet_abi::Wallet;
const OWNER_ADDRESS = Address::from(0x8900c5bec4ca97d4febf9ceb4754a60d782abbf3cd815836c1872116f203f861);

storage {
    balance: u64 = 0,
}

impl Wallet for Contract {
    #[storage(read, write), payable]
    fn receive_funds() {
        if msg_asset_id() == AssetId::base() {
            // If we received the base asset then keep track of the balance.
            // Otherwise, we're receiving other native assets and don't care
            // about our balance of coins.
            storage.balance.write(storage.balance.read() + msg_amount());
        }
    }

    #[storage(read, write)]
    fn send_funds(amount_to_send: u64, recipient_address: Address) {
        let sender = msg_sender().unwrap();
        match sender {
            Identity::Address(addr) =&gt; assert(addr == OWNER_ADDRESS),
            _ =&gt; revert(0),
        };

        let current_balance = storage.balance.read();
        assert(current_balance &gt;= amount_to_send);

        storage.balance.write(current_balance - amount_to_send);

        // Note: `transfer()` is not a call and thus not an
        // interaction. Regardless, this code conforms to
        // checks-effects-interactions to avoid re-entrancy.
        transfer(
            Identity::Address(recipient_address),
            AssetId::base(),
            amount_to_send,
        );
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="liquidity-pool-example"><a class="header" href="#liquidity-pool-example">Liquidity Pool Example</a></h1>
<p>All contracts in Fuel can mint and burn their own native asset. Contracts can also receive and transfer any native asset including their own. Internal balances of all native assets pushed through calls or minted by the contract are tracked by the FuelVM and can be queried at any point using the <code>balance_of</code> function from the <code>std</code> library. Therefore, there is no need for any manual accounting of the contract's balances using persistent storage.</p>
<p>The <code>std</code> library provides handy methods for accessing Fuel's native asset operations.</p>
<p>In this example, we show a basic liquidity pool contract minting its own native asset LP asset.</p>
<pre><code class="language-sway">contract;

use std::{
    asset::{
        mint_to,
        transfer,
    },
    call_frames::msg_asset_id,
    constants::DEFAULT_SUB_ID,
    context::msg_amount,
    hash::*,
};

abi LiquidityPool {
    fn deposit(recipient: Address);
    fn withdraw(recipient: Address);
}

const BASE_ASSET: AssetId = AssetId::from(0x9ae5b658754e096e4d681c548daf46354495a437cc61492599e33fc64dcdc30c);

impl LiquidityPool for Contract {
    fn deposit(recipient: Address) {
        assert(msg_asset_id() == BASE_ASSET);
        assert(msg_amount() &gt; 0);

        // Mint two times the amount.
        let amount_to_mint = msg_amount() * 2;

        // Mint some LP assets based upon the amount of the base asset.
        mint_to(Identity::Address(recipient), DEFAULT_SUB_ID, amount_to_mint);
    }

    fn withdraw(recipient: Address) {
        let asset_id = AssetId::default();
        assert(msg_asset_id() == asset_id);
        assert(msg_amount() &gt; 0);

        // Amount to withdraw.
        let amount_to_transfer = msg_amount() / 2;

        // Transfer base asset to recipient.
        transfer(Identity::Address(recipient), BASE_ASSET, amount_to_transfer);
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sway-applications"><a class="header" href="#sway-applications">Sway Applications</a></h1>
<p>The <a href="https://github.com/FuelLabs/sway-applications">Sway-Applications</a> Repository contains end-to-end example applications that are written in Sway in order to demonstrate what can be built.</p>
<h2 id="asset-management"><a class="header" href="#asset-management">Asset Management</a></h2>
<ul>
<li><a href="https://github.com/FuelLabs/sway-applications/tree/master/airdrop">Airdrop</a> is an asset distribution program where users are able to claim assets given a valid merkle proof.</li>
<li><a href="https://github.com/FuelLabs/sway-applications/tree/master/escrow">Escrow</a> is a third party that keeps an asset on behalf of multiple parties.</li>
<li><a href="https://github.com/FuelLabs/sway-applications/tree/master/NFT">Non-Fungible Native Asset (NFT)</a> is an asset contract which provides unique collectibles, identified and differentiated by IDs, where assets contain metadata giving them distinctive characteristics.</li>
<li><a href="https://github.com/FuelLabs/sway-applications/tree/master/fractional-NFT">Fractional Non-Fungible Token (F-NFT)</a> is a token contract which issues shares or partial ownership upon locking an NFT into a vault.</li>
<li><a href="https://github.com/FuelLabs/sway-applications/tree/master/timelock">Timelock</a> is a contract which restricts the execution of a transaction to a specified time range.</li>
<li><a href="https://github.com/FuelLabs/sway-applications/tree/master/native-asset">Native Asset</a> is a basic asset contract that enables the use of Native Assets on Fuel using existing standards and libraries.</li>
</ul>
<h2 id="decentralized-finance"><a class="header" href="#decentralized-finance">Decentralized Finance</a></h2>
<ul>
<li><a href="https://github.com/FuelLabs/sway-applications/tree/master/english-auction">English Auction</a> is an auction where users bid up the price of an asset until the bidding period has ended or a reserve has been met.</li>
<li><a href="https://github.com/FuelLabs/sway-applications/tree/master/fundraiser">Fundraiser</a> is a program allowing users to pledge towards a goal.</li>
<li><a href="https://github.com/FuelLabs/sway-applications/tree/master/OTC-swap-predicate">OTC Swap Predicate</a> is a predicate that can be used to propose and execute an atomic swap between two parties without requiring any on-chain state.</li>
</ul>
<h2 id="governance"><a class="header" href="#governance">Governance</a></h2>
<ul>
<li><a href="https://github.com/FuelLabs/sway-applications/tree/master/DAO">Decentralized Autonomous Organization (DAO)</a> is an organization where users get to vote on governance proposals using governance assets.</li>
<li><a href="https://github.com/FuelLabs/sway-applications/tree/master/multisig-wallet">Multi-Signature Wallet</a> is a wallet that requires multiple signatures to execute a transaction.</li>
</ul>
<h2 id="games"><a class="header" href="#games">Games</a></h2>
<ul>
<li><a href="https://github.com/FuelLabs/sway-applications/tree/master/TicTacToe">TicTacToe</a> is a game where two players compete to align three markers in a row.</li>
</ul>
<h2 id="other"><a class="header" href="#other">Other</a></h2>
<ul>
<li><a href="https://github.com/FuelLabs/sway-applications/tree/master/counter-script">Counter-Script</a> is a script that calls a contract to increment a counter.</li>
<li><a href="https://github.com/FuelLabs/sway-applications/tree/master/name-registry">Name-Registry</a> allows users to perform transactions with human readable names instead of addresses.</li>
<li><a href="https://github.com/FuelLabs/sway-applications/tree/master/oracle">Oracle</a> is a smart contract that provides off-chain data to on-chain applications.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sway-program-types"><a class="header" href="#sway-program-types">Sway Program Types</a></h1>
<!-- This section should explain program types -->
<!-- programs:example:start -->
<p>A Sway program itself has a type: it is either a <em>contract</em>, a <em>predicate</em>, a <em>script</em>, or a <em>library</em>. The first three of these things are all deployable to the blockchain. A <em>library</em> is simply a project designed for code reuse and is never directly deployed to the chain.</p>
<p>Every Sway file <em>must</em> begin with a declaration of what type of program it is. A project can have many libraries within it, but only one contract, script, or predicate. Scripts and predicates require <code>main</code> functions to serve as entry points, while contracts instead publish an ABI. This chapter will go into detail about all of these various types of programs and what purposes they serve.</p>
<!-- programs:example:end -->
<p>Contracts are used primarily for protocols or systems that operate within a fixed set of rules. A good example would be a staking contract or a decentralized exchange (also called a DEX).</p>
<p>Scripts are used for complex on-chain interactions that won't persist. An example of this may be using a DEX and Lender to create a leveraged position (borrow, swap, re-collateralize) which is a complex transaction that would usually take multiple steps.</p>
<p>Libraries are for code that is reusable and useful for handling common situations. A good example of this would be a library to handle fixed-point math or big number math.</p>
<ul>
<li><a href="sway-program-types/./smart_contracts.html">Contracts</a></li>
<li><a href="sway-program-types/./libraries.html">Libraries</a></li>
<li><a href="sway-program-types/./scripts.html">Scripts</a></li>
<li><a href="sway-program-types/./predicates.html">Predicates</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="what-is-a-smart-contract"><a class="header" href="#what-is-a-smart-contract">What is a Smart Contract?</a></h1>
<!-- This section should explain what is a smart contract -->
<!-- contract:example:start -->
<p>A smart contract is no different than a script or predicate in that it is a piece of bytecode that is deployed to the blockchain via a <a href="https://fuellabs.github.io/fuel-specs/master/protocol/tx_format">transaction</a>. The main features of a smart contract that differentiate it from scripts or predicates are that it is <em>callable</em> and <em>stateful</em>. Put another way, a smart contract is analogous to a deployed API with some database state.</p>
<!-- contract:example:end -->
<p>The interface of a smart contract, also just called a contract, must be defined strictly with an <a href="sway-program-types/smart_contracts.html#the-abi-declaration">ABI declaration</a>. See <a href="sway-program-types/../examples/wallet_smart_contract.html">this contract</a> for an example.</p>
<h2 id="syntax-of-a-smart-contract"><a class="header" href="#syntax-of-a-smart-contract">Syntax of a Smart Contract</a></h2>
<p>As with any Sway program, the program starts with a declaration of what <a href="sway-program-types/./index.html">program type</a> it is. A contract must also either define or import an <a href="sway-program-types/smart_contracts.html#the-abi-declaration">ABI declaration</a> and implement it.</p>
<!-- This section should explain best practices for ABIs -->
<!-- ABI:example:start -->
<p>It is considered good practice to define your ABI in a separate library and import it into your contract. This allows callers of your contract to simply import the ABI directly and use it in their scripts to call your contract.</p>
<!-- ABI:example:end -->
<p>Let's take a look at an ABI declaration in a library:</p>
<pre><code class="language-sway">library;

abi Wallet {
    #[storage(read, write), payable]
    fn receive_funds();

    #[storage(read, write)]
    fn send_funds(amount_to_send: u64, recipient_address: Address);
}
</code></pre>
<p>Let's focus on the ABI declaration and inspect it line-by-line.</p>
<h3 id="the-abi-declaration"><a class="header" href="#the-abi-declaration">The ABI Declaration</a></h3>
<pre><code class="language-sway">abi Wallet {
    #[storage(read, write), payable]
    fn receive_funds();

    #[storage(read, write)]
    fn send_funds(amount_to_send: u64, recipient_address: Address);
}
</code></pre>
<hr />
<p>In the first line, <code>abi Wallet {</code>, we declare the name of this <em>Application Binary Interface</em>, or ABI. We are naming this ABI <code>Wallet</code>. To import this ABI into either a script for calling or a contract for implementing, you would use</p>
<pre><code class="language-sway">use wallet_abi::Wallet;
</code></pre>
<hr />
<p>In the second line,</p>
<pre><code class="language-sway">    #[storage(read, write), payable]
    fn receive_funds();
</code></pre>
<p>we are declaring an ABI method called <code>receive_funds</code> which, when called, should receive funds into this wallet. Note that we are simply defining an interface here, so there is no <em>function body</em> or implementation of the function. We only need to define the interface itself. In this way, ABI declarations are similar to <a href="sway-program-types/../advanced/traits.html">trait declarations</a>. This particular ABI method does not take any parameters.</p>
<hr />
<p>In the third line,</p>
<pre><code class="language-sway">    #[storage(read, write)]
    fn send_funds(amount_to_send: u64, recipient_address: Address);
</code></pre>
<p>we are declaring another ABI method, this time called <code>send_funds</code>. It takes two parameters: the amount to send, and the address to send the funds to.</p>
<blockquote>
<p><strong>Note</strong>: The ABI methods <code>receive_funds</code> and <code>send_funds</code> also require the annotation <code>#[storage(read, write)]</code> because their implementations require reading and writing a storage variable that keeps track of the wallet balance, as we will see shortly. Refer to <a href="sway-program-types/../blockchain-development/purity.html#Purity">Purity</a> for more information on storage annotations.</p>
</blockquote>
<h2 id="implementing-an-abi-for-a-smart-contract"><a class="header" href="#implementing-an-abi-for-a-smart-contract">Implementing an ABI for a Smart Contract</a></h2>
<p>Now that we've discussed how to define the interface, let's discuss how to use it. We will start by implementing the above ABI for a specific contract.</p>
<p>Implementing an ABI for a contract is accomplished with <code>impl &lt;ABI name&gt; for Contract</code> syntax. The <code>for Contract</code> syntax can only be used to implement an ABI for a contract; implementing methods for a struct should use <code>impl Foo</code> syntax.</p>
<pre><code class="language-sway">impl Wallet for Contract {
    #[storage(read, write), payable]
    fn receive_funds() {
        if msg_asset_id() == AssetId::base() {
            // If we received the base asset then keep track of the balance.
            // Otherwise, we're receiving other native assets and don't care
            // about our balance of coins.
            storage.balance.write(storage.balance.read() + msg_amount());
        }
    }

    #[storage(read, write)]
    fn send_funds(amount_to_send: u64, recipient_address: Address) {
        let sender = msg_sender().unwrap();
        match sender {
            Identity::Address(addr) =&gt; assert(addr == OWNER_ADDRESS),
            _ =&gt; revert(0),
        };

        let current_balance = storage.balance.read();
        assert(current_balance &gt;= amount_to_send);

        storage.balance.write(current_balance - amount_to_send);

        // Note: `transfer()` is not a call and thus not an
        // interaction. Regardless, this code conforms to
        // checks-effects-interactions to avoid re-entrancy.
        transfer(
            Identity::Address(recipient_address),
            AssetId::base(),
            amount_to_send,
        );
    }
}
</code></pre>
<p>You may notice once again the similarities between <a href="sway-program-types/../advanced/traits.html">traits</a> and ABIs. And, indeed, as a bonus, you can define methods in addition to the interface surface of an ABI, just like a trait. These pre-implemented ABI methods automatically become available as part of the contract interface that implements the corresponding ABI.</p>
<p>Note that the above implementation of the ABI follows the <a href="https://docs.soliditylang.org/en/v0.6.11/security-considerations.html#re-entrancy">Checks, Effects, Interactions</a> pattern.</p>
<h2 id="the-contractid-type"><a class="header" href="#the-contractid-type">The <code>ContractId</code> type</a></h2>
<p>Contracts have an associated <code>ContractId</code> type in Sway. The <code>ContractId</code> type allows for Sway programs to refer to contracts in the Sway language. Please refer to the <a href="sway-program-types/../basics/blockchain_types.html#contractid-type">ContractId</a> section of the book for more information on <code>ContractId</code>s.</p>
<h2 id="calling-a-smart-contract-from-a-script"><a class="header" href="#calling-a-smart-contract-from-a-script">Calling a Smart Contract from a Script</a></h2>
<blockquote>
<p><strong>Note</strong>: In most cases, calling a contract should be done from the <a href="sway-program-types/../testing/testing-with-rust.html">Rust SDK</a> or the <a href="https://docs.fuel.network/docs/fuels-ts">TypeScript SDK</a> which provide a more ergonomic UI for interacting with a contract. However, there are situations where manually writing a script to call a contract is required.</p>
</blockquote>
<p>Now that we have defined our interface and implemented it for our contract, we need to know how to actually <em>call</em> our contract. Let's take a look at a contract call:</p>
<pre><code class="language-sway">script;

use wallet_abi::Wallet;

fn main() {
    let contract_address = 0x9299da6c73e6dc03eeabcce242bb347de3f5f56cd1c70926d76526d7ed199b8b;
    let caller = abi(Wallet, contract_address);
    let amount_to_send = 200;
    let recipient_address = Address::from(0x9299da6c73e6dc03eeabcce242bb347de3f5f56cd1c70926d76526d7ed199b8b);
    caller
        .send_funds {
            gas: 10000,
            coins: 0,
            asset_id: b256::zero(),
        }(amount_to_send, recipient_address);
}
</code></pre>
<p>The main new concept is the <code>abi cast</code>: <code>abi(AbiName, contract_address)</code>. This returns a <code>ContractCaller</code> type which can be used to call contracts. The methods of the ABI become the methods available on this contract caller: <code>send_funds</code> and <code>receive_funds</code>. We then directly call the contract ABI method as if it was just a regular method. You also have the option of specifying the following special parameters inside curly braces right before the main list of parameters:</p>
<ol>
<li><code>gas</code>: a <code>u64</code> that represents the gas being forwarded to the contract when it is called.</li>
<li><code>coins</code>: a <code>u64</code> that represents how many coins are being forwarded with this call.</li>
<li><code>asset_id</code>: a <code>b256</code> that represents the ID of the <em>asset type</em> of the coins being forwarded.</li>
</ol>
<p>Each special parameter is optional and assumes a default value when skipped:</p>
<ol>
<li>The default value for <code>gas</code> is the context gas (i.e. the content of the special register <code>$cgas</code>). Refer to the <a href="https://fuellabs.github.io/fuel-specs/master/vm">FuelVM specifications</a> for more information about context gas.</li>
<li>The default value for <code>coins</code> is 0.</li>
<li>The default value for <code>asset_id</code> is <code>b256::zero()</code>.</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="libraries"><a class="header" href="#libraries">Libraries</a></h1>
<!-- This section should explain what a library is -->
<!-- library:example:start -->
<p>Libraries in Sway are files used to define new common behavior.</p>
<!-- library:example:end -->
<p>The most prominent example of this is the <a href="sway-program-types/../introduction/standard_library.html">Sway Standard Library</a> that is made implicitly available to all Forc projects created using <code>forc new</code>.</p>
<h2 id="writing-libraries"><a class="header" href="#writing-libraries">Writing Libraries</a></h2>
<!-- This section should explain how libraries are defined -->
<!-- def_lib:example:start -->
<p>Libraries are defined using the <code>library</code> keyword at the beginning of a file, followed by a name so that they can be imported.</p>
<!-- def_lib:example:end -->
<pre><code class="language-sway">library;

// library code
</code></pre>
<p>A good reference library to use when learning library design is the <a href="sway-program-types/../introduction/standard_library.html">Sway Standard Library</a>. For example, the standard library offers an <a href="https://github.com/FuelLabs/sway/blob/master/sway-lib-std/src/option.sw">implementation</a> of <code>enum Option&lt;T&gt;</code> which is a generic type that represents either the existence of a value using the variant <code>Some(..)</code> or a value's absence using the variant <code>None</code>. The <a href="https://github.com/FuelLabs/sway/blob/master/sway-lib-std/src/option.sw">Sway file implementing <code>Option&lt;T&gt;</code></a> has the following structure:</p>
<ul>
<li>The <code>library</code> keyword:</li>
</ul>
<pre><code class="language-sway">library;
</code></pre>
<ul>
<li>A <code>use</code> statement that imports <code>revert</code> from another library <em>inside</em> the standard library:</li>
</ul>
<pre><code class="language-sway">use ::revert::revert;
</code></pre>
<ul>
<li>The <code>enum</code> definition which starts with the keyword <code>pub</code> to indicate that this <code>Option&lt;T&gt;</code> is publicly available <em>outside</em> the <code>option</code> library:</li>
</ul>
<pre><code class="language-sway">pub enum Option&lt;T&gt; {
    // variants
}
</code></pre>
<ul>
<li>An <code>impl</code> block that implements some methods for <code>Option&lt;T&gt;</code>:</li>
</ul>
<pre><code class="language-sway">impl&lt;T&gt; Option&lt;T&gt; {

    fn is_some(self) -&gt; bool {
        // body of is_some
    }

    // other methods
}
</code></pre>
<p>Now that the library <code>option</code> is fully written, and because <code>Option&lt;T&gt;</code> is defined with the <code>pub</code> keyword, we are now able to import <code>Option&lt;T&gt;</code> using <code>use std::option::Option;</code> from any Sway project and have access to all of its variants and methods. That being said, <code>Option</code> is automatically available in the <a href="sway-program-types/../introduction/standard_library.html#standard-library-prelude">standard library prelude</a> so you never actually have to import it manually.</p>
<p>Libraries are composed of just a <code>Forc.toml</code> file and a <code>src</code> directory, unlike contracts which usually contain a <code>tests</code> directory and a <code>Cargo.toml</code> file as well. An example of a library's <code>Forc.toml</code>:</p>
<pre><code class="language-toml">[project]
authors = [&quot;Fuel Labs &lt;contact@fuel.sh&gt;&quot;]
entry = &quot;lib.sw&quot;
license = &quot;Apache-2.0&quot;
name = &quot;my_library&quot;

[dependencies]
</code></pre>
<p>which denotes the authors, an entry file, the name by which it can be imported, and any dependencies.</p>
<p>For large libraries, it is recommended to have a <code>lib.sw</code> entry point re-export all other sub-libraries.</p>
<!-- This section should explain the `mod` keyword -->
<!-- mod:example:start -->
<p>The <code>mod</code> keyword registers a submodule, making its items (such as functions and structs) accessible from the parent library.
If used at the top level it will refer to a file in the <code>src</code> folder and in other cases in a folder named after the library in which it is defined.</p>
<!-- mod:example:end -->
<p>For example, the <code>lib.sw</code> of the standard library looks like:</p>
<pre><code class="language-sway">library;

mod block;
mod storage;
mod constants;
mod vm;
// .. Other deps
</code></pre>
<p>with other libraries contained in the <code>src</code> folder, like the <code>vm</code> library (inside of <code>src/vm.sw</code>):</p>
<pre><code class="language-sway">library;

mod evm;
// ...
</code></pre>
<p>and it's own sub-library <code>evm</code> located in <code>src/vm/evm.sw</code>:</p>
<pre><code class="language-sway">library;

// ...
</code></pre>
<h2 id="using-libraries"><a class="header" href="#using-libraries">Using Libraries</a></h2>
<p>There are two types of Sway libraries, based on their location and how they can be imported.</p>
<h3 id="internal-libraries"><a class="header" href="#internal-libraries">Internal Libraries</a></h3>
<p>Internal libraries are located within the project's <code>src</code> directory alongside
<code>main.sw</code> or in the appropriate folders as shown below:</p>
<pre><code class="language-bash">$ tree
.
â”œâ”€â”€ Cargo.toml
â”œâ”€â”€ Forc.toml
â””â”€â”€ src
    â”œâ”€â”€ internal_lib.sw
    â”œâ”€â”€ main.sw
    â””â”€â”€ internal_lib
        â””â”€â”€ nested_lib.sw
</code></pre>
<p>As <code>internal_lib</code> is an internal library, it can be imported into <code>main.sw</code> as follows:</p>
<ul>
<li>Use the <code>mod</code> keyword followed by the library name to make the internal library a dependency</li>
<li>Use the <code>use</code> keyword with a <code>::</code> separating the name of the library and the imported item(s)</li>
</ul>
<pre><code class="language-sway">mod internal_lib; // Assuming the library name in `internal_lib.sw` is `internal_lib`

use internal_lib::mint;

// `mint` from `internal_library` is now available in this file
</code></pre>
<h3 id="external-libraries"><a class="header" href="#external-libraries">External Libraries</a></h3>
<p>External libraries are located outside the main <code>src</code> directory as shown below:</p>
<pre><code class="language-bash">$ tree
.
â”œâ”€â”€ my_project
â”‚   â”œâ”€â”€ Cargo.toml
â”‚   â”œâ”€â”€ Forc.toml
â”‚   â””â”€â”€â”€ src
â”‚       â””â”€â”€ main.sw
â”‚
â””â”€â”€ external_lib
    â”œâ”€â”€ Cargo.toml
    â”œâ”€â”€ Forc.toml
    â””â”€â”€â”€ src
        â””â”€â”€ lib.sw
</code></pre>
<p>As <code>external_lib</code> is outside the <code>src</code> directory of <code>my_project</code>, it needs to be added as a dependency in the <code>Forc.toml</code> file of <code>my_project</code>, by adding the library path in the <code>dependencies</code> section as shown below, before it can be imported:</p>
<pre><code class="language-toml">[dependencies]
external_library = { path = &quot;../external_library&quot; }
</code></pre>
<p>Once the library dependency is added to the <code>toml</code> file, you can import items from it as follows:</p>
<ul>
<li>Make sure the item you want imported are declared with the <code>pub</code> keyword (if applicable, for instance: <code>pub fn mint() {}</code>)</li>
<li>Use the <code>use</code> keyword to selectively import items from the library</li>
</ul>
<pre><code class="language-sway">use external_library::mint;

// `mint` from `external_library` is now available in this file
</code></pre>
<p>Wildcard imports using <code>*</code> are supported, but it is generally recommended to use explicit imports where possible.</p>
<blockquote>
<p><strong>Note</strong>: the standard library is implicitly available to all Forc projects, that is, you are not required to manually specify <code>std</code> as an explicit dependency in <code>Forc.toml</code>.</p>
</blockquote>
<h2 id="reference-sway-libraries"><a class="header" href="#reference-sway-libraries">Reference Sway Libraries</a></h2>
<p>The repository <a href="https://github.com/FuelLabs/sway-libs/"><code>sway-libs</code></a> is a collection of external libraries that you can import and make use of in your Fuel applications. These libraries are meant to be implementations of common use-cases valuable for dapp development.</p>
<p>Some Sway Libraries to try out:</p>
<ul>
<li><a href="https://github.com/FuelLabs/sway-libs/tree/master/libs/src/merkle">Binary Merkle Proof</a></li>
<li><a href="https://github.com/FuelLabs/sway-libs/tree/master/libs/src/signed_integers">Signed Integers</a></li>
<li><a href="https://github.com/FuelLabs/sway-libs/tree/master/libs/src/fixed_point">Unsigned Fixed Point Number</a></li>
<li><a href="https://github.com/FuelLabs/sway-libs/tree/master/libs/src/ownership">Ownership</a></li>
</ul>
<h3 id="example-1"><a class="header" href="#example-1">Example</a></h3>
<p>You can import and use a Sway Library such as the <a href="https://github.com/FuelLabs/sway-libs/tree/master/libs/src/ownership">Ownership</a> library just like any other external library.</p>
<pre><code class="language-sway">use ownership::Ownership;
</code></pre>
<p>Once imported, you can use the following basic functionality of the library in your smart contract:</p>
<ul>
<li>Declaring an owner</li>
<li>Changing ownership</li>
<li>Renouncing ownership</li>
<li>Ensuring a function may only be called by the owner</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="scripts"><a class="header" href="#scripts">Scripts</a></h1>
<p>A script is runnable bytecode on the chain which executes once to perform some task. It does not represent ownership of any resources and it cannot be called by a contract. A script can return a single value of any type.</p>
<p>Scripts are state-aware in that while they have no persistent storage (because they only exist during the transaction) they can call contracts and act based upon the returned values and results.</p>
<p>This example script calls a contract:</p>
<pre><code class="language-sway">script;

use wallet_abi::Wallet;

fn main() {
    let contract_address = 0x9299da6c73e6dc03eeabcce242bb347de3f5f56cd1c70926d76526d7ed199b8b;
    let caller = abi(Wallet, contract_address);
    let amount_to_send = 200;
    let recipient_address = Address::from(0x9299da6c73e6dc03eeabcce242bb347de3f5f56cd1c70926d76526d7ed199b8b);
    caller
        .send_funds {
            gas: 10000,
            coins: 0,
            asset_id: b256::zero(),
        }(amount_to_send, recipient_address);
}
</code></pre>
<p>Scripts, similar to predicates, rely on a <code>main()</code> function as an entry point. You can call other functions defined in a script from the <code>main()</code> function or call another contract via an <a href="sway-program-types/./smart_contracts.html#calling-a-smart-contract-from-a-script">ABI cast</a>.</p>
<p>An example use case for a script would be a router that trades funds through multiple decentralized exchanges to get the price for the input asset, or a script to re-adjust a Collateralized Debt Position via a flash loan.</p>
<h2 id="scripts-and-the-sdks"><a class="header" href="#scripts-and-the-sdks">Scripts and the SDKs</a></h2>
<p>Unlike EVM transactions which can call a contract directly (but can only call a single contract), Fuel transactions execute a script, which may call zero or more contracts. The Rust and TypeScript SDKs provide functions to call contract methods as if they were calling contracts directly. Under the hood, the SDKs wrap all contract calls with scripts that contain minimal code to simply make the call and forward script data as call parameters.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="predicates"><a class="header" href="#predicates">Predicates</a></h1>
<p>From the perspective of Sway, predicates are programs that return a Boolean value and which represent ownership of some resource upon execution to true. They have no access to contract storage. Here is a trivial predicate, which always evaluates to true:</p>
<pre><code class="language-sway">predicate;

// All predicates require a main function which returns a Boolean value.
fn main() -&gt; bool {
    true
}
</code></pre>
<p>The address of this predicate is <code>0xd19a5fe4cb9baf41ad9813f1a6fef551107c8e8e3f499a6e32bccbb954a74764</code>. Any assets sent to this address can be unlocked or claimed by executing the predicate above as it always evaluates to true.</p>
<p>It does not need to be deployed to a blockchain because it only exists during a transaction. That being said, the predicate address is on-chain as the owner of one or more UTXOs.</p>
<h2 id="transfer-coins-to-a-predicate"><a class="header" href="#transfer-coins-to-a-predicate">Transfer Coins to a Predicate</a></h2>
<p>In Fuel, coins can be sent to a predicate's address(the bytecode root, calculated <a href="https://github.com/FuelLabs/fuel-specs/blob/master/src/identifiers/predicate-id.md">here</a>).</p>
<h2 id="spending-predicate-coins"><a class="header" href="#spending-predicate-coins">Spending Predicate Coins</a></h2>
<p>The coin UTXOs become spendable not on the provision of a valid signature, but rather if the supplied predicate both has a root that matches their owner, and <a href="https://github.com/FuelLabs/fuel-specs/blob/master/src/fuel-vm/index.md#predicate-verification">evaluates</a> to <code>true</code>.</p>
<p>If a predicate reverts, or tries to access impure VM opcodes, the evaluation is automatically <code>false</code>.</p>
<p>An analogy for predicates is rather than a traditional 12 or 24 word seed phrase that generates a private key and creates a valid signature, a predicate's code can be viewed as the private key. Anyone with the code may execute a predicate, but only when the predicate evaluates to true may the assets owned by that address be released.</p>
<h2 id="spending-conditions"><a class="header" href="#spending-conditions">Spending Conditions</a></h2>
<p>Predicates may introspect the transaction spending their coins (inputs, outputs, script bytecode, etc.) and may take runtime arguments, either or both of which may affect the evaluation of the predicate.</p>
<p>It is important to note that predicates cannot read or write memory. They may however check the inputs and outputs of a transaction. For example in the <a href="https://github.com/FuelLabs/sway-applications/tree/master/OTC-swap-predicate">OTC Predicate Swap Example</a>, a user may specify they would like to swap <code>asset1</code> for <code>asset2</code> and with amount of <code>5</code>. The user would then send <code>asset1</code> to the predicate. Only when the predicate can verify that the outputs include <code>5</code> coins of <code>asset2</code> being sent to the original user, may <code>asset1</code> be transferred out of the predicate.</p>
<h2 id="debugging-predicates"><a class="header" href="#debugging-predicates">Debugging Predicates</a></h2>
<p>Because they don't have any side effects (they are <em>pure</em>), predicates cannot create receipts. Therefore, they cannot have logging or create a stack backtrace. This means that there is no native way to debug them aside from using a single-stepping debugger.</p>
<p>As a workaround, the predicate can be written, tested, and debugged first as a <code>script</code>, and then changed back into a <code>predicate</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sway-language-basics"><a class="header" href="#sway-language-basics">Sway Language basics</a></h1>
<p>Sway is a programming language designed for the FuelVM. It is a statically typed, compiled language with type inference and traits. Sway aims to make smart contract development safer and more efficient through the use of strong static analysis and compiler feedback.</p>
<p>Get started with the basics of Sway:</p>
<ul>
<li><a href="basics/./variables.html">Variables</a></li>
<li><a href="basics/./built_in_types.html">Built-in Types</a></li>
<li><a href="basics/./commonly_used_library_types.html">Commonly Used Library Types</a></li>
<li><a href="basics/./blockchain_types.html">Blockchain Types</a></li>
<li><a href="basics/./functions.html">Functions</a></li>
<li><a href="basics/./structs_tuples_and_enums.html">Structs, Tuples, and Enums</a></li>
<li><a href="basics/./methods_and_associated_functions.html">Methods and Associated Functions</a></li>
<li><a href="basics/./constants.html">Constants</a></li>
<li><a href="basics/./comments_and_logging.html">Comments and Logging</a></li>
<li><a href="basics/./control_flow.html">Control Flow</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="variables"><a class="header" href="#variables">Variables</a></h1>
<!-- This section should explain how variables are immutable -->
<!-- immutable_vars:example:start -->
<p>Variables in Sway are <em>immutable by default</em>. This means that, by default, once a variable is declared, its value cannot change. This is one of the ways how Sway encourages safe programming, and many modern languages have this same default.</p>
<!-- immutable_vars:example:end -->
<p>Let's take a look at variables in detail.</p>
<h2 id="declaring-a-variable"><a class="header" href="#declaring-a-variable">Declaring a Variable</a></h2>
<p>Let's look at a variable declaration:</p>
<pre><code class="language-sway">let foo = 5;
</code></pre>
<p>Great! We have just declared a variable, <code>foo</code>. What do we know about <code>foo</code>?</p>
<ol>
<li>It is immutable.</li>
<li>Its value is <code>5</code>.</li>
<li>Its type is <code>u64</code>, a 64-bit unsigned integer.</li>
</ol>
<p><code>u64</code> is the default numeric type, and represents a 64-bit unsigned integer. See the section <a href="basics/./built_in_types.html">Built-in Types</a> for more details.</p>
<p>We can also make a mutable variable. Let's take a look:</p>
<pre><code class="language-sway">let mut foo = 5;
foo = 6;
</code></pre>
<p>Now, <code>foo</code> is mutable, and the reassignment to the number <code>6</code> is valid. That is, we are allowed to <em>mutate</em> the variable <code>foo</code> to change its value.</p>
<p>When assigning to a mutable variable, the right-hand side of the assignment is evaluated before the left-hand side. In the below example, the mutable variable <code>i</code> will first be increased and the resulting value of <code>1</code> will be stored to <code>array[1]</code>, thus resulting in <code>array</code> being changed to <code>[0, 1, 0]</code>.</p>
<pre><code class="language-sway">let mut array = [0, 0, 0];
let mut i = 0;

array[i] = {
    i += 1;
    i
};
</code></pre>
<h2 id="type-annotations"><a class="header" href="#type-annotations">Type Annotations</a></h2>
<!-- This section should explain type annotations -->
<!-- type_annotations:example:start -->
<p>A variable declaration can contain a <em>type annotation</em>. A type annotation serves the purpose of declaring the type, in addition to the value, of a variable.</p>
<!-- type_annotations:example:end -->
<p>Let's take a look:</p>
<pre><code class="language-sway">let foo: u32 = 5;
</code></pre>
<p>We have just declared the <em>type</em> of the variable <code>foo</code> as a <code>u32</code>, which is an unsigned 32-bit integer. Let's take a look at a few other type annotations:</p>
<pre><code class="language-sway">let bar: str[4] = __to_str_array(&quot;sway&quot;);
let baz: bool = true;
</code></pre>
<!-- This section should explain what happens if there is a type conflict -->
<!-- type_conflict:example:start -->
<p>If the value declared cannot be assigned to the declared type, there will be an error generated by the compiler.</p>
<!-- type_conflict:example:end -->
<div style="break-before: page; page-break-before: always;"></div><h1 id="built-in-types"><a class="header" href="#built-in-types">Built-in Types</a></h1>
<p>Every value in Sway is of a certain type. Although deep down, all values are just ones and zeroes in the underlying virtual machine, Sway needs to know what those ones and zeroes actually mean. This is accomplished with <em>types</em>.</p>
<!-- This section should explain how Sway types are inferred -->
<!-- sway_types:example:start -->
<p>Sway is a statically typed language. At compile time, the types of every value must be known. This does not mean you need to specify every single type: usually, the type can be reasonably inferred by the compiler.</p>
<!-- sway_types:example:end -->
<h2 id="primitive-types"><a class="header" href="#primitive-types">Primitive Types</a></h2>
<!-- This section should list the primitive types in Sway -->
<!-- prim_types:example:start -->
<p>Sway has the following primitive types:</p>
<ol>
<li><code>u8</code> (8-bit unsigned integer)</li>
<li><code>u16</code> (16-bit unsigned integer)</li>
<li><code>u32</code> (32-bit unsigned integer)</li>
<li><code>u64</code> (64-bit unsigned integer)</li>
<li><code>u256</code> (256-bit unsigned integer)</li>
<li><code>str[]</code> (fixed-length string)</li>
<li><code>str</code> (string slices)</li>
<li><code>bool</code> (Boolean <code>true</code> or <code>false</code>)</li>
<li><code>b256</code> (256 bits (32 bytes), i.e. a hash)</li>
</ol>
<p>All other types in Sway are built up of these primitive types, or references to these primitive types. You may notice that there are no signed integersâ€”this is by design. In the blockchain domain that Sway occupies, floating-point values and negative numbers have smaller utility, so their implementation has been left up to libraries for specific use cases.</p>
<!-- prim_types:example:end -->
<h2 id="numeric-types"><a class="header" href="#numeric-types">Numeric Types</a></h2>
<p>All of the unsigned integer types are numeric types.</p>
<p>Numbers can be declared with binary syntax, hexadecimal syntax, base-10 syntax, and underscores for delineation. Let's take a look at the following valid numeric primitives:</p>
<pre><code class="language-sway">0xffffff    // hexadecimal
0b10101010  // binary
10          // base-10
100_000     // underscore delineated base-10
0x1111_0000 // underscore delineated binary
0xfff_aaa   // underscore delineated hexadecimal
</code></pre>
<!-- This section should explain the default numeric type in Sway -->
<!-- default_num:example:start -->
<p>The default numeric type is <code>u64</code>. The FuelVM's word size is 64 bits, and the cases where using a smaller numeric type saves space are minimal.</p>
<p>If a 64-bit or 256-bit arithmetic operation produces an overflow or an underflow,
computation gets reverted automatically by FuelVM.</p>
<p>8/16/32-bit arithmetic operations are emulated using their 64-bit analogues with
additional overflow/underflow checks inserted, which generally results in
somewhat higher gas consumption.</p>
<p>The same does not happen with 256-bit operations, including <code>b256</code>, which uses specialized operations and are as efficient as possible.</p>
<!-- default_num:example:end -->
<h2 id="boolean-type"><a class="header" href="#boolean-type">Boolean Type</a></h2>
<!-- This section should explain the `bool` type -->
<!-- bool:example:start -->
<p>The boolean type (<code>bool</code>) has two potential values: <code>true</code> or <code>false</code>. Boolean values are typically used for conditional logic or validation, for example in <code>if</code> expressions. Booleans can be negated, or flipped, with the unary negation operator <code>!</code>.</p>
<!-- bool:example:end -->
<p>For example:</p>
<pre><code class="language-sway">fn returns_false() -&gt; bool {
    let boolean_value: bool = true;
    !boolean_value
}
</code></pre>
<h2 id="string-slices"><a class="header" href="#string-slices">String Slices</a></h2>
<!-- This section should explain the string type in Sway -->
<!-- str:example:start -->
<p>In Sway, string literals are stored as variable length string slices. Which means that they are stored as a pointer to the actual string data and its length.</p>
<!-- str:example:end -->
<pre><code class="language-sway">let my_string: str = &quot;fuel&quot;;
</code></pre>
<p>String slices, because they contain pointers have limited usage. They cannot be used as constants, storage fields, or configurable constants, nor as main function arguments or returns.</p>
<p>For these cases one must use string arrays, as described below.</p>
<h2 id="string-arrays"><a class="header" href="#string-arrays">String Arrays</a></h2>
<!-- This section should explain the string type in Sway -->
<!-- str:example:start -->
<p>In Sway, static-length strings are a primitive type. This means that when you declare a string array, its size is a part of its type. This is necessary for the compiler to know how much memory to give for the storage of that data. The size of the string is denoted with square brackets.</p>
<!-- str:example:end -->
<p>Let's take a look:</p>
<pre><code class="language-sway">let my_string: str[4] = __to_str_array(&quot;fuel&quot;);
</code></pre>
<p>Because the string literal <code>&quot;fuel&quot;</code> is four letters, the type is <code>str[4]</code>, denoting a static length of 4 characters. Strings default to UTF-8 in Sway.</p>
<p>As above, string literals are typed as string slices. So that is why the need for <code>__to_str_array</code> that convert them to string arrays at compile time.</p>
<p>Conversion during runtime can be done with <code>from_str_array</code> and <code>try_as_str_array</code>. The latter can fail, given that the specified string array must be big enough for the string slice content.</p>
<pre><code class="language-sway">let a: str = &quot;abcd&quot;;
let b: str[4] = a.try_as_str_array().unwrap();
let c: str = from_str_array(b);
</code></pre>
<h2 id="compound-types"><a class="header" href="#compound-types">Compound Types</a></h2>
<p><em>Compound types</em> are types that group multiple values into one type. In Sway, we have arrays and tuples.</p>
<h2 id="tuple-types"><a class="header" href="#tuple-types">Tuple Types</a></h2>
<!-- This section should explain what a tuple is -->
<!-- tuple:example:start -->
<p>A tuple is a general-purpose static-length aggregation of types. In more plain terms, a tuple is a single type that consists of an aggregate of zero or more types. The internal types that make up a tuple, and the tuple's arity, define the tuple's type.</p>
<!-- tuple:example:end -->
<p>Let's take a look at some examples.</p>
<pre><code class="language-sway">let x: (u64, u64) = (0, 0);
</code></pre>
<p>This is a tuple, denoted by parenthesized, comma-separated values. Note that the type annotation, <code>(u64, u64)</code>, is similar in syntax to the expression which instantiates that type, <code>(0, 0)</code>.</p>
<pre><code class="language-sway">let x: (u64, bool) = (42, true);
assert(x.1);
</code></pre>
<p>In this example, we have created a new tuple type, <code>(u64, bool)</code>, which is a composite of a <code>u64</code> and a <code>bool</code>.</p>
<!-- This section should explain how to access a value in a tuple -->
<!-- tuple_val:example:start -->
<p>To access a value within a tuple, we use <em>tuple indexing</em>: <code>x.1</code> stands for the first (zero-indexed, so the <code>bool</code>) value of the tuple. Likewise, <code>x.0</code> would be the zeroth, <code>u64</code> value of the tuple. Tuple values can also be accessed via destructuring.</p>
<!-- tuple_val:example:end -->
<pre><code class="language-sway">struct Foo {}
let x: (u64, Foo, bool) = (42, Foo {}, true);
let (number, foo, boolean) = x;
</code></pre>
<p>To create one-arity tuples, we will need to add a trailing comma:</p>
<pre><code class="language-sway">let x: u64 = (42);     // x is of type u64
let y: (u64) = (42);   // y is of type u64
let z: (u64,) = (42,); // z is of type (u64), i.e. a one-arity tuple
let w: (u64) = (42,);  // type error
</code></pre>
<h2 id="arrays"><a class="header" href="#arrays">Arrays</a></h2>
<!-- This section should explain what an array is -->
<!-- array:example:start -->
<p>An array is similar to a tuple, but an array's values must all be of the same type. Arrays can hold arbitrary types including non-primitive types.</p>
<!-- array:example:end -->
<p>An array is written as a comma-separated list inside square brackets:</p>
<pre><code class="language-sway">let x = [1, 2, 3, 4, 5];
</code></pre>
<!-- This section should explain arrays in depth -->
<!-- array_details:example:start -->
<p>Arrays are allocated on the stack since their size is known. An array's size is <em>always</em> static, i.e. it cannot change. An array of five elements cannot become an array of six elements.</p>
<p>Arrays can be iterated over, unlike tuples. An array's type is written as the type the array contains followed by the number of elements, semicolon-separated and within square brackets, e.g., <code>[u64; 5]</code>. To access an element in an array, use the <em>array indexing syntax</em>, i.e. square brackets.</p>
<!-- array_details:example:end -->
<p>Array elements can also be mutated if the underlying array is declared as mutable:</p>
<pre><code class="language-sway">let mut x = [1, 2, 3, 4, 5];
x[0] = 0;
</code></pre>
<pre><code class="language-sway">script;

struct Foo {
    f1: u32,
    f2: b256,
}

fn main() {
    // Array of integers with type ascription
    let array_of_integers: [u8; 5] = [1, 2, 3, 4, 5];

    // Array of strings
    let array_of_strings = [&quot;Bob&quot;, &quot;Jan&quot;, &quot;Ron&quot;];

    // Array of structs
    let array_of_structs: [Foo; 2] = [
        Foo {
            f1: 11,
            f2: 0x1111111111111111111111111111111111111111111111111111111111111111,
        },
        Foo {
            f1: 22,
            f2: 0x2222222222222222222222222222222222222222222222222222222222222222,
        },
    ];

    // Accessing an element of an array
    let mut array_of_bools: [bool; 2] = [true, false];
    assert(array_of_bools[0]);

    // Mutating the element of an array
    array_of_bools[1] = true;
    assert(array_of_bools[1]);
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="commonly-used-library-types"><a class="header" href="#commonly-used-library-types">Commonly Used Library Types</a></h1>
<p>The Sway Standard Library is the foundation of portable Sway software, a set of minimal shared abstractions for the broader Sway ecosystem. It offers core types, library-defined operations on language primitives, native asset management, blockchain contextual operations, access control, storage management, and support for types from other VMs, among many other things. Reference the standard library docs <a href="https://fuellabs.github.io/sway/master/std/index.html">here</a>.</p>
<h2 id="resultt-e"><a class="header" href="#resultt-e"><code>Result&lt;T, E&gt;</code></a></h2>
<!-- This section should explain what the `Result` type is -->
<!-- result:example:start -->
<p>Type <code>Result</code> is the type used for returning and propagating errors. It is an <code>enum</code> with two variants: <code>Ok(T)</code>, representing success and containing a value, and <code>Err(E)</code>, representing error and containing an error value. The <code>T</code> and <code>E</code> in this definition are type parameters, allowing <code>Result</code> to be generic and to be used with any types.</p>
<!-- result:example:end -->
<pre><code class="language-sway">/// `Result` is a type that represents either success (`Ok`) or failure (`Err`).
pub enum Result&lt;T, E&gt; {
    /// Contains the success value.
    Ok: T,
    /// Contains the error value.
    Err: E,
}
</code></pre>
<!-- This section should explain when to use the `Result` type -->
<!-- use_result:example:start -->
<p>Functions return <code>Result</code> whenever errors are expected and recoverable.</p>
<!-- use_result:example:end -->
<p>Take the following example:</p>
<pre><code class="language-sway">script;

enum MyContractError {
    DivisionByZero: (),
}

fn divide(numerator: u64, denominator: u64) -&gt; Result&lt;u64, MyContractError&gt; {
    if (denominator == 0) {
        return Err(MyContractError::DivisionByZero);
    } else {
        Ok(numerator / denominator)
    }
}

fn main() -&gt; Result&lt;u64, str[4]&gt; {
    let result = divide(20, 2);
    match result {
        Ok(value) =&gt; Ok(value),
        Err(MyContractError::DivisionByZero) =&gt; Err(__to_str_array(&quot;Fail&quot;)),
    }
}
</code></pre>
<h2 id="optiont"><a class="header" href="#optiont"><code>Option&lt;T&gt;</code></a></h2>
<!-- This section should explain the `Option` type -->
<!-- option:example:start -->
<p>Type <code>Option</code> represents an optional value: every <code>Option</code> is either <code>Some</code> and contains a value, or <code>None</code>, and does not. <code>Option</code> types are very common in Sway code, as they have a number of uses:</p>
<ul>
<li>Initial values where <code>None</code> can be used as an initializer.</li>
<li>Return value for otherwise reporting simple errors, where <code>None</code> is returned on error.</li>
</ul>
<p>The implementation of <code>Option</code> matches on the variant: if it's <code>Ok</code> it returns the inner value, if it's <code>None</code>, it <a href="https://github.com/FuelLabs/fuel-specs/blob/master/src/fuel-vm/instruction-set.md#rvrt-revert">reverts</a>.</p>
<!-- option:example:end -->
<pre><code class="language-sway">/// A type that represents an optional value, either `Some(val)` or `None`.
pub enum Option&lt;T&gt; {
    /// No value.
    None: (),
    /// Some value of type `T`.
    Some: T,
}
</code></pre>
<!-- This section should explain when to use the `Option` type -->
<!-- use_option:example:start -->
<p><code>Option</code> is commonly paired with pattern matching to query the presence of a value and take action, allowing developers to choose how to handle the <code>None</code> case.</p>
<!-- use_option:example:end -->
<p>Below is an example that uses pattern matching to handle invalid divisions by 0 by returning an <code>Option</code>:</p>
<pre><code class="language-sway">script;

fn divide(numerator: u64, denominator: u64) -&gt; Option&lt;u64&gt; {
    if denominator == 0 {
        None
    } else {
        Some(numerator / denominator)
    }
}

fn main() {
    let result = divide(6, 2);
    // Pattern match to retrieve the value
    match result {
        // The division was valid
        Some(x) =&gt; std::logging::log(x),
        // The division was invalid
        None =&gt; std::logging::log(&quot;Cannot divide by 0&quot;),
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="blockchain-types"><a class="header" href="#blockchain-types">Blockchain Types</a></h1>
<p>Sway is fundamentally a blockchain language, and it offers a selection of types tailored for the blockchain use case.</p>
<p>These are provided via the standard library (<a href="https://github.com/FuelLabs/sway/tree/master/sway-lib-std"><code>lib-std</code></a>) which both add a degree of type-safety, as well as make the intention of the developer more clear.</p>
<h2 id="address-type"><a class="header" href="#address-type"><code>Address</code> Type</a></h2>
<!-- This section should explain the `Address` type -->
<!-- address:example:start -->
<p>The <code>Address</code> type is a type-safe wrapper around the primitive <code>b256</code> type. Unlike the EVM, an address <strong>never</strong> refers to a deployed smart contract (see the <code>ContractId</code> type below). An <code>Address</code> can be either the hash of a public key (effectively an <a href="https://ethereum.org/en/whitepaper/#ethereum-accounts">externally owned account</a> if you're coming from the EVM) or the hash of a <a href="basics/../sway-program-types/predicates.html">predicate</a>. Addresses own UTXOs.</p>
<!-- address:example:end -->
<p>An <code>Address</code> is implemented as follows.</p>
<pre><code class="language-sway">pub struct Address {
    value: b256,
}
</code></pre>
<p>Casting between the <code>b256</code> and <code>Address</code> types must be done explicitly:</p>
<pre><code class="language-sway">let my_number: b256 = 0x000000000000000000000000000000000000000000000000000000000000002A;
let my_address: Address = Address::from(my_number);
let forty_two: b256 = my_address.into();
</code></pre>
<h2 id="contractid-type"><a class="header" href="#contractid-type"><code>ContractId</code> Type</a></h2>
<!-- This section should explain the `ContractId` type -->
<!-- contract_id:example:start -->
<p>The <code>ContractId</code> type is a type-safe wrapper around the primitive <code>b256</code> type. A contract's ID is a unique, deterministic identifier analogous to a contract's address in the EVM. Contracts cannot own UTXOs but can own assets.</p>
<!-- contract_id:example:end -->
<p>A <code>ContractId</code> is implemented as follows.</p>
<pre><code class="language-sway">pub struct ContractId {
    value: b256,
}
</code></pre>
<p>Casting between the <code>b256</code> and <code>ContractId</code> types must be done explicitly:</p>
<pre><code class="language-sway">let my_number: b256 = 0x000000000000000000000000000000000000000000000000000000000000002A;
let my_contract_id: ContractId = ContractId::from(my_number);
let forty_two: b256 = my_contract_id.into();
</code></pre>
<h3 id="getting-a-contracts-contractid"><a class="header" href="#getting-a-contracts-contractid">Getting a Contract's <code>ContractId</code></a></h3>
<p>To get the <code>ContractId</code> of a contract in an internal context use the <code>ContractId::this()</code> function:</p>
<pre><code class="language-sway">impl MyContract for Contract {
    fn foo() {
        let this_contract_id: ContractId = ContractId::this();
    }
}
</code></pre>
<h2 id="identity-type"><a class="header" href="#identity-type"><code>Identity</code> Type</a></h2>
<!-- This section should explain the `Identity` type -->
<!-- identity:example:start -->
<p>The <code>Identity</code> type is an enum that allows for the handling of both <code>Address</code> and <code>ContractId</code> types. This is useful in cases where either type is accepted, e.g., receiving funds from an identified sender, but not caring if the sender is an address or a contract.</p>
<!-- identity:example:end -->
<p>An <code>Identity</code> is implemented as follows.</p>
<pre><code class="language-sway">pub enum Identity {
    Address: Address,
    ContractId: ContractId,
}
</code></pre>
<p>Casting to an <code>Identity</code> must be done explicitly:</p>
<pre><code class="language-sway">        let raw_address: b256 = 0xddec0e7e6a9a4a4e3e57d08d080d71a299c628a46bc609aab4627695679421ca;
        let my_identity: Identity = Identity::Address(Address::from(raw_address));
</code></pre>
<p>A <code>match</code> statement can be used to return to an <code>Address</code> or <code>ContractId</code> as well as handle cases in which their execution differs.</p>
<pre><code class="language-sway">        let my_contract_id: ContractId = match my_identity {
            Identity::ContractId(identity) =&gt; identity,
            _ =&gt; revert(0),
        };
</code></pre>
<pre><code class="language-sway">        match my_identity {
            Identity::Address(address) =&gt; takes_address(address),
            Identity::ContractId(contract_id) =&gt; takes_contract_id(contract_id),
        };
</code></pre>
<!-- This section should explain the use case for the `Identity` type -->
<!-- use_identity:example:start -->
<p>A common use case for <code>Identity</code> is for access control. The use of <code>Identity</code> uniquely allows both <code>ContractId</code> and <code>Address</code> to have access control inclusively.</p>
<!-- use_identity:example:end -->
<pre><code class="language-sway">        let sender = msg_sender().unwrap();
        require(
            sender == storage
                .owner
                .read(),
            MyError::UnauthorizedUser(sender),
        );
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="converting-types"><a class="header" href="#converting-types">Converting Types</a></h1>
<p>Below are some common type conversions in Sway:</p>
<ul>
<li><a href="basics/converting_types.html#identity-conversions">Identity Conversions</a></li>
<li><a href="basics/converting_types.html#string-conversions">String Conversions</a></li>
<li><a href="basics/converting_types.html#number-conversions">Number Conversions</a></li>
<li><a href="basics/converting_types.html#byte-array-conversions">Byte Array Conversions</a></li>
</ul>
<h2 id="identity-conversions"><a class="header" href="#identity-conversions">Identity Conversions</a></h2>
<h3 id="convert-to-identity"><a class="header" href="#convert-to-identity">Convert to <code>Identity</code></a></h3>
<pre><code class="language-sway">    let identity_from_b256: Identity = Identity::Address(Address::from(b256_address));
    let identity_from_address: Identity = Identity::Address(address);
    let identity_from_contract_id: Identity = Identity::ContractId(contract_id);
</code></pre>
<h3 id="convert-identity-to-contractid-or-address"><a class="header" href="#convert-identity-to-contractid-or-address">Convert <code>Identity</code> to <code>ContractId</code> or <code>Address</code></a></h3>
<pre><code class="language-sway">    match my_identity {
        Identity::Address(address) =&gt; log(address),
        Identity::ContractId(contract_id) =&gt; log(contract_id),
    };
</code></pre>
<h3 id="convert-contractid-or-address-to-b256"><a class="header" href="#convert-contractid-or-address-to-b256">Convert <code>ContractId</code> or <code>Address</code> to <code>b256</code></a></h3>
<pre><code class="language-sway">    let b256_from_address: b256 = address.into();
    let b256_from_contract_id: b256 = contract_id.into();
</code></pre>
<h3 id="convert-b256-to-contractid-or-address"><a class="header" href="#convert-b256-to-contractid-or-address">Convert <code>b256</code> to <code>ContractId</code> or <code>Address</code></a></h3>
<pre><code class="language-sway">    let address_from_b256: Address = Address::from(b256_address);
    let contract_id_from_b256: ContractId = ContractId::from(b256_address);
</code></pre>
<h2 id="string-conversions"><a class="header" href="#string-conversions">String Conversions</a></h2>
<h3 id="convert-str-to-str"><a class="header" href="#convert-str-to-str">Convert <code>str</code> to <code>str[]</code></a></h3>
<pre><code class="language-sway">    let fuel_str: str = &quot;fuel&quot;;
    let fuel_str_array: str[4] = fuel_str.try_as_str_array().unwrap();
</code></pre>
<h3 id="convert-str-to-str-1"><a class="header" href="#convert-str-to-str-1">Convert <code>str[]</code> to <code>str</code></a></h3>
<pre><code class="language-sway">    let fuel_str_array: str[4] = __to_str_array(&quot;fuel&quot;);
    let fuel_str: str = from_str_array(fuel_str_array);
</code></pre>
<h2 id="number-conversions"><a class="header" href="#number-conversions">Number Conversions</a></h2>
<h3 id="convert-to-u256"><a class="header" href="#convert-to-u256">Convert to <code>u256</code></a></h3>
<pre><code class="language-sway">    let u8_1: u8 = 2u8;
    let u16_1: u16 = 2u16;
    let u32_1: u32 = 2u32;
    let u64_1: u64 = 2u64;
    let b256_1: b256 = 0x0102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f20;

    let u256_from_u8: u256 = u8_1.as_u256();
    let u256_from_u16: u256 = u16_1.as_u256();
    let u256_from_u32: u256 = u32_1.as_u256();
    let u256_from_u64: u256 = u64_1.as_u256();
    let u256_from_b256: u256 = b256_1.as_u256();
</code></pre>
<h3 id="convert-to-u64"><a class="header" href="#convert-to-u64">Convert to <code>u64</code></a></h3>
<pre><code class="language-sway">    let u8_1: u8 = 2u8;
    let u16_1: u16 = 2u16;
    let u32_1: u32 = 2u32;
    let u256_1: u256 = 0x0000000000000000000000000000000000000000000000000000000000000002u256;

    let u64_from_u8: u64 = u8_1.as_u64();

    let u64_from_u16: u64 = u16_1.as_u64();

    let u64_from_u32: u64 = u32_1.as_u64();

    let u64_from_u256: Option&lt;u64&gt; = &lt;u64 as TryFrom&lt;u256&gt;&gt;::try_from(u256_1);
</code></pre>
<h3 id="convert-to-u32"><a class="header" href="#convert-to-u32">Convert to <code>u32</code></a></h3>
<pre><code class="language-sway">    let u8_1: u8 = 2u8;
    let u16_1: u16 = 2u16;
    let u64_1: u64 = 2;
    let u256_1: u256 = 0x0000000000000000000000000000000000000000000000000000000000000002u256;

    let u32_from_u8: u32 = u8_1.as_u32();

    let u32_from_u16: u32 = u16_1.as_u32();

    let u32_from_u64_1: Option&lt;u32&gt; = u64_1.try_as_u32();
    let u32_from_u64_2: Option&lt;u32&gt; = &lt;u32 as TryFrom&lt;u64&gt;&gt;::try_from(u64_1);

    let u32_from_u256: Option&lt;u32&gt; = &lt;u32 as TryFrom&lt;u256&gt;&gt;::try_from(u256_1);
</code></pre>
<h3 id="convert-to-u16"><a class="header" href="#convert-to-u16">Convert to <code>u16</code></a></h3>
<pre><code class="language-sway">    let u8_1: u8 = 2u8;
    let u32_1: u32 = 2u32;
    let u64_1: u64 = 2;
    let u256_1: u256 = 0x0000000000000000000000000000000000000000000000000000000000000002u256;

    let u16_from_u8: u16 = u8_1.as_u16();

    let u16_from_u32_1: Option&lt;u16&gt; = u32_1.try_as_u16();
    let u16_from_u32_2: Option&lt;u16&gt; = &lt;u16 as TryFrom&lt;u32&gt;&gt;::try_from(u32_1);

    let u16_from_u64_1: Option&lt;u16&gt; = u64_1.try_as_u16();
    let u16_from_u64_2: Option&lt;u16&gt; = &lt;u16 as TryFrom&lt;u64&gt;&gt;::try_from(u64_1);

    let u16_from_u256: Option&lt;u16&gt; = &lt;u16 as TryFrom&lt;u256&gt;&gt;::try_from(u256_1);
</code></pre>
<h3 id="convert-to-u8"><a class="header" href="#convert-to-u8">Convert to <code>u8</code></a></h3>
<pre><code class="language-sway">    let u16_1: u16 = 2u16;
    let u32_1: u32 = 2u32;
    let u64_1: u64 = 2;
    let u256_1: u256 = 0x0000000000000000000000000000000000000000000000000000000000000002u256;

    let u8_from_u16_1: Option&lt;u8&gt; = u16_1.try_as_u8();
    let u8_from_u16_2: Option&lt;u8&gt; = &lt;u8 as TryFrom&lt;u16&gt;&gt;::try_from(u16_1);

    let u8_from_u32_1: Option&lt;u8&gt; = u32_1.try_as_u8();
    let u8_from_u32_2: Option&lt;u8&gt; = &lt;u8 as TryFrom&lt;u32&gt;&gt;::try_from(u32_1);

    let u8_from_u64_1: Option&lt;u8&gt; = u64_1.try_as_u8();
    let u8_from_u64_2: Option&lt;u8&gt; = &lt;u8 as TryFrom&lt;u64&gt;&gt;::try_from(u64_1);

    let u8_from_u256: Option&lt;u8&gt; = &lt;u8 as TryFrom&lt;u256&gt;&gt;::try_from(u256_1);
</code></pre>
<h3 id="convert-to-bytes"><a class="header" href="#convert-to-bytes">Convert to <code>Bytes</code></a></h3>
<pre><code class="language-sway">use std::{bytes::Bytes, bytes_conversions::{b256::*, u16::*, u256::*, u32::*, u64::*,}};
</code></pre>
<pre><code class="language-sway">    let num = 5;
    let little_endian_bytes: Bytes = num.to_le_bytes();
    let big_endian_bytes: Bytes = num.to_be_bytes();
</code></pre>
<h3 id="convert-from-bytes"><a class="header" href="#convert-from-bytes">Convert from <code>Bytes</code></a></h3>
<pre><code class="language-sway">use std::{bytes::Bytes, bytes_conversions::{b256::*, u16::*, u256::*, u32::*, u64::*,}};
</code></pre>
<pre><code class="language-sway">    let u16_from_le_bytes: u16 = u16::from_le_bytes(little_endian_bytes);
    let u16_from_be_bytes: u16 = u16::from_be_bytes(big_endian_bytes);

    let u32_from_le_bytes: u32 = u32::from_le_bytes(little_endian_bytes);
    let u32_from_be_bytes: u32 = u32::from_be_bytes(big_endian_bytes);

    let u64_from_le_bytes: u64 = u64::from_le_bytes(little_endian_bytes);
    let u64_from_be_bytes: u64 = u64::from_be_bytes(big_endian_bytes);

    let u256_from_le_bytes = u256::from_le_bytes(little_endian_bytes);
    let u256_from_be_bytes = u256::from_be_bytes(big_endian_bytes);

    let b256_from_le_bytes = b256::from_le_bytes(little_endian_bytes);
    let b256_from_be_bytes = b256::from_be_bytes(big_endian_bytes);
</code></pre>
<h2 id="byte-array-conversions"><a class="header" href="#byte-array-conversions">Byte Array Conversions</a></h2>
<h3 id="convert-to-a-byte-array"><a class="header" href="#convert-to-a-byte-array">Convert to a Byte Array</a></h3>
<pre><code class="language-sway">use std::array_conversions::{b256::*, u16::*, u256::*, u32::*, u64::*,};
</code></pre>
<pre><code class="language-sway">    let u16_1: u16 = 2u16;
    let u32_1: u32 = 2u32;
    let u64_1: u64 = 2u64;
    let u256_1: u256 = 0x0000000000000000000000000000000000000000000000000000000000000002u256;
    let b256_1: b256 = 0x000000000000000000000000000000000000000000000000000000000000002A;
    // little endian
    let le_byte_array_from_u16: [u8; 2] = u16_1.to_le_bytes();
    let le_byte_array_from_u32: [u8; 4] = u32_1.to_le_bytes();
    let le_byte_array_from_u64: [u8; 8] = u64_1.to_le_bytes();
    let le_byte_array_from_u256: [u8; 32] = u256_1.to_le_bytes();
    let le_byte_array_from_b256: [u8; 32] = b256_1.to_le_bytes();
    // big endian
    let be_byte_array_from_u16: [u8; 2] = u16_1.to_be_bytes();
    let be_byte_array_from_u32: [u8; 4] = u32_1.to_be_bytes();
    let be_byte_array_from_u64: [u8; 8] = u64_1.to_be_bytes();
    let be_byte_array_from_u256: [u8; 32] = u256_1.to_be_bytes();
    let be_byte_array_from_b256: [u8; 32] = b256_1.to_be_bytes();
</code></pre>
<h3 id="convert-from-a-byte-array"><a class="header" href="#convert-from-a-byte-array">Convert from a Byte Array</a></h3>
<pre><code class="language-sway">use std::array_conversions::{b256::*, u16::*, u256::*, u32::*, u64::*,};
</code></pre>
<pre><code class="language-sway">    let u16_byte_array: [u8; 2] = [2_u8, 1_u8];
    let u32_byte_array: [u8; 4] = [4_u8, 3_u8, 2_u8, 1_u8];
    let u64_byte_array: [u8; 8] = [8_u8, 7_u8, 6_u8, 5_u8, 4_u8, 3_u8, 2_u8, 1_u8];
    let u256_byte_array: [u8; 32] = [
        32_u8, 31_u8, 30_u8, 29_u8, 28_u8, 27_u8, 26_u8, 25_u8, 24_u8, 23_u8, 22_u8,
        21_u8, 20_u8, 19_u8, 18_u8, 17_u8, 16_u8, 15_u8, 14_u8, 13_u8, 12_u8, 11_u8,
        10_u8, 9_u8, 8_u8, 7_u8, 6_u8, 5_u8, 4_u8, 3_u8, 2_u8, 1_u8,
    ];
    // little endian
    let le_u16_from_byte_array: u16 = u16::from_le_bytes(u16_byte_array);
    let le_u32_from_byte_array: u32 = u32::from_le_bytes(u32_byte_array);
    let le_u64_from_byte_array: u64 = u64::from_le_bytes(u64_byte_array);
    let le_u256_from_byte_array: u256 = u256::from_le_bytes(u256_byte_array);
    let le_b256_from_byte_array: b256 = b256::from_le_bytes(u256_byte_array);
    // big endian
    let be_u16_from_byte_array: u16 = u16::from_be_bytes(u16_byte_array);
    let be_u32_from_byte_array: u32 = u32::from_be_bytes(u32_byte_array);
    let be_u64_from_byte_array: u64 = u64::from_be_bytes(u64_byte_array);
    let be_u256_from_byte_array: u256 = u256::from_be_bytes(u256_byte_array);
    let be_b256_from_byte_array: b256 = b256::from_be_bytes(u256_byte_array);
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="functions"><a class="header" href="#functions">Functions</a></h1>
<p>Functions in Sway are declared with the <code>fn</code> keyword. Let's take a look:</p>
<pre><code class="language-sway">fn equals(first_param: u64, second_param: u64) -&gt; bool {
    first_param == second_param
}
</code></pre>
<p>We have just declared a function named <code>equals</code> which takes two parameters: <code>first_param</code> and <code>second_param</code>. The parameters must both be 64-bit unsigned integers.</p>
<p>This function also returns a <code>bool</code> value, i.e. either <code>true</code> or <code>false</code>. This function returns <code>true</code> if the two given parameters are equal, and <code>false</code> if they are not. If we want to use this function, we can do so like this:</p>
<pre><code class="language-sway">fn main() {
    equals(5, 5); // evaluates to `true`
    equals(5, 6); // evaluates to `false`
}
</code></pre>
<h2 id="mutable-parameters"><a class="header" href="#mutable-parameters">Mutable Parameters</a></h2>
<!-- This section should explain how/when to use `ref mut` -->
<!-- ref_mut:example:start -->
<p>We can make a function parameter mutable by adding <code>ref mut</code> before the parameter name. This allows mutating the argument passed into the function when the function is called.</p>
<!-- ref_mut:example:end -->
<p>For example:</p>
<pre><code class="language-sway">fn increment(ref mut num: u32) {
    let prev = num;
    num = prev + 1u32;
}
</code></pre>
<p>This function is allowed to mutate its parameter <code>num</code> because of the <code>mut</code> keyword. In addition, the <code>ref</code> keyword instructs the function to modify the argument passed to it when the function is called, instead of modifying a local copy of it.</p>
<pre><code class="language-sway">    let mut num: u32 = 0;
    increment(num);
    assert(num == 1u32); // The function `increment()` modifies `num`
</code></pre>
<p>Note that the variable <code>num</code> itself has to be declared as mutable for the above to compile.</p>
<blockquote>
<p><strong>Note</strong>
It is not currently allowed to use <code>mut</code> without <code>ref</code> or vice versa for a function parameter.</p>
</blockquote>
<p>Similarly, <code>ref mut</code> can be used with more complex data types such as:</p>
<pre><code class="language-sway">fn swap_tuple(ref mut pair: (u64, u64)) {
    let temp = pair.0;
    pair.0 = pair.1;
    pair.1 = temp;
}

fn update_color(ref mut color: Color, new_color: Color) {
    color = new_color;
}
</code></pre>
<p>We can then call these functions as shown below:</p>
<pre><code class="language-sway">    let mut tuple = (42, 24);
    swap_tuple(tuple);
    assert(tuple.0 == 24); // The function `swap_tuple()` modifies `tuple.0`
    assert(tuple.1 == 42); // The function `swap_tuple()` modifies `tuple.1`
    let mut color = Color::Red;
    update_color(color, Color::Blue);
    assert(match color {
        Color::Blue =&gt; true,
        _ =&gt; false,
    }); // The function `update_color()` modifies the color to Blue
</code></pre>
<blockquote>
<p><strong>Note</strong>
The only place, in a Sway program, where the <code>ref</code> keyword is valid is before a mutable function parameter.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="structs-tuples-and-enums"><a class="header" href="#structs-tuples-and-enums">Structs, Tuples, and Enums</a></h1>
<h2 id="structs"><a class="header" href="#structs">Structs</a></h2>
<!-- This section should explain structs in Sway -->
<!-- structs:example:start -->
<p>Structs in Sway are a named grouping of types. You may also be familiar with structs via another name: <em>product types</em>. Sway does not make any significantly unique usages of structs; they are similar to most other languages which have structs. If you're coming from an object-oriented background, a struct is like the data attributes of an object.</p>
<p>Those data attributes are called <em>fields</em> and can be either public or private.</p>
<p>Private struct fields can be accessed only within the module in which their struct is declared. Public fields are accessible everywhere where the struct is accessible. This access control on the field level allows more fine grained encapsulation of data.</p>
<!-- structs:example:end -->
<p>To explain these concepts, let's take a look at the following example, in which we have a module called <em>data_structures</em>.</p>
<p>In that module, we declare a struct named <code>Foo</code> with two fields. The first field is named <code>bar</code>, it is public and it accepts values of type <code>u64</code>. The second field is named <code>baz</code>, it is also public and it accepts <code>bool</code> values.</p>
<p>In a similar way, we define the structs <code>Point</code>, <code>Line</code>, and <code>TupleInStruct</code>. Since all those structs are public, and all their fields are public, they can be instantiated in other modules using the <em>struct instantiation syntax</em> as shown below.</p>
<p>On the other hand, the struct <code>StructWithPrivateFields</code> can be instantiated only within the <em>data_structures</em> module, because it contains private fields. To be able to create instances of such structs outside of the module in which they are declared, the struct must offer <a href="basics/methods_and_associated_functions.html#constructors">constructor associated functions</a>.</p>
<pre><code class="language-sway">// the _data_structures_ module
library;

// Declare a struct type
pub struct Foo {
    pub bar: u64,
    pub baz: bool,
}

// Struct types for destructuring
pub struct Point {
    pub x: u64,
    pub y: u64,
}

pub struct Line {
    pub p1: Point,
    pub p2: Point,
}

pub struct TupleInStruct {
    pub nested_tuple: (u64, (u32, (bool, str))),
}

// Struct type instantiable only in the module _data_structures_
pub struct StructWithPrivateFields {
    pub public_field: u64,
    private_field: u64,
    other_private_field: u64,
}
</code></pre>
<!-- This section should explain how to instantiate a struct in Sway -->
<!-- new_struct:example:start -->
<p>In order to instantiate the struct we use <em>struct instantiation syntax</em>, which is very similar to the declaration syntax except with expressions in place of types.</p>
<p>There are three ways to instantiate the struct.</p>
<ul>
<li>Hard coding values for the fields</li>
<li>Passing in variables with names different than the struct fields</li>
<li>Using a shorthand notation via variables that are the same as the field names</li>
</ul>
<!-- new_struct:example:end -->
<pre><code class="language-sway">library;

mod data_structures;
use data_structures::{Foo, Line, Point, TupleInStruct};

fn hardcoded_instantiation() -&gt; Foo {
    // Instantiate `foo` as `Foo`
    let mut foo = Foo {
        bar: 42,
        baz: false,
    };

    // Access and write to &quot;baz&quot;
    foo.baz = true;

    // Return the struct
    foo
}

fn variable_instantiation() -&gt; Foo {
    // Declare variables with the same names as the fields in `Foo`
    let number = 42;
    let truthness = false;

    // Instantiate `foo` as `Foo`
    let mut foo = Foo {
        bar: number,
        baz: truthness,
    };

    // Access and write to &quot;baz&quot;
    foo.baz = true;

    // Return the struct
    foo
}

fn shorthand_instantiation() -&gt; Foo {
    // Declare variables with the same names as the fields in `Foo`
    let bar = 42;
    let baz = false;

    // Instantiate `foo` as `Foo`
    let mut foo = Foo { bar, baz };

    // Access and write to &quot;baz&quot;
    foo.baz = true;

    // Return the struct
    foo
}

fn struct_destructuring() {
    let point1 = Point { x: 0, y: 0 };
    // Destructure the values from the struct into variables
    let Point { x, y } = point1;

    let point2 = Point { x: 1, y: 1 };
    // If you do not care about specific struct fields then use &quot;..&quot; at the end of your variable list
    let Point { x, .. } = point2;

    let line = Line {
        p1: point1,
        p2: point2,
    };
    // Destructure the values from the nested structs into variables
    let Line {
        p1: Point { x: x0, y: y0 },
        p2: Point { x: x1, y: y1 },
    } = line;
    // You may also destructure tuples nested in structs and structs nested in tuples
    let tuple_in_struct = TupleInStruct {
        nested_tuple: (42u64, (42u32, (true, &quot;ok&quot;))),
    };
    let TupleInStruct {
        nested_tuple: (a, (b, (c, d))),
    } = tuple_in_struct;

    let struct_in_tuple = (Point { x: 2, y: 4 }, Point { x: 3, y: 6 });
    let (Point { x: x0, y: y0 }, Point { x: x1, y: y1 }) = struct_in_tuple;
}
</code></pre>
<blockquote>
<p><strong>Note</strong>
You can mix and match all 3 ways to instantiate the struct at the same time.
Moreover, the order of the fields does not matter when instantiating however we encourage declaring the fields in alphabetical order and instantiating them in the same alphabetical order</p>
</blockquote>
<p>Furthermore, multiple variables can be extracted from a struct using the destructuring syntax.</p>
<h3 id="struct-memory-layout"><a class="header" href="#struct-memory-layout">Struct Memory Layout</a></h3>
<blockquote>
<p><strong>Note</strong>
This information is not vital if you are new to the language, or programming in general</p>
</blockquote>
<p>Structs have zero memory overhead. What that means is that in memory, each struct field is laid out sequentially. No metadata regarding the struct's name or other properties is preserved at runtime. In other words, structs are compile-time constructs. This is the same in Rust, but different in other languages with runtimes like Java.</p>
<h2 id="tuples"><a class="header" href="#tuples">Tuples</a></h2>
<!-- This section should explain what tuples are and how to access tuple values -->
<!-- tuples:example:start -->
<p>Tuples are a <a href="basics/./built_in_types.html#tuple-types">basic static-length type</a> which contain multiple different types within themselves. The type of a tuple is defined by the types of the values within it, and a tuple can contain basic types as well as structs and enums.</p>
<p>You can access values directly by using the <code>.</code> syntax. Moreover, multiple variables can be extracted from a tuple using the destructuring syntax.</p>
<!-- tuples:example:end -->
<pre><code class="language-sway">library;

fn tuple() {
    // You can declare the types yourself
    let tuple1: (u8, bool, u64) = (100, false, 10000);

    // Or have the types be inferred
    let mut tuple2 = (5, true, (&quot;Sway&quot;, 8));

    // Retrieve values from tuples
    let number = tuple1.0;
    let sway = tuple2.2.1;

    // Destructure the values from the tuple into variables
    let (n1, truthness, n2) = tuple1;

    // If you do not care about specific values then use &quot;_&quot;
    let (_, truthness, _) = tuple2;

    // Internally mutate the tuple
    tuple2.1 = false;

    // Or change the values all at once (must keep the same data types)
    tuple2 = (9, false, (&quot;Fuel&quot;, 99));
}
</code></pre>
<h2 id="enums"><a class="header" href="#enums">Enums</a></h2>
<!-- This section should explain what enums are -->
<!-- enums:example:start -->
<p><em>Enumerations</em>, or <em>enums</em>, are also known as <em>sum types</em>. An enum is a type that could be one of several variants. To declare an enum, you enumerate all potential variants.</p>
<!-- enums:example:end -->
<p>Here, we have defined five potential colors. Each enum variant is just the color name. As there is no extra data associated with each variant, we say that each variant is of type <code>()</code>, or unit.</p>
<pre><code class="language-sway">library;

// Declare the enum
enum Color {
    Blue: (),
    Green: (),
    Red: (),
    Silver: (),
    Grey: (),
}

fn main() {
    // To instantiate a variable with the value of an enum the syntax is
    let blue = Color::Blue;
    let silver = Color::Silver;
}
</code></pre>
<h3 id="enums-of-structs"><a class="header" href="#enums-of-structs">Enums of Structs</a></h3>
<p>It is also possible to have an enum variant contain extra data. Take a look at this more substantial example, which combines struct declarations with enum variants:</p>
<pre><code class="language-sway">library;

struct Item {
    price: u64,
    amount: u64,
    id: u64,
}

enum MyEnum {
    Item: Item,
}

fn main() {
    let my_enum = MyEnum::Item(Item {
        price: 5,
        amount: 2,
        id: 42,
    });
}
</code></pre>
<h3 id="enums-of-enums"><a class="header" href="#enums-of-enums">Enums of Enums</a></h3>
<p>It is possible to define enums of enums:</p>
<pre><code class="language-sway">library;

pub enum Error {
    StateError: StateError,
    UserError: UserError,
}

pub enum StateError {
    Void: (),
    Pending: (),
    Completed: (),
}

pub enum UserError {
    InsufficientPermissions: (),
    Unauthorized: (),
}
</code></pre>
<h4 id="preferred-usage"><a class="header" href="#preferred-usage">Preferred usage</a></h4>
<p>The preferred way to use enums is to use the individual (not nested) enums directly because they are easy to follow and the lines are short:</p>
<pre><code class="language-sway">library;

use ::enum_of_enums::{StateError, UserError};

fn preferred() {
    let error1 = StateError::Void;
    let error2 = UserError::Unauthorized;
}
</code></pre>
<h4 id="inadvisable"><a class="header" href="#inadvisable">Inadvisable</a></h4>
<p>If you wish to use the nested form of enums via the <code>Error</code> enum from the example above, then you can instantiate them into variables using the following syntax:</p>
<pre><code class="language-sway">library;

use ::enum_of_enums::{Error, StateError, UserError};

fn avoid() {
    let error1 = Error::StateError(StateError::Void);
    let error2 = Error::UserError(UserError::Unauthorized);
}
</code></pre>
<p>Key points to note:</p>
<ul>
<li>You must import all of the enums you need instead of just the <code>Error</code> enum</li>
<li>The lines may get unnecessarily long (depending on the names)</li>
<li>The syntax is not the most ergonomic</li>
</ul>
<h3 id="enum-memory-layout"><a class="header" href="#enum-memory-layout">Enum Memory Layout</a></h3>
<blockquote>
<p><strong>Note</strong>
This information is not vital if you are new to the language, or programming in general.</p>
</blockquote>
<p>Enums do have some memory overhead. To know which variant is being represented, Sway stores a one-word (8-byte) tag for the enum variant. The space reserved after the tag is equivalent to the size of the <em>largest</em> enum variant. So, to calculate the size of an enum in memory, add 8 bytes to the size of the largest variant. For example, in the case of <code>Color</code> above, where the variants are all <code>()</code>, the size would be 8 bytes since the size of the largest variant is 0 bytes.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="methods-and-associated-functions"><a class="header" href="#methods-and-associated-functions">Methods and Associated Functions</a></h1>
<!-- This section should explain methods & associated functions in Sway -->
<!-- methods_af:example:start -->
<h2 id="methods"><a class="header" href="#methods">Methods</a></h2>
<p>Methods are similar to <a href="basics/functions.html">functions</a> in that we declare them with the <code>fn</code> keyword and they have parameters and return a value. However, unlike functions, <em>Methods</em> are defined within the context of a struct (or enum), and either refers to that type or mutates it. The first parameter of a method is always <code>self</code>, which represents the instance of the struct (or enum) the method is being called on.</p>
<h2 id="associated-functions"><a class="header" href="#associated-functions">Associated Functions</a></h2>
<p><em>Associated functions</em> are very similar to <em>methods</em>, in that they are also defined in the context of a struct or enum, but they do not actually use any of the data in the struct and as a result do not take <em>self</em> as a parameter. Associated functions could be standalone functions, but they are included in a specific type for organizational or semantic reasons.</p>
<h3 id="constructors"><a class="header" href="#constructors">Constructors</a></h3>
<p>Constructors are associated functions that construct, or in other words instantiate, new instances of a type. Their return type is always the type itself. E.g., public structs that have private fields must provide a public constructor, or otherwise they cannot be instantiated outside of the module in which they are declared.</p>
<h2 id="declaring-methods-and-associated-functions"><a class="header" href="#declaring-methods-and-associated-functions">Declaring Methods and Associated Functions</a></h2>
<p>To declare methods and associated functions for a struct or enum, use an <code>impl</code> block. Here, <code>impl</code> is short for implementation.</p>
<!-- methods_af:example:end -->
<pre><code class="language-sway">script;

struct Foo {
    bar: u64,
    baz: bool,
}

impl Foo {
    // this is a _method_, as it takes `self` as a parameter.
    fn is_baz_true(self) -&gt; bool {
        self.baz
    }

    // this is an _associated function_, since it does not take `self` as a parameter.
    // it is at the same time a _constructor_ because it instantiates and returns
    // a new instance of `Foo`.
    fn new_foo(number: u64, boolean: bool) -&gt; Foo {
        Foo {
            bar: number,
            baz: boolean,
        }
    }
}

fn main() {
    let foo = Foo::new_foo(42, true);
    assert(foo.is_baz_true());
}
</code></pre>
<!-- This section should explain how to call a method -->
<!-- call_method:example:start -->
<p>To call a method, simply use dot syntax: <code>foo.iz_baz_true()</code>.</p>
<!-- call_method:example:end -->
<!-- This section should explain how methods + assoc. fns can accept `ref mut` params -->
<!-- ref_mut:example:start -->
<p>Similarly to <a href="basics/functions.html">free functions</a>, methods and associated functions may accept <code>ref mut</code> parameters.</p>
<!-- ref_mut:example:end -->
<p>For example:</p>
<pre><code class="language-sway">struct Coordinates {
    x: u64,
    y: u64,
}

impl Coordinates {
    fn move_right(ref mut self, distance: u64) {
        self.x += distance;
    }
}
</code></pre>
<p>and when called:</p>
<pre><code class="language-sway">    let mut point = Coordinates { x: 1, y: 1 };
    point.move_right(5);
    assert(point.x == 6);
    assert(point.y == 1);
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="constants"><a class="header" href="#constants">Constants</a></h1>
<!-- This section should explain what constants are in Sway -->
<!-- constants:example:start -->
<p>Constants are similar to variables; however, there are a few differences:</p>
<ul>
<li>Constants are always evaluated at compile-time.</li>
<li>Constants can be declared both inside of a <a href="basics/../index.html">function</a> and at global / <code>impl</code> scope.</li>
<li>The <code>mut</code> keyword cannot be used with constants.</li>
</ul>
<!-- constants:example:end -->
<pre><code class="language-sway">const ID: u32 = 0;
</code></pre>
<p>Constant initializer expressions can be quite complex, but they cannot use, for
instance, assembly instructions, storage access, mutable variables, loops and
<code>return</code> statements. Although, function calls, primitive types and compound data
structures are perfectly fine to use:</p>
<pre><code class="language-sway">fn bool_to_num(b: bool) -&gt; u64 {
    if b {
        1
    } else {
        0
    }
}

fn arr_wrapper(a: u64, b: u64, c: u64) -&gt; [u64; 3] {
    [a, b, c]
}

const ARR2 = arr_wrapper(bool_to_num(1) + 42, 2, 3);
</code></pre>
<h2 id="associated-constants"><a class="header" href="#associated-constants">Associated Constants</a></h2>
<!-- This section should explain what associated constants are -->
<!-- assoc_constants:example:start -->
<p>Associated constants are constants associated with a type and can be declared in an <code>impl</code> block or in a <code>trait</code> definition.</p>
<p>Associated constants declared inside a <code>trait</code> definition may omit their initializers to indicate that each implementation of the trait must specify those initializers.</p>
<p>The identifier is the name of the constant used in the path. The type is the type that the
definition has to implement.</p>
<!-- assoc_constants:example:end -->
<p>You can <em>define</em> an associated <code>const</code> directly in the interface surface of a trait:</p>
<pre><code class="language-sway">script;

trait ConstantId {
    const ID: u32 = 0;
}
</code></pre>
<p>Alternatively, you can also <em>declare</em> it in the trait, and implement it in the interface of the
types implementing the trait.</p>
<pre><code class="language-sway">script;

trait ConstantId {
    const ID: u32;
}

struct Struct {}

impl ConstantId for Struct {
    const ID: u32 = 1;
}

fn main() -&gt; u32 {
    Struct::ID
}
</code></pre>
<h3 id="impl-self-constants"><a class="header" href="#impl-self-constants"><code>impl self</code> Constants</a></h3>
<p>Constants can also be declared inside non-trait <code>impl</code> blocks.</p>
<pre><code class="language-sway">script;

struct Point {
    x: u64,
    y: u64,
}

impl Point {
    const ZERO: Point = Point { x: 0, y: 0 };
}

fn main() -&gt; u64  {
    Point::ZERO.x
}
</code></pre>
<h2 id="configurable-constants"><a class="header" href="#configurable-constants">Configurable Constants</a></h2>
<!-- This section should explain what configurable constants are in Sway -->
<!-- config_constants:example:start -->
<p>Configurable constants are special constants that behave like regular constants in the sense that they cannot change during program execution, but they can be configured <em>after</em> the Sway program has been built. The Rust and TS SDKs allow updating the values of these constants by injecting new values for them directly in the bytecode without having to build the program again. These are useful for contract factories and behave somewhat similarly to <code>immutable</code> variables from languages like Solidity.</p>
<!-- config_constants:example:end -->
<p>Configurable constants are declared inside a <code>configurable</code> block and require a type ascription and an initializer as follows:</p>
<pre><code class="language-sway">configurable {
    U8: u8 = 8u8,
    BOOL: bool = true,
    ARRAY: [u32; 3] = [253u32, 254u32, 255u32],
    STR_4: str[4] = __to_str_array(&quot;fuel&quot;),
    STRUCT: StructWithGeneric&lt;u8&gt; = StructWithGeneric {
        field_1: 8u8,
        field_2: 16,
    },
    ENUM: EnumWithGeneric&lt;bool&gt; = EnumWithGeneric::VariantOne(true),
}
</code></pre>
<p>At most one <code>configurable</code> block is allowed in a Sway project. Moreover, <code>configurable</code> blocks are not allowed in libraries.</p>
<p>Configurable constants can be read directly just like regular constants:</p>
<pre><code class="language-sway">    fn return_configurables() -&gt; (u8, bool, [u32; 3], str[4], StructWithGeneric&lt;u8&gt;) {
        (U8, BOOL, ARRAY, STR_4, STRUCT)
    }
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="comments-and-logging"><a class="header" href="#comments-and-logging">Comments and Logging</a></h1>
<h2 id="comments"><a class="header" href="#comments">Comments</a></h2>
<!-- This section should explain how to add comments in Sway -->
<!-- comments:example:start -->
<p>Comments in Sway start with two slashes and continue until the end of the line. For comments that extend beyond a single line, you'll need to include <code>//</code> on each line.</p>
<!-- comments:example:end -->
<pre><code class="language-sway">// hello world
</code></pre>
<pre><code class="language-sway">// let's make a couple of lines
// commented.
</code></pre>
<p>You can also place comments at the ends of lines containing code.</p>
<pre><code class="language-sway">fn main() {
    let baz = 8; // Eight is a lucky number
}
</code></pre>
<p>You can also do block comments</p>
<pre><code class="language-sway">fn main() {
    /*
    You can write on multiple lines
    like this if you want
    */
    let baz = 8;
}
</code></pre>
<h2 id="logging"><a class="header" href="#logging">Logging</a></h2>
<!-- This section should explain logging in Sway -->
<!-- logging:example:start -->
<p>The <code>logging</code> library provides a generic <code>log</code> function that can be imported using <code>use std::logging::log</code> and used to log variables of any type. Each call to <code>log</code> appends a <code>receipt</code> to the list of receipts. There are two types of receipts that a <code>log</code> can generate: <code>Log</code> and <code>LogData</code>.</p>
<!-- logging:example:end -->
<pre><code class="language-sway">fn log_values(){
  // Generates a Log receipt
  log(42);

  // Generates a LogData receipt
  let string = &quot;sway&quot;;
  log(string);
}
</code></pre>
<h3 id="log-receipt"><a class="header" href="#log-receipt"><code>Log</code> Receipt</a></h3>
<!-- This section should explain when `Log` receipts are produced -->
<!-- log_rec:example:start -->
<p>The <code>Log</code> receipt is generated for <em>non-reference</em> types, namely <code>bool</code>, <code>u8</code>, <code>u16</code>, <code>u32</code>, and <code>u64</code>.</p>
<!-- log_rec:example:end -->
<p>For example, logging an integer variable <code>x</code> that holds the value <code>42</code> using <code>log(x)</code> may generate the following receipt:</p>
<pre><code class="language-console">&quot;Log&quot;: {
  &quot;id&quot;: &quot;0000000000000000000000000000000000000000000000000000000000000000&quot;,
  &quot;is&quot;: 10352,
  &quot;pc&quot;: 10404,
  &quot;ra&quot;: 42,
  &quot;rb&quot;: 1018205,
  &quot;rc&quot;: 0,
  &quot;rd&quot;: 0
}
</code></pre>
<p>Note that <code>ra</code> will include the value being logged. The additional registers <code>rc</code> and <code>rd</code> will be zero when using <code>log</code> while <code>rb</code> may include a non-zero value representing a unique ID for the <code>log</code> instance. The unique ID is not meaningful on its own but allows the Rust and the TS SDKs to know the type of the data being logged, by looking up the log ID in the JSON ABI file.</p>
<h3 id="logdata-receipt"><a class="header" href="#logdata-receipt"><code>LogData</code> Receipt</a></h3>
<!-- This section should explain when `LogData` receipts are produced -->
<!-- log_data_rec:example:start -->
<p><code>LogData</code> is generated for <em>reference</em> types which include all types except for <em>non_reference</em> types; and for  <em>non-reference</em> types bigger than 64-bit integers, for example, <code>u256</code>;</p>
<!-- log_data_rec:example:end -->
<p>For example, logging a <code>b256</code> variable <code>b</code> that holds the value <code>0x1111111111111111111111111111111111111111111111111111111111111111</code> using <code>log(b)</code> may generate the following receipt:</p>
<pre><code class="language-console">&quot;LogData&quot;: {
  &quot;data&quot;: &quot;1111111111111111111111111111111111111111111111111111111111111111&quot;,
  &quot;digest&quot;: &quot;02d449a31fbb267c8f352e9968a79e3e5fc95c1bbeaa502fd6454ebde5a4bedc&quot;,
  &quot;id&quot;: &quot;0000000000000000000000000000000000000000000000000000000000000000&quot;,
  &quot;is&quot;: 10352,
  &quot;len&quot;: 32,
  &quot;pc&quot;: 10444,
  &quot;ptr&quot;: 10468,
  &quot;ra&quot;: 0,
  &quot;rb&quot;: 1018194
}
</code></pre>
<p>Note that <code>data</code> in the receipt above will include the value being logged as a hexadecimal. Similarly to the <code>Log</code> receipt, additional registers are written: <code>ra</code> will always be zero when using <code>log</code>, while <code>rb</code> will contain a unique ID for the <code>log</code> instance.</p>
<blockquote>
<p><strong>Note</strong>
The Rust SDK exposes <a href="https://fuellabs.github.io/fuels-rs/master/calling-contracts/logs.html#logs">APIs</a> that allow you to retrieve the logged values and display them nicely based on their types as indicated in the JSON ABI file.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="control-flow"><a class="header" href="#control-flow">Control Flow</a></h1>
<h2 id="if-expressions"><a class="header" href="#if-expressions"><code>if</code> expressions</a></h2>
<!-- This section should explain `if` expressions in Sway -->
<!-- if:example:start -->
<p>Sway supports <em>if</em>, <em>else</em>, and <em>else if</em> expressions that allow you to branch your code depending on conditions.</p>
<!-- if:example:end -->
<p>For example:</p>
<pre><code class="language-sway">fn main() {
    let number = 6;

    if number % 4 == 0 {
        // do something
    } else if number % 3 == 0 {
        // do something else
    } else {
        // do something else
    }
}
</code></pre>
<h3 id="using-if-in-a-let-statement"><a class="header" href="#using-if-in-a-let-statement">Using <code>if</code> in a <code>let</code> statement</a></h3>
<p>Like Rust, <code>if</code>s are expressions in Sway. What this means is you can use <code>if</code> expressions on the right side of a <code>let</code> statement to assign the outcome to a variable.</p>
<pre><code class="language-sway">let my_data = if some_bool &lt; 10 { foo() } else { bar() };
</code></pre>
<p>Note that all branches of the <code>if</code> expression must return a value of the same type.</p>
<h3 id="match-expressions"><a class="header" href="#match-expressions"><code>match</code> expressions</a></h3>
<!-- This section should explain `match` expressions in Sway -->
<!-- match:example:start -->
<p>Sway supports advanced pattern matching through exhaustive <code>match</code> expressions. Unlike an <code>if</code> expression, a <code>match</code> expression asserts <strong>at compile time</strong> that all possible patterns have been matched. If you don't handle all the patterns, you will get compiler error indicating that your <code>match</code> expression is non-exhaustive.</p>
<!-- match:example:end -->
<p>The basic syntax of a <code>match</code> expression is as follows:</p>
<pre><code class="language-sway">let result = match expression {
    pattern1 =&gt; code_to_execute_if_expression_matches_pattern1,
    pattern2 =&gt; code_to_execute_if_expression_matches_pattern2,
    pattern3 | pattern4 =&gt; code_to_execute_if_expression_matches_pattern3_or_pattern4
    ...
    _ =&gt; code_to_execute_if_expression_matches_no_pattern,
}
</code></pre>
<p>Some examples of how you can use a <code>match</code> expression:</p>
<pre><code class="language-sway">script;

// helper functions for our example
fn on_even(num: u64) {
    // do something with even numbers
}
fn on_odd(num: u64) {
    // do something with odd numbers
}

fn main(num: u64) -&gt; u64 {
    // Match as an expression
    let is_even = match num % 2 {
        0 =&gt; true,
        _ =&gt; false,
    };

    // Match as control flow
    let x = 12;
    match x {
        5 =&gt; on_odd(x),
        _ =&gt; on_even(x),
    };

    // Match an enum
    enum Weather {
        Sunny: (),
        Rainy: (),
        Cloudy: (),
        Snowy: (),
    }
    let current_weather = Weather::Sunny;
    let avg_temp = match current_weather {
        Weather::Sunny =&gt; 80,
        Weather::Rainy =&gt; 50,
        Weather::Cloudy =&gt; 60,
        Weather::Snowy =&gt; 20,
    };

    let is_sunny = match current_weather {
        Weather::Sunny =&gt; true,
        Weather::Rainy | Weather::Cloudy | Weather::Snowy =&gt; false,
    };

    // match expression used for a return
    let outside_temp = Weather::Sunny;
    match outside_temp {
        Weather::Sunny =&gt; 80,
        Weather::Rainy =&gt; 50,
        Weather::Cloudy =&gt; 60,
        Weather::Snowy =&gt; 20,
    }
}
</code></pre>
<h2 id="loops"><a class="header" href="#loops">Loops</a></h2>
<h3 id="while"><a class="header" href="#while"><code>while</code></a></h3>
<p>This is what a <code>while</code> loop looks like:</p>
<pre><code class="language-sway">while counter &lt; 10 {
    counter = counter + 1;
}
</code></pre>
<p>You need the <code>while</code> keyword, some condition (<code>value &lt; 10</code> in this case) which will be evaluated each iteration, and a block of code inside the curly braces (<code>{...}</code>) to execute each iteration.</p>
<h3 id="for"><a class="header" href="#for"><code>for</code></a></h3>
<p>This is what a <code>for</code> loop that computes the sum of a vector of numbers looks like:</p>
<pre><code class="language-sway">for element in vector.iter() {
    sum += element;
}
</code></pre>
<p>You need the <code>for</code> keyword, some pattern that contains variable names such as <code>element</code> in this case, the <code>Ã¬n</code> keyword followed by an iterator, and a block of code inside the curly braces (<code>{...}</code>) to execute each iteration. <code>vector.iter()</code> in the example above returns an iterator for the <code>vector</code>. In each iteration, the value of <code>element</code> is updated with the next value in the iterator until the end of the vector is reached and the <code>for</code> loop iteration ends.</p>
<h3 id="break-and-continue"><a class="header" href="#break-and-continue"><code>break</code> and <code>continue</code></a></h3>
<p><code>break</code> and <code>continue</code> keywords are available to use inside the body of a <code>while</code> or <code>for</code> loop. The purpose of the <code>break</code> statement is to break out of a loop early:</p>
<pre><code class="language-sway">fn break_example() -&gt; u64 {
    let mut counter = 1;
    let mut sum = 0;
    let num = 10;
    while true {
        if counter &gt; num {
            break;
        }
        sum += counter;
        counter += 1;
    }
    sum // 1 + 2 + .. + 10 = 55
}
</code></pre>
<p>The purpose of the <code>continue</code> statement is to skip a portion of a loop in an iteration and jump directly into the next iteration:</p>
<pre><code class="language-sway">fn continue_example() -&gt; u64 {
    let mut counter = 0;
    let mut sum = 0;
    let num = 10;
    while counter &lt; num {
        counter += 1;
        if counter % 2 == 0 {
            continue;
        }
        sum += counter;
    }
    sum // 1 + 3 + .. + 9 = 25
}
</code></pre>
<h3 id="nested-loops"><a class="header" href="#nested-loops">Nested loops</a></h3>
<p>You can also use nested <code>while</code> loops if needed:</p>
<pre><code class="language-sway">while condition_1 == true {
    // do stuff...
    while condition_2 == true {
        // do more stuff...
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="blockchain-development-with-sway"><a class="header" href="#blockchain-development-with-sway">Blockchain Development with Sway</a></h1>
<p>Sway is fundamentally a blockchain language. Because of this, it has some features and requirements that you may not have seen in general-purpose programming languages.</p>
<p>These are also some concepts related to the FuelVM and Fuel ecosystem that you may utilize when writing Sway.</p>
<ul>
<li><a href="blockchain-development/./hashing_and_cryptography.html">Hashing and Cryptography</a></li>
<li><a href="blockchain-development/./storage.html">Contract Storage</a></li>
<li><a href="blockchain-development/./purity.html">Function Purity</a></li>
<li><a href="blockchain-development/./identifiers.html">Identifiers</a></li>
<li><a href="blockchain-development/./native_assets.html">Native Assets</a></li>
<li><a href="blockchain-development/./access_control.html">Access Control</a></li>
<li><a href="blockchain-development/./calling_contracts.html">Calling Contracts</a></li>
<li><a href="blockchain-development/./external_code.html">External Code Execution</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hashing-and-cryptography"><a class="header" href="#hashing-and-cryptography">Hashing and Cryptography</a></h1>
<p>The Sway standard library provides easy access to a selection of cryptographic hash functions (<code>sha256</code> and EVM-compatible <code>keccak256</code>), and EVM-compatible <code>secp256k1</code>-based signature recovery operations.</p>
<h2 id="hashing"><a class="header" href="#hashing">Hashing</a></h2>
<pre><code class="language-sway">script;

use std::hash::*;

impl Hash for Location {
    fn hash(self, ref mut state: Hasher) {
        match self {
            Location::Earth =&gt; {
                0_u8.hash(state);
            }
            Location::Mars =&gt; {
                1_u8.hash(state);
            }
        }
    }
}

impl Hash for Stats {
    fn hash(self, ref mut state: Hasher) {
        self.strength.hash(state);
        self.agility.hash(state);
    }
}

impl Hash for Person {
    fn hash(self, ref mut state: Hasher) {
        self.name.hash(state);
        self.age.hash(state);
        self.alive.hash(state);
        self.location.hash(state);
        self.stats.hash(state);
        self.some_tuple.hash(state);
        self.some_array.hash(state);
        self.some_b256.hash(state);
    }
}

const VALUE_A = 0x9280359a3b96819889d30614068715d634ad0cf9bba70c0f430a8c201138f79f;

enum Location {
    Earth: (),
    Mars: (),
}

struct Person {
    name: str,
    age: u64,
    alive: bool,
    location: Location,
    stats: Stats,
    some_tuple: (bool, u64),
    some_array: [u64; 2],
    some_b256: b256,
}

struct Stats {
    strength: u64,
    agility: u64,
}

fn main() {
    let zero = b256::min();
    // Use the generic sha256 to hash some integers
    let sha_hashed_u8 = sha256(u8::max());
    let sha_hashed_u16 = sha256(u16::max());
    let sha_hashed_u32 = sha256(u32::max());
    let sha_hashed_u64 = sha256(u64::max());

    // Or hash a b256
    let sha_hashed_b256 = sha256(VALUE_A);

    // You can hash booleans too
    let sha_hashed_bool = sha256(true);

    // Strings are not a problem either
    let sha_hashed_str = sha256(&quot;Fastest Modular Execution Layer!&quot;);

    // Tuples of any size work too
    let sha_hashed_tuple = sha256((true, 7));

    // As do arrays
    let sha_hashed_array = sha256([4, 5, 6]);

    // Enums work too
    let sha_hashed_enum = sha256(Location::Earth);

    // Complex structs are not a problem
    let sha_hashed_struct = sha256(Person {
        name: &quot;John&quot;,
        age: 9000,
        alive: true,
        location: Location::Mars,
        stats: Stats {
            strength: 10,
            agility: 9,
        },
        some_tuple: (true, 8),
        some_array: [17, 76],
        some_b256: zero,
    });

    log(sha_hashed_u8);
    log(sha_hashed_u16);
    log(sha_hashed_u32);
    log(sha_hashed_u64);
    log(sha_hashed_b256);
    log(sha_hashed_bool);
    log(sha_hashed_str);
    log(sha_hashed_tuple);
    log(sha_hashed_array);
    log(sha_hashed_enum);
    log(sha_hashed_struct);

    // Use the generic keccak256 to hash some integers
    let keccak_hashed_u8 = keccak256(u8::max());
    let keccak_hashed_u16 = keccak256(u16::max());
    let keccak_hashed_u32 = keccak256(u32::max());
    let keccak_hashed_u64 = keccak256(u64::max());

    // Or hash a b256
    let keccak_hashed_b256 = keccak256(VALUE_A);

    // You can hash booleans too
    let keccak_hashed_bool = keccak256(true);

    // Strings are not a problem either
    let keccak_hashed_str = keccak256(&quot;Fastest Modular Execution Layer!&quot;);

    // Tuples of any size work too
    let keccak_hashed_tuple = keccak256((true, 7));

    // As do arrays
    let keccak_hashed_array = keccak256([4, 5, 6]);

    // Enums work too
    let keccak_hashed_enum = keccak256(Location::Earth);

    // Complex structs are not a problem
    let keccak_hashed_struct = keccak256(Person {
        name: &quot;John&quot;,
        age: 9000,
        alive: true,
        location: Location::Mars,
        stats: Stats {
            strength: 10,
            agility: 9,
        },
        some_tuple: (true, 8),
        some_array: [17, 76],
        some_b256: zero,
    });

    log(keccak_hashed_u8);
    log(keccak_hashed_u16);
    log(keccak_hashed_u32);
    log(keccak_hashed_u64);
    log(keccak_hashed_b256);
    log(keccak_hashed_bool);
    log(keccak_hashed_str);
    log(keccak_hashed_tuple);
    log(keccak_hashed_array);
    log(keccak_hashed_enum);
    log(keccak_hashed_struct);
}
</code></pre>
<h2 id="signature-recovery"><a class="header" href="#signature-recovery">Signature Recovery</a></h2>
<pre><code class="language-sway">script;

use std::{b512::B512, ecr::{ec_recover, ec_recover_address, EcRecoverError}};

const MSG_HASH = 0xee45573606c96c98ba970ff7cf9511f1b8b25e6bcd52ced30b89df1e4a9c4323;

fn main() {
    let hi = 0xbd0c9b8792876713afa8bff383eebf31c43437823ed761cc3600d0016de5110c;
    let lo = 0x44ac566bd156b4fc71a4a4cb2655d3dd360c695edb17dc3b64d611e122fea23d;
    let signature: B512 = B512::from((hi, lo));

    // A recovered public key pair.
    let public_key = ec_recover(signature, MSG_HASH);

    // A recovered Fuel address.
    let result_address: Result&lt;Address, EcRecoverError&gt; = ec_recover_address(signature, MSG_HASH);
    if let Ok(address) = result_address {
        log(address.bits());
    } else {
        revert(0);
    }
}
</code></pre>
<blockquote>
<p><strong>Note</strong>: Recovery of EVM addresses is also supported via <code>std::vm::evm</code>.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="storage"><a class="header" href="#storage">Storage</a></h1>
<!-- This section should explain storage in Sway -->
<!-- storage:example:start -->
<p>When developing a <a href="blockchain-development/../sway-program-types/smart_contracts.html">smart contract</a>, you will typically need some sort of persistent storage. In this case, persistent storage, often just called <em>storage</em> in this context, is a place where you can store values that are persisted inside the contract itself. This is in contrast to a regular value in <em>memory</em>, which disappears after the contract exits.</p>
<p>Put in conventional programming terms, contract storage is like saving data to a hard drive. That data is saved even after the program that saved it exits. That data is persistent. Using memory is like declaring a variable in a program: it exists for the duration of the program and is non-persistent.</p>
<p>Some basic use cases of storage include declaring an owner address for a contract and saving balances in a wallet.</p>
<!-- storage:example:end -->
<h2 id="storage-accesses-via-the-storage-keyword"><a class="header" href="#storage-accesses-via-the-storage-keyword">Storage Accesses Via the <code>storage</code> Keyword</a></h2>
<p>Declaring variables in storage requires a <code>storage</code> block that contains a list of all your variables, their types, and their initial values. The initial value can be any expression that can be evaluated to a constant during compilation, as follows:</p>
<pre><code class="language-sway">storage {
    var1: u64 = 1,
    var2: b256 = b256::zero(),
    var3: Address = Address::zero(),
    var4: Option&lt;u8&gt; = None,
}
</code></pre>
<p>To write into a storage variable, you need to use the <code>storage</code> keyword as follows:</p>
<pre><code class="language-sway">        storage.var1.write(42);
        storage
            .var2
            .write(0x1111111111111111111111111111111111111111111111111111111111111111);
        storage
            .var3
            .write(Address::from(0x1111111111111111111111111111111111111111111111111111111111111111));
        storage.var4.write(Some(2u8));
</code></pre>
<p>To read a storage variable, you also need to use the <code>storage</code> keyword. You may use <code>read()</code> or <code>try_read()</code>, however we recommend using <code>try_read()</code> for additional safety.</p>
<pre><code class="language-sway">        let var1: u64 = storage.var1.read();
        let var2: b256 = storage.var2.try_read().unwrap_or(b256::zero());
        let var3: Address = storage.var3.try_read().unwrap_or(Address::zero());
        let var4: Option&lt;u8&gt; = storage.var4.try_read().unwrap_or(None);
</code></pre>
<h2 id="storing-structs"><a class="header" href="#storing-structs">Storing Structs</a></h2>
<p>To store a struct in storage, each variable must be assigned in the <code>storage</code> block. This can be either my assigning the fields individually or using a public <a href="blockchain-development/../basics/methods_and_associated_functions.html#constructors">constructor</a> that can be evaluated to a constant during compilation.</p>
<pre><code class="language-sway">struct Type1 {
    x: u64,
    y: u64,
}

struct Type2 {
    w: b256,
    z: bool,
}

impl Type2 {
    // a constructor that evaluates to a constant during compilation
    fn default() -&gt; Self {
        Self {
            w: 0x0000000000000000000000000000000000000000000000000000000000000000,
            z: true,
        }
    }
}

storage {
    var1: Type1 = Type1 { x: 0, y: 0 },
    var2: Type2 = Type2::default(),
}
</code></pre>
<p>You may write to both fields of a struct and the entire struct as follows:</p>
<pre><code class="language-sway">        // Store individual fields
        storage.var1.x.write(42);
        storage.var1.y.write(77);

        // Store an entire struct
        let new_struct = Type2 {
            w: 0x1111111111111111111111111111111111111111111111111111111111111111,
            z: false,
        };
        storage.var2.write(new_struct);
</code></pre>
<p>The same applies to reading structs from storage, where both the individual and struct as a whole may be read as follows:</p>
<pre><code class="language-sway">        let var1_x: u64 = storage.var1.x.try_read().unwrap_or(0);
        let var1_y: u64 = storage.var1.y.try_read().unwrap_or(0);
        let var2: Type2 = storage.var2.try_read().unwrap_or(Type2::default());
</code></pre>
<h2 id="common-storage-collections"><a class="header" href="#common-storage-collections">Common Storage Collections</a></h2>
<p>We support the following common storage collections:</p>
<ul>
<li><code>StorageMap&lt;K, V&gt;</code></li>
<li><code>StorageVec&lt;T&gt;</code></li>
<li><code>StorageBytes</code></li>
<li><code>StorageString</code></li>
</ul>
<p>Please note that these types are not initialized during compilation. This means that if you try to access a key from a storage map before the storage has been set, for example, the call will revert.</p>
<p>Declaring these variables in storage requires a <code>storage</code> block as follows:</p>
<pre><code class="language-sway">storage {
    storage_map: StorageMap&lt;u64, bool&gt; = StorageMap {},
    storage_vec: StorageVec&lt;b256&gt; = StorageVec {},
    storage_string: StorageString = StorageString {},
    storage_bytes: StorageBytes = StorageBytes {},
}
</code></pre>
<h3 id="storagemapsk-v"><a class="header" href="#storagemapsk-v"><code>StorageMaps&lt;K, V&gt;</code></a></h3>
<p>Generic storage maps are available in the standard library as <code>StorageMap&lt;K, V&gt;</code> which have to be defined inside a <code>storage</code> block and allow you to call <code>insert()</code> and <code>get()</code> to insert values at specific keys and get those values respectively. Refer to <a href="blockchain-development/../common-collections/storage_map.html">Storage Maps</a> for more information about <code>StorageMap&lt;K, V&gt;</code>.</p>
<p><strong>Warning</strong> While the <code>StorageMap&lt;K, V&gt;</code> is currently included in the prelude, to use it the <code>Hash</code> trait must still be imported. This is a known issue and will be resolved.</p>
<pre><code class="language-sway">use std::hash::Hash;

use std::storage::storage_vec::*;

use std::storage::storage_bytes::*;

use std::storage::storage_string::*;

storage {
    storage_map: StorageMap&lt;u64, bool&gt; = StorageMap {},
    storage_vec: StorageVec&lt;b256&gt; = StorageVec {},
    storage_string: StorageString = StorageString {},
    storage_bytes: StorageBytes = StorageBytes {},
}

abi StorageExample {
    #[storage(write)]
    fn store_map();
    #[storage(read)]
    fn get_map();
    #[storage(write)]
    fn store_vec();
    #[storage(read, write)]
    fn get_vec();
    #[storage(write)]
    fn store_string();
    #[storage(read)]
    fn get_string();
    #[storage(write)]
    fn store_bytes();
    #[storage(read)]
    fn get_bytes();
}

impl StorageExample for Contract {
    #[storage(write)]
    fn store_map() {
        storage.storage_map.insert(12, true);
        storage.storage_map.insert(59, false);

        // try_insert() will only insert if a value does not already exist for a key.
        let result = storage.storage_map.try_insert(103, true);
        assert(result.is_ok());
    }
    #[storage(read)]
    fn get_map() {
        // Access directly
        let stored_val1: bool = storage.storage_map.get(12).try_read().unwrap_or(false);

        // First get the storage key and then access the value.
        let storage_key2: StorageKey&lt;bool&gt; = storage.storage_map.get(59);
        let stored_val2: bool = storage_key2.try_read().unwrap_or(false);

        // Unsafely access the value.
        let stored_val3: bool = storage.storage_map.get(103).read();
    }

    #[storage(write)]
    fn store_vec() {
        storage
            .storage_vec
            .push(0x1111111111111111111111111111111111111111111111111111111111111111);
        storage
            .storage_vec
            .push(0x0000000000000000000000000000000000000000000000000000000000000001);
        storage
            .storage_vec
            .push(0x0000000000000000000000000000000000000000000000000000000000000002);

        // Set will overwrite the element stored at the given index.
        storage.storage_vec.set(2, b256::zero());
    }
    #[storage(read, write)]
    fn get_vec() {
        // Method 1: Access the element directly
        // Note: get() does not remove the element from the vec.
        let stored_val1: b256 = storage.storage_vec.get(0).unwrap().try_read().unwrap_or(b256::zero());

        // Method 2: First get the storage key and then access the value.
        let storage_key2: StorageKey&lt;b256&gt; = storage.storage_vec.get(1).unwrap();
        let stored_val2: b256 = storage_key2.try_read().unwrap_or(b256::zero());

        // pop() will remove the last element from the vec.
        let length: u64 = storage.storage_vec.len();
        let stored_val3: b256 = storage.storage_vec.pop().unwrap();
        assert(length != storage.storage_vec.len());
    }

    #[storage(write)]
    fn store_string() {
        let my_string = String::from_ascii_str(&quot;Fuel is blazingly fast&quot;);
        storage.storage_string.write_slice(my_string);
    }
    #[storage(read)]
    fn get_string() {
        let stored_string: String = storage.storage_string.read_slice().unwrap();
    }

    #[storage(write)]
    fn store_bytes() {
        // Setup Bytes
        let mut my_bytes = Bytes::new();
        my_bytes.push(1u8);
        my_bytes.push(2u8);
        my_bytes.push(3u8);

        // Write to storage
        storage.storage_bytes.write_slice(my_bytes);
    }
    #[storage(read)]
    fn get_bytes() {
        let stored_bytes: Bytes = storage.storage_bytes.read_slice().unwrap();
    }
}
</code></pre>
<p>To write to a storage map, call either the <code>insert()</code> or <code>try_insert()</code> functions as follows:</p>
<pre><code class="language-sway">        storage.storage_map.insert(12, true);
        storage.storage_map.insert(59, false);

        // try_insert() will only insert if a value does not already exist for a key.
        let result = storage.storage_map.try_insert(103, true);
        assert(result.is_ok());
</code></pre>
<p>The following demonstrates how to read from a storage map:</p>
<pre><code class="language-sway">        // Access directly
        let stored_val1: bool = storage.storage_map.get(12).try_read().unwrap_or(false);

        // First get the storage key and then access the value.
        let storage_key2: StorageKey&lt;bool&gt; = storage.storage_map.get(59);
        let stored_val2: bool = storage_key2.try_read().unwrap_or(false);

        // Unsafely access the value.
        let stored_val3: bool = storage.storage_map.get(103).read();
</code></pre>
<h3 id="storagevect"><a class="header" href="#storagevect"><code>StorageVec&lt;T&gt;</code></a></h3>
<p>Generic storage vectors are available in the standard library as <code>StorageVec&lt;T&gt;</code> which have to be defined inside a <code>storage</code> block and allow you to call <code>push()</code> and <code>pop()</code> to push and pop values from a vector respectively. Refer to <a href="blockchain-development/../common-collections/storage_vec.html">Storage Vector</a> for more information about <code>StorageVec&lt;T&gt;</code>.</p>
<p>The following demonstrates how to import <code>StorageVec&lt;T&gt;</code>:</p>
<pre><code class="language-sway">use std::storage::storage_vec::*;

use std::storage::storage_bytes::*;

use std::storage::storage_string::*;

storage {
    storage_map: StorageMap&lt;u64, bool&gt; = StorageMap {},
    storage_vec: StorageVec&lt;b256&gt; = StorageVec {},
    storage_string: StorageString = StorageString {},
    storage_bytes: StorageBytes = StorageBytes {},
}

abi StorageExample {
    #[storage(write)]
    fn store_map();
    #[storage(read)]
    fn get_map();
    #[storage(write)]
    fn store_vec();
    #[storage(read, write)]
    fn get_vec();
    #[storage(write)]
    fn store_string();
    #[storage(read)]
    fn get_string();
    #[storage(write)]
    fn store_bytes();
    #[storage(read)]
    fn get_bytes();
}

impl StorageExample for Contract {
    #[storage(write)]
    fn store_map() {
        storage.storage_map.insert(12, true);
        storage.storage_map.insert(59, false);

        // try_insert() will only insert if a value does not already exist for a key.
        let result = storage.storage_map.try_insert(103, true);
        assert(result.is_ok());
    }
    #[storage(read)]
    fn get_map() {
        // Access directly
        let stored_val1: bool = storage.storage_map.get(12).try_read().unwrap_or(false);

        // First get the storage key and then access the value.
        let storage_key2: StorageKey&lt;bool&gt; = storage.storage_map.get(59);
        let stored_val2: bool = storage_key2.try_read().unwrap_or(false);

        // Unsafely access the value.
        let stored_val3: bool = storage.storage_map.get(103).read();
    }

    #[storage(write)]
    fn store_vec() {
        storage
            .storage_vec
            .push(0x1111111111111111111111111111111111111111111111111111111111111111);
        storage
            .storage_vec
            .push(0x0000000000000000000000000000000000000000000000000000000000000001);
        storage
            .storage_vec
            .push(0x0000000000000000000000000000000000000000000000000000000000000002);

        // Set will overwrite the element stored at the given index.
        storage.storage_vec.set(2, b256::zero());
    }
    #[storage(read, write)]
    fn get_vec() {
        // Method 1: Access the element directly
        // Note: get() does not remove the element from the vec.
        let stored_val1: b256 = storage.storage_vec.get(0).unwrap().try_read().unwrap_or(b256::zero());

        // Method 2: First get the storage key and then access the value.
        let storage_key2: StorageKey&lt;b256&gt; = storage.storage_vec.get(1).unwrap();
        let stored_val2: b256 = storage_key2.try_read().unwrap_or(b256::zero());

        // pop() will remove the last element from the vec.
        let length: u64 = storage.storage_vec.len();
        let stored_val3: b256 = storage.storage_vec.pop().unwrap();
        assert(length != storage.storage_vec.len());
    }

    #[storage(write)]
    fn store_string() {
        let my_string = String::from_ascii_str(&quot;Fuel is blazingly fast&quot;);
        storage.storage_string.write_slice(my_string);
    }
    #[storage(read)]
    fn get_string() {
        let stored_string: String = storage.storage_string.read_slice().unwrap();
    }

    #[storage(write)]
    fn store_bytes() {
        // Setup Bytes
        let mut my_bytes = Bytes::new();
        my_bytes.push(1u8);
        my_bytes.push(2u8);
        my_bytes.push(3u8);

        // Write to storage
        storage.storage_bytes.write_slice(my_bytes);
    }
    #[storage(read)]
    fn get_bytes() {
        let stored_bytes: Bytes = storage.storage_bytes.read_slice().unwrap();
    }
}
</code></pre>
<blockquote>
<p><strong>NOTE</strong>: When importing the <code>StorageVec&lt;T&gt;</code>, please be sure to use the glob operator: <code>use std::storage::storage_vec::*</code>.</p>
</blockquote>
<p>The following demonstrates how to write to a <code>StorageVec&lt;T&gt;</code>:</p>
<pre><code class="language-sway">        storage
            .storage_vec
            .push(0x1111111111111111111111111111111111111111111111111111111111111111);
        storage
            .storage_vec
            .push(0x0000000000000000000000000000000000000000000000000000000000000001);
        storage
            .storage_vec
            .push(0x0000000000000000000000000000000000000000000000000000000000000002);

        // Set will overwrite the element stored at the given index.
        storage.storage_vec.set(2, b256::zero());
</code></pre>
<p>The following demonstrates how to read from a <code>StorageVec&lt;T&gt;</code>:</p>
<pre><code class="language-sway">        // Method 1: Access the element directly
        // Note: get() does not remove the element from the vec.
        let stored_val1: b256 = storage.storage_vec.get(0).unwrap().try_read().unwrap_or(b256::zero());

        // Method 2: First get the storage key and then access the value.
        let storage_key2: StorageKey&lt;b256&gt; = storage.storage_vec.get(1).unwrap();
        let stored_val2: b256 = storage_key2.try_read().unwrap_or(b256::zero());

        // pop() will remove the last element from the vec.
        let length: u64 = storage.storage_vec.len();
        let stored_val3: b256 = storage.storage_vec.pop().unwrap();
        assert(length != storage.storage_vec.len());
</code></pre>
<h3 id="storagebytes"><a class="header" href="#storagebytes"><code>StorageBytes</code></a></h3>
<p>Storage of <code>Bytes</code> is available in the standard library as <code>StorageBytes</code> which have to be defined inside a <code>storage</code> block. <code>StorageBytes</code> cannot be manipulated in the same way a <code>StorageVec&lt;T&gt;</code> or <code>StorageMap&lt;K, V&gt;</code> can but stores bytes more efficiently thus reducing gas. Only the entirety of a <code>Bytes</code> may be read/written to storage. This means any changes would require loading the entire <code>Bytes</code> to the heap, making changes, and then storing it once again. If frequent changes are needed, a <code>StorageVec&lt;u8&gt;</code> is recommended.</p>
<p>The following demonstrates how to import <code>StorageBytes</code>:</p>
<pre><code class="language-sway">use std::storage::storage_bytes::*;

use std::storage::storage_string::*;

storage {
    storage_map: StorageMap&lt;u64, bool&gt; = StorageMap {},
    storage_vec: StorageVec&lt;b256&gt; = StorageVec {},
    storage_string: StorageString = StorageString {},
    storage_bytes: StorageBytes = StorageBytes {},
}

abi StorageExample {
    #[storage(write)]
    fn store_map();
    #[storage(read)]
    fn get_map();
    #[storage(write)]
    fn store_vec();
    #[storage(read, write)]
    fn get_vec();
    #[storage(write)]
    fn store_string();
    #[storage(read)]
    fn get_string();
    #[storage(write)]
    fn store_bytes();
    #[storage(read)]
    fn get_bytes();
}

impl StorageExample for Contract {
    #[storage(write)]
    fn store_map() {
        storage.storage_map.insert(12, true);
        storage.storage_map.insert(59, false);

        // try_insert() will only insert if a value does not already exist for a key.
        let result = storage.storage_map.try_insert(103, true);
        assert(result.is_ok());
    }
    #[storage(read)]
    fn get_map() {
        // Access directly
        let stored_val1: bool = storage.storage_map.get(12).try_read().unwrap_or(false);

        // First get the storage key and then access the value.
        let storage_key2: StorageKey&lt;bool&gt; = storage.storage_map.get(59);
        let stored_val2: bool = storage_key2.try_read().unwrap_or(false);

        // Unsafely access the value.
        let stored_val3: bool = storage.storage_map.get(103).read();
    }

    #[storage(write)]
    fn store_vec() {
        storage
            .storage_vec
            .push(0x1111111111111111111111111111111111111111111111111111111111111111);
        storage
            .storage_vec
            .push(0x0000000000000000000000000000000000000000000000000000000000000001);
        storage
            .storage_vec
            .push(0x0000000000000000000000000000000000000000000000000000000000000002);

        // Set will overwrite the element stored at the given index.
        storage.storage_vec.set(2, b256::zero());
    }
    #[storage(read, write)]
    fn get_vec() {
        // Method 1: Access the element directly
        // Note: get() does not remove the element from the vec.
        let stored_val1: b256 = storage.storage_vec.get(0).unwrap().try_read().unwrap_or(b256::zero());

        // Method 2: First get the storage key and then access the value.
        let storage_key2: StorageKey&lt;b256&gt; = storage.storage_vec.get(1).unwrap();
        let stored_val2: b256 = storage_key2.try_read().unwrap_or(b256::zero());

        // pop() will remove the last element from the vec.
        let length: u64 = storage.storage_vec.len();
        let stored_val3: b256 = storage.storage_vec.pop().unwrap();
        assert(length != storage.storage_vec.len());
    }

    #[storage(write)]
    fn store_string() {
        let my_string = String::from_ascii_str(&quot;Fuel is blazingly fast&quot;);
        storage.storage_string.write_slice(my_string);
    }
    #[storage(read)]
    fn get_string() {
        let stored_string: String = storage.storage_string.read_slice().unwrap();
    }

    #[storage(write)]
    fn store_bytes() {
        // Setup Bytes
        let mut my_bytes = Bytes::new();
        my_bytes.push(1u8);
        my_bytes.push(2u8);
        my_bytes.push(3u8);

        // Write to storage
        storage.storage_bytes.write_slice(my_bytes);
    }
    #[storage(read)]
    fn get_bytes() {
        let stored_bytes: Bytes = storage.storage_bytes.read_slice().unwrap();
    }
}
</code></pre>
<blockquote>
<p><strong>NOTE</strong>: When importing the <code>StorageBytes</code>, please be sure to use the glob operator: <code>use std::storage::storage_bytes::*</code>.</p>
</blockquote>
<p>The following demonstrates how to write to a <code>StorageBytes</code>:</p>
<pre><code class="language-sway">        // Setup Bytes
        let mut my_bytes = Bytes::new();
        my_bytes.push(1u8);
        my_bytes.push(2u8);
        my_bytes.push(3u8);

        // Write to storage
        storage.storage_bytes.write_slice(my_bytes);
</code></pre>
<p>The following demonstrates how to read from a <code>StorageBytes</code>:</p>
<pre><code class="language-sway">        let stored_bytes: Bytes = storage.storage_bytes.read_slice().unwrap();
</code></pre>
<h3 id="storagestring"><a class="header" href="#storagestring"><code>StorageString</code></a></h3>
<p>Storage of <code>String</code> is available in the standard library as <code>StorageString</code> which have to be defined inside a <code>storage</code> block. <code>StorageString</code> cannot be manipulated in the same way a <code>StorageVec&lt;T&gt;</code> or <code>StorageMap&lt;K, V&gt;</code>. Only the entirety of a <code>String</code> may be read/written to storage.</p>
<p>The following demonstrates how to import <code>StorageString</code>:</p>
<pre><code class="language-sway">use std::storage::storage_string::*;

storage {
    storage_map: StorageMap&lt;u64, bool&gt; = StorageMap {},
    storage_vec: StorageVec&lt;b256&gt; = StorageVec {},
    storage_string: StorageString = StorageString {},
    storage_bytes: StorageBytes = StorageBytes {},
}

abi StorageExample {
    #[storage(write)]
    fn store_map();
    #[storage(read)]
    fn get_map();
    #[storage(write)]
    fn store_vec();
    #[storage(read, write)]
    fn get_vec();
    #[storage(write)]
    fn store_string();
    #[storage(read)]
    fn get_string();
    #[storage(write)]
    fn store_bytes();
    #[storage(read)]
    fn get_bytes();
}

impl StorageExample for Contract {
    #[storage(write)]
    fn store_map() {
        storage.storage_map.insert(12, true);
        storage.storage_map.insert(59, false);

        // try_insert() will only insert if a value does not already exist for a key.
        let result = storage.storage_map.try_insert(103, true);
        assert(result.is_ok());
    }
    #[storage(read)]
    fn get_map() {
        // Access directly
        let stored_val1: bool = storage.storage_map.get(12).try_read().unwrap_or(false);

        // First get the storage key and then access the value.
        let storage_key2: StorageKey&lt;bool&gt; = storage.storage_map.get(59);
        let stored_val2: bool = storage_key2.try_read().unwrap_or(false);

        // Unsafely access the value.
        let stored_val3: bool = storage.storage_map.get(103).read();
    }

    #[storage(write)]
    fn store_vec() {
        storage
            .storage_vec
            .push(0x1111111111111111111111111111111111111111111111111111111111111111);
        storage
            .storage_vec
            .push(0x0000000000000000000000000000000000000000000000000000000000000001);
        storage
            .storage_vec
            .push(0x0000000000000000000000000000000000000000000000000000000000000002);

        // Set will overwrite the element stored at the given index.
        storage.storage_vec.set(2, b256::zero());
    }
    #[storage(read, write)]
    fn get_vec() {
        // Method 1: Access the element directly
        // Note: get() does not remove the element from the vec.
        let stored_val1: b256 = storage.storage_vec.get(0).unwrap().try_read().unwrap_or(b256::zero());

        // Method 2: First get the storage key and then access the value.
        let storage_key2: StorageKey&lt;b256&gt; = storage.storage_vec.get(1).unwrap();
        let stored_val2: b256 = storage_key2.try_read().unwrap_or(b256::zero());

        // pop() will remove the last element from the vec.
        let length: u64 = storage.storage_vec.len();
        let stored_val3: b256 = storage.storage_vec.pop().unwrap();
        assert(length != storage.storage_vec.len());
    }

    #[storage(write)]
    fn store_string() {
        let my_string = String::from_ascii_str(&quot;Fuel is blazingly fast&quot;);
        storage.storage_string.write_slice(my_string);
    }
    #[storage(read)]
    fn get_string() {
        let stored_string: String = storage.storage_string.read_slice().unwrap();
    }

    #[storage(write)]
    fn store_bytes() {
        // Setup Bytes
        let mut my_bytes = Bytes::new();
        my_bytes.push(1u8);
        my_bytes.push(2u8);
        my_bytes.push(3u8);

        // Write to storage
        storage.storage_bytes.write_slice(my_bytes);
    }
    #[storage(read)]
    fn get_bytes() {
        let stored_bytes: Bytes = storage.storage_bytes.read_slice().unwrap();
    }
}
</code></pre>
<blockquote>
<p><strong>NOTE</strong>: When importing the <code>StorageString</code>, please be sure to use the glob operator: <code>use std::storage::storage_string::*</code>.</p>
</blockquote>
<p>The following demonstrates how to write to a <code>StorageString</code>:</p>
<pre><code class="language-sway">        let my_string = String::from_ascii_str(&quot;Fuel is blazingly fast&quot;);
        storage.storage_string.write_slice(my_string);
</code></pre>
<p>The following demonstrates how to read from a <code>StorageString</code>:</p>
<pre><code class="language-sway">        let stored_string: String = storage.storage_string.read_slice().unwrap();
</code></pre>
<h2 id="advanced-storage"><a class="header" href="#advanced-storage">Advanced Storage</a></h2>
<p>For more advanced storage techniques please refer to the <a href="blockchain-development/../advanced/advanced_storage.html">Advanced Storage</a> page.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="purity"><a class="header" href="#purity">Purity</a></h1>
<!-- This section should explain pure functions in Sway -->
<!-- pure:example:start -->
<p>A function is <em>pure</em> if it does not access any <a href="blockchain-development/./storage.html">persistent storage</a>. Conversely, the function is <em>impure</em> if it does access any storage. Naturally, as storage is only available in smart contracts, impure functions cannot be used in predicates, scripts, or libraries. A pure function cannot call an impure function.</p>
<p>In Sway, functions are pure by default but can be opted into impurity via the <code>storage</code> function attribute. The <code>storage</code> attribute may take <code>read</code> and/or <code>write</code> arguments indicating which type of access the function requires.</p>
<!-- pure:example:end -->
<pre><code class="language-sway">#[storage(read)]
fn get_amount() -&gt; u64 {
    ...
}

#[storage(read, write)]
fn increment_amount(increment: u64) -&gt; u64 {
    ...
}
</code></pre>
<blockquote>
<p><strong>Note</strong>: the <code>#[storage(write)]</code> attribute also permits a function to read from storage. This is due to the fact that partially writing a storage slot requires first reading the slot.</p>
</blockquote>
<!-- This section should explain impure functions in Sway -->
<!-- impure:example:start -->
<p>Impure functions which call other impure functions must have at least the same storage privileges or a superset of those for the function called. For example, to call a function with write access a caller must also have write access, or both read and write access. To call a function with read and write access the caller must also have both privileges.</p>
<!-- impure:example:end -->
<p>The <code>storage</code> attribute may also be applied to <a href="blockchain-development/../basics/methods_and_associated_functions.html">methods and associated functions</a>, <a href="blockchain-development/../advanced/traits.html">trait</a> and <a href="blockchain-development/../sway-program-types/smart_contracts.html#the-abi-declaration">ABI</a> declarations.</p>
<!-- This section should explain the benefits of using pure functions in Sway -->
<!-- pure_benefits:example:start -->
<p>A pure function gives you some guarantees: you will not incur excessive storage gas costs, the compiler can apply additional optimizations, and they are generally easy to reason about and audit.</p>
<!-- pure_benefits:example:end -->
<p><a href="https://docs.soliditylang.org/en/v0.8.10/contracts.html#pure-functions">A similar concept exists in Solidity</a>. Note that Solidity refers to contract storage as <em>contract state</em>, and in the Sway/Fuel ecosystem, these two terms are largely interchangeable.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="identifiers"><a class="header" href="#identifiers">Identifiers</a></h1>
<p>Addresses in Sway are similar to EVM addresses. The two major differences are:</p>
<ol>
<li>Sway addresses are 32 bytes long (instead of 20)</li>
<li>Sway addresses are computed with the SHA-256 hash of the public key instead of the keccak-256 hash.</li>
</ol>
<p>Contracts, on the other hand, are uniquely identified with a contract ID rather than an address. A contract's ID is also 32 bytes long and is calculated <a href="https://fuellabs.github.io/fuel-specs/master/protocol/id/contract">here</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="native-assets"><a class="header" href="#native-assets">Native Assets</a></h1>
<!-- This section should explain native assets in Sway -->
<!-- native_assets:example:start -->
<p>The FuelVM has built-in support for working with multiple assets.</p>
<h2 id="key-differences-between-evm-and-fuelvm-assets"><a class="header" href="#key-differences-between-evm-and-fuelvm-assets">Key Differences Between EVM and FuelVM Assets</a></h2>
<h3 id="erc-20-vs-native-asset"><a class="header" href="#erc-20-vs-native-asset">ERC-20 vs Native Asset</a></h3>
<p>On the EVM, Ether is the native asset. As such, sending ETH to an address or contract is an operation built into the EVM, meaning it doesn't rely on the existence of a smart contract to update balances to track ownership as with ERC-20 tokens.</p>
<p>On the FuelVM, <em>all</em> assets are native and the process for sending <em>any</em> native asset is the same.</p>
<p>While you would still need a smart contract to handle the minting and burning of assets, the sending and receiving of these assets can be done independently of the asset contract.</p>
<p>Just like the EVM however, Fuel has a standard that describes a standard API for Native Assets using the Sway Language. The ERC-20 equivalent for the Sway Language is the <a href="https://github.com/FuelLabs/sway-standards/blob/master/docs/src/src-20-native-asset.md">SRC-20; Native Asset Standard</a>.</p>
<blockquote>
<p><strong>NOTE</strong> It is important to note that Fuel does not have tokens.</p>
</blockquote>
<h3 id="erc-721-vs-native-asset"><a class="header" href="#erc-721-vs-native-asset">ERC-721 vs Native Asset</a></h3>
<p>On the EVM, an ERC-721 token or NFT is a contract that contains multiple tokens which are non-fungible with one another.</p>
<p>On the FuelVM, the ERC-721 equivalent is a Native Asset where each asset has a supply of one. This is defined in the <a href="https://github.com/FuelLabs/sway-standards/blob/master/docs/src/src-20-native-asset.md#non-fungible-asset-restrictions">SRC-20; Native Asset Standard</a> under the Non-Fungible Asset Restrictions.</p>
<p>In practice, this means all NFTs are treated the same as any other Native Asset on Fuel. When writing Sway code, no additional cases for handling non-fungible and fungible assets are required.</p>
<h3 id="no-token-approvals"><a class="header" href="#no-token-approvals">No Token Approvals</a></h3>
<p>An advantage Native Assets bring is that there is no need for token approvals; as with Ether on the EVM. With millions of dollars hacked every year due to misused token approvals, the FuelVM eliminates this attack vector.</p>
<h3 id="asset-vs-coin-vs-token"><a class="header" href="#asset-vs-coin-vs-token">Asset vs Coin vs Token</a></h3>
<p>An &quot;Asset&quot; is a Native Asset on Fuel and has the associated <code>AssetId</code> type. Assets are distinguishable from one another. A &quot;Coin&quot; represents a singular unit of an Asset. Coins of the same Asset are not distinguishable from one another.</p>
<p>Fuel does not use tokens like other ecosystems such as Ethereum and uses Native Assets with a UTXO design instead.</p>
<h2 id="the-assetid-type"><a class="header" href="#the-assetid-type">The <code>AssetId</code> type</a></h2>
<p>The <code>AssetId</code> type represents any Native Asset on Fuel. An <code>AssetId</code> is used for interacting with an asset on the network.</p>
<p>The <code>AssetId</code> of any Native Asset on Fuel is calculated by taking the SHA256 hash digest of the originating <code>ContractId</code> that minted the asset and a <code>SubId</code> i.e. <code>sha256((contract_id, sub_id))</code>.</p>
<h3 id="creating-a-new-assetid"><a class="header" href="#creating-a-new-assetid">Creating a New <code>AssetId</code></a></h3>
<p>There are 3 ways to instantiate a new <code>AssetId</code>:</p>
<h4 id="default"><a class="header" href="#default">Default</a></h4>
<p>When a contract will only ever mint a single asset, it is recommended to use the <code>DEFAULT_ASSET_ID</code> sub id. This is referred to as the default asset of a contract.</p>
<p>To get the default asset from an internal contract call, call the <code>default()</code> function:</p>
<pre><code class="language-sway">    let asset_id: AssetId = AssetId::default();
</code></pre>
<h4 id="new"><a class="header" href="#new">New</a></h4>
<p>If a contract mints multiple assets or if the asset has been minted by an external contract, the <code>new()</code> function will be needed. The <code>new()</code> function takes the <code>ContractId</code> of the contract which minted the token as well as a <code>SubId</code>.</p>
<p>To create a new <code>AssetId</code> using a <code>ContractId</code> and <code>SubId</code>, call the <code>new()</code> function:</p>
<pre><code class="language-sway">    let my_contract_id: ContractId = ContractId::from(0x1000000000000000000000000000000000000000000000000000000000000000);
    let my_sub_id: SubId = 0x2000000000000000000000000000000000000000000000000000000000000000;

    let asset_id: AssetId = AssetId::new(my_contract_id, my_sub_id);
</code></pre>
<h4 id="from"><a class="header" href="#from">From</a></h4>
<p>In the case where the <code>b256</code> value of an asset is already known, you may call the <code>from()</code> function with the <code>b256</code> value.</p>
<pre><code class="language-sway">    let asset_id: AssetId = AssetId::from(0x0000000000000000000000000000000000000000000000000000000000000000);
</code></pre>
<h2 id="the-subid-type"><a class="header" href="#the-subid-type">The <code>SubId</code> type</a></h2>
<p>The SubId is used to differentiate between different assets that are created by the same contract. The <code>SubId</code> is a <code>b256</code> value.</p>
<p>When creating a single new asset on Fuel, we recommend using the <code>DEFAULT_SUB_ID</code> or <code>SubId::zero()</code>.</p>
<h2 id="the-base-asset"><a class="header" href="#the-base-asset">The Base Asset</a></h2>
<p>On the Fuel Network, the base asset is Ether. This is the only asset on the Fuel Network that does not have a <code>SubId</code>.</p>
<p>The Base Asset can be returned anytime by calling the <code>base()</code> function of the <code>AssetId</code> type.</p>
<pre><code class="language-sway">    let base_asset: AssetId = AssetId::base();
</code></pre>
<h2 id="basic-native-asset-functionality"><a class="header" href="#basic-native-asset-functionality">Basic Native Asset Functionality</a></h2>
<h3 id="minting-a-native-asset"><a class="header" href="#minting-a-native-asset">Minting A Native Asset</a></h3>
<p>To mint a new asset, the <code>std::asset::mint()</code> function must be called internally within a contract. A <code>SubId</code> and amount of coins must be provided. These newly minted coins will be owned by the contract which minted them. To mint another asset from the same contract, replace the <code>DEFAULT_SUB_ID</code> with your desired <code>SubId</code>.</p>
<pre><code class="language-sway">        mint(DEFAULT_SUB_ID, mint_amount);
</code></pre>
<p>You may also mint an asset to a specific entity with the <code>std::asset::mint_to()</code> function. Be sure to provide a target <code>Identity</code> that will own the newly minted coins.</p>
<pre><code class="language-sway">        mint_to(target_identity, DEFAULT_SUB_ID, mint_amount);
</code></pre>
<p>If you intend to allow external users to mint assets using your contract, the <a href="https://github.com/FuelLabs/sway-standards/blob/master/docs/src/src-3-minting-and-burning.md#fn-mintrecipient-identity-vault_sub_id-subid-amount-u64">SRC-3; Mint and Burn Standard</a> defines a standard API for minting assets. The <a href="https://fuellabs.github.io/sway-libs/book/asset/supply.html">Sway-Libs Asset Library</a> also provides an additional library to support implementations of the SRC-3 Standard into your contract.</p>
<h3 id="burning-a-native-asset"><a class="header" href="#burning-a-native-asset">Burning a Native Asset</a></h3>
<p>To burn an asset, the <code>std::asset::burn()</code> function must be called internally from the contract which minted them. The <code>SubId</code> used to mint the coins and amount must be provided. The burned coins must be owned by the contract. When an asset is burned it doesn't exist anymore.</p>
<pre><code class="language-sway">        burn(DEFAULT_SUB_ID, burn_amount);
</code></pre>
<p>If you intend to allow external users to burn assets using your contract, the <a href="https://github.com/FuelLabs/sway-standards/blob/master/docs/src/src-3-minting-and-burning.md#fn-mintrecipient-identity-vault_sub_id-subid-amount-u64">SRC-3; Mint and Burn Standard</a> defines a standard API for burning assets. The <a href="https://fuellabs.github.io/sway-libs/book/asset/supply.html">Sway-Libs Asset Library</a> also provides an additional library to support implementations of the SRC-3 Standard into your contract.</p>
<h3 id="transfer-a-native-asset"><a class="header" href="#transfer-a-native-asset">Transfer a Native Asset</a></h3>
<p>To internally transfer a Native Asset, the <code>std::asset::transfer()</code> function must be called. A target <code>Identity</code> or user must be provided as well as the <code>AssetId</code> of the asset and an amount.</p>
<pre><code class="language-sway">        transfer(target, asset_id, coins);
</code></pre>
<h3 id="native-asset-and-transactions"><a class="header" href="#native-asset-and-transactions">Native Asset And Transactions</a></h3>
<h4 id="getting-the-transaction-asset"><a class="header" href="#getting-the-transaction-asset">Getting The Transaction Asset</a></h4>
<p>To query for the Native Asset sent in a transaction, you may call the <code>std::call_frames::msg_asset_id()</code> function.</p>
<pre><code class="language-sway">        let amount = msg_asset_id();
</code></pre>
<h4 id="getting-the-transaction-amount"><a class="header" href="#getting-the-transaction-amount">Getting The Transaction Amount</a></h4>
<p>To query for the amount of coins sent in a transaction, you may call the <code>std::context::msg_amount()</code> function.</p>
<pre><code class="language-sway">        let amount = msg_amount();
</code></pre>
<h3 id="native-assets-and-contracts"><a class="header" href="#native-assets-and-contracts">Native Assets and Contracts</a></h3>
<h4 id="checking-a-contracts-balance"><a class="header" href="#checking-a-contracts-balance">Checking A Contract's Balance</a></h4>
<p>To internally check a contract's balance, call the <code>std::context::this_balance()</code> function with the corresponding <code>AssetId</code>.</p>
<pre><code class="language-sway">        this_balance(asset_id)
</code></pre>
<p>To check the balance of an external contract, call the <code>std::context::balance_of()</code> function with the corresponding <code>AssetId</code>.</p>
<pre><code class="language-sway">        balance_of(target_contract, asset_id)
</code></pre>
<blockquote>
<p><strong>NOTE</strong> Due to the FuelVM's UTXO design, balances of <code>Address</code>'s cannot be returned in the Sway Language. This must be done off-chain using the SDK.</p>
</blockquote>
<h4 id="receiving-native-assets-in-a-contract"><a class="header" href="#receiving-native-assets-in-a-contract">Receiving Native Assets In A Contract</a></h4>
<p>By default, a contract may not receive a Native Asset in a contract call. To allow transferring of assets to the contract, add the <code>#[payable]</code> attribute to the function.</p>
<pre><code class="language-sway">    #[payable]
    fn deposit() {
        assert(msg_amount() &gt; 0);
    }
</code></pre>
<h2 id="native-asset-standards-1"><a class="header" href="#native-asset-standards-1">Native Asset Standards</a></h2>
<p>There are a number of standards developed to enable further functionality for Native Assets and help cross contract functionality. Information on standards can be found in the <a href="https://github.com/FuelLabs/sway-standards">Sway Standards Repo</a>.</p>
<p>We currently have the following standards for Native Assets:</p>
<ul>
<li><a href="https://github.com/FuelLabs/sway-standards/blob/master/docs/src/src-20-native-asset.md">SRC-20; Native Asset Standard</a> defines the implementation of a standard API for Native Assets using the Sway Language.</li>
<li><a href="https://github.com/FuelLabs/sway-standards/blob/master/docs/src/src-3-minting-and-burning.md">SRC-3; Mint and Burn Standard</a> is used to enable mint and burn functionality for Native Assets.</li>
<li><a href="https://github.com/FuelLabs/sway-standards/blob/master/docs/src/src-7-asset-metadata.md">SRC-7; Arbitrary Asset Metadata Standard</a> is used to store metadata for Native Assets.</li>
<li><a href="https://github.com/FuelLabs/sway-standards/blob/master/docs/src/src-6-vault.md">SRC-6; Vault Standard</a> defines the implementation of a standard API for asset vaults developed in Sway.</li>
</ul>
<h2 id="native-asset-libraries"><a class="header" href="#native-asset-libraries">Native Asset Libraries</a></h2>
<p>Additional Libraries have been developed to allow you to quickly create an deploy dApps that follow the <a href="https://github.com/FuelLabs/sway-standards">Sway Standards</a>.</p>
<ul>
<li><a href="https://fuellabs.github.io/sway-libs/book/asset/index.html">Asset Library</a> provides functionality to implement the <a href="https://github.com/FuelLabs/sway-standards/blob/master/docs/src/src-20-native-asset.md">SRC-20; Native Asset Standard</a>, <a href="https://github.com/FuelLabs/sway-standards/blob/master/docs/src/src-3-minting-and-burning.md">SRC-3; Mint and Burn Standard</a>, and <a href="https://github.com/FuelLabs/sway-standards/blob/master/docs/src/src-7-asset-metadata.md">SRC-7; Arbitrary Asset Metadata Standard</a> standards.</li>
</ul>
<!-- native_assets:example:end -->
<h2 id="single-native-asset-example"><a class="header" href="#single-native-asset-example">Single Native Asset Example</a></h2>
<p>In this fully fleshed out example, we show a native asset contract which mints a single asset. This is the equivalent to the ERC-20 Standard use in Ethereum. Note there are no token approval functions.</p>
<p>It implements the <a href="https://github.com/FuelLabs/sway-standards/blob/master/docs/src/src-20-native-asset.md">SRC-20; Native Asset</a>, <a href="https://github.com/FuelLabs/sway-standards/blob/master/docs/src/src-3-minting-and-burning.md">SRC-3; Mint and Burn</a>, and <a href="https://github.com/FuelLabs/sway-standards/blob/master/docs/src/src-5-ownership.md">SRC-5; Ownership</a> standards. It does not use any external libraries.</p>
<pre><code class="language-sway">// ERC20 equivalent in Sway.
contract;

use src3::SRC3;
use src5::{SRC5, State, AccessError};
use src20::SRC20;
use std::{
    asset::{
        burn,
        mint_to,
    },
    call_frames::{
        contract_id,
        msg_asset_id,
    },
    constants::DEFAULT_SUB_ID,
    context::msg_amount,
    string::String,
};

configurable {
    DECIMALS: u8 = 9u8,
    NAME: str[7] = __to_str_array(&quot;MyAsset&quot;),
    SYMBOL: str[5] = __to_str_array(&quot;MYTKN&quot;),
}

storage {
    total_supply: u64 = 0,
    owner: State = State::Uninitialized,
}

// Native Asset Standard
impl SRC20 for Contract {
    #[storage(read)]
    fn total_assets() -&gt; u64 {
        1
    }

    #[storage(read)]
    fn total_supply(asset: AssetId) -&gt; Option&lt;u64&gt; {
        if asset == AssetId::default() {
            Some(storage.total_supply.read())
        } else {
            None
        }
    }

    #[storage(read)]
    fn name(asset: AssetId) -&gt; Option&lt;String&gt; {
        if asset == AssetId::default() {
            Some(String::from_ascii_str(from_str_array(NAME)))
        } else {
            None
        }
    }

    #[storage(read)]
    fn symbol(asset: AssetId) -&gt; Option&lt;String&gt; {
        if asset == AssetId::default() {
            Some(String::from_ascii_str(from_str_array(SYMBOL)))
        } else {
            None
        }
    }

    #[storage(read)]
    fn decimals(asset: AssetId) -&gt; Option&lt;u8&gt; {
        if asset == AssetId::default() {
            Some(DECIMALS)
        } else {
            None
        }
    }
}

// Ownership Standard
impl SRC5 for Contract {
    #[storage(read)]
    fn owner() -&gt; State {
        storage.owner.read()
    }
}

// Mint and Burn Standard
impl SRC3 for Contract {
    #[storage(read, write)]
    fn mint(recipient: Identity, sub_id: SubId, amount: u64) {
        require(sub_id == DEFAULT_SUB_ID, &quot;incorrect-sub-id&quot;);
        require_access_owner();

        storage
            .total_supply
            .write(amount + storage.total_supply.read());
        mint_to(recipient, DEFAULT_SUB_ID, amount);
    }

    #[storage(read, write)]
    fn burn(sub_id: SubId, amount: u64) {
        require(sub_id == DEFAULT_SUB_ID, &quot;incorrect-sub-id&quot;);
        require(msg_amount() &gt;= amount, &quot;incorrect-amount-provided&quot;);
        require(
            msg_asset_id() == AssetId::default(),
            &quot;incorrect-asset-provided&quot;,
        );
        require_access_owner();

        storage
            .total_supply
            .write(storage.total_supply.read() - amount);
        burn(DEFAULT_SUB_ID, amount);
    }
}

abi SingleAsset {
    #[storage(read, write)]
    fn constructor(owner_: Identity);
}

impl SingleAsset for Contract {
    #[storage(read, write)]
    fn constructor(owner_: Identity) {
        require(storage.owner.read() == State::Uninitialized, &quot;owner-initialized&quot;);
        storage.owner.write(State::Initialized(owner_));
    }
}

#[storage(read)]
fn require_access_owner() {
    require(
        storage.owner.read() == State::Initialized(msg_sender().unwrap()),
        AccessError::NotOwner,
    );
}
</code></pre>
<h2 id="multi-native-asset-example"><a class="header" href="#multi-native-asset-example">Multi Native Asset Example</a></h2>
<p>In this fully fleshed out example, we show a native asset contract which mints multiple assets. This is the equivalent to the ERC-1155 Standard use in Ethereum. Note there are no token approval functions.</p>
<p>It implements the <a href="https://github.com/FuelLabs/sway-standards/blob/master/docs/src/src-20-native-asset.md">SRC-20; Native Asset</a>, <a href="https://github.com/FuelLabs/sway-standards/blob/master/docs/src/src-3-minting-and-burning.md">SRC-3; Mint and Burn</a>, and <a href="https://github.com/FuelLabs/sway-standards/blob/master/docs/src/src-5-ownership.md">SRC-5; Ownership</a> standards. It does not use any external libraries.</p>
<pre><code class="language-sway">// ERC1155 equivalent in Sway.
contract;

use src5::{SRC5, State, AccessError};
use src20::SRC20;
use src3::SRC3;
use std::{
    asset::{
        burn,
        mint_to,
    },
    call_frames::{
        contract_id,
        msg_asset_id,
    },
    hash::{
        Hash,
    },
    context::this_balance,
    storage::storage_string::*,
    string::String
};

storage {
    total_assets: u64 = 0,
    total_supply: StorageMap&lt;AssetId, u64&gt; = StorageMap {},
    name: StorageMap&lt;AssetId, StorageString&gt; = StorageMap {},
    symbol: StorageMap&lt;AssetId, StorageString&gt; = StorageMap {},
    decimals: StorageMap&lt;AssetId, u8&gt; = StorageMap {},
    owner: State = State::Uninitialized,
}

// Native Asset Standard
impl SRC20 for Contract {
    #[storage(read)]
    fn total_assets() -&gt; u64 {
        storage.total_assets.read()
    }

    #[storage(read)]
    fn total_supply(asset: AssetId) -&gt; Option&lt;u64&gt; {
        storage.total_supply.get(asset).try_read()
    }

    #[storage(read)]
    fn name(asset: AssetId) -&gt; Option&lt;String&gt; {
        storage.name.get(asset).read_slice()
    }
    
    #[storage(read)]
    fn symbol(asset: AssetId) -&gt; Option&lt;String&gt; {
        storage.symbol.get(asset).read_slice()
    }

    #[storage(read)]
    fn decimals(asset: AssetId) -&gt; Option&lt;u8&gt; {
        storage.decimals.get(asset).try_read()
    }
}

// Mint and Burn Standard
impl SRC3 for Contract {
    #[storage(read, write)]
    fn mint(recipient: Identity, sub_id: SubId, amount: u64) {
        require_access_owner();
        let asset_id = AssetId::new(contract_id(), sub_id);
        let supply = storage.total_supply.get(asset_id).try_read();
        if supply.is_none() {
            storage.total_assets.write(storage.total_assets.try_read().unwrap_or(0) + 1);
        }
        let current_supply = supply.unwrap_or(0);
        storage.total_supply.insert(asset_id, current_supply + amount);
        mint_to(recipient, sub_id, amount);
    }
    
    #[storage(read, write)]
    fn burn(sub_id: SubId, amount: u64) {
        require_access_owner();
        let asset_id = AssetId::new(contract_id(), sub_id);
        require(this_balance(asset_id) &gt;= amount, &quot;not-enough-coins&quot;);
        
        let supply = storage.total_supply.get(asset_id).try_read();
        let current_supply = supply.unwrap_or(0);
        storage.total_supply.insert(asset_id, current_supply - amount);
        burn(sub_id, amount);
    }
}

abi MultiAsset {
    #[storage(read, write)]
    fn constructor(owner_: Identity);
    
    #[storage(read, write)]
    fn set_name(asset: AssetId, name: String);

    #[storage(read, write)]
    fn set_symbol(asset: AssetId, symbol: String);

    #[storage(read, write)]
    fn set_decimals(asset: AssetId, decimals: u8);
}

impl MultiAsset for Contract {
    #[storage(read, write)]
    fn constructor(owner_: Identity) {
        require(storage.owner.read() == State::Uninitialized, &quot;owner-initialized&quot;);
        storage.owner.write(State::Initialized(owner_));
    }
    
    #[storage(read, write)]
    fn set_name(asset: AssetId, name: String) {
        require_access_owner();
        storage.name.insert(asset, StorageString {});
        storage.name.get(asset).write_slice(name);
    }

    #[storage(read, write)]
    fn set_symbol(asset: AssetId, symbol: String) {
        require_access_owner();
        storage.symbol.insert(asset, StorageString {});
        storage.symbol.get(asset).write_slice(symbol);
    }

    #[storage(read, write)]
    fn set_decimals(asset: AssetId, decimals: u8) {
        require_access_owner();
        storage.decimals.insert(asset, decimals);
    }
}

#[storage(read)]
fn require_access_owner() {
    require(
        storage.owner.read() == State::Initialized(msg_sender().unwrap()),
        AccessError::NotOwner,
    );
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="access-control"><a class="header" href="#access-control">Access Control</a></h1>
<!-- This section should explain access control in Sway -->
<!-- access_control:example:start -->
<p>Smart contracts require the ability to restrict access to and identify certain users or contracts. Unlike account-based blockchains, transactions in UTXO-based blockchains (i.e. Fuel) do not necessarily have a unique transaction sender. Additional logic is needed to handle this difference, and is provided by the standard library.</p>
<!-- access_control:example:end -->
<h2 id="msg_sender"><a class="header" href="#msg_sender"><code>msg_sender</code></a></h2>
<!-- This section should explain what the `msg_sender` method is -->
<!-- msg_sender:example:start -->
<p>To deliver an experience akin to the EVM's access control, the <code>std</code> library provides a <code>msg_sender</code> function, which identifies a unique caller based upon the call and/or transaction input data.</p>
<!-- msg_sender:example:end -->
<pre><code class="language-sway">contract;

abi MyOwnedContract {
    fn receive(field_1: u64) -&gt; bool;
}

const OWNER = Address::from(0x9ae5b658754e096e4d681c548daf46354495a437cc61492599e33fc64dcdc30c);

impl MyOwnedContract for Contract {
    fn receive(field_1: u64) -&gt; bool {
        let sender = msg_sender().unwrap();
        if let Identity::Address(addr) = sender {
            assert(addr == OWNER);
        } else {
            revert(0);
        }

        true
    }
}
</code></pre>
<!-- This section should explain how the `msg_sender` method works -->
<!-- msg_sender_details:example:start -->
<p>The <code>msg_sender</code> function works as follows:</p>
<ul>
<li>If the caller is a contract, then <code>Ok(Sender)</code> is returned with the <code>ContractId</code> sender variant.</li>
<li>If the caller is external (i.e. from a script), then all coin input owners in the transaction are checked. If all owners are the same, then <code>Ok(Sender)</code> is returned with the <code>Address</code> sender variant.</li>
<li>If the caller is external and coin input owners are different, then the caller cannot be determined and a <code>Err(AuthError)</code> is returned.</li>
</ul>
<!-- msg_sender_details:example:end -->
<h2 id="contract-ownership"><a class="header" href="#contract-ownership">Contract Ownership</a></h2>
<p>Many contracts require some form of ownership for access control. The <a href="https://github.com/FuelLabs/sway-standards/blob/master/docs/src/src-5-ownership.md">SRC-5 Ownership Standard</a> has been defined to provide an interoperable interface for ownership within contracts.</p>
<p>To accomplish this, use the <a href="https://fuellabs.github.io/sway-libs/book/ownership/index.html">Ownership Library</a> to keep track of the owner. This allows setting and revoking ownership using the variants <code>Some(..)</code> and <code>None</code> respectively. This is better, safer, and more readable than using the <code>Identity</code> type directly where revoking ownership has to be done using some magic value such as <code>b256::zero()</code> or otherwise.</p>
<ul>
<li>The following is an example of how to properly lock a function such that only the owner may call a function:</li>
</ul>
<pre><code class="language-sway">    #[storage(read)]
    fn only_owner() {
        storage.owner.only_owner();
        // Do stuff here
    }
</code></pre>
<p>Setting ownership can be done in one of two ways; During compile time or run time.</p>
<ul>
<li>The following is an example of how to properly set ownership of a contract during compile time:</li>
</ul>
<pre><code class="language-sway">storage {
    owner: Ownership = Ownership::initialized(Identity::Address(Address::zero())),
}
</code></pre>
<ul>
<li>The following is an example of how to properly set ownership of a contract during run time:</li>
</ul>
<pre><code class="language-sway">    #[storage(write)]
    fn set_owner(identity: Identity) {
        storage.owner.set_ownership(identity);
    }
</code></pre>
<ul>
<li>The following is an example of how to properly revoke ownership of a contract:</li>
</ul>
<pre><code class="language-sway">    #[storage(write)]
    fn revoke_ownership() {
        storage.owner.renounce_ownership();
    }
</code></pre>
<ul>
<li>The following is an example of how to properly retrieve the state of ownership:</li>
</ul>
<pre><code class="language-sway">    #[storage(read)]
    fn owner() -&gt; State {
        storage.owner.owner()
    }
</code></pre>
<h2 id="access-control-libraries"><a class="header" href="#access-control-libraries">Access Control Libraries</a></h2>
<p><a href="blockchain-development/../reference/sway_libs.html">Sway-Libs</a> provides the following libraries to enable further access control.</p>
<ul>
<li><a href="https://fuellabs.github.io/sway-libs/book/ownership/index.html">Ownership Library</a>; used to apply restrictions on functions such that only a <strong>single</strong> user may call them. This library provides helper functions for the <a href="https://github.com/FuelLabs/sway-standards/blob/master/docs/src/src-5-ownership.md">SRC-5; Ownership Standard</a>.</li>
<li><a href="https://fuellabs.github.io/sway-libs/book/admin/index.html">Admin Library</a>; used to apply restrictions on functions such that only a select few users may call them like a whitelist.</li>
<li><a href="https://fuellabs.github.io/sway-libs/book/pausable/index.html">Pausable Library</a>; allows contracts to implement an emergency stop mechanism.</li>
<li><a href="https://fuellabs.github.io/sway-libs/book/reentrancy/index.html">Reentrancy Guard Library</a>; used to detect and prevent reentrancy attacks.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="calling-contracts"><a class="header" href="#calling-contracts">Calling Contracts</a></h1>
<p>Smart contracts can be <em>called</em> by other contracts or scripts. In the FuelVM, this is done primarily with the <a href="https://fuellabs.github.io/fuel-specs/master/vm/instruction_set#call-call-contract"><code>call</code></a> instruction.</p>
<p>Sway provides a nice way to manage callable interfaces with its ABI system. The Fuel ABI specification can be found <a href="https://fuellabs.github.io/fuel-specs/master/protocol/abi">here</a>.</p>
<h2 id="example-2"><a class="header" href="#example-2">Example</a></h2>
<p>Here is an example of a contract calling another contract in Sway. A script can call a contract in the same way.</p>
<pre><code class="language-sway">// ./contract_a.sw
contract;

abi ContractA {
    fn receive(field_1: bool, field_2: u64) -&gt; u64;
}

impl ContractA for Contract {
    fn receive(field_1: bool, field_2: u64) -&gt; u64 {
        assert(field_1 == true);
        assert(field_2 &gt; 0);
        return_45()
    }
}

fn return_45() -&gt; u64 {
  45
}
</code></pre>
<pre><code class="language-sway">// ./contract_b.sw
contract;

use contract_a::ContractA;

abi ContractB {
    fn make_call();
}

const contract_id = 0x79fa8779bed2f36c3581d01c79df8da45eee09fac1fd76a5a656e16326317ef0;

impl ContractB for Contract {
    fn make_call() {
      let x = abi(ContractA, contract_id);
      let return_value = x.receive(true, 3); // will be 45
    }
}
</code></pre>
<blockquote>
<p><strong>Note</strong>: The ABI is for external calls only therefore you cannot define a method in the ABI and call it in the same contract. If you want to define a function for a contract, but keep it private so that only your contract can call it, you can define it outside of the <code>impl</code> and call it inside the contract, similar to the <code>return_45()</code> function above.</p>
</blockquote>
<h2 id="advanced-calls"><a class="header" href="#advanced-calls">Advanced Calls</a></h2>
<p>All calls forward a gas stipend, and may additionally forward one native asset with the call.</p>
<p>Here is an example of how to specify the amount of gas (<code>gas</code>), the asset ID of the native asset (<code>asset_id</code>), and the amount of the native asset (<code>coins</code>) to forward:</p>
<pre><code class="language-sway">script;

abi MyContract {
    fn foo(field_1: bool, field_2: u64);
}

fn main() {
    let x = abi(MyContract, 0x79fa8779bed2f36c3581d01c79df8da45eee09fac1fd76a5a656e16326317ef0);
    let asset_id = 0x7777_7777_7777_7777_7777_7777_7777_7777_7777_7777_7777_7777_7777_7777_7777_7777;
    x.foo {
        gas: 5000, asset_id: asset_id, coins: 5000
    }
    (true, 3);
}
</code></pre>
<h2 id="handling-re-entrancy"><a class="header" href="#handling-re-entrancy">Handling Re-entrancy</a></h2>
<p>A common attack vector for smart contracts is <a href="https://docs.soliditylang.org/en/v0.8.4/security-considerations.html#re-entrancy">re-entrancy</a>. Similar to the EVM, the FuelVM allows for re-entrancy.</p>
<p>A <em>stateless</em> re-entrancy guard is included in the <a href="https://fuellabs.github.io/sway-libs/book/reentrancy/index.html"><code>sway-libs</code></a> library. The guard will panic (revert) at run time if re-entrancy is detected.</p>
<pre><code class="language-sway">contract;

use reentrancy::reentrancy_guard;

abi MyContract {
    fn some_method();
}

impl ContractB for Contract {
    fn some_method() {
        reentrancy_guard();
        // do something
    }
}
</code></pre>
<h3 id="cei-pattern-violation-static-analysis"><a class="header" href="#cei-pattern-violation-static-analysis">CEI pattern violation static analysis</a></h3>
<p>Another way of avoiding re-entrancy-related attacks is to follow the so-called
<em>CEI</em> pattern. CEI stands for &quot;Checks, Effects, Interactions&quot;, meaning that the
contract code should first perform safety checks, also known as
&quot;pre-conditions&quot;, then perform effects, i.e. modify or read the contract storage
and execute external contract calls (interaction) only at the very end of the
function/method.</p>
<p>Please see this <a href="https://fravoll.github.io/solidity-patterns/checks_effects_interactions.html">blog post</a>
for more detail on some vulnerabilities in case of storage modification after
interaction and this <a href="https://chainsecurity.com/curve-lp-oracle-manipulation-post-mortem">blog post</a> for
more information on storage reads after interaction.</p>
<p>The Sway compiler implements a check that the CEI pattern is not violated in the
user contract and issues warnings if that's the case.</p>
<p>For example, in the following contract the CEI pattern is violated, because an
external contract call is executed before a storage write.</p>
<pre><code class="language-sway">contract;

mod other_contract;

use other_contract::*;
use std::hash::*;

abi MyContract {
    #[storage(read, write)]
    fn withdraw(external_contract_id: ContractId);
}

storage {
    balances: StorageMap&lt;Identity, u64&gt; = StorageMap::&lt;Identity, u64&gt; {},
}

impl MyContract for Contract {
    #[storage(read, write)]
    fn withdraw(external_contract_id: ContractId) {
        let sender = msg_sender().unwrap();
        let bal = storage.balances.get(sender).try_read().unwrap_or(0);

        assert(bal &gt; 0);

        // External call
        let caller = abi(OtherContract, external_contract_id.into());
        caller.external_call {
            coins: bal,
        }();

        // Storage update _after_ external call
        storage.balances.insert(sender, 0);
    }
}
</code></pre>
<p>Here, <code>other_contract</code> is defined as follows:</p>
<pre><code class="language-sway">library;

abi OtherContract {
    #[payable]
    fn external_call();
}
</code></pre>
<p>The CEI pattern analyzer issues a warning as follows, pointing to the
interaction before a storage modification:</p>
<pre><code class="language-sh">warning
  --&gt; /path/to/contract/main.sw:28:9
   |
26 |
27 |           let caller = abi(OtherContract, external_contract_id.into());
28 |           caller.external_call { coins: bal }();
   |  _________-
29 | |
30 | |         // Storage update _after_ external call
31 | |         storage.balances.insert(sender, 0);
   | |__________________________________________- Storage write after external contract interaction in function or method &quot;withdraw&quot;. Consider making all storage writes before calling another contract
32 |       }
33 |   }
   |
____
</code></pre>
<p>In case there is a storage read after an interaction, the CEI analyzer will issue a similar warning.</p>
<p>In addition to storage reads and writes after an interaction, the CEI analyzer reports analogous warnings about:</p>
<ul>
<li>balance tree updates, i.e. balance tree reads with subsequent writes, which may be produced by the <code>tr</code> and <code>tro</code> ASM instructions or library functions using them under the hood;</li>
<li>balance trees reads with <code>bal</code> instruction;</li>
<li>changes to the output messages that can be produced by the <code>__smo</code> intrinsic function or the <code>smo</code> ASM instruction.</li>
</ul>
<h2 id="differences-from-the-evm"><a class="header" href="#differences-from-the-evm">Differences from the EVM</a></h2>
<p>While the Fuel contract calling paradigm is similar to the EVM's (using an ABI, forwarding gas and data), it differs in <em>two</em> key ways:</p>
<ol>
<li>
<p><a href="blockchain-development/./native_assets.html"><strong>Native assets</strong></a>: FuelVM calls can forward any native asset not just base asset.</p>
</li>
<li>
<p><strong>No data serialization</strong>: Contract calls in the FuelVM do not need to serialize data to pass it between contracts; instead they simply pass a pointer to the data. This is because the FuelVM has a shared global memory which all call frames can read from.</p>
</li>
</ol>
<h2 id="fallback"><a class="header" href="#fallback">Fallback</a></h2>
<p>When a contract is compiled, a special section called &quot;contract selection&quot; is also generated. This section checks if the contract call method matches any of the available ABI methods. If this fails, one of two possible actions will happen:</p>
<p>1 - if no fallback function was specified, the contract will revert;
2 - otherwise, the fallback function will be called.</p>
<p>For all intents and purposes the fallback function is considered a contract method, which means that it has all the limitations that other contract methods have. As the fallback function signature, the function cannot have arguments, but they can return anything.</p>
<p>If for some reason the fallback function needs to returns different types, the intrinsic <code>__contract_ret</code> can be used.</p>
<pre><code class="language-sway">contract;

abi MyContract {
    fn some_method();
}

impl ContractB for Contract {
    fn some_method() {
    }
}

#[fallback]
fn fallback() {
}
</code></pre>
<p>You may still access the method selector and arguments to the call in the fallback.
For instance, let's assume a function <code>fn foobar(bool, u64) {}</code> gets called on a contract that doesn't have it with arguments <code>true</code> and <code>42</code>.
It can execute the following fallback:</p>
<pre><code class="language-sway">#[fallback]
fn fallback() {
    // the method selector is the first four bytes of sha256(&quot;foobar(bool,u64)&quot;)
    // per https://fuellabs.github.io/fuel-specs/master/protocol/abi#function-selector-encoding
    let method_selector = std::call_frames::first_param::&lt;u64&gt;();

    // the arguments tuple is (true, 42)
    let arguments = std::call_frames::second_param::&lt;(bool, u64)&gt;();
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="external-code-execution"><a class="header" href="#external-code-execution">External Code Execution</a></h1>
<p>The <code>std-lib</code> includes a function called <code>run_external</code> that allows Sway contracts to execute arbitrary external Sway code.</p>
<p>This functionality enables features like upgradeable contracts and
proxies.</p>
<h2 id="upgradeable-contracts"><a class="header" href="#upgradeable-contracts">Upgradeable Contracts</a></h2>
<p>Upgradeable contracts are designed to allow the logic of a smart contract to be updated after deployment.</p>
<p>Consider this example proxy contract:</p>
<pre><code class="language-sway">#[namespace(my_storage_namespace)]
storage {
    target_contract: Option&lt;ContractId&gt; = None,
}

impl Proxy for Contract {
    #[storage(write)]
    fn set_target_contract(id: ContractId) {
        storage.target_contract.write(Some(id));
    }

    #[storage(read)]
    fn double_input(_value: u64) -&gt; u64 {
        let target = storage.target_contract.read().unwrap();
        run_external(target)
    }
}
</code></pre>
<p>The contract has two functions:</p>
<ul>
<li><code>set_target_contract</code> updates the <code>target_contract</code> variable in storage with the <code>ContractId</code> of an external contract.</li>
<li><code>double_input</code> reads the <code>target_contract</code> from storage and uses it to run external code. If the <code>target_contract</code> has a function with the same name (<code>double_input</code>), the code in the external <code>double_input</code> function will run.
In this case, the function will return a <code>u64</code>.</li>
</ul>
<p>Notice in the <code>Proxy</code> example above, the storage block has a <code>namespace</code> attribute. Using this attribute is considered a best practice for all proxy contracts in Sway, because it will prevent storage collisions with the implementation contract, as the implementation contract has access to both storage contexts.</p>
<p>Below is what an implementation contract could look like for this:</p>
<pre><code class="language-sway">storage {
    value: u64 = 0,
    // to stay compatible, this has to stay the same in the next version
}

impl Implementation for Contract {
    #[storage(write)]
    fn double_input(value: u64) -&gt; u64 {
        let new_value = value * 2;
        storage.value.write(new_value);
        new_value
    }
}
</code></pre>
<p>This contract has one function called <code>double_input</code>, which calculates the input value times two, updates the <code>value</code> variable in storage, and returns the new value.</p>
<h2 id="how-does-this-differ-from-calling-a-contract"><a class="header" href="#how-does-this-differ-from-calling-a-contract">How does this differ from calling a contract?</a></h2>
<p>There are a couple of major differences between calling a contract directly and using the <code>run_external</code> method.</p>
<p>First, to use <code>run_external</code>, the ABI of the external contract is not required. The proxy contract has no knowledge of the external contract except for its <code>ContractId</code>.</p>
<h3 id="upgradeable-contract-storage"><a class="header" href="#upgradeable-contract-storage">Upgradeable Contract Storage</a></h3>
<p>Second, the storage context of the proxy contract is retained for the loaded code.
This means that in the examples above, the <code>value</code> variable gets updated in the storage for the <em>proxy</em> contract.</p>
<p>For example, if you were to read the <code>value</code> variable by directly calling the implementation contract, you would get a different result than if you read it through the proxy contract.
The proxy contract loads the code and executes it in its own context.</p>
<h2 id="fallback-functions"><a class="header" href="#fallback-functions">Fallback functions</a></h2>
<p>If the function name doesn't exist in the target contract but a <code>fallback</code> function does, the <code>fallback</code> function will be triggered.</p>
<blockquote>
<p>If there is no fallback function, the transaction will revert.</p>
</blockquote>
<p>You can access function parameters for fallback functions using the <code>call_frames</code> module in the <code>std-lib</code>.
For example, to access the <code>_foo</code> input parameter in the proxy function below, you can use the <code>called_args</code> method in the <code>fallback</code> function:</p>
<pre><code class="language-sway">    fn does_not_exist_in_the_target(_foo: u64) -&gt; u64 {
        run_external(TARGET)
    }
</code></pre>
<pre><code class="language-sway">#[fallback]
fn fallback() -&gt; u64 {
    use std::call_frames::*;
    __log(3);
    __log(called_method());
    __log(&quot;double_value&quot;);
    __log(called_method() == &quot;double_value&quot;);
    let foo = called_args::&lt;u64&gt;();
    foo * 3
}
</code></pre>
<p>In this case, the <code>does_not_exist_in_the_target</code> function will return <code>_foo * 3</code>.</p>
<h2 id="limitations"><a class="header" href="#limitations">Limitations</a></h2>
<p>Some limitations of <code>run_external</code> function are:</p>
<ul>
<li>It can only be used with other contracts. Scripts, predicates, and library code cannot be run externally.</li>
<li>If you change the implementation contract, you must maintain the same order of previous storage variables and types, as this is what has been stored in the proxy storage.</li>
<li>You can't use the call stack in another call frame before you use <code>run_external</code>. You can only use the call stack within the call frame that contains <code>run_external</code>.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="advanced-concepts"><a class="header" href="#advanced-concepts">Advanced Concepts</a></h1>
<p>Advanced concepts.</p>
<ul>
<li><a href="advanced/./advanced_types.html">Advanced Types</a></li>
<li><a href="advanced/./advanced_storage.html">Advanced Storage</a></li>
<li><a href="advanced/./generic_types.html">Generic Types</a></li>
<li><a href="advanced/./traits.html">Traits</a></li>
<li><a href="advanced/./associated_types.html">Associated Types</a></li>
<li><a href="advanced/./generics_and_trait_constraints.html">Generics and Trait Constraints</a></li>
<li><a href="advanced/./assembly.html">Assembly</a></li>
<li><a href="advanced/./never_type.html">Never Type</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="advanced-types"><a class="header" href="#advanced-types">Advanced Types</a></h1>
<h2 id="creating-type-synonyms-with-type-aliases"><a class="header" href="#creating-type-synonyms-with-type-aliases">Creating Type Synonyms with Type Aliases</a></h2>
<p>Sway provides the ability to declare a type alias to give an existing type another name. For this we use the <code>type</code> keyword. For example, we can create the alias <code>Kilometers</code> to <code>u64</code> like so:</p>
<pre><code class="language-sway">type Kilometers = u64;
</code></pre>
<p>Now, the alias <code>Kilometers</code> is a <em>synonym</em> for <code>u64</code>. Note that <code>Kilometers</code> is <strong>not</strong> a separate new type. Values that have the type <code>Kilometers</code> will be treated the same as values of type <code>u64</code>:</p>
<pre><code class="language-sway">    let x: u64 = 5;
    let y: Kilometers = 5;
    assert(x + y == 10);
</code></pre>
<p>Because <code>Kilometers</code> and <code>u64</code> are the same type, we can add values of both types and we can pass <code>Kilometers</code> values to functions that take <code>u64</code> parameters. However, using this method, we donâ€™t get the type checking benefits that we get from introducing a <em>separate</em> new type called <code>Kilometers</code>. In other words, if we mix up <code>Kilometers</code> and <code>i32</code> values somewhere, the compiler will not give us an error.</p>
<p>The main use case for type synonyms is to reduce repetition. For example, we might have a lengthy array type like this:</p>
<pre><code class="language-sway">[MyStruct&lt;u64, b256&gt;; 5]
</code></pre>
<p>Writing this lengthy type in function signatures and as type annotations all over the code can be tiresome and error prone. Imagine having a project full of code like this:</p>
<pre><code class="language-sway">fn foo_long(array: [MyStruct&lt;u64, b256&gt;; 5]) -&gt; [MyStruct&lt;u64, b256&gt;; 5] {
    array
}
</code></pre>
<p>A type alias makes this code more manageable by reducing the repetition. Below, weâ€™ve introduced an alias named <code>MyArray</code> for the verbose type and can replace all uses of the type with the shorter alias <code>MyArray</code>:</p>
<pre><code class="language-sway">type MyArray = [MyStruct&lt;u64, b256&gt;; 5];

fn foo_shorter(array: MyArray) -&gt; MyArray {
    array
}
</code></pre>
<p>This code is much easier to read and write! Choosing a meaningful name for a type alias can help communicate your intent as well.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="advanced-storage-1"><a class="header" href="#advanced-storage-1">Advanced Storage</a></h1>
<h2 id="nested-storage-collections"><a class="header" href="#nested-storage-collections">Nested Storage Collections</a></h2>
<p>Through the use of <code>StorageKey</code>s, you may have nested storage collections such as storing a <code>StorageString</code> in a <code>StorageMap&lt;K, V&gt;</code>.</p>
<p>For example, here we have a few common nested storage types declared in a <code>storage</code> block:</p>
<pre><code class="language-sway">storage {
    nested_map_vec: StorageMap&lt;u64, StorageVec&lt;u8&gt;&gt; = StorageMap {},
    nested_map_string: StorageMap&lt;u64, StorageString&gt; = StorageMap {},
    nested_vec_bytes: StorageVec&lt;StorageBytes&gt; = StorageVec {},
}
</code></pre>
<p>Please note that storage initialization is needed to do this.</p>
<blockquote>
<p><strong>NOTE</strong>: When importing a storage type, please be sure to use the glob operator i.e. <code>use std::storage::storage_vec::*</code>.</p>
</blockquote>
<h3 id="storing-a-storagevect-in-a-storagemapk-v"><a class="header" href="#storing-a-storagevect-in-a-storagemapk-v">Storing a <code>StorageVec&lt;T&gt;</code> in a <code>StorageMap&lt;K, V&gt;</code></a></h3>
<p>The following demonstrates how to write to a <code>StorageVec&lt;T&gt;</code> that is nested in a <code>StorageMap&lt;T, V&gt;</code>:</p>
<pre><code class="language-sway">        // Setup and initialize storage for the StorageVec.
        storage.nested_map_vec.try_insert(10, StorageVec {});

        // Method 1: Push to the vec directly
        storage.nested_map_vec.get(10).push(1u8);
        storage.nested_map_vec.get(10).push(2u8);
        storage.nested_map_vec.get(10).push(3u8);

        // Method 2: First get the storage key and then push the values.
        let storage_key_vec: StorageKey&lt;StorageVec&lt;u8&gt;&gt; = storage.nested_map_vec.get(10);
        storage_key_vec.push(4u8);
        storage_key_vec.push(5u8);
        storage_key_vec.push(6u8);
</code></pre>
<p>The following demonstrates how to read from a <code>StorageVec&lt;T&gt;</code> that is nested in a <code>StorageMap&lt;T, V&gt;</code>:</p>
<pre><code class="language-sway">        // Method 1: Access the StorageVec directly.
        let stored_val1: u8 = storage.nested_map_vec.get(10).pop().unwrap();
        let stored_val2: u8 = storage.nested_map_vec.get(10).pop().unwrap();
        let stored_val3: u8 = storage.nested_map_vec.get(10).pop().unwrap();

        // Method 2: First get the storage key and then access the value.
        let storage_key: StorageKey&lt;StorageVec&lt;u8&gt;&gt; = storage.nested_map_vec.get(10);
        let stored_val4: u8 = storage_key.pop().unwrap();
        let stored_val5: u8 = storage_key.pop().unwrap();
        let stored_val6: u8 = storage_key.pop().unwrap();
</code></pre>
<h3 id="storing-a-storagestring-in-a-storagemapk-v"><a class="header" href="#storing-a-storagestring-in-a-storagemapk-v">Storing a <code>StorageString</code> in a <code>StorageMap&lt;K, V&gt;</code></a></h3>
<p>The following demonstrates how to write to a <code>StorageString</code> that is nested in a <code>StorageMap&lt;T, V&gt;</code>:</p>
<pre><code class="language-sway">        // Setup and initialize storage for the StorageString.
        storage.nested_map_string.try_insert(10, StorageString {});

        // Method 1: Store the string directly.
        let my_string = String::from_ascii_str(&quot;Fuel is blazingly fast&quot;);
        storage.nested_map_string.get(10).write_slice(my_string);

        // Method 2: First get the storage key and then write the value.
        let my_string = String::from_ascii_str(&quot;Fuel is modular&quot;);
        let storage_key: StorageKey&lt;StorageString&gt; = storage.nested_map_string.get(10);
        storage_key.write_slice(my_string);
</code></pre>
<p>The following demonstrates how to read from a <code>StorageString</code> that is nested in a <code>StorageMap&lt;T, V&gt;</code>:</p>
<pre><code class="language-sway">        // Method 1: Access the string directly.
        let stored_string: String = storage.nested_map_string.get(10).read_slice().unwrap();

        // Method 2: First get the storage key and then access the value.
        let storage_key: StorageKey&lt;StorageString&gt; = storage.nested_map_string.get(10);
        let stored_string: String = storage_key.read_slice().unwrap();
</code></pre>
<h3 id="storing-a-storagebytes-in-a-storagevect"><a class="header" href="#storing-a-storagebytes-in-a-storagevect">Storing a <code>StorageBytes</code> in a <code>StorageVec&lt;T&gt;</code></a></h3>
<p>The following demonstrates how to write to a <code>StorageBytes</code> that is nested in a <code>StorageVec&lt;T&gt;</code>:</p>
<pre><code class="language-sway">        // Setup and initialize storage for the StorageVec.
        storage.nested_map_vec.try_insert(10, StorageVec {});

        // Method 1: Push to the vec directly
        storage.nested_map_vec.get(10).push(1u8);
        storage.nested_map_vec.get(10).push(2u8);
        storage.nested_map_vec.get(10).push(3u8);

        // Method 2: First get the storage key and then push the values.
        let storage_key_vec: StorageKey&lt;StorageVec&lt;u8&gt;&gt; = storage.nested_map_vec.get(10);
        storage_key_vec.push(4u8);
        storage_key_vec.push(5u8);
        storage_key_vec.push(6u8);
</code></pre>
<p>The following demonstrates how to read from a <code>StorageBytes</code> that is nested in a <code>StorageVec&lt;T&gt;</code>:</p>
<pre><code class="language-sway">        // Method 1: Access the StorageVec directly.
        let stored_val1: u8 = storage.nested_map_vec.get(10).pop().unwrap();
        let stored_val2: u8 = storage.nested_map_vec.get(10).pop().unwrap();
        let stored_val3: u8 = storage.nested_map_vec.get(10).pop().unwrap();

        // Method 2: First get the storage key and then access the value.
        let storage_key: StorageKey&lt;StorageVec&lt;u8&gt;&gt; = storage.nested_map_vec.get(10);
        let stored_val4: u8 = storage_key.pop().unwrap();
        let stored_val5: u8 = storage_key.pop().unwrap();
        let stored_val6: u8 = storage_key.pop().unwrap();
</code></pre>
<h2 id="storage-namespace"><a class="header" href="#storage-namespace">Storage Namespace</a></h2>
<p>If you want the values in storage to be positioned differently, for instance to avoid collisions with storage from another contract when loading code, you can use the namespace annotation to add a salt to the slot calculations.</p>
<pre><code class="language-sway">storage {
    example_namespace {
        foo: u64 = 0,
    },
</code></pre>
<h2 id="manual-storage-management"><a class="header" href="#manual-storage-management">Manual Storage Management</a></h2>
<p>It is possible to leverage FuelVM storage operations directly using the <code>std::storage::storage_api::write</code> and <code>std::storage::storage_api::read</code> functions provided in the standard library. With this approach, you will have to manually assign the internal key used for storage. An example is as follows:</p>
<pre><code class="language-sway">contract;

use std::storage::storage_api::{read, write};

abi StorageExample {
    #[storage(write)]
    fn store_something(amount: u64);

    #[storage(read)]
    fn get_something() -&gt; u64;
}

const STORAGE_KEY: b256 = 0x0000000000000000000000000000000000000000000000000000000000000000;

impl StorageExample for Contract {
    #[storage(write)]
    fn store_something(amount: u64) {
        write(STORAGE_KEY, 0, amount);
    }

    #[storage(read)]
    fn get_something() -&gt; u64 {
        let value: Option&lt;u64&gt; = read::&lt;u64&gt;(STORAGE_KEY, 0);
        value.unwrap_or(0)
    }
}
</code></pre>
<blockquote>
<p><strong>Note</strong>: Though these functions can be used for any data type, they should mostly be used for arrays because arrays are not yet supported in <code>storage</code> blocks. Note, however, that <em>all</em> data types can be used as types for keys and/or values in <code>StorageMap&lt;K, V&gt;</code> without any restrictions.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="generic-types"><a class="header" href="#generic-types">Generic Types</a></h1>
<h2 id="basics"><a class="header" href="#basics">Basics</a></h2>
<p>In Sway, generic types follow a very similar pattern to those in Rust. Let's look at some example syntax,
starting with a generic function:</p>
<pre><code class="language-sway">fn noop&lt;T&gt;(argument: T) -&gt; T {
    argument
}
</code></pre>
<p>Here, the <code>noop()</code> function trivially returns exactly what was given to it. <code>T</code> is a <em>type parameter</em>, and it says
that this function exists for all types T. More formally, this function could be typed as:</p>
<pre><code class="language-math">noop :: âˆ€T. T -&gt; T
</code></pre>
<p>Generic types are a way to refer to types <em>in general</em>, meaning without specifying a single type. Our <code>noop</code> function
would work with any type in the language, so we don't need to specify <code>noop(argument: u8) -&gt; u8</code>, <code>noop(argument: u16) -&gt; u16</code>, etc.</p>
<h2 id="code-generation"><a class="header" href="#code-generation">Code Generation</a></h2>
<p>One question that arises when dealing with generic types is: how does the assembly handle this? There are a few approaches to handling
generic types at the lowest level. Sway uses a technique called <a href="https://en.wikipedia.org/wiki/Monomorphization">monomorphization</a>. This
means that the generic function is compiled to a non-generic version for every type it is called on. In this way, generic functions are
purely shorthand for the sake of ergonomics.</p>
<h2 id="trait-constraints"><a class="header" href="#trait-constraints">Trait Constraints</a></h2>
<p>An important background to know before diving into trait constraints is that the <code>where</code> clause can be used to specify the required traits for the generic argument. So, when writing something like a <code>HashMap</code> you may
want to specify that the generic argument implements a <code>Hash</code> trait.</p>
<pre><code class="language-sway">fn get_hashmap_key&lt;T&gt;(key: T) -&gt; b256
    where T: Hash
{
    // Code within here can then call methods associated with the Hash trait on Key
}
</code></pre>
<p>Of course, our <code>noop()</code> function is not useful. Often, a programmer will want to declare functions over types which satisfy certain traits.
For example, let's try to implement the successor function, <code>successor()</code>, for all numeric types.</p>
<pre><code class="language-sway">fn successor&lt;T&gt;(argument: T)
    where T: Add
{
    argument + 1
}
</code></pre>
<p>Run <code>forc build</code>, and you will get:</p>
<pre><code class="language-console">.. |
 9 |   where T: Add
10 |   {
11 |       argument + 1                                        
   |                  ^ Mismatched types: expected type &quot;T&quot; but saw type &quot;u64&quot;
12 |   }
13 |
</code></pre>
<p>This is because we don't know for a fact that <code>1</code>, which in this case defaulted to <code>1u64</code>, actually can be added to <code>T</code>. What if <code>T</code> is <code>f64</code>? Or <code>b256</code>? What does it mean to add <code>1u64</code> in these cases?</p>
<p>We can solve this problem with another trait constraint. We can only find the successor of some value of type <code>T</code> if that type <code>T</code> defines some incrementor. Let's make a trait:</p>
<pre><code class="language-sway">trait Incrementable {
    /// Returns the value to add when calculating the successor of a value.
    fn incrementor() -&gt; Self;
}
</code></pre>
<p>Now, we can modify our <code>successor()</code> function:</p>
<pre><code class="language-sway">fn successor&lt;T&gt;(argument: T)
    where T: Add,
          T: Incrementable
{
    argument + T::incrementor()
}
</code></pre>
<h2 id="generic-structs-and-enums"><a class="header" href="#generic-structs-and-enums">Generic Structs and Enums</a></h2>
<p>Just like functions, structs and enums can be generic. Let's take a look at the standard library version of <code>Option&lt;T&gt;</code>:</p>
<pre><code class="language-sway">enum Option&lt;T&gt; {
    Some: T,
    None: (),
}
</code></pre>
<p>Just like an unconstrained generic function, this type exists for all (âˆ€) types <code>T</code>. <code>Result&lt;T, E&gt;</code> is another example:</p>
<pre><code class="language-sway">enum Result&lt;T, E&gt; {
    Ok: T,
    Err: E,
}
</code></pre>
<p>Both generic enums and generic structs can be trait constrained, as well. Consider this struct:</p>
<pre><code class="language-sway">struct Foo&lt;T&gt;
    where T: Add
{
    field_one: T,
}
</code></pre>
<h2 id="type-arguments"><a class="header" href="#type-arguments">Type Arguments</a></h2>
<p>Similar to Rust, Sway has what is colloquially known as the <a href="https://github.com/rust-lang/rust/blob/e98309298d927307c5184f4869604bd068d26183/src/test/ui/parser/bastion-of-the-turbofish.rs">turbofish</a>. The turbofish looks like this: <code>::&lt;&gt;</code> (see the little fish with bubbles behind it?). The turbofish is used to annotate types in a generic context. Say you have the following function:</p>
<pre><code class="language-sway">fn foo&lt;T, E&gt;(t: T) -&gt; Result&lt;T, E&gt; {
    Ok(t)
}
</code></pre>
<p>In this code example, which is admittedly asinine, you can't possibly know what type <code>E</code> is. You'd need to provide the type manually, with a turbofish:</p>
<pre><code class="language-sway">fn foo&lt;T, E&gt;(t: T) -&gt; Result&lt;T, E&gt; {
    Ok::&lt;T, MyErrorType&gt;(t)
}
</code></pre>
<p>It is also common to see the turbofish used on the function itself:</p>
<pre><code class="language-sway">fn main() {
    foo::&lt;Bar, Baz&gt;()
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="traits"><a class="header" href="#traits">Traits</a></h1>
<h2 id="declaring-a-trait"><a class="header" href="#declaring-a-trait">Declaring a Trait</a></h2>
<p>A <em>trait</em> opts a type into a certain type of behavior or functionality that can be shared among types. This allows for easy reuse of code and generic programming. If you have ever used a typeclass in Haskell, a trait in Rust, or even an interface in Java, these are similar concepts.</p>
<p>Let's take a look at some code:</p>
<pre><code class="language-sway">trait Compare {
    fn equals(self, b: Self) -&gt; bool;
} {
    fn not_equals(self, b: Self) -&gt; bool {
        !self.equals(b)
    }
}
</code></pre>
<p>We have just declared a trait called <code>Compare</code>. After the name of the trait, there are two <em>blocks</em> of code (a <em>block</em> is code enclosed in <code>{</code> curly brackets <code>}</code>). The first block is the <em>interface surface</em>. The second block is the <em>methods</em> provided by the trait. If a type can provide the methods in the interface surface, then it gets access to the methods in the trait for free! What the above trait is saying is: if you can determine if two values are equal, then for free, you can determine that they are not equal. Note that trait methods have access to the methods defined in the interface surface.</p>
<h2 id="implementing-a-trait"><a class="header" href="#implementing-a-trait">Implementing a Trait</a></h2>
<p>The example below implements a <code>Compare</code> trait for <code>u64</code> to check if two numbers are equal. Let's take a look at how that is done:</p>
<pre><code class="language-sway">impl Compare for u64 {
    fn equals(self, b: Self) -&gt; bool {
        self == b
    }
}
</code></pre>
<p>The above snippet declares all of the methods in the trait <code>Compare</code> for the type <code>u64</code>. Now, we have access to both the <code>equals</code> and <code>not_equals</code> methods for <code>u64</code>, as long as the trait <code>Compare</code> is in scope.</p>
<h2 id="supertraits"><a class="header" href="#supertraits">Supertraits</a></h2>
<p>When using multiple traits, scenarios often come up where one trait may require functionality from another trait. This is where supertraits come in as they allow you to require a trait when implementing another trait, i.e., a trait with a trait.
A good example of this is the <code>Ord</code> trait of the <code>core</code> library of Sway. The <code>Ord</code> trait requires the <code>Eq</code> trait, so <code>Eq</code> is kept as a separate trait as one may decide to implement <code>Eq</code>
without implementing other parts of the <code>Ord</code> trait.</p>
<pre><code class="language-sway">
trait Eq {
    fn equals(self, b: Self) -&gt; bool;
}

trait Ord: Eq {
    fn gte(self, b: Self) -&gt; bool;
}

impl Ord for u64 {
    fn gte(self, b: Self) -&gt; bool {
        // As `Eq` is a supertrait of `Ord`, `Ord` can access the equals method
        self.equals(b) || self.gt(b)
    }
}
</code></pre>
<p>To require a supertrait, add a <code>:</code> after the trait name and then list the traits you would like to require and separate them with a <code>+</code>.</p>
<h3 id="abi-supertraits"><a class="header" href="#abi-supertraits">ABI supertraits</a></h3>
<p>ABIs can also have supertrait annotations:</p>
<pre><code class="language-sway">contract;

struct Foo {}
impl ABIsupertrait for Foo {
    fn foo() {}
}

trait ABIsupertrait {
    fn foo();
}

abi MyAbi : ABIsupertrait {
    fn bar();
} {
    fn baz() {
        Self::foo() // supertrait method usage
    }
}

impl ABIsupertrait for Contract {
    fn foo() {}
}

// The implementation of MyAbi for Contract must also implement ABIsupertrait
impl MyAbi for Contract {
    fn bar() {
        Self::foo() // supertrait method usage
    }
}
</code></pre>
<p>The implementation of <code>MyAbi</code> for <code>Contract</code> must also implement the <code>ABIsupertrait</code> trait. Methods in <code>ABIsupertrait</code> are not available externally, i.e. they're not actually contract methods, but they can be used in the actual contract methods, as shown in the example above.</p>
<p>ABI supertraits are intended to make contract implementations compositional, allowing combining orthogonal contract features using, for instance, libraries.</p>
<h3 id="superabis"><a class="header" href="#superabis">SuperABIs</a></h3>
<p>In addition to supertraits, ABIs can have <em>superABI</em> annotations:</p>
<pre><code class="language-sway">contract;

abi MySuperAbi {
    fn foo();
}

abi MyAbi : MySuperAbi {
    fn bar();
}

impl MySuperAbi for Contract {
    fn foo() {}
}

// The implementation of MyAbi for Contract must also implement MySuperAbi
impl MyAbi for Contract {
    fn bar() {}
}
</code></pre>
<p>The implementation of <code>MyAbi</code> for <code>Contract</code> must also implement the <code>MySuperAbi</code> superABI. Methods in <code>MySuperAbi</code> will be part of the <code>MyAbi</code> contract interface, i.e. will be available externally (and hence cannot be called from other <code>MyAbi</code> contract methods).</p>
<p>SuperABIs are intended to make contract implementations compositional, allowing combining orthogonal contract features using, for instance, libraries.</p>
<h2 id="associated-items"><a class="header" href="#associated-items">Associated Items</a></h2>
<p>Traits can declare different kinds of associated items in their interface surface:</p>
<ul>
<li><a href="advanced/traits.html#associated-functions">Functions</a></li>
<li><a href="advanced/traits.html#associated-constants">Constants</a></li>
<li><a href="advanced/traits.html#associated-types">Types</a></li>
</ul>
<h3 id="associated-functions-1"><a class="header" href="#associated-functions-1">Associated functions</a></h3>
<p>Associated functions in traits consist of just function signatures. This indicates that each implementation of the trait for a given type must define all the trait functions.</p>
<pre><code class="language-sway">trait Trait {
    fn associated_fn(self, b: Self) -&gt; bool;
}
</code></pre>
<h3 id="associated-constants-1"><a class="header" href="#associated-constants-1">Associated constants</a></h3>
<p>Associated constants are constants associated with a type.</p>
<pre><code class="language-sway">trait Trait {
    const ID: u32 = 0;
}
</code></pre>
<p>The initializer expression of an <a href="advanced/../basics/constants.html#associated-constants">associated constants</a> in a trait definition may be omitted to indicate that each implementation of the <code>trait</code> for a given type must specify an initializer:</p>
<pre><code class="language-sway">trait Trait {
    const ID: u32;
}
</code></pre>
<p>Check the <code>associated consts</code> section on <a href="advanced/../basics/constants.html">constants</a> page.</p>
<h3 id="associated-types"><a class="header" href="#associated-types">Associated types</a></h3>
<p>Associated types in Sway allow you to define placeholder types within a trait, which can be customized by concrete
implementations of that trait. These associated types are used to specify the return types of trait methods or to
define type relationships within the trait.</p>
<pre><code class="language-sway">trait MyTrait {
    type AssociatedType;
}
</code></pre>
<p>Check the <code>associated types</code> section on <a href="advanced/./associated_types.html">associated types</a> page.</p>
<h2 id="use-cases"><a class="header" href="#use-cases">Use Cases</a></h2>
<h3 id="custom-types-structs-enums"><a class="header" href="#custom-types-structs-enums">Custom Types (structs, enums)</a></h3>
<p>Often, libraries and APIs have interfaces that are abstracted over a type that implements a certain trait. It is up to the consumer of the interface to implement that trait for the type they wish to use with the interface. For example, let's take a look at a trait and an interface built off of it.</p>
<pre><code class="language-sway">library;

pub enum Suit {
    Hearts: (),
    Diamonds: (),
    Clubs: (),
    Spades: (),
}

pub trait Card {
    fn suit(self) -&gt; Suit;
    fn value(self) -&gt; u8;
}

fn play_game_with_deck&lt;T&gt;(a: Vec&lt;T&gt;) where T: Card {
    // insert some creative card game here
}
</code></pre>
<blockquote>
<p><strong>Note</strong> Trait constraints (i.e. using the <code>where</code> keyword) <a href="https://github.com/FuelLabs/sway/issues/970">have not yet been implemented</a></p>
</blockquote>
<p>Now, if you want to use the function <code>play_game_with_deck</code> with your struct, you must implement <code>Card</code> for your struct. Note that the following code example assumes a dependency <em>games</em> has been included in the <code>Forc.toml</code> file.</p>
<pre><code class="language-sway">script;

use games::*;

struct MyCard {
    suit: Suit,
    value: u8
}

impl Card for MyCard {
    fn suit(self) -&gt; Suit {
        self.suit
    }
    fn value(self) -&gt; u8 {
        self.value
    }
}

fn main() {
    let mut i = 52;
    let mut deck: Vec&lt;MyCard&gt; = Vec::with_capacity(50);
    while i &gt; 0 {
        i = i - 1;
        deck.push(MyCard { suit: generate_random_suit(), value: i % 4}
    }
    play_game_with_deck(deck);
}

fn generate_random_suit() -&gt; Suit {
  [ ... ]
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="associated-types-1"><a class="header" href="#associated-types-1">Associated Types</a></h1>
<p>Associated types in Sway allow you to define placeholder types within a trait, which can be customized by concrete
implementations of that trait. These associated types are used to specify the return types of trait methods or to
define type relationships within the trait.</p>
<p>Associated types are a powerful feature of Sway's trait system, enabling generic programming and abstraction over
types. They help improve code clarity and maintainability by allowing you to define generic traits without committing
to specific types.</p>
<h2 id="declaring-associated-types"><a class="header" href="#declaring-associated-types">Declaring Associated Types</a></h2>
<p>Associated types are declared within a trait using the type keyword. Here's the syntax for declaring an associated type:</p>
<pre><code class="language-sway">trait MyTrait {
    type AssociatedType;
}
</code></pre>
<h2 id="implementing-associated-types"><a class="header" href="#implementing-associated-types">Implementing Associated Types</a></h2>
<p>Concrete implementations of a trait with associated types must provide a specific type for each associated type
defined in the trait. Here's an example of implementing a trait with an associated type:</p>
<pre><code class="language-sway">struct MyStruct;

impl MyTrait for MyStruct {
    type AssociatedType = u32; // Implementing the associated type with u32
}
</code></pre>
<p>In this example, <code>MyStruct</code> implements <code>MyTrait</code> and specifies that the associated type <code>AssociatedType</code> is <code>u32</code>.</p>
<h2 id="using-associated-types"><a class="header" href="#using-associated-types">Using Associated Types</a></h2>
<p>Associated types are used within trait methods or where the trait is used as a bound for generic functions or
structs. You can use the associated type like any other type. Here's an example:</p>
<pre><code class="language-sway">trait MyTrait {
    type AssociatedType;
    
    fn get_value(self) -&gt; Self::AssociatedType;
}

struct MyStruct;

impl MyTrait for MyStruct {
    type AssociatedType = u32;

    fn get_value(self) -&gt; Self::AssociatedType {
        42
    }
}
</code></pre>
<p>In this example, <code>get_value</code> is a trait method that returns an associated type <code>AssociatedType</code>.</p>
<h2 id="use-cases-1"><a class="header" href="#use-cases-1">Use Cases</a></h2>
<p>Associated types are particularly useful in scenarios where you want to define traits that work with different
types of data structures or abstractions, allowing the implementer to specify the concrete types. Some common use cases include:</p>
<ul>
<li>Collections: Traits for generic collections that allow users to specify the type of elements.</li>
<li>Iterator Patterns: Traits for implementing iterators with varying element types.</li>
<li>Serialization and Deserialization: Traits for serializing and deserializing data with different data formats.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="generics-and-trait-constraints"><a class="header" href="#generics-and-trait-constraints">Generics and Trait Constraints</a></h1>
<h2 id="generics-as-constraints"><a class="header" href="#generics-as-constraints">Generics as Constraints</a></h2>
<p>At a high level, Sway allows you to define constraints, or restrictions, that
allow you to strike a balance between writing abstract and reusable code and
enforcing compile-time checks to determine if the abstract code that you've
written is correct.</p>
<p>The &quot;abstract and reusable&quot; part largely comes from <a href="advanced/./generic_types.html">generic types</a> and the
&quot;enforcing compile-time checks&quot; part largely comes from trait constraints.
Generic types can be used with functions, structs, and enums (as we have seen in
this book), but they can also be used with traits.</p>
<h2 id="generic-traits"><a class="header" href="#generic-traits">Generic Traits</a></h2>
<p>Combining generic types with traits allows you to write abstract and reusable
traits that can be implemented for any number of data types.</p>
<p>For example, imagine that you want to write a trait for converting between
different types. This would be similar to Rust's <code>Into</code> and <code>From</code> traits. In
Sway your conversion trait would look something like:</p>
<pre><code class="language-sway">trait Convert&lt;T&gt; {
    fn from(t: T) -&gt; Self;
}
</code></pre>
<p>The trait <code>Convert</code> takes a generic type <code>T</code>. <code>Convert</code> has one method
<code>from</code>, which takes one parameter of type <code>T</code> and returns a <code>Self</code>. This means
that when you implement <code>Convert</code> for a data type, <code>from</code> will return the type
of that data type but will take as input the type that you define as <code>T</code>. Here
is an example:</p>
<pre><code class="language-sway">struct Square {
    width: u64,
}

struct Rectangle {
    width: u64,
    length: u64,
}

impl Convert&lt;Square&gt; for Rectangle {
    fn from(t: Square) -&gt; Self {
        Self {
            width: t.width,
            length: t.width,
        }
    }
}
</code></pre>
<p>In this example, you have two different data types, <code>Square</code> and <code>Rectangle</code>.
You know that all squares are rectangles and thus <code>Square</code> can convert into <code>Rectangle</code> (but not vice
versa) and thus you can implement the conversion trait for those types.</p>
<p>If we want to call these methods we can do so by:</p>
<pre><code class="language-sway">fn main() {
    let s = Square { width: 5 };
    let r = Rectangle::from(s);
}
</code></pre>
<h2 id="trait-constraints-1"><a class="header" href="#trait-constraints-1">Trait Constraints</a></h2>
<p>Trait constraints allow you to use generic types and traits to place constraints
on what abstract code you are willing to accept in your program as correct.
These constraints take the form of compile-time checks for correctness.</p>
<p>If we wanted to use trait constraints with our <code>Convert</code> trait from the previous
section we could do so like so:</p>
<pre><code class="language-sway">fn into_rectangle&lt;T&gt;(t: T) -&gt; Rectangle
where
    Rectangle: Convert&lt;T&gt;,
{
    Rectangle::from(t)
}
</code></pre>
<p>This function allows you to take any generic data type <code>T</code> and convert it to the
type <code>Rectangle</code> <em>as long as <code>Convert&lt;T&gt;</code> is implemented for <code>Rectangle</code></em>.
Calling this function with a type <code>T</code> for which <code>Convert&lt;T&gt;</code> is not implemented
for <code>Rectangle</code> will fail Sway's compile-time checks.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="inline-assembly-in-sway"><a class="header" href="#inline-assembly-in-sway">Inline Assembly in Sway</a></h1>
<p>While many users will never have to touch assembly language while writing sway code, it is a powerful tool that enables many advanced use-cases (e.g., optimizations, building libraries, etc).</p>
<h2 id="asm-block"><a class="header" href="#asm-block">ASM Block</a></h2>
<p>In Sway, the way we use assembly inline is to declare an <code>asm</code> block like this:</p>
<pre><code class="language-sway">asm() {...}
</code></pre>
<p>Declaring an <code>asm</code> block is similar to declaring a function.
We can specify register names to operate on as arguments, we can perform operations within the block, and we can return a value.
Here's an example showing what this might look like:</p>
<pre><code class="language-sway">pub fn add_1(num: u32) -&gt; u32 {
    asm(r1: num, r2) {
        add r2 r1 one;
        r2: u32
    }
}
</code></pre>
<p>An <code>asm</code> block can only return a single register. If you really need to return more than one value, you can modify a tuple. Here's an example showing how you can implement this <code>(u64, u64)</code>:</p>
<pre><code class="language-sway">script;

fn adder(a: u64, b: u64, c: u64) -&gt; (u64, u64) {
    let empty_tuple = (0u64, 0u64);
    asm(output: empty_tuple, r1: a, r2: b, r3: c, r4, r5) {
        add r4 r1 r2; // add a &amp; b and put the result in r4
        add r5 r2 r3; // add b &amp; c and put the result in r5
        sw output r4 i0; // store the word in r4 in output + 0 words
        sw output r5 i1; // store the word in r5 in output + 1 word
        output: (u64, u64) // return both values
    }
}

fn main() -&gt; bool {
    let (first, second) = adder(1, 2, 3);
    assert(first == 3);
    assert(second == 5);
    true
}
</code></pre>
<p>Note that this is contrived example meant to demonstrate the syntax; there's absolutely no need to use assembly to add integers!</p>
<p>Note that in the above example:</p>
<ul>
<li>we initialized the register <code>r1</code> with the value of <code>num</code>.</li>
<li>we declared a second register <code>r2</code> (you may choose any register names you want).</li>
<li>we use the <code>add</code> opcode to add <code>one</code> to the value of <code>r1</code> and store it in <code>r2</code>.</li>
<li><code>one</code> is an example of a &quot;reserved register&quot;, of which there are 16 in total. Further reading on this is linked below under &quot;Semantics&quot;.</li>
<li>we return <code>r2</code> &amp; specify the return type as being u32 (the return type is u64 by default).</li>
</ul>
<p>An important note is that the <code>ji</code> and <code>jnei</code> opcodes are not available within an <code>asm</code> block. For those looking to introduce control flow to <code>asm</code> blocks, it is recommended to surround smaller chunks of <code>asm</code> with control flow (<code>if</code>, <code>else</code>, and <code>while</code>).</p>
<h2 id="helpful-links"><a class="header" href="#helpful-links">Helpful Links</a></h2>
<p>For examples of assembly in action, check out the <a href="https://github.com/FuelLabs/sway/tree/master/sway-lib-std">Sway standard library</a>.</p>
<p>For a complete list of all instructions supported in the FuelVM: <a href="https://fuellabs.github.io/fuel-specs/master/vm/instruction_set">Instructions</a>.</p>
<p>And to learn more about the FuelVM semantics: <a href="https://fuellabs.github.io/fuel-specs/master/vm#semantics">Semantics</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="never-type"><a class="header" href="#never-type">Never Type</a></h1>
<p>The Never type <code>!</code> represents the type of computations which never resolve to any value at all.</p>
<h2 id="additional-information"><a class="header" href="#additional-information">Additional Information</a></h2>
<p><code>break</code>, <code>continue</code> and <code>return</code> expressions also have type <code>!</code>. For example we are allowed to
write:</p>
<pre><code class="language-sway">let x: ! = {
    return 123
};
</code></pre>
<p>Although the <code>let</code> is pointless here, it illustrates the meaning of <code>!</code>. Since <code>x</code> is never
assigned a value (because <code>return</code> returns from the entire function), <code>x</code> can be given type
<code>Never</code>. We could also replace <code>return 123</code> with a <code>revert()</code> or a never-ending <code>loop</code> and this code
would still be valid.</p>
<p>A more realistic usage of <code>Never</code> is in this code:</p>
<pre><code class="language-sway">let num: u32 = match get_a_number() {
    Some(num) =&gt; num,
    None =&gt; break,
};
</code></pre>
<p>Both match arms must produce values of type [<code>u32</code>], but since <code>break</code> never produces a value
at all we know it can never produce a value which isn't a [<code>u32</code>]. This illustrates another
behaviour of the <code>!</code> type - expressions with type <code>!</code> will coerce into any other type.</p>
<p>Note that <code>!</code> type coerces into any other type, another example of this would be:</p>
<pre><code class="language-sway">let x: u32 = {
    return 123
};
</code></pre>
<p>Regardless of the type of <code>x</code>, the return block of type <code>Never</code> will always coerce into <code>x</code> type.</p>
<h2 id="examples"><a class="header" href="#examples">Examples</a></h2>
<pre><code class="language-sway">fn foo() {
    let num: u64 = match Option::None::&lt;u64&gt; {
        Some(num) =&gt; num,
        None =&gt; return,
    };
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="common-collections"><a class="header" href="#common-collections">Common Collections</a></h1>
<p>Swayâ€™s standard library includes a number of very useful data structures called collections. Most other data types represent one specific value, but collections can contain multiple values. Unlike the built-in array and tuple types which are allocated on the &quot;stack&quot; and cannot grow in size, the data these collections point to is stored either on the &quot;heap&quot; or in contract &quot;storage&quot;, which means the amount of data does not need to be known at compile time and can grow as the program runs. Each kind of collection has different capabilities and costs, and choosing an appropriate one for your current situation is a skill youâ€™ll develop over time. In this chapter, weâ€™ll discuss three collections that are used very often in Sway programs:</p>
<p>A vector on the heap allows you to store a variable number of values next to each other.</p>
<p>A <code>StorageVec</code> is similar to a vector on the heap but uses persistent storage.</p>
<p>A <code>StorageMap</code> allows you to associate a value with a particular key.</p>
<p>Weâ€™ll discuss how to create and update a vector, <code>StorageVec</code>, and <code>StorageMap</code>, as well as what makes each special.</p>
<ul>
<li><a href="common-collections/./vec.html">Vectors on the Heap</a></li>
<li><a href="common-collections/./storage_vec.html"><code>StorageVec</code></a></li>
<li><a href="common-collections/./storage_map.html"><code>StorageMap</code></a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="vectors-on-the-heap"><a class="header" href="#vectors-on-the-heap">Vectors on the Heap</a></h1>
<p>The first collection type weâ€™ll look at is <code>Vec&lt;T&gt;</code>, also known as a vector. Vectors allow you to store more than one value in a single data structure that puts all the values next to each other in memory. Vectors can only store values of the same type. They are useful when you have a list of items, such as the lines of text in a file or the prices of items in a shopping cart.</p>
<p><code>Vec&lt;T&gt;</code> is included in the <a href="common-collections/../introduction/standard_library.html#standard-library-prelude">standard library prelude</a> which means that there is no need to import it manually.</p>
<h2 id="creating-a-new-vector"><a class="header" href="#creating-a-new-vector">Creating a New Vector</a></h2>
<p>To create a new empty vector, we call the <code>Vec::new</code> function, as shown below:</p>
<pre><code class="language-sway">    let v: Vec&lt;u64&gt; = Vec::new();
</code></pre>
<p>Note that we added a type annotation here. Because we arenâ€™t inserting any values into this vector, the Sway compiler doesnâ€™t know what kind of elements we intend to store. Vectors are implemented using generics which means that the <code>Vec&lt;T&gt;</code> type provided by the standard library can hold any type. When we create a vector to hold a specific type, we can specify the type within angle brackets. In the example above, weâ€™ve told the Sway compiler that the <code>Vec&lt;T&gt;</code> in <code>v</code> will hold elements of the <code>u64</code> type.</p>
<h2 id="updating-a-vector"><a class="header" href="#updating-a-vector">Updating a Vector</a></h2>
<p>To create a vector and then add elements to it, we can use the <code>push</code> method, as shown below:</p>
<pre><code class="language-sway">    let mut v = Vec::new();

    v.push(5);
    v.push(6);
    v.push(7);
    v.push(8);
</code></pre>
<p>As with any variable, if we want to be able to change its value, we need to make it mutable using the <code>mut</code> keyword, as discussed in the section <a href="common-collections/../basics/variables.html#declaring-a-variable">Declaring a Variable</a>. The numbers we place inside are all of type <code>u64</code>, and the Sway compiler infers this from the data, so we donâ€™t need the <code>Vec&lt;u64&gt;</code> annotation.</p>
<h2 id="reading-elements-of-vectors"><a class="header" href="#reading-elements-of-vectors">Reading Elements of Vectors</a></h2>
<p>To read a value stored in a vector at a particular index, you can use the <code>get</code> method as shown below:</p>
<pre><code class="language-sway">    let third = v.get(2);
    match third {
        Some(third) =&gt; log(third),
        None =&gt; revert(42),
    }
</code></pre>
<p>Note two details here. First, we use the index value of <code>2</code> to get the third element because vectors are indexed by number, starting at zero. Second, we get the third element by using the <code>get</code> method with the index passed as an argument, which gives us an <code>Option&lt;T&gt;</code>.</p>
<p>When the <code>get</code> method is passed an index that is outside the vector, it returns <code>None</code> without panicking. This is particularly useful if accessing an element beyond the range of the vector may happen occasionally under normal circumstances. Your code will then have logic to handle having either <code>Some(element)</code> or <code>None</code>. For example, the index could be coming as a contract method argument. If the argument passed is too large, the method <code>get</code> will return a <code>None</code> value, and the contract method may then decide to revert when that happens or return a meaningful error that tells the user how many items are in the current vector and give them another chance to pass a valid value.</p>
<h2 id="iterating-over-the-values-in-a-vector"><a class="header" href="#iterating-over-the-values-in-a-vector">Iterating over the Values in a Vector</a></h2>
<p>To access each element in a vector in turn, we would iterate through all of the valid indices using a <code>while</code> loop and the <code>len</code> method as shown below:</p>
<pre><code class="language-sway">    let mut i = 0;
    while i &lt; v.len() {
        log(v.get(i).unwrap());
        i += 1;
    }
</code></pre>
<p>Note two details here. First, we use the method <code>len</code> which returns the length of the vector. Second, we call the method <code>unwrap</code> to extract the <code>Option</code> returned by <code>get</code>. We know that <code>unwrap</code> will not fail (i.e. will not cause a revert) because each index <code>i</code> passed to <code>get</code> is known to be smaller than the length of the vector.</p>
<h2 id="using-an-enum-to-store-multiple-types"><a class="header" href="#using-an-enum-to-store-multiple-types">Using an Enum to store Multiple Types</a></h2>
<p>Vectors can only store values that are the same type. This can be inconvenient; there are definitely use cases for needing to store a list of items of different types. Fortunately, the variants of an enum are defined under the same enum type, so when we need one type to represent elements of different types, we can define and use an enum!</p>
<p>For example, say we want to get values from a row in a table in which some of the columns in the row contain integers, some <code>b256</code> values, and some Booleans. We can define an enum whose variants will hold the different value types, and all the enum variants will be considered the same type: that of the enum. Then we can create a vector to hold that enum and so, ultimately, holds different types. Weâ€™ve demonstrated this below:</p>
<pre><code class="language-sway">    enum TableCell {
        Int: u64,
        B256: b256,
        Boolean: bool,
    }

    let mut row = Vec::new();
    row.push(TableCell::Int(3));
    row.push(TableCell::B256(0x0101010101010101010101010101010101010101010101010101010101010101));
    row.push(TableCell::Boolean(true));
</code></pre>
<p>Now that weâ€™ve discussed some of the most common ways to use vectors, be sure to review the API documentation for all the many useful methods defined on <code>Vec&lt;T&gt;</code> by the standard library. For now, these can be found in the <a href="https://github.com/FuelLabs/sway/blob/master/sway-lib-std/src/vec.sw">source code for <code>Vec&lt;T&gt;</code></a>. For example, in addition to <code>push</code>, a <code>pop</code> method removes and returns the last element, a <code>remove</code> method removes and returns the element at some chosen index within the vector, an <code>insert</code> method inserts an element at some chosen index within the vector, etc.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="storage-vectors"><a class="header" href="#storage-vectors">Storage Vectors</a></h1>
<p>The second collection type weâ€™ll look at is <code>StorageVec&lt;T&gt;</code>. Just like vectors on the heap (i.e. <code>Vec&lt;T&gt;</code>), storage vectors allow you to store more than one value in a single data structure where each value is assigned an index and can only store values of the same type. However, unlike <code>Vec&lt;T&gt;</code>, the elements of a <code>StorageVec</code> are stored in <em>persistent storage</em>, and consecutive elements are not necessarily stored in storage slots that have consecutive keys.</p>
<p>In order to use <code>StorageVec&lt;T&gt;</code>, you must first import <code>StorageVec</code> as follows:</p>
<pre><code class="language-sway">use std::storage::storage_vec::*;
</code></pre>
<p>Another major difference between <code>Vec&lt;T&gt;</code> and <code>StorageVec&lt;T&gt;</code> is that <code>StorageVec&lt;T&gt;</code> can only be used in a contract because only contracts are allowed to access persistent storage.</p>
<h2 id="creating-a-new-storagevec"><a class="header" href="#creating-a-new-storagevec">Creating a New <code>StorageVec</code></a></h2>
<p>To create a new empty <code>StorageVec</code>, we have to declare the vector in a <code>storage</code> block as follows:</p>
<pre><code class="language-sway">    v: StorageVec&lt;u64&gt; = StorageVec {},
</code></pre>
<p>Just like any other storage variable, two things are required when declaring a <code>StorageVec</code>: a type annotation and an initializer. The initializer is just an empty struct of type <code>StorageVec</code> because <code>StorageVec&lt;T&gt;</code> itself is an empty struct! Everything that is interesting about <code>StorageVec&lt;T&gt;</code> is implemented in its methods.</p>
<p>Storage vectors, just like <code>Vec&lt;T&gt;</code>, are implemented using generics which means that the <code>StorageVec&lt;T&gt;</code> type provided by the standard library can hold any type. When we create a <code>StorageVec</code> to hold a specific type, we can specify the type within angle brackets. In the example above, weâ€™ve told the Sway compiler that the <code>StorageVec&lt;T&gt;</code> in <code>v</code> will hold elements of the <code>u64</code> type.</p>
<h2 id="updating-a-storagevec"><a class="header" href="#updating-a-storagevec">Updating a <code>StorageVec</code></a></h2>
<p>To add elements to a <code>StorageVec</code>, we can use the <code>push</code> method, as shown below:</p>
<pre><code class="language-sway">    #[storage(read, write)]
    fn push_to_storage_vec() {
        storage.v.push(5);
        storage.v.push(6);
        storage.v.push(7);
        storage.v.push(8);
    }
</code></pre>
<p>Note two details here. First, in order to use <code>push</code>, we need to first access the vector using the <code>storage</code> keyword. Second, because <code>push</code> requires accessing storage, a <code>storage</code> annotation is required on the ABI function that calls <code>push</code>. While it may seem that <code>#[storage(write)]</code> should be enough here, the <code>read</code> annotation is also required because each call to <code>push</code> requires <em>reading</em> (and then updating) the length of the <code>StorageVec</code> which is also stored in persistent storage.</p>
<blockquote>
<p><strong>Note</strong>
The storage annotation is also required for any private function defined in the contract that tries to push into the vector.</p>
</blockquote>
<!-- markdownlint-disable-line MD028 -->
<blockquote>
<p><strong>Note</strong>
There is no need to add the <code>mut</code> keyword when declaring a <code>StorageVec&lt;T&gt;</code>. All storage variables are mutable by default.</p>
</blockquote>
<h2 id="reading-elements-of-storage-vectors"><a class="header" href="#reading-elements-of-storage-vectors">Reading Elements of Storage Vectors</a></h2>
<p>To read a value stored in a vector at a particular index, you can use the <code>get</code> method as shown below:</p>
<pre><code class="language-sway">    #[storage(read)]
    fn read_from_storage_vec() {
        let third = storage.v.get(2);
        match third {
            Some(third) =&gt; log(third.read()),
            None =&gt; revert(42),
        }
    }
</code></pre>
<p>Note three details here. First, we use the index value of <code>2</code> to get the third element because vectors are indexed by number, starting at zero. Second, we get the third element by using the <code>get</code> method with the index passed as an argument, which gives us an <code>Option&lt;StorageKey&lt;T&gt;&gt;</code>. Third, the ABI function calling <code>get</code> only requires the annotation <code>#[storage(read)]</code> as one might expect because <code>get</code> does not write to storage.</p>
<p>When the <code>get</code> method is passed an index that is outside the vector, it returns <code>None</code> without panicking. This is particularly useful if accessing an element beyond the range of the vector may happen occasionally under normal circumstances. Your code will then have logic to handle having either <code>Some(element)</code> or <code>None</code>. For example, the index could be coming as a contract method argument. If the argument passed is too large, the method <code>get</code> will return a <code>None</code> value, and the contract method may then decide to revert when that happens or return a meaningful error that tells the user how many items are in the current vector and give them another chance to pass a valid value.</p>
<h2 id="iterating-over-the-values-in-a-vector-1"><a class="header" href="#iterating-over-the-values-in-a-vector-1">Iterating over the Values in a Vector</a></h2>
<p>To access each element in a vector in turn, we would iterate through all of the valid indices using a <code>while</code> loop and the <code>len</code> method as shown below:</p>
<pre><code class="language-sway">    #[storage(read)]
    fn iterate_over_a_storage_vec() {
        let mut i = 0;
        while i &lt; storage.v.len() {
            log(storage.v.get(i).unwrap().read());
            i += 1;
        }
    }
</code></pre>
<p>Again, this is quite similar to iterating over the elements of a <code>Vec&lt;T&gt;</code> where we use the method <code>len</code> to return the length of the vector. We also call the method <code>unwrap</code> to extract the <code>Option</code> returned by <code>get</code> followed by a call to <code>read()</code> to actually read the stored value. We know that <code>unwrap</code> will not fail (i.e. will not cause a revert) because each index <code>i</code> passed to <code>get</code> is known to be smaller than the length of the vector.</p>
<h2 id="using-an-enum-to-store-multiple-types-1"><a class="header" href="#using-an-enum-to-store-multiple-types-1">Using an Enum to store Multiple Types</a></h2>
<p>Storage vectors, just like <code>Vec&lt;T&gt;</code>, can only store values that are the same type. Similarly to what we did for <code>Vec&lt;T&gt;</code> in the section <a href="common-collections/./vec.html#using-an-enum-to-store-multiple-types">Using an Enum to store Multiple Types</a>, we can define an enum whose variants will hold the different value types, and all the enum variants will be considered the same type: that of the enum. This is shown below:</p>
<pre><code class="language-sway">enum TableCell {
    Int: u64,
    B256: b256,
    Boolean: bool,
}
</code></pre>
<p>Then we can declare a <code>StorageVec</code> in a <code>storage</code> block to hold that enum and so, ultimately, holds different types:</p>
<pre><code class="language-sway">    row: StorageVec&lt;TableCell&gt; = StorageVec {},
</code></pre>
<p>We can now push different enum variants to the <code>StorageVec</code> as follows:</p>
<pre><code class="language-sway">    #[storage(read, write)]
    fn push_to_multiple_types_storage_vec() {
        storage.row.push(TableCell::Int(3));
        storage
            .row
            .push(TableCell::B256(0x0101010101010101010101010101010101010101010101010101010101010101));
        storage.row.push(TableCell::Boolean(true));
    }
</code></pre>
<p>Now that weâ€™ve discussed some of the most common ways to use storage vectors, be sure to review the API documentation for all the many useful methods defined on <code>StorageVec&lt;T&gt;</code> by the standard library. For now, these can be found in the <a href="https://github.com/FuelLabs/sway/blob/master/sway-lib-std/src/storage.sw">source code for <code>StorageVec&lt;T&gt;</code></a>. For example, in addition to <code>push</code>, a <code>pop</code> method removes and returns the last element, a <code>remove</code> method removes and returns the element at some chosen index within the vector, an <code>insert</code> method inserts an element at some chosen index within the vector, etc.</p>
<h2 id="nested-storage-vectors"><a class="header" href="#nested-storage-vectors">Nested Storage Vectors</a></h2>
<p>It is possible to nest storage vectors as follows:</p>
<pre><code class="language-sway">    nested_vec: StorageVec&lt;StorageVec&lt;u64&gt;&gt; = StorageVec {},
</code></pre>
<p>The nested vector can then be accessed as follows:</p>
<pre><code class="language-sway">    #[storage(read, write)]
    fn access_nested_vec() {
        storage.nested_vec.push(StorageVec {});
        storage.nested_vec.push(StorageVec {});

        let mut inner_vec0 = storage.nested_vec.get(0).unwrap();
        let mut inner_vec1 = storage.nested_vec.get(1).unwrap();

        inner_vec0.push(0);
        inner_vec0.push(1);

        inner_vec1.push(2);
        inner_vec1.push(3);
        inner_vec1.push(4);

        assert(inner_vec0.len() == 2);
        assert(inner_vec0.get(0).unwrap().read() == 0);
        assert(inner_vec0.get(1).unwrap().read() == 1);
        assert(inner_vec0.get(2).is_none());

        assert(inner_vec1.len() == 3);
        assert(inner_vec1.get(0).unwrap().read() == 2);
        assert(inner_vec1.get(1).unwrap().read() == 3);
        assert(inner_vec1.get(2).unwrap().read() == 4);
        assert(inner_vec1.get(3).is_none());
    }
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="storage-maps"><a class="header" href="#storage-maps">Storage Maps</a></h1>
<p>Another important common collection is the storage map.</p>
<!-- This section should explain storage maps in Sway -->
<!-- storage_map:example:start -->
<p>The type <code>StorageMap&lt;K, V&gt;</code> from the standard library stores a mapping of keys of type <code>K</code> to values of type <code>V</code> using a hashing function, which determines how it places these keys and values into <em>storage slots</em>. This is similar to <a href="https://doc.rust-lang.org/std/collections/struct.HashMap.html">Rust's <code>HashMap&lt;K, V&gt;</code></a> but with a few differences.</p>
<p>Storage maps are useful when you want to look up data not by using an index, as you can with vectors, but by using a key that can be of any type. For example, when building a ledger-based sub-currency smart contract, you could keep track of the balance of each wallet in a storage map in which each key is a walletâ€™s <code>Address</code> and the values are each walletâ€™s balance. Given an <code>Address</code>, you can retrieve its balance.</p>
<p>Similarly to <code>StorageVec&lt;T&gt;</code>, <code>StorageMap&lt;K, V&gt;</code> can only be used in a contract because only contracts are allowed to access persistent storage.</p>
<p><code>StorageMap&lt;T&gt;</code> is included in the <a href="common-collections/../introduction/standard_library.html#standard-library-prelude">standard library prelude</a> which means that there is no need to import it manually.</p>
<!-- storage_map:example:end -->
<h2 id="creating-a-new-storage-map"><a class="header" href="#creating-a-new-storage-map">Creating a New Storage Map</a></h2>
<p>To create a new empty storage map, we have to declare the map in a <code>storage</code> block as follows:</p>
<pre><code class="language-sway">    map: StorageMap&lt;Address, u64&gt; = StorageMap::&lt;Address, u64&gt; {},
</code></pre>
<!-- This section should explain how to implement storage maps in Sway -->
<!-- use_storage_maps:example:start -->
<p>Just like any other storage variable, two things are required when declaring a <code>StorageMap</code>: a type annotation and an initializer. The initializer is just an empty struct of type <code>StorageMap</code> because <code>StorageMap&lt;K, V&gt;</code> itself is an empty struct! Everything that is interesting about <code>StorageMap&lt;K, V&gt;</code> is implemented in its methods.</p>
<p>Storage maps, just like <code>Vec&lt;T&gt;</code> and <code>StorageVec&lt;T&gt;</code>, are implemented using generics which means that the <code>StorageMap&lt;K, V&gt;</code> type provided by the standard library can map keys of any type <code>K</code> to values of any type <code>V</code>. In the example above, weâ€™ve told the Sway compiler that the <code>StorageMap&lt;K, V&gt;</code> in <code>map</code> will map keys of type <code>Address</code> to values of type <code>u64</code>.</p>
<!-- use_storage_maps:example:end -->
<h2 id="updating-a-storage-map"><a class="header" href="#updating-a-storage-map">Updating a Storage Map</a></h2>
<!-- This section should explain how to update storage maps in Sway -->
<!-- update_storage_maps:example:start -->
<p>To insert key-value pairs into a storage map, we can use the <code>insert</code> method.</p>
<!-- update_storage_maps:example:end -->
<p>For example:</p>
<pre><code class="language-sway">    #[storage(write)]
    fn insert_into_storage_map() {
        let addr1 = Address::from(0x0101010101010101010101010101010101010101010101010101010101010101);
        let addr2 = Address::from(0x0202020202020202020202020202020202020202020202020202020202020202);

        storage.map.insert(addr1, 42);
        storage.map.insert(addr2, 77);
    }
</code></pre>
<p>Note two details here. First, in order to use <code>insert</code>, we need to first access the storage map using the <code>storage</code> keyword. Second, because <code>insert</code> requires <em>writing</em> into storage, a <code>#[storage(write)]</code> annotation is required on the ABI function that calls <code>insert</code>.</p>
<blockquote>
<p><strong>Note</strong>
The storage annotation is also required for any private function defined in the contract that tries to insert into the map.</p>
</blockquote>
<!-- markdownlint-disable-line MD028 -->
<blockquote>
<p><strong>Note</strong>
There is no need to add the <code>mut</code> keyword when declaring a <code>StorageMap&lt;K, V&gt;</code>. All storage variables are mutable by default.</p>
</blockquote>
<h2 id="accessing-values-in-a-storage-map"><a class="header" href="#accessing-values-in-a-storage-map">Accessing Values in a Storage Map</a></h2>
<!-- This section should explain how to access storage map values in Sway -->
<!-- access_storage_maps:example:start -->
<p>We can get a value out of the storage map by providing its <code>key</code> to the <code>get</code> method.</p>
<!-- access_storage_maps:example:end -->
<p>For example:</p>
<pre><code class="language-sway">    #[storage(read, write)]
    fn get_from_storage_map() {
        let addr1 = Address::from(0x0101010101010101010101010101010101010101010101010101010101010101);
        let addr2 = Address::from(0x0202020202020202020202020202020202020202020202020202020202020202);

        storage.map.insert(addr1, 42);
        storage.map.insert(addr2, 77);

        let value1 = storage.map.get(addr1).try_read().unwrap_or(0);
    }
</code></pre>
<p>Here, <code>value1</code> will have the value that's associated with the first address, and the result will be <code>42</code>. The <code>get</code> method returns an <code>Option&lt;V&gt;</code>; if thereâ€™s no value for that key in the storage map, <code>get</code> will return <code>None</code>. This program handles the <code>Option</code> by calling <code>unwrap_or</code> to set <code>value1</code> to zero if <code>map</code> doesn't have an entry for the key.</p>
<h2 id="storage-maps-with-multiple-keys"><a class="header" href="#storage-maps-with-multiple-keys">Storage Maps with Multiple Keys</a></h2>
<p>Maps with multiple keys can be implemented using tuples as keys. For example:</p>
<pre><code class="language-sway">    map_two_keys: StorageMap&lt;(b256, bool), b256&gt; = StorageMap::&lt;(b256, bool), b256&gt; {},
</code></pre>
<h2 id="nested-storage-maps"><a class="header" href="#nested-storage-maps">Nested Storage Maps</a></h2>
<p>It is possible to nest storage maps as follows:</p>
<pre><code class="language-sway">    nested_map: StorageMap&lt;u64, StorageMap&lt;u64, u64&gt;&gt; = StorageMap::&lt;u64, StorageMap&lt;u64, u64&gt;&gt; {},
</code></pre>
<p>The nested map can then be accessed as follows:</p>
<pre><code class="language-sway">    #[storage(read, write)]
    fn access_nested_map() {
        storage.nested_map.get(0).insert(1, 42);
        storage.nested_map.get(2).insert(3, 24);

        assert(storage.nested_map.get(0).get(1).read() == 42);
        assert(storage.nested_map.get(0).get(0).try_read().is_none()); // Nothing inserted here
        assert(storage.nested_map.get(2).get(3).read() == 24);
        assert(storage.nested_map.get(2).get(2).try_read().is_none()); // Nothing inserted here
    }
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="testing"><a class="header" href="#testing">Testing</a></h1>
<p>Sway aims to provide facilities for both unit testing and integration testing.</p>
<p><strong>Unit testing</strong> refers to &quot;in-language&quot; test functions annotated with <code>#[test]</code>.</p>
<p><strong>Integration testing</strong> refers to the testing of your Sway project's integration
within some wider application. You can add integration testing to your Sway+Rust
projects today using the cargo generate template and Rust SDK.</p>
<ul>
<li><a href="testing/./unit-testing.html">Unit Testing</a></li>
<li><a href="testing/./testing-with-rust.html">Testing with Rust</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="unit-testing"><a class="header" href="#unit-testing">Unit Testing</a></h1>
<!-- This section should explain unit testing in Sway -->
<!-- unit_test:example:start -->
<p>Forc provides built-in support for building and executing tests for a package.</p>
<p>Tests are written as free functions with the <code>#[test]</code> attribute.</p>
<!-- unit_test:example:end -->
<p>For example:</p>
<pre><code class="language-sway">#[test]
fn test_meaning_of_life() {
    assert(6 * 7 == 42);
}
</code></pre>
<p>Each test function is ran as if it were the entry point for a
<a href="testing/../sway-program-types/scripts.html">script</a>. Tests &quot;pass&quot; if they return
successfully, and &quot;fail&quot; if they revert or vice versa while <a href="testing/unit-testing.html#testing-failure">testing failure</a>.</p>
<p>If the project has failing tests <code>forc test</code> will exit with exit status <code>101</code>.</p>
<h2 id="building-and-running-tests"><a class="header" href="#building-and-running-tests">Building and Running Tests</a></h2>
<p>We can build and execute all tests within a package with the following:</p>
<pre><code class="language-console">forc test
</code></pre>
<p>The output should look similar to this:</p>
<pre><code class="language-console">  Compiled library &quot;core&quot;.
  Compiled library &quot;std&quot;.
  Compiled library &quot;lib_single_test&quot;.
  Bytecode size is 92 bytes.
   Running 1 tests
      test test_meaning_of_life ... ok (170.652Âµs)
   Result: OK. 1 passed. 0 failed. Finished in 1.564996ms.
</code></pre>
<p>Visit the <a href="testing/../forc/commands/forc_test.html"><code>forc test</code></a> command reference to find
the options available for <code>forc test</code>.</p>
<h2 id="testing-failure"><a class="header" href="#testing-failure">Testing Failure</a></h2>
<!-- This section should explain support for failing unit tests in Sway -->
<!-- unit_test_fail:example:start -->
<p>Forc supports testing failing cases for test functions declared with <code>#[test(should_revert)]</code>.</p>
<!-- unit_test_fail:example:end -->
<p>For example:</p>
<pre><code class="language-sway">#[test(should_revert)]
fn test_meaning_of_life() {
    assert(6 * 6 == 42);
}
</code></pre>
<p>It is also possible to specify an expected revert code, like the following example.</p>
<pre><code class="language-sway">#[test(should_revert = &quot;18446744073709486084&quot;)]
fn test_meaning_of_life() {
    assert(6 * 6 == 42);
}
</code></pre>
<p>Tests with <code>#[test(should_revert)]</code> are considered to be passing if they are reverting.</p>
<h2 id="calling-contracts-1"><a class="header" href="#calling-contracts-1">Calling Contracts</a></h2>
<p>Unit tests can call contract functions an example for such calls can be seen below.</p>
<pre><code class="language-sway">contract;

abi MyContract {
    fn test_function() -&gt; bool;
}

impl MyContract for Contract {
    fn test_function() -&gt; bool {
        true
    }
}
</code></pre>
<p>To test the <code>test_function()</code>, a unit test like the following can be written.</p>
<pre><code class="language-sway">#[test]
fn test_success() {
    let caller = abi(MyContract, CONTRACT_ID);
    let result = caller.test_function {}();
    assert(result == true)
}
</code></pre>
<p>It is also possible to test failure with contract calls as well.</p>
<pre><code class="language-sway">#[test(should_revert)]
fn test_fail() {
    let caller = abi(MyContract, CONTRACT_ID);
    let result = caller.test_function {}();
    assert(result == false)
}
</code></pre>
<!-- This section should explain how the `CONTRACT_ID` variable works in Sway unit tests -->
<!-- contract_id:example:start -->
<blockquote>
<p><strong>Note:</strong> When running <code>forc test</code>, your contract will be built twice: first <em>without</em> unit tests in order to determine the contract's ID, then a second time <em>with</em> unit tests with the <code>CONTRACT_ID</code> provided to their namespace. This <code>CONTRACT_ID</code> can be used with the <code>abi</code> cast to enable contract calls within unit tests.</p>
</blockquote>
<!-- contract_id:example:end -->
<p>Unit tests can call methods of external contracts if those contracts are added as contract dependencies, i.e. in the <a href="testing/../forc/manifest_reference.html#the-contract-dependencies-section"><code>contract-dependencies</code></a> section of the manifest file. An example of such calls is shown below:</p>
<pre><code class="language-sway">contract;

abi CallerContract {
    fn test_false() -&gt; bool;
}

impl CallerContract for Contract {
    fn test_false() -&gt; bool {
        false
    }
}

abi CalleeContract {
    fn test_true() -&gt; bool;
}

#[test]
fn test_multi_contract_calls() {
    let caller = abi(CallerContract, CONTRACT_ID);
    let callee = abi(CalleeContract, callee::CONTRACT_ID);

    let should_be_false = caller.test_false();
    let should_be_true = callee.test_true();
    assert(!should_be_false);
    assert(should_be_true);
}
</code></pre>
<p>Example <code>Forc.toml</code> for contract above:</p>
<pre><code class="language-toml">[project]
authors = [&quot;Fuel Labs &lt;contact@fuel.sh&gt;&quot;]
entry = &quot;main.sw&quot;
license = &quot;Apache-2.0&quot;
name = &quot;caller&quot;

[dependencies]
core = { path = &quot;../../../sway-lib-core&quot; }
std = { path = &quot;../../../sway-lib-std/&quot; }

[contract-dependencies]
callee = { path = &quot;../callee&quot; }
</code></pre>
<h2 id="running-tests-in-parallel-or-serially"><a class="header" href="#running-tests-in-parallel-or-serially">Running Tests in Parallel or Serially</a></h2>
<!-- This section should explain how unit tests do not share storage -->
<!-- storage:example:start -->
<p>By default, all unit tests in your project are run in parallel. Note that this does not lead to any data races in storage because each unit test has its own storage space that is not shared by any other unit test.</p>
<!-- storage:example:end -->
<p>By default, <code>forc test</code> will use all the available threads in your system. To request that a specific number of threads be used, the flag <code>--test-threads &lt;val&gt;</code> can be provided to <code>forc test</code>.</p>
<pre><code class="language-console">forc test --test-threads 1
</code></pre>
<h2 id="logs-inside-tests"><a class="header" href="#logs-inside-tests">Logs Inside Tests</a></h2>
<!-- This section should explain how log decoding works with Sway unit tests -->
<!-- unit_test_log::example::start -->
<p>Forc has some capacity to help decode logs returned from the unit tests. You can use this feature to decode raw logs into a human readable format.</p>
<pre><code class="language-sway">script;

fn main() {}

#[test]
fn test_fn() {
let a = 10;
    log(a);
    let b = 30;
    log(b);
    assert_eq(a, 10)
    assert_eq(b, 30)
}
</code></pre>
<p>The example shown above is logging two different variables, <code>a</code> and <code>b</code> and their values are <code>10</code> and <code>30</code>, respectively. Without log decoding printed log for this test with <code>forc test --logs</code> (<code>--logs</code> flag is required to see the logs for this example since the test is passing. Logs are silenced by default in passing tests, and can be enabled using the <code>--logs</code> flag.):</p>
<pre><code class="language-console">Finished debug [unoptimized + fuel] target(s) in 5.23s
      Bytecode hash: 0x1cb1edc031691c5c08b50fd0f07b02431848ab81b325b72eb3fd233c67d6b548
   Running 1 test, filtered 0 tests
      test test_fn ... ok (38.875Âµs, 232 gas)
[{&quot;LogData&quot;:{&quot;data&quot;:&quot;000000000000000a&quot;,&quot;digest&quot;:&quot;8d85f8467240628a94819b26bee26e3a9b2804334c63482deacec8d64ab4e1e7&quot;,&quot;id&quot;:&quot;0000000000000000000000000000000000000000000000000000000000000000&quot;,&quot;is&quot;:10368,&quot;len&quot;:8,&quot;pc&quot;:11032,&quot;ptr&quot;:67107840,&quot;ra&quot;:0,&quot;rb&quot;:0}},{&quot;LogData&quot;:{&quot;data&quot;:&quot;000000000000001e&quot;,&quot;digest&quot;:&quot;48a97e421546f8d4cae1cf88c51a459a8c10a88442eed63643dd263cef880c1c&quot;,&quot;id&quot;:&quot;0000000000000000000000000000000000000000000000000000000000000000&quot;,&quot;is&quot;:10368,&quot;len&quot;:8,&quot;pc&quot;:11516,&quot;ptr&quot;:67106816,&quot;ra&quot;:0,&quot;rb&quot;:1}}]
</code></pre>
<p>This is not very easy to understand, it is possible to decode these logs with <code>--decode</code> flag, executing <code>forc test --logs --decode</code>:</p>
<pre><code class="language-console">Finished debug [unoptimized + fuel] target(s) in 5.23s
      Bytecode hash: 0x1cb1edc031691c5c08b50fd0f07b02431848ab81b325b72eb3fd233c67d6b548
   Running 1 test, filtered 0 tests
      test test_fn ... ok (38.875Âµs, 232 gas)
Decoded log value: 10, log rb: 0
Decoded log value: 30, log rb: 1
</code></pre>
<p>As it can be seen, the values are human readable and easier to understand which makes debugging much more easier.</p>
<p><strong>Note</strong>: This is an experimental feature and we are actively working on reporting variable names next to their values.</p>
<!-- unit_test_log::example::end -->
<div style="break-before: page; page-break-before: always;"></div><h1 id="testing-with-rust"><a class="header" href="#testing-with-rust">Testing with Rust</a></h1>
<p>A common use of Sway is for writing contracts or scripts that exist as part of a
wider Rust application. In order to test the interaction between our Sway code
and our Rust code we can add integration testing.</p>
<h2 id="adding-rust-integration-testing"><a class="header" href="#adding-rust-integration-testing">Adding Rust Integration Testing</a></h2>
<p>To add Rust integration testing to a Forc project we can use <a href="https://github.com/FuelLabs/sway/tree/master/templates/sway-test-rs">the <code>sway-test-rs</code>
cargo generate
template</a>.
This template makes it easier for Sway developers to add the boilerplate required when
setting up their Rust integration testing.</p>
<p>Let's add a Rust integration test to <a href="testing/../introduction/forc_project.html">the fresh project we created in the introduction</a>.</p>
<h3 id="1-enter-the-project"><a class="header" href="#1-enter-the-project">1. Enter the project</a></h3>
<p>To recap, here's what our empty project looks like:</p>
<pre><code class="language-console">$ cd my-fuel-project
$ tree .
â”œâ”€â”€ Forc.toml
â””â”€â”€ src
 Â Â  â””â”€â”€ main.sw
</code></pre>
<h3 id="2-install-cargo-generate"><a class="header" href="#2-install-cargo-generate">2. Install <code>cargo generate</code></a></h3>
<p>We're going to add a Rust integration test harness using a cargo generate
template. Let's make sure we have the <code>cargo generate</code> command installed!</p>
<pre><code class="language-console">cargo install cargo-generate
</code></pre>
<blockquote>
<p><em><strong>Note</strong>: You can learn more about cargo generate by visiting the
<a href="https://github.com/cargo-generate/cargo-generate">cargo-generate repository</a>.</em></p>
</blockquote>
<h3 id="3-generate-the-test-harness"><a class="header" href="#3-generate-the-test-harness">3. Generate the test harness</a></h3>
<p>Let's generate the default test harness with the following:</p>
<pre><code class="language-console">cargo generate --init fuellabs/sway templates/sway-test-rs --name my-fuel-project --force
</code></pre>
<p><code>--force</code> forces your <code>--name</code> input to retain your desired casing for the <code>{{project-name}}</code>
placeholder in the template. Otherwise, <code>cargo-generate</code> automatically converts it to <code>kebab-case</code>.
With <code>--force</code>, this means that both <code>my_fuel_project</code> and <code>my-fuel-project</code> are valid project names,
depending on your needs.</p>
<blockquote>
<p>_<strong>Note</strong>: <code>templates/sway-test-rs</code> can be replaced with <code>templates/sway-script-test-rs</code> or <code>templates/sway-predicate-test-rs</code> to generate a test
harness for scripts and predicates respectively.</p>
</blockquote>
<p>If all goes well, the output should look as follows:</p>
<pre><code class="language-console">âš ï¸   Favorite `fuellabs/sway` not found in config, using it as a git repository: https://github.com/fuellabs/sway
ðŸ¤·   Project Name : my-fuel-project
ðŸ”§   Destination: /home/user/path/to/my-fuel-project ...
ðŸ”§   Generating template ...
[1/3]   Done: Cargo.toml
[2/3]   Done: tests/harness.rs
[3/3]   Done: tests
ðŸ”§   Moving generated files into: `/home/user/path/to/my-fuel-project`...
âœ¨   Done! New project created /home/user/path/to/my-fuel-project
</code></pre>
<p>Let's have a look at the result:</p>
<pre><code class="language-console">$ tree .
â”œâ”€â”€ Cargo.toml
â”œâ”€â”€ Forc.toml
â”œâ”€â”€ src
â”‚Â Â  â””â”€â”€ main.sw
â””â”€â”€ tests
    â””â”€â”€ harness.rs
</code></pre>
<p>We have two new files!</p>
<ul>
<li>The <code>Cargo.toml</code> is the manifest for our new test harness and specifies the
required dependencies including <code>fuels</code> the Fuel Rust SDK.</li>
<li>The <code>tests/harness.rs</code> contains some boilerplate test code to get us started,
though doesn't call any contract methods just yet.</li>
</ul>
<h3 id="4-build-the-forc-project"><a class="header" href="#4-build-the-forc-project">4. Build the forc project</a></h3>
<p>Before running the tests, we need to build our contract so that the necessary
ABI, storage and bytecode artifacts are available. We can do so with <code>forc build</code>:</p>
<pre><code class="language-console">$ forc build
  Creating a new `Forc.lock` file. (Cause: lock file did not exist)
    Adding core
    Adding std git+https://github.com/fuellabs/sway?tag=v0.24.5#e695606d8884a18664f6231681333a784e623bc9
   Created new lock file at /home/user/path/to/my-fuel-project/Forc.lock
  Compiled library &quot;core&quot;.
  Compiled library &quot;std&quot;.
  Compiled contract &quot;my-fuel-project&quot;.
  Bytecode size is 60 bytes.
</code></pre>
<p>At this point, our project should look like the following:</p>
<pre><code class="language-console">$ tree
â”œâ”€â”€ Cargo.toml
â”œâ”€â”€ Forc.lock
â”œâ”€â”€ Forc.toml
â”œâ”€â”€ out
â”‚Â Â  â””â”€â”€ debug
â”‚Â Â      â”œâ”€â”€ my-fuel-project-abi.json
â”‚Â Â      â”œâ”€â”€ my-fuel-project.bin
â”‚Â Â      â””â”€â”€ my-fuel-project-storage_slots.json
â”œâ”€â”€ src
â”‚Â Â  â””â”€â”€ main.sw
â””â”€â”€ tests
    â””â”€â”€ harness.rs
</code></pre>
<p>We now have an <code>out</code> directory with our required JSON files!</p>
<blockquote>
<p><em><strong>Note</strong>: This step may no longer be required in the future as we plan to
enable the integration testing to automatically build the artifacts as
necessary so that files like the ABI JSON are always up to date.</em></p>
</blockquote>
<h3 id="5-build-and-run-the-tests"><a class="header" href="#5-build-and-run-the-tests">5. Build and run the tests</a></h3>
<p>Now we're ready to build and run the default integration test.</p>
<pre><code class="language-console">$ cargo test
    Updating crates.io index
   Compiling version_check v0.9.4
   Compiling proc-macro2 v1.0.46
   Compiling quote v1.0.21
   ...
   Compiling fuels v0.24.0
   Compiling my-fuel-project v0.1.0 (/home/user/path/to/my-fuel-project)
    Finished test [unoptimized + debuginfo] target(s) in 1m 03s
     Running tests/harness.rs (target/debug/deps/integration_tests-373971ac377845f7)

running 1 test
test can_get_contract_id ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.36s
</code></pre>
<blockquote>
<p><em><strong>Note</strong>: The first time we run <code>cargo test</code>, cargo will spend some time
fetching and building the dependencies for Fuel's Rust SDK. This might take a
while, but only the first time!</em></p>
</blockquote>
<p>If all went well, we should see some output that looks like the above!</p>
<h2 id="writing-tests"><a class="header" href="#writing-tests">Writing Tests</a></h2>
<p>Now that we've learned how to setup Rust integration testing in our project,
let's try to write some of our own tests!</p>
<p>First, let's update our contract code with a simple counter example:</p>
<pre><code class="language-sway">contract;

abi TestContract {
    #[storage(write)]
    fn initialize_counter(value: u64) -&gt; u64;

    #[storage(read, write)]
    fn increment_counter(amount: u64) -&gt; u64;
}

storage {
    counter: u64 = 0,
}

impl TestContract for Contract {
    #[storage(write)]
    fn initialize_counter(value: u64) -&gt; u64 {
        storage.counter.write(value);
        value
    }

    #[storage(read, write)]
    fn increment_counter(amount: u64) -&gt; u64 {
        let incremented = storage.counter.read() + amount;
        storage.counter.write(incremented);
        incremented
    }
}
</code></pre>
<p>To test our <code>initialize_counter</code> and <code>increment_counter</code> contract methods from
the Rust test harness, we could update our <code>tests/harness.rs</code> file with the
following:</p>
<!--TODO add test here once examples are tested-->
<pre><code class="language-rust ignore">use fuels::{prelude::*, types::ContractId};

// Load ABI from JSON
abigen!(TestContract, &quot;out/debug/my-fuel-project-abi.json&quot;);

async fn get_contract_instance() -&gt; (TestContract, ContractId) {
    // Launch a local network and deploy the contract
    let mut wallets = launch_custom_provider_and_get_wallets(
        WalletsConfig::new(
            Some(1),             /* Single wallet */
            Some(1),             /* Single coin (UTXO) */
            Some(1_000_000_000), /* Amount per coin */
        ),
        None,
    )
    .await;
    let wallet = wallets.pop().unwrap();

    let id = Contract::load_from(
        &quot;./out/debug/my-fuel-project.bin&quot;,
        LoadConfiguration::default().set_storage_configuration(
            StorageConfiguration::load_from(
                &quot;./out/debug/my-fuel-project-storage_slots.json&quot;,
            )
            .unwrap(),
        ),
    )
    .unwrap()
    .deploy(&amp;wallet, TxParameters::default())
    .await
    .unwrap();

    let instance = TestContract::new(id.to_string(), wallet);

    (instance, id.into())
}

#[tokio::test]
async fn initialize_and_increment() {
    let (contract_instance, _id) = get_contract_instance().await;
    // Now you have an instance of your contract you can use to test each function

    let result = contract_instance
        .methods()
        .initialize_counter(42)
        .call()
        .await
        .unwrap();

    assert_eq!(42, result.value);

    // Call `increment_counter()` method in our deployed contract.
    let result = contract_instance
        .methods()
        .increment_counter(10)
        .call()
        .await
        .unwrap();

    assert_eq!(52, result.value);
}</code></pre>
<p>Let's build our project once more and run the test:</p>
<pre><code class="language-console">forc build
</code></pre>
<pre><code class="language-console">$ cargo test
   Compiling my-fuel-project v0.1.0 (/home/mindtree/programming/sway/my-fuel-project)
    Finished test [unoptimized + debuginfo] target(s) in 11.61s
     Running tests/harness.rs (target/debug/deps/integration_tests-373971ac377845f7)

running 1 test
test initialize_and_increment ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 1.25s
</code></pre>
<p>When cargo runs our test, our test uses the SDK to spin up a local in-memory
Fuel network, deploy our contract to it, and call the contract methods via the
ABI.</p>
<p>You can add as many functions decorated with <code>#[tokio::test]</code> as you like, and
<code>cargo test</code> will automatically test each of them!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="debugging"><a class="header" href="#debugging">Debugging</a></h1>
<p>Forc provides tools for debugging both live transactions as well as Sway unit tests.
Debugging can be done via CLI or using the VSCode IDE.</p>
<p><strong>Unit testing</strong> refers to &quot;in-language&quot; test functions annotated with <code>#[test]</code>. Line-by-line
debugging is available within the VSCode IDE.</p>
<p><strong>Live transaction</strong> refers to the testing sending a transaction to a running Fuel Client
node to exercise your Sway code. Instruction-by-instruction debugging is available in the <code>forc debug</code> CLI.</p>
<ul>
<li><a href="debugging/./debugging_with_cli.html">Debugging with CLI</a></li>
<li><a href="debugging/./debugging_with_ide.html">Debugging with IDE</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="debugging-with-cli"><a class="header" href="#debugging-with-cli">Debugging with CLI</a></h1>
<p>The <code>forc debug</code> CLI enables debugging a live transaction on a running Fuel Client node.</p>
<h2 id="an-example-project"><a class="header" href="#an-example-project">An example project</a></h2>
<p>First, we need a project to debug, so create a new project using</p>
<pre><code class="language-bash">forc new --script dbg_example &amp;&amp; cd dbg_example
</code></pre>
<p>And then add some content to <code>src/main.sw</code>, for example:</p>
<pre><code class="language-sway">script;

use std::logging::log;

fn factorial(n: u64) -&gt; u64 {
    let mut result = 1;
    let mut counter = 0;
    while counter &lt; n {
        counter = counter + 1;
        result = result * counter;
    }
    return result;
}

fn main() {
    log::&lt;u64&gt;(factorial(5)); // 120
}
</code></pre>
<h2 id="building-and-bytecode-output"><a class="header" href="#building-and-bytecode-output">Building and bytecode output</a></h2>
<p>Now we are ready to build the project.</p>
<pre><code class="language-bash">forc build
</code></pre>
<p>After this the resulting binary should be located at <code>out/debug/dbg_example.bin</code>. Because we are interested in the resulting bytecode, we can read that with:</p>
<pre><code class="language-bash">forc parse-bytecode out/debug/dbg_example.bin
</code></pre>
<p>Which should give us something like</p>
<pre><code class="language-text">
  half-word   byte   op                                    raw           notes
          0   0      JI { imm: 4 }                         90 00 00 04   jump to byte 16
          1   4      NOOP                                  47 00 00 00
          2   8      InvalidOpcode                         00 00 00 00   data section offset lo (0)
          3   12     InvalidOpcode                         00 00 00 44   data section offset hi (68)
          4   16     LW { ra: 63, rb: 12, imm: 1 }         5d fc c0 01
          5   20     ADD { ra: 63, rb: 63, rc: 12 }        10 ff f3 00
          6   24     MOVE { ra: 18, rb: 1 }                1a 48 10 00
          7   28     MOVE { ra: 17, rb: 0 }                1a 44 00 00
          8   32     LW { ra: 16, rb: 63, imm: 0 }         5d 43 f0 00
          9   36     LT { ra: 16, rb: 17, rc: 16 }         16 41 14 00
         10   40     JNZI { ra: 16, imm: 13 }              73 40 00 0d   conditionally jump to byte 52
         11   44     LOG { ra: 18, rb: 0, rc: 0, rd: 0 }   33 48 00 00
         12   48     RET { ra: 0 }                         24 00 00 00
         13   52     ADD { ra: 17, rb: 17, rc: 1 }         10 45 10 40
         14   56     MUL { ra: 18, rb: 18, rc: 17 }        1b 49 24 40
         15   60     JI { imm: 8 }                         90 00 00 08   jump to byte 32
         16   64     NOOP                                  47 00 00 00
         17   68     InvalidOpcode                         00 00 00 00
         18   72     InvalidOpcode                         00 00 00 05
</code></pre>
<p>We can recognize the <code>while</code> loop by the conditional jumps <code>JNZI</code>. The condition just before the first jump can be identified by <code>LT</code> instruction (for <code>&lt;</code>). Some notable instructions that are generated only once in our code include <code>MUL</code> for multiplication and <code>LOG {.., 0, 0, 0}</code> from the <code>log</code> function.</p>
<h2 id="setting-up-the-debugging"><a class="header" href="#setting-up-the-debugging">Setting up the debugging</a></h2>
<p>We can start up the debug infrastructure. On a new terminal session run <code>fuel-core run --db-type in-memory --debug</code>; we need to have that running because it actually executes the program. Now we can fire up the debugger itself: <code>forc-debug</code>. Now
if everything is set up correctly, you should see the debugger prompt (<code>&gt;&gt;</code>). You can use <code>help</code> command to list available commands.</p>
<p>Now we would like to inspect the program while it's running. To do this, we first need to send the script to the executor, i.e. <code>fuel-core</code>. To do so, we need a <em>transaction specification</em>, <code>tx.json</code>. It looks something like this:</p>
<pre><code class="language-json">{
    &quot;Script&quot;: {
        &quot;script_gas_limit&quot;: 1000000,
        &quot;script&quot;: [],
        &quot;script_data&quot;: [],
        &quot;policies&quot;: {
            &quot;bits&quot;: &quot;GasPrice&quot;,
            &quot;values&quot;: [0,0,0,0]
        },
        &quot;inputs&quot;: [
            {
                &quot;CoinSigned&quot;: {
                    &quot;utxo_id&quot;: {
                        &quot;tx_id&quot;: &quot;c49d65de61cf04588a764b557d25cc6c6b4bc0d7429227e2a21e61c213b3a3e2&quot;,
                        &quot;output_index&quot;: 18
                    },
                    &quot;owner&quot;: &quot;f1e92c42b90934aa6372e30bc568a326f6e66a1a0288595e6e3fbd392a4f3e6e&quot;,
                    &quot;amount&quot;: 10599410012256088338,
                    &quot;asset_id&quot;: &quot;2cafad611543e0265d89f1c2b60d9ebf5d56ad7e23d9827d6b522fd4d6e44bc3&quot;,
                    &quot;tx_pointer&quot;: {
                        &quot;block_height&quot;: 0,
                        &quot;tx_index&quot;: 0
                    },
                    &quot;witness_index&quot;: 0,
                    &quot;maturity&quot;: 0,
                    &quot;predicate_gas_used&quot;: null,
                    &quot;predicate&quot;: null,
                    &quot;predicate_data&quot;: null
                }
            }
        ],
        &quot;outputs&quot;: [],
        &quot;witnesses&quot;: [
            {
                &quot;data&quot;: [
                    156,254,34,102,65,96,133,170,254,105,147,35,196,199,179,133,132,240,208,149,11,46,30,96,44,91,121,195,145,184,159,235,117,82,135,41,84,154,102,61,61,16,99,123,58,173,75,226,219,139,62,33,41,176,16,18,132,178,8,125,130,169,32,108
                ]
            }
        ],
        &quot;receipts_root&quot;: &quot;0000000000000000000000000000000000000000000000000000000000000000&quot;
    }
}
</code></pre>
<p>However, the key <code>script</code> should contain the actual bytecode to execute, i.e. the contents of <code>out/debug/dbg_example.bin</code> as a JSON array. The following command can be used to generate it:</p>
<pre><code class="language-bash">python3 -c 'print(list(open(&quot;out/debug/dbg_example.bin&quot;, &quot;rb&quot;).read()))'
</code></pre>
<p>So now we replace the script array with the result, and save it as <code>tx.json</code>.</p>
<h2 id="using-the-debugger"><a class="header" href="#using-the-debugger">Using the debugger</a></h2>
<p>Now we can actually execute the script:</p>
<pre><code class="language-text">&gt;&gt; start_tx tx.json

Receipt: Log { id: 0000000000000000000000000000000000000000000000000000000000000000, ra: 120, rb: 0, rc: 0, rd: 0, pc: 10380, is: 10336 }
Receipt: Return { id: 0000000000000000000000000000000000000000000000000000000000000000, val: 0, pc: 10384, is: 10336 }
Receipt: ScriptResult { result: Success, gas_used: 60 }
Terminated
</code></pre>
<p>Looking at the first output line, we can see that it logged <code>ra: 120</code> which is the correct return value for <code>factorial(5)</code>. It also tells us that the execution terminated without hitting any breakpoints. That's unsurprising, because we haven't set up any. We can do so with <code>breakpoint</code> command:</p>
<pre><code class="language-text">&gt;&gt; breakpoint 0

&gt;&gt; start_tx tx.json

Receipt: ScriptResult { result: Success, gas_used: 0 }
Stopped on breakpoint at address 0 of contract 0x0000000000000000000000000000000000000000000000000000000000000000

</code></pre>
<p>Now we have stopped execution at the breakpoint on entry (address <code>0</code>). We can now inspect the initial state of the VM.</p>
<pre><code class="language-text">&gt;&gt; register ggas

reg[0x9] = 1000000  # ggas

&gt;&gt; memory 0x10 0x8

 000010: e9 5c 58 86 c8 87 26 dd
</code></pre>
<p>However, that's not too interesting either, so let's just execute until the end, and then reset the VM to remove the breakpoints.</p>
<pre><code class="language-text">&gt;&gt; continue

Receipt: Log { id: 0000000000000000000000000000000000000000000000000000000000000000, ra: 120, rb: 0, rc: 0, rd: 0, pc: 10380, is: 10336 }
Receipt: Return { id: 0000000000000000000000000000000000000000000000000000000000000000, val: 0, pc: 10384, is: 10336 }
Terminated

&gt;&gt; reset

</code></pre>
<p>Next, we will setup a breakpoint to check the state on each iteration of the <code>while</code> loop. For instance, if we'd like to see what numbers get multiplied together, we could set up a breakpoint before the operation. The bytecode has only a single <code>MUL</code> instruction:</p>
<pre><code class="language-text">  half-word   byte   op                                    raw           notes
         14   56     MUL { ra: 18, rb: 18, rc: 17 }        1b 49 24 40
</code></pre>
<p>We can set a breakpoint on its address, at halfword-offset <code>14</code>.</p>
<pre><code class="language-text">&gt;&gt;&gt; breakpoint 14

&gt;&gt; start_tx tx.json

Receipt: ScriptResult { result: Success, gas_used: 9 }
Stopped on breakpoint at address 56 of contract 0x0000000000000000000000000000000000000000000000000000000000000000

</code></pre>
<p>Now we can inspect the inputs to multiply. Looking at <a href="https://github.com/FuelLabs/fuel-specs/blob/master/src/fuel-vm/instruction-set.md#mul-multiply">the specification</a> tells us that the instruction <code>MUL { ra: 18, rb: 18, rc: 17 }</code> means <code>reg[18] = reg[18] * reg[17]</code>. So inspecting the inputs tells us that</p>
<pre><code class="language-text">&gt;&gt; r 18 17

reg[0x12] = 1        # reg18
reg[0x11] = 1        # reg17
</code></pre>
<p>So on the first round the numbers are <code>1</code> and <code>1</code>, so we can continue to the next iteration:</p>
<pre><code class="language-text">&gt;&gt; c

Stopped on breakpoint at address 56 of contract 0x0000000000000000000000000000000000000000000000000000000000000000

&gt;&gt; r 18 17

reg[0x12] = 1        # reg18
reg[0x11] = 2        # reg17

</code></pre>
<p>And the next one:</p>
<pre><code class="language-text">&gt;&gt; c

Stopped on breakpoint at address 56 of contract 0x0000000000000000000000000000000000000000000000000000000000000000

&gt;&gt; r 18 17

reg[0x12] = 2        # reg18
reg[0x11] = 3        # reg17
</code></pre>
<p>And fourth one:</p>
<pre><code class="language-text">&gt;&gt; c

Stopped on breakpoint at address 56 of contract 0x0000000000000000000000000000000000000000000000000000000000000000

&gt;&gt; r 18 17

reg[0x12] = 6        # reg18
reg[0x11] = 4        # reg17

</code></pre>
<p>And round 5:</p>
<pre><code class="language-text">&gt;&gt; c

Stopped on breakpoint at address 56 of contract 0x0000000000000000000000000000000000000000000000000000000000000000

&gt;&gt; r 18 17

reg[0x12] = 24       # reg18
reg[0x11] = 5        # reg17

</code></pre>
<p>At this point we can look at the values</p>
<div class="table-wrapper"><table><thead><tr><th>17</th><th>18</th></tr></thead><tbody>
<tr><td>1</td><td>1</td></tr>
<tr><td>2</td><td>1</td></tr>
<tr><td>3</td><td>2</td></tr>
<tr><td>4</td><td>6</td></tr>
<tr><td>5</td><td>24</td></tr>
</tbody></table>
</div>
<p>From this we can clearly see that the left side, register <code>17</code> is the <code>counter</code> variable, and register <code>18</code> is <code>result</code>. Now the counter equals the given factorial function argument <code>5</code>, and the loop terminates. So when we continue, the program finishes without encountering any more breakpoints:</p>
<pre><code class="language-text">&gt;&gt; c

Receipt: Log { id: 0000000000000000000000000000000000000000000000000000000000000000, ra: 120, rb: 0, rc: 0, rd: 0, pc: 10380, is: 10336 }
Receipt: Return { id: 0000000000000000000000000000000000000000000000000000000000000000, val: 0, pc: 10384, is: 10336 }
Terminated
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="debugging-with-ide"><a class="header" href="#debugging-with-ide">Debugging with IDE</a></h1>
<p>The <code>forc debug</code> plugin also enables line-by-line debugging of Sway unit tests in VSCode.</p>
<h2 id="installation"><a class="header" href="#installation">Installation</a></h2>
<ol>
<li>Install the Sway VSCode extension from the <a href="https://marketplace.visualstudio.com/items?itemName=FuelLabs.sway-vscode-plugin">marketplace</a>.</li>
<li>Ensure you have the forc-debug binary installed. <code>which forc-debug</code>.
It can be installed with <code>fuelup component add forc-debug</code>.</li>
<li>Create a <code>.vscode/launch.json</code> file with the following contents:</li>
</ol>
<pre><code class="language-json">{
    &quot;version&quot;: &quot;0.2.0&quot;,
    &quot;configurations&quot;: [
        {
        &quot;type&quot;: &quot;sway&quot;,
        &quot;request&quot;: &quot;launch&quot;,
        &quot;name&quot;: &quot;Debug Sway&quot;,
        &quot;program&quot;: &quot;${file}&quot;
    }]
}
</code></pre>
<h2 id="an-example-project-1"><a class="header" href="#an-example-project-1">An example project</a></h2>
<p>Given this example contract:</p>
<pre><code class="language-sway">contract;

abi CallerContract {
    fn test_false() -&gt; bool;
}

impl CallerContract for Contract {
    fn test_false() -&gt; bool {
        false
    }
}

abi CalleeContract {
    fn test_true() -&gt; bool;
}

#[test]
fn test_multi_contract_calls() {
    let caller = abi(CallerContract, CONTRACT_ID);
    let callee = abi(CalleeContract, callee::CONTRACT_ID);

    let should_be_false = caller.test_false();
    let should_be_true = callee.test_true();
    assert(!should_be_false);
    assert(should_be_true);
}
</code></pre>
<p>Within the sway file open in VSCode, you can set breakpoints on lines within the test or functions that it calls, and click Run -&gt; Start Debugging to begin debugging the unit test.</p>
<p>This will build the sway project and run it in debug mode. The debugger will stop the VM execution when a breakpoint is hit.</p>
<p>The debug panel will show VM registers under the Variables tab, as well as the current VM opcode where execution is suspended. You can continue execution, or use the Step Over function to step forward, instruction by instruction.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sway-lsp"><a class="header" href="#sway-lsp">Sway LSP</a></h1>
<p>Welcome to the documentation for Sway LSP, the language server designed specifically for the Sway programming language. This documentation serves as a comprehensive guide to help you understand and utilize the powerful features provided by Sway LSP.</p>
<p>Sway LSP is built on the <a href="https://microsoft.github.io/language-server-protocol/">Language Server Protocol</a> (LSP), a standardized protocol for enabling rich programming language support in editor and IDE environments. It acts as a bridge between your favorite code editor or integrated development environment and the Sway programming language, offering advanced semantic analysis and a wide range of features to enhance your development experience.</p>
<p>With Sway LSP, you can expect a seamless and efficient coding experience while working with the Sway programming language. It provides intelligent code completion, precise symbol navigation, type information, and other smart features that empower you to write clean and error-free code. By leveraging the power of Sway LSP, you can increase productivity, reduce debugging time, and write high-quality code with confidence.</p>
<p>In this documentation, you will find detailed information about how to set up Sway LSP in your preferred code editor or IDE, configure its settings to match your coding style, and take advantage of its various features. We will guide you through the installation process, provide examples of typical configuration setups, and walk you through the usage of each feature supported by Sway LSP.</p>
<p>Whether you are a beginner or an experienced Sway developer, this documentation aims to be your go-to resource for understanding and maximizing the capabilities of Sway LSP. So let's dive in and unlock the full potential of the Sway programming language with Sway LSP!</p>
<ul>
<li><a href="lsp/./installation.html">Installation</a></li>
<li><a href="lsp/./features.html">Features</a></li>
<li><a href="lsp/./troubleshooting.html">Troubleshooting</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="installation-1"><a class="header" href="#installation-1">Installation</a></h1>
<p>The Sway language server is contained in the <a href="lsp/../forc/plugins/forc_lsp.html"><code>forc-lsp</code></a> binary, which is installed as part of the <a href="lsp/../introduction/fuel_toolchain.html">Fuel toolchain</a>. Once installed, it can be used with a variety of IDEs. It must be installed for any of the IDE plugins to work.</p>
<blockquote>
<p><strong>Note</strong>: There is no need to manually run <code>forc-lsp</code> (the plugin will automatically start it), however both <code>forc</code> and <code>forc-lsp</code> must be in your <code>$PATH</code>. To check if <code>forc</code> is in your <code>$PATH</code>, type <code>forc --help</code> in your terminal.</p>
</blockquote>
<h2 id="vscode"><a class="header" href="#vscode">VSCode</a></h2>
<p>This is the best supported editor at the moment.</p>
<p>You can install the latest release of the plugin from the <a href="https://marketplace.visualstudio.com/items?itemName=FuelLabs.sway-vscode-plugin">marketplace</a>.</p>
<p>Note that we only support the most recent version of VS Code.</p>
<h2 id="code-oss-vscode-on-linux"><a class="header" href="#code-oss-vscode-on-linux">Code OSS (VSCode on Linux)</a></h2>
<ol>
<li>Install <a href="https://aur.archlinux.org/packages/code-marketplace">code-marketplace</a> to get access to all of the extensions in the VSCode marketplace.</li>
<li>Install the <a href="https://marketplace.visualstudio.com/items?itemName=FuelLabs.sway-vscode-plugin">Sway</a> extension.</li>
</ol>
<h2 id="vim--neovim"><a class="header" href="#vim--neovim">vim / neovim</a></h2>
<p>Follow the documentation for <a href="https://github.com/FuelLabs/sway.vim">sway.vim</a> to install.</p>
<h2 id="helix"><a class="header" href="#helix">helix</a></h2>
<p><a href="https://docs.helix-editor.com/install.html">Install helix</a> and Sway LSP will work out of the box.</p>
<p>Sway support is built into helix using <a href="https://github.com/FuelLabs/tree-sitter-sway">tree-sitter-sway</a>.</p>
<h2 id="emacs"><a class="header" href="#emacs">Emacs</a></h2>
<p>Coming soon! Feel free to <a href="https://github.com/FuelLabs/sway/issues/3527">contribute</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="features"><a class="header" href="#features">Features</a></h1>
<h2 id="code-actions"><a class="header" href="#code-actions">Code Actions</a></h2>
<p><em>Source:</em> <a href="https://github.com/FuelLabs/sway/tree/master/sway-lsp/src/capabilities/code_actions">code_actions</a></p>
<p>Quickly generate boilerplate code and code comments for functions, structs, and ABIs.</p>
<h2 id="completion"><a class="header" href="#completion">Completion</a></h2>
<p><em>Source:</em> <a href="https://github.com/FuelLabs/sway/blob/master/sway-lsp/src/capabilities/completion.rs">completion.rs</a></p>
<p>Suggests code to follow partially written statements for functions and variables.</p>
<h2 id="diagnostics"><a class="header" href="#diagnostics">Diagnostics</a></h2>
<p><em>Source:</em> <a href="https://github.com/FuelLabs/sway/blob/master/sway-lsp/src/capabilities/diagnostic.rs">diagnostic.rs</a></p>
<p>Displays compiler warnings and errors inline.</p>
<h2 id="syntax-highlighting"><a class="header" href="#syntax-highlighting">Syntax Highlighting</a></h2>
<p><em>Source:</em> <a href="https://github.com/FuelLabs/sway/blob/master/sway-lsp/src/capabilities/highlight.rs">highlight.rs</a></p>
<p>Highlights code based on type and context.</p>
<h2 id="hover"><a class="header" href="#hover">Hover</a></h2>
<p><em>Source:</em> <a href="https://github.com/FuelLabs/sway/tree/master/sway-lsp/src/capabilities/hover">hover</a></p>
<p>Provides documentation, compiler diagnostics, and reference links when hovering over functions and variables.</p>
<h2 id="inlay-hints"><a class="header" href="#inlay-hints">Inlay Hints</a></h2>
<p><em>Source:</em> <a href="https://github.com/FuelLabs/sway/blob/master/sway-lsp/src/capabilities/inlay_hints.rs">inlay_hints.rs</a></p>
<p>Displays the implied type of a variable next to the variable name. Configurable in Settings.</p>
<h2 id="rename"><a class="header" href="#rename">Rename</a></h2>
<p><em>Source:</em> <a href="https://github.com/FuelLabs/sway/blob/master/sway-lsp/src/capabilities/rename.rs">rename.rs</a></p>
<p>Renames a symbol everywhere in the workspace.</p>
<h2 id="run"><a class="header" href="#run">Run</a></h2>
<p><em>Source:</em> <a href="https://github.com/FuelLabs/sway/blob/master/sway-lsp/src/capabilities/runnable.rs">runnable.rs</a></p>
<p>Shows a button above a runnable function or test.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="troubleshooting"><a class="header" href="#troubleshooting">Troubleshooting</a></h1>
<p>First, confirm you are running the most recent version:</p>
<pre><code class="language-sh">fuelup toolchain install latest
fuelup update
forc-lsp --version
</code></pre>
<p>Second, confirm that your <code>$PATH</code> resolves to the <code>forc-lsp</code> binary in <code>$HOME/.fuelup/bin</code>.</p>
<pre><code class="language-sh">which forc-lsp
</code></pre>
<h2 id="slow-performance"><a class="header" href="#slow-performance">Slow Performance</a></h2>
<p>If you are experiencing slow performance, you can try the following:</p>
<p>Follow <a href="lsp/troubleshooting.html#troubleshooting">the steps above</a> to ensure you are running the most recent version.</p>
<p>Then, make sure you only have the most recent version of the LSP server running.</p>
<pre><code class="language-sh">pkill forc-lsp
</code></pre>
<h3 id="large-projects"><a class="header" href="#large-projects">Large projects</a></h3>
<p>Sway projects with ten or more Sway files are likely to have slower LSP performance. We are working on better support for large projects.</p>
<p>In the meantime, if it's too slow, you can disable the LSP server entirely with the <code>sway-lsp.diagnostic.disableLsp</code> setting. The extension will still provide basic syntax highlighting, command palettes, as well as the Sway debugger, but all other language features will be disabled.</p>
<h2 id="server-logs"><a class="header" href="#server-logs">Server Logs</a></h2>
<p>You can you enable verbose logging of the LSP server.</p>
<p>In VSCode, this is under the setting:</p>
<pre><code class="language-json">&quot;sway-lsp.trace.server&quot;: &quot;verbose&quot;
</code></pre>
<p>Once enabled, you can find this in the output window under Sway Language Server.</p>
<p>For other editors, see <a href="lsp/./installation.html">Installation</a> for links to documentation.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sway-reference"><a class="header" href="#sway-reference">Sway Reference</a></h1>
<ul>
<li><a href="reference/./compiler_intrinsics.html">Compiler Intrinsics</a></li>
<li><a href="reference/./attributes.html">Attributes</a></li>
<li><a href="reference/./style_guide.html">Style Guide</a></li>
<li><a href="reference/./known_issues_and_workarounds.html">Known Issues and Workarounds</a></li>
<li><a href="reference/./rust_differences.html">Differences from Rust</a></li>
<li><a href="reference/./solidity_differences.html">Differences from Solidity</a></li>
<li><a href="reference/./contributing_to_sway.html">Contributing to Sway</a></li>
<li><a href="reference/./keywords.html">Keywords</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sway-libraries"><a class="header" href="#sway-libraries">Sway Libraries</a></h1>
<p>The purpose of Sway Libraries is to contain libraries which users can import and use that are not part of the standard library.</p>
<p>These libraries contain helper functions and other tools valuable to blockchain development.</p>
<p>For more information on how to use a Sway-Libs library, please refer to the <a href="https://fuellabs.github.io/sway-libs/book/getting_started/index.html">Sway-Libs Book</a>.</p>
<h2 id="assets-libraries"><a class="header" href="#assets-libraries">Assets Libraries</a></h2>
<p>Asset Libraries are any libraries that use <a href="reference/../blockchain-development/native_assets.html">Native Assets</a> on the Fuel Network.</p>
<ul>
<li><a href="https://fuellabs.github.io/sway-libs/book/asset/index.html">Asset Library</a>; provides helper functions for the <a href="https://github.com/FuelLabs/sway-standards/blob/master/docs/src/src-20-native-asset.md">SRC-20</a>, <a href="https://github.com/FuelLabs/sway-standards/blob/master/docs/src/src-3-minting-and-burning.md">SRC-3</a>, and <a href="https://github.com/FuelLabs/sway-standards/blob/master/docs/src/src-7-asset-metadata.md">SRC-7</a> standards.</li>
</ul>
<h2 id="access-control-and-security-libraries"><a class="header" href="#access-control-and-security-libraries">Access Control and Security Libraries</a></h2>
<p>Access Control and Security Libraries are any libraries that are built and intended to provide additional safety when developing smart contracts.</p>
<ul>
<li><a href="https://fuellabs.github.io/sway-libs/book/ownership/index.html">Ownership Library</a>; used to apply restrictions on functions such that only a <strong>single</strong> user may call them. This library provides helper functions for the <a href="https://github.com/FuelLabs/sway-standards/blob/master/docs/src/src-5-ownership.md">SRC-5; Ownership Standard</a>.</li>
<li><a href="https://fuellabs.github.io/sway-libs/book/admin/index.html">Admin Library</a>; used to apply restrictions on functions such that only a select few users may call them like a whitelist.</li>
<li><a href="https://fuellabs.github.io/sway-libs/book/pausable/index.html">Pausable Library</a>; allows contracts to implement an emergency stop mechanism.</li>
<li><a href="https://fuellabs.github.io/sway-libs/book/reentrancy/index.html">Reentrancy Guard Library</a>; used to detect and prevent reentrancy attacks.</li>
</ul>
<h2 id="cryptography-libraries"><a class="header" href="#cryptography-libraries">Cryptography Libraries</a></h2>
<p>Cryptography Libraries are any libraries that provided cryptographic functionality beyond what the std-lib provides.</p>
<ul>
<li><a href="https://fuellabs.github.io/sway-libs/book/bytecode/index.html">Bytecode Library</a>; used for on-chain verification and computation of bytecode roots for contracts and predicates.</li>
<li><a href="https://fuellabs.github.io/sway-libs/book/merkle/index.html">Merkle Proof Library</a>; used to verify Binary Merkle Trees computed off-chain.</li>
</ul>
<h2 id="math-libraries"><a class="header" href="#math-libraries">Math Libraries</a></h2>
<p>Math Libraries are libraries which provide mathematic functions or number types that are outside of the std-lib's scope.</p>
<ul>
<li><a href="https://fuellabs.github.io/sway-libs/book/fixed_point/index.html">Fixed Point Number Library</a>; an interface to implement fixed-point numbers.</li>
<li><a href="https://fuellabs.github.io/sway-libs/book/signed_integers/index.html">Signed Integers Library</a>; an interface to implement signed integers.</li>
</ul>
<h2 id="data-structures-libraries"><a class="header" href="#data-structures-libraries">Data Structures Libraries</a></h2>
<p>Data Structure Libraries are libraries which provide complex data structures which unlock additional functionality for Smart Contracts.</p>
<ul>
<li><a href="https://fuellabs.github.io/sway-libs/book/queue/index.html">Queue Library</a>; a linear data structure that provides First-In-First-Out (FIFO) operations.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="compiler-intrinsics"><a class="header" href="#compiler-intrinsics">Compiler Intrinsics</a></h1>
<p>The Sway compiler supports a list of intrinsics that perform various low level operations that are useful for building libraries. Compiler intrinsics should rarely be used but are preferred over <code>asm</code> blocks because they are type-checked and are safer overall. Below is a list of all available compiler intrinsics:</p>
<hr />
<pre><code class="language-sway">__size_of_val&lt;T&gt;(val: T) -&gt; u64
</code></pre>
<p><strong>Description:</strong> Return the size of type <code>T</code> in bytes.</p>
<p><strong>Constraints:</strong> None.</p>
<hr />
<pre><code class="language-sway">__size_of&lt;T&gt;() -&gt; u64
</code></pre>
<p><strong>Description:</strong> Return the size of type <code>T</code> in bytes.</p>
<p><strong>Constraints:</strong> None.</p>
<hr />
<pre><code class="language-sway">__size_of_str_array&lt;T&gt;() -&gt; u64
</code></pre>
<p><strong>Description:</strong> Return the size of type <code>T</code> in bytes. This intrinsic differs from <code>__size_of</code> in the case of &quot;string arrays&quot; where the actual length in bytes of the string is returned without padding the byte size to the next word alignment. When <code>T</code> is not a &quot;string array&quot; <code>0</code> is returned.</p>
<p><strong>Constraints:</strong> None.</p>
<hr />
<pre><code class="language-sway">__assert_is_str_array&lt;T&gt;()
</code></pre>
<p><strong>Description:</strong> Throws a compile error if type <code>T</code> is not a &quot;string array&quot;.</p>
<p><strong>Constraints:</strong> None.</p>
<hr />
<pre><code class="language-sway">__to_str_array(s: str) -&gt; str[N]
</code></pre>
<p><strong>Description:</strong> Converts a &quot;string slice&quot; to &quot;string array&quot; at compile time. Parameter &quot;s&quot; must be a string literal.</p>
<p><strong>Constraints:</strong> None.</p>
<hr />
<pre><code class="language-sway">__is_reference_type&lt;T&gt;() -&gt; bool
</code></pre>
<p><strong>Description:</strong> Returns <code>true</code> if <code>T</code> is a <em>reference type</em> and <code>false</code> otherwise.</p>
<p><strong>Constraints:</strong> None.</p>
<hr />
<pre><code class="language-sway">__is_str_array&lt;T&gt;() -&gt; bool
</code></pre>
<p><strong>Description:</strong> Returns <code>true</code> if <code>T</code> is a string array and <code>false</code> otherwise.</p>
<p><strong>Constraints:</strong> None.</p>
<hr />
<pre><code class="language-sway">__eq&lt;T&gt;(lhs: T, rhs: T) -&gt; bool
</code></pre>
<p><strong>Description:</strong> Returns whether <code>lhs</code> and <code>rhs</code> are equal.</p>
<p><strong>Constraints:</strong> <code>T</code> is <code>bool</code>, <code>u8</code>, <code>u16</code>, <code>u32</code>, <code>u64</code>, <code>u256</code>, <code>b256</code> or <code>raw_ptr</code>.</p>
<hr />
<pre><code class="language-sway">__gt&lt;T&gt;(lhs: T, rhs: T) -&gt; bool
</code></pre>
<p><strong>Description:</strong> Returns whether <code>lhs</code> is greater than <code>rhs</code>.</p>
<p><strong>Constraints:</strong> <code>T</code> is <code>u8</code>, <code>u16</code>, <code>u32</code>, <code>u64</code>, <code>u256</code>, <code>b256</code>.</p>
<hr />
<pre><code class="language-sway">__lt&lt;T&gt;(lhs: T, rhs: T) -&gt; bool
</code></pre>
<p><strong>Description:</strong> Returns whether <code>lhs</code> is less than <code>rhs</code>.</p>
<p><strong>Constraints:</strong> <code>T</code> is <code>u8</code>, <code>u16</code>, <code>u32</code>, <code>u64</code>, <code>u256</code>, <code>b256</code>.</p>
<hr />
<pre><code class="language-sway">__gtf&lt;T&gt;(index: u64, tx_field_id: u64) -&gt; T
</code></pre>
<p><strong>Description:</strong> Returns transaction field with ID <code>tx_field_id</code> at index <code>index</code>, if applicable. This is a wrapper around FuelVM's <a href="https://fuellabs.github.io/fuel-specs/master/vm/instruction_set#gtf-get-transaction-fields"><code>gtf</code> instruction</a>. The resulting field is cast to <code>T</code>.</p>
<p><strong>Constraints:</strong> None.</p>
<hr />
<pre><code class="language-sway">__addr_of&lt;T&gt;(val: T) -&gt; raw_ptr
</code></pre>
<p><strong>Description:</strong> Returns the address in memory where <code>val</code> is stored.</p>
<p><strong>Constraints:</strong> <code>T</code> is a reference type.</p>
<hr />
<pre><code class="language-sway">__state_load_word(key: b256) -&gt; u64
</code></pre>
<p><strong>Description:</strong> Reads and returns a single word from storage at key <code>key</code>.</p>
<p><strong>Constraints:</strong> None.</p>
<hr />
<pre><code class="language-sway">__state_load_quad(key: b256, ptr: raw_ptr, slots: u64) -&gt; bool
</code></pre>
<p><strong>Description:</strong> Reads <code>slots</code> number of slots (<code>b256</code> each) from storage starting at key <code>key</code> and stores them in memory starting at address <code>ptr</code>. Returns a Boolean describing whether all the storage slots were previously set.</p>
<p><strong>Constraints:</strong> None.</p>
<hr />
<pre><code class="language-sway">__state_store_word(key: b256, val: u64) -&gt; bool
</code></pre>
<p><strong>Description:</strong> Stores a single word <code>val</code> into storage at key <code>key</code>. Returns a Boolean describing whether the store slot was previously set.</p>
<p><strong>Constraints:</strong> None.</p>
<hr />
<pre><code class="language-sway">__state_store_quad(key: b256, ptr: raw_ptr, slots: u64) -&gt; bool
</code></pre>
<p><strong>Description:</strong> Stores <code>slots</code> number of slots (<code>b256</code> each) starting at address <code>ptr</code> in memory into storage starting at key <code>key</code>. Returns a Boolean describing whether the first storage slot was previously set.</p>
<p><strong>Constraints:</strong> None.</p>
<hr />
<pre><code class="language-sway">__log&lt;T&gt;(val: T)
</code></pre>
<p><strong>Description:</strong> Logs value <code>val</code>.</p>
<p><strong>Constraints:</strong> None.</p>
<hr />
<pre><code class="language-sway">__add&lt;T&gt;(lhs: T, rhs: T) -&gt; T
</code></pre>
<p><strong>Description:</strong> Adds <code>lhs</code> and <code>rhs</code> and returns the result.</p>
<p><strong>Constraints:</strong> <code>T</code> is an integer type, i.e. <code>u8</code>, <code>u16</code>, <code>u32</code>, <code>u64</code>, <code>u256</code>.</p>
<hr />
<pre><code class="language-sway">__sub&lt;T&gt;(lhs: T, rhs: T) -&gt; T
</code></pre>
<p><strong>Description:</strong> Subtracts <code>rhs</code> from <code>lhs</code>.</p>
<p><strong>Constraints:</strong> <code>T</code> is an integer type, i.e. <code>u8</code>, <code>u16</code>, <code>u32</code>, <code>u64</code>, <code>u256</code>.</p>
<hr />
<pre><code class="language-sway">__mul&lt;T&gt;(lhs: T, rhs: T) -&gt; T
</code></pre>
<p><strong>Description:</strong> Multiplies <code>lhs</code> by <code>rhs</code>.</p>
<p><strong>Constraints:</strong> <code>T</code> is an integer type, i.e. <code>u8</code>, <code>u16</code>, <code>u32</code>, <code>u64</code>, <code>u256</code>.</p>
<hr />
<pre><code class="language-sway">__div&lt;T&gt;(lhs: T, rhs: T) -&gt; T
</code></pre>
<p><strong>Description:</strong> Divides <code>lhs</code> by <code>rhs</code>.</p>
<p><strong>Constraints:</strong> <code>T</code> is an integer type, i.e. <code>u8</code>, <code>u16</code>, <code>u32</code>, <code>u64</code>, <code>u256</code>.</p>
<hr />
<pre><code class="language-sway">__and&lt;T&gt;(lhs: T, rhs: T) -&gt; T
</code></pre>
<p><strong>Description:</strong> Bitwise AND <code>lhs</code> and <code>rhs</code>.</p>
<p><strong>Constraints:</strong> <code>T</code> is an integer type, i.e. <code>u8</code>, <code>u16</code>, <code>u32</code>, <code>u64</code>, <code>u256</code>, <code>b256</code>.</p>
<hr />
<pre><code class="language-sway">__or&lt;T&gt;(lhs: T, rhs: T) -&gt; T
</code></pre>
<p><strong>Description:</strong> Bitwise OR <code>lhs</code> and <code>rhs</code>.</p>
<p><strong>Constraints:</strong> <code>T</code> is an integer type, i.e. <code>u8</code>, <code>u16</code>, <code>u32</code>, <code>u64</code>, <code>u256</code>, <code>b256</code>.</p>
<hr />
<pre><code class="language-sway">__xor&lt;T&gt;(lhs: T, rhs: T) -&gt; T
</code></pre>
<p><strong>Description:</strong> Bitwise XOR <code>lhs</code> and <code>rhs</code>.</p>
<p><strong>Constraints:</strong> <code>T</code> is an integer type, i.e. <code>u8</code>, <code>u16</code>, <code>u32</code>, <code>u64</code>, <code>u256</code>, <code>b256</code>.</p>
<hr />
<pre><code class="language-sway">__mod&lt;T&gt;(lhs: T, rhs: T) -&gt; T
</code></pre>
<p><strong>Description:</strong> Modulo of <code>lhs</code> by <code>rhs</code>.</p>
<p><strong>Constraints:</strong> <code>T</code> is an integer type, i.e. <code>u8</code>, <code>u16</code>, <code>u32</code>, <code>u64</code>, <code>u256</code>.</p>
<hr />
<pre><code class="language-sway">__rsh&lt;T&gt;(lhs: T, rhs: u64) -&gt; T
</code></pre>
<p><strong>Description:</strong> Logical right shift of <code>lhs</code> by <code>rhs</code>.</p>
<p><strong>Constraints:</strong> <code>T</code> is an integer type, i.e. <code>u8</code>, <code>u16</code>, <code>u32</code>, <code>u64</code>, <code>u256</code>, <code>b256</code>.</p>
<hr />
<pre><code class="language-sway">__lsh&lt;T&gt;(lhs: T, rhs: u64) -&gt; T
</code></pre>
<p><strong>Description:</strong> Logical left shift of <code>lhs</code> by <code>rhs</code>.</p>
<p><strong>Constraints:</strong> <code>T</code> is an integer type, i.e. <code>u8</code>, <code>u16</code>, <code>u32</code>, <code>u64</code>, <code>u256</code>, <code>b256</code>.</p>
<hr />
<pre><code class="language-sway">__revert(code: u64)
</code></pre>
<p><strong>Description:</strong> Reverts with error code <code>code</code>.</p>
<p><strong>Constraints:</strong> None.</p>
<hr />
<pre><code class="language-sway">__ptr_add(ptr: raw_ptr, offset: u64)
</code></pre>
<p><strong>Description:</strong> Adds <code>offset</code> to the raw value of pointer <code>ptr</code>.</p>
<p><strong>Constraints:</strong> None.</p>
<hr />
<pre><code class="language-sway">__ptr_sub(ptr: raw_ptr, offset: u64)
</code></pre>
<p><strong>Description:</strong> Subtracts <code>offset</code> to the raw value of pointer <code>ptr</code>.</p>
<p><strong>Constraints:</strong> None.</p>
<hr />
<pre><code class="language-sway">__smo&lt;T&gt;(recipient: b256, data: T, coins: u64)
</code></pre>
<p><strong>Description:</strong> Sends a message <code>data</code> of arbitrary type <code>T</code> and <code>coins</code> amount of the base asset to address <code>recipient</code>.</p>
<p><strong>Constraints:</strong> None.</p>
<hr />
<pre><code class="language-sway">__not(op: T) -&gt; T
</code></pre>
<p><strong>Description:</strong> Bitwise NOT of <code>op</code></p>
<p><strong>Constraints:</strong> <code>T</code> is an integer type, i.e. <code>u8</code>, <code>u16</code>, <code>u32</code>, <code>u64</code>, <code>u256</code>, <code>b256</code>.</p>
<hr />
<pre><code class="language-sway">__jmp_mem()
</code></pre>
<p><strong>Description:</strong> Jumps to <code>MEM[$hp]</code>.</p>
<p><strong>Constraints:</strong> None.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="attributes"><a class="header" href="#attributes">Attributes</a></h1>
<p>The Sway compiler supports a list of attributes that perform various operations that are useful for building, testing and documenting Sway programs. Below is a list of all available attributes:</p>
<h2 id="allow"><a class="header" href="#allow">Allow</a></h2>
<p>The <code>#[allow(...)]</code> attribute overrides checks so that violations will go unreported. The following checks can be disabled:</p>
<ul>
<li><code>#[allow(dead_code)]</code> disable checks for dead code;</li>
<li><code>#[allow(deprecated)]</code> disables checks for usage of deprecated structs, functions and other items.</li>
</ul>
<h2 id="doc"><a class="header" href="#doc">Doc</a></h2>
<p>The <code>#[doc(..)]</code> attribute specifies documentation.</p>
<p>Line doc comments beginning with exactly three slashes <code>///</code>, are interpreted as a special syntax for doc attributes. That is, they are equivalent to writing <code>#[doc(&quot;...&quot;)]</code> around the body of the comment, i.e., <code>/// Foo</code> turns into <code>#[doc(&quot;Foo&quot;)]</code></p>
<p>Line comments beginning with <code>//!</code> are doc comments that apply to the module of the source file they are in. That is, they are equivalent to writing <code>#![doc(&quot;...&quot;)]</code> around the body of the comment. <code>//!</code> module level doc comments should be at the top of Sway files.</p>
<p>Documentation can be generated from doc attributes using <code>forc doc</code>.</p>
<h2 id="inline"><a class="header" href="#inline">Inline</a></h2>
<p>The inline attribute suggests that a copy of the attributed function should be placed in the caller, rather than generating code to call the function where it is defined.</p>
<blockquote>
<p><strong>Note</strong>: The Sway compiler automatically inlines functions based on internal heuristics. Incorrectly inlining functions can make the program slower, so this attribute should be used with care.</p>
</blockquote>
<p>The <code>#[inline(never)]</code> attribute <em>suggests</em> that an inline expansion should never be performed.</p>
<p>The <code>#[inline(always)]</code> attribute <em>suggests</em> that an inline expansion should always be performed.</p>
<blockquote>
<p><strong>Note</strong>: <code>#[inline(..)]</code> in every form is a hint, with no <em>requirements</em>
on the language to place a copy of the attributed function in the caller.</p>
</blockquote>
<h2 id="payable"><a class="header" href="#payable">Payable</a></h2>
<p>The lack of <code>#[payable]</code> implies the method is non-payable. When calling an ABI method that is non-payable, the compiler emits an error if the amount of coins forwarded with the call is not guaranteed to be zero. Note that this is strictly a compile-time check and does not incur any runtime cost.</p>
<h2 id="storage-1"><a class="header" href="#storage-1">Storage</a></h2>
<p>In Sway, functions are pure by default but can be opted into impurity via the <code>storage</code> function attribute. The <code>storage</code> attribute may take <code>read</code> and/or <code>write</code> arguments indicating which type of access the function requires.</p>
<p>The <code>#[storage(read)]</code> attribute indicates that a function requires read access to the storage.</p>
<p>The <code>#[storage(write)]</code> attribute indicates that a function requires write access to the storage.</p>
<p>More details in <a href="reference/../blockchain-development/purity.html">Purity</a>.</p>
<h2 id="test"><a class="header" href="#test">Test</a></h2>
<p>The <code>#[test]</code> attribute marks a function to be executed as a test.</p>
<p>The <code>#[test(should_revert)]</code> attribute marks a function to be executed as a test that should revert.</p>
<p>More details in <a href="reference/../testing/unit-testing.html">Unit Testing</a>.</p>
<h2 id="deprecated"><a class="header" href="#deprecated">Deprecated</a></h2>
<p>The <code>#[deprecated]</code> attribute marks an item as deprecated and makes the compiler emit a warning for every usage of the deprecated item. This warning can be disabled using <code>#[allow(deprecated)]</code>.</p>
<p>It is possible to improve the warning message with <code>#[deprecated(note = &quot;your message&quot;)]</code></p>
<h2 id="fallback-1"><a class="header" href="#fallback-1">Fallback</a></h2>
<p>The <code>#[fallback]</code> attribute makes the compiler use the marked function as the contract call fallback function, which means that, when a contract is called, and the contract selection fails, the fallback function will be called instead.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="style-guide"><a class="header" href="#style-guide">Style Guide</a></h1>
<h2 id="capitalization"><a class="header" href="#capitalization">Capitalization</a></h2>
<!-- This section should explain the capitalization style guide -->
<!-- cap:example:start -->
<p>In Sway, structs, traits, and enums are <code>CapitalCase</code>. Modules, variables, and functions are <code>snake_case</code>, constants are <code>SCREAMING_SNAKE_CASE</code>. The compiler will warn you if your capitalization is ever unidiomatic.</p>
<!-- cap:example:end -->
<div style="break-before: page; page-break-before: always;"></div><h1 id="known-issues-and-workarounds"><a class="header" href="#known-issues-and-workarounds">Known Issues and Workarounds</a></h1>
<h2 id="known-issues"><a class="header" href="#known-issues">Known Issues</a></h2>
<ul>
<li><a href="https://github.com/FuelLabs/sway/issues/870">#870</a>: All <code>impl</code> blocks need to be defined before any of the functions they define can be called.  This includes sibling functions in the same <code>impl</code> declaration, i.e., functions in an <code>impl</code> can't call each other yet.</li>
</ul>
<h2 id="missing-features"><a class="header" href="#missing-features">Missing Features</a></h2>
<ul>
<li><a href="https://github.com/FuelLabs/sway/issues/1182">#1182</a> Arrays in a <code>storage</code> block are not yet supported. See the <a href="reference/../advanced/advanced_storage.html#manual-storage-management">Manual Storage Management</a> section for details on how to use <code>store</code> and <code>get</code> from the standard library to manage storage slots directly. Note, however, that <code>StorageMap&lt;K, V&gt;</code> <em>does</em> support arbitrary types for <code>K</code> and <code>V</code> without any limitations.</li>
</ul>
<h2 id="general"><a class="header" href="#general">General</a></h2>
<ul>
<li>No compiler optimization passes have been implemented yet, therefore bytecode will be more expensive and larger than it would be in production. Note that eventually the optimizer will support zero-cost abstractions, avoiding the need for developers to go down to inline assembly to produce optimal code.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="behavior-considered-undefined"><a class="header" href="#behavior-considered-undefined">Behavior Considered Undefined</a></h1>
<p>Sway code that contains any of the following behavior is considered undefined.
The compiler is allowed to treat undefined Sway code however it desires,
including removing it or replacing it with any other Sway code.</p>
<p>This is not an exhaustive list, it may grow or shrink, there is no formal model
of Sway's semantics so there may be more behavior considered undefined. We
reserve the right to make some of the listed behavior defined in the future.</p>
<ul>
<li>Invalid arithmetic operations (overflows, underflows, division by zero, etc)</li>
<li>Misuse of compiler intrinsics</li>
<li>Incorrect use of inline assembly</li>
<li>Reading and writing <code>raw_ptr</code> and <code>raw_slice</code></li>
<li>Slicing and indexing out of bounds by directly using compiler intrinsics.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="differences-from-solidity"><a class="header" href="#differences-from-solidity">Differences From Solidity</a></h1>
<p>This page outlines some of the critical differences between Sway and Solidity, and between the FuelVM and the EVM.</p>
<h2 id="underlying-virtual-machine"><a class="header" href="#underlying-virtual-machine">Underlying Virtual Machine</a></h2>
<p>The underlying virtual machine targeted by Sway is the FuelVM, specified <a href="https://github.com/FuelLabs/fuel-specs">here</a>. Solidity targets the Ethereum Virtual Machine (EVM), specified <a href="https://ethereum.github.io/yellowpaper/paper.pdf">here</a>.</p>
<h2 id="word-size"><a class="header" href="#word-size">Word Size</a></h2>
<p>Words in the FuelVM are 64 bits (8 bytes), rather than the 256 bits (32 bytes) of the EVM. Therefore, all primitive integers smaller and including <code>u64</code> are stored in registers; <code>u256</code>, being bigger than the registers, and hashes (the <code>b256</code> type) are not stored in registers but rather in memory. They are therefore pointers to a 32-byte memory region containing their data.</p>
<h2 id="unsigned-integers-only"><a class="header" href="#unsigned-integers-only">Unsigned Integers Only</a></h2>
<p>Only unsigned integers are provided as primitives: <code>u8</code>, <code>u16</code>, <code>u32</code>, <code>u64</code>, and <code>u256</code>. Signed integer arithmetic is not available in the FuelVM. Signed integers and signed integer arithmetic can be implemented in high-level libraries if needed.</p>
<h2 id="global-revert"><a class="header" href="#global-revert">Global Revert</a></h2>
<p>Panics in the FuelVM (called &quot;reverts&quot; in Solidity and the EVM) are global, i.e. they cannot be caught. A panic will completely and unconditionally revert the stateful effects of a transaction, minus gas used.</p>
<h2 id="default-safe-math"><a class="header" href="#default-safe-math">Default Safe Math</a></h2>
<!-- This section should explain safe math in Fuel vs EVM -->
<!-- safe_math:example:start -->
<p>Math in the FuelVM is by default safe (i.e. any overflow or exception is a panic). Safety checks are performed natively in the VM implementation, rather than at the bytecode level like <a href="https://docs.soliditylang.org/en/latest/080-breaking-changes.html#silent-changes-of-the-semantics">Solidity's default safe math</a>.</p>
<!-- safe_math:example:end -->
<h2 id="no-code-size-limit"><a class="header" href="#no-code-size-limit">No* Code Size Limit</a></h2>
<p>There is no practical code size limit to Sway contracts. The physical limit is governed by the <a href="https://fuellabs.github.io/fuel-specs/master/vm#parameters"><code>VM_MAX_RAM</code> VM parameter</a>, which at the time of writing is 64 MiB.</p>
<h2 id="account-types"><a class="header" href="#account-types">Account Types</a></h2>
<p>Account types in the FuelVM have type-safe wrappers around primitive <code>b256</code> hashes to clearly distinguish their respective types. The wrapper <code>Address</code> mirrors that of an EOA (Externally Owned Account) and has the ability to hold UTXOs in the context of the EVM. The other wrapper, <code>ContractId</code>, reflects that of a deployed contract in the EVM but cannot hold UTXOs.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="differences-from-rust"><a class="header" href="#differences-from-rust">Differences From Rust</a></h1>
<p>Sway shares a lot with Rust, especially its syntax. Because they are so similar, you may be surprised or caught off guard when they differ. This page serves to outline, from a high level, some of the syntactic <em>gotchas</em> that you may encounter.</p>
<h2 id="enum-variant-syntax"><a class="header" href="#enum-variant-syntax">Enum Variant Syntax</a></h2>
<p>In Rust, enums generally take one of three forms: <em>unit</em> variants, which have no inner data, <em>struct</em> variants, which contain named fields, and <em>tuple</em> variants, which contain within them a tuple of data. If you are unfamiliar with these terms, this is what they look like:</p>
<pre><code class="language-rust ignore">// note to those skimming the docs: this is Rust syntax! Not Sway! Don't copy/paste this into a Sway program.

enum Foo {
    UnitVariant,
    TupleVariant(u32, u64, bool),
    StructVariant {
        field_one: bool,
        field_two: bool
    }
}</code></pre>
<p>In Sway, enums are simplified. Enums variants must all specify exactly one type. This type represents their interior data. This is actually isomorphic to what Rust offers, but with a different syntax. You can see the above enum but with Sway syntax below:</p>
<pre><code class="language-sway">// This is equivalent Sway syntax for the above Rust enum.
enum Foo {
    UnitVariant: (),
    TupleVariant: (u32, u64, bool),
    StructVariant: MyStruct,
}

struct MyStruct {
    field_one: bool,
    field_two: bool,
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="contributing-to-sway"><a class="header" href="#contributing-to-sway">Contributing To Sway</a></h1>
<p>Thanks for your interest in contributing to Sway! This document outlines the process for installing and setting up the Sway toolchain for development, as well as some conventions on contributing to Sway.</p>
<p>If you run into any difficulties getting started, you can always ask questions on our <a href="https://forum.fuel.network/">Discourse</a>.</p>
<h2 id="building-and-setting-up-a-development-workspace"><a class="header" href="#building-and-setting-up-a-development-workspace">Building and setting up a development workspace</a></h2>
<p>See the <a href="reference/../introduction/index.html">introduction</a> section for instructions on installing and setting up the Sway toolchain.</p>
<h2 id="getting-the-repository"><a class="header" href="#getting-the-repository">Getting the repository</a></h2>
<ol>
<li>Visit the <a href="https://github.com/FuelLabs/sway">Sway</a> repo and fork the project.</li>
<li>Then clone your forked copy to your local machine and get to work.</li>
</ol>
<pre><code class="language-sh">git clone https://github.com/FuelLabs/sway
cd sway
</code></pre>
<h2 id="building-and-testing"><a class="header" href="#building-and-testing">Building and testing</a></h2>
<p>The following steps will run the sway test suite and ensure that everything is set up correctly.</p>
<p>First, open a new terminal and start <code>fuel-core</code> with:</p>
<pre><code class="language-sh">fuel-core
</code></pre>
<p>Then open a second terminal, <code>cd</code> into the <code>sway</code> repo and run:</p>
<pre><code class="language-sh">cargo run --bin test
</code></pre>
<p>After the test suite runs, you should see:</p>
<pre><code class="language-console">Tests passed.
_n_ tests run (0 skipped)
</code></pre>
<p>Congratulations! You've now got everything setup and are ready to start making contributions.</p>
<h2 id="finding-something-to-work-on"><a class="header" href="#finding-something-to-work-on">Finding something to work on</a></h2>
<p>There are many ways in which you may contribute to the Sway project, some of which involve coding knowledge and some which do not. A few examples include:</p>
<ul>
<li>Reporting bugs</li>
<li>Adding documentation to the Sway book</li>
<li>Adding new features or bug fixes for which there is already an open issue</li>
<li>Making feature requests</li>
</ul>
<p>Check out our <a href="https://github.com/FuelLabs/sway/issues?q=is%3Aopen+is%3Aissue+label%3A%22help+wanted%22">Help Wanted</a>, <a href="https://github.com/FuelLabs/sway/issues?q=is%3Aopen+is%3Aissue+label%3A%22The+Sway+Book%22">Sway Book</a> or <a href="https://github.com/FuelLabs/sway/issues?q=is%3Aopen+is%3Aissue+label%3A%22good+first+issue%22">Good First Issue</a> issues to find a suitable task.</p>
<p>If you are planning something big, for example, related to multiple components or changes current behaviors, make sure to open an issue to discuss with us before starting on the implementation.</p>
<h2 id="contribution-flow"><a class="header" href="#contribution-flow">Contribution flow</a></h2>
<p>This is a rough outline of what a contributor's workflow looks like:</p>
<ul>
<li>Make sure what you want to contribute is already tracked as an issue.
<ul>
<li>We may discuss the problem and solution in the issue.</li>
</ul>
</li>
<li>Create a Git branch from where you want to base your work. This is usually master.</li>
<li>Write code, add test cases, and commit your work.</li>
<li>Run tests and make sure all tests pass.</li>
<li>If the PR contains any breaking changes, add the breaking label to your PR.</li>
<li>Push your changes to a branch in your fork of the repository and submit a pull request.
<ul>
<li>Make sure to mention the issue, which is created at step 1, in the commit message.</li>
</ul>
</li>
<li>Your PR will be reviewed and some changes may be requested.
<ul>
<li>Once you've made changes, your PR must be re-reviewed and approved.</li>
<li>If the PR becomes out of date, you can use GitHub's 'update branch' button.</li>
<li>If there are conflicts, you can merge and resolve them locally. Then push to your PR branch.
Any changes to the branch will require a re-review.</li>
</ul>
</li>
<li>Our CI system (Github Actions) automatically tests all authorized pull requests.</li>
<li>Use Github to merge the PR once approved.</li>
</ul>
<p>Thanks for your contributions!</p>
<h3 id="linking-issues"><a class="header" href="#linking-issues">Linking issues</a></h3>
<p>Pull requests should be linked to at least one issue in the same repo.</p>
<p>If the pull request resolves the relevant issues, and you want GitHub to close these issues automatically after it merged into the default branch, you can use the syntax (<code>KEYWORD #ISSUE-NUMBER</code>) like this:</p>
<pre><code class="language-markdown">close #123
</code></pre>
<p>If the pull request links an issue but does not close it, you can use the keyword <code>ref</code> like this:</p>
<pre><code class="language-markdown">ref #456
</code></pre>
<p>Multiple issues should use full syntax for each issue and separate by a comma, like:</p>
<pre><code class="language-markdown">close #123, ref #456
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="keywords"><a class="header" href="#keywords">Keywords</a></h1>
<p>The following list contains keywords that are reserved for current or
future use by the Sway language. As such, they cannot be used as
identifiers. Identifiers are names of functions, variables,
parameters, modules, constants, attributes, types or
traits, etc.</p>
<h2 id="keywords-currently-in-use"><a class="header" href="#keywords-currently-in-use">Keywords Currently in Use</a></h2>
<p>The following is a list of keywords currently in use, with their
functionality described.</p>
<ul>
<li><code>as</code> - rename items in <code>use</code> statements, e.g., <code>use type::a as alias_name</code></li>
<li><a href="reference/../sway-program-types/smart_contracts.html#the-abi-declaration"><code>abi</code></a> - defines a smart contract ABI in a syntactically similar way to traits</li>
<li><a href="reference/../basics/control_flow.html#break-and-continue"><code>break</code></a> - exit a loop immediately</li>
<li><a href="reference/../basics/constants.html"><code>const</code></a> - define constant items</li>
<li><a href="reference/../basics/control_flow.html#break-and-continue"><code>continue</code></a> - continue to the next loop iteration</li>
<li><code>else</code> - used in conjunction with <code>if</code> conditions for control flow constructs</li>
<li><a href="reference/../basics/structs_tuples_and_enums.html#enums"><code>enum</code></a> - define an enumeration</li>
<li><code>false</code> - Boolean false literal</li>
<li><a href="reference/../basics/functions.html"><code>fn</code></a>- define a function or the function pointer type</li>
<li><a href="reference/../basics/control_flow.html#if-expressions"><code>if</code></a> - branch based on the result of a conditional expression</li>
<li><code>impl</code> - implement inherent or trait functionality</li>
<li><code>let</code> - bind a variable</li>
<li><a href="reference/../basics/control_flow.html#match-expressions"><code>match</code></a> - exhaustively match a value to patterns</li>
<li><code>mod</code> - define a module</li>
<li><code>mut</code> - denote mutability in references, or pattern bindings</li>
<li><code>pub</code> - denote public visibility of Sway data structures, traits, or modules</li>
<li><code>ref</code> - bind by reference</li>
<li><code>return</code> - return early from a function</li>
<li><code>Self</code> - a type alias for the type we are defining or implementing</li>
<li><code>self</code> - method subject</li>
<li><a href="reference/../basics/structs_tuples_and_enums.html#structs"><code>struct</code></a> - define a structure</li>
<li><a href="reference/../advanced/traits.html#declaring-a-trait"><code>trait</code></a> - define a trait</li>
<li><code>true</code> - Boolean true literal</li>
<li><a href="reference/../advanced/advanced_types.html#creating-type-synonyms-with-type-aliases"><code>type</code></a> - define a type alias or associated type</li>
<li><code>use</code> - bring symbols into scope</li>
<li><code>where</code> - specifies traits for generic types</li>
<li><a href="reference/../basics/control_flow.html#while"><code>while</code></a> - loop conditionally based on the result of an expression</li>
</ul>
<h2 id="keywords-reserved-for-possible-future-use"><a class="header" href="#keywords-reserved-for-possible-future-use">Keywords Reserved for Possible Future Use</a></h2>
<ul>
<li><code>abstract</code></li>
<li><code>async</code></li>
<li><code>await</code></li>
<li><code>become</code></li>
<li><code>box</code></li>
<li><code>do</code></li>
<li><code>dyn</code></li>
<li><code>extern</code></li>
<li><code>for</code></li>
<li><code>in</code></li>
<li><code>loop</code></li>
<li><code>macro</code></li>
<li><code>move</code></li>
<li><code>override</code></li>
<li><code>priv</code></li>
<li><code>static</code></li>
<li><code>super</code></li>
<li><code>try</code></li>
<li><code>typeof</code></li>
<li><code>unsafe</code></li>
<li><code>unsized</code></li>
<li><code>virtual</code></li>
<li><code>yield</code></li>
</ul>
<h2 id="special-keywords"><a class="header" href="#special-keywords">Special Keywords</a></h2>
<h3 id="program-keywords"><a class="header" href="#program-keywords">Program Keywords</a></h3>
<p>Keywords associated with defining the type of Sway program to compile</p>
<ul>
<li><a href="reference/../sway-program-types/smart_contracts.html"><code>contract</code></a> - analogous to a deployed API with some database state</li>
<li><a href="reference/../sway-program-types/libraries.html"><code>library</code></a> - Sway code that defines new common behavior</li>
<li><a href="reference/../sway-program-types/predicates.html"><code>predicate</code></a> - programs that return a Boolean value and which represent ownership of some resource upon execution to true</li>
<li><a href="reference/../sway-program-types/scripts.html"><code>script</code></a> - a runnable bytecode on the chain, which executes once to perform a task</li>
</ul>
<h3 id="attribute-keywords"><a class="header" href="#attribute-keywords">Attribute Keywords</a></h3>
<p>Keywords associated with defining the functionality of attributes</p>
<ul>
<li><a href="reference/./attributes.html#allow"><code>allow</code></a> - overrides checks that would otherwise result in errors or warnings</li>
<li><a href="reference/./attributes.html#doc"><code>doc</code></a> - specifies documentation</li>
<li><a href="reference/./attributes.html#inline"><code>inline</code></a> - suggests that a copy of the attributed function should be placed in the caller, rather than generating code to call the function where it is defined</li>
<li><a href="reference/./attributes.html#payable"><code>payable</code></a> - implies method is payable for compile time</li>
<li><a href="reference/./attributes.html#storage"><code>storage</code></a> - declaration that contains a list of stored variables</li>
<li><a href="reference/./attributes.html#test"><code>test</code></a> - marks a function to be executed as a test</li>
<li><a href="reference/./attributes.html#deprecated"><code>deprecated</code></a> - marks an item as deprecated</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="forc-reference"><a class="header" href="#forc-reference">Forc Reference</a></h1>
<p>Forc stands for Fuel Orchestrator. Forc provides a variety of tools and commands for developers working with the Fuel ecosystem, such as scaffolding a new project, formatting, running scripts, deploying contracts, testing contracts, and more. If you're coming from a Rust background, forc is similar to cargo.</p>
<p>If you are new to Forc, see the <a href="https://docs.fuel.network/docs/sway/introduction/forc_project/">Forc Project</a> introduction section.</p>
<p>For a comprehensive overview of the Forc CLI commands, see the <a href="forc/./commands/index.html">Commands</a> section.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="manifest-reference"><a class="header" href="#manifest-reference">Manifest Reference</a></h1>
<p>The <code>Forc.toml</code> (the <em>manifest</em> file) is a compulsory file for each package and it is written in [TOML] format. <code>Forc.toml</code> consists of the following fields:</p>
<ul>
<li>
<p><a href="forc/manifest_reference.html#the-project-section"><code>[project]</code></a> â€” Defines a sway project.</p>
<ul>
<li><code>name</code> â€” The name of the project.</li>
<li><code>authors</code> â€” The authors of the project.</li>
<li><code>organization</code> â€” The organization of the project.</li>
<li><code>license</code>â€” The project license.</li>
<li><code>entry</code> â€” The entry point for the compiler to start parsing from.
<ul>
<li>For the recommended way of selecting an entry point of large libraries please take a look at: <a href="forc/./../sway-program-types/libraries.html">Libraries</a></li>
</ul>
</li>
<li><code>implicit-std</code> -  Controls whether provided <code>std</code> version (with the current <code>forc</code> version) will get added as a dependency <em>implicitly</em>. <em>Unless you know what you are doing, leave this as default.</em></li>
<li><code>forc-version</code> - The minimum forc version required for this project to work properly.</li>
</ul>
</li>
<li>
<p><a href="forc/manifest_reference.html#the-dependencies-section"><code>[dependencies]</code></a> â€” Defines the dependencies.</p>
</li>
<li>
<p><code>[network]</code> â€” Defines a network for forc to interact with.</p>
<ul>
<li><code>url</code> â€” URL of the network.</li>
</ul>
</li>
<li>
<p><a href="forc/manifest_reference.html#the-build-profile-section"><code>[build-profile]</code></a> - Defines the build profiles.</p>
</li>
<li>
<p><a href="forc/manifest_reference.html#the-patch-section"><code>[patch]</code></a> - Defines the patches.</p>
</li>
<li>
<p><a href="forc/manifest_reference.html#the-contract-dependencies-section"><code>[contract-dependencies]</code></a> - Defines the contract dependencies.</p>
</li>
</ul>
<h2 id="the-project-section"><a class="header" href="#the-project-section">The <code>[project]</code> section</a></h2>
<p>An example <code>Forc.toml</code> is shown below. Under <code>[project]</code> the following fields are optional:</p>
<ul>
<li><code>authors</code></li>
<li><code>organization</code></li>
</ul>
<p>Also for the following fields, a default value is provided so omitting them is allowed:</p>
<ul>
<li><code>entry</code> - (default : <code>main.sw</code> )</li>
<li><code>implicit-std</code> - (default : <code>true</code> )</li>
</ul>
<pre><code class="language-toml">[project]
authors = [&quot;user&quot;]
entry = &quot;main.sw&quot;
organization = &quot;Fuel_Labs&quot;
license = &quot;Apache-2.0&quot;
name = &quot;wallet_contract&quot;
</code></pre>
<h2 id="the-dependencies-section"><a class="header" href="#the-dependencies-section">The <code>[dependencies]</code> section</a></h2>
<p>The following fields can be provided with a dependency:</p>
<ul>
<li><code>version</code> - Desired version of the dependency</li>
<li><code>path</code> - The path of the dependency (if it is local)</li>
<li><code>git</code> - The URL of the git repo hosting the dependency</li>
<li><code>branch</code> - The desired branch to fetch from the git repo</li>
<li><code>tag</code> - The desired tag to fetch from the git repo</li>
<li><code>rev</code> - The desired rev (i.e. commit hash) reference</li>
</ul>
<p>Please see <a href="forc/./dependencies.html">dependencies</a> for details</p>
<h2 id="the-network-section"><a class="header" href="#the-network-section">The <code>[network]</code> section</a></h2>
<p>For the following fields, a default value is provided so omitting them is allowed:</p>
<ul>
<li><code>URL</code> - (default: <em><a href="http://127.0.0.1:4000">http://127.0.0.1:4000</a></em>)</li>
</ul>
<h2 id="the-build-profile-section"><a class="header" href="#the-build-profile-section">The <code>[build-profile.*]</code> section</a></h2>
<p>The <code>[build-profile]</code> tables provide a way to customize compiler settings such as debug options.</p>
<p>The following fields can be provided for a build-profile:</p>
<ul>
<li><code>print-ast</code> - Whether to print out the generated AST or not, defaults to false.</li>
<li><code>print-dca-graph</code> - Whether to print out the computed Dead Code Analysis (DCA) graph (in GraphViz DOT format), defaults to false.</li>
<li><code>print-dca-graph-url-format</code> - The URL format to be used in the generated DOT file, an example for VS Code would be: <code>vscode://file/{path}:{line}:{col}</code>.</li>
<li><code>print-ir</code> - Whether to print out the generated Sway IR (Intermediate Representation) or not, defaults to false.</li>
<li><code>print-asm</code> - Whether to print out the generated ASM (assembler), defaults to false.</li>
<li><code>terse</code> - Terse mode. Limited warning and error output, defaults to false.</li>
<li><code>time_phases</code> - Whether to output the time elapsed over each part of the compilation process, defaults to false.</li>
<li><code>include_tests</code> -  Whether or not to include test functions in parsing, type-checking, and code generation. This is set to true by invocations like <code>forc test</code>, but defaults to false.</li>
<li><code>json_abi_with_callpaths</code> - Whether to generate a JSON ABI with <code>callpaths</code> instead of names for structs and enums, defaults to false. This option can help prevent conflicting struct or enum definitions by using the full path instead of the name.</li>
<li><code>error_on_warnings</code> - Whether to treat errors as warnings, defaults to false.</li>
</ul>
<p>There are two default <code>[build-profile]</code> available with every manifest file. These are <code>debug</code> and <code>release</code> profiles. If you want to override these profiles, you can provide them explicitly in the manifest file like the following example:</p>
<pre><code class="language-toml">[project]
authors = [&quot;user&quot;]
entry = &quot;main.sw&quot;
organization = &quot;Fuel_Labs&quot;
license = &quot;Apache-2.0&quot;
name = &quot;wallet_contract&quot;

[build-profile.debug]
print-asm = { virtual = false, allocated = false, final = true }
print-ir = { initial = false, final = true, modified = false, passes = []}
terse = false

[build-profile.release]
print-asm = { virtual = true, allocated = false, final = true }
print-ir = { initial = true, final = false, modified = true, passes = [&quot;dce&quot;, &quot;sroa&quot;]}
terse = true
</code></pre>
<p>Since <code>release</code> and <code>debug</code> are implicitly included in every manifest file, you can use them by just passing <code>--release</code> or by not passing anything (<code>debug</code> is default). For using a user defined build profile there is <code>--build-profile &lt;profile name&gt;</code> option available to the relevant commands. (For an example see <a href="forc/../forc/commands/forc_build.html">forc-build</a>)</p>
<p>Note that providing the corresponding CLI options (like <code>--asm</code>) will override the selected build profile. For example if you pass both <code>--release</code> and <code>--asm all</code>, <code>release</code> build profile is overridden and resulting build profile would have a structure like the following:</p>
<pre><code class="language-toml">print-ast = false
print-ir = { initial = false, final = false, modified = false, passes = []}
print-asm = { virtual = true, allocated = true, final = true }
terse = false
time-phases = false
include-tests = false
json-abi-with-callpaths = false
error-on-warnings = false
experimental-private-modules = false
</code></pre>
<h2 id="the-patch-section"><a class="header" href="#the-patch-section">The <code>[patch]</code> section</a></h2>
<p>The [patch] section of <code>Forc.toml</code> can be used to override dependencies with other copies. The example provided below patches <code>https://github.com/fuellabs/sway</code> with the <code>test</code> branch of the same repo.</p>
<pre><code class="language-toml">[project]
authors = [&quot;user&quot;]
entry = &quot;main.sw&quot;
organization = &quot;Fuel_Labs&quot;
license = &quot;Apache-2.0&quot;
name = &quot;wallet_contract&quot;

[dependencies]

[patch.'https://github.com/fuellabs/sway']
std = { git = &quot;https://github.com/fuellabs/sway&quot;, branch = &quot;test&quot; }
</code></pre>
<p>In the example above, <code>std</code> is patched with the <code>test</code> branch from <code>std</code> repo. You can also patch git dependencies with dependencies defined with a path.</p>
<pre><code class="language-toml">[patch.'https://github.com/fuellabs/sway']
std = { path = &quot;/path/to/local_std_version&quot; }
</code></pre>
<p>Just like <code>std</code> or <code>core</code> you can also patch dependencies you declared with a git repo.</p>
<pre><code class="language-toml">[project]
authors = [&quot;user&quot;]
entry = &quot;main.sw&quot;
organization = &quot;Fuel_Labs&quot;
license = &quot;Apache-2.0&quot;
name = &quot;wallet_contract&quot;

[dependencies]
foo = { git = &quot;https://github.com/foo/foo&quot;, branch = &quot;master&quot; }

[patch.'https://github.com/foo']
foo = { git = &quot;https://github.com/foo/foo&quot;, branch = &quot;test&quot; }
</code></pre>
<p>Note that each key after the <code>[patch]</code> is a URL of the source that is being patched.</p>
<h2 id="the-contract-dependencies-section"><a class="header" href="#the-contract-dependencies-section">The <code>[contract-dependencies]</code> section</a></h2>
<p>The <code>[contract-dependencies]</code> table can be used to declare contract dependencies for a Sway contract or script. Contract dependencies are the set of contracts that our contract or script may interact with. Declaring <code>[contract-dependencies]</code> makes it easier to refer to contracts in your Sway source code without having to manually update IDs each time a new version is deployed. Instead, we can use forc to pin and update contract dependencies just like we do for regular library dependencies.</p>
<p>Contracts declared under <code>[contract-dependencies]</code> are built and pinned just like regular <code>[dependencies]</code> however rather than importing each contract dependency's entire public namespace we instead import their respective contract IDs as <code>CONTRACT_ID</code> constants available via each contract dependency's namespace root. This means you can use a contract dependency's ID as if it were declared as a <code>pub const</code> in the root of the contract dependency package as demonstrated in the example below.</p>
<p>Entries under <code>[contract-dependencies]</code> can be declared in the same way that <code>[dependencies]</code> can be declared. That is, they can refer to the <code>path</code> or <code>git</code> source of another contract. Note that entries under <code>[contract-dependencies]</code> must refer to contracts and will otherwise produce an error.</p>
<p>Example <code>Forc.toml</code>:</p>
<pre><code class="language-toml">[project]
authors = [&quot;user&quot;]
entry = &quot;main.sw&quot;
organization = &quot;Fuel_Labs&quot;
license = &quot;Apache-2.0&quot;
name = &quot;wallet_contract&quot;

[contract-dependencies]
foo = { path = &quot;../foo&quot; }
</code></pre>
<p>Example usage:</p>
<pre><code class="language-sway">script;

fn main() {
  let foo_id = foo::CONTRACT_ID;
}
</code></pre>
<p>Because the ID of a contract is computed deterministically, rebuilding the same contract would always result in the same contract ID. Since two contracts with the same contract ID cannot be deployed on the blockchain, a &quot;salt&quot; factor is needed to modify the contract ID. For each contract dependency declared under <code>[contract-dependencies]</code>, <code>salt</code> can be specified. An example is shown below:</p>
<pre><code class="language-toml">[contract-dependencies]
foo = { path = &quot;../foo&quot;, salt = &quot;0x1000000000000000000000000000000000000000000000000000000000000000&quot; }
</code></pre>
<p>For contract dependencies that do not specify any value for <code>salt</code>, a default of all zeros for <code>salt</code> is implicitly applied.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="workspaces"><a class="header" href="#workspaces">Workspaces</a></h1>
<p>A <em>workspace</em> is a collection of one or more packages, namely <em>workspace members</em>, that are managed together.</p>
<p>The key points for workspaces are:</p>
<ul>
<li>Common <code>forc</code> commands available for a single package can also be used for a workspace, like <code>forc build</code> or <code>forc deploy</code>.</li>
<li>All packages share a common <code>Forc.lock</code> file which resides in the root directory of the workspace.</li>
</ul>
<p>Workspace manifests are declared within <code>Forc.toml</code> files and support the following fields:</p>
<ul>
<li><a href="forc/workspaces.html#the-members-field"><code>members</code></a> - Packages to include in the workspace.</li>
<li><a href="forc/workspaces.html#the-patch-section"><code>[patch]</code></a> - Defines the patches.</li>
</ul>
<p>An empty workspace can be created with <code>forc new --workspace</code> or <code>forc init --workspace</code>.</p>
<h2 id="the-members-field"><a class="header" href="#the-members-field">The <code>members</code> field</a></h2>
<p>The <code>members</code> field defines which packages are members of the workspace:</p>
<pre><code class="language-toml">[workspace]
members = [&quot;member1&quot;, &quot;path/to/member2&quot;]
</code></pre>
<p>The <code>members</code> field accepts entries to be given in relative path with respect to the workspace root.
Packages that are located within a workspace directory but are <em>not</em> contained within the <code>members</code> set are ignored.</p>
<h2 id="the-patch-section-1"><a class="header" href="#the-patch-section-1">The <code>[patch]</code> section</a></h2>
<p>The <code>[patch]</code> section can be used to override any dependency in the workspace dependency graph. The usage is the same with package level <code>[patch]</code> section and details can be seen <a href="forc/./manifest_reference.html#the-patch-section">here</a>.</p>
<p>It is not allowed to declare patch table in member of a workspace if the workspace manifest file contains a patch table.</p>
<p>Example:</p>
<pre><code class="language-toml">[workspace]
members = [&quot;member1&quot;, &quot;path/to/member2&quot;]


[patch.'https://github.com/fuellabs/sway']
std = { git = &quot;https://github.com/fuellabs/sway&quot;, branch = &quot;test&quot; }
</code></pre>
<p>In the above example each occurrence of <code>std</code> as a dependency in the workspace will be changed with <code>std</code> from <code>test</code> branch of sway repo.</p>
<h2 id="some-forc-commands-that-support-workspaces"><a class="header" href="#some-forc-commands-that-support-workspaces">Some <code>forc</code> commands that support workspaces</a></h2>
<ul>
<li><code>forc build</code> - Builds an entire workspace.</li>
<li><code>forc deploy</code> - Builds and deploys all deployable members (i.e, contracts) of the workspace in the correct order.</li>
<li><code>forc run</code> - Builds and runs all scripts of the workspace.</li>
<li><code>forc check</code> - Checks all members of the workspace.</li>
<li><code>forc update</code> - Checks and updates workspace level <code>Forc.lock</code> file that is shared between workspace members.</li>
<li><code>forc clean</code> - Cleans all output artifacts for each member of the workspace.</li>
<li><code>forc fmt</code> - Formats all members of a workspace.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="dependencies"><a class="header" href="#dependencies">Dependencies</a></h1>
<p>Forc has a dependency management system which can pull packages using git and <code>ipfs</code>. This allows users to build and share Forc libraries.</p>
<h2 id="adding-a-dependency"><a class="header" href="#adding-a-dependency">Adding a dependency</a></h2>
<p>If your <code>Forc.toml</code> doesn't already have a <code>[dependencies]</code> table, add one. Below, list the package name alongside its source. Currently, <code>forc</code> supports <code>git</code>, <code>ipfs</code> and <code>path</code> sources.</p>
<p>If a <code>git</code> source is specified, <code>forc</code> will fetch the git repository at the given URL and then search for a <code>Forc.toml</code> for a package with the given name anywhere inside the git repository.</p>
<p>The following example adds a library dependency named <code>custom_lib</code>. For git dependencies you may optionally specify a <code>branch</code>, <code>tag</code>, or <code>rev</code> (i.e. commit hash) reference.</p>
<pre><code class="language-toml">[dependencies]
custom_lib = { git = &quot;https://github.com/FuelLabs/custom_lib&quot;, branch = &quot;master&quot; }
# custom_lib = { git = &quot;https://github.com/FuelLabs/custom_lib&quot;, tag = &quot;v0.0.1&quot; }
# custom_lib = { git = &quot;https://github.com/FuelLabs/custom_lib&quot;, rev = &quot;87f80bdf323e2d64e213895d0a639ad468f4deff&quot; }
</code></pre>
<p>Depending on a local library using <code>path</code>:</p>
<pre><code class="language-toml">[dependencies]
custom_lib = { path = &quot;../custom_lib&quot; }
</code></pre>
<p>For <code>ipfs</code> sources, <code>forc</code> will fetch the specified <code>cid</code> using either a local <code>ipfs</code> node or a public gateway. <code>forc</code> automatically tries to connect to local <code>ipfs</code> node. If it fails, it defaults to using <code>https://ipfs.io/</code> as a gateway.</p>
<p>The following example adds a dependency with an <code>ipfs</code> source.</p>
<pre><code class="language-toml">[dependencies]
custom_lib = { ipfs = &quot;QmYwAPJzv5CZsnA625s3Xf2nemtYgPpHdWEz79ojWnPbdG&quot; }
</code></pre>
<p>Once the package is added, running <code>forc build</code> will automatically download added dependencies.</p>
<h2 id="updating-dependencies"><a class="header" href="#updating-dependencies">Updating dependencies</a></h2>
<p>To update dependencies in your Forc directory you can run <code>forc update</code>. For <code>path</code> and <code>ipfs</code> dependencies this will have no effect. For <code>git</code> dependencies with a <code>branch</code> reference, this will update the project to use the latest commit for the given branch.</p>
<div style="break-before: page; page-break-before: always;"></div><!-- markdownlint-disable MD041 -->
<p>Here are a list of commands available to forc:</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="forc-addr2line"><a class="header" href="#forc-addr2line"><code>forc addr2line</code></a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="forc-build"><a class="header" href="#forc-build"><code>forc build</code></a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="forc-check"><a class="header" href="#forc-check"><code>forc check</code></a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="forc-clean"><a class="header" href="#forc-clean"><code>forc clean</code></a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="forc-completions"><a class="header" href="#forc-completions"><code>forc completions</code></a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="forc-contract-id"><a class="header" href="#forc-contract-id"><code>forc contract-id</code></a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="forc-init"><a class="header" href="#forc-init"><code>forc init</code></a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="forc-new"><a class="header" href="#forc-new"><code>forc new</code></a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="forc-parse-bytecode"><a class="header" href="#forc-parse-bytecode"><code>forc parse-bytecode</code></a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="forc-plugins"><a class="header" href="#forc-plugins"><code>forc plugins</code></a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="forc-predicate-root"><a class="header" href="#forc-predicate-root"><code>forc predicate-root</code></a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="forc-test"><a class="header" href="#forc-test"><code>forc test</code></a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="forc-update"><a class="header" href="#forc-update"><code>forc update</code></a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="forc-template"><a class="header" href="#forc-template"><code>forc template</code></a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="plugins"><a class="header" href="#plugins">Plugins</a></h1>
<p>Plugins can be used to extend <code>forc</code> with new commands that go beyond the native commands mentioned in the previous chapter. While the Fuel ecosystem provides a few commonly useful plugins (<code>forc-fmt</code>, <code>forc-client</code>, <code>forc-lsp</code>, <code>forc-explore</code>), anyone can write their own!</p>
<p>Let's install a plugin, <code>forc-explore</code>, and see what's underneath the plugin:</p>
<pre><code class="language-sh">cargo install forc-explore
</code></pre>
<p>Check that we have installed <code>forc-explore</code>:</p>
<pre><code class="language-console">$ forc plugins
Installed Plugins:
forc-explore
</code></pre>
<p><code>forc-explore</code> runs the Fuel Network Explorer, which you can run and check out for yourself:</p>
<pre><code class="language-console">$ forc explore
Fuel Network Explorer 0.1.1
Running server on http://127.0.0.1:3030
Server::run{addr=127.0.0.1:3030}: listening on http://127.0.0.1:3030
</code></pre>
<p>You can visit <a href="http://127.0.0.1:3030">http://127.0.0.1:3030</a> to check out the network explorer!</p>
<p>Note that some plugin crates can also provide more than one command. For example, installing the <code>forc-client</code> plugin provides the <code>forc deploy</code> and <code>forc run</code> commands. This is achieved by specifying multiple <code>[[bin]]</code> targets within the <code>forc-client</code> manifest.</p>
<h2 id="writing-your-own-plugin"><a class="header" href="#writing-your-own-plugin">Writing your own plugin</a></h2>
<p>We encourage anyone to write and publish their own <code>forc</code> plugin to enhance their development experience.</p>
<p>Your plugin must be named in the format <code>forc-&lt;MY_PLUGIN&gt;</code> and you may use the above template as a starting point. You can use <a href="https://docs.rs/clap/latest/clap/">clap</a> and add more subcommands, options and configurations to suit your plugin's needs.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="forc-client"><a class="header" href="#forc-client"><code>forc-client</code></a></h1>
<p>Forc plugin for interacting with a Fuel node.</p>
<h2 id="initializing-the-wallet-and-adding-accounts"><a class="header" href="#initializing-the-wallet-and-adding-accounts">Initializing the wallet and adding accounts</a></h2>
<p>If you don't have an initialized wallet or any account for your wallet you won't be able to sign transactions.</p>
<p>To create a wallet you can use <code>forc wallet new</code>. It will ask you to choose a password to encrypt your wallet. After the initialization is done you will have your mnemonic phrase.</p>
<p>After you have created a wallet, you can derive a new account by running <code>forc wallet account new</code>. It will ask your password to decrypt the wallet before deriving an account.</p>
<h2 id="signing-transactions-using-forc-wallet-cli"><a class="header" href="#signing-transactions-using-forc-wallet-cli">Signing transactions using <code>forc-wallet</code> CLI</a></h2>
<p>To submit the transactions created by <code>forc deploy</code> or <code>forc run</code>, you need to sign them first (unless you are using a client without UTXO validation). To sign a transaction you can use <code>forc-wallet</code> CLI. This section is going to walk you through the whole signing process.</p>
<p>By default <code>fuel-core</code> runs without UTXO validation, this allows you to send invalid inputs to emulate different conditions.</p>
<p>If you want to run <code>fuel-core</code> with UTXO validation, you can pass <code>--utxo-validation</code> to <code>fuel-core run</code>.</p>
<p>To install <code>forc-wallet</code> please refer to <code>forc-wallet</code>'s <a href="https://github.com/FuelLabs/forc-wallet#forc-wallet">GitHub repo</a>.</p>
<ol>
<li>Construct the transaction by using either <code>forc deploy</code> or <code>forc run</code>. To do so simply run <code>forc deploy</code> or <code>forc run</code> with your desired parameters. For a list of parameters please refer to the <a href="forc/plugins/forc_client/./forc_deploy.html">forc-deploy</a> or <a href="forc/plugins/forc_client/./forc_run.html">forc-run</a> section of the book. Once you run either command you will be asked the address of the wallet you are going to be signing with. After the address is given the transaction will be generated and you will be given a transaction ID. At this point CLI will actively wait for you to insert the signature.</li>
<li>Take the transaction ID generated in the first step and sign it with <code>forc wallet sign --account &lt;account_index&gt; tx-id &lt;transaction_id&gt;</code>. This will generate a signature.</li>
<li>Take the signature generated in the second step and provide it to <code>forc-deploy</code> (or <code>forc-run</code>). Once the signature is provided, the signed transaction will be submitted.</li>
</ol>
<h2 id="other-useful-commands-of-forc-wallet"><a class="header" href="#other-useful-commands-of-forc-wallet">Other useful commands of <code>forc-wallet</code></a></h2>
<ul>
<li>You can see a list of existing accounts with <code>accounts</code> command.</li>
</ul>
<pre><code class="language-sh">forc wallet accounts
</code></pre>
<ul>
<li>If you want to retrieve the address for an account by its index you can use <code>account</code> command.</li>
</ul>
<pre><code class="language-sh">forc wallet account &lt;account_index&gt;
</code></pre>
<blockquote>
<p>If you want to sign the transaction generated by <code>forc-deploy</code> or <code>forc-run</code> with an account funded by default once you start your local node, you can pass <code>--default-signer</code> to them. Please note that this will only work against your local node.</p>
<pre><code class="language-sh">forc-deploy --default-signer
</code></pre>
<pre><code class="language-sh">forc-run --default-signer
</code></pre>
</blockquote>
<p>By default <code>--default-signer</code> flag would sign your transactions with the following private-key:</p>
<pre><code class="language-sh">0xde97d8624a438121b86a1956544bd72ed68cd69f2c99555b08b1e8c51ffd511c
</code></pre>
<h2 id="interacting-with-the-testnet"><a class="header" href="#interacting-with-the-testnet">Interacting with the testnet</a></h2>
<p>To interact with the latest testnet, use the <code>--testnet</code> flag. When this flag is passed, transactions created by <code>forc-deploy</code> will be sent to the <code>beta-4</code> testnet.</p>
<pre><code class="language-sh">forc-deploy --testnet
</code></pre>
<p>It is also possible to pass the exact node URL while using <code>forc-deploy</code> or <code>forc-run</code> which can be done using <code>--node-url</code> flag.</p>
<pre><code class="language-sh">forc-deploy --node-url https://beta-3.fuel.network
</code></pre>
<p>Another alternative is the <code>--target</code> option, which provides useful aliases to all targets. For example if you want to deploy to <code>beta-3</code> you can use:</p>
<pre><code class="language-sh">forc-deploy --target beta-3
</code></pre>
<p>Since deploying and running projects on the testnet cost gas, you will need coins to pay for them. You can get some using the <a href="https://faucet-testnet.fuel.network/">testnet faucet</a>.</p>
<h2 id="deployment-artifacts"><a class="header" href="#deployment-artifacts">Deployment Artifacts</a></h2>
<p>forc-deploy saves the details of each deployment in the <code>out/deployments</code> folder within the project's root directory. Below is an example of a deployment artifact:</p>
<pre><code class="language-json">{
  &quot;transaction_id&quot;: &quot;0xec27bb7a4c8a3b8af98070666cf4e6ea22ca4b9950a0862334a1830520012f5d&quot;,
  &quot;salt&quot;: &quot;0x9e35d1d5ef5724f29e649a3465033f5397d3ebb973c40a1d76bb35c253f0dec7&quot;,
  &quot;network_endpoint&quot;: &quot;http://127.0.0.1:4000&quot;,
  &quot;chain_id&quot;: 0,
  &quot;contract_id&quot;: &quot;0x767eeaa7af2621e637f9785552620e175d4422b17d4cf0d76335c38808608a7b&quot;,
  &quot;deployment_size&quot;: 68,
  &quot;deployed_block_id&quot;: &quot;0x915c6f372252be6bc54bd70df6362dae9bf750ba652bf5582d9b31c7023ca6cf&quot;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="forc-deploy"><a class="header" href="#forc-deploy"><code>forc deploy</code></a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="forc-run"><a class="header" href="#forc-run"><code>forc run</code></a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="forc-submit"><a class="header" href="#forc-submit"><code>forc submit</code></a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="forc-crypto"><a class="header" href="#forc-crypto"><code>forc crypto</code></a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="forc-debug"><a class="header" href="#forc-debug">forc debug</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="forc-doc"><a class="header" href="#forc-doc"><code>forc doc</code></a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="forc-explore"><a class="header" href="#forc-explore"><code>forc explore</code></a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="forc-fmt"><a class="header" href="#forc-fmt"><code>forc fmt</code></a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="forc-lsp"><a class="header" href="#forc-lsp"><code>forc lsp</code></a></h1>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </body>
</html>
