<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>The Sway Programming Language</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="index.html">The Sway Programming Language</a></li><li class="chapter-item expanded "><a href="introduction/index.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="introduction/installation.html"><strong aria-hidden="true">1.1.</strong> Installation</a></li><li class="chapter-item expanded "><a href="introduction/overview.html"><strong aria-hidden="true">1.2.</strong> Getting Started</a></li><li class="chapter-item expanded "><a href="introduction/fuel-toolchain.html"><strong aria-hidden="true">1.3.</strong> The Fuel Toolchain</a></li><li class="chapter-item expanded "><a href="introduction/forc_project.html"><strong aria-hidden="true">1.4.</strong> A Forc Project</a></li><li class="chapter-item expanded "><a href="introduction/standard_library.html"><strong aria-hidden="true">1.5.</strong> Standard Library</a></li></ol></li><li class="chapter-item expanded "><a href="examples/index.html"><strong aria-hidden="true">2.</strong> Examples</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="examples/counter.html"><strong aria-hidden="true">2.1.</strong> Counter</a></li><li class="chapter-item expanded "><a href="examples/subcurrency.html"><strong aria-hidden="true">2.2.</strong> Subcurrency</a></li><li class="chapter-item expanded "><a href="examples/fizzbuzz.html"><strong aria-hidden="true">2.3.</strong> FizzBuzz</a></li><li class="chapter-item expanded "><a href="examples/wallet_smart_contract.html"><strong aria-hidden="true">2.4.</strong> Wallet Smart Contract</a></li></ol></li><li class="chapter-item expanded "><a href="sway-program-types/index.html"><strong aria-hidden="true">3.</strong> Program Types</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="sway-program-types/smart_contracts.html"><strong aria-hidden="true">3.1.</strong> Contracts</a></li><li class="chapter-item expanded "><a href="sway-program-types/libraries.html"><strong aria-hidden="true">3.2.</strong> Libraries</a></li><li class="chapter-item expanded "><a href="sway-program-types/scripts.html"><strong aria-hidden="true">3.3.</strong> Scripts</a></li><li class="chapter-item expanded "><a href="sway-program-types/predicates.html"><strong aria-hidden="true">3.4.</strong> Predicates</a></li></ol></li><li class="chapter-item expanded "><a href="basics/index.html"><strong aria-hidden="true">4.</strong> Sway Language Basics</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="basics/variables.html"><strong aria-hidden="true">4.1.</strong> Variables</a></li><li class="chapter-item expanded "><a href="basics/built_in_types.html"><strong aria-hidden="true">4.2.</strong> Built-in Types</a></li><li class="chapter-item expanded "><a href="basics/blockchain_types.html"><strong aria-hidden="true">4.3.</strong> Blockchain Types</a></li><li class="chapter-item expanded "><a href="basics/functions.html"><strong aria-hidden="true">4.4.</strong> Functions</a></li><li class="chapter-item expanded "><a href="basics/structs_tuples_and_enums.html"><strong aria-hidden="true">4.5.</strong> Structs, Tuples, and Enums</a></li><li class="chapter-item expanded "><a href="basics/methods_and_associated_functions.html"><strong aria-hidden="true">4.6.</strong> Methods and Associated Functions</a></li><li class="chapter-item expanded "><a href="basics/comments_and_logging.html"><strong aria-hidden="true">4.7.</strong> Comments and Logging</a></li><li class="chapter-item expanded "><a href="basics/control_flow.html"><strong aria-hidden="true">4.8.</strong> Control Flow</a></li></ol></li><li class="chapter-item expanded "><a href="blockchain-development/index.html"><strong aria-hidden="true">5.</strong> Blockchain Development with Sway</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="blockchain-development/hashing_and_cryptography.html"><strong aria-hidden="true">5.1.</strong> Hashing and Cryptography</a></li><li class="chapter-item expanded "><a href="blockchain-development/storage.html"><strong aria-hidden="true">5.2.</strong> Contract Storage</a></li><li class="chapter-item expanded "><a href="blockchain-development/purity.html"><strong aria-hidden="true">5.3.</strong> Function Purity</a></li><li class="chapter-item expanded "><a href="blockchain-development/identifiers.html"><strong aria-hidden="true">5.4.</strong> Identifiers</a></li><li class="chapter-item expanded "><a href="blockchain-development/native_assets.html"><strong aria-hidden="true">5.5.</strong> Native Assets</a></li><li class="chapter-item expanded "><a href="blockchain-development/access_control.html"><strong aria-hidden="true">5.6.</strong> Access Control</a></li><li class="chapter-item expanded "><a href="blockchain-development/calling_contracts.html"><strong aria-hidden="true">5.7.</strong> Calling Contracts</a></li></ol></li><li class="chapter-item expanded "><a href="advanced/index.html"><strong aria-hidden="true">6.</strong> Advanced Concepts</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="advanced/generic_types.html"><strong aria-hidden="true">6.1.</strong> Generic Types</a></li><li class="chapter-item expanded "><a href="advanced/traits.html"><strong aria-hidden="true">6.2.</strong> Traits</a></li><li class="chapter-item expanded "><a href="advanced/assembly.html"><strong aria-hidden="true">6.3.</strong> Assembly</a></li></ol></li><li class="chapter-item expanded "><a href="common-collections/index.html"><strong aria-hidden="true">7.</strong> Common Collections</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="common-collections/vec.html"><strong aria-hidden="true">7.1.</strong> Vectors on the Heap</a></li><li class="chapter-item expanded "><a href="common-collections/storage_vec.html"><strong aria-hidden="true">7.2.</strong> Storage Vectors</a></li><li class="chapter-item expanded "><a href="common-collections/storage_map.html"><strong aria-hidden="true">7.3.</strong> Storage Maps</a></li></ol></li><li class="chapter-item expanded "><a href="testing/index.html"><strong aria-hidden="true">8.</strong> Testing</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="testing/testing-with-rust.html"><strong aria-hidden="true">8.1.</strong> Testing with Rust</a></li></ol></li><li class="chapter-item expanded "><a href="frontend/index.html"><strong aria-hidden="true">9.</strong> Application Frontend</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="frontend/typescript_sdk.html"><strong aria-hidden="true">9.1.</strong> TypeScript SDK</a></li></ol></li><li class="chapter-item expanded "><a href="reference/index.html"><strong aria-hidden="true">10.</strong> Sway Reference</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="reference/style_guide.html"><strong aria-hidden="true">10.1.</strong> Style Guide</a></li><li class="chapter-item expanded "><a href="reference/known_issues_and_workarounds.html"><strong aria-hidden="true">10.2.</strong> Known Issues and Workarounds</a></li><li class="chapter-item expanded "><a href="reference/solidity_differences.html"><strong aria-hidden="true">10.3.</strong> Differences From Solidity</a></li><li class="chapter-item expanded "><a href="reference/rust_differences.html"><strong aria-hidden="true">10.4.</strong> Differences From Rust</a></li><li class="chapter-item expanded "><a href="reference/contributing_to_sway.html"><strong aria-hidden="true">10.5.</strong> Contributing To Sway</a></li></ol></li><li class="chapter-item expanded "><a href="forc/index.html"><strong aria-hidden="true">11.</strong> Forc Reference</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="forc/manifest_reference.html"><strong aria-hidden="true">11.1.</strong> Manifest Reference</a></li><li class="chapter-item expanded "><a href="forc/dependencies.html"><strong aria-hidden="true">11.2.</strong> Dependencies</a></li><li class="chapter-item expanded "><a href="forc/commands/index.html"><strong aria-hidden="true">11.3.</strong> Commands</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="forc/commands/forc_addr2line.html"><strong aria-hidden="true">11.3.1.</strong> forc addr2line</a></li><li class="chapter-item expanded "><a href="forc/commands/forc_build.html"><strong aria-hidden="true">11.3.2.</strong> forc build</a></li><li class="chapter-item expanded "><a href="forc/commands/forc_check.html"><strong aria-hidden="true">11.3.3.</strong> forc check</a></li><li class="chapter-item expanded "><a href="forc/commands/forc_clean.html"><strong aria-hidden="true">11.3.4.</strong> forc clean</a></li><li class="chapter-item expanded "><a href="forc/commands/forc_completions.html"><strong aria-hidden="true">11.3.5.</strong> forc completions</a></li><li class="chapter-item expanded "><a href="forc/commands/forc_init.html"><strong aria-hidden="true">11.3.6.</strong> forc init</a></li><li class="chapter-item expanded "><a href="forc/commands/forc_new.html"><strong aria-hidden="true">11.3.7.</strong> forc new</a></li><li class="chapter-item expanded "><a href="forc/commands/forc_parse-bytecode.html"><strong aria-hidden="true">11.3.8.</strong> forc parse-bytecode</a></li><li class="chapter-item expanded "><a href="forc/commands/forc_plugins.html"><strong aria-hidden="true">11.3.9.</strong> forc plugins</a></li><li class="chapter-item expanded "><a href="forc/commands/forc_test.html"><strong aria-hidden="true">11.3.10.</strong> forc test</a></li><li class="chapter-item expanded "><a href="forc/commands/forc_update.html"><strong aria-hidden="true">11.3.11.</strong> forc update</a></li><li class="chapter-item expanded "><a href="forc/commands/forc_template.html"><strong aria-hidden="true">11.3.12.</strong> forc template</a></li></ol></li><li class="chapter-item expanded "><a href="forc/plugins.html"><strong aria-hidden="true">11.4.</strong> Plugins</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="forc_client.html"><strong aria-hidden="true">11.4.1.</strong> forc client</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="forc_deploy.html"><strong aria-hidden="true">11.4.1.1.</strong> forc deploy</a></li><li class="chapter-item expanded "><a href="forc_run.html"><strong aria-hidden="true">11.4.1.2.</strong> forc run</a></li></ol></li><li class="chapter-item expanded "><a href="forc_explore.html"><strong aria-hidden="true">11.4.2.</strong> forc explore</a></li><li class="chapter-item expanded "><a href="forc_fmt.html"><strong aria-hidden="true">11.4.3.</strong> forc fmt</a></li><li class="chapter-item expanded "><a href="forc_lsp.html"><strong aria-hidden="true">11.4.4.</strong> forc lsp</a></li></ol></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Sway Programming Language</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/FuelLabs/sway" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="the-sway-programming-language"><a class="header" href="#the-sway-programming-language">The Sway Programming Language</a></h1>
<p>Sway is a domain-specific language (DSL) for the <a href="https://github.com/FuelLabs/fuel-specs">Fuel Virtual Machine (FuelVM)</a>, a blockchain-optimized VM designed for the Fuel blockchain. Sway is based on <a href="https://doc.rust-lang.org/book/">Rust</a>, and includes syntax to leverage a blockchain VM without needlessly verbose boilerplate.</p>
<p>This book documents how to write smart contracts in Sway, along with how to install and use the Sway toolchain.</p>
<p>Before starting developing smart contracts in Sway, please keep in mind the <a href="./reference/known_issues_and_workarounds.html">known issues and workarounds</a> of the language and toolchain.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p>To get started with Forc and Sway smart contract development, install the Fuel toolchain and Fuel full node and set up your first project.</p>
<ul>
<li><a href="introduction/./installation.html">Installation</a></li>
<li><a href="introduction/./overview.html">Getting Started</a></li>
<li><a href="introduction/./fuel-toolchain.html">The Fuel Toolchain</a></li>
<li><a href="introduction/./forc_project.html">A Forc Project</a></li>
<li><a href="introduction/./standard_library.html">Standard Library</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="installation"><a class="header" href="#installation">Installation</a></h1>
<p>The <em>Sway toolchain</em> is sufficient to compile Sway smart contracts. Otherwise, note that if you want to run Sway smart contracts (e.g. for testing), a Fuel Core full node is required, which is packaged together with the <em>Sway toolchain</em> together as the <em>Fuel toolchain</em>.</p>
<h2 id="installing-from-pre-compiled-binaries"><a class="header" href="#installing-from-pre-compiled-binaries">Installing from Pre-compiled Binaries</a></h2>
<p>Pre-compiled release binaries for Linux and macOS are available for the Sway toolchain. Native Windows is currently unsupported (<a href="https://github.com/FuelLabs/sway/issues/1526">tracking issue for Windows support</a>). Windows Subsystem for Linux should work but is not officially supported.</p>
<p><a href="https://github.com/FuelLabs/fuelup"><code>fuelup</code></a> is the equivalent of Rust's <code>rustup</code> for the Fuel toolchain. It enables easily downloading binary releases of the Fuel toolchain.</p>
<p>Start by installing <code>fuelup</code> with:</p>
<pre><code class="language-sh">curl --proto '=https' --tlsv1.2 -sSf \
    https://fuellabs.github.io/fuelup/fuelup-init.sh | sh
</code></pre>
<p><code>fuelup-init</code> will ask for permission to add <code>~/.fuelup/bin</code> to your PATH. Otherwise, you can also pass <code>--no-modify-path</code> so that <code>fuelup-init</code> does not modify your PATH:</p>
<pre><code class="language-sh">curl --proto '=https' --tlsv1.2 -sSf \
    https://fuellabs.github.io/fuelup/fuelup-init.sh | sh -s -- --no-modify-path
</code></pre>
<p>Once <code>fuelup</code> is installed, <code>fuelup-init</code> automatically runs the command below</p>
<pre><code class="language-sh">fuelup toolchain install latest
</code></pre>
<p>to install the latest Fuel toolchain.</p>
<p>You can run the same command at a later time to update the toolchain.</p>
<h2 id="installing-from-source"><a class="header" href="#installing-from-source">Installing from Source</a></h2>
<h3 id="dependencies"><a class="header" href="#dependencies">Dependencies</a></h3>
<p>A prerequisite for installing and using Sway is the Rust toolchain. Platform-specific instructions for installing <code>rustup</code> can be found <a href="https://www.rust-lang.org/tools/install">here</a>. Then, install the Rust toolchain with:</p>
<pre><code class="language-sh"># Install the latest stable Rust toolchain.
rustup install stable
</code></pre>
<p>Installing <code>fuel-core</code> may require installing additional system dependencies. See <a href="https://github.com/FuelLabs/fuel-core#building">here</a> for instructions.</p>
<p>The Sway toolchain is built and tested against the <code>stable</code> Rust toolchain version (<a href="https://github.com/rust-lang/rust/releases/latest">https://github.com/rust-lang/rust/releases/latest</a>). There is no guarantee it will work with the <code>nightly</code> Rust toolchain, or with earlier <code>stable</code> versions, so ensure you are using <code>stable</code> with:</p>
<pre><code class="language-sh"># Update installed Rust toolchain; can be used independently.
rustup update
# Set the stable Rust toolchain as default; can be used independently.
rustup default stable
</code></pre>
<h3 id="installing-from-cargo"><a class="header" href="#installing-from-cargo">Installing from Cargo</a></h3>
<p>The Sway toolchain and Fuel Core full node can be installed from source with Cargo with:</p>
<pre><code class="language-sh">cargo install forc fuel-core
</code></pre>
<h4 id="updating-forc-from-cargo"><a class="header" href="#updating-forc-from-cargo">Updating <code>forc</code> from Cargo</a></h4>
<p>You can update the toolchain from source with Cargo with:</p>
<pre><code class="language-sh">cargo install forc fuel-core
</code></pre>
<h4 id="installing-forc-plugins-from-cargo"><a class="header" href="#installing-forc-plugins-from-cargo">Installing <code>forc</code> Plugins from Cargo</a></h4>
<p>The Fuel ecosystem has a few plugins which can be easily installed via Cargo.</p>
<blockquote>
<p><strong>Note</strong>: <code>forc</code> detects anything in your <code>$PATH</code> prefixed with <code>forc-</code> as a plugin. Use <code>forc plugins</code> to see what you currently have installed.</p>
</blockquote>
<pre><code class="language-sh"># Sway Formatter
cargo install forc-fmt

# Block Explorer
cargo install forc-explore

# Sway Language Server
cargo install forc-lsp
</code></pre>
<h3 id="building-from-source"><a class="header" href="#building-from-source">Building from Source</a></h3>
<p>Rather than installing from <code>cargo</code>, the Sway toolchain can be built from a local source checkout by following instructions at <a href="https://github.com/FuelLabs/sway">https://github.com/FuelLabs/sway</a>. The Fuel Core full node implementation can be built from source by following instructions at <a href="https://github.com/FuelLabs/fuel-core">https://github.com/FuelLabs/fuel-core</a>.</p>
<h2 id="enable-tab-completion-for-bash-fish-zsh-or-powershell"><a class="header" href="#enable-tab-completion-for-bash-fish-zsh-or-powershell">Enable tab completion for Bash, Fish, Zsh, or PowerShell</a></h2>
<p><code>forc</code> supports generating completion scripts for Bash, Fish, Zsh, and PowerShell. See <code>forc completions --help</code> for full details, but the gist is as simple as using one of the following:</p>
<pre><code class="language-sh"># Bash
forc completions --shell=bash &gt; ~/.local/share/bash-completion/completions/forc

# Bash (macOS/Homebrew)
forc completions --shell=bash &gt; $(brew --prefix)/etc/bash_completion.d/forc.bash-completion

# Fish
mkdir -p ~/.config/fish/completions
forc completions --shell=fish &gt; ~/.config/fish/completions/forc.fish

# Zsh
forc completions --shell=zsh &gt; ~/.zfunc/_forc

# PowerShell v5.0+
forc completions --shell=powershell &gt;&gt; $PROFILE.CurrentUserCurrentHost
# or
forc completions --shell=powershell | Out-String | Invoke-Expression
</code></pre>
<p>Once the completions have been generated and properly installed, close and reopen your terminal for the new completions to take effect.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="getting-started"><a class="header" href="#getting-started">Getting Started</a></h1>
<p>Follow this guide to write, test, and deploy a simple smart contract in Sway.</p>
<h2 id="glossary"><a class="header" href="#glossary">Glossary</a></h2>
<p>Before we begin, it may be helpful to understand terminology that will used throughout the docs and how they relate to each other:</p>
<ul>
<li><strong>Fuel</strong>: the Fuel blockchain.</li>
<li><strong>FuelVM</strong>: the virtual machine powering Fuel.</li>
<li><strong>Sway</strong>: the domain-specific language crafted for the FuelVM; it is inspired by Rust.</li>
<li><strong>Forc</strong>: the build system and package manager for Sway, similar to Cargo for Rust.</li>
</ul>
<h2 id="understand-sway-program-types"><a class="header" href="#understand-sway-program-types">Understand Sway Program Types</a></h2>
<p>There are four types of Sway programs:</p>
<ul>
<li><code>contract</code></li>
<li><code>predicate</code></li>
<li><code>script</code></li>
<li><code>library</code></li>
</ul>
<p>Contracts, predicates, and scripts can produce artifacts usable on the blockchain, while a library is simply a project designed for code reuse and is not directly deployable.</p>
<p>See <a href="introduction/../sway-program-types/index.html">the chapter on program types</a> for more information.</p>
<h2 id="your-first-sway-project"><a class="header" href="#your-first-sway-project">Your First Sway Project</a></h2>
<p>We'll build a simple counter contract with two functions: one to increment the counter, and one to return the value of the counter.</p>
<p>A few pieces of info that will be helpful before moving on:</p>
<ul>
<li>The main features of a smart contract that differentiate it from scripts or predicates are that it is callable and stateful.</li>
<li>A script is runnable bytecode on the chain which can call contracts to perform some task. It does not represent ownership of any resources and it cannot be called by a contract.</li>
</ul>
<h3 id="writing-the-contract"><a class="header" href="#writing-the-contract">Writing the Contract</a></h3>
<p>First, let's <a href="introduction/./installation.html">install the Sway toolchain</a>. Then with <code>forc</code> installed, create a contract project:</p>
<pre><code class="language-sh">forc new counter_contract
</code></pre>
<p>Here is the project that Forc has initialized:</p>
<pre><code class="language-console">$ cd counter_contract
$ tree .
â”œâ”€â”€ Cargo.toml
â”œâ”€â”€ Forc.toml
â”œâ”€â”€ src
â”‚Â Â  â””â”€â”€ main.sw
â””â”€â”€ tests
    â””â”€â”€ harness.rs
</code></pre>
<p><code>Forc.toml</code> is the <em>manifest file</em> (similar to <code>Cargo.toml</code> for Cargo or <code>package.json</code> for Node), and defines project metadata such as the project name and dependencies.</p>
<p>We'll be writing our code in the <code>src/main.sw</code>.</p>
<p><code>cd</code> (change directories) into your contract project and delete the boilerplate code in <code>src/main.sw</code>. Every Sway file must start with a declaration of what type of program the file contains; here, we've declared that this file is a contract.</p>
<pre><code class="language-sway">contract;
</code></pre>
<p>Next, we'll define a storage value. In our case, we have a single counter that we'll call <code>counter</code> of type 64-bit unsigned integer and initialize it to 0.</p>
<pre><code class="language-sway">storage {
    counter: u64 = 0,
}
</code></pre>
<h3 id="abi"><a class="header" href="#abi">ABI</a></h3>
<p>An ABI defines an interface, and there is no function body in the ABI. A contract must either define or import an ABI declaration and implement it. It is considered best practice to define your ABI in a separate library and import it into your contract because this allows callers of the contract to import and use the ABI in scripts to call your contract.</p>
<p>For simplicity, we will define the ABI natively in the contract.</p>
<pre><code class="language-sway">abi Counter {
    #[storage(read, write)]
    fn increment();

    #[storage(read)]
    fn counter() -&gt; u64;
}
</code></pre>
<h3 id="going-line-by-line"><a class="header" href="#going-line-by-line">Going line by line</a></h3>
<p><code>#[storage(read, write)]</code> is an annotation which denotes that this function has permission to read and write a value in storage.</p>
<p><code>fn increment()</code> - We're introducing the functionality to increment and denoting it shouldn't return any value.</p>
<p><code>#[storage(read)]</code> is an annotation which denotes that this function has permission to read values in storage.</p>
<p><code>fn counter() -&gt; u64;</code> - We're introducing the functionality to increment the counter and denoting the function's return value.</p>
<h3 id="implement-abi"><a class="header" href="#implement-abi">Implement ABI</a></h3>
<p>Below your ABI definition, you will write the implementation of the functions defined in your ABI.</p>
<pre><code class="language-sway">impl Counter for Contract {
    #[storage(read)]
    fn counter() -&gt; u64 {
      return storage.counter;
    }
    #[storage(read, write)]
    fn increment() {
        storage.counter = storage.counter + 1;
    }
}
</code></pre>
<blockquote>
<p><strong>Note</strong>
<code>return storage.counter;</code> is equivalent to <code>storage.counter</code>.</p>
</blockquote>
<h3 id="what-we-just-did"><a class="header" href="#what-we-just-did">What we just did</a></h3>
<p>Read and return the counter property value from the contract storage.</p>
<pre><code class="language-sway">fn counter() -&gt; u64 {
    return storage.counter;
}
</code></pre>
<p>The function body accesses the value counter in storage, and increments the value by one. Then, we return the newly updated value of counter.</p>
<pre><code class="language-sway">fn increment() {
    storage.counter = storage.counter + 1;
}
</code></pre>
<h3 id="build-the-contract"><a class="header" href="#build-the-contract">Build the Contract</a></h3>
<p>Build <code>counter_contract</code> by running the following command in your terminal from inside the <code>counter_contract</code> directory:</p>
<pre><code class="language-sh">forc build
</code></pre>
<p>You should see something like this output:</p>
<pre><code class="language-console">Compiled library &quot;core&quot;.
  Compiled library &quot;std&quot;.
  Compiled contract &quot;counter_contract&quot;.
  Bytecode size is 224 bytes.
</code></pre>
<h3 id="deploy-the-contract"><a class="header" href="#deploy-the-contract">Deploy the Contract</a></h3>
<p>It's now time to deploy the contract and call it on a Fuel node. We will show how to do this using <code>forc</code> from the command line, but you can also do it using the <a href="https://fuellabs.github.io/fuels-rs/master/getting-started/contracts.html">Rust SDK</a> or the <a href="https://fuellabs.github.io/fuels-ts/#deploying-contracts">TypeScript SDK</a></p>
<h3 id="spin-up-a-fuel-node"><a class="header" href="#spin-up-a-fuel-node">Spin Up a Fuel node</a></h3>
<p>In a separate tab in your terminal, spin up a local Fuel node:</p>
<pre><code class="language-sh">fuel-core run --db-type in-memory
</code></pre>
<p>This starts a Fuel node with a volatile database that will be cleared when shut down (good for testing purposes).</p>
<h3 id="deploy-counter_contract-to-your-local-fuel-node"><a class="header" href="#deploy-counter_contract-to-your-local-fuel-node">Deploy <code>counter_contract</code> To Your Local Fuel Node</a></h3>
<p>To deploy <code>counter_contract</code> on your local Fuel node, open a new terminal tab and run the following command from the root of the <code>wallet_contract</code> directory:</p>
<pre><code class="language-sh">forc deploy --unsigned
</code></pre>
<blockquote>
<p><strong>Note</strong>
You can't use the same terminal session that is running fuel-core to run any other commands as this will end your fuel-core process.</p>
</blockquote>
<p>This should produce some output in <code>stdout</code> that looks like this:</p>
<pre><code class="language-console">$ forc deploy --unsigned
  Compiled library &quot;core&quot;.
  Compiled library &quot;std&quot;.
  Compiled contract &quot;counter_contract&quot;.
  Bytecode size is 224 bytes.
Contract id: 0xaf94c0a707756caae667ee43ca18bace441b25998c668010192444a19674dc4f
Logs:
TransactionId(HexFormatted(7cef24ea33513733ab78c5daa5328d622d4b38187d0f0d1857b272090d99f96a))
</code></pre>
<p>Note the contract IDâ€”you will need it if you want to build out a frontend to interact with this contract.</p>
<h2 id="testing-your-contract"><a class="header" href="#testing-your-contract">Testing your Contract</a></h2>
<p>In the directory <code>tests</code>, navigate to <code>harness.rs.</code> Here you'll see there is some boilerplate code to help you start interacting with and testing your contract.</p>
<p>At the bottom of the file, define the body of <code>can_get_contract_instance</code>. Here is what your code should look like to verify that the value of the counter did get incremented:</p>
<pre><code class="language-sway">#[tokio::test]
async fn can_get_contract_instance() {
    // Increment the counter
    let _result = instance.increment().call().await.unwrap();

    // Get the current value of the counter
    let result = instance.counter().call().await.unwrap();
    assert!(result.value &gt; 0);
}
</code></pre>
<p>Run the following command in the terminal: <code>forc test</code>.</p>
<p>You'll see something like this as your output:</p>
<pre><code class="language-console">  Compiled library &quot;core&quot;.
  Compiled library &quot;std&quot;.
  Compiled contract &quot;counter_contract&quot;.
  Bytecode size is 224 bytes.
   Compiling counter_contract v0.1.0 (&lt;path/to/counter_contract&gt;)
    Finished test [unoptimized + debuginfo] target(s) in 4.55s
     Running tests/harness.rs (target/debug/deps/integration_tests-7a2922c770587b45)

running 1 test
test can_get_contract_id ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.09s
</code></pre>
<p>Congratulations, you've just created and tested your first Sway smart contract ðŸŽ‰. Now you can build a frontend to interact with your contract using the TypeScript SDK. You can find a step-by-step guide to building a front end for your project <a href="https://fuellabs.github.io/fuels-ts/QUICKSTART.html">here</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-fuel-toolchain"><a class="header" href="#the-fuel-toolchain">The Fuel Toolchain</a></h1>
<p>The Fuel toolchain consists of several components.</p>
<h2 id="forc-forc"><a class="header" href="#forc-forc">Forc (<code>forc</code>)</a></h2>
<p>The &quot;Fuel Orchestrator&quot; <a href="https://github.com/FuelLabs/sway/tree/master/forc">Forc</a> is our equivalent of Rust's <a href="https://doc.rust-lang.org/cargo/">Cargo</a>. It is the primary entry point for creating, building, testing, and deploying Sway projects.</p>
<h2 id="sway-language-server-forc-lsp"><a class="header" href="#sway-language-server-forc-lsp">Sway Language Server (<code>forc-lsp</code>)</a></h2>
<p>The Sway Language Server <code>forc-lsp</code> is provided to expose features to IDEs. <a href="introduction/./installation.html">Installation instructions</a>.</p>
<p>Currently, only <a href="https://marketplace.visualstudio.com/items?itemName=FuelLabs.sway-vscode-plugin">Visual Studio Code is supported through a plugin</a>. Vim support is forthcoming, though <a href="https://github.com/FuelLabs/sway.vim">syntax highlighting is provided</a>.</p>
<blockquote>
<p><strong>Note</strong>: There is no need to manually run <code>forc-lsp</code> (the plugin will automatically start it), however both <code>forc</code> and <code>forc-lsp</code> must be in your <code>$PATH</code>. To check if <code>forc</code> is in your <code>$PATH</code>, type <code>forc --help</code> in your terminal.</p>
</blockquote>
<h2 id="sway-formatter-forc-fmt"><a class="header" href="#sway-formatter-forc-fmt">Sway Formatter (<code>forc-fmt</code>)</a></h2>
<p>A canonical formatter is provided with <code>forc-fmt</code>. <a href="introduction/./installation.html">Installation instructions</a>. It can be run manually with</p>
<pre><code class="language-sh">forc fmt
</code></pre>
<p>The <a href="https://marketplace.visualstudio.com/items?itemName=FuelLabs.sway-vscode-plugin">Visual Studio Code plugin</a> will automatically format Sway files with <code>forc-fmt</code> on save.</p>
<h2 id="fuel-core-fuel-core"><a class="header" href="#fuel-core-fuel-core">Fuel Core (<code>fuel-core</code>)</a></h2>
<p>An implementation of the Fuel protocol, <a href="https://github.com/FuelLabs/fuel-core">Fuel Core</a>, is provided together with the <em>Sway toolchain</em> to form the <em>Fuel toolchain</em>. <a href="https://github.com/FuelLabs/fuels-rs">The Rust SDK</a> will automatically start and stop an instance of the node during tests, so there is no need to manually run a node unless using Forc directly without the SDK.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="a-forc-project"><a class="header" href="#a-forc-project">A Forc Project</a></h1>
<p>To initialize a new project with Forc, use <code>forc new</code>:</p>
<pre><code class="language-sh">forc new my-fuel-project
</code></pre>
<p>Here is the project that Forc has initialized:</p>
<pre><code class="language-console">$ cd my-fuel-project
$ tree .
â”œâ”€â”€ Forc.toml
â””â”€â”€ src
 Â Â  â””â”€â”€ main.sw
</code></pre>
<p><code>Forc.toml</code> is the <em>manifest file</em> (similar to <code>Cargo.toml</code> for Cargo or <code>package.json</code> for Node), and defines project metadata such as the project name and dependencies.</p>
<p>For additional information on dependency management, see: <a href="introduction/../forc/dependencies.html">here</a>.</p>
<pre><code class="language-toml">[project]
authors = [&quot;User&quot;]
entry = &quot;main.sw&quot;
license = &quot;Apache-2.0&quot;
name = &quot;my-fuel-project&quot;

[dependencies]
</code></pre>
<p>Here are the contents of the only Sway file in the project, and the main entry point, <code>src/main.sw</code>:</p>
<pre><code class="language-sway">contract;

abi MyContract {
    fn test_function() -&gt; bool;
}

impl MyContract for Contract {
    fn test_function() -&gt; bool {
        true
    }
}
</code></pre>
<p>The project is a <em>contract</em>, one of four different project types. For additional information on different project types, see <a href="introduction/../sway-program-types/index.html">here</a>.</p>
<p>We now compile our project with <code>forc build</code>, passing the flag <code>--print-finalized-asm</code> to view the generated assembly:</p>
<pre><code class="language-console">$ forc build --print-finalized-asm
...
.program:
ji   i4
noop
DATA_SECTION_OFFSET[0..32]
DATA_SECTION_OFFSET[32..64]
lw   $ds $is 1
add  $$ds $$ds $is
lw   $r0 $fp i73              ; load input function selector
lw   $r1 data_0               ; load fn selector for comparison
eq   $r2 $r0 $r1              ; function selector comparison
jnzi $r2 i12                  ; jump to selected function
movi $$tmp i123               ; special code for mismatched selector
rvrt $$tmp                    ; revert if no selectors matched
ret  $one
.data:
data_0 .word 559005003

  Compiled contract &quot;my-fuel-project&quot;.
  Bytecode size is 60 bytes.
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="standard-library"><a class="header" href="#standard-library">Standard Library</a></h1>
<p>Similar to Rust, Sway comes with its own standard library.</p>
<p>The Sway Standard Library is the foundation of portable Sway software, a set of minimal shared abstractions for the broader Sway ecosystem. It offers core types, like <code>Result&lt;T, E&gt;</code> and <code>Option&lt;T&gt;</code>, library-defined operations on language primitives, native asset management, blockchain contextual operations, access control, storage management, and support for types from other VMs, among many other things.</p>
<p>The entire Sway standard library is a Forc project called <code>std</code>, and is available directly here: <a href="https://github.com/FuelLabs/sway/tree/master/sway-lib-std">https://github.com/FuelLabs/sway/tree/master/sway-lib-std</a> (navigate to the appropriate tagged release if the latest <code>master</code> is not compatible).</p>
<h2 id="using-the-standard-library"><a class="header" href="#using-the-standard-library">Using the Standard Library</a></h2>
<p>The standard library is made implicitly available to all Forc projects created using <a href="introduction/../forc/commands/forc_new.html"><code>forc new</code></a>. In other words, it is not required to manually specify <code>std</code> as an explicit dependency. Forc will automatically use the version of <code>std</code> that matches its version.</p>
<p>Importing items from the standard library can be done using the <code>use</code> keyword, just as importing items from any Sway project. For example:</p>
<pre><code class="language-sway">use std::storage::StorageMap;
</code></pre>
<p>This imports the <code>StorageMap</code> type into the current namespace.</p>
<h2 id="standard-library-prelude"><a class="header" href="#standard-library-prelude">Standard Library Prelude</a></h2>
<p>Sway comes with a variety of things in its standard library. However, if you had to manually import every single thing that you used, it would be very verbose. But importing a lot of things that a program never uses isn't good either. A balance needs to be struck.</p>
<p>The prelude is the list of things that Sway automatically imports into every Sway program. It's kept as small as possible, and is focused on things which are used in almost every single Sway program.</p>
<p>The current version of the prelude lives in <a href="https://github.com/FuelLabs/sway/blob/master/sway-lib-std/src/prelude.sw"><code>std::prelude</code></a>, and re-exports the following:</p>
<ul>
<li><a href="https://github.com/FuelLabs/sway/blob/master/sway-lib-std/src/address.sw"><code>std::address::Address</code></a>, a wrapper around the <code>b256</code> type representing a wallet address.</li>
<li><a href="https://github.com/FuelLabs/sway/blob/master/sway-lib-std/src/contract_id.sw"><code>std::contract_id::ContractId</code></a>, a wrapper around the <code>b256</code> type representing the ID of a contract.</li>
<li><a href="https://github.com/FuelLabs/sway/blob/master/sway-lib-std/src/identity.sw"><code>std::identity::Identity</code></a>, an enum with two possible variants: <code>Address: Address</code> and <code>ContractId: ContractId</code>.</li>
<li><a href="https://github.com/FuelLabs/sway/blob/master/sway-lib-std/src/vec.sw"><code>std::vec::Vec</code></a>, a growable, heap-allocated vector.</li>
<li><a href="https://github.com/FuelLabs/sway/blob/master/sway-lib-std/src/option.sw"><code>std::option::Option</code></a>, an enum which expresses the presence or absence of a value.</li>
<li><a href="https://github.com/FuelLabs/sway/blob/master/sway-lib-std/src/result.sw"><code>std::result::Result</code></a>, an enum for functions that may succeed or fail.</li>
<li><a href="https://github.com/FuelLabs/sway/blob/master/sway-lib-std/src/assert.sw"><code>std::assert::assert</code></a>, a function that reverts the VM if the condition provided to it is <code>false</code>.</li>
<li><a href="https://github.com/FuelLabs/sway/blob/master/sway-lib-std/src/revert.sw"><code>std::revert::require</code></a>, a function that reverts the VM and logs a given value if the condition provided to it is <code>false</code>.</li>
<li><a href="https://github.com/FuelLabs/sway/blob/master/sway-lib-std/src/revert.sw"><code>std::revert::revert</code></a>, a function that reverts the VM.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="example"><a class="header" href="#example">Example</a></h1>
<p>Some basic example contracts to see how Sway and Forc work.</p>
<ul>
<li><a href="examples/./counter.html">Counter</a></li>
<li><a href="examples/./subcurrency.html">Subcurrency</a></li>
<li><a href="examples/./fizzbuzz.html">FizzBuzz</a></li>
<li><a href="examples/./wallet_smart_contract.html">Wallet Smart Contract</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="counter"><a class="header" href="#counter">Counter</a></h1>
<p>The following is a simple example of a contract which implements a counter. Both the <code>initialize_counter()</code> and <code>increment_counter()</code> ABI methods return the currently set value.</p>
<pre><code class="language-bash">forc template --template-name counter my_counter_project
</code></pre>
<pre><code class="language-sway">contract;

abi TestContract {
    #[storage(write)]
    fn initialize_counter(value: u64) -&gt; u64;

    #[storage(read, write)]
    fn increment_counter(amount: u64) -&gt; u64;
}

storage {
    counter: u64 = 0,
}

impl TestContract for Contract {
    #[storage(write)]
    fn initialize_counter(value: u64) -&gt; u64 {
        storage.counter = value;
        value
    }

    #[storage(read, write)]
    fn increment_counter(amount: u64) -&gt; u64 {
        let incremented = storage.counter + amount;
        storage.counter = incremented;
        incremented
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="subcurrency"><a class="header" href="#subcurrency">Subcurrency</a></h1>
<p>The following is a simple example of a subcurrency which implements functionality to mint and send a token. It is a ledger-based token, i.e. the contract maintains a ledger of user account balances.</p>
<p>Being a ledger-based token, this example does not use Fuel's <a href="examples/../blockchain-development/native_assets.html">native asset system</a>. It is not recommended to actually use ledger-based tokens in production; this example is here purely for illustrative purposes.</p>
<pre><code class="language-sway">contract;

use std::{chain::auth::{AuthError, msg_sender}, hash::sha256, logging::log, storage::StorageMap};

////////////////////////////////////////
// Event declarations
////////////////////////////////////////
// 
// Events allow clients to react to changes in the contract.
// Unlike Solidity, events are simply structs.
//
/// Emitted when a token is sent.
struct Sent {
    from: Address,
    to: Address,
    amount: u64,
}

////////////////////////////////////////
// ABI method declarations
////////////////////////////////////////
/// ABI for a subcurrency.
abi Token {
    // Mint new tokens and send to an address.
    // Can only be called by the contract creator.
    #[storage(read, write)]
    fn mint(receiver: Address, amount: u64);

    // Sends an amount of an existing token.
    // Can be called from any address.
    #[storage(read, write)]
    fn send(receiver: Address, amount: u64);
}

////////////////////////////////////////
// Constants
////////////////////////////////////////
/// Address of contract creator.
const MINTER = ~Address::from(0x9299da6c73e6dc03eeabcce242bb347de3f5f56cd1c70926d76526d7ed199b8b);

////////////////////////////////////////
// Contract storage
////////////////////////////////////////
// Contract storage persists across transactions.
storage {
    balances: StorageMap&lt;Address, u64&gt; = StorageMap {},
}

////////////////////////////////////////
// ABI definitions
////////////////////////////////////////
/// Contract implements the `Token` ABI.
impl Token for Contract {
    #[storage(read, write)]
    fn mint(receiver: Address, amount: u64) {
        // Note: The return type of `msg_sender()` can be inferred by the
        // compiler. It is shown here for explicitness.
        let sender: Result&lt;Identity, AuthError&gt; = msg_sender();
        let sender: Address = match sender.unwrap() {
            Identity::Address(addr) =&gt; {
                assert(addr == MINTER);
                addr
            },
            _ =&gt; revert(0),
        };

        // Increase the balance of receiver
        storage.balances.insert(receiver, storage.balances.get(receiver) + amount)
    }

    #[storage(read, write)]
    fn send(receiver: Address, amount: u64) {
        // Note: The return type of `msg_sender()` can be inferred by the
        // compiler. It is shown here for explicitness.
        let sender: Result&lt;Identity, AuthError&gt; = msg_sender();
        let sender = match sender.unwrap() {
            Identity::Address(addr) =&gt; addr,
            _ =&gt; revert(0),
        };

        // Reduce the balance of sender
        let sender_amount = storage.balances.get(sender);
        assert(sender_amount &gt; amount);
        storage.balances.insert(sender, sender_amount - amount);

        // Increase the balance of receiver
        storage.balances.insert(receiver, storage.balances.get(receiver) + amount);

        log(Sent {
            from: sender,
            to: receiver,
            amount: amount,
        });
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="fizzbuzz"><a class="header" href="#fizzbuzz">FizzBuzz</a></h1>
<p>This example is not the traditional <a href="https://en.wikipedia.org/wiki/Fizz_buzz#Programming">FizzBuzz</a>; instead it is the smart contract version! A script can call the <code>fizzbuzz</code> ABI method of this contract with some <code>u64</code> value and receive back its fizzbuzzability as an <code>enum</code>.</p>
<p>The format for custom structs and enums such as <code>FizzBuzzResult</code> will be automatically included in the ABI JSON so that off-chain code can handle the encoded form of the returned data.</p>
<pre><code class="language-sway">contract;

enum FizzBuzzResult {
    Fizz: (),
    Buzz: (),
    FizzBuzz: (),
    Other: u64,
}

abi FizzBuzz {
    fn fizzbuzz(input: u64) -&gt; FizzBuzzResult;
}

impl FizzBuzz for Contract {
    fn fizzbuzz(input: u64) -&gt; FizzBuzzResult {
        if input % 15 == 0 {
            FizzBuzzResult::FizzBuzz
        } else if input % 3 == 0 {
            FizzBuzzResult::Fizz
        } else if input % 5 == 0 {
            FizzBuzzResult::Buzz
        } else {
            FizzBuzzResult::Other(input)
        }
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="wallet-smart-contract"><a class="header" href="#wallet-smart-contract">Wallet Smart Contract</a></h1>
<h2 id="abi-declaration"><a class="header" href="#abi-declaration">ABI Declaration</a></h2>
<pre><code class="language-sway">library wallet_abi;

abi Wallet {
    #[storage(read, write)]
    fn receive_funds();
    
    #[storage(read, write)]
    fn send_funds(amount_to_send: u64, recipient_address: Address);
}
</code></pre>
<h2 id="abi-implementation"><a class="header" href="#abi-implementation">ABI Implementation</a></h2>
<pre><code class="language-sway">contract;

use std::{
    chain::auth::{
        AuthError,
        msg_sender,
    },
    constants::BASE_ASSET_ID,
    context::{
        call_frames::msg_asset_id,
        msg_amount,
    },
    token::transfer_to_address,
};

use wallet_abi::Wallet;
const OWNER_ADDRESS = ~Address::from(0x8900c5bec4ca97d4febf9ceb4754a60d782abbf3cd815836c1872116f203f861);

storage {
    balance: u64 = 0,
}

impl Wallet for Contract {
    #[storage(read, write)]
    fn receive_funds() {
        if msg_asset_id() == BASE_ASSET_ID {
            // If we received `BASE_ASSET_ID` then keep track of the balance.
            // Otherwise, we're receiving other native assets and don't care
            // about our balance of tokens.
            storage.balance += msg_amount();
        }
    }

    #[storage(read, write)]
    fn send_funds(amount_to_send: u64, recipient_address: Address) {
        // Note: The return type of `msg_sender()` can be inferred by the
        // compiler. It is shown here for explicitness.
        let sender: Result&lt;Identity, AuthError&gt; = msg_sender();
        match sender.unwrap() {
            Identity::Address(addr) =&gt; assert(addr == OWNER_ADDRESS),
            _ =&gt; revert(0),
        };

        let current_balance = storage.balance;
        assert(current_balance &gt;= amount_to_send);

        storage.balance = current_balance - amount_to_send;

        // Note: `transfer_to_address()` is not a call and thus not an
        // interaction. Regardless, this code conforms to
        // checks-effects-interactions to avoid re-entrancy.
        transfer_to_address(amount_to_send, BASE_ASSET_ID, recipient_address);
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sway-program-types"><a class="header" href="#sway-program-types">Sway Program Types</a></h1>
<p>A Sway program itself has a type: it is either a <em>contract</em>, a <em>predicate</em>, a <em>script</em>, or a <em>library</em>. The first three of these things are all deployable to the blockchain. A <em>library</em> is simply a project designed for code reuse and is never directly deployed to the chain.</p>
<p>Every Sway file <em>must</em> begin with a declaration of what type of program it is. A project can have many libraries within it, but only one contract, script, or predicate. Scripts and predicates require <code>main</code> functions to serve as entry points, while contracts instead publish an ABI. This chapter will go into detail about all of these various types of programs and what purposes they serve.</p>
<p>Contracts are used primarily for protocols or systems that operate within a fixed set of rules. A good example would be a staking contract or a decentralized exchange.</p>
<p>Scripts are used for complex on-chain interactions that won't persist. An example of this may be using a DEX and Lender to create a leveraged position (borrow, swap, re-collateralize, borrow) which is a complex transaction that would usually take multiple steps.</p>
<p>Libraries are for code that is reusable and useful for handling common situations. A good example of this would be a library to handle fixed-point math or big number math.</p>
<ul>
<li><a href="sway-program-types/./smart_contracts.html">Contracts</a></li>
<li><a href="sway-program-types/./libraries.html">Libraries</a></li>
<li><a href="sway-program-types/./scripts.html">Scripts</a></li>
<li><a href="sway-program-types/./predicates.html">Predicates</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="what-is-a-smart-contract"><a class="header" href="#what-is-a-smart-contract">What is a Smart Contract?</a></h1>
<p>A smart contract is no different than a script or predicate in that it is a piece of bytecode that is deployed to the blockchain via a <a href="https://github.com/FuelLabs/fuel-specs/blob/master/specs/protocol/tx_format.md">transaction</a>. The main features of a smart contract that differentiate it from scripts or predicates are that it is <em>callable</em> and <em>stateful</em>. Put another way, a smart contract is analogous to a deployed API with some database state. The interface of a smart contract, also just called a contract, must be defined strictly with an <a href="sway-program-types/smart_contracts.html#the-abi-declaration">ABI declaration</a>. See <a href="sway-program-types/../examples/subcurrency.html">this contract</a> for an example.</p>
<h2 id="syntax-of-a-smart-contract"><a class="header" href="#syntax-of-a-smart-contract">Syntax of a Smart Contract</a></h2>
<p>As with any Sway program, the program starts with a declaration of what <a href="sway-program-types/./index.html">program type</a> it is. A contract must also either define or import an <a href="sway-program-types/smart_contracts.html#the-abi-declaration">ABI declaration</a> and implement it. It is considered good practice to define your ABI in a separate library and import it into your contract. This allows callers of your contract to simply import the ABI directly and use it in their scripts to call your contract. Let's take a look at an ABI declaration in a library:</p>
<pre><code class="language-sway">library wallet_abi;

abi Wallet {
    #[storage(read, write)]
    fn receive_funds();
    
    #[storage(read, write)]
    fn send_funds(amount_to_send: u64, recipient_address: Address);
}
</code></pre>
<p>Let's focus on the ABI declaration and inspect it line-by-line.</p>
<h3 id="the-abi-declaration"><a class="header" href="#the-abi-declaration">The ABI Declaration</a></h3>
<pre><code class="language-sway">abi Wallet {
    #[storage(read, write)]
    fn receive_funds();
    
    #[storage(read, write)]
    fn send_funds(amount_to_send: u64, recipient_address: Address);
}
</code></pre>
<hr />
<p>In the first line, <code>abi Wallet {</code>, we declare the name of this <em>Application Binary Interface</em>, or ABI. We are naming this ABI <code>Wallet</code>. To import this ABI into either a script for calling or a contract for implementing, you would use</p>
<pre><code class="language-sway">use wallet_abi::Wallet;
</code></pre>
<hr />
<p>In the second line,</p>
<pre><code class="language-sway">    #[storage(read, write)]
    fn receive_funds();
</code></pre>
<p>we are declaring an ABI method called <code>receive_funds</code> which, when called, should receive funds into this wallet. Note that we are simply defining an interface here, so there is no <em>function body</em> or implementation of the function. We only need to define the interface itself. In this way, ABI declarations are similar to <a href="sway-program-types/../advanced/traits.html">trait declarations</a>. This particular ABI method does not take any parameters.</p>
<hr />
<p>In the third line,</p>
<pre><code class="language-sway">    #[storage(read, write)]
    fn send_funds(amount_to_send: u64, recipient_address: Address);
</code></pre>
<p>we are declaring another ABI method, this time called <code>send_funds</code>. It takes two parameters: the amount to send, and the address to send the funds to.</p>
<blockquote>
<p><strong>Note</strong>: The ABI methods <code>receive_funds</code> and <code>send_funds</code> also require the annotation <code>#[storage(read, write)]</code> because their implementations require reading and writing a storage variable that keeps track of the wallet balance, as we will see shortly. Refer to <a href="sway-program-types/../blockchain-development/purity.html#Purity">Purity</a> for more information on storage annotations.</p>
</blockquote>
<h2 id="implementing-an-abi-for-a-smart-contract"><a class="header" href="#implementing-an-abi-for-a-smart-contract">Implementing an ABI for a Smart Contract</a></h2>
<p>Now that we've discussed how to define the interface, let's discuss how to use it. We will start by implementing the above ABI for a specific contract.</p>
<p>Implementing an ABI for a contract is accomplished with <code>impl &lt;ABI name&gt; for Contract</code> syntax. The <code>for Contract</code> syntax can only be used to implement an ABI for a contract; implementing methods for a struct should use <code>impl Foo</code> syntax.</p>
<pre><code class="language-sway">impl Wallet for Contract {
    #[storage(read, write)]
    fn receive_funds() {
        if msg_asset_id() == BASE_ASSET_ID {
            // If we received `BASE_ASSET_ID` then keep track of the balance.
            // Otherwise, we're receiving other native assets and don't care
            // about our balance of tokens.
            storage.balance += msg_amount();
        }
    }

    #[storage(read, write)]
    fn send_funds(amount_to_send: u64, recipient_address: Address) {
        // Note: The return type of `msg_sender()` can be inferred by the
        // compiler. It is shown here for explicitness.
        let sender: Result&lt;Identity, AuthError&gt; = msg_sender();
        match sender.unwrap() {
            Identity::Address(addr) =&gt; assert(addr == OWNER_ADDRESS),
            _ =&gt; revert(0),
        };

        let current_balance = storage.balance;
        assert(current_balance &gt;= amount_to_send);

        storage.balance = current_balance - amount_to_send;

        // Note: `transfer_to_address()` is not a call and thus not an
        // interaction. Regardless, this code conforms to
        // checks-effects-interactions to avoid re-entrancy.
        transfer_to_address(amount_to_send, BASE_ASSET_ID, recipient_address);
    }
}
</code></pre>
<p>You may notice once again the similarities between <a href="sway-program-types/../advanced/traits.html">traits</a> and ABIs. And, indeed, as a bonus, you can specify methods in addition to the interface surface of an ABI, just like a trait. By implementing the methods in the interface surface, you get the extra method implementations For Freeâ„¢.</p>
<p>Note that the above implementation of the ABI follows the <a href="https://docs.soliditylang.org/en/v0.6.11/security-considerations.html#re-entrancy">Checks, Effects, Interactions</a> pattern.</p>
<h2 id="calling-a-smart-contract-from-a-script"><a class="header" href="#calling-a-smart-contract-from-a-script">Calling a Smart Contract from a Script</a></h2>
<blockquote>
<p><strong>Note</strong>: In most cases, calling a contract should be done from the <a href="sway-program-types/../testing/testing-with-rust.html">Rust SDK</a> or the <a href="sway-program-types/../frontend/typescript_sdk.html">TypeScript SDK</a> which provide a more ergonomic UI for interacting with a contract. However, there are situations where manually writing a script to call a contract is required.</p>
</blockquote>
<p>Now that we have defined our interface and implemented it for our contract, we need to know how to actually <em>call</em> our contract. Let's take a look at a contract call:</p>
<pre><code class="language-sway">script;

use std::constants::ZERO_B256;
use wallet_abi::Wallet;

fn main() {
    let contract_address = 0x9299da6c73e6dc03eeabcce242bb347de3f5f56cd1c70926d76526d7ed199b8b;
    let caller = abi(Wallet, contract_address);
    let amount_to_send = 200;
    let recipient_address = ~Address::from(0x9299da6c73e6dc03eeabcce242bb347de3f5f56cd1c70926d76526d7ed199b8b);
    caller.send_funds {
        gas: 10000,
        coins: 0,
        asset_id: ZERO_B256,
    }(amount_to_send, recipient_address);
}
</code></pre>
<p>The main new concept is the <em>abi cast</em>: <code>abi(AbiName, contract_address)</code>. This returns a <code>ContractCaller</code> type which can be used to call contracts. The methods of the ABI become the methods available on this contract caller: <code>send_funds</code> and <code>receive_funds</code>. We then directly call the contract ABI method as if it was just a regular method. You also have the option of specifying the following special parameters inside curly braces right before the main list of parameters:</p>
<ol>
<li><code>gas</code>: a <code>u64</code> that represents the gas being forwarded to the contract when it is called.</li>
<li><code>coins</code>: a <code>u64</code> that represents how many coins are being forwarded with this call.</li>
<li><code>asset_id</code>: a <code>b256</code> that represents the ID of the <em>asset type</em> of the coins being forwarded.</li>
</ol>
<p>Each special parameter is optional and assumes a default value when skipped:</p>
<ol>
<li>The default value for <code>gas</code> is the context gas (i.e. the content of the special register <code>$cgas</code>). Refer to the <a href="https://github.com/FuelLabs/fuel-specs/blob/master/specs/vm/main.md">FuelVM specifications</a> for more information about context gas.</li>
<li>The default value for <code>coins</code> is 0.</li>
<li>The default value for <code>asset_id</code> is <code>ZERO_B256</code>.</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="libraries"><a class="header" href="#libraries">Libraries</a></h1>
<p>Libraries in Sway are files used to define new common behavior. The most prominent example of this is the <a href="sway-program-types/../introduction/standard_library.html">Sway Standard Library</a>.</p>
<h2 id="writing-libraries"><a class="header" href="#writing-libraries">Writing Libraries</a></h2>
<p>Libraries are defined using the <code>library</code> keyword at the beginning of a file, followed by a name so that they can be imported.</p>
<pre><code class="language-sway">library my_library;

// library code
</code></pre>
<p>A good reference library to use when learning library design is the <a href="sway-program-types/../introduction/standard_library.html">Sway Standard Library</a>. For example, the standard library offers an <a href="https://github.com/FuelLabs/sway/blob/master/sway-lib-std/src/option.sw">implementation</a> of <code>enum Option&lt;T&gt;</code> which is a generic type that represents either the existence of a value using the variant <code>Some(..)</code> or a value's absence using the variant <code>None</code>. The <a href="https://github.com/FuelLabs/sway/blob/master/sway-lib-std/src/option.sw">Sway file implementing <code>Option&lt;T&gt;</code></a> has the following structure:</p>
<ul>
<li>The <code>library</code> keyword followed by the name of the library:</li>
</ul>
<pre><code class="language-sway">library option;
</code></pre>
<ul>
<li>A <code>use</code> statement that imports <code>revert</code> from another library <em>inside</em> the standard library:</li>
</ul>
<pre><code class="language-sway">use ::revert::revert;
</code></pre>
<ul>
<li>The <code>enum</code> definition which starts with the keyword <code>pub</code> to indicate that this <code>Option&lt;T&gt;</code> is publically available <em>outside</em> the <code>option</code> library:</li>
</ul>
<pre><code class="language-sway">pub enum Option&lt;T&gt; {
    // variants
}
</code></pre>
<ul>
<li>An <code>impl</code> block that implements some methods for <code>Option&lt;T&gt;</code>:</li>
</ul>
<pre><code class="language-sway">impl&lt;T&gt; Option&lt;T&gt; {

    fn is_some(self) -&gt; bool {
        // body of is_some
    }

    // other methods
}
</code></pre>
<p>Now that the library <code>option</code> is fully written, and because <code>Option&lt;T&gt;</code> is defined with the <code>pub</code> keyword, we are now able to import <code>Option&lt;T&gt;</code> using <code>use std::option::Option;</code> from any Sway project and have access to all of its variants and methods. That being said, <code>Option</code> is automatically available in the <a href="sway-program-types/../introduction/standard_library.html#standard-library-prelude">standard library prelude</a> so you never actually have to import it manually.</p>
<p>Libraries are composed of just a <code>Forc.toml</code> file and a <code>src</code> directory, unlike contracts which usually contain a <code>tests</code> directory and a <code>Cargo.toml</code> file as well. An example of a library's <code>Forc.toml</code>:</p>
<pre><code class="language-toml">[project]
authors = [&quot;Fuel Labs &lt;contact@fuel.sh&gt;&quot;]
entry = &quot;lib.sw&quot;
license = &quot;Apache-2.0&quot;
name = &quot;my_library&quot;

[dependencies]
</code></pre>
<p>which denotes the authors, an entry file, the name by which it can be imported, and any dependencies.</p>
<p>For large libraries, it is recommended to have a <code>lib.sw</code> entry point re-export all other sub-libraries. For example, the <code>lib.sw</code> of the standard library looks like:</p>
<pre><code class="language-sway">library std;

dep block;
dep storage;
dep constants;
// .. Other deps
</code></pre>
<p>with other libraries contained in the <code>src</code> folder, like the block library (inside of <code>block.sw</code>):</p>
<pre><code class="language-sway">library block;

// Implementation of the `block` library 
</code></pre>
<p>The <code>dep</code> keyword in the main library includes a dependency on another library, making all of its items (such as functions and structs) accessible from the main library. The <code>dep</code> keyword simply makes the library a dependency and fully accessible within the current context.</p>
<h2 id="using-libraries"><a class="header" href="#using-libraries">Using Libraries</a></h2>
<p>Libraries can be imported using the <code>use</code> keyword and with a <code>::</code> separating the name of the library and the import.</p>
<p>Here is an example of importing the <code>get&lt;T&gt;</code> and <code>store&lt;T&gt;</code> functions from the <code>storage</code> library.</p>
<pre><code class="language-sway">use std::storage::{get, store};
</code></pre>
<p>Wildcard imports using <code>*</code> are supported, but it is always recommended to use explicit imports where possible.</p>
<p>Libraries <em>other than the standard library</em> have to be added as a dependency in <code>Forc.toml</code>. This can be done by adding a path to the library in the <code>[dependencies]</code> section. For example:</p>
<pre><code class="language-toml">wallet_lib = { path = &quot;/path/to/wallet_lib&quot; }
</code></pre>
<blockquote>
<p><strong>Note</strong>: the standard library is implicitly available to all Forc projects, that is, you are not required to manually specify <code>std</code> as an explicit dependency in <code>Forc.toml</code>.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="scripts"><a class="header" href="#scripts">Scripts</a></h1>
<p>A script is runnable bytecode on the chain which executes once to perform some task. It does not represent ownership of any resources and it cannot be called by a contract. A script can return a single value of any type.</p>
<p>Scripts are state-aware in that while they have no persistent storage (because they only exist during the transaction) they can call contracts and act based upon the returned values and results.</p>
<p>This example script calls a contract:</p>
<pre><code class="language-sway">script;

use std::constants::ZERO_B256;
use wallet_abi::Wallet;

fn main() {
    let contract_address = 0x9299da6c73e6dc03eeabcce242bb347de3f5f56cd1c70926d76526d7ed199b8b;
    let caller = abi(Wallet, contract_address);
    let amount_to_send = 200;
    let recipient_address = ~Address::from(0x9299da6c73e6dc03eeabcce242bb347de3f5f56cd1c70926d76526d7ed199b8b);
    caller.send_funds {
        gas: 10000,
        coins: 0,
        asset_id: ZERO_B256,
    }(amount_to_send, recipient_address);
}
</code></pre>
<p>Scripts, similar to predicates, rely on a <code>main()</code> function as an entry point. You can call other functions defined in a script from the <code>main()</code> function or call another contract via an <a href="sway-program-types/./smart_contracts.html#calling-a-smart-contract-from-a-script">abi cast</a>.</p>
<p>An example use case for a script would be a router that trades funds through multiple DEXes to get the price for the input asset, or a script to re-adjust a Collateralized Debt Position via a flashloan.</p>
<h2 id="scripts-and-the-sdks"><a class="header" href="#scripts-and-the-sdks">Scripts and the SDKs</a></h2>
<p>Unlike EVM transactions which can call a contract directly (but can only call a single contract), Fuel transactions execute a script, which may call zero or more contracts. The Rust and TypeScript SDKs provide functions to call contract methods as if they were calling contracts directly. Under the hood, the SDKs wrap all contract calls with scripts that contain minimal code to simply make the call and forward script data as call parameters.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="predicates"><a class="header" href="#predicates">Predicates</a></h1>
<p>From the perspective of Sway, predicates are programs that return a Boolean value and which represent ownership of some resource upon execution to true. They have no access to contract storage. Here is a trivial predicate, which always evaluates to true:</p>
<pre><code class="language-sway">predicate;

// All predicates require a main function which returns a Boolean value.
fn main() -&gt; bool {
    true
}
</code></pre>
<h2 id="debugging-predicates"><a class="header" href="#debugging-predicates">Debugging Predicates</a></h2>
<p>Because they don't have any side effects (they are <em>pure</em>), predicates cannot create receipts. Therefore, they cannot have logging or create a stack backtrace. This means that there is no naive way to debug them aside from using a single-stepping debugger (which is a <a href="https://github.com/FuelLabs/fuel-debugger/pull/1">work-in-progress</a>).</p>
<p>As a workaround, the predicate can be written, tested, and debugged first as a <code>script</code>, and then changed back into a <code>predicate</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sway-language-basics"><a class="header" href="#sway-language-basics">Sway Language basics</a></h1>
<p>Sway is a programming language designed for the FuelVM. It is a statically typed, compiled language with type inference and traits. Sway aims to make smart contract development safer and more performant through the use of strong static analysis and compiler feedback.</p>
<p>Sway basics.</p>
<ul>
<li><a href="basics/./variables.html">Variables</a></li>
<li><a href="basics/./built_in_types.html">Built-in Types</a></li>
<li><a href="basics/./blockchain_types.html">Blockchain Types</a></li>
<li><a href="basics/./functions.html">Functions</a></li>
<li><a href="basics/./structs_tuples_and_enums.html">Structs, Tuples, and Enums</a></li>
<li><a href="basics/./methods_and_associated_functions.html">Methods and Associated Functions</a></li>
<li><a href="basics/./control_flow.html">Control Flow</a></li>
<li><a href="basics/./comments_and_logging.html">Comments and Logging</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="variables"><a class="header" href="#variables">Variables</a></h1>
<p>Variables in Sway are <em>immutable by default</em>. This means that, by default, once a variable is declared, its value cannot change. This is one of the ways how Sway encourages safe programming, and many modern languages have this same default. Let's take a look at variables in detail.</p>
<h2 id="declaring-a-variable"><a class="header" href="#declaring-a-variable">Declaring a Variable</a></h2>
<p>Let's look at a variable declaration:</p>
<pre><code class="language-sway">let foo = 5;
</code></pre>
<p>Great! We have just declared a variable, <code>foo</code>. What do we know about <code>foo</code>?</p>
<ol>
<li>It is immutable.</li>
<li>Its value is <code>5</code>.</li>
<li>Its type is <code>u64</code>, a 64-bit unsigned integer.</li>
</ol>
<p><code>u64</code> is the default numeric type, and represents a 64-bit unsigned integer. See the section <a href="basics/./built_in_types.html">Built-in Types</a> for more details.</p>
<p>We can also make a mutable variable. Let's take a look:</p>
<pre><code class="language-sway">let mut foo = 5;
foo = 6;
</code></pre>
<p>Now, <code>foo</code> is mutable, and the reassignment to the number <code>6</code> is valid. That is, we are allowed to <em>mutate</em> the variable <code>foo</code> to change its value.</p>
<h2 id="type-annotations"><a class="header" href="#type-annotations">Type Annotations</a></h2>
<p>A variable declaration can contain a <em>type annotation</em>. A type annotation serves the purpose of declaring the type, in addition to the value, of a variable. Let's take a look:</p>
<pre><code class="language-sway">let foo: u32 = 5;
</code></pre>
<p>We have just declared the <em>type</em> of the variable <code>foo</code> as a <code>u32</code>, which is an unsigned 32-bit integer. Let's take a look at a few other type annotations:</p>
<pre><code class="language-sway">let bar: str[4] = &quot;sway&quot;;
let baz: bool = true;
</code></pre>
<p>If the value declared cannot be assigned to the declared type, there will be an error generated by the compiler.</p>
<h2 id="configuration-time-constants"><a class="header" href="#configuration-time-constants">Configuration-time Constants</a></h2>
<p>It is possible to define and initialize constant variables in the manifest file <code>Forc.toml</code> of a Sway project. These constants then become visible and usable in the corresponding Sway program. Such variables are called configuration-time constants and have to be defined in their own section called <code>[constants]</code> in the manifest file. The syntax for declaring such constants is as follows:</p>
<pre><code class="language-sway">[constants]
some_contract_addr = { type = &quot;b256&quot;, value = &quot;0x580acb6ee759d9be0c0f78d3ef24e1b59300c625b3c61999967366dbbebad31c&quot; }
some_num = { type = &quot;u64&quot;, value = &quot;42&quot; }
some_string = { type = &quot;str[4]&quot;, value = &quot;\&quot;fuel\&quot;&quot; }
true_bool = { type = &quot;bool&quot;, value = &quot;true&quot; }
</code></pre>
<p>Notice that each constant requires two fields: a <code>type</code> and a <code>value</code>.</p>
<blockquote>
<p><strong>Note</strong>
Because configuration-time constants are <em>constants</em>, they are immutable and cannot be made otherwise.</p>
</blockquote>
<p>The constants defined above can now be used in a Sway program that uses the manifest file as follows:</p>
<pre><code class="language-sway">script;

struct S {
    x: u64,
}

fn main() -&gt; u64 {
    let addr = some_contract_addr;

    let string = some_string;

    return if true_bool { some_num } else { 0 };
}
</code></pre>
<blockquote>
<p><strong>Note</strong>
Currently, it is only possible to define configuration-time constants that have <a href="basics/built_in_types.html#primitive-types">primitive types</a> and that are initialized using literals. This will change in the future.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="built-in-types"><a class="header" href="#built-in-types">Built-in Types</a></h1>
<p>Every value in Sway is of a certain type. Although deep down, all values are just ones and zeroes in the underlying virtual machine, Sway needs to know what those ones and zeroes actually mean. This is accomplished with <em>types</em>.</p>
<p>Sway is a statically typed language. At compile time, the types of every value must be known. This does not mean you need to specify every single type: usually, the type can be reasonably inferred by the compiler.</p>
<h2 id="primitive-types"><a class="header" href="#primitive-types">Primitive Types</a></h2>
<p>Sway has the following primitive types:</p>
<ol>
<li><code>u8</code> (8-bit unsigned integer)</li>
<li><code>u16</code> (16-bit unsigned integer)</li>
<li><code>u32</code> (32-bit unsigned integer)</li>
<li><code>u64</code> (64-bit unsigned integer)</li>
<li><code>str[]</code> (fixed-length string)</li>
<li><code>bool</code> (Boolean <code>true</code> or <code>false</code>)</li>
<li><code>b256</code> (256 bits (32 bytes), i.e. a hash)</li>
</ol>
<p>All other types in Sway are built up of these primitive types, or references to these primitive types. You may notice that there are no signed integersâ€”this is by design. In the blockchain domain that Sway occupies, floating-point values and negative numbers have smaller utility, so their implementation has been left up to libraries for specific use cases.</p>
<h2 id="numeric-types"><a class="header" href="#numeric-types">Numeric Types</a></h2>
<p>All of the unsigned integer types are numeric types.</p>
<p>Numbers can be declared with binary syntax, hexadecimal syntax, base-10 syntax, and underscores for delineation. Let's take a look at the following valid numeric primitives:</p>
<pre><code class="language-sway">0xffffff    // hexadecimal
0b10101010  // binary
10          // base-10
100_000     // underscore delineated base-10
0x1111_0000 // underscore delineated binary
0xfff_aaa   // underscore delineated hexadecimal
</code></pre>
<p>The default numeric type is <code>u64</code>. The FuelVM's word size is 64 bits, and the cases where using a smaller numeric type saves space are minimal.</p>
<h2 id="boolean-type"><a class="header" href="#boolean-type">Boolean Type</a></h2>
<p>The boolean type (<code>bool</code>) has two potential values: <code>true</code> or <code>false</code>. Boolean values are typically used for conditional logic or validation, for example in <code>if</code> expressions. Booleans can be negated, or flipped, with the unary negation operator <code>!</code>. For example:</p>
<pre><code class="language-sway">fn returns_false() -&gt; bool {
    let boolean_value: bool = true;
    !boolean_value
}
</code></pre>
<h2 id="string-type"><a class="header" href="#string-type">String Type</a></h2>
<p>In Sway, static-length strings are a primitive type. This means that when you declare a string, its size is a part of its type. This is necessary for the compiler to know how much memory to give for the storage of that data. The size of the string is denoted with square brackets. Let's take a look:</p>
<pre><code class="language-sway">let my_string: str[4] = &quot;fuel&quot;;
</code></pre>
<p>Because the string literal <code>&quot;fuel&quot;</code> is four letters, the type is <code>str[4]</code>, denoting a static length of 4 characters. Strings default to UTF-8 in Sway.</p>
<h2 id="compound-types"><a class="header" href="#compound-types">Compound Types</a></h2>
<p><em>Compound types</em> are types that group multiple values into one type. In Sway, we have arrays and tuples.</p>
<h2 id="tuple-types"><a class="header" href="#tuple-types">Tuple Types</a></h2>
<p>A tuple is a general-purpose static-length aggregation of types. In more plain terms, a tuple is a single type that consists of an aggregate of zero or more types. The internal types that make up a tuple, and the tuple's arity, define the tuple's type. Let's take a look at some examples.</p>
<pre><code class="language-sway">let x: (u64, u64) = (0, 0);
</code></pre>
<p>This is a tuple, denoted by parenthesized, comma-separated values. Note that the type annotation, <code>(u64, u64)</code>, is similar in syntax to the expression which instantiates that type, <code>(0, 0)</code>.</p>
<pre><code class="language-sway">let x: (u64, bool) = (42, true);
assert(x.1);
</code></pre>
<p>In this example, we have created a new tuple type, <code>(u64, bool)</code>, which is a composite of a <code>u64</code> and a <code>bool</code>. To access a value within a tuple, we use <em>tuple indexing</em>: <code>x.1</code> stands for the first (zero-indexed, so the <code>bool</code>) value of the tuple. Likewise, <code>x.0</code> would be the zeroth, <code>u64</code> value of the tuple. Tuple values can also be accessed via destructuring:</p>
<pre><code class="language-sway">struct Foo {}
let x: (u64, Foo, bool) = (42, Foo {}, true);
let (number, foo, boolean) = x;
</code></pre>
<p>To create one-arity tuples, we will need to add a trailing comma:</p>
<pre><code class="language-sway">let x: u64 = (42);     // x is of type u64
let y: (u64) = (42);   // y is of type u64
let z: (u64,) = (42,); // z is of type (u64), i.e. a one-arity tuple
let w: (u64) = (42,);  // type error
</code></pre>
<h2 id="arrays"><a class="header" href="#arrays">Arrays</a></h2>
<p>An array is similar to a tuple, but an array's values must all be of the same type. Arrays can hold arbitrary types include non-primitive types.</p>
<p>An array is written as a comma-separated list inside square brackets:</p>
<pre><code class="language-sway">let x = [1, 2, 3, 4, 5];
</code></pre>
<p>Arrays are allocated on the stack since their size is known. An array's size is <em>always</em> static, i.e. it cannot change. An array of five elements cannot become an array of six elements.</p>
<p>Arrays can be iterated over, unlike tuples. An array's type is written as the type the array contains followed by the number of elements, semicolon-separated and within square brackets, e.g. <code>[u64; 5]</code>. To access an element in an array, use the <em>array indexing syntax</em>, i.e. square brackets.</p>
<pre><code class="language-sway">script;

struct Foo {
    f1: u32,
    f2: b256,
}

fn main() {
    // Array of integers with type ascription
    let array_of_integers: [u8; 5] = [1, 2, 3, 4, 5];

    // Array of strings
    let array_of_strings = [&quot;Bob&quot;, &quot;Jan&quot;, &quot;Ron&quot;];

    // Array of structs
    let array_of_structs: [Foo; 2] = [
        Foo {
            f1: 11,
            f2: 0x1111111111111111111111111111111111111111111111111111111111111111,
        },
        Foo {
            f1: 22,
            f2: 0x2222222222222222222222222222222222222222222222222222222222222222,
        },
    ];

    // Accessing an element of an array
    let array_of_bools: [bool; 2] = [true, false];
    assert(array_of_bools[0]);
}
</code></pre>
<blockquote>
<p><strong>Note</strong>: Arrays are currently immutable which means that changing elements of an array once initialized is not yet possible.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="blockchain-types"><a class="header" href="#blockchain-types">Blockchain Types</a></h1>
<p>Sway is fundamentally a blockchain language, and it offers a selection of types tailored for the blockchain use case.</p>
<p>These are provided via the standard library (<a href="https://github.com/FuelLabs/sway/tree/master/sway-lib-std"><code>lib-std</code></a>) which both add a degree of type-safety, as well as make the intention of the developer more clear.</p>
<h2 id="address-type"><a class="header" href="#address-type"><code>Address</code> Type</a></h2>
<p>The <code>Address</code> type is a type-safe wrapper around the primitive <code>b256</code> type. Unlike the EVM, an address <strong>never</strong> refers to a deployed smart contract (see the <code>ContractId</code> type below). An <code>Address</code> can be either the hash of a public key (effectively an <a href="https://ethereum.org/en/whitepaper/#ethereum-accounts">externally owned account</a> if you're coming from the EVM) or the hash of a <a href="basics/../sway-program-types/predicates.html">predicate</a>. Addresses own UTXOs.</p>
<p>An <code>Address</code> is implemented as follows.</p>
<pre><code class="language-sway">pub struct Address {
    value: b256,
}
</code></pre>
<p>Casting between the <code>b256</code> and <code>Address</code> types must be done explicitly:</p>
<pre><code class="language-sway">let my_number: b256 = 0x000000000000000000000000000000000000000000000000000000000000002A;
let my_address: Address = ~Address::from(my_number);
let forty_two: b256 = my_address.into();
</code></pre>
<h2 id="contractid-type"><a class="header" href="#contractid-type"><code>ContractId</code> Type</a></h2>
<p>The <code>ContractId</code> type is a type-safe wrapper around the primitive <code>b256</code> type. A contract's ID is a unique, deterministic identifier analogous to a contract's address in the EVM. Contracts cannot own UTXOs but can own assets.</p>
<p>A <code>ContractId</code> is implemented as follows.</p>
<pre><code class="language-sway">pub struct ContractId {
    value: b256,
}
</code></pre>
<p>Casting between the <code>b256</code> and <code>ContractId</code> types must be done explicitly:</p>
<pre><code class="language-sway">let my_number: b256 = 0x000000000000000000000000000000000000000000000000000000000000002A;
let my_contract_id: ContractId = ~ContractId::from(my_number);
let forty_two: b256 = my_contract_id.into();
</code></pre>
<h2 id="identity-type"><a class="header" href="#identity-type"><code>Identity</code> Type</a></h2>
<p>The <code>Identity</code> type is an enum that allows for the handling of both <code>Address</code> and <code>ContractId</code> types. This is useful in cases where either type is accepted, e.g. receiving funds from an identified sender, but not caring if the sender is an address or a contract.</p>
<p>An <code>Identity</code> is implemented as follows.</p>
<pre><code class="language-sway">pub enum Identity {
    Address: Address,
    ContractId: ContractId,
}
</code></pre>
<p>Casting to an <code>Identity</code> must be done explicitly:</p>
<pre><code class="language-sway">        let raw_address: b256 = 0xddec0e7e6a9a4a4e3e57d08d080d71a299c628a46bc609aab4627695679421ca;
        let my_identity: Identity = Identity::Address(~Address::from(raw_address));
</code></pre>
<p>A <code>match</code> statement can be used to return to an <code>Address</code> or <code>ContractId</code> as well as handle cases in which their execution differs.</p>
<pre><code class="language-sway">        let my_contract_id: ContractId = match my_identity {
            Identity::ContractId(identity) =&gt; identity,
            _ =&gt; revert(0),
        };
</code></pre>
<pre><code class="language-sway">        match my_identity {
            Identity::Address(address) =&gt; transfer_to_address(amount, token_id, address),
            Identity::ContractId(contract_id) =&gt; force_transfer_to_contract(amount, token_id, contract_id),
        };
</code></pre>
<p>A common use case for <code>Identity</code> is for access control. The use of <code>Identity</code> uniquely allows both <code>ContractId</code> and <code>Address</code> to have access control inclusively.</p>
<pre><code class="language-sway">        let sender: Result&lt;Identity, AuthError&gt; = msg_sender();
        require(sender.unwrap() == storage.owner, MyError::UnauthorizedUser);
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="functions"><a class="header" href="#functions">Functions</a></h1>
<p>Functions in Sway are declared with the <code>fn</code> keyword. Let's take a look:</p>
<pre><code class="language-sway">fn equals(first_param: u64, second_param: u64) -&gt; bool {
    first_param == second_param
}
</code></pre>
<p>We have just declared a function named <code>equals</code> which takes two parameters: <code>first_param</code> and <code>second_param</code>. The parameters must both be 64-bit unsigned integers.</p>
<p>This function also returns a <code>bool</code> value, i.e. either <code>true</code> or <code>false</code>. This function returns <code>true</code> if the two given parameters are equal, and <code>false</code> if they are not. If we want to use this function, we can do so like this:</p>
<pre><code class="language-sway">fn main() {
    equals(5, 5); // evaluates to `true`
    equals(5, 6); // evaluates to `false`
}
</code></pre>
<h2 id="mutable-parameters"><a class="header" href="#mutable-parameters">Mutable Parameters</a></h2>
<p>We can make a function parameter mutable by adding <code>ref mut</code> before the parameter name. This allows mutating the argument passed into the function when the function is called. For example:</p>
<pre><code class="language-sway">fn increment(ref mut num: u32) {
    let prev = num;
    num = prev + 1u32;
}
</code></pre>
<p>This function is allowed to mutate its parameter <code>num</code> because of the <code>mut</code> keyword. In addition, the <code>ref</code> keyword instructs the function to modify the argument passed to it when the function is called, instead of modifying a local copy of it.</p>
<pre><code class="language-sway">    let mut num: u32 = 0;
    increment(num);
    assert(num == 1u32); // The function `increment()` modifies `num`
</code></pre>
<p>Note that the variable <code>num</code> itself has to be declared as mutable for the above to compile.</p>
<blockquote>
<p><strong>Note</strong>
It is not currently allowed to use <code>mut</code> without <code>ref</code> or vice versa for a function parameter.</p>
</blockquote>
<p>Similarly, <code>ref mut</code> can be used with more complex data types such as:</p>
<pre><code class="language-sway">fn swap_tuple(ref mut pair: (u64, u64)) {
    let temp = pair.0;
    pair.0 = pair.1;
    pair.1 = temp;
}

fn update_color(ref mut color: Color, new_color: Color) {
    color = new_color;
}
</code></pre>
<p>We can then call these functions as shown below:</p>
<pre><code class="language-sway">    let mut tuple = (42, 24);
    swap_tuple(tuple);
    assert(tuple.0 == 24); // The function `swap_tuple()` modifies `tuple.0`
    assert(tuple.1 == 42); // The function `swap_tuple()` modifies `tuple.1`
    let mut color = Color::Red;
    update_color(color, Color::Blue);
    assert(match color {
        Color::Blue =&gt; true,
        _ =&gt; false,
    }); // The function `update_color()` modifies the color to Blue
</code></pre>
<blockquote>
<p><strong>Note</strong>
The only place, in a Sway program, where the <code>ref</code> keyword is valid is before a mutable function parameter.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="structs-tuples-and-enums"><a class="header" href="#structs-tuples-and-enums">Structs, Tuples, and Enums</a></h1>
<h2 id="structs"><a class="header" href="#structs">Structs</a></h2>
<p>Structs in Sway are a named grouping of types. You may also be familiar with structs via another name: <em>product types</em>. Sway does not make any significantly unique usages of structs; they are similar to most other languages which have structs. If you're coming from an object-oriented background, a struct is like the data attributes of an object.</p>
<p>Firstly, we declare a struct named <code>Foo</code> with two fields. The first field is named <code>bar</code> and it accepts values of type <code>u64</code>, the second field is named <code>baz</code> and it accepts <code>bool</code> values.</p>
<pre><code class="language-sway">library data_structures;

// Declare a struct type
pub struct Foo {
    bar: u64,
    baz: bool,
}

// Struct types for destructuring
pub struct Point {
    x: u64,
    y: u64,
}

pub struct Line {
    p1: Point,
    p2: Point,
}

pub struct TupleInStruct {
    nested_tuple: (u64, (u32, (bool, str[2]))),
}
</code></pre>
<p>In order to instantiate the struct we use <em>struct instantiation syntax</em>, which is very similar to the declaration syntax except with expressions in place of types.</p>
<p>There are three ways to instantiate the struct.</p>
<ul>
<li>Hardcoding values for the fields</li>
<li>Passing in variables with names different than the struct fields</li>
<li>Using a shorthand notation via variables that are the same as the field names</li>
</ul>
<pre><code class="language-sway">library utils;

dep data_structures;
use data_structures::{Foo, Line, Point, TupleInStruct};

fn hardcoded_instantiation() -&gt; Foo {
    // Instantiate `foo` as `Foo`
    let mut foo = Foo {
        bar: 42,
        baz: false,
    };

    // Access and write to &quot;baz&quot;
    foo.baz = true;

    // Return the struct
    foo
}

fn variable_instantiation() -&gt; Foo {
    // Declare variables with the same names as the fields in `Foo`
    let number = 42;
    let truthness = false;

    // Instantiate `foo` as `Foo`
    let mut foo = Foo {
        bar: number,
        baz: truthness,
    };

    // Access and write to &quot;baz&quot;
    foo.baz = true;

    // Return the struct
    foo
}

fn shorthand_instantiation() -&gt; Foo {
    // Declare variables with the same names as the fields in `Foo`
    let bar = 42;
    let baz = false;

    // Instantiate `foo` as `Foo`
    let mut foo = Foo { bar, baz };

    // Access and write to &quot;baz&quot;
    foo.baz = true;

    // Return the struct
    foo
}

fn struct_destructuring() {
    let point1 = Point { x: 0, y: 0 };
    // Destructure the values from the struct into variables
    let Point { x, y } = point1;

    let point2 = Point { x: 1, y: 1 };
    // If you do not care about specific struct fields then use &quot;..&quot; at the end of your variable list
    let Point { x, .. } = point2;

    let line = Line {
        p1: point1,
        p2: point2,
    };
    // Destructure the values from the nested structs into variables
    let Line {
        p1: Point { x: x0, y: y0 },
        p2: Point { x: x1, y: y1 },
    } = line;
    // You may also destructure tuples nested in structs and structs nested in tuples
    let tuple_in_struct = TupleInStruct {
        nested_tuple: (42u64, (42u32, (true, &quot;ok&quot;))),
    };
    let TupleInStruct {
        nested_tuple: (a, (b, (c, d))),
    } = tuple_in_struct;

    let struct_in_tuple = (Point { x: 2, y: 4 }, Point { x: 3, y: 6 });
    let (Point { x: x0, y: y0 }, Point { x: x1, y: y1 }) = struct_in_tuple;
}
</code></pre>
<blockquote>
<p><strong>Note</strong>
You can mix and match all 3 ways to instantiate the struct at the same time.
Moreover, the order of the fields does not matter when instantiating however we encourage declaring the fields in alphabetical order and instantiating them in the same alphabetical order</p>
</blockquote>
<p>Furthermore, multiple variables can be extracted from a struct using the destructuring syntax.</p>
<h3 id="struct-memory-layout"><a class="header" href="#struct-memory-layout">Struct Memory Layout</a></h3>
<blockquote>
<p><strong>Note</strong>
This information is not vital if you are new to the language, or programming in general</p>
</blockquote>
<p>Structs have zero memory overhead. What that means is that in memory, each struct field is laid out sequentially. No metadata regarding the struct's name or other properties is preserved at runtime. In other words, structs are compile-time constructs. This is the same in Rust, but different in other languages with runtimes like Java.</p>
<h2 id="tuples"><a class="header" href="#tuples">Tuples</a></h2>
<p>Tuples are a <a href="basics/./built_in_types.html#tuple-types">basic static-length type</a> which contain multiple different types within themselves. The type of a tuple is defined by the types of the values within it, and a tuple can contain basic types as well as structs and enums.</p>
<p>You can access values directly by using the <code>.</code> syntax. Moreover, multiple variables can be extracted from a tuple using the destructuring syntax.</p>
<pre><code class="language-sway">library tuples;

fn tuple() {
    // You can declare the types youself
    let tuple1: (u8, bool, u64) = (100, false, 10000);

    // Or have the types be inferred
    let mut tuple2 = (5, true, (&quot;Sway&quot;, 8));

    // Retrieve values from tuples
    let number = tuple1.0;
    let sway = tuple2.2.1;

    // Destructure the values from the tuple into variables
    let (n1, truthness, n2) = tuple1;

    // If you do not care about specific values then use &quot;_&quot;
    let (_, truthness, _) = tuple2;

    // Internally mutate the tuple
    tuple2.1 = false;

    // Or change the values all at once (must keep the same data types)
    tuple2 = (9, false, (&quot;Fuel&quot;, 99));
}
</code></pre>
<h2 id="enums"><a class="header" href="#enums">Enums</a></h2>
<p><em>Enumerations</em>, or <em>enums</em>, are also known as <em>sum types</em>. An enum is a type that could be one of several variants. To declare an enum, you enumerate all potential variants.</p>
<p>Here, we have defined five potential colors. Each enum variant is just the color name. As there is no extra data associated with each variant, we say that each variant is of type <code>()</code>, or unit.</p>
<blockquote>
<p><strong>Note</strong>
enum instantiation does not require the <code>~</code> tilde syntax</p>
</blockquote>
<pre><code class="language-sway">library basic_enum;

// Declare the enum
enum Color {
    Blue: (),
    Green: (),
    Red: (),
    Silver: (),
    Grey: (),
}

fn main() {
    // To instantiate a variable with the value of an enum the syntax is
    let blue = Color::Blue;
    let silver = Color::Silver;
}
</code></pre>
<h3 id="enums-of-structs"><a class="header" href="#enums-of-structs">Enums of Structs</a></h3>
<p>It is also possible to have an enum variant contain extra data. Take a look at this more substantial example, which combines struct declarations with enum variants:</p>
<pre><code class="language-sway">library enum_of_structs;

struct Item {
    price: u64,
    amount: u64,
    id: u64,
}

enum MyEnum {
    Item: Item,
}

fn main() {
    let my_enum = MyEnum::Item(Item {
        price: 5,
        amount: 2,
        id: 42,
    });
}
</code></pre>
<h3 id="enums-of-enums"><a class="header" href="#enums-of-enums">Enums of Enums</a></h3>
<p>It is possible to define enums of enums:</p>
<pre><code class="language-sway">library enum_of_enums;

pub enum Error {
    StateError: StateError,
    UserError: UserError,
}

pub enum StateError {
    Void: (),
    Pending: (),
    Completed: (),
}

pub enum UserError {
    InsufficientPermissions: (),
    Unauthorized: (),
}
</code></pre>
<h4 id="preferred-usage"><a class="header" href="#preferred-usage">Preferred usage</a></h4>
<p>The preferred way to use enums is to use the individual (not nested) enums directly because they are easy to follow and the lines are short:</p>
<pre><code class="language-sway">library enums_preferred;

dep enum_of_enums;
use enum_of_enums::{StateError, UserError};

fn preferred() {
    let error1 = StateError::Void;
    let error2 = UserError::Unauthorized;
}
</code></pre>
<h4 id="inadvisable"><a class="header" href="#inadvisable">Inadvisable</a></h4>
<p>If you wish to use the nested form of enums via the <code>Error</code> enum from the example above, then you can instantiate them into variables using the following syntax:</p>
<pre><code class="language-sway">library enums_avoid;

dep enum_of_enums;
use enum_of_enums::{Error, StateError, UserError};

fn avoid() {
    let error1 = Error::StateError(StateError::Void);
    let error2 = Error::UserError(UserError::Unauthorized);
}
</code></pre>
<p>Key points to note:</p>
<ul>
<li>You must import all of the enums you need instead of just the <code>Error</code> enum</li>
<li>The lines may get unnecessarily long (depending on the names)</li>
<li>The syntax is not the most ergonomic</li>
</ul>
<h3 id="enum-memory-layout"><a class="header" href="#enum-memory-layout">Enum Memory Layout</a></h3>
<blockquote>
<p><strong>Note</strong>
This information is not vital if you are new to the language, or programming in general.</p>
</blockquote>
<p>Enums do have some memory overhead. To know which variant is being represented, Sway stores a one-word (8-byte) tag for the enum variant. The space reserved after the tag is equivalent to the size of the <em>largest</em> enum variant. So, to calculate the size of an enum in memory, add 8 bytes to the size of the largest variant. For example, in the case of <code>Color</code> above, where the variants are all <code>()</code>, the size would be 8 bytes since the size of the largest variant is 0 bytes.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="methods-and-associated-functions"><a class="header" href="#methods-and-associated-functions">Methods and Associated Functions</a></h1>
<p>Methods are similar to functions in that we declare them with the <code>fn</code> keyword and they have parameters and return a value. However, unlike functions, <em>Methods</em> are defined within the context of a struct (or enum), and either refers to that type or mutates it. The first parameter of a method is always <code>self</code>, which represents the instance of the struct the method is being called on.</p>
<p><em>Associated functions</em> are very similar to <em>methods</em>, in that they are also defined in the context of a struct or enum, but they do not actually use any of the data in the struct and as a result do not take <em>self</em> as a parameter. Associated functions could be standalone functions, but they are included in a specific type for organizational or semantic reasons.</p>
<p>To declare methods and associated functions for a struct or enum, use an <em>impl block</em>. Here, <code>impl</code> stands for implementation.</p>
<pre><code class="language-sway">script;

struct Foo {
    bar: u64,
    baz: bool,
}

impl Foo {
    // this is a _method_, as it takes `self` as a parameter.
    fn is_baz_true(self) -&gt; bool {
        self.baz
    }

    // this is an _associated function_, since it does not take `self` as a parameter.
    fn new_foo(number: u64, boolean: bool) -&gt; Foo {
        Foo {
            bar: number,
            baz: boolean,
        }
    }
}

fn main() {
    let foo = ~Foo::new_foo(42, true);
    assert(foo.is_baz_true());
}
</code></pre>
<p>Note the syntax of the associated function call: <code>~Foo::new_foo(42, true);</code>. This bit of syntax is unique to Sway: when referring to a type directly, you preface the type with a tilde (<code>~</code>). To call an associated function, refer to the type and then the function name.
To call a method, simply use dot syntax: <code>foo.iz_baz_true()</code>.</p>
<p>Similarly to <a href="basics/functions.html">free functions</a>, methods and associated functions may accept <code>ref mut</code> parameters. For example:</p>
<pre><code class="language-sway">struct Coordinates {
    x: u64,
    y: u64,
}

impl Coordinates {
    fn move_right(ref mut self, distance: u64) {
        self.x += distance;
    }
}
</code></pre>
<p>and when called:</p>
<pre><code class="language-sway">    let mut point = Coordinates { x: 1, y: 1 };
    point.move_right(5);
    assert(point.x == 6);
    assert(point.y == 1);
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="comments-and-logging"><a class="header" href="#comments-and-logging">Comments and Logging</a></h1>
<h2 id="comments"><a class="header" href="#comments">Comments</a></h2>
<p>Comments in Sway start with two slashes and continue until the end of the line. For comments that extend beyond a single line, you'll need to include <code>//</code> on each line.</p>
<pre><code class="language-sway">// hello world
</code></pre>
<pre><code class="language-sway">// let's make a couple of lines
// commented.
</code></pre>
<p>You can also place comments at the ends of lines containing code.</p>
<pre><code class="language-sway">fn main() {
    let baz = 8; // Eight is a lucky number
}
</code></pre>
<p>You can also do block comments</p>
<pre><code class="language-sway">fn main() {
    /*
    You can write on multiple lines
    like this if you want
    */
    let baz = 8;
}
</code></pre>
<h2 id="logging"><a class="header" href="#logging">Logging</a></h2>
<p>The <code>logging</code> library provides a generic <code>log</code> function that can be imported using <code>use std::logging::log</code> and used to log variables of any type. Each call to <code>log</code> appends a <code>receipt</code> to the list of receipts. There are two types of receipts that a <code>log</code> can generate: <code>Log</code> and <code>LogData</code>.</p>
<h3 id="log-receipt"><a class="header" href="#log-receipt"><code>Log</code> Receipt</a></h3>
<p>The <code>Log</code> receipt is generated for <em>non-reference</em> types, namely <code>bool</code>, <code>u8</code>, <code>u16</code>, <code>u32</code>, and <code>u64</code>. For example, logging an integer variable <code>x</code> that holds the value <code>42</code> using <code>log(x)</code> may generate the following receipt:</p>
<pre><code class="language-console">&quot;Log&quot;: {
  &quot;id&quot;: &quot;0000000000000000000000000000000000000000000000000000000000000000&quot;,
  &quot;is&quot;: 10352,
  &quot;pc&quot;: 10404,
  &quot;ra&quot;: 42,
  &quot;rb&quot;: 1018205,
  &quot;rc&quot;: 0,
  &quot;rd&quot;: 0
}
</code></pre>
<p>Note that <code>ra</code> will include the value being logged. The additional registers <code>rc</code> and <code>rd</code> will be zero when using <code>log</code> while <code>rb</code> may include a non-zero value representing a unique ID for the <code>log</code> instance. The unique ID is not meaningful on its own but allows the Rust and the TS SDKs to know the type of the data being logged, by looking up the log ID in the JSON ABI file.</p>
<h3 id="logdata-receipt"><a class="header" href="#logdata-receipt"><code>LogData</code> Receipt</a></h3>
<p><code>LogData</code> is generated for <em>reference</em> types which include all types except for the <em>non_reference</em> types mentioned above. For example, logging a <code>b256</code> variable <code>b</code> that holds the value <code>0x1111111111111111111111111111111111111111111111111111111111111111</code> using <code>log(b)</code> may generate the following receipt:</p>
<pre><code class="language-console">&quot;LogData&quot;: {
  &quot;data&quot;: &quot;1111111111111111111111111111111111111111111111111111111111111111&quot;,
  &quot;digest&quot;: &quot;02d449a31fbb267c8f352e9968a79e3e5fc95c1bbeaa502fd6454ebde5a4bedc&quot;,
  &quot;id&quot;: &quot;0000000000000000000000000000000000000000000000000000000000000000&quot;,
  &quot;is&quot;: 10352,
  &quot;len&quot;: 32,
  &quot;pc&quot;: 10444,
  &quot;ptr&quot;: 10468,
  &quot;ra&quot;: 0,
  &quot;rb&quot;: 1018194
}
</code></pre>
<p>Note that <code>data</code> in the receipt above will include the value being logged as a hexadecimal. Similarly to the <code>Log</code> receipt, additional registers are written: <code>ra</code> will always be zero when using <code>log</code>, while <code>rb</code> will contain a unique ID for the <code>log</code> instance.</p>
<blockquote>
<p><strong>Note</strong>
The Rust SDK exposes <a href="https://fuellabs.github.io/fuels-rs/master/calling-contracts/logs.html#logs">APIs</a> that allow you to retrieve the logged values and display them nicely based on their types as indicated in the JSON ABI file.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="control-flow"><a class="header" href="#control-flow">Control Flow</a></h1>
<h2 id="if-expressions"><a class="header" href="#if-expressions"><code>if</code> expressions</a></h2>
<p>Sway supports <em>if</em>, <em>else</em>, and <em>else if</em> expressions that allow you to branch your code depending on conditions.</p>
<p>For example:</p>
<pre><code class="language-sway">fn main() {
    let number = 6;

    if number % 4 == 0 {
        // do something
    } else if number % 3 == 0 {
        // do something else
    } else {
        // do something else
    }
}
</code></pre>
<h3 id="using-if-in-a-let-statement"><a class="header" href="#using-if-in-a-let-statement">Using <code>if</code> in a <code>let</code> statement</a></h3>
<p>Like Rust, <code>if</code>s are expressions in Sway. What this means is you can use <code>if</code> expressions on the right side of a <code>let</code> statement to assign the outcome to a variable.</p>
<pre><code class="language-sway">let my_data = if some_bool &lt; 10 { foo() } else { bar() };
</code></pre>
<p>Note that all branches of the <code>if</code> expression must return a value of the same type.</p>
<h3 id="match-expressions"><a class="header" href="#match-expressions"><code>match</code> expressions</a></h3>
<p>Sway supports advanced pattern matching through exhaustive <code>match</code> expressions.</p>
<pre><code class="language-sway">script;

fn foo() {}
    // do something
fn bar() {}

    // do something
enum SomeEnum {
    A: u64,
    B: bool,
    C: b256,
}

fn main() -&gt; u64 {
    let x = 5;

    // Match as an expression.
    let a = match 8 {
        7 =&gt; 4,
        9 =&gt; 5,
        8 =&gt; 6,
        _ =&gt; 100,
    };

    // Match as a statement for control flow.
    match x {
        5 =&gt; foo(),
        _ =&gt; bar(),
    };

    // Match an enum
    let e = SomeEnum::A(42);
    let v = match e {
        SomeEnum::A(val) =&gt; val,
        SomeEnum::B(true) =&gt; 1,
        SomeEnum::B(false) =&gt; 0,
        _ =&gt; 0,
    };

    // Match as expression used for a return.
    match 42 {
        0 =&gt; 24,
        foo =&gt; foo,
    }
}
</code></pre>
<h2 id="loops"><a class="header" href="#loops">Loops</a></h2>
<h3 id="while"><a class="header" href="#while"><code>while</code></a></h3>
<p>Loops in Sway are currently limited to <code>while</code> loops. This is what they look like:</p>
<pre><code class="language-sway">while counter &lt; 10 {
    counter = counter + 1;
}
</code></pre>
<p>You need the <code>while</code> keyword, some condition (<code>value &lt; 10</code> in this case) which will be evaluated each iteration, and a block of code inside the curly braces (<code>{...}</code>) to execute each iteration.</p>
<h3 id="break-and-continue"><a class="header" href="#break-and-continue"><code>break</code> and <code>continue</code></a></h3>
<p><code>break</code> and <code>continue</code> keywords are available to use inside the body of a <code>while</code> loop. The purpose of the <code>break</code> statement is to break out of a loop early:</p>
<pre><code class="language-sway">fn break_example() -&gt; u64 {
    let mut counter = 1;
    let mut sum = 0;
    let num = 10;
    while true {
        if counter &gt; num {
            break;
        }
        sum += counter;
        counter += 1;
    }
    sum // 1 + 2 + .. + 10 = 55
}
</code></pre>
<p>The purpose of the <code>continue</code> statement is to skip a portion of a loop in an iteration and jump directly into the next iteration:</p>
<pre><code class="language-sway">fn continue_example() -&gt; u64 {
    let mut counter = 0;
    let mut sum = 0;
    let num = 10;
    while counter &lt; num {
        counter += 1;
        if counter % 2 == 0 {
            continue;
        }
        sum += counter;
    }
    sum // 1 + 3 + .. + 9 = 25
}
</code></pre>
<h3 id="nested-loops"><a class="header" href="#nested-loops">Nested loops</a></h3>
<p>You can also use nested <code>while</code> loops if needed:</p>
<pre><code class="language-sway">while condition_1 == true {
    // do stuff...
    while condition_2 == true {
        // do more stuff...
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="blockchain-development-with-sway"><a class="header" href="#blockchain-development-with-sway">Blockchain Development with Sway</a></h1>
<p>Sway is fundamentally a blockchain language. Because of this, it has some features and requirements that you may not have seen in general-purpose programming languages.</p>
<p>These are also some concepts related to the FuelVM and Fuel ecosystem that you may utilize when writing Sway.</p>
<ul>
<li><a href="blockchain-development/./hashing_and_cryptography.html">Hashing and Cryptography</a></li>
<li><a href="blockchain-development/./storage.html">Contract Storage</a></li>
<li><a href="blockchain-development/./purity.html">Function Purity</a></li>
<li><a href="blockchain-development/./identifiers.html">Identifiers</a></li>
<li><a href="blockchain-development/./native_assets.html">Native Assets</a></li>
<li><a href="blockchain-development/./access_control.html">Access Control</a></li>
<li><a href="blockchain-development/./calling_contracts.html">Calling Contracts</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hashing-and-cryptography"><a class="header" href="#hashing-and-cryptography">Hashing and Cryptography</a></h1>
<p>The Sway standard library provides easy access to a selection of cryptographic hash functions (<code>sha256</code> and EVM-compatible <code>keccak256</code>), and EVM-compatible <code>secp256k1</code>-based signature recovery operations.</p>
<h2 id="hashing"><a class="header" href="#hashing">Hashing</a></h2>
<pre><code class="language-sway">script;

use core::num::*;
use std::{hash::{keccak256, sha256}, logging::log};

const VALUE_A = 0x9280359a3b96819889d30614068715d634ad0cf9bba70c0f430a8c201138f79f;

enum Location {
    Earth: (),
    Mars: (),
}

struct Person {
    name: str[4],
    age: u64,
    alive: bool,
    location: Location,
    stats: Stats,
    some_tuple: (bool, u64),
    some_array: [u64; 2],
    some_b256: b256,
}

struct Stats {
    strength: u64,
    agility: u64,
}

fn main() {
    let zero = ~b256::min();
    // Use the generic sha256 to hash some integers
    let sha_hashed_u8 = sha256(~u8::max());
    let sha_hashed_u16 = sha256(~u16::max());
    let sha_hashed_u32 = sha256(~u32::max());
    let sha_hashed_u64 = sha256(~u64::max());

    // Or hash a b256
    let sha_hashed_b256 = sha256(VALUE_A);

    // You can hash booleans too
    let sha_hashed_bool = sha256(true);

    // Strings are not a problem either
    let sha_hashed_str = sha256(&quot;Fastest Modular Execution Layer!&quot;);

    // Tuples of any size work too
    let sha_hashed_tuple = sha256((true, 7));

    // As do arrays
    let sha_hashed_array = sha256([4, 5, 6]);

    // Enums work too
    let sha_hashed_enum = sha256(Location::Earth);

    // Complex structs are not a problem
    let sha_hashed_struct = sha256(Person {
        name: &quot;John&quot;,
        age: 9000,
        alive: true,
        location: Location::Mars,
        stats: Stats {
            strength: 10,
            agility: 9,
        },
        some_tuple: (true, 8),
        some_array: [17, 76],
        some_b256: zero,
    });

    log(sha_hashed_u8);
    log(sha_hashed_u16);
    log(sha_hashed_u32);
    log(sha_hashed_u64);
    log(sha_hashed_b256);
    log(sha_hashed_bool);
    log(sha_hashed_str);
    log(sha_hashed_tuple);
    log(sha_hashed_array);
    log(sha_hashed_enum);
    log(sha_hashed_struct);

    // Use the generic keccak256 to hash some integers
    let keccak_hashed_u8 = keccak256(~u8::max());
    let keccak_hashed_u16 = keccak256(~u16::max());
    let keccak_hashed_u32 = keccak256(~u32::max());
    let keccak_hashed_u64 = keccak256(~u64::max());

    // Or hash a b256
    let keccak_hashed_b256 = keccak256(VALUE_A);

    // You can hash booleans too
    let keccak_hashed_bool = keccak256(true);

    // Strings are not a problem either
    let keccak_hashed_str = keccak256(&quot;Fastest Modular Execution Layer!&quot;);

    // Tuples of any size work too
    let keccak_hashed_tuple = keccak256((true, 7));

    // As do arrays
    let keccak_hashed_array = keccak256([4, 5, 6]);

    // Enums work too
    let keccak_hashed_enum = keccak256(Location::Earth);

    // Complex structs are not a problem
    let keccak_hashed_struct = keccak256(Person {
        name: &quot;John&quot;,
        age: 9000,
        alive: true,
        location: Location::Mars,
        stats: Stats {
            strength: 10,
            agility: 9,
        },
        some_tuple: (true, 8),
        some_array: [17, 76],
        some_b256: zero,
    });

    log(keccak_hashed_u8);
    log(keccak_hashed_u16);
    log(keccak_hashed_u32);
    log(keccak_hashed_u64);
    log(keccak_hashed_b256);
    log(keccak_hashed_bool);
    log(keccak_hashed_str);
    log(keccak_hashed_tuple);
    log(keccak_hashed_array);
    log(keccak_hashed_enum);
    log(keccak_hashed_struct);
}
</code></pre>
<h2 id="signature-recovery"><a class="header" href="#signature-recovery">Signature Recovery</a></h2>
<pre><code class="language-sway">script;

use std::{b512::B512, ecr::{ec_recover, ec_recover_address, EcRecoverError}, logging::log};

const MSG_HASH = 0xee45573606c96c98ba970ff7cf9511f1b8b25e6bcd52ced30b89df1e4a9c4323;

fn main() {
    let hi = 0xbd0c9b8792876713afa8bff383eebf31c43437823ed761cc3600d0016de5110c;
    let lo = 0x44ac566bd156b4fc71a4a4cb2655d3dd360c695edb17dc3b64d611e122fea23d;
    let signature: B512 = ~B512::from(hi, lo);

    // A recovered public key pair.
    let public_key = ec_recover(signature, MSG_HASH);

    // A recovered Fuel address.
    let result_address: Result&lt;Address, EcRecoverError&gt; = ec_recover_address(signature, MSG_HASH);
    if let Result::Ok(address) = result_address {
        log(address.value);
    } else {
        revert(0);
    }
}
</code></pre>
<blockquote>
<p><strong>Note</strong>: Recovery of EVM addresses is also supported via <code>std::vm::evm</code>.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="storage"><a class="header" href="#storage">Storage</a></h1>
<p>When developing a <a href="blockchain-development/../sway-program-types/smart_contracts.html">smart contract</a>, you will typically need some sort of persistent storage. In this case, persistent storage, often just called <em>storage</em> in this context, is a place where you can store values that are persisted inside the contract itself. This is in contrast to a regular value in <em>memory</em>, which disappears after the contract exits.</p>
<p>Put in conventional programming terms, contract storage is like saving data to a hard drive. That data is saved even after the program which saved it exits. That data is persistent. Using memory is like declaring a variable in a program: it exists for the duration of the program and is non-persistent.</p>
<p>Some basic use cases of storage include declaring an owner address for a contract and saving balances in a wallet.</p>
<h2 id="storage-accesses-via-the-storage-keyword"><a class="header" href="#storage-accesses-via-the-storage-keyword">Storage Accesses Via the <code>storage</code> Keyword</a></h2>
<p>Declaring variables in storage requires a <code>storage</code> declaration that contains a list of all your variables, their types, and their initial values as follows:</p>
<pre><code class="language-sway">struct Type1 {
    x: u64,
    y: u64,
}

struct Type2 {
    w: b256,
    z: bool,
}

storage {
    var1: Type1 = Type1 { x: 0, y: 0 },
    var2: Type2 = Type2 {
        w: 0x0000000000000000000000000000000000000000000000000000000000000000,
        z: false,
    },
}

</code></pre>
<p>To write into a storage variable, you need to use the <code>storage</code> keyword as follows:</p>
<pre><code class="language-sway">    #[storage(write)]
    fn store_something() {
        storage.var1.x = 42;
        storage.var1.y = 77;
        storage.var2.w = 0x1111111111111111111111111111111111111111111111111111111111111111;
        storage.var2.z = true;
    }
</code></pre>
<p>To read a storage variable, you also need to use the <code>storage</code> keyword as follows:</p>
<pre><code class="language-sway">    #[storage(read)]
    fn get_something() -&gt; (u64, u64, b256, bool) {
        (
            storage.var1.x,
            storage.var1.y,
            storage.var2.w,
            storage.var2.z,
        )
    }
</code></pre>
<h2 id="storage-maps"><a class="header" href="#storage-maps">Storage Maps</a></h2>
<p>Generic storage maps are available in the standard library as <code>StorageMap&lt;K, V&gt;</code> which have to be defined inside a <code>storage</code> block and allow you to call <code>insert()</code> and <code>get()</code> to insert values at specific keys and get those values respectively. Refer to <a href="blockchain-development/../common-collections/storage_map.html">Storage Maps</a> for more information about <code>StorageMap&lt;K, V&gt;</code>.</p>
<h2 id="manual-storage-management"><a class="header" href="#manual-storage-management">Manual Storage Management</a></h2>
<p>It is possible to leverage FuelVM storage operations directly using the <code>std::storage::store</code> and <code>std::storage::get</code> functions provided in the standard library. With this approach you will have to manually assign the internal key used for storage. An example is as follows:</p>
<pre><code class="language-sway">contract;

use std::storage::{get, store};

abi StorageExample {
    #[storage(write)]
    fn store_something(amount: u64);

    #[storage(read)]
    fn get_something() -&gt; u64;
}

const STORAGE_KEY: b256 = 0x0000000000000000000000000000000000000000000000000000000000000000;

impl StorageExample for Contract {
    #[storage(write)]
    fn store_something(amount: u64) {
        store(STORAGE_KEY, amount);
    }

    #[storage(read)]
    fn get_something() -&gt; u64 {
        let value = get::&lt;u64&gt;(STORAGE_KEY);
        value
    }
}
</code></pre>
<blockquote>
<p><strong>Note</strong>: Though these functions can be used for any data type, they should mostly be used for arrays because arrays are not yet supported in <code>storage</code> blocks. Note, however, that <em>all</em> data types can be used as types for keys and/or values in <code>StorageMap&lt;K, V&gt;</code> without any restrictions.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="purity"><a class="header" href="#purity">Purity</a></h1>
<p>A function is <em>pure</em> if it does not access any <a href="blockchain-development/./storage.html">persistent storage</a>. Conversely, the function is <em>impure</em> if it does access any storage. Naturally, as storage is only available in smart contracts, impure functions cannot be used in predicates, scripts, or libraries. A pure function cannot call an impure function.</p>
<p>In Sway, functions are pure by default but can be opted into impurity via the <code>storage</code> function attribute. The <code>storage</code> attribute may take <code>read</code> and/or <code>write</code> arguments indicating which type of access the function requires.</p>
<pre><code class="language-sway">#[storage(read)]
fn get_amount() -&gt; u64 {
    ...
}

#[storage(read, write)]
fn increment_amount(increment: u64) -&gt; u64 {
    ...
}
</code></pre>
<p>Impure functions which call other impure functions must have at least the same storage privileges or a superset of those for the function called. For example, to call a function with write access a caller must also have write access, or both read and write access. To call a function with read and write access the caller must also have both privileges.</p>
<p>The <code>storage</code> attribute may also be applied to <a href="blockchain-development/../basics/methods_and_associated_functions.html">methods and associated functions</a>, <a href="blockchain-development/../advanced/traits.html">trait</a> and <a href="blockchain-development/../sway-program-types/smart_contracts.html#the-abi-declaration">ABI</a> declarations.</p>
<p>A pure function gives you some guarantees: you will not incur excessive storage gas costs, the compiler can apply additional optimizations, and they are generally easy to reason about and audit. <a href="https://docs.soliditylang.org/en/v0.8.10/contracts.html#pure-functions">A similar concept exists in Solidity</a>. Note that Solidity refers to contract storage as <em>contract state</em>, and in the Sway/Fuel ecosystem, these two terms are largely interchangeable.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="identifiers"><a class="header" href="#identifiers">Identifiers</a></h1>
<p>Addresses in Sway are similar to EVM addresses. The two major differences are:</p>
<ol>
<li>Sway addresses are 32 bytes long (instead of 20)</li>
<li>Sway addresses are computed with the SHA-256 hash of the public key instead of the keccak-256 hash.</li>
</ol>
<p>Contracts, on the other hand, are uniquely identified with a contract ID rather than an address. A contract's ID is also 32 bytes long and is calculated <a href="https://github.com/FuelLabs/fuel-specs/blob/master/specs/protocol/identifiers.md#contract-id">here</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="native-support-for-multiple-asset-types"><a class="header" href="#native-support-for-multiple-asset-types">Native Support for Multiple Asset Types</a></h1>
<p>The FuelVM has built-in support for working with multiple assets.</p>
<p>What does this mean in practice?</p>
<p>As in the EVM, sending ETH to an address or contract is an operation built into the FuelVM, meaning it doesn't rely on the existence of some token smart contract to update balances to track ownership.</p>
<p>However, unlike the EVM, the process for sending <em>any</em> native asset is the same. This means that while you would still need a smart contract to handle the minting and burning of fungible tokens, the sending and receiving of these tokens can be done independently of the token contract.</p>
<h2 id="liquidity-pool-example"><a class="header" href="#liquidity-pool-example">Liquidity Pool Example</a></h2>
<p>All contracts in Fuel can mint and burn their own native token. Contracts can also receive and transfer any native asset including their own. Internal balances of all native assets pushed through calls or minted by the contract are tracked by the FuelVM and can be queried at any point using the balance_of function from the <code>std</code> library. Therefore, there is no need for any manual accounting of the contract's balances using persistent storage.</p>
<p>The <code>std</code> library provides handy methods for accessing Fuel's native assset operations.</p>
<p>In this example, we show a basic liquidity pool contract minting its own native asset LP token.</p>
<pre><code class="language-sway">contract;

use std::{
    context::call_frames::{
        contract_id,
        msg_asset_id,
    },
    context::msg_amount,
    token::{
        mint_to_address,
        transfer_to_address,
    },
};

abi LiquidityPool {
    fn deposit(recipient: Address);
    fn withdraw(recipient: Address);
}

const BASE_TOKEN = ~ContractId::from(0x9ae5b658754e096e4d681c548daf46354495a437cc61492599e33fc64dcdc30c);

impl LiquidityPool for Contract {
    fn deposit(recipient: Address) {
        assert(msg_asset_id() == BASE_TOKEN);
        assert(msg_amount() &gt; 0);

        // Mint two times the amount.
        let amount_to_mint = msg_amount() * 2;

        // Mint some LP token based upon the amount of the base token.
        mint_to_address(amount_to_mint, recipient);
    }

    fn withdraw(recipient: Address) {
        assert(msg_asset_id() == contract_id());
        assert(msg_amount() &gt; 0);

        // Amount to withdraw.
        let amount_to_transfer = msg_amount() / 2;

        // Transfer base token to recipient.
        transfer_to_address(amount_to_transfer, BASE_TOKEN, recipient);
    }
}
</code></pre>
<h2 id="native-token-example"><a class="header" href="#native-token-example">Native Token Example</a></h2>
<p>In this example, we show a native token contract with more minting, burning and transferring capabilities.</p>
<pre><code class="language-sway">contract;

use std::{context::*, token::*};

abi NativeAssetToken {
    fn mint_coins(mint_amount: u64);
    fn burn_coins(burn_amount: u64);
    fn force_transfer_coins(coins: u64, asset_id: ContractId, target: ContractId);
    fn transfer_coins_to_output(coins: u64, asset_id: ContractId, recipient: Address);
    fn deposit();
    fn get_balance(target: ContractId, asset_id: ContractId) -&gt; u64;
    fn mint_and_send_to_contract(amount: u64, destination: ContractId);
    fn mint_and_send_to_address(amount: u64, recipient: Address);
}

impl NativeAssetToken for Contract {
    /// Mint an amount of this contracts native asset to the contracts balance.
    fn mint_coins(mint_amount: u64) {
        mint(mint_amount);
    }

    /// Burn an amount of this contracts native asset.
    fn burn_coins(burn_amount: u64) {
        burn(burn_amount);
    }

    /// Transfer coins to a target contract.
    fn force_transfer_coins(coins: u64, asset_id: ContractId, target: ContractId) {
        force_transfer_to_contract(coins, asset_id, target);
    }

    /// Transfer coins to a transaction output to be spent later.
    fn transfer_coins_to_output(coins: u64, asset_id: ContractId, recipient: Address) {
        transfer_to_address(coins, asset_id, recipient);
    }

    /// Get the internal balance of a specific coin at a specific contract.
    fn get_balance(target: ContractId, asset_id: ContractId) -&gt; u64 {
        balance_of(target, asset_id)
    }

    /// Deposit tokens back into the contract.
    fn deposit() {
        assert(msg_amount() &gt; 0);
    }

    /// Mint and send this contracts native token to a destination contract.
    fn mint_and_send_to_contract(amount: u64, destination: ContractId) {
        mint_to_contract(amount, destination);
    }

    /// Mind and send this contracts native token to a destination address.
    fn mint_and_send_to_address(amount: u64, recipient: Address) {
        mint_to_address(amount, recipient);
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="access-control"><a class="header" href="#access-control">Access Control</a></h1>
<p>Smart contracts require the ability to restrict access to and identify certain users or contracts. Unlike account-based blockchains, transactions in UTXO-based blockchains (i.e. Fuel) do not necessarily have a unique transaction sender. Additional logic is needed to handle this difference, and is provided by the standard library.</p>
<h2 id="msg_sender"><a class="header" href="#msg_sender"><code>msg_sender</code></a></h2>
<p>To deliver an experience akin to the EVM's access control, the <code>std</code> library provides a <code>msg_sender</code> function, which identifies a unique caller based upon the call and/or transaction input data.</p>
<pre><code class="language-sway">contract;

use std::chain::auth::{AuthError, msg_sender};

abi MyOwnedContract {
    fn receive(field_1: u64) -&gt; bool;
}

const OWNER = ~Address::from(0x9ae5b658754e096e4d681c548daf46354495a437cc61492599e33fc64dcdc30c);

impl MyOwnedContract for Contract {
    fn receive(field_1: u64) -&gt; bool {
        let sender: Result&lt;Identity, AuthError&gt; = msg_sender();
        if let Identity::Address(addr) = sender.unwrap() {
            assert(addr == OWNER);
        } else {
            revert(0);
        }

        true
    }
}
</code></pre>
<p>The <code>msg_sender</code> function works as follows:</p>
<ul>
<li>If the caller is a contract, then <code>Result::Ok(Sender)</code> is returned with the <code>ContractId</code> sender variant.</li>
<li>If the caller is external (i.e. from a script), then all coin input owners in the transaction are checked. If all owners are the same, then <code>Result::Ok(Sender)</code> is returned with the <code>Address</code> sender variant.</li>
<li>If the caller is external and coin input owners are different, then the caller cannot be determined and a <code>Result::Err(AuthError)</code> is returned.</li>
</ul>
<h2 id="contract-ownership"><a class="header" href="#contract-ownership">Contract Ownership</a></h2>
<p>Many contracts require some form of ownership for access control. To accomplish this, it is recommended that a storage variable of type <code>Option&lt;Identity&gt;</code> is used to keep track of the owner. This allows setting and revoking ownership using the variants <code>Some(..)</code> and <code>None</code> respectively. This is better, safer, and more readable than using the <code>Identity</code> type directly where revoking ownership has to be done using some magic value such as <code>std::constants::ZERO_B256</code> or otherwise.</p>
<p>The following is an example of how to properly set ownership of a contract:</p>
<pre><code class="language-sway">    #[storage(write)]
    fn set_owner(identity: Identity) {
        storage.owner = Option::Some(identity);
    }
</code></pre>
<p>The following is an example of how to properly revoke ownership of a contract:</p>
<pre><code class="language-sway">    #[storage(write)]
    fn revoke_ownership() {
        storage.owner = Option::None();
    }
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="calling-contracts"><a class="header" href="#calling-contracts">Calling Contracts</a></h1>
<p>Smart contracts can be <em>called</em> by other contracts or scripts. In the FuelVM, this is done primarily with the <a href="https://github.com/FuelLabs/fuel-specs/blob/master/specs/vm/instruction_set.md#call-call-contract"><code>call</code></a> instruction.</p>
<p>Sway provides a nice way to manage callable interfaces with its <code>abi</code> system. The Fuel ABI specification can be found <a href="https://github.com/FuelLabs/fuel-specs/blob/master/specs/protocol/abi.md">here</a>.</p>
<h2 id="example-1"><a class="header" href="#example-1">Example</a></h2>
<p>Here is an example of a contract calling another contract in Sway. A script can call a contract in the same way.</p>
<pre><code class="language-sway">// ./contract_a.sw
contract;

abi ContractA {
    fn receive(field_1: bool, field_2: u64) -&gt; u64;
}

impl ContractA for Contract {
    fn receive(field_1: bool, field_2: u64) -&gt; u64 {
        assert(field_1 == true);
        assert(field_2 &gt; 0);
        return_45()
    }
}

fn return_45() -&gt; u64 {
  45
}
</code></pre>
<pre><code class="language-sway">// ./contract_b.sw
contract;

use contract_a::ContractA;

abi ContractB {
    fn make_call();
}

const contract_id = 0x79fa8779bed2f36c3581d01c79df8da45eee09fac1fd76a5a656e16326317ef0;

impl ContractB for Contract {
    fn make_call() {
      let x = abi(ContractA, contract_id);
      let return_value = x.receive(true, 3); // will be 45
    }
}
</code></pre>
<blockquote>
<p><strong>Note</strong>: The ABI is for external calls only therefore you cannot define a method in the ABI and call it in the same contract. If you want to define a function for a contract, but keep it private so that only your contract can call it, you can define it outside of the <code>impl</code> and call it inside the contract, similar to the <code>return_45()</code> function above.</p>
</blockquote>
<h2 id="advanced-calls"><a class="header" href="#advanced-calls">Advanced Calls</a></h2>
<p>All calls forward a gas stipend, and may additionally forward one native asset with the call.</p>
<p>Here is an example of how to specify the amount of gas (<code>gas</code>), the asset ID of the native asset (<code>asset_id</code>), and the amount of the native asset (<code>amount</code>) to forward:</p>
<pre><code class="language-sway">script;

abi MyContract {
    fn foo(field_1: bool, field_2: u64);
}

fn main() {
    let x = abi(MyContract, 0x79fa8779bed2f36c3581d01c79df8da45eee09fac1fd76a5a656e16326317ef0);
    let asset_id = 0x7777_7777_7777_7777_7777_7777_7777_7777_7777_7777_7777_7777_7777_7777_7777_7777;
    x.foo {
        gas: 5000, asset_id: asset_id, amount: 5000
    }
    (true, 3);
}
</code></pre>
<h2 id="handling-re-entrancy"><a class="header" href="#handling-re-entrancy">Handling Re-entrancy</a></h2>
<p>A common attack vector for smart contracts is <a href="https://docs.soliditylang.org/en/v0.8.4/security-considerations.html#re-entrancy">re-entrancy</a>. Similar to the EVM, the FuelVM allows for re-entrancy.</p>
<p>A <em>stateless</em> re-entrancy guard is included in the Sway standard library. The guard will panic (revert) at run time if re-entrancy is detected.</p>
<pre><code class="language-sway">contract;

use std::reentrancy::reentrancy_guard;

abi MyContract {
    fn some_method();
}

impl ContractB for Contract {
    fn some_method() {
        reentrancy_guard();
        // do something
    }
}
</code></pre>
<h2 id="differences-from-the-evm"><a class="header" href="#differences-from-the-evm">Differences from the EVM</a></h2>
<p>While the Fuel contract calling paradigm is similar to the EVM's (using an ABI, forwarding gas and data), it differs in <em>two</em> key ways:</p>
<ol>
<li>
<p><a href="blockchain-development/./native_assets.html"><strong>Native assets</strong></a>: FuelVM calls can forward any native asset not just base asset.</p>
</li>
<li>
<p><strong>No data serialization</strong>: Contract calls in the FuelVM do not need to serialize data to pass it between contracts; instead they simply pass a pointer to the data. This is because the FuelVM has a shared global memory which all call frames can read from.</p>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="advanced-concepts"><a class="header" href="#advanced-concepts">Advanced Concepts</a></h1>
<p>Advanced concepts.</p>
<ul>
<li><a href="advanced/./generic_types.html">Generic Types</a></li>
<li><a href="advanced/./traits.html">Traits</a></li>
<li><a href="advanced/./trait_constraints.html">Trait Constraints</a></li>
<li><a href="advanced/./assembly.html">Assembly</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="generic-types"><a class="header" href="#generic-types">Generic Types</a></h1>
<h2 id="basics"><a class="header" href="#basics">Basics</a></h2>
<p>In Sway, generic types follow a very similar pattern to those in Rust. Let's look at some example syntax,
starting with a generic function:</p>
<pre><code class="language-sway">fn noop&lt;T&gt;(argument: T) -&gt; T {
    argument
}
</code></pre>
<p>Here, the <code>noop()</code> function trivially returns exactly what was given to it. <code>T</code> is a <em>type parameter</em>, and it says
that this function exists for all types T. More formally, this function could be typed as:</p>
<pre><code class="language-math">noop :: âˆ€T. T -&gt; T
</code></pre>
<p>Generic types are a way to refer to types <em>in general</em>, meaning without specifying a single type. Our <code>noop</code> function
would work with any type in the language, so we don't need to specify <code>noop(argument: u8) -&gt; u8</code>, <code>noop(argument: u16) -&gt; u16</code>, etc.</p>
<h2 id="code-generation"><a class="header" href="#code-generation">Code Generation</a></h2>
<p>One question that arises when dealing with generic types is: how does the assembly handle this? There are a few approaches to handling
generic types at the lowest level. Sway uses a technique called <a href="https://en.wikipedia.org/wiki/Monomorphization">monomorphization</a>. This
means that the generic function is compiled to a non-generic version for every type it is called on. In this way, generic functions are
purely shorthand for the sake of ergonomics.</p>
<h2 id="trait-constraints"><a class="header" href="#trait-constraints">Trait Constraints</a></h2>
<blockquote>
<p><strong>Note</strong> Trait constraints <a href="https://github.com/FuelLabs/sway/issues/970">have not yet been implemented</a></p>
</blockquote>
<p>Important background to know before diving into trait constraints is that the <code>where</code> clause can be used to specify the required traits for the generic argument. So, when writing something like a <code>HashMap</code> you may
want to specify that the generic argument implements a <code>Hash</code> trait.</p>
<pre><code class="language-sway">fn get_hashmap_key&lt;T&gt;(Key : T) -&gt; b256
    where T: Hash
{
    // Code within here can then call methods associated with the Hash trait on Key
}
</code></pre>
<p>Of course, our <code>noop()</code> function is not useful. Often, a programmer will want to declare functions over types which satisfy certain traits.
For example, let's try to implement the successor function, <code>successor()</code>, for all numeric types.</p>
<pre><code class="language-sway">fn successor&lt;T&gt;(argument: T)
    where T: Add
{
    argument + 1
}
</code></pre>
<p>Run <code>forc build</code>, and you will get:</p>
<pre><code class="language-console">.. |
 9 |   where T: Add
10 |   {
11 |       argument + 1                                        
   |                  ^ Mismatched types: expected type &quot;T&quot; but saw type &quot;u64&quot;
12 |   }
13 |
</code></pre>
<p>This is because we don't know for a fact that <code>1</code>, which in this case defaulted to <code>1u64</code>, actually can be added to <code>T</code>. What if <code>T</code> is <code>f64</code>? Or <code>b256</code>? What does it mean to add <code>1u64</code> in these cases?</p>
<p>We can solve this problem with another trait constraint. We can only find the successor of some value of type <code>T</code> if that type <code>T</code> defines some incrementor. Let's make a trait:</p>
<pre><code class="language-sway">trait Incrementable {
    /// Returns the value to add when calculating the successor of a value.
    fn incrementor() -&gt; Self;
}
</code></pre>
<p>Now, we can modify our <code>successor()</code> function:</p>
<pre><code class="language-sway">fn successor&lt;T&gt;(argument: T)
    where T: Add,
          T: Incrementable
{
    argument + ~T::incrementor()
}
</code></pre>
<p><em>(There's a little bit of new syntax here. When directly referring to a type to execute a method from it, a tilde (<code>~</code>) is used. This may change in the future.)</em></p>
<h2 id="generic-structs-and-enums"><a class="header" href="#generic-structs-and-enums">Generic Structs and Enums</a></h2>
<p>Just like functions, structs and enums can be generic. Let's take a look at the standard library version of <code>Option&lt;T&gt;</code>:</p>
<pre><code class="language-sway">enum Option&lt;T&gt; {
    Some: T,
    None: (),
}
</code></pre>
<p>Just like an unconstrained generic function, this type exists for all (âˆ€) types <code>T</code>. <code>Result&lt;T, E&gt;</code> is another example:</p>
<pre><code class="language-sway">enum Result&lt;T, E&gt; {
    Ok: T,
    Err: E,
}
</code></pre>
<p>Both generic enums and generic structs can be trait constrained, as well. Consider this struct:</p>
<pre><code class="language-sway">struct Foo&lt;T&gt;
    where T: Add
{
    field_one: T,
}
</code></pre>
<h2 id="type-arguments"><a class="header" href="#type-arguments">Type Arguments</a></h2>
<p>Similar to Rust, Sway has what is colloquially known as the <a href="https://github.com/rust-lang/rust/blob/e98309298d927307c5184f4869604bd068d26183/src/test/ui/parser/bastion-of-the-turbofish.rs">turbofish</a>. The turbofish looks like this: <code>::&lt;&gt;</code> (see the little fish with bubbles behind it?). The turbofish is used to annotate types in a generic context. Say you have the following function:</p>
<pre><code class="language-sway">fn foo&lt;T, E&gt;(t: T) -&gt; Result&lt;T, E&gt; {
    Result::Ok(t)
}
</code></pre>
<p>In this code example, which is admittedly asinine, you can't possibly know what type <code>E</code> is. You'd need to provide the type manually, with a turbofish:</p>
<pre><code class="language-sway">fn foo&lt;T, E&gt;(t: T) -&gt; Result&lt;T, E&gt; {
    Result::Ok::&lt;T, MyErrorType&gt;(t)
}
</code></pre>
<p>It is also common to see the turbofish used on the function itself:</p>
<pre><code class="language-sway">fn main() {
    foo::&lt;Bar, Baz&gt;()
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="traits"><a class="header" href="#traits">Traits</a></h1>
<h2 id="declaring-a-trait"><a class="header" href="#declaring-a-trait">Declaring a Trait</a></h2>
<p>A <em>trait</em> opts a type into a certain type of behavior or functionality that can be shared among types. This allows for easy reuse of code and generic programming. If you have ever used a typeclass in Haskell, a trait in Rust, or even an interface in Java, these are similar concepts.</p>
<p>Let's take a look at some code:</p>
<pre><code class="language-sway">trait Compare {
    fn equals(self, b: Self) -&gt; bool;
} {
    fn not_equals(self, b: Self) -&gt; bool {
        !self.equals(b)
    }
}
</code></pre>
<p>We have just declared a trait called <code>Compare</code>. After the name of the trait, there are two <em>blocks</em> of code (a <em>block</em> is code enclosed in <code>{</code> curly brackets <code>}</code>). The first block is the <em>interface surface</em>. The second block is the <em>methods</em> provided by the trait. If a type can provide the methods in the interface surface, then it gets access to the methods in the trait for free! What the above trait is saying is: if you can determine if two values are equal, then for free, you can determine that they are not equal. Note that trait methods have access to the methods defined in the interface surface.</p>
<h2 id="implementing-a-trait"><a class="header" href="#implementing-a-trait">Implementing a Trait</a></h2>
<p>Ok, so I know that numbers can be equal. I want to implement my <code>Compare</code> trait for <code>u64</code>. Let's take a look at how that is done:</p>
<pre><code class="language-sway">impl Compare for u64 {
    fn equals(self, b: Self) -&gt; bool {
        self == b
    }
}
</code></pre>
<p>The above snippet declares all of the methods in the trait <code>Compare</code> for the type <code>u64</code>. Now, we have access to both the <code>equals</code> and <code>not_equals</code> methods for <code>u64</code>, as long as the trait <code>Compare</code> is in scope.</p>
<h2 id="supertraits"><a class="header" href="#supertraits">Supertraits</a></h2>
<p>When using multiple traits, scenarios often come up where one trait may require functionality from another trait. This is where supertraits come in as they allow you to require a trait when implementing another
trait (ie. a trait with a trait). A good example of this is the <code>Ord</code> trait of the <code>core</code> library of Sway. The <code>Ord</code> trait requires the <code>Eq</code> trait, so <code>Eq</code> is kept as a separate trait as one may decide to implement <code>Eq</code>
without implementing other parts of the <code>Ord</code> trait.</p>
<pre><code class="language-sway">
trait Eq {
    fn equals(self, b: Self) -&gt; bool;
}

trait Ord: Eq {
    fn gte(self, b: Self) -&gt; bool;
}

impl Ord for u64 {
    fn gte(self, b: Self) -&gt; bool {
        // As `Eq` is a supertrait of `Ord`, `Ord` can access the equals method
        self.equals(b) || self.gt(b)
    }
}
</code></pre>
<p>To require a supertrait, add a <code>:</code> after the trait name and then list the traits you would like to require and separate them with a <code>+</code>.</p>
<h2 id="use-cases"><a class="header" href="#use-cases">Use Cases</a></h2>
<h3 id="custom-types-structs-enums"><a class="header" href="#custom-types-structs-enums">Custom Types (structs, enums)</a></h3>
<p>Often, libraries and APIs have interfaces that are abstracted over a type that implements a certain trait. It is up to the consumer of the interface to implement that trait for the type they wish to use with the interface. For example, let's take a look at a trait and an interface built off of it.</p>
<pre><code class="language-sway">library games;

pub enum Suit {
    Hearts: (),
    Diamonds: (),
    Clubs: (),
    Spades: (),
}

pub trait Card {
    fn suit(self) -&gt; Suit;
    fn value(self) -&gt; u8;
}

fn play_game_with_deck&lt;T&gt;(a: Vec&lt;T&gt;) where T: Card {
    // insert some creative card game here
}
</code></pre>
<blockquote>
<p><strong>Note</strong> Trait constraints (i.e. using the <code>where</code> keyword) <a href="https://github.com/FuelLabs/sway/issues/970">have not yet been implemented</a></p>
</blockquote>
<p>Now, if you want to use the function <code>play_game_with_deck</code> with your struct, you must implement <code>Card</code> for your struct. Note that the following code example assumes a dependency <em>games</em> has been included in the <code>Forc.toml</code> file.</p>
<pre><code class="language-sway">script;

use games::*;

struct MyCard {
    suit: Suit,
    value: u8
}

impl Card for MyCard {
    fn suit(self) -&gt; Suit {
        self.suit
    }
    fn value(self) -&gt; u8 {
        self.value
    }
}

fn main() {
    let mut i = 52;
    let mut deck: Vec&lt;MyCard&gt; = Vec::with_capacity(50);
    while i &gt; 0 {
        i = i - 1;
        deck.push(MyCard { suit: generate_random_suit(), value: i % 4}
    }
    play_game_with_deck(deck);
}

fn generate_random_suit() -&gt; Suit {
  [ ... ]
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="inline-assembly-in-sway"><a class="header" href="#inline-assembly-in-sway">Inline Assembly in Sway</a></h1>
<p>While many users will never have to touch assembly language while writing sway code, it is a powerful tool that enables many advanced use-cases (ie: optimizations, building libraries, etc).</p>
<h2 id="asm-block"><a class="header" href="#asm-block">ASM Block</a></h2>
<p>In Sway, the way we use assembly inline is to declare an asm block like this:</p>
<pre><code class="language-sway">asm() {...}
</code></pre>
<p>Declaring an <code>asm</code> block is similar to declaring a function.
We can specify register names to operate on as arguments, we can perform operations within the block, and we can return a value.
Here's an example showing what this might look like:</p>
<pre><code class="language-sway">pub fn add_1(num: u32) -&gt; u32 {
    asm(r1: num, r2) {
        add r2 r1 one;
        r2: u32
    }
}
</code></pre>
<p>An <code>asm</code> block can only return a single register. If you really need to return more than one value, you can modify a tuple. Here's an example showing how can implement this <code>(u64, u64)</code>:</p>
<pre><code class="language-sway">script;

fn adder(a: u64, b: u64, c: u64) -&gt; (u64, u64) {
    let empty_tuple = (0u64, 0u64);
    asm(output: empty_tuple, r1: a, r2: b, r3: c, r4, r5) {
        add r4 r1 r2; // add a &amp; b and put the result in r4
        add r5 r2 r3; // add b &amp; c and put the result in r5
        sw output r4 i0; // store the word in r4 in output + 0 words
        sw output r5 i1; // store the word in r5 in output + 1 word
        output: (u64, u64) // return both values
    }
}

fn main() -&gt; bool {
    let (first, second) = adder(1, 2, 3);
    assert(first == 3);
    assert(second == 5);
    true
}
</code></pre>
<p>Note that this is contrived example meant to demonstrate the syntax; there's absolutely no need to use assembly to add integers!</p>
<p>Note that in the above example:</p>
<ul>
<li>we initialized the register <code>r1</code> with the value of <code>num</code>.</li>
<li>we declared a second register <code>r2</code> (you may choose any register names you want).</li>
<li>we use the <code>add</code> opcode to add <code>one</code> to the value of <code>r1</code> and store it in <code>r2</code>.</li>
<li><code>one</code> is an example of a &quot;reserved register&quot;, of which there are 16 in total. Further reading on this is linked below under &quot;Semantics&quot;.</li>
<li>we return <code>r2</code> &amp; specify the return type as being u32 (the return type is u64 by default).</li>
</ul>
<p>An important note is that the <code>ji</code> and <code>jnei</code> opcodes are not available within an <code>asm</code> block. For those looking to introduce control flow to <code>asm</code> blocks, it is recommended to surround smaller chunks of <code>asm</code> with control flow (<code>if</code>, <code>else</code>, and <code>while</code>).</p>
<h2 id="helpful-links"><a class="header" href="#helpful-links">Helpful Links</a></h2>
<p>For examples of assembly in action, check out the <a href="https://github.com/FuelLabs/sway/tree/master/sway-lib-std">Sway standard library</a>.</p>
<p>For a complete list of all instructions supported in the FuelVM: <a href="https://github.com/FuelLabs/fuel-specs/blob/master/specs/vm/instruction_set.md">Instructions</a>.</p>
<p>And to learn more about the FuelVM semantics: <a href="https://github.com/FuelLabs/fuel-specs/blob/master/specs/vm/main.md#semantics">Semantics</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="common-collections"><a class="header" href="#common-collections">Common Collections</a></h1>
<p>Swayâ€™s standard library includes a number of very useful data structures called collections. Most other data types represent one specific value, but collections can contain multiple values. Unlike the built-in array and tuple types which are allocated on the &quot;stack&quot; and cannot grow in size, the data these collections point to is stored either on the &quot;heap&quot; or in contract &quot;storage&quot;, which means the amount of data does not need to be known at compile time and can grow as the program runs. Each kind of collection has different capabilities and costs, and choosing an appropriate one for your current situation is a skill youâ€™ll develop over time. In this chapter, weâ€™ll discuss three collections that are used very often in Sway programs:</p>
<p>A vector on the heap allows you to store a variable number of values next to each other.</p>
<p>A storage vector is similar to a vector on the heap but uses persistent storage.</p>
<p>A storage map allows you to associate a value with a particular key.</p>
<p>Weâ€™ll discuss how to create and update vectors, storage vectors, and storage maps, as well as what makes each special.</p>
<ul>
<li><a href="common-collections/./vec.html">Vectors on the Heap</a></li>
<li><a href="common-collections/./storage_vec.html">Storage Vectors</a></li>
<li><a href="common-collections/./storage_map.html">Storage Maps</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="vectors-on-the-heap"><a class="header" href="#vectors-on-the-heap">Vectors on the Heap</a></h1>
<p>The first collection type weâ€™ll look at is <code>Vec&lt;T&gt;</code>, also known as a vector. Vectors allow you to store more than one value in a single data structure that puts all the values next to each other in memory. Vectors can only store values of the same type. They are useful when you have a list of items, such as the lines of text in a file or the prices of items in a shopping cart.</p>
<p><code>Vec&lt;T&gt;</code> is included in the <a href="common-collections/../introduction/standard_library.html#standard-library-prelude">standard library prelude</a> which means that there is no need to import it manually.</p>
<h2 id="creating-a-new-vector"><a class="header" href="#creating-a-new-vector">Creating a New Vector</a></h2>
<p>To create a new empty vector, we call the <code>Vec::new</code> function, as shown below:</p>
<pre><code class="language-sway">    let v: Vec&lt;u64&gt; = ~Vec::new();
</code></pre>
<p>Note that we added a type annotation here. Because we arenâ€™t inserting any values into this vector, the Sway compiler doesnâ€™t know what kind of elements we intend to store. Vectors are implemented using generics which means that the <code>Vec&lt;T&gt;</code> type provided by the standard library can hold any type. When we create a vector to hold a specific type, we can specify the type within angle brackets. In the example above, weâ€™ve told the Sway compiler that the <code>Vec&lt;T&gt;</code> in <code>v</code> will hold elements of the <code>u64</code> type.</p>
<h2 id="updating-a-vector"><a class="header" href="#updating-a-vector">Updating a Vector</a></h2>
<p>To create a vector and then add elements to it, we can use the <code>push</code> method, as shown below:</p>
<pre><code class="language-sway">    let mut v = ~Vec::new();

    v.push(5);
    v.push(6);
    v.push(7);
    v.push(8);
</code></pre>
<p>As with any variable, if we want to be able to change its value, we need to make it mutable using the <code>mut</code> keyword, as discussed in the section <a href="common-collections/../basics/variables.html#declaring-a-variable">Declaring a Variable</a>. The numbers we place inside are all of type <code>u64</code>, and the Sway compiler infers this from the data, so we donâ€™t need the <code>Vec&lt;u64&gt;</code> annotation.</p>
<h2 id="reading-elements-of-vectors"><a class="header" href="#reading-elements-of-vectors">Reading Elements of Vectors</a></h2>
<p>To read a value stored in a vector at a particular index, you can use the <code>get</code> method as shown below:</p>
<pre><code class="language-sway">    let third = v.get(2);
    match third {
        Option::Some(third) =&gt; log(third),
        Option::None =&gt; revert(42),
    }
</code></pre>
<p>Note two details here. First, we use the index value of <code>2</code> to get the third element because vectors are indexed by number, starting at zero. Second, we get the third element by using the <code>get</code> method with the index passed as an argument, which gives us an <code>Option&lt;T&gt;</code>.</p>
<p>When the <code>get</code> method is passed an index that is outside the vector, it returns <code>None</code> without panicking. This is particularly useful if accessing an element beyond the range of the vector may happen occasionally under normal circumstances. Your code will then have logic to handle having either <code>Some(element)</code> or <code>None</code>. For example, the index could be coming as a contract method argument. If the argument passed is too large, the method <code>get</code> will return a <code>None</code> value, and the contract method may then decide to revert when that happens or return a meaningful error that tells the user how many items are in the current vector and give them another chance to pass a valid value.</p>
<h2 id="iterating-over-the-values-in-a-vector"><a class="header" href="#iterating-over-the-values-in-a-vector">Iterating over the Values in a Vector</a></h2>
<p>To access each element in a vector in turn, we would iterate through all of the valid indices using a <code>while</code> loop and the <code>len</code> method as shown below:</p>
<pre><code class="language-sway">    let mut i = 0;
    while i &lt; v.len() {
        log(v.get(i).unwrap());
        i += 1;
    }
</code></pre>
<p>Note two details here. First, we use the method <code>len</code> which returns the length of the vector. Second, we call the method <code>unwrap</code> to extract the <code>Option</code> returned by <code>get</code>. We know that <code>unwrap</code> will not fail (i.e. will not cause a revert) because each index <code>i</code> passed to <code>get</code> is known to be smaller than the length of the vector.</p>
<h2 id="using-an-enum-to-store-multiple-types"><a class="header" href="#using-an-enum-to-store-multiple-types">Using an Enum to store Multiple Types</a></h2>
<p>Vectors can only store values that are the same type. This can be inconvenient; there are definitely use cases for needing to store a list of items of different types. Fortunately, the variants of an enum are defined under the same enum type, so when we need one type to represent elements of different types, we can define and use an enum!</p>
<p>For example, say we want to get values from a row in a table in which some of the columns in the row contain integers, some <code>b256</code> values, and some Booleans. We can define an enum whose variants will hold the different value types, and all the enum variants will be considered the same type: that of the enum. Then we can create a vector to hold that enum and so, ultimately, holds different types. Weâ€™ve demonstrated this below:</p>
<pre><code class="language-sway">    enum TableCell {
        Int: u64,
        B256: b256,
        Boolean: bool,
    }

    let mut row = ~Vec::new();
    row.push(TableCell::Int(3));
    row.push(TableCell::B256(0x0101010101010101010101010101010101010101010101010101010101010101));
    row.push(TableCell::Boolean(true));
</code></pre>
<p>Now that weâ€™ve discussed some of the most common ways to use vectors, be sure to review the API documentation for all the many useful methods defined on <code>Vec&lt;T&gt;</code> by the standard library. For now, these can be found in the <a href="https://github.com/FuelLabs/sway/blob/master/sway-lib-std/src/vec.sw">source code for <code>Vec&lt;T&gt;</code></a>. For example, in addition to <code>push</code>, a <code>pop</code> method removes and returns the last element, a <code>remove</code> method removes and returns the element at some chosen index within the vector, an <code>insert</code> method inserts an element at some chosen index within the vector, etc.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="storage-vectors"><a class="header" href="#storage-vectors">Storage Vectors</a></h1>
<p>The second collection type weâ€™ll look at is <code>StorageVec&lt;T&gt;</code>. Just like vectors on the heap (i.e. <code>Vec&lt;T&gt;</code>), storage vectors allow you to store more than one value in a single data structure where each value is assigned an index and can only store values of the same type. However, unlike <code>Vec&lt;T&gt;</code>, the elements of a <code>StorageVec</code> are stored in <em>persistent storage</em>, and consecutive elements are not necessarily stored in storage slots that have consecutive keys.</p>
<p>In order to use <code>StorageVec&lt;T&gt;</code>, you must first import <code>StorageVec</code> as follows:</p>
<pre><code class="language-sway">use std::storage::StorageVec;
</code></pre>
<p>Another major difference between <code>Vec&lt;T&gt;</code> and <code>StorageVec&lt;T&gt;</code> is that <code>StorageVec&lt;T&gt;</code> can only be used in a contract because only contracts are allowed to access persistent storage.</p>
<h2 id="creating-a-new-storage-vector"><a class="header" href="#creating-a-new-storage-vector">Creating a New Storage Vector</a></h2>
<p>To create a new empty storage vector, we have to declare the vector in a <code>storage</code> block as follows:</p>
<pre><code class="language-sway">    v: StorageVec&lt;u64&gt; = StorageVec {},
</code></pre>
<p>Just like any other storage variable, two things are required when declaring a <code>StorageVec</code>: a type annotation and an initializer. The initializer is just an empty struct of type <code>StorageVec</code> because <code>StorageVec&lt;T&gt;</code> itself is an empty struct! Everything that is interesting about <code>StorageVec&lt;T&gt;</code> is implemented in its methods.</p>
<p>Storage vectors, just like <code>Vec&lt;T&gt;</code>, are implemented using generics which means that the <code>StorageVec&lt;T&gt;</code> type provided by the standard library can hold any type. When we create a storage vector to hold a specific type, we can specify the type within angle brackets. In the example above, weâ€™ve told the Sway compiler that the <code>StorageVec&lt;T&gt;</code> in <code>v</code> will hold elements of the <code>u64</code> type.</p>
<h2 id="updating-a-storage-vector"><a class="header" href="#updating-a-storage-vector">Updating a Storage Vector</a></h2>
<p>To add elements to a storage vector, we can use the <code>push</code> method, as shown below:</p>
<pre><code class="language-sway">    #[storage(read, write)]
    fn push_to_storage_vec() {
        storage.v.push(5);
        storage.v.push(6);
        storage.v.push(7);
        storage.v.push(8);
    }
</code></pre>
<p>Note two details here. First, in order to use <code>push</code>, we need to first access the vector using the <code>storage</code> keyword. Second, because <code>push</code> requires accessing storage, a <code>storage</code> annotation is required on the ABI function that calls <code>push</code>. While it may seem that <code>#[storage(write)]</code> should be enough here, the <code>read</code> annotation is also required because each call to <code>push</code> requires <em>reading</em> (and then updating) the length of the storage vector which is also stored in persistent storage.</p>
<blockquote>
<p><strong>Note</strong>
The storage annotation is also required for any private function defined in the contract that tries to push into the vector.</p>
</blockquote>
<!-- markdownlint-disable-line MD028 -->
<blockquote>
<p><strong>Note</strong>
There is no need to add the <code>mut</code> keyword when declaring a <code>StorageVec&lt;T&gt;</code>. All storage variables are mutable by default.</p>
</blockquote>
<h2 id="reading-elements-of-storage-vectors"><a class="header" href="#reading-elements-of-storage-vectors">Reading Elements of Storage Vectors</a></h2>
<p>To read a value stored in a vector at a particular index, you can use the <code>get</code> method as shown below:</p>
<pre><code class="language-sway">    #[storage(read)]
    fn read_from_storage_vec() {
        let third = storage.v.get(2);
        match third {
            Option::Some(third) =&gt; log(third),
            Option::None =&gt; revert(42),
        }
    }
</code></pre>
<p>Note three details here. First, we use the index value of <code>2</code> to get the third element because vectors are indexed by number, starting at zero. Second, we get the third element by using the <code>get</code> method with the index passed as an argument, which gives us an <code>Option&lt;T&gt;</code>. Third, the ABI function calling <code>get</code> only requires the annotation <code>#[storage(read)]</code> as one might expect because <code>get</code> does not write to storage.</p>
<p>When the <code>get</code> method is passed an index that is outside the vector, it returns <code>None</code> without panicking. This is particularly useful if accessing an element beyond the range of the vector may happen occasionally under normal circumstances. Your code will then have logic to handle having either <code>Some(element)</code> or <code>None</code>. For example, the index could be coming as a contract method argument. If the argument passed is too large, the method <code>get</code> will return a <code>None</code> value, and the contract method may then decide to revert when that happens or return a meaningful error that tells the user how many items are in the current vector and give them another chance to pass a valid value.</p>
<h2 id="iterating-over-the-values-in-a-vector-1"><a class="header" href="#iterating-over-the-values-in-a-vector-1">Iterating over the Values in a Vector</a></h2>
<p>To access each element in a vector in turn, we would iterate through all of the valid indices using a <code>while</code> loop and the <code>len</code> method as shown below:</p>
<pre><code class="language-sway">    #[storage(read)]
    fn iterate_over_a_storage_vec() {
        let mut i = 0;
        while i &lt; storage.v.len() {
            log(storage.v.get(i).unwrap());
            i += 1;
        }
    }
</code></pre>
<p>Again, this is quite similar to iterating over the elements of a <code>Vec&lt;T&gt;</code> where we use the method <code>len</code> to return the length of the vector. We also call the method <code>unwrap</code> to extract the <code>Option</code> returned by <code>get</code>. We know that <code>unwrap</code> will not fail (i.e. will not cause a revert) because each index <code>i</code> passed to <code>get</code> is known to be smaller than the length of the vector.</p>
<h2 id="using-an-enum-to-store-multiple-types-1"><a class="header" href="#using-an-enum-to-store-multiple-types-1">Using an Enum to store Multiple Types</a></h2>
<p>Storage vectors, just like <code>Vec&lt;T&gt;</code>, can only store values that are the same type. Similarly to what we did for <code>Vec&lt;T&gt;</code> in the section <a href="common-collections/./vec.html#using-an-enum-to-store-multiple-types">Using an Enum to store Multiple Types</a>, we can define an enum whose variants will hold the different value types, and all the enum variants will be considered the same type: that of the enum. This is shown below:</p>
<pre><code class="language-sway">enum TableCell {
    Int: u64,
    B256: b256,
    Boolean: bool,
}
</code></pre>
<p>Then we can declare a storage vector in a <code>storage</code> block to hold that enum and so, ultimately, holds different types:</p>
<pre><code class="language-sway">    row: StorageVec&lt;TableCell&gt; = StorageVec {},
</code></pre>
<p>We can now push different enum variants to the storage vector as follows:</p>
<pre><code class="language-sway">    #[storage(read, write)]
    fn push_to_multiple_types_storage_vec() {
        storage.row.push(TableCell::Int(3));
        storage.row.push(TableCell::B256(0x0101010101010101010101010101010101010101010101010101010101010101));
        storage.row.push(TableCell::Boolean(true));
    }
</code></pre>
<p>Now that weâ€™ve discussed some of the most common ways to use storage vectors, be sure to review the API documentation for all the many useful methods defined on <code>StorageVec&lt;T&gt;</code> by the standard library. For now, these can be found in the <a href="https://github.com/FuelLabs/sway/blob/master/sway-lib-std/src/storage.sw">source code for <code>StorageVec&lt;T&gt;</code></a>. For example, in addition to <code>push</code>, a <code>pop</code> method removes and returns the last element, a <code>remove</code> method removes and returns the element at some chosen index within the vector, an <code>insert</code> method inserts an element at some chosen index within the vector, etc.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="storage-maps-1"><a class="header" href="#storage-maps-1">Storage Maps</a></h1>
<p>Another important common collection is the storage map. The type <code>StorageMap&lt;K, V&gt;</code> from the standard library stores a mapping of keys of type <code>K</code> to values of type <code>V</code> using a hashing function, which determines how it places these keys and values into <em>storage slots</em>. This is similar to <a href="https://doc.rust-lang.org/std/collections/struct.HashMap.html">Rust's <code>HashMap&lt;K, V&gt;</code></a> but with a few differences.</p>
<p>Storage maps are useful when you want to look up data not by using an index, as you can with vectors, but by using a key that can be of any type. For example, when building a ledger-based sub-currency smart contract, you could keep track of the balance of each wallet in a storage map in which each key is a walletâ€™s <code>Address</code> and the values are each walletâ€™s balance. Given an <code>Address</code>, you can retrieve its balance.</p>
<p>Similarly to <code>StorageVec&lt;T&gt;</code>, <code>StorageMap&lt;K, V&gt;</code> can only be used in a contract because only contracts are allowed to access persistent storage.</p>
<p>In order to use <code>StorageMap&lt;K, V&gt;</code>, you must first import <code>StorageMap</code> as follows:</p>
<pre><code class="language-sway">use std::storage::StorageMap;
</code></pre>
<h2 id="creating-a-new-storage-map"><a class="header" href="#creating-a-new-storage-map">Creating a New Storage Map</a></h2>
<p>To create a new empty storage map, we have to declare the map in a <code>storage</code> block as follows:</p>
<pre><code class="language-sway">    map: StorageMap&lt;Address, u64&gt; = StorageMap {},
</code></pre>
<p>Just like any other storage variable, two things are required when declaring a <code>StorageMap</code>: a type annotation and an initializer. The initializer is just an empty struct of type <code>StorageMap</code> because <code>StorageMap&lt;K, V&gt;</code> itself is an empty struct! Everything that is interesting about <code>StorageMap&lt;K, V&gt;</code> is implemented in its methods.</p>
<p>Storage maps, just like <code>Vec&lt;T&gt;</code> and <code>StorageVec&lt;T&gt;</code>, are implemented using generics which means that the <code>StorageMap&lt;K, V&gt;</code> type provided by the standard library can map keys of any type <code>K</code> to values of any type <code>V</code>. In the example above, weâ€™ve told the Sway compiler that the <code>StorageMap&lt;K, V&gt;</code> in <code>map</code> will map keys of type <code>Address</code> to values of type <code>u64</code>.</p>
<h2 id="updating-a-storage-map"><a class="header" href="#updating-a-storage-map">Updating a Storage Map</a></h2>
<p>To insert key-value pairs into a storage map, we can use the <code>insert</code> method, as shown below:</p>
<pre><code class="language-sway">    #[storage(write)]
    fn insert_into_storage_map() {
        let addr1 = ~Address::from(0x0101010101010101010101010101010101010101010101010101010101010101);
        let addr2 = ~Address::from(0x0202020202020202020202020202020202020202020202020202020202020202);

        storage.map.insert(addr1, 42);
        storage.map.insert(addr2, 77);
    }
</code></pre>
<p>Note two details here. First, in order to use <code>insert</code>, we need to first access the storage map using the <code>storage</code> keyword. Second, because <code>insert</code> requires <em>writing</em> into storage, a <code>#[storage(write)]</code> annotation is required on the ABI function that calls <code>insert</code>.</p>
<blockquote>
<p><strong>Note</strong>
The storage annotation is also required for any private function defined in the contract that tries to insert into the map.</p>
</blockquote>
<!-- markdownlint-disable-line MD028 -->
<blockquote>
<p><strong>Note</strong>
There is no need to add the <code>mut</code> keyword when declaring a <code>StorageMap&lt;K, V&gt;</code>. All storage variables are mutable by default.</p>
</blockquote>
<h2 id="accessing-values-in-a-storage-map"><a class="header" href="#accessing-values-in-a-storage-map">Accessing Values in a Storage Map</a></h2>
<p>We can get a value out of the storage map by providing its <code>key</code> to the <code>get</code> method, as shown below:</p>
<pre><code class="language-sway">    #[storage(read, write)]
    fn get_from_storage_map() {
        let addr1 = ~Address::from(0x0101010101010101010101010101010101010101010101010101010101010101);
        let addr2 = ~Address::from(0x0202020202020202020202020202020202020202020202020202020202020202);

        storage.map.insert(addr1, 42);
        storage.map.insert(addr2, 77);

        let value1 = storage.map.get(addr1);
    }
</code></pre>
<p>Here, <code>value1</code> will have the value that's associated with the first address, and the result will be <code>42</code>. You might expect <code>get</code> to return an <code>Option&lt;V&gt;</code> where the return value would be <code>None</code> if the value does not exist. However, that is not case for <code>StorageMap</code>. In fact, storage maps have no way of knowing whether <code>insert</code> has been called with a given key or not as it would be too expensive to keep track of that information. Instead, a default value whose byte-representation is all zeros is returned if <code>get</code> is called with a key that has no value in the map. Note that each type interprets that default value differently:</p>
<ul>
<li>The default value for a <code>bool</code> is <code>false</code>.</li>
<li>The default value for a integers is <code>0</code>.</li>
<li>The default value for a <code>b256</code> is <code>0x0000000000000000000000000000000000000000000000000000000000000000</code>.</li>
<li>The default value for a <code>str[n]</code> is a string of <code>Null</code> characters.</li>
<li>The default value for a tuple is a tuple of the default values of its components.</li>
<li>The default value for a struct is a struct of the default values of its components.</li>
<li>The default value for an enum is an instance of its first variant containing the default for its associated value.</li>
</ul>
<h2 id="storage-maps-with-multiple-keys"><a class="header" href="#storage-maps-with-multiple-keys">Storage maps with multiple keys</a></h2>
<p>You might find yourself needing a <code>StorageMap&lt;K1, V1&gt;</code> where the type <code>V1</code> is itself another <code>StorageMap&lt;K2, V2&gt;</code>. This is not allowed in Sway. The right approach is to use a single <code>StorageMap&lt;K, V&gt;</code> where <code>K</code> is a tuple <code>(K1, K2)</code>. For example:</p>
<pre><code class="language-sway">    map_two_keys: StorageMap&lt;(b256, bool), b256&gt; = StorageMap {},
</code></pre>
<h2 id="limitations"><a class="header" href="#limitations">Limitations</a></h2>
<p>It is not currently allowed to have a <code>StorageMap&lt;K, V&gt;</code> as a component of a complex type such as a struct or an enum. For example, the code below is not legal:</p>
<pre><code class="language-sway">Struct Wrapper {
    map1: StorageMap&lt;u64, u64&gt;,
    map2: StorageMap&lt;u64, u64&gt;,
}

storage {
    w: Wrapper
}
...

storage.w.map1.insert(..);
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="testing"><a class="header" href="#testing">Testing</a></h1>
<p>Sway aims to provide facilities for both unit testing and integration testing.</p>
<p><strong>Unit testing</strong> refers to &quot;in-language&quot; testing which can be triggered via the
<code>forc test</code> command. Sway unit testing is currently a high-priority
work-in-progress, you can follow along at <a href="https://github.com/FuelLabs/sway/issues/1832">this
issue</a>.</p>
<p><strong>Integration testing</strong> refers to the testing of your Sway project's integration
within some wider application. You can add integration testing to your Sway+Rust
projects today using the cargo generate template and Rust SDK.</p>
<ul>
<li><a href="testing/./testing-with-rust.html">Testing with Rust</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="testing-with-rust"><a class="header" href="#testing-with-rust">Testing with Rust</a></h1>
<p>A common use of Sway is for writing contracts or scripts that exist as part of a
wider Rust application. In order to test the interaction between our Sway code
and our Rust code we can add integration testing.</p>
<h2 id="adding-rust-integration-testing"><a class="header" href="#adding-rust-integration-testing">Adding Rust Integration Testing</a></h2>
<p>To add Rust integration testing to a Forc project we can use <a href="https://github.com/FuelLabs/sway/tree/master/templates/sway-test-rs">the <code>sway-test-rs</code>
cargo generate
template</a>.
This template makes it easy for Sway devs to add the boilerplate required when
setting up their Rust integration testing.</p>
<p>Let's add a Rust integration test to <a href="testing/../introduction/forc_project.html">the fresh project we created in the
introduction</a>.</p>
<h3 id="1-enter-the-project"><a class="header" href="#1-enter-the-project">1. Enter the project</a></h3>
<p>To recap, here's what our empty project looks like:</p>
<pre><code class="language-console">$ cd my-fuel-project
$ tree .
â”œâ”€â”€ Forc.toml
â””â”€â”€ src
 Â Â  â””â”€â”€ main.sw
</code></pre>
<h3 id="2-install-cargo-generate"><a class="header" href="#2-install-cargo-generate">2. Install <code>cargo generate</code></a></h3>
<p>We're going to add a Rust integration test harness using a cargo generate
template. Let's make sure we have the <code>cargo generate</code> command installed!</p>
<pre><code class="language-console">cargo install cargo-generate
</code></pre>
<blockquote>
<p><em><strong>Note</strong>: You can learn more about cargo generate by visiting <a href="https://github.com/cargo-generate/cargo-generate">its
repository</a>.</em></p>
</blockquote>
<h3 id="3-generate-the-test-harness"><a class="header" href="#3-generate-the-test-harness">3. Generate the test harness</a></h3>
<p>Let's generate the default test harness with the following:</p>
<pre><code class="language-console">cargo generate --init fuellabs/sway templates/sway-test-rs --name my-fuel-project
</code></pre>
<p>If all goes well, the output should look as follows:</p>
<pre><code class="language-console">âš ï¸   Favorite `fuellabs/sway` not found in config, using it as a git repository: https://github.com/fuellabs/sway
ðŸ¤·   Project Name : my-fuel-project
ðŸ”§   Destination: /home/user/path/to/my-fuel-project ...
ðŸ”§   Generating template ...
[1/3]   Done: Cargo.toml
[2/3]   Done: tests/harness.rs
[3/3]   Done: tests
ðŸ”§   Moving generated files into: `/home/user/path/to/my-fuel-project`...
âœ¨   Done! New project created /home/user/path/to/my-fuel-project
</code></pre>
<p>Let's have a look at the result:</p>
<pre><code class="language-console">$ tree .
â”œâ”€â”€ Cargo.toml
â”œâ”€â”€ Forc.toml
â”œâ”€â”€ src
â”‚Â Â  â””â”€â”€ main.sw
â””â”€â”€ tests
    â””â”€â”€ harness.rs
</code></pre>
<p>We have two new files!</p>
<ul>
<li>The <code>Cargo.toml</code> is the manifest for our new test harness and specifies the
required dependencies including <code>fuels</code> the Fuel Rust SDK.</li>
<li>The <code>tests/harness.rs</code> contains some boilerplate test code to get us started,
though doesn't call any contract methods just yet.</li>
</ul>
<h3 id="4-build-the-forc-project"><a class="header" href="#4-build-the-forc-project">4. Build the forc project</a></h3>
<p>Before running the tests, we need to build our contract so that the necessary
ABI, storage and bytecode artifacts are available. We can do so with <code>forc build</code>:</p>
<pre><code class="language-console">$ forc build
  Creating a new `Forc.lock` file. (Cause: lock file did not exist)
    Adding core
    Adding std git+https://github.com/fuellabs/sway?tag=v0.24.5#e695606d8884a18664f6231681333a784e623bc9
   Created new lock file at /home/user/path/to/my-fuel-project/Forc.lock
  Compiled library &quot;core&quot;.
  Compiled library &quot;std&quot;.
  Compiled contract &quot;my-fuel-project&quot;.
  Bytecode size is 60 bytes.
</code></pre>
<p>At this point, our project should look like the following:</p>
<pre><code class="language-console">$ tree
â”œâ”€â”€ Cargo.toml
â”œâ”€â”€ Forc.lock
â”œâ”€â”€ Forc.toml
â”œâ”€â”€ out
â”‚Â Â  â””â”€â”€ debug
â”‚Â Â      â”œâ”€â”€ my-fuel-project-abi.json
â”‚Â Â      â”œâ”€â”€ my-fuel-project.bin
â”‚Â Â      â””â”€â”€ my-fuel-project-storage_slots.json
â”œâ”€â”€ src
â”‚Â Â  â””â”€â”€ main.sw
â””â”€â”€ tests
    â””â”€â”€ harness.rs
</code></pre>
<p>We now have an <code>out</code> directory with our required JSON files!</p>
<blockquote>
<p><em><strong>Note</strong>: This step may no longer be required in the future as we plan to
enable the integration testing to automatically build the artifacts as
necessary so that files like the ABI JSON are always up to date.</em></p>
</blockquote>
<h3 id="5-build-and-run-the-tests"><a class="header" href="#5-build-and-run-the-tests">5. Build and run the tests</a></h3>
<p>Now we're ready to build and run the default integration test.</p>
<pre><code class="language-console">$ cargo test
    Updating crates.io index
   Compiling version_check v0.9.4
   Compiling proc-macro2 v1.0.46
   Compiling quote v1.0.21
   ...
   Compiling fuels v0.24.0
   Compiling my-fuel-project v0.1.0 (/home/user/path/to/my-fuel-project)
    Finished test [unoptimized + debuginfo] target(s) in 1m 03s
     Running tests/harness.rs (target/debug/deps/integration_tests-373971ac377845f7)

running 1 test
test can_get_contract_id ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.36s
</code></pre>
<blockquote>
<p><em><strong>Note</strong>: The first time we run <code>cargo test</code>, cargo will spend some time
fetching and building the dependencies for Fuel's Rust SDK. This might take a
while, but only the first time!</em></p>
</blockquote>
<p>If all went well, we should see some output that looks like the above!</p>
<h2 id="writing-tests"><a class="header" href="#writing-tests">Writing Tests</a></h2>
<p>Now that we've learned how to setup Rust integration testing in our project,
let's try to write some of our own tests!</p>
<p>First, let's update our contract code with a simple counter example:</p>
<pre><code class="language-sway">contract;

abi TestContract {
    #[storage(write)]
    fn initialize_counter(value: u64) -&gt; u64;

    #[storage(read, write)]
    fn increment_counter(amount: u64) -&gt; u64;
}

storage {
    counter: u64 = 0,
}

impl TestContract for Contract {
    #[storage(write)]
    fn initialize_counter(value: u64) -&gt; u64 {
        storage.counter = value;
        value
    }

    #[storage(read, write)]
    fn increment_counter(amount: u64) -&gt; u64 {
        let incremented = storage.counter + amount;
        storage.counter = incremented;
        incremented
    }
}
</code></pre>
<p>To test our <code>initialize_counter</code> and <code>increment_counter</code> contract methods from
the Rust test harness, we could update our <code>tests/harness.rs</code> file with the
following:</p>
<!--TODO add test here once examples are tested-->
<pre><code class="language-rust ignore">use fuels::{prelude::*, tx::ContractId};

// Load abi from json
abigen!(TestContract, &quot;out/debug/my-fuel-project-abi.json&quot;);

async fn get_contract_instance() -&gt; (TestContract, ContractId) {
    // Launch a local network and deploy the contract
    let mut wallets = launch_custom_provider_and_get_wallets(
        WalletsConfig::new(
            Some(1),             /* Single wallet */
            Some(1),             /* Single coin (UTXO) */
            Some(1_000_000_000), /* Amount per coin */
        ),
        None,
    )
    .await;
    let wallet = wallets.pop().unwrap();

    let id = Contract::deploy(
        &quot;./out/debug/my-fuel-project.bin&quot;,
        &amp;wallet,
        TxParameters::default(),
        StorageConfiguration::with_storage_path(Some(
            &quot;./out/debug/my-fuel-project-storage_slots.json&quot;.to_string(),
        )),
    )
    .await
    .unwrap();

    let instance = TestContract::new(id.to_string(), wallet);

    (instance, id.into())
}

#[tokio::test]
async fn initialize_and_increment() {
    let (contract_instance, _id) = get_contract_instance().await;
    // Now you have an instance of your contract you can use to test each function

    let result = contract_instance
        .methods()
        .initialize_counter(42)
        .call()
        .await
        .unwrap();

    assert_eq!(42, result.value);

    // Call `increment_counter()` method in our deployed contract.
    let result = contract_instance
        .methods()
        .increment_counter(10)
        .call()
        .await
        .unwrap();

    assert_eq!(52, result.value);
}
</code></pre>
<p>Let's build our project once more and run the test:</p>
<pre><code class="language-console">forc build
</code></pre>
<pre><code class="language-console">$ cargo test
   Compiling my-fuel-project v0.1.0 (/home/mindtree/programming/sway/my-fuel-project)
    Finished test [unoptimized + debuginfo] target(s) in 11.61s
     Running tests/harness.rs (target/debug/deps/integration_tests-373971ac377845f7)

running 1 test
test initialize_and_increment ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 1.25s
</code></pre>
<p>When cargo runs our test, our test uses the SDK to spin up a local in-memory
Fuel network, deploy our contract to it, and call the contract methods via the
ABI.</p>
<p>You can add as many functions decorated with <code>#[tokio::test]</code> as you like, and
<code>cargo test</code> will automatically test each of them!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="application-frontend-development"><a class="header" href="#application-frontend-development">Application Frontend Development</a></h1>
<ul>
<li><a href="frontend/./typescript_sdk.html">TypeScript SDK</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="typescript-sdk"><a class="header" href="#typescript-sdk">TypeScript SDK</a></h1>
<p>The TypeScript SDK supports common tasks like:</p>
<ul>
<li>Deploying and calling contracts</li>
<li>Generating contract types with TypeChain</li>
<li>Building and sending transactions</li>
<li>Encoding and decoding contract ABI</li>
</ul>
<p>Refer <a href="https://fuellabs.github.io/fuels-ts">here</a> for full documentation.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sway-reference"><a class="header" href="#sway-reference">Sway Reference</a></h1>
<ul>
<li><a href="reference/./style_guide.html">Style Guide</a></li>
<li><a href="reference/./known_issues_and_workarounds.html">Known Issues and Workarounds</a></li>
<li><a href="reference/./rust_differences.html">Differences from Rust</a></li>
<li><a href="reference/./solidity_differences.html">Differences from Solidity</a></li>
<li><a href="reference/./contributing_to_sway.html">Contributing to Sway</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="style-guide"><a class="header" href="#style-guide">Style Guide</a></h1>
<h2 id="capitalization"><a class="header" href="#capitalization">Capitalization</a></h2>
<p>In Sway, structs, traits, and enums are <code>CapitalCase</code>. Modules, variables, and functions are <code>snake_case</code>, constants are <code>SCREAMING_SNAKE_CASE</code>. The compiler will warn you if your capitalization is ever unidiomatic.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="known-issues-and-workarounds"><a class="header" href="#known-issues-and-workarounds">Known Issues and Workarounds</a></h1>
<h2 id="known-issues"><a class="header" href="#known-issues">Known Issues</a></h2>
<ul>
<li><a href="https://github.com/FuelLabs/sway/issues/870">#870</a>: All <code>impl</code> blocks need to be defined before any of the functions they define can be called.  This includes sibling functions in the same <code>impl</code> declaration, i.e., functions in an <code>impl</code> can't call each other yet.</li>
</ul>
<h2 id="missing-features"><a class="header" href="#missing-features">Missing Features</a></h2>
<ul>
<li>
<p><a href="https://github.com/FuelLabs/sway/issues/1182">#1182</a> Arrays in a <code>storage</code> block are not yet supported. See the <a href="reference/../blockchain-development/storage.html#manual-storage-management">Manual Storage Management</a> section for details on how to use <code>store</code> and <code>get</code> from the standard library to manage storage slots directly. Note, however, that <code>StorageMap&lt;K, V&gt;</code> <em>does</em> support arbitrary types for <code>K</code> and <code>V</code> without any limitations.</p>
</li>
<li>
<p><a href="https://github.com/FuelLabs/sway/issues/428">#428</a>: Arrays are currently immutable which means that changing elements of an array once initialized is not yet possible.</p>
</li>
<li>
<p><a href="https://github.com/FuelLabs/sway/issues/2465">#1796</a>: It is not yet allowed to use <code>StorageMap&lt;K, V&gt;</code> as a component of a complex type such as a struct or an enum.</p>
</li>
<li>
<p><a href="https://github.com/FuelLabs/sway/issues/2647">#2647</a>: Currently, it is only possible to define configuration-time constants that have <a href="reference/../basics/built_in_types.html#primitive-types">primitive types</a> and that are initialized using literals.</p>
</li>
</ul>
<h2 id="general"><a class="header" href="#general">General</a></h2>
<ul>
<li>No compiler optimization passes have been implemented yet, therefore bytecode will be more expensive and larger than it would be in production. Note that eventually the optimizer will support zero-cost abstractions, avoiding the need for developers to go down to inline assembly to produce optimal code.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="differences-from-solidity"><a class="header" href="#differences-from-solidity">Differences From Solidity</a></h1>
<p>This page outlines some of the critical differences between Sway and Solidity, and between the FuelVM and the EVM.</p>
<h2 id="underlying-virtual-machine"><a class="header" href="#underlying-virtual-machine">Underlying Virtual Machine</a></h2>
<p>The underlying virtual machine targeted by Sway is the FuelVM, specified <a href="https://github.com/FuelLabs/fuel-specs">here</a>. Solidity targets the Ethereum Virtual Machine (EVM), specified <a href="https://ethereum.github.io/yellowpaper/paper.pdf">here</a>.</p>
<h2 id="word-size"><a class="header" href="#word-size">Word Size</a></h2>
<p>Words in the FuelVM are 64 bits (8 bytes), rather than the 256 bits (32 bytes) of the EVM. Therefore, primitive integers only go up to <code>u64</code>, and hashes (the <code>b256</code> type) are not in registers but rather in memory. A <code>b256</code> is therefore a pointer to a 32-byte memory region containing the hash value.</p>
<h2 id="unsigned-integers-only"><a class="header" href="#unsigned-integers-only">Unsigned Integers Only</a></h2>
<p>Only unsigned integers are provided as primitives: <code>u8</code>, <code>u16</code>, <code>u32</code>, and <code>u64</code>. Signed integer arithmetic is not available in the FuelVM. Signed integers and signed integer arithmetic can be implemented in high-level libraries if needed.</p>
<h2 id="global-revert"><a class="header" href="#global-revert">Global Revert</a></h2>
<p>Panics in the FuelVM (called &quot;reverts&quot; in Solidity and the EVM) are global, i.e. they cannot be caught. A panic will completely and unconditionally revert the stateful effects of a transaction, minus gas used.</p>
<h2 id="default-safe-math"><a class="header" href="#default-safe-math">Default Safe Math</a></h2>
<p>Math in the FuelVM is by default safe (i.e. any overflow or exception is a panic). Safety checks are performed natively in the VM implementation, rather than at the bytecode level like <a href="https://docs.soliditylang.org/en/latest/080-breaking-changes.html#silent-changes-of-the-semantics">Solidity's default safe math</a>.</p>
<h2 id="no-code-size-limit"><a class="header" href="#no-code-size-limit">No* Code Size Limit</a></h2>
<p>There is no practical code size limit to Sway contracts. The physical limit is governed by the <a href="https://github.com/FuelLabs/fuel-specs/blob/master/specs/vm/main.md#parameters"><code>VM_MAX_RAM</code> VM parameter</a>, which at the time of writing is 64 MiB.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="differences-from-rust"><a class="header" href="#differences-from-rust">Differences From Rust</a></h1>
<p>Sway shares a lot with Rust, especially its syntax. Because they are so similar, you may be surprised or caught off guard when they differ. This page serves to outline, from a high level, some of the syntactic <em>gotchas</em> that you may encounter.</p>
<h2 id="enum-variant-syntax"><a class="header" href="#enum-variant-syntax">Enum Variant Syntax</a></h2>
<p>In Rust, enums generally take one of three forms: <em>unit</em> variants, which have no inner data, <em>struct</em> variants, which contain named fields, and <em>tuple</em> variants, which contain within them a tuple of data. If you are unfamiliar with these terms, this is what they look like:</p>
<pre><code class="language-rust ignore">// note to those skimming the docs: this is Rust syntax! Not Sway! Don't copy/paste this into a Sway program.

enum Foo {
    UnitVariant,
    TupleVariant(u32, u64, bool),
    StructVariant {
        field_one: bool,
        field_two: bool
    }
}
</code></pre>
<p>In Sway, enums are simplified. Enums variants must all specify exactly one type. This type represents their interior data. This is actually isomorphic to what Rust offers, just with a different syntax. I'll now rewrite the above enum but with Sway syntax:</p>
<pre><code class="language-sway">// This is equivalent Sway syntax for the above Rust enum.
enum Foo {
    UnitVariant: (),
    TupleVariant: (u32, u64, bool),
    StructVariant: MyStruct,
}

struct MyStruct {
    field_one: bool,
    field_two: bool,
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="contributing-to-sway"><a class="header" href="#contributing-to-sway">Contributing To Sway</a></h1>
<p>Thanks for your interest in contributing to Sway! This document outlines the process for installing and setting up the Sway toolchain for development, as well as some conventions on contributing to Sway.</p>
<p>If you run into any difficulties getting started, you can always ask questions on our <a href="https://discord.gg/xfpK4Pe">Discord</a>.</p>
<h2 id="building-and-setting-up-a-development-workspace"><a class="header" href="#building-and-setting-up-a-development-workspace">Building and setting up a development workspace</a></h2>
<p>See the <a href="reference/../introduction/index.html">introduction</a> section for instructions on installing and setting up the Sway toolchain.</p>
<h2 id="getting-the-repository"><a class="header" href="#getting-the-repository">Getting the repository</a></h2>
<ol>
<li>Visit the <a href="https://github.com/FuelLabs/sway">Sway</a> repo and fork the project.</li>
<li>Then clone your forked copy to your local machine and get to work.</li>
</ol>
<pre><code class="language-sh">git clone https://github.com/FuelLabs/sway
cd sway
</code></pre>
<h2 id="building-and-testing"><a class="header" href="#building-and-testing">Building and testing</a></h2>
<p>The following steps will run the sway test suite and ensure that everything is set up correctly.</p>
<p>First, open a new terminal and start <code>fuel-core</code> with:</p>
<pre><code class="language-sh">fuel-core
</code></pre>
<p>Then open a second terminal, cd into the <code>sway</code> repo and run:</p>
<pre><code class="language-sh">cargo run --bin test
</code></pre>
<p>After the test suite runs, you should see:</p>
<pre><code class="language-console">Tests passed.
_n_ tests run (0 skipped)
</code></pre>
<p>Congratulations! You've now got everything setup and are ready to start making contributions.</p>
<h2 id="finding-something-to-work-on"><a class="header" href="#finding-something-to-work-on">Finding something to work on</a></h2>
<p>There are many ways in which you may contribute to the Sway project, some of which involve coding knowledge and some which do not. A few examples include:</p>
<ul>
<li>Reporting bugs</li>
<li>Adding documentation to the Sway book</li>
<li>Adding new features or bugfixes for which there is already an open issue</li>
<li>Making feature requests</li>
</ul>
<p>Check out our <a href="https://github.com/FuelLabs/sway/issues?q=is%3Aopen+is%3Aissue+label%3A%22help+wanted%22">Help Wanted</a>, <a href="https://github.com/FuelLabs/sway/issues?q=is%3Aopen+is%3Aissue+label%3A%22The+Sway+Book%22">Sway Book</a> or <a href="https://github.com/FuelLabs/sway/issues?q=is%3Aopen+is%3Aissue+label%3A%22good+first+issue%22">Good First Issue</a> issues to find a suitable task.</p>
<p>If you are planning something big, for example, related to multiple components or changes current behaviors, make sure to open an issue to discuss with us before starting on the implementation.</p>
<h2 id="contribution-flow"><a class="header" href="#contribution-flow">Contribution flow</a></h2>
<p>This is a rough outline of what a contributor's workflow looks like:</p>
<ul>
<li>Make sure what you want to contribute is already tracked as an issue.
<ul>
<li>We may discuss the problem and solution in the issue.</li>
</ul>
</li>
<li>Create a Git branch from where you want to base your work. This is usually master.</li>
<li>Write code, add test cases, and commit your work.</li>
<li>Run tests and make sure all tests pass.</li>
<li>If the PR contains any breaking changes, add the breaking label to your PR.</li>
<li>Push your changes to a branch in your fork of the repository and submit a pull request.
<ul>
<li>Make sure mention the issue, which is created at step 1, in the commit message.</li>
</ul>
</li>
<li>Your PR will be reviewed and some changes may be requested.
<ul>
<li>Once you've made changes, your PR must be re-reviewed and approved.</li>
<li>If the PR becomes out of date, you can use GitHub's 'update branch' button.</li>
<li>If there are conflicts, you can merge and resolve them locally. Then push to your PR branch.
Any changes to the branch will require a re-review.</li>
</ul>
</li>
<li>Our CI system (Github Actions) automatically tests all authorized pull requests.</li>
<li>Use Github to merge the PR once approved.</li>
</ul>
<p>Thanks for your contributions!</p>
<h3 id="linking-issues"><a class="header" href="#linking-issues">Linking issues</a></h3>
<p>Pull requests should be linked to at least one issue in the same repo.</p>
<p>If the pull request resolves the relevant issues, and you want GitHub to close these issues automatically after it merged into the default branch, you can use the syntax (<code>KEYWORD #ISSUE-NUMBER</code>) like this:</p>
<pre><code class="language-markdown">close #123
</code></pre>
<p>If the pull request links an issue but does not close it, you can use the keyword <code>ref</code> like this:</p>
<pre><code class="language-markdown">ref #456
</code></pre>
<p>Multiple issues should use full syntax for each issue and separate by a comma, like:</p>
<pre><code class="language-markdown">close #123, ref #456
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="forc-reference"><a class="header" href="#forc-reference">Forc Reference</a></h1>
<p>Forc stands for Fuel Orchestrator. Forc provides a variety of tools and commands for developers working with the Fuel ecosystem, such as scaffolding a new project, formatting, running scripts, deploying contracts, testing contracts, and more. If you're coming from a Rust background, forc is similar to cargo.</p>
<p>If you are new to Forc, see the <a href="forc/../introduction/forc_project.html">Forc Project</a> introduction section.</p>
<p>For a comprehensive overview of the Forc CLI commands, see the <a href="forc/./commands/index.html">Commands</a> section.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="manifest-reference"><a class="header" href="#manifest-reference">Manifest Reference</a></h1>
<p>The <code>Forc.toml</code> (the <em>manifest</em> file) is a compulsory file for each package and it is written in [TOML] format. <code>Forc.toml</code> consists of the following fields:</p>
<ul>
<li>
<p><a href="forc/manifest_reference.html#the-project-section"><code>[project]</code></a> â€” Defines a sway project.</p>
<ul>
<li><code>name</code> â€” The name of the project.</li>
<li><code>authors</code> â€” The authors of the project.</li>
<li><code>organization</code> â€” The organization of the project.</li>
<li><code>license</code>â€” The project license.</li>
<li><code>entry</code> â€” The entry point for the compiler to start parsing from.
<ul>
<li>For the recomended way of selecting an entry point of large libraries please take a look at: <a href="forc/./../sway-program-types/libraries.html">Libraries</a></li>
</ul>
</li>
<li><code>implicit-std</code> -  Controls whether provided <code>std</code> version (with the current <code>forc</code> version) will get added as a dependency <em>implicitly</em>. <em>Unless you know what you are doing, leave this as default.</em></li>
<li><code>forc-version</code> - The minimum forc version required for this project to work properly.</li>
</ul>
</li>
<li>
<p><a href="forc/manifest_reference.html#the-dependencies-section"><code>[dependencies]</code></a> â€” Defines the dependencies.</p>
</li>
<li>
<p><code>[network]</code> â€” Defines a network for forc to interact with.</p>
<ul>
<li><code>url</code> â€” URL of the network.</li>
</ul>
</li>
<li>
<p><a href="forc/manifest_reference.html#the-build-profiles--section"><code>[build-profiles]</code></a> - Defines the build profiles.</p>
</li>
<li>
<p><a href="forc/manifest_reference.html#the-patch-section"><code>[patch]</code></a> - Defines the patches.</p>
</li>
</ul>
<h2 id="the-project-section"><a class="header" href="#the-project-section">The <code>[project]</code> section</a></h2>
<p>An example <code>Forc.toml</code> is shown below. Under <code>[project]</code> the following fields are optional:</p>
<ul>
<li><code>authors</code></li>
<li><code>organization</code></li>
</ul>
<p>Also for the following fields, a default value is provided so omitting them is allowed:</p>
<ul>
<li><code>entry</code> - (default : <em>main.sw</em>)</li>
<li><code>implicit-std</code> - (default : <em>true</em>)</li>
</ul>
<pre><code class="language-toml">[project]
authors = [&quot;user&quot;]
entry = &quot;main.sw&quot;
organization = &quot;Fuel_Labs&quot;
license = &quot;Apache-2.0&quot;
name = &quot;wallet_contract&quot;
</code></pre>
<h2 id="the-dependencies-section"><a class="header" href="#the-dependencies-section">The <code>[dependencies]</code> section</a></h2>
<p>The following fields can be provided with a dependency:</p>
<ul>
<li><code>version</code> - Desired version of the dependency</li>
<li><code>path</code> - The path of the dependency (if it is local)</li>
<li><code>git</code> - The URL of the git repo hosting the dependency</li>
<li><code>branch</code> - The desired branch to fetch from the git repo</li>
<li><code>tag</code> - The desired tag to fetch from the git repo</li>
<li><code>rev</code> - The desired rev (i.e. commit hash) reference</li>
</ul>
<p>Please see <a href="forc/./dependencies.html">dependencies</a> for details</p>
<h2 id="the-network-section"><a class="header" href="#the-network-section">The <code>[network]</code> section</a></h2>
<p>For the following fields, a default value is provided so omitting them is allowed:</p>
<ul>
<li><code>URL</code> - (default: <em><a href="http://127.0.0.1:4000">http://127.0.0.1:4000</a></em>)</li>
</ul>
<h2 id="the-build-profiles--section"><a class="header" href="#the-build-profiles--section">The <code>[build-profiles-*]</code> section</a></h2>
<p>The <code>[build-profiles]</code> tables provide a way to customize compiler settings such as debug options.</p>
<p>The following fields needs to be provided for a build-profile:</p>
<ul>
<li><code>print-ast</code> - Whether to print out the generated AST (true) or not (false).</li>
<li><code>print-finalized-asm</code> - Whether to compile to bytecode (false) or to print out the generated ASM (true).</li>
<li><code>print-intermediate-asm</code> - Whether to compile to bytecode (false) or to print out the generated ASM (true).</li>
<li><code>print-ir</code> - Whether to compile to bytecode (false) or to print out the generated IR (true).</li>
<li><code>terse-mode</code> - Terse mode. Limited warning and error output.</li>
</ul>
<p>There are two default <code>[build-profile]</code> available with every manifest file. These are <code>debug</code> and <code>release</code> profiles. If you want to override these profiles, you can provide them explicitly in the manifest file like the following example:</p>
<pre><code class="language-toml">[project]
authors = [&quot;user&quot;]
entry = &quot;main.sw&quot;
organization = &quot;Fuel_Labs&quot;
license = &quot;Apache-2.0&quot;
name = &quot;wallet_contract&quot;

[build-profiles.debug]
print-finalized-asm = false
print-intermediate-asm = false
print-ir = false
terse = false

[build-profiles.release]
print-finalized-asm = false 
print-intermediate-asm = false
print-ir = false
terse = true
</code></pre>
<p>Since <code>release</code> and <code>debug</code> implicitly included in every manifest file, you can use them by just passing <code>--release</code> or by not passing anything (debug is default). For using a user defined build profile there is <code>--build-profile &lt;profile name&gt;</code> option available to the relevant commands. (For an example see <a href="forc/../forc/commands/forc_build.html">forc-build</a>)</p>
<p>Note that providing the corresponding cli options (like <code>--print-finalized-asm</code>) will override the selected build profile. For example if you pass both <code>--release</code> and <code>--print-finalized-asm</code>, release build profile is omitted and resulting build profile would have a structure like the following:</p>
<ul>
<li>print-finalized-asm - true</li>
<li>print-intermediate-asm - false</li>
<li>print-ir - false</li>
<li>terse - false</li>
</ul>
<h2 id="the-patch-section"><a class="header" href="#the-patch-section">The <code>[patch]</code> section</a></h2>
<p>The [patch] section of <code>Forc.toml</code> can be used to override dependencies with other copies. The example provided below patches <a href="https://github.com/fuellabs/sway">https://github.com/fuellabs/sway</a> source with master branch of the same repo.</p>
<pre><code class="language-toml">[project]
authors = [&quot;user&quot;]
entry = &quot;main.sw&quot;
organization = &quot;Fuel_Labs&quot;
license = &quot;Apache-2.0&quot;
name = &quot;wallet_contract&quot;

[dependencies]

[patch.'https://github.com/fuellabs/sway']
std = { git = &quot;https://github.com/fuellabs/sway&quot;, branch = &quot;test&quot; }
</code></pre>
<p>In the example above, <code>std</code> is patched with the <code>test</code> branch from <code>std</code> repo. You can also patch git dependencies with dependencies defined with a path.</p>
<pre><code class="language-toml">[patch.'https://github.com/fuellabs/sway']
std = { path = &quot;/path/to/local_std_version&quot; }
</code></pre>
<p>Just like <code>std</code> or <code>core</code> you can also patch dependencies you declared with a git repo.</p>
<pre><code class="language-toml">[project]
authors = [&quot;user&quot;]
entry = &quot;main.sw&quot;
organization = &quot;Fuel_Labs&quot;
license = &quot;Apache-2.0&quot;
name = &quot;wallet_contract&quot;

[dependencies]
foo = { git = &quot;https://github.com/foo/foo&quot;, branch = &quot;master&quot; }

[patch.'https://github.com/foo']
foo = { git = &quot;https://github.com/foo/foo&quot;, branch = &quot;test&quot; }
</code></pre>
<p>Note that each key after the <code>[patch]</code> is a URL of the source that is being patched.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="dependencies-1"><a class="header" href="#dependencies-1">Dependencies</a></h1>
<p>Forc has a dependency management system which can pull packages using git. This allows users to build and share Forc libraries.</p>
<h2 id="adding-a-dependency"><a class="header" href="#adding-a-dependency">Adding a dependency</a></h2>
<p>If your <code>Forc.toml</code> doesn't already have a <code>[dependencies]</code> table, add one. Below, list the package name alongside its source. Currently, <code>forc</code> supports both <code>git</code> and <code>path</code> sources.</p>
<p>If a <code>git</code> source is specified, <code>forc</code> will fetch the git repository at the given URL and then search for a <code>Forc.toml</code> for a package with the given name anywhere inside the git repository.</p>
<p>The following example adds a library dependency named <code>custom_lib</code>. For git dependencies you may optionally specify a <code>branch</code>, <code>tag</code>, or <code>rev</code> (i.e. commit hash) reference.</p>
<pre><code class="language-toml">[dependencies]
custom_lib = { git = &quot;https://github.com/FuelLabs/custom_lib&quot;, branch = &quot;master&quot; }
# custom_lib = { git = &quot;https://github.com/FuelLabs/custom_lib&quot;, tag = &quot;v0.0.1&quot; }
# custom_lib = { git = &quot;https://github.com/FuelLabs/custom_lib&quot;, rev = &quot;87f80bdf323e2d64e213895d0a639ad468f4deff&quot; }
</code></pre>
<p>Depending on a local library using <code>path</code>:</p>
<pre><code class="language-toml">[dependencies]
custom_lib = { path = &quot;../custom_lib&quot; }
</code></pre>
<p>Once the package is added, running <code>forc build</code> will automatically download added dependencies.</p>
<h2 id="updating-dependencies"><a class="header" href="#updating-dependencies">Updating dependencies</a></h2>
<p>To update dependencies in your Forc directory you can run <code>forc update</code>. For <code>path</code> dependencies this will have no effect. For <code>git</code> dependencies with a <code>branch</code> reference, this will update the project to use the latest commit for the given branch.</p>
<div style="break-before: page; page-break-before: always;"></div><!-- markdownlint-disable MD041 -->
<p>Here are a list of commands available to forc:</p>
<ul>
<li><a href="forc/commands/./forc_addr2line.html">forc addr2line</a></li>
<li><a href="forc/commands/./forc_build.html">forc build</a></li>
<li><a href="forc/commands/./forc_check.html">forc check</a></li>
<li><a href="forc/commands/./forc_clean.html">forc clean</a></li>
<li><a href="forc/commands/./forc_completions.html">forc completions</a></li>
<li><a href="forc/commands/./forc_init.html">forc init</a></li>
<li><a href="forc/commands/./forc_new.html">forc new</a></li>
<li><a href="forc/commands/./forc_parse-bytecode.html">forc parse-bytecode</a></li>
<li><a href="forc/commands/./forc_plugins.html">forc plugins</a></li>
<li><a href="forc/commands/./forc_test.html">forc test</a></li>
<li><a href="forc/commands/./forc_update.html">forc update</a></li>
<li><a href="forc/commands/./forc_template.html">forc template</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="forc-addr2line"><a class="header" href="#forc-addr2line">forc-addr2line</a></h1>
<p>Show location and context of an opcode address in its source file</p>
<h2 id="usage"><a class="header" href="#usage">USAGE:</a></h2>
<p>forc addr2line [OPTIONS] --sourcemap-path &lt;SOURCEMAP_PATH&gt; --opcode-index &lt;OPCODE_INDEX&gt;</p>
<h2 id="options"><a class="header" href="#options">OPTIONS:</a></h2>
<p><code>-c</code>, <code>--context</code> &lt;<em>CONTEXT</em>&gt;</p>
<p>How many lines of context to show [default: 2]</p>
<p><code>-g</code>, <code>--sourcemap-path</code> &lt;<em>SOURCEMAP_PATH</em>&gt;</p>
<p>Source file mapping in JSON format</p>
<p><code>-h</code>, <code>--help</code> </p>
<p>Print help information</p>
<p><code>-i</code>, <code>--opcode-index</code> &lt;<em>OPCODE_INDEX</em>&gt;</p>
<p>Opcode index</p>
<p><code>-L</code>, <code>--log-level</code> &lt;<em>LOG_LEVEL</em>&gt;</p>
<p>Set the log level</p>
<p><code>-s</code>, <code>--silent</code> </p>
<p>Silence all output</p>
<p><code>-S</code>, <code>--search-dir</code> &lt;<em>SEARCH_DIR</em>&gt;</p>
<p>Where to search for the project root [default: .]</p>
<p><code>-v</code>, <code>--verbose</code> </p>
<p>Use verbose output</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="forc-build"><a class="header" href="#forc-build">forc-build</a></h1>
<p>Compile the current or target project.</p>
<p>The output produced will depend on the project's program type.</p>
<ul>
<li>
<p><code>script</code>, <code>predicate</code> and <code>contract</code> projects will produce their bytecode in binary format
<code>&lt;project-name&gt;.bin</code>.</p>
</li>
<li>
<p><code>script</code> projects will also produce a file containing the hash of the bytecode binary
<code>&lt;project-name&gt;-bin-hash</code> (using <code>fuel_cypto::Hasher</code>).</p>
</li>
<li>
<p><code>predicate</code> projects will also produce a file containing the <strong>root</strong> hash of the bytecode binary
<code>&lt;project-name&gt;-bin-root</code> (using <code>fuel_tx::Contract::root_from_code</code>).</p>
</li>
<li>
<p><code>contract</code> and <code>library</code> projects will also produce the public ABI in JSON format
<code>&lt;project-name&gt;-abi.json</code>.</p>
</li>
</ul>
<h2 id="usage-1"><a class="header" href="#usage-1">USAGE:</a></h2>
<p>forc build [OPTIONS]</p>
<h2 id="options-1"><a class="header" href="#options-1">OPTIONS:</a></h2>
<p><code>--build-profile</code> &lt;<em>BUILD_PROFILE</em>&gt;</p>
<p>Name of the build profile to use. If it is not specified, forc will use debug build
profile</p>
<p><code>-g</code>, <code>--debug-outfile</code> &lt;<em>DEBUG_OUTFILE</em>&gt;</p>
<p>If set, outputs source file mapping in JSON format</p>
<p><code>-h</code>, <code>--help</code> </p>
<p>Print help information</p>
<p><code>-L</code>, <code>--log-level</code> &lt;<em>LOG_LEVEL</em>&gt;</p>
<p>Set the log level</p>
<p><code>--locked</code> </p>
<p>Requires that the Forc.lock file is up-to-date. If the lock file is missing, or it needs
to be updated, Forc will exit with an error</p>
<p><code>--minify-json-abi</code> </p>
<p>By default the JSON for ABIs is formatted for human readability. By using this option
JSON output will be &quot;minified&quot;, i.e. all on one line without whitespace</p>
<p><code>--minify-json-storage-slots</code> </p>
<p>By default the JSON for initial storage slots is formatted for human readability. By
using this option JSON output will be &quot;minified&quot;, i.e. all on one line without
whitespace</p>
<p><code>-o</code> &lt;<em>BINARY_OUTFILE</em>&gt;</p>
<p>If set, outputs a binary file representing the script bytes</p>
<p><code>--offline</code> </p>
<p>Offline mode, prevents Forc from using the network when managing dependencies. Meaning
it will only try to use previously downloaded dependencies</p>
<p><code>--output-directory</code> &lt;<em>OUTPUT_DIRECTORY</em>&gt;</p>
<p>The directory in which the sway compiler output artifacts are placed.</p>
<p>By default, this is <code>&lt;project-root&gt;/out</code>.</p>
<p><code>-p</code>, <code>--path</code> &lt;<em>PATH</em>&gt;</p>
<p>Path to the project, if not specified, current working directory will be used</p>
<p><code>--print-ast</code> </p>
<p>Print the generated Sway AST (Abstract Syntax Tree)</p>
<p><code>--print-finalized-asm</code> </p>
<p>Print the finalized ASM.</p>
<p>This is the state of the ASM with registers allocated and optimisations applied.</p>
<p><code>--print-intermediate-asm</code> </p>
<p>Print the generated ASM.</p>
<p>This is the state of the ASM prior to performing register allocation and other ASM
optimisations.</p>
<p><code>--print-ir</code> </p>
<p>Print the generated Sway IR (Intermediate Representation)</p>
<p><code>--release</code> </p>
<p>Use release build plan. If a custom release plan is not specified, it is implicitly
added to the manifest file.</p>
<p>If --build-profile is also provided, forc omits this flag and uses provided
build-profile.</p>
<p><code>-s</code>, <code>--silent</code> </p>
<p>Silence all output</p>
<p><code>-t</code>, <code>--terse</code> </p>
<p>Terse mode. Limited warning and error output</p>
<p><code>--time-phases</code> </p>
<p>Output the time elapsed over each part of the compilation process</p>
<p><code>-v</code>, <code>--verbose</code> </p>
<p>Use verbose output<!-- markdownlint-disable MD041 --></p>
<h2 id="example-2"><a class="header" href="#example-2">EXAMPLE</a></h2>
<p>Compile the sway files of the current project.</p>
<pre><code class="language-console">$ forc build
Compiled script &quot;my-fuel-project&quot;.
Bytecode size is 28 bytes.
</code></pre>
<p>The output produced will depend on the project's program type. Building script, predicate and contract projects will produce their bytecode in binary format <code>&lt;project-name&gt;.bin</code>. Building contracts and libraries will also produce the public ABI in JSON format <code>&lt;project-name&gt;-abi.json</code>.</p>
<p>By default, these artifacts are placed in the <code>out/</code> directory.</p>
<p>If a <code>Forc.lock</code> file did not yet exist, it will be created in order to pin each of the dependencies listed in <code>Forc.toml</code> to a specific commit or version.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="forc-check"><a class="header" href="#forc-check">forc-check</a></h1>
<p>Check the current or target project and all of its dependencies for errors.</p>
<p>This will essentially compile the packages without performing the final step of code generation,
which is faster than running forc build.</p>
<h2 id="usage-2"><a class="header" href="#usage-2">USAGE:</a></h2>
<p>forc check [OPTIONS]</p>
<h2 id="options-2"><a class="header" href="#options-2">OPTIONS:</a></h2>
<p><code>-h</code>, <code>--help</code> </p>
<p>Print help information</p>
<p><code>-L</code>, <code>--log-level</code> &lt;<em>LOG_LEVEL</em>&gt;</p>
<p>Set the log level</p>
<p><code>--locked</code> </p>
<p>Requires that the Forc.lock file is up-to-date. If the lock file is missing, or it needs
to be updated, Forc will exit with an error</p>
<p><code>--offline</code> </p>
<p>Offline mode, prevents Forc from using the network when managing dependencies. Meaning
it will only try to use previously downloaded dependencies</p>
<p><code>-p</code>, <code>--path</code> &lt;<em>PATH</em>&gt;</p>
<p>Path to the project, if not specified, current working directory will be used</p>
<p><code>-s</code>, <code>--silent</code> </p>
<p>Silence all output</p>
<p><code>-t</code>, <code>--terse</code> </p>
<p>Terse mode. Limited warning and error output</p>
<p><code>-v</code>, <code>--verbose</code> </p>
<p>Use verbose output</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="forc-clean"><a class="header" href="#forc-clean">forc-clean</a></h1>
<p>Removes the default forc compiler output artifact directory, i.e. <code>&lt;project-name&gt;/out</code></p>
<h2 id="usage-3"><a class="header" href="#usage-3">USAGE:</a></h2>
<p>forc clean [OPTIONS]</p>
<h2 id="options-3"><a class="header" href="#options-3">OPTIONS:</a></h2>
<p><code>-h</code>, <code>--help</code> </p>
<p>Print help information</p>
<p><code>-L</code>, <code>--log-level</code> &lt;<em>LOG_LEVEL</em>&gt;</p>
<p>Set the log level</p>
<p><code>-p</code>, <code>--path</code> &lt;<em>PATH</em>&gt;</p>
<p>Path to the project, if not specified, current working directory
will be used</p>
<p><code>-s</code>, <code>--silent</code> </p>
<p>Silence all output</p>
<p><code>-v</code>, <code>--verbose</code> </p>
<p>Use verbose output</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="forc-completions"><a class="header" href="#forc-completions">forc-completions</a></h1>
<p>Generate tab-completion scripts for your shell</p>
<h2 id="usage-4"><a class="header" href="#usage-4">USAGE:</a></h2>
<p>forc completions [OPTIONS] --shell <SHELL></p>
<h2 id="options-4"><a class="header" href="#options-4">OPTIONS:</a></h2>
<p><code>-h</code>, <code>--help</code> </p>
<p>Print help information</p>
<p><code>-L</code>, <code>--log-level</code> &lt;<em>LOG_LEVEL</em>&gt;</p>
<p>Set the log level</p>
<p><code>-s</code>, <code>--silent</code> </p>
<p>Silence all output</p>
<p><code>-S</code>, <code>--shell</code> &lt;<em>SHELL</em>&gt;</p>
<p>Specify shell to enable tab-completion for</p>
<p>[possible values: zsh, bash, fish, powershell, elvish]</p>
<p>For more info:
https://fuellabs.github.io/sway/latest/forc/commands/forc_completions.html</p>
<p><code>-v</code>, <code>--verbose</code> </p>
<p>Use verbose output<!-- markdownlint-disable MD041 --></p>
<h2 id="discussion"><a class="header" href="#discussion">DISCUSSION</a></h2>
<p>Enable tab completion for Bash, Fish, Zsh, or PowerShell
The script is output on <code>stdout</code>, allowing one to re-direct the
output to the file of their choosing. Where you place the file
will depend on which shell, and which operating system you are
using. Your particular configuration may also determine where
these scripts need to be placed.</p>
<p>Here are some common set ups for the three supported shells under
Unix and similar operating systems (such as GNU/Linux).</p>
<h3 id="bash"><a class="header" href="#bash">BASH</a></h3>
<p>Completion files are commonly stored in <code>/etc/bash_completion.d/</code> for
system-wide commands, but can be stored in
<code>~/.local/share/bash-completion/completions</code> for user-specific commands.
Run the command:</p>
<pre><code class="language-sh">mkdir -p ~/.local/share/bash-completion/completions
forc completions --shell=bash &gt;&gt; ~/.local/share/bash-completion/completions/forc
</code></pre>
<p>This installs the completion script. You may have to log out and
log back in to your shell session for the changes to take effect.</p>
<h3 id="bash-macoshomebrew"><a class="header" href="#bash-macoshomebrew">BASH (macOS/Homebrew)</a></h3>
<p>Homebrew stores bash completion files within the Homebrew directory.
With the <code>bash-completion</code> brew formula installed, run the command:</p>
<pre><code class="language-sh">mkdir -p $(brew --prefix)/etc/bash_completion.d
forc completions --shell=bash &gt; $(brew --prefix)/etc/bash_completion.d/forc.bash-completion
</code></pre>
<h3 id="fish"><a class="header" href="#fish">FISH</a></h3>
<p>Fish completion files are commonly stored in
<code>$HOME/.config/fish/completions</code>. Run the command:</p>
<pre><code class="language-sh">mkdir -p ~/.config/fish/completions
forc completions --shell=fish &gt; ~/.config/fish/completions/forc.fish
</code></pre>
<p>This installs the completion script. You may have to log out and
log back in to your shell session for the changes to take effect.</p>
<h3 id="zsh"><a class="header" href="#zsh">ZSH</a></h3>
<p>ZSH completions are commonly stored in any directory listed in
your <code>$fpath</code> variable. To use these completions, you must either
add the generated script to one of those directories, or add your
own to this list.</p>
<p>Adding a custom directory is often the safest bet if you are
unsure of which directory to use. First create the directory; for
this example we'll create a hidden directory inside our <code>$HOME</code>
directory:</p>
<pre><code class="language-sh">mkdir ~/.zfunc
</code></pre>
<p>Then add the following lines to your <code>.zshrc</code> just before
<code>compinit</code>:</p>
<pre><code class="language-sh">fpath+=~/.zfunc
</code></pre>
<p>Now you can install the completions script using the following
command:</p>
<pre><code class="language-sh">forc completions --shell=zsh &gt; ~/.zfunc/_forc
</code></pre>
<p>You must then either log out and log back in, or simply run</p>
<pre><code class="language-sh">exec zsh
</code></pre>
<p>for the new completions to take effect.</p>
<h3 id="custom-locations"><a class="header" href="#custom-locations">CUSTOM LOCATIONS</a></h3>
<p>Alternatively, you could save these files to the place of your
choosing, such as a custom directory inside your $HOME. Doing so
will require you to add the proper directives, such as <code>source</code>ing
inside your login script. Consult your shells documentation for
how to add such directives.</p>
<h3 id="powershell"><a class="header" href="#powershell">POWERSHELL</a></h3>
<p>The powershell completion scripts require PowerShell v5.0+ (which
comes with Windows 10, but can be downloaded separately for windows 7
or 8.1).</p>
<p>First, check if a profile has already been set</p>
<pre><code class="language-sh">Test-Path $profile
</code></pre>
<p>If the above command returns <code>False</code> run the following</p>
<pre><code class="language-sh">New-Item -path $profile -type file -force
</code></pre>
<p>Now open the file provided by <code>$profile</code> (if you used the
<code>New-Item</code> command it will be
<code>${env:USERPROFILE}\Documents\WindowsPowerShell\Microsoft.PowerShell_profile.ps1</code></p>
<p>Next, we either save the completions file into our profile, or
into a separate file and source it inside our profile. To save the
completions into our profile simply use</p>
<pre><code class="language-sh">forc completions --shell=powershell &gt;&gt; ${env:USERPROFILE}\Documents\WindowsPowerShell\Microsoft.PowerShell_profile.ps1
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="forc-init"><a class="header" href="#forc-init">forc-init</a></h1>
<p>Create a new Forc project in an existing directory</p>
<h2 id="usage-5"><a class="header" href="#usage-5">USAGE:</a></h2>
<p>forc init [OPTIONS]</p>
<h2 id="options-5"><a class="header" href="#options-5">OPTIONS:</a></h2>
<p><code>--contract</code> </p>
<p>The default program type, excluding all flags or adding this flag
creates a basic contract program</p>
<p><code>-h</code>, <code>--help</code> </p>
<p>Print help information</p>
<p><code>-L</code>, <code>--log-level</code> &lt;<em>LOG_LEVEL</em>&gt;</p>
<p>Set the log level</p>
<p><code>--library</code> </p>
<p>Create a package with a library target (src/lib.sw)</p>
<p><code>--name</code> &lt;<em>NAME</em>&gt;</p>
<p>Set the package name. Defaults to the directory name</p>
<p><code>--path</code> &lt;<em>PATH</em>&gt;</p>
<p>The directory in which the forc project will be initialized</p>
<p><code>--predicate</code> </p>
<p>Create a package with a predicate target (src/predicate.rs)</p>
<p><code>-s</code>, <code>--silent</code> </p>
<p>Silence all output</p>
<p><code>--script</code> </p>
<p>Create a package with a script target (src/main.sw)</p>
<p><code>-v</code>, <code>--verbose</code> </p>
<p>Use verbose output<!-- markdownlint-disable MD041 --></p>
<h2 id="example-3"><a class="header" href="#example-3">EXAMPLE</a></h2>
<pre><code class="language-console">$ mkdir my-fuel-project
$ cd my-fuel-project
$ forc init
$ tree
.
â”œâ”€â”€ Forc.toml
â””â”€â”€ src
    â””â”€â”€ main.sw
</code></pre>
<p><code>Forc.toml</code> is the Forc manifest file, containing information about the project and dependencies.</p>
<p>A <code>src/</code> directory is created, with a single <code>main.sw</code> Sway file in it.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="forc-new"><a class="header" href="#forc-new">forc-new</a></h1>
<p>Create a new Forc project at <code>&lt;path&gt;</code></p>
<h2 id="usage-6"><a class="header" href="#usage-6">USAGE:</a></h2>
<p>forc new [OPTIONS] <PATH></p>
<h2 id="args"><a class="header" href="#args">ARGS:</a></h2>
<p>&lt;<em>PATH</em>&gt;</p>
<p>The path at which the project directory will be created</p>
<h2 id="options-6"><a class="header" href="#options-6">OPTIONS:</a></h2>
<p><code>--contract</code> </p>
<p>The default program type. Excluding all flags or adding this flag
creates a basic contract program</p>
<p><code>-h</code>, <code>--help</code> </p>
<p>Print help information</p>
<p><code>-L</code>, <code>--log-level</code> &lt;<em>LOG_LEVEL</em>&gt;</p>
<p>Set the log level</p>
<p><code>--library</code> </p>
<p>Adding this flag creates an empty library program</p>
<p><code>--name</code> &lt;<em>NAME</em>&gt;</p>
<p>Set the package name. Defaults to the directory name</p>
<p><code>--predicate</code> </p>
<p>Adding this flag creates an empty predicate program</p>
<p><code>-s</code>, <code>--silent</code> </p>
<p>Silence all output</p>
<p><code>--script</code> </p>
<p>Adding this flag creates an empty script program</p>
<p><code>-v</code>, <code>--verbose</code> </p>
<p>Use verbose output<!-- markdownlint-disable MD041 --></p>
<h2 id="example-4"><a class="header" href="#example-4">EXAMPLE</a></h2>
<pre><code class="language-console">$ forc new my-fuel-project
$ cd my-fuel-project
$ tree
.
â”œâ”€â”€ Forc.toml
â””â”€â”€ src
    â””â”€â”€ main.sw
</code></pre>
<p><code>Forc.toml</code> is the Forc manifest file, containing information about the project and dependencies.</p>
<p>A <code>src/</code> directory is created, with a single <code>main.sw</code> Sway file in it.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="forc-parse-bytecode"><a class="header" href="#forc-parse-bytecode">forc-parse-bytecode</a></h1>
<p>Parse bytecode file into a debug format</p>
<h2 id="usage-7"><a class="header" href="#usage-7">USAGE:</a></h2>
<p>forc parse-bytecode [OPTIONS] &lt;FILE_PATH&gt;</p>
<h2 id="args-1"><a class="header" href="#args-1">ARGS:</a></h2>
<p>&lt;<em>FILE_PATH</em>&gt;</p>
<h2 id="options-7"><a class="header" href="#options-7">OPTIONS:</a></h2>
<p><code>-h</code>, <code>--help</code> </p>
<p>Print help information</p>
<p><code>-L</code>, <code>--log-level</code> &lt;<em>LOG_LEVEL</em>&gt;</p>
<p>Set the log level</p>
<p><code>-s</code>, <code>--silent</code> </p>
<p>Silence all output</p>
<p><code>-v</code>, <code>--verbose</code> </p>
<p>Use verbose output<!-- markdownlint-disable MD041 --></p>
<h2 id="example-5"><a class="header" href="#example-5">EXAMPLE</a></h2>
<p>We can try this command with the initial project created using <code>forc init</code>, with the counter template:</p>
<pre><code class="language-sh">forc new --template counter counter
cd counter
forc build -o obj
</code></pre>
<pre><code class="language-console">counter$ forc parse-bytecode obj

  half-word   byte   op                   raw           notes
          0   0      JI(4)                90 00 00 04   conditionally jumps to byte 16
          1   4      NOOP                 47 00 00 00
          2   8      Undefined            00 00 00 00   data section offset lo (0)
          3   12     Undefined            00 00 00 c8   data section offset hi (200)
          4   16     LW(63, 12, 1)        5d fc c0 01
          5   20     ADD(63, 63, 12)      10 ff f3 00
         ...
         ...
         ...
         60   240    Undefined            00 00 00 00
         61   244    Undefined            fa f9 0d d3
         62   248    Undefined            00 00 00 00
         63   252    Undefined            00 00 00 c8
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="forc-plugins"><a class="header" href="#forc-plugins">forc-plugins</a></h1>
<p>Find all forc plugins available via <code>PATH</code>.</p>
<p>Prints information about each discovered plugin.</p>
<h2 id="usage-8"><a class="header" href="#usage-8">USAGE:</a></h2>
<p>forc plugins [OPTIONS]</p>
<h2 id="options-8"><a class="header" href="#options-8">OPTIONS:</a></h2>
<p><code>-d</code>, <code>--describe</code> </p>
<p>Prints the long description associated with each listed plugin</p>
<p><code>-h</code>, <code>--help</code> </p>
<p>Print help information</p>
<p><code>-L</code>, <code>--log-level</code> &lt;<em>LOG_LEVEL</em>&gt;</p>
<p>Set the log level</p>
<p><code>-p</code>, <code>--paths</code> </p>
<p>Prints the absolute path to each discovered plugin</p>
<p><code>-s</code>, <code>--silent</code> </p>
<p>Silence all output</p>
<p><code>-v</code>, <code>--verbose</code> </p>
<p>Use verbose output</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="forc-test"><a class="header" href="#forc-test">forc-test</a></h1>
<p>Run the Sway unit tests for the current project.</p>
<p>NOTE: This feature is not yet implemented. Track progress at the following link:
https://github.com/FuelLabs/sway/issues/1832</p>
<p>NOTE: Previously this command was used to support Rust integration testing, however the provided
behaviour served no benefit over running <code>cargo test</code> directly. The proposal to change the behaviour
to support unit testing can be found at the following link:
https://github.com/FuelLabs/sway/issues/1833</p>
<p>Sway unit tests are functions decorated with the <code>#[test_script]</code> attribute. Each test is compiled
as an independent <code>script</code> program and has access to the namespace of the module in which it is
declared. Unit tests declared within <code>contract</code> projects may also call directly into their
associated contract's ABI.</p>
<p>Upon successful compilation, test scripts are executed to their completion. A test is considered a
failure in the case that a revert (<code>rvrt</code>) instruction is encountered during execution. Otherwise,
it is considered a success.</p>
<h2 id="usage-9"><a class="header" href="#usage-9">USAGE:</a></h2>
<p>forc test [OPTIONS] [FILTER]</p>
<h2 id="args-2"><a class="header" href="#args-2">ARGS:</a></h2>
<p>&lt;<em>FILTER</em>&gt;
When specified, only tests containing the given string will be executed</p>
<h2 id="options-9"><a class="header" href="#options-9">OPTIONS:</a></h2>
<p><code>-h</code>, <code>--help</code> </p>
<p>Print help information</p>
<p><code>-L</code>, <code>--log-level</code> &lt;<em>LOG_LEVEL</em>&gt;</p>
<p>Set the log level</p>
<p><code>-s</code>, <code>--silent</code> </p>
<p>Silence all output</p>
<p><code>-v</code>, <code>--verbose</code> </p>
<p>Use verbose output</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="forc-update"><a class="header" href="#forc-update">forc-update</a></h1>
<p>Update dependencies in the Forc dependencies directory</p>
<h2 id="usage-10"><a class="header" href="#usage-10">USAGE:</a></h2>
<p>forc update [OPTIONS]</p>
<h2 id="options-10"><a class="header" href="#options-10">OPTIONS:</a></h2>
<p><code>-c</code>, <code>--check</code> </p>
<p>Checks if the dependencies have newer versions. Won't actually
perform the update, will output which ones are up-to-date and
outdated</p>
<p><code>-d</code> &lt;<em>TARGET_DEPENDENCY</em>&gt;</p>
<p>Dependency to be updated. If not set, all dependencies will be
updated</p>
<p><code>-h</code>, <code>--help</code> </p>
<p>Print help information</p>
<p><code>-L</code>, <code>--log-level</code> &lt;<em>LOG_LEVEL</em>&gt;</p>
<p>Set the log level</p>
<p><code>-p</code>, <code>--path</code> &lt;<em>PATH</em>&gt;</p>
<p>Path to the project, if not specified, current working directory
will be used</p>
<p><code>-s</code>, <code>--silent</code> </p>
<p>Silence all output</p>
<p><code>-v</code>, <code>--verbose</code> </p>
<p>Use verbose output</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="forc-template"><a class="header" href="#forc-template">forc-template</a></h1>
<p>Create a new Forc project from a git template</p>
<h2 id="usage-11"><a class="header" href="#usage-11">USAGE:</a></h2>
<p>forc template [OPTIONS] &lt;PROJECT_NAME&gt;</p>
<h2 id="args-3"><a class="header" href="#args-3">ARGS:</a></h2>
<p>&lt;<em>PROJECT_NAME</em>&gt;</p>
<p>The name of the project that will be created</p>
<h2 id="options-11"><a class="header" href="#options-11">OPTIONS:</a></h2>
<p><code>-h</code>, <code>--help</code> </p>
<p>Print help information</p>
<p><code>-L</code>, <code>--log-level</code> &lt;<em>LOG_LEVEL</em>&gt;</p>
<p>Set the log level</p>
<p><code>-s</code>, <code>--silent</code> </p>
<p>Silence all output</p>
<p><code>-t</code>, <code>--template-name</code> &lt;<em>TEMPLATE_NAME</em>&gt;</p>
<p>The name of the template that needs to be fetched and used from git repo provided</p>
<p><code>-u</code>, <code>--url</code> &lt;<em>URL</em>&gt;</p>
<p>The template url, should be a git repo [default: https://github.com/fuellabs/sway]</p>
<p><code>-v</code>, <code>--verbose</code> </p>
<p>Use verbose output<!-- markdownlint-disable MD041 --></p>
<h2 id="example-6"><a class="header" href="#example-6">EXAMPLE</a></h2>
<pre><code class="language-sh">forc template --url https://github.com/owner/template/ --project_name my_example_project
</code></pre>
<p>The command above fetches the <code>HEAD</code> of the <code>template</code> repo and searches for <code>Forc.toml</code> at the root of the fetched repo. It will fetch the repo and prepare a new <code>Forc.toml</code> with the new project name. Outputs everything to <code>current_dir/project_name</code>.</p>
<pre><code class="language-sh">forc template --url https://github.com/FuelLabs/sway --template_name counter --project_name my_example_project
</code></pre>
<p>The command above fetches the HEAD of the <code>sway</code> repo and searches for <code>counter</code> example inside it (there is an example called <code>counter</code> under <code>sway/examples</code>). It will fetch the <code>counter</code> example and prepare a new <code>Forc.toml</code> with the new project name. Outputs everything to <code>current_dir/project_name</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="plugins"><a class="header" href="#plugins">Plugins</a></h1>
<p>Plugins can be used to extend <code>forc</code> with new commands that go beyond the native commands mentioned in the previous chapter. While the Fuel ecosystem provides a few commonly useful plugins (<code>forc-fmt</code>, <code>forc-client</code>, <code>forc-lsp</code>, <code>forc-explore</code>), anyone can write their own!</p>
<p>Let's install a plugin, <code>forc-explore</code>, and see what's underneath the plugin:</p>
<pre><code class="language-sh">cargo install forc-explore
</code></pre>
<p>Check that we have installed <code>forc-explore</code>:</p>
<pre><code class="language-console">$ forc plugins
Installed Plugins:
forc-explore
</code></pre>
<p><code>forc-explore</code> runs the Fuel Network Explorer, which you can run and check out for yourself:</p>
<pre><code class="language-console">$ forc explore
Fuel Network Explorer 0.1.1
Running server on http://127.0.0.1:3030
Server::run{addr=127.0.0.1:3030}: listening on http://127.0.0.1:3030
</code></pre>
<p>You can visit <a href="http://127.0.0.1:3030">http://127.0.0.1:3030</a> to check out the network explorer!</p>
<p>Note that some plugin crates can also provide more than one command. For example, installing the <code>forc-client</code> plugin provides the <code>forc deploy</code> and <code>forc run</code> commands. This is achieved by specifying multiple <code>[[bin]]</code> targets within the <code>forc-client</code> manifest.</p>
<h2 id="writing-your-own-plugin"><a class="header" href="#writing-your-own-plugin">Writing your own plugin</a></h2>
<p>We encourage anyone to write and publish their own <code>forc</code> plugin to enhance their development experience.</p>
<p>Your plugin must be named in the format <code>forc-&lt;MY_PLUGIN&gt;</code> and you may use the above template as a starting point. You can use <a href="https://docs.rs/clap/latest/clap/">clap</a> and add more subcommands, options and configurations to suit your plugin's needs.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="forc-client"><a class="header" href="#forc-client">forc-client</a></h1>
<p>Forc plugin for interacting with a Fuel node.</p>
<h2 id="initializing-the-wallet-and-adding-accounts"><a class="header" href="#initializing-the-wallet-and-adding-accounts">Initializing the wallet and adding accounts</a></h2>
<p>If you don't have an initialized wallet or any account for your wallet you won't be able to sign transactions.</p>
<p>To initialize a wallet you can use <code>forc wallet init</code>. It will ask you to choose a password to encrypt your wallet. After the initialization is done you will have your mnemonic phrase.</p>
<p>After you have an initialized wallet, you can create an account for it by simply running <code>forc wallet new</code>. It will ask your password to decrypt the wallet before creating an account.</p>
<h2 id="signing-transactions-using-forc-wallet-cli"><a class="header" href="#signing-transactions-using-forc-wallet-cli">Signing transactions using <code>forc-wallet</code> CLI</a></h2>
<p>To submit the transactions created by <code>forc deploy</code> or <code>forc run</code>, you need to sign them first (unless you are using a client without UTXO validation). To sign a transaction you can use <code>forc-wallet</code> CLI. This section is going to walk you through the whole signing process.</p>
<p>By default <code>fuel-core</code> runs without UTXO validation, which means you can run unsigned transactions. This allows you to send invalid inputs to emulate different conditions.</p>
<p>If you want to run <code>fuel-core</code> with UTXO validation, you can pass <code>--utxo-validation</code> to <code>fuel-core run</code>. If UTXO validation is enabled, unsigned transactions will return an error.</p>
<p>To install <code>forc-wallet</code> please refer to <code>forc-wallet</code>'s <a href="https://github.com/FuelLabs/forc-wallet#forc-wallet">github repo</a>.</p>
<ol>
<li>Construct the transaction by using either <code>forc deploy</code> or <code>forc run</code>. To do so simply run <code>forc deploy</code> or <code>forc run</code> with your desired parameters. For a list of parameters please refer to the <a href="./forc_deploy">forc-deploy</a> or <a href="./forc_run">forc-run</a> section of the book. Once you run either command you will be asked the address of the wallet you are going to be signing with. After the address is given the transaction will be generated and you will be given a transaction ID. At this point CLI will actively wait for you to insert the signature.</li>
<li>Take the transaction ID generated in the first step and sign it with <code>forc wallet sign &lt;transaction_id&gt; &lt;account_index&gt;</code>. This will generate a signature.</li>
<li>Take the signature generated in the second step and provide it to <code>forc-deploy</code> (or <code>forc-run</code>). Once the signature is provided, the signed transaction will be submitted.</li>
</ol>
<h2 id="other-useful-commands-of-forc-wallet"><a class="header" href="#other-useful-commands-of-forc-wallet">Other useful commands of <code>forc-wallet</code></a></h2>
<ul>
<li>You can see a list of existing accounts with <code>list</code> command.</li>
</ul>
<pre><code class="language-sh">forc wallet list
</code></pre>
<ul>
<li>If you want to retrieve the address for an account by its index you can use <code>account</code> command.</li>
</ul>
<pre><code class="language-sh">forc wallet account &lt;account_index&gt;
</code></pre>
<blockquote>
<p>If you don't want to sign the transaction generated by <code>forc-deploy</code> or <code>forc-run</code> you can pass <code>--unsigned</code> to them.</p>
<pre><code class="language-sh">forc-deploy --unsigned
</code></pre>
<pre><code class="language-sh">forc-run --unsigned
</code></pre>
</blockquote>
<h2 id="interacting-with-the-testnet"><a class="header" href="#interacting-with-the-testnet">Interacting with the testnet</a></h2>
<p>While using <code>forc-deploy</code> or <code>forc-run</code> to interact with the testnet you need to pass the testnet end point with <code>--url</code></p>
<pre><code class="language-sh">forc-deploy --url https://node-beta-1.fuel.network/graphql:443
</code></pre>
<p>Since deploying and running projects on the testnet cost gas, you will need coins to pay for them. You can get some using the <a href="https://faucet-beta-1.fuel.network/">testnet faucet</a>.</p>
<p>Also the default value of the &quot;gas price&quot; parameter is 0 for both <code>forc-deploy</code> and <code>forc-run</code>. Without changing it you will get an error complaining about gas price being too low. While using testnet you can pass <code>--gas-price 1</code> to overcome this issue. So a complete command for deploying to the testnet would look like:</p>
<pre><code class="language-sh">forc-deploy --url https://node-beta-1.fuel.network/graphql:443 --gas-price 1
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="forc-deploy"><a class="header" href="#forc-deploy">forc-deploy</a></h1>
<h2 id="usage-12"><a class="header" href="#usage-12">USAGE:</a></h2>
<p>forc deploy [OPTIONS] [SIGNING_KEY]</p>
<h2 id="args-4"><a class="header" href="#args-4">ARGS:</a></h2>
<p>&lt;<em>SIGNING_KEY</em>&gt;
Set the key to be used for signing</p>
<h2 id="options-12"><a class="header" href="#options-12">OPTIONS:</a></h2>
<p><code>--build-profile</code> &lt;<em>BUILD_PROFILE</em>&gt;</p>
<p>Name of the build profile to use. If it is not specified, forc will use debug build
profile</p>
<p><code>-g</code>, <code>--debug-outfile</code> &lt;<em>DEBUG_OUTFILE</em>&gt;</p>
<p>If set, outputs source file mapping in JSON format</p>
<p><code>--gas-limit</code> &lt;<em>GAS_LIMIT</em>&gt;</p>
<p>Set the transaction gas limit. Defaults to the maximum gas limit</p>
<p><code>--gas-price</code> &lt;<em>GAS_PRICE</em>&gt;</p>
<p>Set the transaction gas price. Defaults to 0</p>
<p><code>-h</code>, <code>--help</code> </p>
<p>Print help information</p>
<p><code>--locked</code> </p>
<p>Requires that the Forc.lock file is up-to-date. If the lock file is missing, or it needs
to be updated, Forc will exit with an error</p>
<p><code>--minify-json-abi</code> </p>
<p>By default the JSON for ABIs is formatted for human readability. By using this option
JSON output will be &quot;minified&quot;, i.e. all on one line without whitespace</p>
<p><code>--minify-json-storage-slots</code> </p>
<p>By default the JSON for initial storage slots is formatted for human readability. By
using this option JSON output will be &quot;minified&quot;, i.e. all on one line without
whitespace</p>
<p><code>-o</code> &lt;<em>BINARY_OUTFILE</em>&gt;</p>
<p>If set, outputs a binary file representing the script bytes</p>
<p><code>--offline</code> </p>
<p>Offline mode, prevents Forc from using the network when managing dependencies. Meaning
it will only try to use previously downloaded dependencies</p>
<p><code>--output-directory</code> &lt;<em>OUTPUT_DIRECTORY</em>&gt;</p>
<p>The directory in which the sway compiler output artifacts are placed.</p>
<p>By default, this is <code>&lt;project-root&gt;/out</code>.</p>
<p><code>-p</code>, <code>--path</code> &lt;<em>PATH</em>&gt;</p>
<p>Path to the project, if not specified, current working directory will be used</p>
<p><code>--print-ast</code> </p>
<p>Print the generated Sway AST (Abstract Syntax Tree)</p>
<p><code>--print-finalized-asm</code> </p>
<p>Print the finalized ASM.</p>
<p>This is the state of the ASM with registers allocated and optimisations applied.</p>
<p><code>--print-intermediate-asm</code> </p>
<p>Print the generated ASM.</p>
<p>This is the state of the ASM prior to performing register allocation and other ASM
optimisations.</p>
<p><code>--print-ir</code> </p>
<p>Print the generated Sway IR (Intermediate Representation)</p>
<p><code>--release</code> </p>
<p>Use release build plan. If a custom release plan is not specified, it is implicitly
added to the manifest file.</p>
<p>If --build-profile is also provided, forc omits this flag and uses provided
build-profile.</p>
<p><code>-t</code>, <code>--terse</code> </p>
<p>Terse mode. Limited warning and error output</p>
<p><code>--time-phases</code> </p>
<p>Output the time elapsed over each part of the compilation process</p>
<p><code>-u</code>, <code>--url</code> &lt;<em>URL</em>&gt;</p>
<p>The node url to deploy, if not specified uses DEFAULT_NODE_URL. If url is specified
overrides network url in manifest file (if there is one)</p>
<p><code>--unsigned</code> </p>
<p>Do not sign the transaction</p>
<p><code>-V</code>, <code>--version</code> </p>
<p>Print version information<!-- markdownlint-disable MD041 --></p>
<h2 id="example-7"><a class="header" href="#example-7">EXAMPLE</a></h2>
<p>You can use <code>forc deploy</code>, which triggers a contract deployment transaction and sends it to a running node.</p>
<p>Alternatively, you can deploy your Sway contract programmatically using <a href="https://github.com/FuelLabs/fuels-rs">fuels-rs</a>, our Rust SDK.</p>
<p>You can find an example within our <a href="https://fuellabs.github.io/fuels-rs/latest/getting-started/basics.html#deploying-a-sway-contract">fuels-rs book</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="forc-run"><a class="header" href="#forc-run">forc-run</a></h1>
<p>Run script project. Crafts a script transaction then sends it to a running node</p>
<h2 id="usage-13"><a class="header" href="#usage-13">USAGE:</a></h2>
<p>forc run [OPTIONS] [ARGS]</p>
<h2 id="args-5"><a class="header" href="#args-5">ARGS:</a></h2>
<p>&lt;<em>NODE_URL</em>&gt;
URL of the Fuel Client Node</p>
<p>[env: FUEL_NODE_URL=]</p>
<p>&lt;<em>SIGNING_KEY</em>&gt;
Set the key to be used for signing</p>
<h2 id="options-13"><a class="header" href="#options-13">OPTIONS:</a></h2>
<p><code>--contract</code> &lt;<em>CONTRACT</em>&gt;</p>
<p>32-byte contract ID that will be called during the transaction</p>
<p><code>-d</code>, <code>--data</code> &lt;<em>DATA</em>&gt;</p>
<p>Hex string of data to input to script</p>
<p><code>--dry-run</code> </p>
<p>Only craft transaction and print it out</p>
<p><code>-g</code>, <code>--debug-outfile</code> &lt;<em>DEBUG_OUTFILE</em>&gt;</p>
<p>If set, outputs source file mapping in JSON format</p>
<p><code>--gas-limit</code> &lt;<em>GAS_LIMIT</em>&gt;</p>
<p>Set the transaction gas limit. Defaults to the maximum gas limit</p>
<p><code>--gas-price</code> &lt;<em>GAS_PRICE</em>&gt;</p>
<p>Set the transaction gas price. Defaults to 0</p>
<p><code>-h</code>, <code>--help</code> </p>
<p>Print help information</p>
<p><code>-k</code>, <code>--kill-node</code> </p>
<p>Kill Fuel Node Client after running the code. This is only available if the node is
started from <code>forc run</code></p>
<p><code>--locked</code> </p>
<p>Requires that the Forc.lock file is up-to-date. If the lock file is missing, or it needs
to be updated, Forc will exit with an error</p>
<p><code>--minify-json-abi</code> </p>
<p>By default the JSON for ABIs is formatted for human readability. By using this option
JSON output will be &quot;minified&quot;, i.e. all on one line without whitespace</p>
<p><code>--minify-json-storage-slots</code> </p>
<p>By default the JSON for initial storage slots is formatted for human readability. By
using this option JSON output will be &quot;minified&quot;, i.e. all on one line without
whitespace</p>
<p><code>-o</code> &lt;<em>BINARY_OUTFILE</em>&gt;</p>
<p>If set, outputs a binary file representing the script bytes</p>
<p><code>--output-directory</code> &lt;<em>OUTPUT_DIRECTORY</em>&gt;</p>
<p>The directory in which the sway compiler output artifacts are placed.</p>
<p>By default, this is <code>&lt;project-root&gt;/out</code>.</p>
<p><code>-p</code>, <code>--path</code> &lt;<em>PATH</em>&gt;</p>
<p>Path to the project, if not specified, current working directory will be used</p>
<p><code>--print-ast</code> </p>
<p>Print the generated Sway AST (Abstract Syntax Tree)</p>
<p><code>--print-finalized-asm</code> </p>
<p>Print the finalized ASM.</p>
<p>This is the state of the ASM with registers allocated and optimisations applied.</p>
<p><code>--print-intermediate-asm</code> </p>
<p>Print the generated ASM.</p>
<p>This is the state of the ASM prior to performing register allocation and other ASM
optimisations.</p>
<p><code>--print-ir</code> </p>
<p>Print the generated Sway IR (Intermediate Representation)</p>
<p><code>-r</code>, <code>--pretty-print</code> </p>
<p>Pretty-print the outputs from the node</p>
<p><code>--simulate</code> </p>
<p>Execute the transaction and return the final mutated transaction along with receipts
(which includes whether the transaction reverted or not). The transaction is not
inserted in the node's view of the blockchain, (i.e. it does not affect the chain state)</p>
<p><code>-t</code>, <code>--terse</code> </p>
<p>Terse mode. Limited warning and error output</p>
<p><code>--time-phases</code> </p>
<p>Output the time elapsed over each part of the compilation process</p>
<p><code>--unsigned</code> </p>
<p>Do not sign the transaction</p>
<p><code>-V</code>, <code>--version</code> </p>
<p>Print version information</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="forc-explore"><a class="header" href="#forc-explore">forc-explore</a></h1>
<p>Forc plugin for running the Fuel Block Explorer.</p>
<h2 id="usage-14"><a class="header" href="#usage-14">USAGE:</a></h2>
<p>forc-explore [OPTIONS] [SUBCOMMAND]</p>
<h2 id="options-14"><a class="header" href="#options-14">OPTIONS:</a></h2>
<p><code>-h</code>, <code>--help</code> </p>
<p>Print help information</p>
<p><code>-p</code>, <code>--port</code> &lt;<em>PORT</em>&gt;</p>
<p>The port number at which the explorer will run on localhost [default: 3030]</p>
<p><code>-V</code>, <code>--version</code> </p>
<p>Print version information</p>
<h2 id="subcommands"><a class="header" href="#subcommands">SUBCOMMANDS:</a></h2>
<p><code>clean</code></p>
<p>Cleans up any existing state associated with the fuel block explorer</p>
<p><code>help</code></p>
<p>Print this message or the help of the given subcommand(s)</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="forc-fmt"><a class="header" href="#forc-fmt">forc-fmt</a></h1>
<p>Forc plugin for running the Sway code formatter.</p>
<h2 id="usage-15"><a class="header" href="#usage-15">USAGE:</a></h2>
<p>forc-fmt [OPTIONS]</p>
<h2 id="options-15"><a class="header" href="#options-15">OPTIONS:</a></h2>
<p><code>-c</code>, <code>--check</code> </p>
<p>Run in 'check' mode.</p>
<ul>
<li>Exits with <code>0</code> if input is formatted correctly. - Exits with <code>1</code> and prints a diff if
formatting is required.</li>
</ul>
<p><code>-h</code>, <code>--help</code> </p>
<p>Print help information</p>
<p><code>-p</code>, <code>--path</code> &lt;<em>PATH</em>&gt;</p>
<p>Path to the project, if not specified, current working directory will be used</p>
<p><code>-V</code>, <code>--version</code> </p>
<p>Print version information</p>
<div style="break-before: page; page-break-before: always;"></div>
                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
    </body>
</html>
