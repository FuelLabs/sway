mod r#abstract;
mod allocated;
mod r#final;

use super::{
    register_sequencer::RegisterSequencer, AbstractInstructionSet, AllocatedAbstractInstructionSet,
    DataSection, InstructionSet,
};

use crate::asm_lang::Label;

#[derive(Clone, Copy, Debug, Eq, PartialEq)]
pub(super) enum ProgramKind {
    Script,
    Contract,
}

/// An AbstractProgram represents code generated by the compilation from IR, with virtual registers
/// and abstract control flow.
///
/// Use `AbstractProgram::to_allocated_program()` to perform register allocation.
///
pub(super) struct AbstractProgram {
    kind:         ProgramKind,
    data_section: DataSection,
    entries:      Vec<(Option<[u8; 4]>, Label, AbstractInstructionSet)>,
    non_entries:  Vec<AbstractInstructionSet>,
    reg_seqr:     RegisterSequencer,
}

/// An AllocatedProgram represents code which has allocated registers but still has abstract
/// control flow.
pub(super) struct AllocatedProgram {
    kind:         ProgramKind,
    data_section: DataSection,
    prologue:     AllocatedAbstractInstructionSet,
    functions:    Vec<AllocatedAbstractInstructionSet>,
}

/// A FinalProgram represents code which may be serialized to VM bytecode.
pub(super) struct FinalProgram {
    kind:         ProgramKind,
    data_section: DataSection,
    ops:          InstructionSet,
}
