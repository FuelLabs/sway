mod r#abstract;
mod allocated;
mod r#final;

use super::{
    register_sequencer::RegisterSequencer, AbstractInstructionSet, AllocatedAbstractInstructionSet,
    DataSection, InstructionSet,
};

use crate::asm_lang::Label;

#[derive(Clone, Copy, Debug, Eq, PartialEq)]
pub enum ProgramKind {
    Contract,
    Library,
    Predicate,
    Script,
}

/// An AbstractProgram represents code generated by the compilation from IR, with virtual registers
/// and abstract control flow.
///
/// Use `AbstractProgram::to_allocated_program()` to perform register allocation.
///
pub(super) struct AbstractProgram {
    kind: ProgramKind,
    data_section: DataSection,
    entries: Vec<AbstractEntry>,
    non_entries: Vec<AbstractInstructionSet>,
    reg_seqr: RegisterSequencer,
}

/// The entry point of an abstract program.
pub(super) struct AbstractEntry {
    pub(super) selector: Option<[u8; 4]>,
    pub(super) label: Label,
    pub(super) ops: AbstractInstructionSet,
    pub(super) name: String,
}

/// An AllocatedProgram represents code which has allocated registers but still has abstract
/// control flow.
pub(super) struct AllocatedProgram {
    kind: ProgramKind,
    data_section: DataSection,
    prologue: AllocatedAbstractInstructionSet,
    functions: Vec<AllocatedAbstractInstructionSet>,
    entries: Vec<(Label, String)>,
}

/// A FinalProgram represents code which may be serialized to VM bytecode.
pub(super) struct FinalProgram {
    kind: ProgramKind,
    data_section: DataSection,
    ops: InstructionSet,
    entries: Vec<(u64, String)>,
}
