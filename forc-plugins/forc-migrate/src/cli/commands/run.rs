use std::{
    collections::HashSet,
    path::{Path, PathBuf},
};

use anyhow::{bail, Ok, Result};
use clap::Parser;
use forc_tracing::{println_action_green, println_action_yellow, println_yellow_bold};
use forc_util::{format_diagnostic, fs_locking::is_file_dirty};
use itertools::Itertools;
use sway_ast::Module;
use sway_core::{
    language::lexed::{LexedModule, LexedProgram},
    Engines,
};
use sway_error::formatting::*;
use sway_features::Feature;
use sway_types::{SourceEngine, Span};
use swayfmt::Formatter;

use crate::{
    cli::{
        self,
        shared::{
            compile_package, create_migration_diagnostic, detailed_migration_guide_msg,
            max_feature_name_len, PROJECT_IS_COMPATIBLE,
        },
    },
    get_migration_steps_or_return, instructive_error,
    migrations::{DryRun, MigrationStep, MigrationStepKind, MigrationSteps},
};

forc_util::cli_examples! {
    crate::cli::Opt {
        [ Migrate the project in the current path => "forc migrate run"]
        [ Migrate the project located in another path => "forc migrate run --path {path}" ]
        [ Migrate the project offline without downloading any dependency => "forc migrate run --offline" ]
    }
}

/// Migrate the project.
///
/// Runs the migration steps and and guides you through the migration process.
#[derive(Debug, Parser)]
pub(crate) struct Command {
    #[clap(flatten)]
    pub run: cli::shared::Compile,
}

/// Contains information about lexed [Module]s that are modified
/// during a migration step.
struct ModifiedModules<'a> {
    source_engine: &'a SourceEngine,
    modified_modules_paths: HashSet<PathBuf>,
}

impl<'a> ModifiedModules<'a> {
    fn new(source_engine: &'a SourceEngine, occurrences_spans: &[Span]) -> Self {
        Self {
            source_engine,
            modified_modules_paths: occurrences_spans
                .iter()
                .filter_map(|span| span.source_id().copied())
                .filter(|source_id| !source_engine.is_source_id_autogenerated(source_id))
                .map(|source_id| source_engine.get_path(&source_id))
                .collect(),
        }
    }

    /// Returns the `module`s path, if the `module` was modified.
    fn get_path_if_modified(&self, module: &Module) -> Option<PathBuf> {
        module.source_id().and_then(|source_id| {
            let path = self.source_engine.get_path(&source_id);
            if self.modified_modules_paths.contains(&path) {
                Some(path)
            } else {
                None
            }
        })
    }

    /// Returns the paths of modified modules, that are at the same
    /// time marked as "dirty", means in-use by some other programs
    /// like IDEs.
    fn get_dirty_modified_modules_paths(&self) -> Vec<&PathBuf> {
        self.modified_modules_paths
            .iter()
            .filter(|path| is_file_dirty(path))
            .collect()
    }
}

pub(crate) fn exec(command: Command) -> Result<()> {
    let migration_steps = get_migration_steps_or_return!();
    let engines = Engines::default();
    let build_instructions = command.run;

    let mut program_info = compile_package(&engines, &build_instructions)?;

    // For migrations, we go with the following workflow.
    // We have three possible situations:
    //  - we skip a migration step if it doesn't have any occurrences in code.
    //    We say that the step is *checked*.
    //  - we *check* an instruction migration step if it does have occurrences in code.
    //    We print those occurrences.
    //  - we *migrate* a code transformation step if it does have changes in code.
    //    We rewrite original code files with the changed code.
    //    We print just the number of the applied transformations.
    //
    // Skipping (checked) and checking will move to the next migration step.
    //
    // Migrating will stop the further execution of migration steps **if there are manual migration actions**
    // to be done by developers. In that case, it will ask for manual action and instruct developers to review
    // the changes before continuing migration.
    //
    // Migrating **without manual migration actions** will move to the next migration step **in the same feature**.
    // If that was the last migration step in the feature, the migration will stop, and instruct the developer
    // to review the migrations done in that feature, before continuing to migrate the next experimental feature.

    print_migrating_action(migration_steps);

    let max_len = max_feature_name_len(migration_steps);
    let last_migration_feature = migration_steps
        .last()
        .expect(
            "`get_migration_steps_or_return!` guarantees that the `migration_steps` are not empty",
        )
        .0;
    let mut current_feature_migration_has_code_changes = false;
    for (feature, migration_steps) in migration_steps.iter() {
        for migration_step in migration_steps.iter() {
            match migration_step.kind {
                MigrationStepKind::Instruction(migration) => {
                    let occurrences_spans = migration(&program_info)?;
                    if occurrences_spans.is_empty() {
                        print_checked_action(max_len, feature, migration_step);
                    } else {
                        print_review_action(max_len, feature, migration_step);

                        if let Some(diagnostic) = create_migration_diagnostic(
                            engines.se(),
                            feature,
                            migration_step,
                            &occurrences_spans,
                        ) {
                            format_diagnostic(&diagnostic);
                        }

                        println_yellow_bold("If you've already reviewed the above points, you can ignore this info.");
                    }
                }
                MigrationStepKind::CodeTransformation(migration, manual_migration_actions) => {
                    let occurrences_spans = migration(&mut program_info.as_mut(), DryRun::No)?;

                    if occurrences_spans.is_empty() {
                        print_checked_action(max_len, feature, migration_step);
                    } else {
                        print_changing_code_action(max_len, feature, migration_step);

                        let modified_modules =
                            ModifiedModules::new(engines.se(), &occurrences_spans);

                        check_that_modified_modules_are_not_dirty(&modified_modules)?;

                        output_changed_lexed_program(
                            &build_instructions.manifest_dir()?,
                            &modified_modules,
                            &program_info.lexed_program,
                        )?;

                        // Print the confirmation.
                        println!(
                            "Source code successfully changed ({} change{}).",
                            occurrences_spans.len(),
                            plural_s(occurrences_spans.len())
                        );

                        // Check if we can proceed with the next migration step or break for manual action.
                        if !migration_step.has_manual_actions() {
                            // Mark the feature as having made code changes in the migration, and proceed with the
                            // next migration step *within the same feature*, if any.
                            current_feature_migration_has_code_changes = true;
                        } else {
                            // Display the manual migration actions and stop the further execution of the migration steps.
                            println!();
                            println!("You still need to manually:");
                            manual_migration_actions
                                .iter()
                                .for_each(|help| println!("- {help}"));
                            println!();
                            println!("{}", detailed_migration_guide_msg(feature));
                            print_continue_migration_action("Do the above manual changes");

                            return Ok(());
                        }
                    }
                }
            };
        }

        // If there were code changes and this is not the last feature,
        // stop for a review before continuing with the next feature.
        if current_feature_migration_has_code_changes {
            if *feature == last_migration_feature {
                print_migration_finished_action();
            } else {
                print_continue_migration_action("Review the changed code");
            }

            return Ok(());
        }
    }

    // We've run through all the migration steps.
    // Print the confirmation message, even if there were maybe infos
    // displayed for manual reviews.
    print_migration_finished_action();

    Ok(())
}

fn check_that_modified_modules_are_not_dirty(modified_modules: &ModifiedModules) -> Result<()> {
    let dirty_modules = modified_modules.get_dirty_modified_modules_paths();
    if !dirty_modules.is_empty() {
        bail!(instructive_error("Files cannot be changed, because they are open in an editor and contain unsaved changes.",
            &[
                "The below files are open in an editor and contain unsaved changes:".to_string(),
            ]
            .into_iter()
            .chain(dirty_modules.iter().map(|file| format!(" - {}", file.display())))
            .chain(vec!["Please save the open files before running the migrations.".to_string()])
            .collect::<Vec<_>>()
        ));
    }
    Ok(())
}

fn output_changed_lexed_program(
    manifest_dir: &Path,
    modified_modules: &ModifiedModules,
    lexed_program: &LexedProgram,
) -> Result<()> {
    fn output_modules_rec(
        manifest_dir: &Path,
        modified_modules: &ModifiedModules,
        lexed_module: &LexedModule,
    ) -> Result<()> {
        if let Some(path) = modified_modules.get_path_if_modified(&lexed_module.tree) {
            let mut formatter = Formatter::from_dir(manifest_dir)?;

            let code = formatter.format_module(&lexed_module.tree)?;

            std::fs::write(path, code)?;
        }

        for (_, lexed_submodule) in lexed_module.submodules.iter() {
            output_modules_rec(manifest_dir, modified_modules, &lexed_submodule.module)?;
        }

        Ok(())
    }

    output_modules_rec(manifest_dir, modified_modules, &lexed_program.root)
}

fn print_migrating_action(migration_steps: MigrationSteps) {
    println_action_green(
        "Migrating",
        &format!(
            "Breaking change feature{} {}",
            plural_s(migration_steps.len()),
            sequence_to_str(
                &migration_steps
                    .iter()
                    .map(|(feature, _)| feature.name())
                    .collect_vec(),
                Enclosing::None,
                4
            ),
        ),
    );
}

fn print_changing_code_action(max_len: usize, feature: &Feature, migration_step: &MigrationStep) {
    println_action_yellow(
        "Changing",
        &full_migration_step_title(max_len, feature, migration_step),
    );
}

fn print_checked_action(max_len: usize, feature: &Feature, migration_step: &MigrationStep) {
    println_action_green(
        "Checked",
        &full_migration_step_title(max_len, feature, migration_step),
    );
}

fn print_review_action(max_len: usize, feature: &Feature, migration_step: &MigrationStep) {
    println_action_yellow(
        "Review",
        &full_migration_step_title(max_len, feature, migration_step),
    );
}

fn print_migration_finished_action() {
    println_action_green("Finished", PROJECT_IS_COMPATIBLE);
}

fn print_continue_migration_action(txt: &str) {
    println_action_yellow(
        "Continue",
        &format!(
            "{} and re-run `forc migrate` to finish the migration process",
            txt
        ),
    );
}

/// Returns the [MigrationStep::title] prefixed by its [Feature::name].
fn full_migration_step_title(
    max_len: usize,
    feature: &Feature,
    migration_step: &MigrationStep,
) -> String {
    let feature_name_len = max_len + 2;
    format!(
        "{:<feature_name_len$}  {}",
        format!("[{}]", feature.name()),
        migration_step.title
    )
}
