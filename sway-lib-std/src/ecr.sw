//! Helper functions to verify signatures.
library;

use ::address::Address;
use ::b512::B512;
use ::registers::error;
use ::hash::*;
use ::result::Result::{*, self};

/// The error type used when the `ec_recover` function fails.
pub enum EcRecoverError {
    /// The error varient used when the recover fails.
    UnrecoverablePublicKey: (),
}

/// Recover the public key derived from the private key used to sign a message.
/// Returns a `Result` to let the caller choose an error handling strategy.
///
/// # Arguments
///
/// * `signature`: [B512] - The signature generated by signing a message hash.
/// * `msg_hash`: [b256] - The signed data.
///
/// # Returns
///
/// * [Result<B512, EcRecoverError>] - The recovered public key or an error.
///
/// # Examples
///
/// ```sway
/// use std::{erc::ec_recover, b512::B512};
///
/// fn foo() {
///     let hi = 0xbd0c9b8792876713afa8bff383eebf31c43437823ed761cc3600d0016de5110c;
///     let lo = 0x44ac566bd156b4fc71a4a4cb2655d3dd360c695edb17dc3b64d611e122fea23d;
///     let msg_hash = 0xee45573606c96c98ba970ff7cf9511f1b8b25e6bcd52ced30b89df1e4a9c4323;
///     let pub_hi = 0xD73A188181464CC84AE267E45041AEF6AB938F278E636AA1D02D3014C1BEF74E;
///     let pub_lo = 0xC44415635160ACFC87A84300EED97928C949A2D958FC0947C535F7539C59AE75;
///     let signature: B512 = B512::from((hi, lo));
///     // A recovered public key pair.
///     let public_key = ec_recover(signature, msg_hash).unwrap();
///
///     assert(public_key.bytes[0] == pub_hi);
///     assert(public_key.bytes[1] == pub_lo);
/// }
/// ```
pub fn ec_recover(signature: B512, msg_hash: b256) -> Result<B512, EcRecoverError> {
    let public_key = B512::new();
    let was_error = asm(buffer: public_key.bytes, sig: signature.bytes, hash: msg_hash) {
        eck1 buffer sig hash;
        err
    };
    // check the $err register to see if the `eck1` opcode succeeded
    if was_error == 1 {
        Err(EcRecoverError::UnrecoverablePublicKey)
    } else {
        Ok(public_key)
    }
}

/// Recover the address derived from the private key used to sign a message.
/// Returns a `Result` to let the caller choose an error handling strategy.
///
/// # Arguments
///
/// * `signature`: [B512] - The signature generated by signing a message hash.
/// * `msg_hash`: [b256] - The signed data.
///
/// # Returns
///
/// * [Result<Address, EcRecoverError>] - The recovered Fuel address or an error.
///
/// # Examples
///
/// ```sway
/// use std::{erc::ec_recover_address, b512::B512};
///
/// fn foo() {
///     let hi = 0xbd0c9b8792876713afa8bff383eebf31c43437823ed761cc3600d0016de5110c;
///     let lo = 0x44ac566bd156b4fc71a4a4cb2655d3dd360c695edb17dc3b64d611e122fea23d;
///     let msg_hash = 0xee45573606c96c98ba970ff7cf9511f1b8b25e6bcd52ced30b89df1e4a9c4323;
///     let address = Address::from(0x7AAE2D980BE4C3275C72CE5B527FA23FFB97B766966559DD062E2B78FD9D3766);
///     let signature: B512 = B512::from((hi, lo));
///     // A recovered Fuel address.
///     let result_address = ec_recover_address(signature, msg_hash).unwrap();
///     assert(result_address == address);
/// }
/// ```
pub fn ec_recover_address(signature: B512, msg_hash: b256) -> Result<Address, EcRecoverError> {
    let pub_key_result = ec_recover(signature, msg_hash);

    if let Err(e) = pub_key_result {
        // propagate the error if it exists
        Err(e)
    } else {
        let pub_key = pub_key_result.unwrap();
        let address = sha256(((pub_key.bytes)[0], (pub_key.bytes)[1]));
        Ok(Address::from(address))
    }
}
